// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Plugin type category
public enum pluginType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Sensor simulation and analysis
  case sensor = 0
  ///  Orbital propagation algorithms
  case propagator = 1
  ///  Custom rendering/visualization
  case renderer = 2
  ///  Data analysis and processing
  case analysis = 3
  ///  External data source integration
  case datasource = 4
  ///  Electronic warfare simulation
  case ew = 5
  ///  Communications modeling
  case comms = 6
  ///  Physics simulation
  case physics = 7

  public static var max: pluginType { return .physics }
  public static var min: pluginType { return .sensor }
}


///  Plugin capability declaration
public struct PluginCapability: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PLG" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PluginCapability.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case VERSION = 6
    case REQUIRED = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Capability name, e.g., "gpu_compute", "wasm_simd"
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Capability version
  public var VERSION: String? { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VERSION.v) }
  ///  Whether this capability is required
  public var REQUIRED: Bool { let o = _accessor.offset(VTOFFSET.REQUIRED.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startPluginCapability(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERSION, at: VTOFFSET.VERSION.p) }
  public static func add(REQUIRED: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REQUIRED, def: false,
   at: VTOFFSET.REQUIRED.p) }
  public static func endPluginCapability(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPluginCapability(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    VERSIONOffset VERSION: Offset = Offset(),
    REQUIRED: Bool = false
  ) -> Offset {
    let __start = PluginCapability.startPluginCapability(&fbb)
    PluginCapability.add(NAME: NAME, &fbb)
    PluginCapability.add(VERSION: VERSION, &fbb)
    PluginCapability.add(REQUIRED: REQUIRED, &fbb)
    return PluginCapability.endPluginCapability(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REQUIRED.p, fieldName: "REQUIRED", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Plugin dependency on another plugin
public struct PluginDependency: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PLG" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PluginDependency.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PLUGIN_ID = 4
    case MIN_VERSION = 6
    case MAX_VERSION = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Plugin ID of the dependency
  public var PLUGIN_ID: String? { let o = _accessor.offset(VTOFFSET.PLUGIN_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PLUGIN_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PLUGIN_ID.v) }
  ///  Minimum version required (semver)
  public var MIN_VERSION: String? { let o = _accessor.offset(VTOFFSET.MIN_VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MIN_VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MIN_VERSION.v) }
  ///  Maximum version allowed (optional)
  public var MAX_VERSION: String? { let o = _accessor.offset(VTOFFSET.MAX_VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAX_VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAX_VERSION.v) }
  public static func startPluginDependency(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(PLUGIN_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PLUGIN_ID, at: VTOFFSET.PLUGIN_ID.p) }
  public static func add(MIN_VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MIN_VERSION, at: VTOFFSET.MIN_VERSION.p) }
  public static func add(MAX_VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAX_VERSION, at: VTOFFSET.MAX_VERSION.p) }
  public static func endPluginDependency(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPluginDependency(
    _ fbb: inout FlatBufferBuilder,
    PLUGIN_IDOffset PLUGIN_ID: Offset = Offset(),
    MIN_VERSIONOffset MIN_VERSION: Offset = Offset(),
    MAX_VERSIONOffset MAX_VERSION: Offset = Offset()
  ) -> Offset {
    let __start = PluginDependency.startPluginDependency(&fbb)
    PluginDependency.add(PLUGIN_ID: PLUGIN_ID, &fbb)
    PluginDependency.add(MIN_VERSION: MIN_VERSION, &fbb)
    PluginDependency.add(MAX_VERSION: MAX_VERSION, &fbb)
    return PluginDependency.endPluginDependency(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PLUGIN_ID.p, fieldName: "PLUGIN_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MIN_VERSION.p, fieldName: "MIN_VERSION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAX_VERSION.p, fieldName: "MAX_VERSION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Plugin entry point function definition
public struct EntryFunction: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PLG" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EntryFunction.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DESCRIPTION = 6
    case INPUT_SCHEMAS = 8
    case OUTPUT_SCHEMA = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Function name as exported from WASM
  public var NAME: String! { let o = _accessor.offset(VTOFFSET.NAME.v); return _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Human-readable description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Input parameter types (FlatBuffer schema names)
  public var hasInputSchemas: Bool { let o = _accessor.offset(VTOFFSET.INPUT_SCHEMAS.v); return o == 0 ? false : true }
  public var INPUT_SCHEMASCount: Int32 { let o = _accessor.offset(VTOFFSET.INPUT_SCHEMAS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INPUT_SCHEMAS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.INPUT_SCHEMAS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Output type (FlatBuffer schema name)
  public var OUTPUT_SCHEMA: String? { let o = _accessor.offset(VTOFFSET.OUTPUT_SCHEMA.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OUTPUT_SCHEMASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OUTPUT_SCHEMA.v) }
  public static func startEntryFunction(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func addVectorOf(INPUT_SCHEMAS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INPUT_SCHEMAS, at: VTOFFSET.INPUT_SCHEMAS.p) }
  public static func add(OUTPUT_SCHEMA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTPUT_SCHEMA, at: VTOFFSET.OUTPUT_SCHEMA.p) }
  public static func endEntryFunction(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createEntryFunction(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset,
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    INPUT_SCHEMASVectorOffset INPUT_SCHEMAS: Offset = Offset(),
    OUTPUT_SCHEMAOffset OUTPUT_SCHEMA: Offset = Offset()
  ) -> Offset {
    let __start = EntryFunction.startEntryFunction(&fbb)
    EntryFunction.add(NAME: NAME, &fbb)
    EntryFunction.add(DESCRIPTION: DESCRIPTION, &fbb)
    EntryFunction.addVectorOf(INPUT_SCHEMAS: INPUT_SCHEMAS, &fbb)
    EntryFunction.add(OUTPUT_SCHEMA: OUTPUT_SCHEMA, &fbb)
    return EntryFunction.endEntryFunction(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INPUT_SCHEMAS.p, fieldName: "INPUT_SCHEMAS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OUTPUT_SCHEMA.p, fieldName: "OUTPUT_SCHEMA", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Plugin Manifest - WASM plugin distribution
public struct PLG: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PLG" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PLG.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PLUGIN_ID = 4
    case NAME = 6
    case VERSION = 8
    case DESCRIPTION = 10
    case PLUGIN_TYPE = 12
    case ABI_VERSION = 14
    case WASM_HASH = 16
    case WASM_SIZE = 18
    case WASM_CID = 20
    case ENTRY_FUNCTIONS = 22
    case REQUIRED_SCHEMAS = 24
    case DEPENDENCIES = 26
    case CAPABILITIES = 28
    case PROVIDER_PEER_ID = 30
    case PROVIDER_EPM_CID = 32
    case ENCRYPTED = 34
    case MIN_PERMISSIONS = 36
    case CREATED_AT = 38
    case UPDATED_AT = 40
    case DOCUMENTATION_URL = 42
    case ICON_URL = 44
    case LICENSE = 46
    case SIGNATURE = 48
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for the plugin
  public var PLUGIN_ID: String! { let o = _accessor.offset(VTOFFSET.PLUGIN_ID.v); return _accessor.string(at: o) }
  public var PLUGIN_IDSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.PLUGIN_ID.v) }
  ///  Human-readable plugin name
  public var NAME: String! { let o = _accessor.offset(VTOFFSET.NAME.v); return _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Plugin version (semver format)
  public var VERSION: String! { let o = _accessor.offset(VTOFFSET.VERSION.v); return _accessor.string(at: o) }
  public var VERSIONSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.VERSION.v) }
  ///  Detailed description of plugin functionality
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Type/category of the plugin
  public var PLUGIN_TYPE: pluginType { let o = _accessor.offset(VTOFFSET.PLUGIN_TYPE.v); return o == 0 ? .sensor : pluginType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .sensor }
  ///  ABI version for compatibility checking
  public var ABI_VERSION: UInt32 { let o = _accessor.offset(VTOFFSET.ABI_VERSION.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  SHA256 hash of the decrypted WASM binary
  public var hasWasmHash: Bool { let o = _accessor.offset(VTOFFSET.WASM_HASH.v); return o == 0 ? false : true }
  public var WASM_HASHCount: Int32 { let o = _accessor.offset(VTOFFSET.WASM_HASH.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func WASM_HASH(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.WASM_HASH.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var WASM_HASH: [UInt8] { return _accessor.getVector(at: VTOFFSET.WASM_HASH.v) ?? [] }
  ///  Size of WASM binary in bytes
  public var WASM_SIZE: UInt64 { let o = _accessor.offset(VTOFFSET.WASM_SIZE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  IPFS CID of the encrypted WASM binary
  public var WASM_CID: String? { let o = _accessor.offset(VTOFFSET.WASM_CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var WASM_CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.WASM_CID.v) }
  ///  Entry point functions exported by the plugin
  public var hasEntryFunctions: Bool { let o = _accessor.offset(VTOFFSET.ENTRY_FUNCTIONS.v); return o == 0 ? false : true }
  public var ENTRY_FUNCTIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.ENTRY_FUNCTIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENTRY_FUNCTIONS(at index: Int32) -> EntryFunction? { let o = _accessor.offset(VTOFFSET.ENTRY_FUNCTIONS.v); return o == 0 ? nil : EntryFunction(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  FlatBuffer schemas required by this plugin
  public var hasRequiredSchemas: Bool { let o = _accessor.offset(VTOFFSET.REQUIRED_SCHEMAS.v); return o == 0 ? false : true }
  public var REQUIRED_SCHEMASCount: Int32 { let o = _accessor.offset(VTOFFSET.REQUIRED_SCHEMAS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func REQUIRED_SCHEMAS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.REQUIRED_SCHEMAS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Other plugins this depends on
  public var hasDependencies: Bool { let o = _accessor.offset(VTOFFSET.DEPENDENCIES.v); return o == 0 ? false : true }
  public var DEPENDENCIESCount: Int32 { let o = _accessor.offset(VTOFFSET.DEPENDENCIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DEPENDENCIES(at index: Int32) -> PluginDependency? { let o = _accessor.offset(VTOFFSET.DEPENDENCIES.v); return o == 0 ? nil : PluginDependency(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Capabilities provided by this plugin
  public var hasCapabilities: Bool { let o = _accessor.offset(VTOFFSET.CAPABILITIES.v); return o == 0 ? false : true }
  public var CAPABILITIESCount: Int32 { let o = _accessor.offset(VTOFFSET.CAPABILITIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CAPABILITIES(at index: Int32) -> PluginCapability? { let o = _accessor.offset(VTOFFSET.CAPABILITIES.v); return o == 0 ? nil : PluginCapability(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Peer ID of the plugin provider
  public var PROVIDER_PEER_ID: String? { let o = _accessor.offset(VTOFFSET.PROVIDER_PEER_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PROVIDER_PEER_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PROVIDER_PEER_ID.v) }
  ///  IPFS CID of provider's EPM (Entity Profile Message)
  public var PROVIDER_EPM_CID: String? { let o = _accessor.offset(VTOFFSET.PROVIDER_EPM_CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PROVIDER_EPM_CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PROVIDER_EPM_CID.v) }
  ///  Whether the WASM binary is encrypted
  public var ENCRYPTED: Bool { let o = _accessor.offset(VTOFFSET.ENCRYPTED.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Minimum permissions required to run
  public var hasMinPermissions: Bool { let o = _accessor.offset(VTOFFSET.MIN_PERMISSIONS.v); return o == 0 ? false : true }
  public var MIN_PERMISSIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.MIN_PERMISSIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MIN_PERMISSIONS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.MIN_PERMISSIONS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Unix timestamp when plugin was created
  public var CREATED_AT: UInt64 { let o = _accessor.offset(VTOFFSET.CREATED_AT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Unix timestamp when plugin was last updated
  public var UPDATED_AT: UInt64 { let o = _accessor.offset(VTOFFSET.UPDATED_AT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  URL to plugin documentation
  public var DOCUMENTATION_URL: String? { let o = _accessor.offset(VTOFFSET.DOCUMENTATION_URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DOCUMENTATION_URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DOCUMENTATION_URL.v) }
  ///  URL to plugin icon/logo
  public var ICON_URL: String? { let o = _accessor.offset(VTOFFSET.ICON_URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ICON_URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ICON_URL.v) }
  ///  License identifier (SPDX format)
  public var LICENSE: String? { let o = _accessor.offset(VTOFFSET.LICENSE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LICENSESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LICENSE.v) }
  ///  Ed25519 signature from provider over manifest
  public var hasSignature: Bool { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? false : true }
  public var SIGNATURECount: Int32 { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SIGNATURE(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var SIGNATURE: [UInt8] { return _accessor.getVector(at: VTOFFSET.SIGNATURE.v) ?? [] }
  public static func startPLG(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 23) }
  public static func add(PLUGIN_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PLUGIN_ID, at: VTOFFSET.PLUGIN_ID.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERSION, at: VTOFFSET.VERSION.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(PLUGIN_TYPE: pluginType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PLUGIN_TYPE.rawValue, def: 0, at: VTOFFSET.PLUGIN_TYPE.p) }
  public static func add(ABI_VERSION: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ABI_VERSION, def: 1, at: VTOFFSET.ABI_VERSION.p) }
  public static func addVectorOf(WASM_HASH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WASM_HASH, at: VTOFFSET.WASM_HASH.p) }
  public static func add(WASM_SIZE: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WASM_SIZE, def: 0, at: VTOFFSET.WASM_SIZE.p) }
  public static func add(WASM_CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WASM_CID, at: VTOFFSET.WASM_CID.p) }
  public static func addVectorOf(ENTRY_FUNCTIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENTRY_FUNCTIONS, at: VTOFFSET.ENTRY_FUNCTIONS.p) }
  public static func addVectorOf(REQUIRED_SCHEMAS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REQUIRED_SCHEMAS, at: VTOFFSET.REQUIRED_SCHEMAS.p) }
  public static func addVectorOf(DEPENDENCIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEPENDENCIES, at: VTOFFSET.DEPENDENCIES.p) }
  public static func addVectorOf(CAPABILITIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CAPABILITIES, at: VTOFFSET.CAPABILITIES.p) }
  public static func add(PROVIDER_PEER_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROVIDER_PEER_ID, at: VTOFFSET.PROVIDER_PEER_ID.p) }
  public static func add(PROVIDER_EPM_CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROVIDER_EPM_CID, at: VTOFFSET.PROVIDER_EPM_CID.p) }
  public static func add(ENCRYPTED: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENCRYPTED, def: true,
   at: VTOFFSET.ENCRYPTED.p) }
  public static func addVectorOf(MIN_PERMISSIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MIN_PERMISSIONS, at: VTOFFSET.MIN_PERMISSIONS.p) }
  public static func add(CREATED_AT: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CREATED_AT, def: 0, at: VTOFFSET.CREATED_AT.p) }
  public static func add(UPDATED_AT: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: UPDATED_AT, def: 0, at: VTOFFSET.UPDATED_AT.p) }
  public static func add(DOCUMENTATION_URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DOCUMENTATION_URL, at: VTOFFSET.DOCUMENTATION_URL.p) }
  public static func add(ICON_URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ICON_URL, at: VTOFFSET.ICON_URL.p) }
  public static func add(LICENSE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LICENSE, at: VTOFFSET.LICENSE.p) }
  public static func addVectorOf(SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIGNATURE, at: VTOFFSET.SIGNATURE.p) }
  public static func endPLG(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8]); return end }
  public static func createPLG(
    _ fbb: inout FlatBufferBuilder,
    PLUGIN_IDOffset PLUGIN_ID: Offset,
    NAMEOffset NAME: Offset,
    VERSIONOffset VERSION: Offset,
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    PLUGIN_TYPE: pluginType = .sensor,
    ABI_VERSION: UInt32 = 1,
    WASM_HASHVectorOffset WASM_HASH: Offset = Offset(),
    WASM_SIZE: UInt64 = 0,
    WASM_CIDOffset WASM_CID: Offset = Offset(),
    ENTRY_FUNCTIONSVectorOffset ENTRY_FUNCTIONS: Offset = Offset(),
    REQUIRED_SCHEMASVectorOffset REQUIRED_SCHEMAS: Offset = Offset(),
    DEPENDENCIESVectorOffset DEPENDENCIES: Offset = Offset(),
    CAPABILITIESVectorOffset CAPABILITIES: Offset = Offset(),
    PROVIDER_PEER_IDOffset PROVIDER_PEER_ID: Offset = Offset(),
    PROVIDER_EPM_CIDOffset PROVIDER_EPM_CID: Offset = Offset(),
    ENCRYPTED: Bool = true,
    MIN_PERMISSIONSVectorOffset MIN_PERMISSIONS: Offset = Offset(),
    CREATED_AT: UInt64 = 0,
    UPDATED_AT: UInt64 = 0,
    DOCUMENTATION_URLOffset DOCUMENTATION_URL: Offset = Offset(),
    ICON_URLOffset ICON_URL: Offset = Offset(),
    LICENSEOffset LICENSE: Offset = Offset(),
    SIGNATUREVectorOffset SIGNATURE: Offset = Offset()
  ) -> Offset {
    let __start = PLG.startPLG(&fbb)
    PLG.add(PLUGIN_ID: PLUGIN_ID, &fbb)
    PLG.add(NAME: NAME, &fbb)
    PLG.add(VERSION: VERSION, &fbb)
    PLG.add(DESCRIPTION: DESCRIPTION, &fbb)
    PLG.add(PLUGIN_TYPE: PLUGIN_TYPE, &fbb)
    PLG.add(ABI_VERSION: ABI_VERSION, &fbb)
    PLG.addVectorOf(WASM_HASH: WASM_HASH, &fbb)
    PLG.add(WASM_SIZE: WASM_SIZE, &fbb)
    PLG.add(WASM_CID: WASM_CID, &fbb)
    PLG.addVectorOf(ENTRY_FUNCTIONS: ENTRY_FUNCTIONS, &fbb)
    PLG.addVectorOf(REQUIRED_SCHEMAS: REQUIRED_SCHEMAS, &fbb)
    PLG.addVectorOf(DEPENDENCIES: DEPENDENCIES, &fbb)
    PLG.addVectorOf(CAPABILITIES: CAPABILITIES, &fbb)
    PLG.add(PROVIDER_PEER_ID: PROVIDER_PEER_ID, &fbb)
    PLG.add(PROVIDER_EPM_CID: PROVIDER_EPM_CID, &fbb)
    PLG.add(ENCRYPTED: ENCRYPTED, &fbb)
    PLG.addVectorOf(MIN_PERMISSIONS: MIN_PERMISSIONS, &fbb)
    PLG.add(CREATED_AT: CREATED_AT, &fbb)
    PLG.add(UPDATED_AT: UPDATED_AT, &fbb)
    PLG.add(DOCUMENTATION_URL: DOCUMENTATION_URL, &fbb)
    PLG.add(ICON_URL: ICON_URL, &fbb)
    PLG.add(LICENSE: LICENSE, &fbb)
    PLG.addVectorOf(SIGNATURE: SIGNATURE, &fbb)
    return PLG.endPLG(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PLUGIN_ID.p, fieldName: "PLUGIN_ID", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PLUGIN_TYPE.p, fieldName: "PLUGIN_TYPE", required: false, type: pluginType.self)
    try _v.visit(field: VTOFFSET.ABI_VERSION.p, fieldName: "ABI_VERSION", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.WASM_HASH.p, fieldName: "WASM_HASH", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.WASM_SIZE.p, fieldName: "WASM_SIZE", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.WASM_CID.p, fieldName: "WASM_CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENTRY_FUNCTIONS.p, fieldName: "ENTRY_FUNCTIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<EntryFunction>, EntryFunction>>.self)
    try _v.visit(field: VTOFFSET.REQUIRED_SCHEMAS.p, fieldName: "REQUIRED_SCHEMAS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.DEPENDENCIES.p, fieldName: "DEPENDENCIES", required: false, type: ForwardOffset<Vector<ForwardOffset<PluginDependency>, PluginDependency>>.self)
    try _v.visit(field: VTOFFSET.CAPABILITIES.p, fieldName: "CAPABILITIES", required: false, type: ForwardOffset<Vector<ForwardOffset<PluginCapability>, PluginCapability>>.self)
    try _v.visit(field: VTOFFSET.PROVIDER_PEER_ID.p, fieldName: "PROVIDER_PEER_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROVIDER_EPM_CID.p, fieldName: "PROVIDER_EPM_CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENCRYPTED.p, fieldName: "ENCRYPTED", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.MIN_PERMISSIONS.p, fieldName: "MIN_PERMISSIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.CREATED_AT.p, fieldName: "CREATED_AT", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.UPDATED_AT.p, fieldName: "UPDATED_AT", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.DOCUMENTATION_URL.p, fieldName: "DOCUMENTATION_URL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ICON_URL.p, fieldName: "ICON_URL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LICENSE.p, fieldName: "LICENSE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIGNATURE.p, fieldName: "SIGNATURE", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

