// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum ScoreType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case outlier = 0

  public static var max: ScoreType { return .outlier }
  public static var min: ScoreType { return .outlier }
}


public struct Score: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$HYP" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Score.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NORAD_CAT_ID = 4
    case TYPE = 6
    case TAG = 8
    case SCORE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var NORAD_CAT_ID: String? { let o = _accessor.offset(VTOFFSET.NORAD_CAT_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NORAD_CAT_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NORAD_CAT_ID.v) }
  public var TYPE: ScoreType { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? .outlier : ScoreType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .outlier }
  public var TAG: String? { let o = _accessor.offset(VTOFFSET.TAG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TAGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TAG.v) }
  public var SCORE: Float32 { let o = _accessor.offset(VTOFFSET.SCORE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public static func startScore(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NORAD_CAT_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NORAD_CAT_ID, at: VTOFFSET.NORAD_CAT_ID.p) }
  public static func add(TYPE: ScoreType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TYPE.rawValue, def: 0, at: VTOFFSET.TYPE.p) }
  public static func add(TAG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TAG, at: VTOFFSET.TAG.p) }
  public static func add(SCORE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCORE, def: 0.0, at: VTOFFSET.SCORE.p) }
  public static func endScore(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createScore(
    _ fbb: inout FlatBufferBuilder,
    NORAD_CAT_IDOffset NORAD_CAT_ID: Offset = Offset(),
    TYPE: ScoreType = .outlier,
    TAGOffset TAG: Offset = Offset(),
    SCORE: Float32 = 0.0
  ) -> Offset {
    let __start = Score.startScore(&fbb)
    Score.add(NORAD_CAT_ID: NORAD_CAT_ID, &fbb)
    Score.add(TYPE: TYPE, &fbb)
    Score.add(TAG: TAG, &fbb)
    Score.add(SCORE: SCORE, &fbb)
    return Score.endScore(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NORAD_CAT_ID.p, fieldName: "NORAD_CAT_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ScoreType.self)
    try _v.visit(field: VTOFFSET.TAG.p, fieldName: "TAG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SCORE.p, fieldName: "SCORE", required: false, type: Float32.self)
    _v.finish()
  }
}

///  Hypothesis Message
public struct HYP: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$HYP" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: HYP.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CAT_IDS = 4
    case SIT_IDS = 6
    case NAME = 8
    case CATEGORY = 10
    case ROW_INDICATORS = 12
    case COL_INDICATORS = 14
    case MATRIX = 16
    case SCORE = 18
    case ANALYSIS_METHOD = 20
    case EVENT_START_TIME = 22
    case EVENT_END_TIME = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Space Objects Involved
  public var hasCatIds: Bool { let o = _accessor.offset(VTOFFSET.CAT_IDS.v); return o == 0 ? false : true }
  public var CAT_IDSCount: Int32 { let o = _accessor.offset(VTOFFSET.CAT_IDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CAT_IDS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.CAT_IDS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Space Objects Involved
  public var hasSitIds: Bool { let o = _accessor.offset(VTOFFSET.SIT_IDS.v); return o == 0 ? false : true }
  public var SIT_IDSCount: Int32 { let o = _accessor.offset(VTOFFSET.SIT_IDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SIT_IDS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.SIT_IDS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Name of the hypothesis
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Category of the hypothesis
  public var CATEGORY: String? { let o = _accessor.offset(VTOFFSET.CATEGORY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CATEGORYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CATEGORY.v) }
  ///  Row indicators for the hypothesis matrix
  public var hasRowIndicators: Bool { let o = _accessor.offset(VTOFFSET.ROW_INDICATORS.v); return o == 0 ? false : true }
  public var ROW_INDICATORSCount: Int32 { let o = _accessor.offset(VTOFFSET.ROW_INDICATORS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ROW_INDICATORS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ROW_INDICATORS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Column indicators for the hypothesis matrix
  public var hasColIndicators: Bool { let o = _accessor.offset(VTOFFSET.COL_INDICATORS.v); return o == 0 ? false : true }
  public var COL_INDICATORSCount: Int32 { let o = _accessor.offset(VTOFFSET.COL_INDICATORS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COL_INDICATORS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COL_INDICATORS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Matrix data as a boolean array in row major format; if overflow, adds additional rows
  public var hasMatrix: Bool { let o = _accessor.offset(VTOFFSET.MATRIX.v); return o == 0 ? false : true }
  public var MATRIXCount: Int32 { let o = _accessor.offset(VTOFFSET.MATRIX.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MATRIX(at index: Int32) -> Bool { let o = _accessor.offset(VTOFFSET.MATRIX.v); return o == 0 ? true : _accessor.directRead(of: Bool.self, offset: _accessor.vector(at: o) + index * 1) }
  public var MATRIX: [Bool] { return _accessor.getVector(at: VTOFFSET.MATRIX.v) ?? [] }
  ///  Scores for objects
  public var hasScore: Bool { let o = _accessor.offset(VTOFFSET.SCORE.v); return o == 0 ? false : true }
  public var SCORECount: Int32 { let o = _accessor.offset(VTOFFSET.SCORE.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SCORE(at index: Int32) -> Score? { let o = _accessor.offset(VTOFFSET.SCORE.v); return o == 0 ? nil : Score(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Analysis methodology used to form the hypothesis
  public var ANALYSIS_METHOD: String? { let o = _accessor.offset(VTOFFSET.ANALYSIS_METHOD.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ANALYSIS_METHODSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ANALYSIS_METHOD.v) }
  public var EVENT_START_TIME: String? { let o = _accessor.offset(VTOFFSET.EVENT_START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EVENT_START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EVENT_START_TIME.v) }
  public var EVENT_END_TIME: String? { let o = _accessor.offset(VTOFFSET.EVENT_END_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EVENT_END_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EVENT_END_TIME.v) }
  public static func startHYP(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func addVectorOf(CAT_IDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CAT_IDS, at: VTOFFSET.CAT_IDS.p) }
  public static func addVectorOf(SIT_IDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIT_IDS, at: VTOFFSET.SIT_IDS.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(CATEGORY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CATEGORY, at: VTOFFSET.CATEGORY.p) }
  public static func addVectorOf(ROW_INDICATORS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ROW_INDICATORS, at: VTOFFSET.ROW_INDICATORS.p) }
  public static func addVectorOf(COL_INDICATORS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COL_INDICATORS, at: VTOFFSET.COL_INDICATORS.p) }
  public static func addVectorOf(MATRIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATRIX, at: VTOFFSET.MATRIX.p) }
  public static func addVectorOf(SCORE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SCORE, at: VTOFFSET.SCORE.p) }
  public static func add(ANALYSIS_METHOD: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ANALYSIS_METHOD, at: VTOFFSET.ANALYSIS_METHOD.p) }
  public static func add(EVENT_START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EVENT_START_TIME, at: VTOFFSET.EVENT_START_TIME.p) }
  public static func add(EVENT_END_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EVENT_END_TIME, at: VTOFFSET.EVENT_END_TIME.p) }
  public static func endHYP(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createHYP(
    _ fbb: inout FlatBufferBuilder,
    CAT_IDSVectorOffset CAT_IDS: Offset = Offset(),
    SIT_IDSVectorOffset SIT_IDS: Offset = Offset(),
    NAMEOffset NAME: Offset = Offset(),
    CATEGORYOffset CATEGORY: Offset = Offset(),
    ROW_INDICATORSVectorOffset ROW_INDICATORS: Offset = Offset(),
    COL_INDICATORSVectorOffset COL_INDICATORS: Offset = Offset(),
    MATRIXVectorOffset MATRIX: Offset = Offset(),
    SCOREVectorOffset SCORE: Offset = Offset(),
    ANALYSIS_METHODOffset ANALYSIS_METHOD: Offset = Offset(),
    EVENT_START_TIMEOffset EVENT_START_TIME: Offset = Offset(),
    EVENT_END_TIMEOffset EVENT_END_TIME: Offset = Offset()
  ) -> Offset {
    let __start = HYP.startHYP(&fbb)
    HYP.addVectorOf(CAT_IDS: CAT_IDS, &fbb)
    HYP.addVectorOf(SIT_IDS: SIT_IDS, &fbb)
    HYP.add(NAME: NAME, &fbb)
    HYP.add(CATEGORY: CATEGORY, &fbb)
    HYP.addVectorOf(ROW_INDICATORS: ROW_INDICATORS, &fbb)
    HYP.addVectorOf(COL_INDICATORS: COL_INDICATORS, &fbb)
    HYP.addVectorOf(MATRIX: MATRIX, &fbb)
    HYP.addVectorOf(SCORE: SCORE, &fbb)
    HYP.add(ANALYSIS_METHOD: ANALYSIS_METHOD, &fbb)
    HYP.add(EVENT_START_TIME: EVENT_START_TIME, &fbb)
    HYP.add(EVENT_END_TIME: EVENT_END_TIME, &fbb)
    return HYP.endHYP(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CAT_IDS.p, fieldName: "CAT_IDS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.SIT_IDS.p, fieldName: "SIT_IDS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CATEGORY.p, fieldName: "CATEGORY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ROW_INDICATORS.p, fieldName: "ROW_INDICATORS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.COL_INDICATORS.p, fieldName: "COL_INDICATORS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.MATRIX.p, fieldName: "MATRIX", required: false, type: ForwardOffset<Vector<Bool, Bool>>.self)
    try _v.visit(field: VTOFFSET.SCORE.p, fieldName: "SCORE", required: false, type: ForwardOffset<Vector<ForwardOffset<Score>, Score>>.self)
    try _v.visit(field: VTOFFSET.ANALYSIS_METHOD.p, fieldName: "ANALYSIS_METHOD", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EVENT_START_TIME.p, fieldName: "EVENT_START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EVENT_END_TIME.p, fieldName: "EVENT_END_TIME", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

