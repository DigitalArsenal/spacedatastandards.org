// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Comparison operators for match criteria and conditions
public enum ComparisonOperator: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Equal to
  case eq = 0
  ///  Not equal to
  case ne = 1
  ///  Greater than
  case gt = 2
  ///  Less than
  case lt = 3
  ///  Greater than or equal to
  case ge = 4
  ///  Less than or equal to
  case le = 5
  ///  String starts with
  case startsWith = 6
  ///  String ends with
  case endsWith = 7
  ///  String contains
  case contains = 8
  ///  String does not start with
  case notStartsWith = 9
  ///  String does not end with
  case notEndsWith = 10
  ///  String does not contain
  case notContains = 11

  public static var max: ComparisonOperator { return .notContains }
  public static var min: ComparisonOperator { return .eq }
}


///  Data source types for telemetry parameters
public enum DataSourceType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Data received from spacecraft telemetry
  case telemetered = 0
  ///  Computed from other parameters
  case derived = 1
  ///  Fixed constant value
  case constant = 2
  ///  Local ground system value
  case local = 3
  ///  Ground-generated data
  case ground = 4

  public static var max: DataSourceType { return .ground }
  public static var min: DataSourceType { return .telemetered }
}


///  Boolean operators for combining conditions
public enum BooleanOperatorType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Logical AND
  case and = 0
  ///  Logical OR
  case or = 1
  ///  Logical XOR
  case xor = 2

  public static var max: BooleanOperatorType { return .xor }
  public static var min: BooleanOperatorType { return .and }
}


///  Reference location for positioning within containers
public enum ReferenceLocationType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Start of the container
  case containerStart = 0
  ///  End of the container
  case containerEnd = 1
  ///  End of previous entry
  case previousEntry = 2
  ///  Start of next entry
  case nextEntry = 3

  public static var max: ReferenceLocationType { return .nextEntry }
  public static var min: ReferenceLocationType { return .containerStart }
}


///  Rate basis for stream rate specifications
public enum RateBasisType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Rate per second
  case perSecond = 0
  ///  Rate per container occurrence
  case perContainer = 1

  public static var max: RateBasisType { return .perContainer }
  public static var min: RateBasisType { return .perSecond }
}


///  Byte ordering for data encoding
public enum ByteOrderType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Most significant byte first
  case bigEndian = 0
  ///  Least significant byte first
  case littleEndian = 1

  public static var max: ByteOrderType { return .littleEndian }
  public static var min: ByteOrderType { return .bigEndian }
}


///  Integer encoding types
public enum IntegerEncodingType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Unsigned binary
  case unsigned = 0
  ///  Two's complement signed
  case twosComplement = 1
  ///  Sign-magnitude representation
  case signMagnitude = 2
  ///  Ones' complement signed
  case onesComplement = 3
  ///  Binary Coded Decimal
  case bcd = 4
  ///  Packed BCD
  case packedBcd = 5

  public static var max: IntegerEncodingType { return .packedBcd }
  public static var min: IntegerEncodingType { return .unsigned }
}


///  Float encoding formats
public enum FloatEncodingType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  IEEE 754-1985 single precision (32-bit)
  case ieee7541985 = 0
  ///  MIL-STD-1750A format
  case milstd1750a = 1
  ///  DEC PDP format
  case dec = 2
  ///  IBM System/360 format
  case ibm = 3
  ///  Texas Instruments TI format
  case ti = 4

  public static var max: FloatEncodingType { return .ti }
  public static var min: FloatEncodingType { return .ieee7541985 }
}


///  String encoding character sets
public enum StringEncodingType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  US-ASCII (7-bit)
  case usAscii = 0
  ///  ISO 8859-1 Latin-1
  case iso88591 = 1
  ///  Windows-1252
  case windows1252 = 2
  ///  UTF-8
  case utf8 = 3
  ///  UTF-16
  case utf16 = 4
  ///  UTF-16 Big Endian
  case utf16be = 5
  ///  UTF-16 Little Endian
  case utf16le = 6

  public static var max: StringEncodingType { return .utf16le }
  public static var min: StringEncodingType { return .usAscii }
}


///  String size specification type
public enum StringSizeType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Fixed length string
  case fixed = 0
  ///  Variable with leading count
  case leadingSize = 1
  ///  Variable with termination character
  case terminationChar = 2

  public static var max: StringSizeType { return .terminationChar }
  public static var min: StringSizeType { return .fixed }
}


///  Alarm severity levels
public enum AlarmSeverityType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Normal operation
  case normal = 0
  ///  Watch level - early warning
  case watch = 1
  ///  Warning level
  case warning = 2
  ///  Distress level - significant issue
  case distress = 3
  ///  Critical level - immediate action required
  case critical = 4
  ///  Severe level - system failure
  case severe = 5

  public static var max: AlarmSeverityType { return .severe }
  public static var min: AlarmSeverityType { return .normal }
}


///  Verifier type for command verification
public enum VerifierType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Execution started
  case start = 0
  ///  Progress update
  case progress = 1
  ///  Execution complete
  case complete = 2
  ///  Command failed
  case failed = 3

  public static var max: VerifierType { return .failed }
  public static var min: VerifierType { return .start }
}


///  Time window reference for command verification
public enum TimeWindowRefType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Relative to command release time
  case commandRelease = 0
  ///  Relative to last verifier passed
  case timeLastVerifierPassed = 1

  public static var max: TimeWindowRefType { return .timeLastVerifierPassed }
  public static var min: TimeWindowRefType { return .commandRelease }
}


///  Epoch reference for absolute time
public enum EpochType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  TAI epoch (1958-01-01)
  case tai = 0
  ///  J2000 epoch (2000-01-01 12:00:00 TT)
  case j2000 = 1
  ///  Unix epoch (1970-01-01)
  case unix = 2
  ///  GPS epoch (1980-01-06)
  case gps = 3
  ///  Custom epoch specified in offset
  case custom = 4

  public static var max: EpochType { return .custom }
  public static var min: EpochType { return .tai }
}


///  Error detection/correction algorithms
public enum ErrorDetectionType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  No error detection
  case none_ = 0
  ///  Cyclic redundancy check
  case crc = 1
  ///  Checksum
  case checksum = 2
  ///  Parity
  case parity = 3

  public static var max: ErrorDetectionType { return .parity }
  public static var min: ErrorDetectionType { return .none_ }
}


///  Integer data encoding specification
public struct IntegerDataEncoding: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: IntegerDataEncoding.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SIZE_IN_BITS = 4
    case BYTE_ORDER = 6
    case ENCODING = 8
    case DEFAULT_CALIBRATOR = 10
    case CONTEXT_CALIBRATOR_LIST = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Number of bits for this integer
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Byte ordering
  public var BYTE_ORDER: ByteOrderType { let o = _accessor.offset(VTOFFSET.BYTE_ORDER.v); return o == 0 ? .bigEndian : ByteOrderType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .bigEndian }
  ///  Integer encoding type
  public var ENCODING: IntegerEncodingType { let o = _accessor.offset(VTOFFSET.ENCODING.v); return o == 0 ? .unsigned : IntegerEncodingType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unsigned }
  ///  Default calibrator reference
  public var DEFAULT_CALIBRATOR: String? { let o = _accessor.offset(VTOFFSET.DEFAULT_CALIBRATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DEFAULT_CALIBRATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DEFAULT_CALIBRATOR.v) }
  ///  Context-dependent calibrators
  public var hasContextCalibratorList: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? false : true }
  public var CONTEXT_CALIBRATOR_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_CALIBRATOR_LIST(at index: Int32) -> ContextCalibrator? { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? nil : ContextCalibrator(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startIntegerDataEncoding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(BYTE_ORDER: ByteOrderType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BYTE_ORDER.rawValue, def: 0, at: VTOFFSET.BYTE_ORDER.p) }
  public static func add(ENCODING: IntegerEncodingType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENCODING.rawValue, def: 0, at: VTOFFSET.ENCODING.p) }
  public static func add(DEFAULT_CALIBRATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_CALIBRATOR, at: VTOFFSET.DEFAULT_CALIBRATOR.p) }
  public static func addVectorOf(CONTEXT_CALIBRATOR_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_CALIBRATOR_LIST, at: VTOFFSET.CONTEXT_CALIBRATOR_LIST.p) }
  public static func endIntegerDataEncoding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createIntegerDataEncoding(
    _ fbb: inout FlatBufferBuilder,
    SIZE_IN_BITS: UInt16 = 0,
    BYTE_ORDER: ByteOrderType = .bigEndian,
    ENCODING: IntegerEncodingType = .unsigned,
    DEFAULT_CALIBRATOROffset DEFAULT_CALIBRATOR: Offset = Offset(),
    CONTEXT_CALIBRATOR_LISTVectorOffset CONTEXT_CALIBRATOR_LIST: Offset = Offset()
  ) -> Offset {
    let __start = IntegerDataEncoding.startIntegerDataEncoding(&fbb)
    IntegerDataEncoding.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    IntegerDataEncoding.add(BYTE_ORDER: BYTE_ORDER, &fbb)
    IntegerDataEncoding.add(ENCODING: ENCODING, &fbb)
    IntegerDataEncoding.add(DEFAULT_CALIBRATOR: DEFAULT_CALIBRATOR, &fbb)
    IntegerDataEncoding.addVectorOf(CONTEXT_CALIBRATOR_LIST: CONTEXT_CALIBRATOR_LIST, &fbb)
    return IntegerDataEncoding.endIntegerDataEncoding(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.BYTE_ORDER.p, fieldName: "BYTE_ORDER", required: false, type: ByteOrderType.self)
    try _v.visit(field: VTOFFSET.ENCODING.p, fieldName: "ENCODING", required: false, type: IntegerEncodingType.self)
    try _v.visit(field: VTOFFSET.DEFAULT_CALIBRATOR.p, fieldName: "DEFAULT_CALIBRATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_CALIBRATOR_LIST.p, fieldName: "CONTEXT_CALIBRATOR_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextCalibrator>, ContextCalibrator>>.self)
    _v.finish()
  }
}

///  Float data encoding specification
public struct FloatDataEncoding: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FloatDataEncoding.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SIZE_IN_BITS = 4
    case BYTE_ORDER = 6
    case ENCODING = 8
    case DEFAULT_CALIBRATOR = 10
    case CONTEXT_CALIBRATOR_LIST = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Number of bits (typically 32 or 64)
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Byte ordering
  public var BYTE_ORDER: ByteOrderType { let o = _accessor.offset(VTOFFSET.BYTE_ORDER.v); return o == 0 ? .bigEndian : ByteOrderType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .bigEndian }
  ///  Float encoding format
  public var ENCODING: FloatEncodingType { let o = _accessor.offset(VTOFFSET.ENCODING.v); return o == 0 ? .ieee7541985 : FloatEncodingType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ieee7541985 }
  ///  Default calibrator reference
  public var DEFAULT_CALIBRATOR: String? { let o = _accessor.offset(VTOFFSET.DEFAULT_CALIBRATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DEFAULT_CALIBRATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DEFAULT_CALIBRATOR.v) }
  ///  Context-dependent calibrators
  public var hasContextCalibratorList: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? false : true }
  public var CONTEXT_CALIBRATOR_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_CALIBRATOR_LIST(at index: Int32) -> ContextCalibrator? { let o = _accessor.offset(VTOFFSET.CONTEXT_CALIBRATOR_LIST.v); return o == 0 ? nil : ContextCalibrator(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startFloatDataEncoding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(BYTE_ORDER: ByteOrderType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BYTE_ORDER.rawValue, def: 0, at: VTOFFSET.BYTE_ORDER.p) }
  public static func add(ENCODING: FloatEncodingType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENCODING.rawValue, def: 0, at: VTOFFSET.ENCODING.p) }
  public static func add(DEFAULT_CALIBRATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_CALIBRATOR, at: VTOFFSET.DEFAULT_CALIBRATOR.p) }
  public static func addVectorOf(CONTEXT_CALIBRATOR_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_CALIBRATOR_LIST, at: VTOFFSET.CONTEXT_CALIBRATOR_LIST.p) }
  public static func endFloatDataEncoding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFloatDataEncoding(
    _ fbb: inout FlatBufferBuilder,
    SIZE_IN_BITS: UInt16 = 0,
    BYTE_ORDER: ByteOrderType = .bigEndian,
    ENCODING: FloatEncodingType = .ieee7541985,
    DEFAULT_CALIBRATOROffset DEFAULT_CALIBRATOR: Offset = Offset(),
    CONTEXT_CALIBRATOR_LISTVectorOffset CONTEXT_CALIBRATOR_LIST: Offset = Offset()
  ) -> Offset {
    let __start = FloatDataEncoding.startFloatDataEncoding(&fbb)
    FloatDataEncoding.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    FloatDataEncoding.add(BYTE_ORDER: BYTE_ORDER, &fbb)
    FloatDataEncoding.add(ENCODING: ENCODING, &fbb)
    FloatDataEncoding.add(DEFAULT_CALIBRATOR: DEFAULT_CALIBRATOR, &fbb)
    FloatDataEncoding.addVectorOf(CONTEXT_CALIBRATOR_LIST: CONTEXT_CALIBRATOR_LIST, &fbb)
    return FloatDataEncoding.endFloatDataEncoding(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.BYTE_ORDER.p, fieldName: "BYTE_ORDER", required: false, type: ByteOrderType.self)
    try _v.visit(field: VTOFFSET.ENCODING.p, fieldName: "ENCODING", required: false, type: FloatEncodingType.self)
    try _v.visit(field: VTOFFSET.DEFAULT_CALIBRATOR.p, fieldName: "DEFAULT_CALIBRATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_CALIBRATOR_LIST.p, fieldName: "CONTEXT_CALIBRATOR_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextCalibrator>, ContextCalibrator>>.self)
    _v.finish()
  }
}

///  String data encoding specification
public struct StringDataEncoding: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StringDataEncoding.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ENCODING = 4
    case SIZE_TYPE = 6
    case SIZE_IN_BITS = 8
    case TERMINATION_CHAR = 10
    case MAX_SIZE_IN_BITS = 12
    case LEADING_SIZE_BITS = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Character encoding
  public var ENCODING: StringEncodingType { let o = _accessor.offset(VTOFFSET.ENCODING.v); return o == 0 ? .utf8 : StringEncodingType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .utf8 }
  ///  Size type specification
  public var SIZE_TYPE: StringSizeType { let o = _accessor.offset(VTOFFSET.SIZE_TYPE.v); return o == 0 ? .fixed : StringSizeType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .fixed }
  ///  Fixed size in bits (when SIZE_TYPE=FIXED)
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Termination character (when SIZE_TYPE=TERMINATION_CHAR)
  public var TERMINATION_CHAR: UInt8 { let o = _accessor.offset(VTOFFSET.TERMINATION_CHAR.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Maximum size in bits (for variable length)
  public var MAX_SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.MAX_SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Leading size field bits (when SIZE_TYPE=LEADING_SIZE)
  public var LEADING_SIZE_BITS: UInt8 { let o = _accessor.offset(VTOFFSET.LEADING_SIZE_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startStringDataEncoding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(ENCODING: StringEncodingType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENCODING.rawValue, def: 3, at: VTOFFSET.ENCODING.p) }
  public static func add(SIZE_TYPE: StringSizeType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_TYPE.rawValue, def: 0, at: VTOFFSET.SIZE_TYPE.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(TERMINATION_CHAR: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TERMINATION_CHAR, def: 0, at: VTOFFSET.TERMINATION_CHAR.p) }
  public static func add(MAX_SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_SIZE_IN_BITS, def: 0, at: VTOFFSET.MAX_SIZE_IN_BITS.p) }
  public static func add(LEADING_SIZE_BITS: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LEADING_SIZE_BITS, def: 0, at: VTOFFSET.LEADING_SIZE_BITS.p) }
  public static func endStringDataEncoding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStringDataEncoding(
    _ fbb: inout FlatBufferBuilder,
    ENCODING: StringEncodingType = .utf8,
    SIZE_TYPE: StringSizeType = .fixed,
    SIZE_IN_BITS: UInt16 = 0,
    TERMINATION_CHAR: UInt8 = 0,
    MAX_SIZE_IN_BITS: UInt16 = 0,
    LEADING_SIZE_BITS: UInt8 = 0
  ) -> Offset {
    let __start = StringDataEncoding.startStringDataEncoding(&fbb)
    StringDataEncoding.add(ENCODING: ENCODING, &fbb)
    StringDataEncoding.add(SIZE_TYPE: SIZE_TYPE, &fbb)
    StringDataEncoding.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    StringDataEncoding.add(TERMINATION_CHAR: TERMINATION_CHAR, &fbb)
    StringDataEncoding.add(MAX_SIZE_IN_BITS: MAX_SIZE_IN_BITS, &fbb)
    StringDataEncoding.add(LEADING_SIZE_BITS: LEADING_SIZE_BITS, &fbb)
    return StringDataEncoding.endStringDataEncoding(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ENCODING.p, fieldName: "ENCODING", required: false, type: StringEncodingType.self)
    try _v.visit(field: VTOFFSET.SIZE_TYPE.p, fieldName: "SIZE_TYPE", required: false, type: StringSizeType.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.TERMINATION_CHAR.p, fieldName: "TERMINATION_CHAR", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.MAX_SIZE_IN_BITS.p, fieldName: "MAX_SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.LEADING_SIZE_BITS.p, fieldName: "LEADING_SIZE_BITS", required: false, type: UInt8.self)
    _v.finish()
  }
}

///  Binary data encoding specification
public struct BinaryDataEncoding: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BinaryDataEncoding.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SIZE_IN_BITS = 4
    case MAX_SIZE_IN_BITS = 6
    case LEADING_SIZE_BITS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Fixed size in bits
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Maximum size in bits (for variable length)
  public var MAX_SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.MAX_SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Leading size field bits (for variable length)
  public var LEADING_SIZE_BITS: UInt8 { let o = _accessor.offset(VTOFFSET.LEADING_SIZE_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startBinaryDataEncoding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(MAX_SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_SIZE_IN_BITS, def: 0, at: VTOFFSET.MAX_SIZE_IN_BITS.p) }
  public static func add(LEADING_SIZE_BITS: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LEADING_SIZE_BITS, def: 0, at: VTOFFSET.LEADING_SIZE_BITS.p) }
  public static func endBinaryDataEncoding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBinaryDataEncoding(
    _ fbb: inout FlatBufferBuilder,
    SIZE_IN_BITS: UInt16 = 0,
    MAX_SIZE_IN_BITS: UInt16 = 0,
    LEADING_SIZE_BITS: UInt8 = 0
  ) -> Offset {
    let __start = BinaryDataEncoding.startBinaryDataEncoding(&fbb)
    BinaryDataEncoding.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    BinaryDataEncoding.add(MAX_SIZE_IN_BITS: MAX_SIZE_IN_BITS, &fbb)
    BinaryDataEncoding.add(LEADING_SIZE_BITS: LEADING_SIZE_BITS, &fbb)
    return BinaryDataEncoding.endBinaryDataEncoding(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.MAX_SIZE_IN_BITS.p, fieldName: "MAX_SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.LEADING_SIZE_BITS.p, fieldName: "LEADING_SIZE_BITS", required: false, type: UInt8.self)
    _v.finish()
  }
}

///  Polynomial calibrator - converts raw to engineering using polynomial
public struct PolynomialCalibrator: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PolynomialCalibrator.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COEFFICIENTS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Polynomial terms (index is power, value is coefficient)
  public var hasCoefficients: Bool { let o = _accessor.offset(VTOFFSET.COEFFICIENTS.v); return o == 0 ? false : true }
  public var COEFFICIENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.COEFFICIENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COEFFICIENTS(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.COEFFICIENTS.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var COEFFICIENTS: [Double] { return _accessor.getVector(at: VTOFFSET.COEFFICIENTS.v) ?? [] }
  public static func startPolynomialCalibrator(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(COEFFICIENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COEFFICIENTS, at: VTOFFSET.COEFFICIENTS.p) }
  public static func endPolynomialCalibrator(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPolynomialCalibrator(
    _ fbb: inout FlatBufferBuilder,
    COEFFICIENTSVectorOffset COEFFICIENTS: Offset = Offset()
  ) -> Offset {
    let __start = PolynomialCalibrator.startPolynomialCalibrator(&fbb)
    PolynomialCalibrator.addVectorOf(COEFFICIENTS: COEFFICIENTS, &fbb)
    return PolynomialCalibrator.endPolynomialCalibrator(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COEFFICIENTS.p, fieldName: "COEFFICIENTS", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    _v.finish()
  }
}

///  Spline point for spline calibration
public struct SplinePoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SplinePoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RAW = 4
    case CALIBRATED = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Raw value
  public var RAW: Double { let o = _accessor.offset(VTOFFSET.RAW.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Calibrated/engineering value
  public var CALIBRATED: Double { let o = _accessor.offset(VTOFFSET.CALIBRATED.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startSplinePoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(RAW: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RAW, def: 0.0, at: VTOFFSET.RAW.p) }
  public static func add(CALIBRATED: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CALIBRATED, def: 0.0, at: VTOFFSET.CALIBRATED.p) }
  public static func endSplinePoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSplinePoint(
    _ fbb: inout FlatBufferBuilder,
    RAW: Double = 0.0,
    CALIBRATED: Double = 0.0
  ) -> Offset {
    let __start = SplinePoint.startSplinePoint(&fbb)
    SplinePoint.add(RAW: RAW, &fbb)
    SplinePoint.add(CALIBRATED: CALIBRATED, &fbb)
    return SplinePoint.endSplinePoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RAW.p, fieldName: "RAW", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CALIBRATED.p, fieldName: "CALIBRATED", required: false, type: Double.self)
    _v.finish()
  }
}

///  Spline calibrator - piecewise linear interpolation
public struct SplineCalibrator: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SplineCalibrator.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case POINTS = 4
    case EXTRAPOLATE_LOW = 6
    case EXTRAPOLATE_HIGH = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Spline points ordered by raw value
  public var hasPoints: Bool { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? false : true }
  public var POINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POINTS(at index: Int32) -> SplinePoint? { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? nil : SplinePoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Extrapolate below minimum point
  public var EXTRAPOLATE_LOW: Bool { let o = _accessor.offset(VTOFFSET.EXTRAPOLATE_LOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Extrapolate above maximum point
  public var EXTRAPOLATE_HIGH: Bool { let o = _accessor.offset(VTOFFSET.EXTRAPOLATE_HIGH.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startSplineCalibrator(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(POINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINTS, at: VTOFFSET.POINTS.p) }
  public static func add(EXTRAPOLATE_LOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRAPOLATE_LOW, def: false,
   at: VTOFFSET.EXTRAPOLATE_LOW.p) }
  public static func add(EXTRAPOLATE_HIGH: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRAPOLATE_HIGH, def: false,
   at: VTOFFSET.EXTRAPOLATE_HIGH.p) }
  public static func endSplineCalibrator(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSplineCalibrator(
    _ fbb: inout FlatBufferBuilder,
    POINTSVectorOffset POINTS: Offset = Offset(),
    EXTRAPOLATE_LOW: Bool = false,
    EXTRAPOLATE_HIGH: Bool = false
  ) -> Offset {
    let __start = SplineCalibrator.startSplineCalibrator(&fbb)
    SplineCalibrator.addVectorOf(POINTS: POINTS, &fbb)
    SplineCalibrator.add(EXTRAPOLATE_LOW: EXTRAPOLATE_LOW, &fbb)
    SplineCalibrator.add(EXTRAPOLATE_HIGH: EXTRAPOLATE_HIGH, &fbb)
    return SplineCalibrator.endSplineCalibrator(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.POINTS.p, fieldName: "POINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<SplinePoint>, SplinePoint>>.self)
    try _v.visit(field: VTOFFSET.EXTRAPOLATE_LOW.p, fieldName: "EXTRAPOLATE_LOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.EXTRAPOLATE_HIGH.p, fieldName: "EXTRAPOLATE_HIGH", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Mathematical operation for math operation calibrator
public struct MathOperation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MathOperation.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RPN_EXPRESSION = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Operation in Reverse Polish Notation (RPN)
  public var RPN_EXPRESSION: String? { let o = _accessor.offset(VTOFFSET.RPN_EXPRESSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RPN_EXPRESSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RPN_EXPRESSION.v) }
  public static func startMathOperation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(RPN_EXPRESSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RPN_EXPRESSION, at: VTOFFSET.RPN_EXPRESSION.p) }
  public static func endMathOperation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMathOperation(
    _ fbb: inout FlatBufferBuilder,
    RPN_EXPRESSIONOffset RPN_EXPRESSION: Offset = Offset()
  ) -> Offset {
    let __start = MathOperation.startMathOperation(&fbb)
    MathOperation.add(RPN_EXPRESSION: RPN_EXPRESSION, &fbb)
    return MathOperation.endMathOperation(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RPN_EXPRESSION.p, fieldName: "RPN_EXPRESSION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Context-dependent calibrator selection
public struct ContextCalibrator: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContextCalibrator.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MATCH_CRITERIA = 4
    case POLYNOMIAL = 6
    case SPLINE = 8
    case MATH_OPERATION = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Match criteria for selecting this calibrator
  public var MATCH_CRITERIA: MatchCriteria? { let o = _accessor.offset(VTOFFSET.MATCH_CRITERIA.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Polynomial calibrator (if used)
  public var POLYNOMIAL: PolynomialCalibrator? { let o = _accessor.offset(VTOFFSET.POLYNOMIAL.v); return o == 0 ? nil : PolynomialCalibrator(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Spline calibrator (if used)
  public var SPLINE: SplineCalibrator? { let o = _accessor.offset(VTOFFSET.SPLINE.v); return o == 0 ? nil : SplineCalibrator(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Math operation calibrator (if used)
  public var MATH_OPERATION: MathOperation? { let o = _accessor.offset(VTOFFSET.MATH_OPERATION.v); return o == 0 ? nil : MathOperation(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startContextCalibrator(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(MATCH_CRITERIA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATCH_CRITERIA, at: VTOFFSET.MATCH_CRITERIA.p) }
  public static func add(POLYNOMIAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYNOMIAL, at: VTOFFSET.POLYNOMIAL.p) }
  public static func add(SPLINE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SPLINE, at: VTOFFSET.SPLINE.p) }
  public static func add(MATH_OPERATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATH_OPERATION, at: VTOFFSET.MATH_OPERATION.p) }
  public static func endContextCalibrator(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContextCalibrator(
    _ fbb: inout FlatBufferBuilder,
    MATCH_CRITERIAOffset MATCH_CRITERIA: Offset = Offset(),
    POLYNOMIALOffset POLYNOMIAL: Offset = Offset(),
    SPLINEOffset SPLINE: Offset = Offset(),
    MATH_OPERATIONOffset MATH_OPERATION: Offset = Offset()
  ) -> Offset {
    let __start = ContextCalibrator.startContextCalibrator(&fbb)
    ContextCalibrator.add(MATCH_CRITERIA: MATCH_CRITERIA, &fbb)
    ContextCalibrator.add(POLYNOMIAL: POLYNOMIAL, &fbb)
    ContextCalibrator.add(SPLINE: SPLINE, &fbb)
    ContextCalibrator.add(MATH_OPERATION: MATH_OPERATION, &fbb)
    return ContextCalibrator.endContextCalibrator(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MATCH_CRITERIA.p, fieldName: "MATCH_CRITERIA", required: false, type: ForwardOffset<MatchCriteria>.self)
    try _v.visit(field: VTOFFSET.POLYNOMIAL.p, fieldName: "POLYNOMIAL", required: false, type: ForwardOffset<PolynomialCalibrator>.self)
    try _v.visit(field: VTOFFSET.SPLINE.p, fieldName: "SPLINE", required: false, type: ForwardOffset<SplineCalibrator>.self)
    try _v.visit(field: VTOFFSET.MATH_OPERATION.p, fieldName: "MATH_OPERATION", required: false, type: ForwardOffset<MathOperation>.self)
    _v.finish()
  }
}

///  Numeric alarm range
public struct AlarmRange: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AlarmRange.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MIN_INCLUSIVE = 4
    case MAX_INCLUSIVE = 6
    case MIN_EXCLUSIVE = 8
    case MAX_EXCLUSIVE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Minimum value (inclusive)
  public var MIN_INCLUSIVE: Double { let o = _accessor.offset(VTOFFSET.MIN_INCLUSIVE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum value (inclusive)
  public var MAX_INCLUSIVE: Double { let o = _accessor.offset(VTOFFSET.MAX_INCLUSIVE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum value (exclusive)
  public var MIN_EXCLUSIVE: Double { let o = _accessor.offset(VTOFFSET.MIN_EXCLUSIVE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum value (exclusive)
  public var MAX_EXCLUSIVE: Double { let o = _accessor.offset(VTOFFSET.MAX_EXCLUSIVE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startAlarmRange(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(MIN_INCLUSIVE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MIN_INCLUSIVE, def: 0.0, at: VTOFFSET.MIN_INCLUSIVE.p) }
  public static func add(MAX_INCLUSIVE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_INCLUSIVE, def: 0.0, at: VTOFFSET.MAX_INCLUSIVE.p) }
  public static func add(MIN_EXCLUSIVE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MIN_EXCLUSIVE, def: 0.0, at: VTOFFSET.MIN_EXCLUSIVE.p) }
  public static func add(MAX_EXCLUSIVE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_EXCLUSIVE, def: 0.0, at: VTOFFSET.MAX_EXCLUSIVE.p) }
  public static func endAlarmRange(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAlarmRange(
    _ fbb: inout FlatBufferBuilder,
    MIN_INCLUSIVE: Double = 0.0,
    MAX_INCLUSIVE: Double = 0.0,
    MIN_EXCLUSIVE: Double = 0.0,
    MAX_EXCLUSIVE: Double = 0.0
  ) -> Offset {
    let __start = AlarmRange.startAlarmRange(&fbb)
    AlarmRange.add(MIN_INCLUSIVE: MIN_INCLUSIVE, &fbb)
    AlarmRange.add(MAX_INCLUSIVE: MAX_INCLUSIVE, &fbb)
    AlarmRange.add(MIN_EXCLUSIVE: MIN_EXCLUSIVE, &fbb)
    AlarmRange.add(MAX_EXCLUSIVE: MAX_EXCLUSIVE, &fbb)
    return AlarmRange.endAlarmRange(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MIN_INCLUSIVE.p, fieldName: "MIN_INCLUSIVE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MAX_INCLUSIVE.p, fieldName: "MAX_INCLUSIVE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MIN_EXCLUSIVE.p, fieldName: "MIN_EXCLUSIVE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MAX_EXCLUSIVE.p, fieldName: "MAX_EXCLUSIVE", required: false, type: Double.self)
    _v.finish()
  }
}

///  Static numeric alarm levels
public struct StaticAlarmRanges: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StaticAlarmRanges.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case WATCH_RANGE = 4
    case WARNING_RANGE = 6
    case DISTRESS_RANGE = 8
    case CRITICAL_RANGE = 10
    case SEVERE_RANGE = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Watch range
  public var WATCH_RANGE: AlarmRange? { let o = _accessor.offset(VTOFFSET.WATCH_RANGE.v); return o == 0 ? nil : AlarmRange(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Warning range
  public var WARNING_RANGE: AlarmRange? { let o = _accessor.offset(VTOFFSET.WARNING_RANGE.v); return o == 0 ? nil : AlarmRange(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Distress range
  public var DISTRESS_RANGE: AlarmRange? { let o = _accessor.offset(VTOFFSET.DISTRESS_RANGE.v); return o == 0 ? nil : AlarmRange(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Critical range
  public var CRITICAL_RANGE: AlarmRange? { let o = _accessor.offset(VTOFFSET.CRITICAL_RANGE.v); return o == 0 ? nil : AlarmRange(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Severe range
  public var SEVERE_RANGE: AlarmRange? { let o = _accessor.offset(VTOFFSET.SEVERE_RANGE.v); return o == 0 ? nil : AlarmRange(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startStaticAlarmRanges(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(WATCH_RANGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WATCH_RANGE, at: VTOFFSET.WATCH_RANGE.p) }
  public static func add(WARNING_RANGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WARNING_RANGE, at: VTOFFSET.WARNING_RANGE.p) }
  public static func add(DISTRESS_RANGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DISTRESS_RANGE, at: VTOFFSET.DISTRESS_RANGE.p) }
  public static func add(CRITICAL_RANGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CRITICAL_RANGE, at: VTOFFSET.CRITICAL_RANGE.p) }
  public static func add(SEVERE_RANGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SEVERE_RANGE, at: VTOFFSET.SEVERE_RANGE.p) }
  public static func endStaticAlarmRanges(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStaticAlarmRanges(
    _ fbb: inout FlatBufferBuilder,
    WATCH_RANGEOffset WATCH_RANGE: Offset = Offset(),
    WARNING_RANGEOffset WARNING_RANGE: Offset = Offset(),
    DISTRESS_RANGEOffset DISTRESS_RANGE: Offset = Offset(),
    CRITICAL_RANGEOffset CRITICAL_RANGE: Offset = Offset(),
    SEVERE_RANGEOffset SEVERE_RANGE: Offset = Offset()
  ) -> Offset {
    let __start = StaticAlarmRanges.startStaticAlarmRanges(&fbb)
    StaticAlarmRanges.add(WATCH_RANGE: WATCH_RANGE, &fbb)
    StaticAlarmRanges.add(WARNING_RANGE: WARNING_RANGE, &fbb)
    StaticAlarmRanges.add(DISTRESS_RANGE: DISTRESS_RANGE, &fbb)
    StaticAlarmRanges.add(CRITICAL_RANGE: CRITICAL_RANGE, &fbb)
    StaticAlarmRanges.add(SEVERE_RANGE: SEVERE_RANGE, &fbb)
    return StaticAlarmRanges.endStaticAlarmRanges(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.WATCH_RANGE.p, fieldName: "WATCH_RANGE", required: false, type: ForwardOffset<AlarmRange>.self)
    try _v.visit(field: VTOFFSET.WARNING_RANGE.p, fieldName: "WARNING_RANGE", required: false, type: ForwardOffset<AlarmRange>.self)
    try _v.visit(field: VTOFFSET.DISTRESS_RANGE.p, fieldName: "DISTRESS_RANGE", required: false, type: ForwardOffset<AlarmRange>.self)
    try _v.visit(field: VTOFFSET.CRITICAL_RANGE.p, fieldName: "CRITICAL_RANGE", required: false, type: ForwardOffset<AlarmRange>.self)
    try _v.visit(field: VTOFFSET.SEVERE_RANGE.p, fieldName: "SEVERE_RANGE", required: false, type: ForwardOffset<AlarmRange>.self)
    _v.finish()
  }
}

///  Enumerated alarm
public struct EnumerationAlarm: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EnumerationAlarm.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LABEL = 4
    case ALARM_LEVEL = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Enumerated value label
  public var LABEL: String? { let o = _accessor.offset(VTOFFSET.LABEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LABELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LABEL.v) }
  ///  Alarm level for this value
  public var ALARM_LEVEL: AlarmSeverityType { let o = _accessor.offset(VTOFFSET.ALARM_LEVEL.v); return o == 0 ? .normal : AlarmSeverityType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  public static func startEnumerationAlarm(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(LABEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LABEL, at: VTOFFSET.LABEL.p) }
  public static func add(ALARM_LEVEL: AlarmSeverityType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALARM_LEVEL.rawValue, def: 0, at: VTOFFSET.ALARM_LEVEL.p) }
  public static func endEnumerationAlarm(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEnumerationAlarm(
    _ fbb: inout FlatBufferBuilder,
    LABELOffset LABEL: Offset = Offset(),
    ALARM_LEVEL: AlarmSeverityType = .normal
  ) -> Offset {
    let __start = EnumerationAlarm.startEnumerationAlarm(&fbb)
    EnumerationAlarm.add(LABEL: LABEL, &fbb)
    EnumerationAlarm.add(ALARM_LEVEL: ALARM_LEVEL, &fbb)
    return EnumerationAlarm.endEnumerationAlarm(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LABEL.p, fieldName: "LABEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALARM_LEVEL.p, fieldName: "ALARM_LEVEL", required: false, type: AlarmSeverityType.self)
    _v.finish()
  }
}

///  Default alarm definition
public struct DefaultAlarm: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: DefaultAlarm.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MIN_VIOLATIONS = 4
    case STATIC_ALARM_RANGES = 6
    case ENUMERATION_ALARMS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Minimum violations before alarm triggers
  public var MIN_VIOLATIONS: UInt16 { let o = _accessor.offset(VTOFFSET.MIN_VIOLATIONS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Static numeric alarm ranges
  public var STATIC_ALARM_RANGES: StaticAlarmRanges? { let o = _accessor.offset(VTOFFSET.STATIC_ALARM_RANGES.v); return o == 0 ? nil : StaticAlarmRanges(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Enumeration alarms for enumerated types
  public var hasEnumerationAlarms: Bool { let o = _accessor.offset(VTOFFSET.ENUMERATION_ALARMS.v); return o == 0 ? false : true }
  public var ENUMERATION_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.ENUMERATION_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENUMERATION_ALARMS(at index: Int32) -> EnumerationAlarm? { let o = _accessor.offset(VTOFFSET.ENUMERATION_ALARMS.v); return o == 0 ? nil : EnumerationAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startDefaultAlarm(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(MIN_VIOLATIONS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MIN_VIOLATIONS, def: 0, at: VTOFFSET.MIN_VIOLATIONS.p) }
  public static func add(STATIC_ALARM_RANGES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STATIC_ALARM_RANGES, at: VTOFFSET.STATIC_ALARM_RANGES.p) }
  public static func addVectorOf(ENUMERATION_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENUMERATION_ALARMS, at: VTOFFSET.ENUMERATION_ALARMS.p) }
  public static func endDefaultAlarm(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDefaultAlarm(
    _ fbb: inout FlatBufferBuilder,
    MIN_VIOLATIONS: UInt16 = 0,
    STATIC_ALARM_RANGESOffset STATIC_ALARM_RANGES: Offset = Offset(),
    ENUMERATION_ALARMSVectorOffset ENUMERATION_ALARMS: Offset = Offset()
  ) -> Offset {
    let __start = DefaultAlarm.startDefaultAlarm(&fbb)
    DefaultAlarm.add(MIN_VIOLATIONS: MIN_VIOLATIONS, &fbb)
    DefaultAlarm.add(STATIC_ALARM_RANGES: STATIC_ALARM_RANGES, &fbb)
    DefaultAlarm.addVectorOf(ENUMERATION_ALARMS: ENUMERATION_ALARMS, &fbb)
    return DefaultAlarm.endDefaultAlarm(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MIN_VIOLATIONS.p, fieldName: "MIN_VIOLATIONS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.STATIC_ALARM_RANGES.p, fieldName: "STATIC_ALARM_RANGES", required: false, type: ForwardOffset<StaticAlarmRanges>.self)
    try _v.visit(field: VTOFFSET.ENUMERATION_ALARMS.p, fieldName: "ENUMERATION_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<EnumerationAlarm>, EnumerationAlarm>>.self)
    _v.finish()
  }
}

///  Context-dependent alarm
public struct ContextAlarm: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContextAlarm.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MATCH_CRITERIA = 4
    case ALARM = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Match criteria for this alarm context
  public var MATCH_CRITERIA: MatchCriteria? { let o = _accessor.offset(VTOFFSET.MATCH_CRITERIA.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Alarm definition for this context
  public var ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startContextAlarm(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(MATCH_CRITERIA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATCH_CRITERIA, at: VTOFFSET.MATCH_CRITERIA.p) }
  public static func add(ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALARM, at: VTOFFSET.ALARM.p) }
  public static func endContextAlarm(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContextAlarm(
    _ fbb: inout FlatBufferBuilder,
    MATCH_CRITERIAOffset MATCH_CRITERIA: Offset = Offset(),
    ALARMOffset ALARM: Offset = Offset()
  ) -> Offset {
    let __start = ContextAlarm.startContextAlarm(&fbb)
    ContextAlarm.add(MATCH_CRITERIA: MATCH_CRITERIA, &fbb)
    ContextAlarm.add(ALARM: ALARM, &fbb)
    return ContextAlarm.endContextAlarm(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MATCH_CRITERIA.p, fieldName: "MATCH_CRITERIA", required: false, type: ForwardOffset<MatchCriteria>.self)
    try _v.visit(field: VTOFFSET.ALARM.p, fieldName: "ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    _v.finish()
  }
}

///  Parameter comparison for match criteria
public struct ParameterComparison: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ParameterComparison.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case OPERATOR = 6
    case VALUE = 8
    case USE_CALIBRATED_VALUE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference path
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Comparison operator
  public var OPERATOR: ComparisonOperator { let o = _accessor.offset(VTOFFSET.OPERATOR.v); return o == 0 ? .eq : ComparisonOperator(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .eq }
  ///  Value to compare against
  public var VALUE: String? { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALUE.v) }
  ///  Use calibrated value (true) or raw value (false)
  public var USE_CALIBRATED_VALUE: Bool { let o = _accessor.offset(VTOFFSET.USE_CALIBRATED_VALUE.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startParameterComparison(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(OPERATOR: ComparisonOperator, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OPERATOR.rawValue, def: 0, at: VTOFFSET.OPERATOR.p) }
  public static func add(VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALUE, at: VTOFFSET.VALUE.p) }
  public static func add(USE_CALIBRATED_VALUE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: USE_CALIBRATED_VALUE, def: true,
   at: VTOFFSET.USE_CALIBRATED_VALUE.p) }
  public static func endParameterComparison(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameterComparison(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    OPERATOR: ComparisonOperator = .eq,
    VALUEOffset VALUE: Offset = Offset(),
    USE_CALIBRATED_VALUE: Bool = true
  ) -> Offset {
    let __start = ParameterComparison.startParameterComparison(&fbb)
    ParameterComparison.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    ParameterComparison.add(OPERATOR: OPERATOR, &fbb)
    ParameterComparison.add(VALUE: VALUE, &fbb)
    ParameterComparison.add(USE_CALIBRATED_VALUE: USE_CALIBRATED_VALUE, &fbb)
    return ParameterComparison.endParameterComparison(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OPERATOR.p, fieldName: "OPERATOR", required: false, type: ComparisonOperator.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.USE_CALIBRATED_VALUE.p, fieldName: "USE_CALIBRATED_VALUE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Boolean expression combining comparisons
public struct BooleanExpression: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BooleanExpression.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case OPERATOR = 4
    case CONDITIONS = 6
    case EXPRESSIONS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Boolean operator
  public var OPERATOR: BooleanOperatorType { let o = _accessor.offset(VTOFFSET.OPERATOR.v); return o == 0 ? .and : BooleanOperatorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .and }
  ///  Comparison conditions
  public var hasConditions: Bool { let o = _accessor.offset(VTOFFSET.CONDITIONS.v); return o == 0 ? false : true }
  public var CONDITIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONDITIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONDITIONS(at index: Int32) -> ParameterComparison? { let o = _accessor.offset(VTOFFSET.CONDITIONS.v); return o == 0 ? nil : ParameterComparison(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Nested expressions
  public var hasExpressions: Bool { let o = _accessor.offset(VTOFFSET.EXPRESSIONS.v); return o == 0 ? false : true }
  public var EXPRESSIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.EXPRESSIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func EXPRESSIONS(at index: Int32) -> BooleanExpression? { let o = _accessor.offset(VTOFFSET.EXPRESSIONS.v); return o == 0 ? nil : BooleanExpression(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startBooleanExpression(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(OPERATOR: BooleanOperatorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OPERATOR.rawValue, def: 0, at: VTOFFSET.OPERATOR.p) }
  public static func addVectorOf(CONDITIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONDITIONS, at: VTOFFSET.CONDITIONS.p) }
  public static func addVectorOf(EXPRESSIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EXPRESSIONS, at: VTOFFSET.EXPRESSIONS.p) }
  public static func endBooleanExpression(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBooleanExpression(
    _ fbb: inout FlatBufferBuilder,
    OPERATOR: BooleanOperatorType = .and,
    CONDITIONSVectorOffset CONDITIONS: Offset = Offset(),
    EXPRESSIONSVectorOffset EXPRESSIONS: Offset = Offset()
  ) -> Offset {
    let __start = BooleanExpression.startBooleanExpression(&fbb)
    BooleanExpression.add(OPERATOR: OPERATOR, &fbb)
    BooleanExpression.addVectorOf(CONDITIONS: CONDITIONS, &fbb)
    BooleanExpression.addVectorOf(EXPRESSIONS: EXPRESSIONS, &fbb)
    return BooleanExpression.endBooleanExpression(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.OPERATOR.p, fieldName: "OPERATOR", required: false, type: BooleanOperatorType.self)
    try _v.visit(field: VTOFFSET.CONDITIONS.p, fieldName: "CONDITIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<ParameterComparison>, ParameterComparison>>.self)
    try _v.visit(field: VTOFFSET.EXPRESSIONS.p, fieldName: "EXPRESSIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<BooleanExpression>, BooleanExpression>>.self)
    _v.finish()
  }
}

///  Match criteria for conditional logic
public struct MatchCriteria: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MatchCriteria.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMPARISON = 4
    case COMPARISON_LIST = 6
    case BOOLEAN_EXPRESSION = 8
    case CUSTOM_ALGORITHM = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Single comparison
  public var COMPARISON: ParameterComparison? { let o = _accessor.offset(VTOFFSET.COMPARISON.v); return o == 0 ? nil : ParameterComparison(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  List of comparisons (implicit AND)
  public var hasComparisonList: Bool { let o = _accessor.offset(VTOFFSET.COMPARISON_LIST.v); return o == 0 ? false : true }
  public var COMPARISON_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.COMPARISON_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMPARISON_LIST(at index: Int32) -> ParameterComparison? { let o = _accessor.offset(VTOFFSET.COMPARISON_LIST.v); return o == 0 ? nil : ParameterComparison(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Boolean expression
  public var BOOLEAN_EXPRESSION: BooleanExpression? { let o = _accessor.offset(VTOFFSET.BOOLEAN_EXPRESSION.v); return o == 0 ? nil : BooleanExpression(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Custom algorithm reference
  public var CUSTOM_ALGORITHM: String? { let o = _accessor.offset(VTOFFSET.CUSTOM_ALGORITHM.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CUSTOM_ALGORITHMSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CUSTOM_ALGORITHM.v) }
  public static func startMatchCriteria(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(COMPARISON: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMPARISON, at: VTOFFSET.COMPARISON.p) }
  public static func addVectorOf(COMPARISON_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMPARISON_LIST, at: VTOFFSET.COMPARISON_LIST.p) }
  public static func add(BOOLEAN_EXPRESSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BOOLEAN_EXPRESSION, at: VTOFFSET.BOOLEAN_EXPRESSION.p) }
  public static func add(CUSTOM_ALGORITHM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CUSTOM_ALGORITHM, at: VTOFFSET.CUSTOM_ALGORITHM.p) }
  public static func endMatchCriteria(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMatchCriteria(
    _ fbb: inout FlatBufferBuilder,
    COMPARISONOffset COMPARISON: Offset = Offset(),
    COMPARISON_LISTVectorOffset COMPARISON_LIST: Offset = Offset(),
    BOOLEAN_EXPRESSIONOffset BOOLEAN_EXPRESSION: Offset = Offset(),
    CUSTOM_ALGORITHMOffset CUSTOM_ALGORITHM: Offset = Offset()
  ) -> Offset {
    let __start = MatchCriteria.startMatchCriteria(&fbb)
    MatchCriteria.add(COMPARISON: COMPARISON, &fbb)
    MatchCriteria.addVectorOf(COMPARISON_LIST: COMPARISON_LIST, &fbb)
    MatchCriteria.add(BOOLEAN_EXPRESSION: BOOLEAN_EXPRESSION, &fbb)
    MatchCriteria.add(CUSTOM_ALGORITHM: CUSTOM_ALGORITHM, &fbb)
    return MatchCriteria.endMatchCriteria(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMPARISON.p, fieldName: "COMPARISON", required: false, type: ForwardOffset<ParameterComparison>.self)
    try _v.visit(field: VTOFFSET.COMPARISON_LIST.p, fieldName: "COMPARISON_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<ParameterComparison>, ParameterComparison>>.self)
    try _v.visit(field: VTOFFSET.BOOLEAN_EXPRESSION.p, fieldName: "BOOLEAN_EXPRESSION", required: false, type: ForwardOffset<BooleanExpression>.self)
    try _v.visit(field: VTOFFSET.CUSTOM_ALGORITHM.p, fieldName: "CUSTOM_ALGORITHM", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Unit specification
public struct Unit: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Unit.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case DESCRIPTION = 4
    case SYMBOL = 6
    case POWER = 8
    case FACTOR = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unit description (e.g., "meters per second")
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Unit symbol (e.g., "m/s")
  public var SYMBOL: String? { let o = _accessor.offset(VTOFFSET.SYMBOL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SYMBOLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SYMBOL.v) }
  ///  Power/exponent for this unit
  public var POWER: Double { let o = _accessor.offset(VTOFFSET.POWER.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Factor multiplier
  public var FACTOR: Double { let o = _accessor.offset(VTOFFSET.FACTOR.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startUnit(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(SYMBOL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SYMBOL, at: VTOFFSET.SYMBOL.p) }
  public static func add(POWER: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: POWER, def: 0.0, at: VTOFFSET.POWER.p) }
  public static func add(FACTOR: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FACTOR, def: 0.0, at: VTOFFSET.FACTOR.p) }
  public static func endUnit(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUnit(
    _ fbb: inout FlatBufferBuilder,
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    SYMBOLOffset SYMBOL: Offset = Offset(),
    POWER: Double = 0.0,
    FACTOR: Double = 0.0
  ) -> Offset {
    let __start = Unit.startUnit(&fbb)
    Unit.add(DESCRIPTION: DESCRIPTION, &fbb)
    Unit.add(SYMBOL: SYMBOL, &fbb)
    Unit.add(POWER: POWER, &fbb)
    Unit.add(FACTOR: FACTOR, &fbb)
    return Unit.endUnit(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SYMBOL.p, fieldName: "SYMBOL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POWER.p, fieldName: "POWER", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FACTOR.p, fieldName: "FACTOR", required: false, type: Double.self)
    _v.finish()
  }
}

///  Enumeration value mapping
public struct EnumerationValue: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EnumerationValue.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LABEL = 4
    case VALUE = 6
    case MAX_VALUE = 8
    case DESCRIPTION = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Label/name for this value
  public var LABEL: String? { let o = _accessor.offset(VTOFFSET.LABEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LABELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LABEL.v) }
  ///  Numeric value
  public var VALUE: Int64 { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Maximum value (for ranges)
  public var MAX_VALUE: Int64 { let o = _accessor.offset(VTOFFSET.MAX_VALUE.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Description of this enumeration value
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  public static func startEnumerationValue(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(LABEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LABEL, at: VTOFFSET.LABEL.p) }
  public static func add(VALUE: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALUE, def: 0, at: VTOFFSET.VALUE.p) }
  public static func add(MAX_VALUE: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_VALUE, def: 0, at: VTOFFSET.MAX_VALUE.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func endEnumerationValue(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEnumerationValue(
    _ fbb: inout FlatBufferBuilder,
    LABELOffset LABEL: Offset = Offset(),
    VALUE: Int64 = 0,
    MAX_VALUE: Int64 = 0,
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset()
  ) -> Offset {
    let __start = EnumerationValue.startEnumerationValue(&fbb)
    EnumerationValue.add(LABEL: LABEL, &fbb)
    EnumerationValue.add(VALUE: VALUE, &fbb)
    EnumerationValue.add(MAX_VALUE: MAX_VALUE, &fbb)
    EnumerationValue.add(DESCRIPTION: DESCRIPTION, &fbb)
    return EnumerationValue.endEnumerationValue(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LABEL.p, fieldName: "LABEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.MAX_VALUE.p, fieldName: "MAX_VALUE", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Integer parameter type
public struct IntegerParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: IntegerParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case UNITS = 10
    case DATA_ENCODING = 12
    case DEFAULT_ALARM = 14
    case CONTEXT_ALARMS = 16
    case VALID_MIN = 18
    case VALID_MAX = 20
    case SIGNED = 22
    case SIZE_IN_BITS = 24
    case INITIAL_VALUE = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Units
  public var hasUnits: Bool { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? false : true }
  public var UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func UNITS(at index: Int32) -> Unit? { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? nil : Unit(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Minimum valid value
  public var VALID_MIN: Int64 { let o = _accessor.offset(VTOFFSET.VALID_MIN.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Maximum valid value
  public var VALID_MAX: Int64 { let o = _accessor.offset(VTOFFSET.VALID_MAX.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Signed integer (true) or unsigned (false)
  public var SIGNED: Bool { let o = _accessor.offset(VTOFFSET.SIGNED.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Size in bits
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Initial/default value
  public var INITIAL_VALUE: Int64 { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public static func startIntegerParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UNITS, at: VTOFFSET.UNITS.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func add(VALID_MIN: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MIN, def: 0, at: VTOFFSET.VALID_MIN.p) }
  public static func add(VALID_MAX: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MAX, def: 0, at: VTOFFSET.VALID_MAX.p) }
  public static func add(SIGNED: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIGNED, def: false,
   at: VTOFFSET.SIGNED.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(INITIAL_VALUE: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: 0, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endIntegerParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createIntegerParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    UNITSVectorOffset UNITS: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset(),
    VALID_MIN: Int64 = 0,
    VALID_MAX: Int64 = 0,
    SIGNED: Bool = false,
    SIZE_IN_BITS: UInt16 = 0,
    INITIAL_VALUE: Int64 = 0
  ) -> Offset {
    let __start = IntegerParameterType.startIntegerParameterType(&fbb)
    IntegerParameterType.add(NAME: NAME, &fbb)
    IntegerParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    IntegerParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    IntegerParameterType.addVectorOf(UNITS: UNITS, &fbb)
    IntegerParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    IntegerParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    IntegerParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    IntegerParameterType.add(VALID_MIN: VALID_MIN, &fbb)
    IntegerParameterType.add(VALID_MAX: VALID_MAX, &fbb)
    IntegerParameterType.add(SIGNED: SIGNED, &fbb)
    IntegerParameterType.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    IntegerParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return IntegerParameterType.endIntegerParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UNITS.p, fieldName: "UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<Unit>, Unit>>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    try _v.visit(field: VTOFFSET.VALID_MIN.p, fieldName: "VALID_MIN", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.VALID_MAX.p, fieldName: "VALID_MAX", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.SIGNED.p, fieldName: "SIGNED", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Int64.self)
    _v.finish()
  }
}

///  Float parameter type
public struct FloatParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FloatParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case UNITS = 10
    case DATA_ENCODING = 12
    case DEFAULT_ALARM = 14
    case CONTEXT_ALARMS = 16
    case VALID_MIN = 18
    case VALID_MAX = 20
    case SIZE_IN_BITS = 22
    case INITIAL_VALUE = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Units
  public var hasUnits: Bool { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? false : true }
  public var UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func UNITS(at index: Int32) -> Unit? { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? nil : Unit(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data encoding
  public var DATA_ENCODING: FloatDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : FloatDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Minimum valid value
  public var VALID_MIN: Double { let o = _accessor.offset(VTOFFSET.VALID_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum valid value
  public var VALID_MAX: Double { let o = _accessor.offset(VTOFFSET.VALID_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Size in bits (32 or 64)
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Initial/default value
  public var INITIAL_VALUE: Double { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startFloatParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UNITS, at: VTOFFSET.UNITS.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func add(VALID_MIN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MIN, def: 0.0, at: VTOFFSET.VALID_MIN.p) }
  public static func add(VALID_MAX: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MAX, def: 0.0, at: VTOFFSET.VALID_MAX.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(INITIAL_VALUE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: 0.0, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endFloatParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFloatParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    UNITSVectorOffset UNITS: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset(),
    VALID_MIN: Double = 0.0,
    VALID_MAX: Double = 0.0,
    SIZE_IN_BITS: UInt16 = 0,
    INITIAL_VALUE: Double = 0.0
  ) -> Offset {
    let __start = FloatParameterType.startFloatParameterType(&fbb)
    FloatParameterType.add(NAME: NAME, &fbb)
    FloatParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    FloatParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    FloatParameterType.addVectorOf(UNITS: UNITS, &fbb)
    FloatParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    FloatParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    FloatParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    FloatParameterType.add(VALID_MIN: VALID_MIN, &fbb)
    FloatParameterType.add(VALID_MAX: VALID_MAX, &fbb)
    FloatParameterType.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    FloatParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return FloatParameterType.endFloatParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UNITS.p, fieldName: "UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<Unit>, Unit>>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<FloatDataEncoding>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    try _v.visit(field: VTOFFSET.VALID_MIN.p, fieldName: "VALID_MIN", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VALID_MAX.p, fieldName: "VALID_MAX", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Double.self)
    _v.finish()
  }
}

///  String parameter type
public struct StringParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StringParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case DEFAULT_ALARM = 12
    case CONTEXT_ALARMS = 14
    case INITIAL_VALUE = 16
    case RESTRICTION_PATTERN = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: StringDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : StringDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Initial/default value
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  ///  Restriction pattern (regex)
  public var RESTRICTION_PATTERN: String? { let o = _accessor.offset(VTOFFSET.RESTRICTION_PATTERN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RESTRICTION_PATTERNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RESTRICTION_PATTERN.v) }
  public static func startStringParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func add(RESTRICTION_PATTERN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESTRICTION_PATTERN, at: VTOFFSET.RESTRICTION_PATTERN.p) }
  public static func endStringParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStringParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset(),
    RESTRICTION_PATTERNOffset RESTRICTION_PATTERN: Offset = Offset()
  ) -> Offset {
    let __start = StringParameterType.startStringParameterType(&fbb)
    StringParameterType.add(NAME: NAME, &fbb)
    StringParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    StringParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    StringParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    StringParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    StringParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    StringParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    StringParameterType.add(RESTRICTION_PATTERN: RESTRICTION_PATTERN, &fbb)
    return StringParameterType.endStringParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<StringDataEncoding>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RESTRICTION_PATTERN.p, fieldName: "RESTRICTION_PATTERN", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Boolean parameter type
public struct BooleanParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BooleanParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case ONE_STRING_VALUE = 12
    case ZERO_STRING_VALUE = 14
    case INITIAL_VALUE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding (typically IntegerDataEncoding with 1 bit)
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  String representation of true value
  public var ONE_STRING_VALUE: String? { let o = _accessor.offset(VTOFFSET.ONE_STRING_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ONE_STRING_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ONE_STRING_VALUE.v) }
  ///  String representation of false value
  public var ZERO_STRING_VALUE: String? { let o = _accessor.offset(VTOFFSET.ZERO_STRING_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ZERO_STRING_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ZERO_STRING_VALUE.v) }
  ///  Initial/default value
  public var INITIAL_VALUE: Bool { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startBooleanParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(ONE_STRING_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ONE_STRING_VALUE, at: VTOFFSET.ONE_STRING_VALUE.p) }
  public static func add(ZERO_STRING_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ZERO_STRING_VALUE, at: VTOFFSET.ZERO_STRING_VALUE.p) }
  public static func add(INITIAL_VALUE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: false,
   at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endBooleanParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBooleanParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    ONE_STRING_VALUEOffset ONE_STRING_VALUE: Offset = Offset(),
    ZERO_STRING_VALUEOffset ZERO_STRING_VALUE: Offset = Offset(),
    INITIAL_VALUE: Bool = false
  ) -> Offset {
    let __start = BooleanParameterType.startBooleanParameterType(&fbb)
    BooleanParameterType.add(NAME: NAME, &fbb)
    BooleanParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    BooleanParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    BooleanParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    BooleanParameterType.add(ONE_STRING_VALUE: ONE_STRING_VALUE, &fbb)
    BooleanParameterType.add(ZERO_STRING_VALUE: ZERO_STRING_VALUE, &fbb)
    BooleanParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return BooleanParameterType.endBooleanParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.ONE_STRING_VALUE.p, fieldName: "ONE_STRING_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ZERO_STRING_VALUE.p, fieldName: "ZERO_STRING_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Enumerated parameter type
public struct EnumeratedParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EnumeratedParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case DEFAULT_ALARM = 12
    case CONTEXT_ALARMS = 14
    case ENUMERATION_LIST = 16
    case INITIAL_VALUE = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Enumeration values list
  public var hasEnumerationList: Bool { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? false : true }
  public var ENUMERATION_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENUMERATION_LIST(at index: Int32) -> EnumerationValue? { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? nil : EnumerationValue(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Initial/default value label
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startEnumeratedParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func addVectorOf(ENUMERATION_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENUMERATION_LIST, at: VTOFFSET.ENUMERATION_LIST.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endEnumeratedParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEnumeratedParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset(),
    ENUMERATION_LISTVectorOffset ENUMERATION_LIST: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = EnumeratedParameterType.startEnumeratedParameterType(&fbb)
    EnumeratedParameterType.add(NAME: NAME, &fbb)
    EnumeratedParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    EnumeratedParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    EnumeratedParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    EnumeratedParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    EnumeratedParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    EnumeratedParameterType.addVectorOf(ENUMERATION_LIST: ENUMERATION_LIST, &fbb)
    EnumeratedParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return EnumeratedParameterType.endEnumeratedParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    try _v.visit(field: VTOFFSET.ENUMERATION_LIST.p, fieldName: "ENUMERATION_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<EnumerationValue>, EnumerationValue>>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Binary parameter type
public struct BinaryParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BinaryParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case INITIAL_VALUE = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: BinaryDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : BinaryDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Initial/default value (hex string)
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startBinaryParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endBinaryParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBinaryParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = BinaryParameterType.startBinaryParameterType(&fbb)
    BinaryParameterType.add(NAME: NAME, &fbb)
    BinaryParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    BinaryParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    BinaryParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    BinaryParameterType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return BinaryParameterType.endBinaryParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<BinaryDataEncoding>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Absolute time parameter type
public struct AbsoluteTimeParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AbsoluteTimeParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case EPOCH = 10
    case EPOCH_DATE = 12
    case DATA_ENCODING = 14
    case SCALE = 16
    case OFFSET = 18
    case DEFAULT_ALARM = 20
    case CONTEXT_ALARMS = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Reference epoch
  public var EPOCH: EpochType { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? .unix : EpochType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .unix }
  ///  Custom epoch date (ISO 8601) when EPOCH=CUSTOM
  public var EPOCH_DATE: String? { let o = _accessor.offset(VTOFFSET.EPOCH_DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCH_DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH_DATE.v) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Time unit scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time unit offset
  public var OFFSET: Double { let o = _accessor.offset(VTOFFSET.OFFSET.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startAbsoluteTimeParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(EPOCH: EpochType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EPOCH.rawValue, def: 2, at: VTOFFSET.EPOCH.p) }
  public static func add(EPOCH_DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH_DATE, at: VTOFFSET.EPOCH_DATE.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func add(OFFSET: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OFFSET, def: 0.0, at: VTOFFSET.OFFSET.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func endAbsoluteTimeParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAbsoluteTimeParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    EPOCH: EpochType = .unix,
    EPOCH_DATEOffset EPOCH_DATE: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    SCALE: Double = 0.0,
    OFFSET: Double = 0.0,
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset()
  ) -> Offset {
    let __start = AbsoluteTimeParameterType.startAbsoluteTimeParameterType(&fbb)
    AbsoluteTimeParameterType.add(NAME: NAME, &fbb)
    AbsoluteTimeParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    AbsoluteTimeParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    AbsoluteTimeParameterType.add(EPOCH: EPOCH, &fbb)
    AbsoluteTimeParameterType.add(EPOCH_DATE: EPOCH_DATE, &fbb)
    AbsoluteTimeParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    AbsoluteTimeParameterType.add(SCALE: SCALE, &fbb)
    AbsoluteTimeParameterType.add(OFFSET: OFFSET, &fbb)
    AbsoluteTimeParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    AbsoluteTimeParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    return AbsoluteTimeParameterType.endAbsoluteTimeParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: EpochType.self)
    try _v.visit(field: VTOFFSET.EPOCH_DATE.p, fieldName: "EPOCH_DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OFFSET.p, fieldName: "OFFSET", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    _v.finish()
  }
}

///  Relative time parameter type
public struct RelativeTimeParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RelativeTimeParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case UNITS = 10
    case DATA_ENCODING = 12
    case DEFAULT_ALARM = 14
    case CONTEXT_ALARMS = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Units
  public var hasUnits: Bool { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? false : true }
  public var UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func UNITS(at index: Int32) -> Unit? { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? nil : Unit(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Default alarm
  public var DEFAULT_ALARM: DefaultAlarm? { let o = _accessor.offset(VTOFFSET.DEFAULT_ALARM.v); return o == 0 ? nil : DefaultAlarm(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Context alarms
  public var hasContextAlarms: Bool { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? false : true }
  public var CONTEXT_ALARMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTEXT_ALARMS(at index: Int32) -> ContextAlarm? { let o = _accessor.offset(VTOFFSET.CONTEXT_ALARMS.v); return o == 0 ? nil : ContextAlarm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startRelativeTimeParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UNITS, at: VTOFFSET.UNITS.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(DEFAULT_ALARM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_ALARM, at: VTOFFSET.DEFAULT_ALARM.p) }
  public static func addVectorOf(CONTEXT_ALARMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT_ALARMS, at: VTOFFSET.CONTEXT_ALARMS.p) }
  public static func endRelativeTimeParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRelativeTimeParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    UNITSVectorOffset UNITS: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    DEFAULT_ALARMOffset DEFAULT_ALARM: Offset = Offset(),
    CONTEXT_ALARMSVectorOffset CONTEXT_ALARMS: Offset = Offset()
  ) -> Offset {
    let __start = RelativeTimeParameterType.startRelativeTimeParameterType(&fbb)
    RelativeTimeParameterType.add(NAME: NAME, &fbb)
    RelativeTimeParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    RelativeTimeParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    RelativeTimeParameterType.addVectorOf(UNITS: UNITS, &fbb)
    RelativeTimeParameterType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    RelativeTimeParameterType.add(DEFAULT_ALARM: DEFAULT_ALARM, &fbb)
    RelativeTimeParameterType.addVectorOf(CONTEXT_ALARMS: CONTEXT_ALARMS, &fbb)
    return RelativeTimeParameterType.endRelativeTimeParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UNITS.p, fieldName: "UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<Unit>, Unit>>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_ALARM.p, fieldName: "DEFAULT_ALARM", required: false, type: ForwardOffset<DefaultAlarm>.self)
    try _v.visit(field: VTOFFSET.CONTEXT_ALARMS.p, fieldName: "CONTEXT_ALARMS", required: false, type: ForwardOffset<Vector<ForwardOffset<ContextAlarm>, ContextAlarm>>.self)
    _v.finish()
  }
}

///  Array dimension specification
public struct ArrayDimension: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArrayDimension.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SIZE = 4
    case SIZE_PARAMETER_REF = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Fixed size of this dimension
  public var SIZE: UInt32 { let o = _accessor.offset(VTOFFSET.SIZE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Dynamic size from parameter reference
  public var SIZE_PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.SIZE_PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SIZE_PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SIZE_PARAMETER_REF.v) }
  public static func startArrayDimension(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(SIZE: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE, def: 0, at: VTOFFSET.SIZE.p) }
  public static func add(SIZE_PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIZE_PARAMETER_REF, at: VTOFFSET.SIZE_PARAMETER_REF.p) }
  public static func endArrayDimension(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArrayDimension(
    _ fbb: inout FlatBufferBuilder,
    SIZE: UInt32 = 0,
    SIZE_PARAMETER_REFOffset SIZE_PARAMETER_REF: Offset = Offset()
  ) -> Offset {
    let __start = ArrayDimension.startArrayDimension(&fbb)
    ArrayDimension.add(SIZE: SIZE, &fbb)
    ArrayDimension.add(SIZE_PARAMETER_REF: SIZE_PARAMETER_REF, &fbb)
    return ArrayDimension.endArrayDimension(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SIZE.p, fieldName: "SIZE", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.SIZE_PARAMETER_REF.p, fieldName: "SIZE_PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Array parameter type
public struct ArrayParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArrayParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case ARRAY_TYPE_REF = 10
    case DIMENSIONS = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Reference to the array element type
  public var ARRAY_TYPE_REF: String? { let o = _accessor.offset(VTOFFSET.ARRAY_TYPE_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ARRAY_TYPE_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ARRAY_TYPE_REF.v) }
  ///  Dimension list
  public var hasDimensions: Bool { let o = _accessor.offset(VTOFFSET.DIMENSIONS.v); return o == 0 ? false : true }
  public var DIMENSIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.DIMENSIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DIMENSIONS(at index: Int32) -> ArrayDimension? { let o = _accessor.offset(VTOFFSET.DIMENSIONS.v); return o == 0 ? nil : ArrayDimension(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startArrayParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(ARRAY_TYPE_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARRAY_TYPE_REF, at: VTOFFSET.ARRAY_TYPE_REF.p) }
  public static func addVectorOf(DIMENSIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DIMENSIONS, at: VTOFFSET.DIMENSIONS.p) }
  public static func endArrayParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArrayParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    ARRAY_TYPE_REFOffset ARRAY_TYPE_REF: Offset = Offset(),
    DIMENSIONSVectorOffset DIMENSIONS: Offset = Offset()
  ) -> Offset {
    let __start = ArrayParameterType.startArrayParameterType(&fbb)
    ArrayParameterType.add(NAME: NAME, &fbb)
    ArrayParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    ArrayParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    ArrayParameterType.add(ARRAY_TYPE_REF: ARRAY_TYPE_REF, &fbb)
    ArrayParameterType.addVectorOf(DIMENSIONS: DIMENSIONS, &fbb)
    return ArrayParameterType.endArrayParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ARRAY_TYPE_REF.p, fieldName: "ARRAY_TYPE_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DIMENSIONS.p, fieldName: "DIMENSIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<ArrayDimension>, ArrayDimension>>.self)
    _v.finish()
  }
}

///  Aggregate member definition
public struct AggregateMember: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AggregateMember.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case TYPE_REF = 6
    case SHORT_DESCRIPTION = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Member name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Reference to parameter type
  public var TYPE_REF: String? { let o = _accessor.offset(VTOFFSET.TYPE_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPE_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE_REF.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  public static func startAggregateMember(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(TYPE_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE_REF, at: VTOFFSET.TYPE_REF.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func endAggregateMember(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAggregateMember(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    TYPE_REFOffset TYPE_REF: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset()
  ) -> Offset {
    let __start = AggregateMember.startAggregateMember(&fbb)
    AggregateMember.add(NAME: NAME, &fbb)
    AggregateMember.add(TYPE_REF: TYPE_REF, &fbb)
    AggregateMember.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    return AggregateMember.endAggregateMember(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TYPE_REF.p, fieldName: "TYPE_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Aggregate parameter type (structure)
public struct AggregateParameterType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AggregateParameterType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case MEMBERS = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Member list
  public var hasMembers: Bool { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? false : true }
  public var MEMBERSCount: Int32 { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MEMBERS(at index: Int32) -> AggregateMember? { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? nil : AggregateMember(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startAggregateParameterType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(MEMBERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MEMBERS, at: VTOFFSET.MEMBERS.p) }
  public static func endAggregateParameterType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAggregateParameterType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    MEMBERSVectorOffset MEMBERS: Offset = Offset()
  ) -> Offset {
    let __start = AggregateParameterType.startAggregateParameterType(&fbb)
    AggregateParameterType.add(NAME: NAME, &fbb)
    AggregateParameterType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    AggregateParameterType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    AggregateParameterType.addVectorOf(MEMBERS: MEMBERS, &fbb)
    return AggregateParameterType.endAggregateParameterType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MEMBERS.p, fieldName: "MEMBERS", required: false, type: ForwardOffset<Vector<ForwardOffset<AggregateMember>, AggregateMember>>.self)
    _v.finish()
  }
}

///  Collection of all parameter types
public struct ParameterTypeSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ParameterTypeSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case INTEGER_TYPES = 4
    case FLOAT_TYPES = 6
    case STRING_TYPES = 8
    case BOOLEAN_TYPES = 10
    case ENUMERATED_TYPES = 12
    case BINARY_TYPES = 14
    case ABSOLUTE_TIME_TYPES = 16
    case RELATIVE_TIME_TYPES = 18
    case ARRAY_TYPES = 20
    case AGGREGATE_TYPES = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Integer parameter types
  public var hasIntegerTypes: Bool { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? false : true }
  public var INTEGER_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INTEGER_TYPES(at index: Int32) -> IntegerParameterType? { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? nil : IntegerParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Float parameter types
  public var hasFloatTypes: Bool { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? false : true }
  public var FLOAT_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FLOAT_TYPES(at index: Int32) -> FloatParameterType? { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? nil : FloatParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  String parameter types
  public var hasStringTypes: Bool { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? false : true }
  public var STRING_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STRING_TYPES(at index: Int32) -> StringParameterType? { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? nil : StringParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Boolean parameter types
  public var hasBooleanTypes: Bool { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? false : true }
  public var BOOLEAN_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func BOOLEAN_TYPES(at index: Int32) -> BooleanParameterType? { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? nil : BooleanParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Enumerated parameter types
  public var hasEnumeratedTypes: Bool { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? false : true }
  public var ENUMERATED_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENUMERATED_TYPES(at index: Int32) -> EnumeratedParameterType? { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? nil : EnumeratedParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Binary parameter types
  public var hasBinaryTypes: Bool { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? false : true }
  public var BINARY_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func BINARY_TYPES(at index: Int32) -> BinaryParameterType? { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? nil : BinaryParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Absolute time parameter types
  public var hasAbsoluteTimeTypes: Bool { let o = _accessor.offset(VTOFFSET.ABSOLUTE_TIME_TYPES.v); return o == 0 ? false : true }
  public var ABSOLUTE_TIME_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.ABSOLUTE_TIME_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ABSOLUTE_TIME_TYPES(at index: Int32) -> AbsoluteTimeParameterType? { let o = _accessor.offset(VTOFFSET.ABSOLUTE_TIME_TYPES.v); return o == 0 ? nil : AbsoluteTimeParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Relative time parameter types
  public var hasRelativeTimeTypes: Bool { let o = _accessor.offset(VTOFFSET.RELATIVE_TIME_TYPES.v); return o == 0 ? false : true }
  public var RELATIVE_TIME_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.RELATIVE_TIME_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RELATIVE_TIME_TYPES(at index: Int32) -> RelativeTimeParameterType? { let o = _accessor.offset(VTOFFSET.RELATIVE_TIME_TYPES.v); return o == 0 ? nil : RelativeTimeParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Array parameter types
  public var hasArrayTypes: Bool { let o = _accessor.offset(VTOFFSET.ARRAY_TYPES.v); return o == 0 ? false : true }
  public var ARRAY_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.ARRAY_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ARRAY_TYPES(at index: Int32) -> ArrayParameterType? { let o = _accessor.offset(VTOFFSET.ARRAY_TYPES.v); return o == 0 ? nil : ArrayParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Aggregate parameter types
  public var hasAggregateTypes: Bool { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? false : true }
  public var AGGREGATE_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func AGGREGATE_TYPES(at index: Int32) -> AggregateParameterType? { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? nil : AggregateParameterType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startParameterTypeSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func addVectorOf(INTEGER_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTEGER_TYPES, at: VTOFFSET.INTEGER_TYPES.p) }
  public static func addVectorOf(FLOAT_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FLOAT_TYPES, at: VTOFFSET.FLOAT_TYPES.p) }
  public static func addVectorOf(STRING_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STRING_TYPES, at: VTOFFSET.STRING_TYPES.p) }
  public static func addVectorOf(BOOLEAN_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BOOLEAN_TYPES, at: VTOFFSET.BOOLEAN_TYPES.p) }
  public static func addVectorOf(ENUMERATED_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENUMERATED_TYPES, at: VTOFFSET.ENUMERATED_TYPES.p) }
  public static func addVectorOf(BINARY_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BINARY_TYPES, at: VTOFFSET.BINARY_TYPES.p) }
  public static func addVectorOf(ABSOLUTE_TIME_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ABSOLUTE_TIME_TYPES, at: VTOFFSET.ABSOLUTE_TIME_TYPES.p) }
  public static func addVectorOf(RELATIVE_TIME_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RELATIVE_TIME_TYPES, at: VTOFFSET.RELATIVE_TIME_TYPES.p) }
  public static func addVectorOf(ARRAY_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARRAY_TYPES, at: VTOFFSET.ARRAY_TYPES.p) }
  public static func addVectorOf(AGGREGATE_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AGGREGATE_TYPES, at: VTOFFSET.AGGREGATE_TYPES.p) }
  public static func endParameterTypeSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameterTypeSet(
    _ fbb: inout FlatBufferBuilder,
    INTEGER_TYPESVectorOffset INTEGER_TYPES: Offset = Offset(),
    FLOAT_TYPESVectorOffset FLOAT_TYPES: Offset = Offset(),
    STRING_TYPESVectorOffset STRING_TYPES: Offset = Offset(),
    BOOLEAN_TYPESVectorOffset BOOLEAN_TYPES: Offset = Offset(),
    ENUMERATED_TYPESVectorOffset ENUMERATED_TYPES: Offset = Offset(),
    BINARY_TYPESVectorOffset BINARY_TYPES: Offset = Offset(),
    ABSOLUTE_TIME_TYPESVectorOffset ABSOLUTE_TIME_TYPES: Offset = Offset(),
    RELATIVE_TIME_TYPESVectorOffset RELATIVE_TIME_TYPES: Offset = Offset(),
    ARRAY_TYPESVectorOffset ARRAY_TYPES: Offset = Offset(),
    AGGREGATE_TYPESVectorOffset AGGREGATE_TYPES: Offset = Offset()
  ) -> Offset {
    let __start = ParameterTypeSet.startParameterTypeSet(&fbb)
    ParameterTypeSet.addVectorOf(INTEGER_TYPES: INTEGER_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(FLOAT_TYPES: FLOAT_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(STRING_TYPES: STRING_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(BOOLEAN_TYPES: BOOLEAN_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(ENUMERATED_TYPES: ENUMERATED_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(BINARY_TYPES: BINARY_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(ABSOLUTE_TIME_TYPES: ABSOLUTE_TIME_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(RELATIVE_TIME_TYPES: RELATIVE_TIME_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(ARRAY_TYPES: ARRAY_TYPES, &fbb)
    ParameterTypeSet.addVectorOf(AGGREGATE_TYPES: AGGREGATE_TYPES, &fbb)
    return ParameterTypeSet.endParameterTypeSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.INTEGER_TYPES.p, fieldName: "INTEGER_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<IntegerParameterType>, IntegerParameterType>>.self)
    try _v.visit(field: VTOFFSET.FLOAT_TYPES.p, fieldName: "FLOAT_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<FloatParameterType>, FloatParameterType>>.self)
    try _v.visit(field: VTOFFSET.STRING_TYPES.p, fieldName: "STRING_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<StringParameterType>, StringParameterType>>.self)
    try _v.visit(field: VTOFFSET.BOOLEAN_TYPES.p, fieldName: "BOOLEAN_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<BooleanParameterType>, BooleanParameterType>>.self)
    try _v.visit(field: VTOFFSET.ENUMERATED_TYPES.p, fieldName: "ENUMERATED_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<EnumeratedParameterType>, EnumeratedParameterType>>.self)
    try _v.visit(field: VTOFFSET.BINARY_TYPES.p, fieldName: "BINARY_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<BinaryParameterType>, BinaryParameterType>>.self)
    try _v.visit(field: VTOFFSET.ABSOLUTE_TIME_TYPES.p, fieldName: "ABSOLUTE_TIME_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<AbsoluteTimeParameterType>, AbsoluteTimeParameterType>>.self)
    try _v.visit(field: VTOFFSET.RELATIVE_TIME_TYPES.p, fieldName: "RELATIVE_TIME_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<RelativeTimeParameterType>, RelativeTimeParameterType>>.self)
    try _v.visit(field: VTOFFSET.ARRAY_TYPES.p, fieldName: "ARRAY_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<ArrayParameterType>, ArrayParameterType>>.self)
    try _v.visit(field: VTOFFSET.AGGREGATE_TYPES.p, fieldName: "AGGREGATE_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<AggregateParameterType>, AggregateParameterType>>.self)
    _v.finish()
  }
}

///  Parameter properties
public struct ParameterProperties: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ParameterProperties.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case DATA_SOURCE = 4
    case READ_ONLY = 6
    case SYSTEM_NAME = 8
    case VALIDITY_CONDITION = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Data source type
  public var DATA_SOURCE: DataSourceType { let o = _accessor.offset(VTOFFSET.DATA_SOURCE.v); return o == 0 ? .telemetered : DataSourceType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .telemetered }
  ///  Read-only parameter
  public var READ_ONLY: Bool { let o = _accessor.offset(VTOFFSET.READ_ONLY.v); return o == 0 ? true : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  System/subsystem name
  public var SYSTEM_NAME: String? { let o = _accessor.offset(VTOFFSET.SYSTEM_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SYSTEM_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SYSTEM_NAME.v) }
  ///  Validity condition
  public var VALIDITY_CONDITION: MatchCriteria? { let o = _accessor.offset(VTOFFSET.VALIDITY_CONDITION.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startParameterProperties(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(DATA_SOURCE: DataSourceType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DATA_SOURCE.rawValue, def: 0, at: VTOFFSET.DATA_SOURCE.p) }
  public static func add(READ_ONLY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: READ_ONLY, def: true,
   at: VTOFFSET.READ_ONLY.p) }
  public static func add(SYSTEM_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SYSTEM_NAME, at: VTOFFSET.SYSTEM_NAME.p) }
  public static func add(VALIDITY_CONDITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALIDITY_CONDITION, at: VTOFFSET.VALIDITY_CONDITION.p) }
  public static func endParameterProperties(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameterProperties(
    _ fbb: inout FlatBufferBuilder,
    DATA_SOURCE: DataSourceType = .telemetered,
    READ_ONLY: Bool = true,
    SYSTEM_NAMEOffset SYSTEM_NAME: Offset = Offset(),
    VALIDITY_CONDITIONOffset VALIDITY_CONDITION: Offset = Offset()
  ) -> Offset {
    let __start = ParameterProperties.startParameterProperties(&fbb)
    ParameterProperties.add(DATA_SOURCE: DATA_SOURCE, &fbb)
    ParameterProperties.add(READ_ONLY: READ_ONLY, &fbb)
    ParameterProperties.add(SYSTEM_NAME: SYSTEM_NAME, &fbb)
    ParameterProperties.add(VALIDITY_CONDITION: VALIDITY_CONDITION, &fbb)
    return ParameterProperties.endParameterProperties(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.DATA_SOURCE.p, fieldName: "DATA_SOURCE", required: false, type: DataSourceType.self)
    try _v.visit(field: VTOFFSET.READ_ONLY.p, fieldName: "READ_ONLY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.SYSTEM_NAME.p, fieldName: "SYSTEM_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALIDITY_CONDITION.p, fieldName: "VALIDITY_CONDITION", required: false, type: ForwardOffset<MatchCriteria>.self)
    _v.finish()
  }
}

///  Parameter definition
public struct Parameter: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Parameter.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case PARAMETER_TYPE_REF = 6
    case SHORT_DESCRIPTION = 8
    case LONG_DESCRIPTION = 10
    case PROPERTIES = 12
    case PHYSICAL_ADDRESS = 14
    case INITIAL_VALUE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Reference to parameter type
  public var PARAMETER_TYPE_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_TYPE_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_TYPE_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_TYPE_REF.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Parameter properties
  public var PROPERTIES: ParameterProperties? { let o = _accessor.offset(VTOFFSET.PROPERTIES.v); return o == 0 ? nil : ParameterProperties(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Physical address mapping
  public var PHYSICAL_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.PHYSICAL_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PHYSICAL_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PHYSICAL_ADDRESS.v) }
  ///  Initial/default value
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startParameter(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(PARAMETER_TYPE_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_TYPE_REF, at: VTOFFSET.PARAMETER_TYPE_REF.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(PROPERTIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROPERTIES, at: VTOFFSET.PROPERTIES.p) }
  public static func add(PHYSICAL_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PHYSICAL_ADDRESS, at: VTOFFSET.PHYSICAL_ADDRESS.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endParameter(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameter(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    PARAMETER_TYPE_REFOffset PARAMETER_TYPE_REF: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    PROPERTIESOffset PROPERTIES: Offset = Offset(),
    PHYSICAL_ADDRESSOffset PHYSICAL_ADDRESS: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = Parameter.startParameter(&fbb)
    Parameter.add(NAME: NAME, &fbb)
    Parameter.add(PARAMETER_TYPE_REF: PARAMETER_TYPE_REF, &fbb)
    Parameter.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    Parameter.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    Parameter.add(PROPERTIES: PROPERTIES, &fbb)
    Parameter.add(PHYSICAL_ADDRESS: PHYSICAL_ADDRESS, &fbb)
    Parameter.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return Parameter.endParameter(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PARAMETER_TYPE_REF.p, fieldName: "PARAMETER_TYPE_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROPERTIES.p, fieldName: "PROPERTIES", required: false, type: ForwardOffset<ParameterProperties>.self)
    try _v.visit(field: VTOFFSET.PHYSICAL_ADDRESS.p, fieldName: "PHYSICAL_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of parameters
public struct ParameterSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ParameterSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETERS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameters
  public var hasParameters: Bool { let o = _accessor.offset(VTOFFSET.PARAMETERS.v); return o == 0 ? false : true }
  public var PARAMETERSCount: Int32 { let o = _accessor.offset(VTOFFSET.PARAMETERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PARAMETERS(at index: Int32) -> Parameter? { let o = _accessor.offset(VTOFFSET.PARAMETERS.v); return o == 0 ? nil : Parameter(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startParameterSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETERS, at: VTOFFSET.PARAMETERS.p) }
  public static func endParameterSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameterSet(
    _ fbb: inout FlatBufferBuilder,
    PARAMETERSVectorOffset PARAMETERS: Offset = Offset()
  ) -> Offset {
    let __start = ParameterSet.startParameterSet(&fbb)
    ParameterSet.addVectorOf(PARAMETERS: PARAMETERS, &fbb)
    return ParameterSet.endParameterSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETERS.p, fieldName: "PARAMETERS", required: false, type: ForwardOffset<Vector<ForwardOffset<Parameter>, Parameter>>.self)
    _v.finish()
  }
}

///  Location specification within a container
public struct LocationInContainer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: LocationInContainer.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case REFERENCE_LOCATION = 4
    case OFFSET_IN_BITS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Reference location type
  public var REFERENCE_LOCATION: ReferenceLocationType { let o = _accessor.offset(VTOFFSET.REFERENCE_LOCATION.v); return o == 0 ? .previousEntry : ReferenceLocationType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .previousEntry }
  ///  Offset in bits from reference location
  public var OFFSET_IN_BITS: Int32 { let o = _accessor.offset(VTOFFSET.OFFSET_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startLocationInContainer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(REFERENCE_LOCATION: ReferenceLocationType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REFERENCE_LOCATION.rawValue, def: 2, at: VTOFFSET.REFERENCE_LOCATION.p) }
  public static func add(OFFSET_IN_BITS: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OFFSET_IN_BITS, def: 0, at: VTOFFSET.OFFSET_IN_BITS.p) }
  public static func endLocationInContainer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createLocationInContainer(
    _ fbb: inout FlatBufferBuilder,
    REFERENCE_LOCATION: ReferenceLocationType = .previousEntry,
    OFFSET_IN_BITS: Int32 = 0
  ) -> Offset {
    let __start = LocationInContainer.startLocationInContainer(&fbb)
    LocationInContainer.add(REFERENCE_LOCATION: REFERENCE_LOCATION, &fbb)
    LocationInContainer.add(OFFSET_IN_BITS: OFFSET_IN_BITS, &fbb)
    return LocationInContainer.endLocationInContainer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.REFERENCE_LOCATION.p, fieldName: "REFERENCE_LOCATION", required: false, type: ReferenceLocationType.self)
    try _v.visit(field: VTOFFSET.OFFSET_IN_BITS.p, fieldName: "OFFSET_IN_BITS", required: false, type: Int32.self)
    _v.finish()
  }
}

///  Repeat entry specification
public struct RepeatEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RepeatEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COUNT = 4
    case COUNT_PARAMETER_REF = 6
    case OFFSET_IN_BITS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Fixed repeat count
  public var COUNT: UInt32 { let o = _accessor.offset(VTOFFSET.COUNT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Dynamic count from parameter reference
  public var COUNT_PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.COUNT_PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COUNT_PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COUNT_PARAMETER_REF.v) }
  ///  Offset in bits between repetitions
  public var OFFSET_IN_BITS: Int32 { let o = _accessor.offset(VTOFFSET.OFFSET_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startRepeatEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(COUNT: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COUNT, def: 0, at: VTOFFSET.COUNT.p) }
  public static func add(COUNT_PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COUNT_PARAMETER_REF, at: VTOFFSET.COUNT_PARAMETER_REF.p) }
  public static func add(OFFSET_IN_BITS: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OFFSET_IN_BITS, def: 0, at: VTOFFSET.OFFSET_IN_BITS.p) }
  public static func endRepeatEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRepeatEntry(
    _ fbb: inout FlatBufferBuilder,
    COUNT: UInt32 = 0,
    COUNT_PARAMETER_REFOffset COUNT_PARAMETER_REF: Offset = Offset(),
    OFFSET_IN_BITS: Int32 = 0
  ) -> Offset {
    let __start = RepeatEntry.startRepeatEntry(&fbb)
    RepeatEntry.add(COUNT: COUNT, &fbb)
    RepeatEntry.add(COUNT_PARAMETER_REF: COUNT_PARAMETER_REF, &fbb)
    RepeatEntry.add(OFFSET_IN_BITS: OFFSET_IN_BITS, &fbb)
    return RepeatEntry.endRepeatEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COUNT.p, fieldName: "COUNT", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.COUNT_PARAMETER_REF.p, fieldName: "COUNT_PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OFFSET_IN_BITS.p, fieldName: "OFFSET_IN_BITS", required: false, type: Int32.self)
    _v.finish()
  }
}

///  Parameter reference entry in container
public struct ParameterRefEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ParameterRefEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case LOCATION = 6
    case REPEAT = 8
    case INCLUDE_CONDITION = 10
    case SHORT_DESCRIPTION = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference path
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Location in container
  public var LOCATION: LocationInContainer? { let o = _accessor.offset(VTOFFSET.LOCATION.v); return o == 0 ? nil : LocationInContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Repeat specification
  public var REPEAT: RepeatEntry? { let o = _accessor.offset(VTOFFSET.REPEAT.v); return o == 0 ? nil : RepeatEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Include condition
  public var INCLUDE_CONDITION: MatchCriteria? { let o = _accessor.offset(VTOFFSET.INCLUDE_CONDITION.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  public static func startParameterRefEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(LOCATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCATION, at: VTOFFSET.LOCATION.p) }
  public static func add(REPEAT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REPEAT, at: VTOFFSET.REPEAT.p) }
  public static func add(INCLUDE_CONDITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INCLUDE_CONDITION, at: VTOFFSET.INCLUDE_CONDITION.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func endParameterRefEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createParameterRefEntry(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    LOCATIONOffset LOCATION: Offset = Offset(),
    REPEATOffset REPEAT: Offset = Offset(),
    INCLUDE_CONDITIONOffset INCLUDE_CONDITION: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset()
  ) -> Offset {
    let __start = ParameterRefEntry.startParameterRefEntry(&fbb)
    ParameterRefEntry.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    ParameterRefEntry.add(LOCATION: LOCATION, &fbb)
    ParameterRefEntry.add(REPEAT: REPEAT, &fbb)
    ParameterRefEntry.add(INCLUDE_CONDITION: INCLUDE_CONDITION, &fbb)
    ParameterRefEntry.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    return ParameterRefEntry.endParameterRefEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCATION.p, fieldName: "LOCATION", required: false, type: ForwardOffset<LocationInContainer>.self)
    try _v.visit(field: VTOFFSET.REPEAT.p, fieldName: "REPEAT", required: false, type: ForwardOffset<RepeatEntry>.self)
    try _v.visit(field: VTOFFSET.INCLUDE_CONDITION.p, fieldName: "INCLUDE_CONDITION", required: false, type: ForwardOffset<MatchCriteria>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Container reference entry (nested container)
public struct ContainerRefEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContainerRefEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CONTAINER_REF = 4
    case LOCATION = 6
    case REPEAT = 8
    case INCLUDE_CONDITION = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Container reference path
  public var CONTAINER_REF: String? { let o = _accessor.offset(VTOFFSET.CONTAINER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTAINER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTAINER_REF.v) }
  ///  Location in container
  public var LOCATION: LocationInContainer? { let o = _accessor.offset(VTOFFSET.LOCATION.v); return o == 0 ? nil : LocationInContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Repeat specification
  public var REPEAT: RepeatEntry? { let o = _accessor.offset(VTOFFSET.REPEAT.v); return o == 0 ? nil : RepeatEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Include condition
  public var INCLUDE_CONDITION: MatchCriteria? { let o = _accessor.offset(VTOFFSET.INCLUDE_CONDITION.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startContainerRefEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(CONTAINER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REF, at: VTOFFSET.CONTAINER_REF.p) }
  public static func add(LOCATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCATION, at: VTOFFSET.LOCATION.p) }
  public static func add(REPEAT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REPEAT, at: VTOFFSET.REPEAT.p) }
  public static func add(INCLUDE_CONDITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INCLUDE_CONDITION, at: VTOFFSET.INCLUDE_CONDITION.p) }
  public static func endContainerRefEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContainerRefEntry(
    _ fbb: inout FlatBufferBuilder,
    CONTAINER_REFOffset CONTAINER_REF: Offset = Offset(),
    LOCATIONOffset LOCATION: Offset = Offset(),
    REPEATOffset REPEAT: Offset = Offset(),
    INCLUDE_CONDITIONOffset INCLUDE_CONDITION: Offset = Offset()
  ) -> Offset {
    let __start = ContainerRefEntry.startContainerRefEntry(&fbb)
    ContainerRefEntry.add(CONTAINER_REF: CONTAINER_REF, &fbb)
    ContainerRefEntry.add(LOCATION: LOCATION, &fbb)
    ContainerRefEntry.add(REPEAT: REPEAT, &fbb)
    ContainerRefEntry.add(INCLUDE_CONDITION: INCLUDE_CONDITION, &fbb)
    return ContainerRefEntry.endContainerRefEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CONTAINER_REF.p, fieldName: "CONTAINER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCATION.p, fieldName: "LOCATION", required: false, type: ForwardOffset<LocationInContainer>.self)
    try _v.visit(field: VTOFFSET.REPEAT.p, fieldName: "REPEAT", required: false, type: ForwardOffset<RepeatEntry>.self)
    try _v.visit(field: VTOFFSET.INCLUDE_CONDITION.p, fieldName: "INCLUDE_CONDITION", required: false, type: ForwardOffset<MatchCriteria>.self)
    _v.finish()
  }
}

///  Fixed value entry (static padding/header)
public struct FixedValueEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FixedValueEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case BINARY_VALUE = 4
    case SIZE_IN_BITS = 6
    case NAME = 8
    case LOCATION = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Binary value (hex string)
  public var BINARY_VALUE: String? { let o = _accessor.offset(VTOFFSET.BINARY_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var BINARY_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.BINARY_VALUE.v) }
  ///  Size in bits
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Name/description
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Location in container
  public var LOCATION: LocationInContainer? { let o = _accessor.offset(VTOFFSET.LOCATION.v); return o == 0 ? nil : LocationInContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startFixedValueEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(BINARY_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BINARY_VALUE, at: VTOFFSET.BINARY_VALUE.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(LOCATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCATION, at: VTOFFSET.LOCATION.p) }
  public static func endFixedValueEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFixedValueEntry(
    _ fbb: inout FlatBufferBuilder,
    BINARY_VALUEOffset BINARY_VALUE: Offset = Offset(),
    SIZE_IN_BITS: UInt16 = 0,
    NAMEOffset NAME: Offset = Offset(),
    LOCATIONOffset LOCATION: Offset = Offset()
  ) -> Offset {
    let __start = FixedValueEntry.startFixedValueEntry(&fbb)
    FixedValueEntry.add(BINARY_VALUE: BINARY_VALUE, &fbb)
    FixedValueEntry.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    FixedValueEntry.add(NAME: NAME, &fbb)
    FixedValueEntry.add(LOCATION: LOCATION, &fbb)
    return FixedValueEntry.endFixedValueEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.BINARY_VALUE.p, fieldName: "BINARY_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCATION.p, fieldName: "LOCATION", required: false, type: ForwardOffset<LocationInContainer>.self)
    _v.finish()
  }
}

///  Array parameter reference entry
public struct ArrayParameterRefEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArrayParameterRefEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case LOCATION = 6
    case FIRST_INDEX = 8
    case LAST_INDEX = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference path
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Location in container
  public var LOCATION: LocationInContainer? { let o = _accessor.offset(VTOFFSET.LOCATION.v); return o == 0 ? nil : LocationInContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  First index to include
  public var FIRST_INDEX: UInt32 { let o = _accessor.offset(VTOFFSET.FIRST_INDEX.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Last index to include
  public var LAST_INDEX: UInt32 { let o = _accessor.offset(VTOFFSET.LAST_INDEX.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startArrayParameterRefEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(LOCATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCATION, at: VTOFFSET.LOCATION.p) }
  public static func add(FIRST_INDEX: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FIRST_INDEX, def: 0, at: VTOFFSET.FIRST_INDEX.p) }
  public static func add(LAST_INDEX: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LAST_INDEX, def: 0, at: VTOFFSET.LAST_INDEX.p) }
  public static func endArrayParameterRefEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArrayParameterRefEntry(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    LOCATIONOffset LOCATION: Offset = Offset(),
    FIRST_INDEX: UInt32 = 0,
    LAST_INDEX: UInt32 = 0
  ) -> Offset {
    let __start = ArrayParameterRefEntry.startArrayParameterRefEntry(&fbb)
    ArrayParameterRefEntry.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    ArrayParameterRefEntry.add(LOCATION: LOCATION, &fbb)
    ArrayParameterRefEntry.add(FIRST_INDEX: FIRST_INDEX, &fbb)
    ArrayParameterRefEntry.add(LAST_INDEX: LAST_INDEX, &fbb)
    return ArrayParameterRefEntry.endArrayParameterRefEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCATION.p, fieldName: "LOCATION", required: false, type: ForwardOffset<LocationInContainer>.self)
    try _v.visit(field: VTOFFSET.FIRST_INDEX.p, fieldName: "FIRST_INDEX", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.LAST_INDEX.p, fieldName: "LAST_INDEX", required: false, type: UInt32.self)
    _v.finish()
  }
}

///  Container entry list item (union of entry types)
public struct ContainerEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContainerEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF_ENTRY = 4
    case CONTAINER_REF_ENTRY = 6
    case FIXED_VALUE_ENTRY = 8
    case ARRAY_PARAMETER_REF_ENTRY = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference entry
  public var PARAMETER_REF_ENTRY: ParameterRefEntry? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF_ENTRY.v); return o == 0 ? nil : ParameterRefEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Container reference entry
  public var CONTAINER_REF_ENTRY: ContainerRefEntry? { let o = _accessor.offset(VTOFFSET.CONTAINER_REF_ENTRY.v); return o == 0 ? nil : ContainerRefEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Fixed value entry
  public var FIXED_VALUE_ENTRY: FixedValueEntry? { let o = _accessor.offset(VTOFFSET.FIXED_VALUE_ENTRY.v); return o == 0 ? nil : FixedValueEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Array parameter reference entry
  public var ARRAY_PARAMETER_REF_ENTRY: ArrayParameterRefEntry? { let o = _accessor.offset(VTOFFSET.ARRAY_PARAMETER_REF_ENTRY.v); return o == 0 ? nil : ArrayParameterRefEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startContainerEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(PARAMETER_REF_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF_ENTRY, at: VTOFFSET.PARAMETER_REF_ENTRY.p) }
  public static func add(CONTAINER_REF_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REF_ENTRY, at: VTOFFSET.CONTAINER_REF_ENTRY.p) }
  public static func add(FIXED_VALUE_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FIXED_VALUE_ENTRY, at: VTOFFSET.FIXED_VALUE_ENTRY.p) }
  public static func add(ARRAY_PARAMETER_REF_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARRAY_PARAMETER_REF_ENTRY, at: VTOFFSET.ARRAY_PARAMETER_REF_ENTRY.p) }
  public static func endContainerEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContainerEntry(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REF_ENTRYOffset PARAMETER_REF_ENTRY: Offset = Offset(),
    CONTAINER_REF_ENTRYOffset CONTAINER_REF_ENTRY: Offset = Offset(),
    FIXED_VALUE_ENTRYOffset FIXED_VALUE_ENTRY: Offset = Offset(),
    ARRAY_PARAMETER_REF_ENTRYOffset ARRAY_PARAMETER_REF_ENTRY: Offset = Offset()
  ) -> Offset {
    let __start = ContainerEntry.startContainerEntry(&fbb)
    ContainerEntry.add(PARAMETER_REF_ENTRY: PARAMETER_REF_ENTRY, &fbb)
    ContainerEntry.add(CONTAINER_REF_ENTRY: CONTAINER_REF_ENTRY, &fbb)
    ContainerEntry.add(FIXED_VALUE_ENTRY: FIXED_VALUE_ENTRY, &fbb)
    ContainerEntry.add(ARRAY_PARAMETER_REF_ENTRY: ARRAY_PARAMETER_REF_ENTRY, &fbb)
    return ContainerEntry.endContainerEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF_ENTRY.p, fieldName: "PARAMETER_REF_ENTRY", required: false, type: ForwardOffset<ParameterRefEntry>.self)
    try _v.visit(field: VTOFFSET.CONTAINER_REF_ENTRY.p, fieldName: "CONTAINER_REF_ENTRY", required: false, type: ForwardOffset<ContainerRefEntry>.self)
    try _v.visit(field: VTOFFSET.FIXED_VALUE_ENTRY.p, fieldName: "FIXED_VALUE_ENTRY", required: false, type: ForwardOffset<FixedValueEntry>.self)
    try _v.visit(field: VTOFFSET.ARRAY_PARAMETER_REF_ENTRY.p, fieldName: "ARRAY_PARAMETER_REF_ENTRY", required: false, type: ForwardOffset<ArrayParameterRefEntry>.self)
    _v.finish()
  }
}

///  Base container reference with restriction
public struct BaseContainer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BaseContainer.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CONTAINER_REF = 4
    case RESTRICTION_CRITERIA = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Container reference path
  public var CONTAINER_REF: String? { let o = _accessor.offset(VTOFFSET.CONTAINER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTAINER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTAINER_REF.v) }
  ///  Restriction criteria
  public var RESTRICTION_CRITERIA: MatchCriteria? { let o = _accessor.offset(VTOFFSET.RESTRICTION_CRITERIA.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startBaseContainer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(CONTAINER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REF, at: VTOFFSET.CONTAINER_REF.p) }
  public static func add(RESTRICTION_CRITERIA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESTRICTION_CRITERIA, at: VTOFFSET.RESTRICTION_CRITERIA.p) }
  public static func endBaseContainer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBaseContainer(
    _ fbb: inout FlatBufferBuilder,
    CONTAINER_REFOffset CONTAINER_REF: Offset = Offset(),
    RESTRICTION_CRITERIAOffset RESTRICTION_CRITERIA: Offset = Offset()
  ) -> Offset {
    let __start = BaseContainer.startBaseContainer(&fbb)
    BaseContainer.add(CONTAINER_REF: CONTAINER_REF, &fbb)
    BaseContainer.add(RESTRICTION_CRITERIA: RESTRICTION_CRITERIA, &fbb)
    return BaseContainer.endBaseContainer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CONTAINER_REF.p, fieldName: "CONTAINER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RESTRICTION_CRITERIA.p, fieldName: "RESTRICTION_CRITERIA", required: false, type: ForwardOffset<MatchCriteria>.self)
    _v.finish()
  }
}

///  Rate specification for container in stream
public struct RateInStream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RateInStream.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case STREAM_REF = 4
    case RATE = 6
    case BASIS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Stream reference
  public var STREAM_REF: String? { let o = _accessor.offset(VTOFFSET.STREAM_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STREAM_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STREAM_REF.v) }
  ///  Rate value
  public var RATE: Double { let o = _accessor.offset(VTOFFSET.RATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rate basis
  public var BASIS: RateBasisType { let o = _accessor.offset(VTOFFSET.BASIS.v); return o == 0 ? .perSecond : RateBasisType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .perSecond }
  public static func startRateInStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(STREAM_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STREAM_REF, at: VTOFFSET.STREAM_REF.p) }
  public static func add(RATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RATE, def: 0.0, at: VTOFFSET.RATE.p) }
  public static func add(BASIS: RateBasisType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BASIS.rawValue, def: 0, at: VTOFFSET.BASIS.p) }
  public static func endRateInStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRateInStream(
    _ fbb: inout FlatBufferBuilder,
    STREAM_REFOffset STREAM_REF: Offset = Offset(),
    RATE: Double = 0.0,
    BASIS: RateBasisType = .perSecond
  ) -> Offset {
    let __start = RateInStream.startRateInStream(&fbb)
    RateInStream.add(STREAM_REF: STREAM_REF, &fbb)
    RateInStream.add(RATE: RATE, &fbb)
    RateInStream.add(BASIS: BASIS, &fbb)
    return RateInStream.endRateInStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.STREAM_REF.p, fieldName: "STREAM_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RATE.p, fieldName: "RATE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BASIS.p, fieldName: "BASIS", required: false, type: RateBasisType.self)
    _v.finish()
  }
}

///  Binary encoding specification for container
public struct ContainerBinaryEncoding: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContainerBinaryEncoding.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ERROR_DETECTION = 4
    case CRC_POLYNOMIAL = 6
    case SIZE_IN_BITS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Error detection type
  public var ERROR_DETECTION: ErrorDetectionType { let o = _accessor.offset(VTOFFSET.ERROR_DETECTION.v); return o == 0 ? .none_ : ErrorDetectionType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  ///  CRC polynomial (for CRC error detection)
  public var CRC_POLYNOMIAL: String? { let o = _accessor.offset(VTOFFSET.CRC_POLYNOMIAL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CRC_POLYNOMIALSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CRC_POLYNOMIAL.v) }
  ///  Size in bits
  public var SIZE_IN_BITS: UInt32 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startContainerBinaryEncoding(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ERROR_DETECTION: ErrorDetectionType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ERROR_DETECTION.rawValue, def: 0, at: VTOFFSET.ERROR_DETECTION.p) }
  public static func add(CRC_POLYNOMIAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CRC_POLYNOMIAL, at: VTOFFSET.CRC_POLYNOMIAL.p) }
  public static func add(SIZE_IN_BITS: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func endContainerBinaryEncoding(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContainerBinaryEncoding(
    _ fbb: inout FlatBufferBuilder,
    ERROR_DETECTION: ErrorDetectionType = .none_,
    CRC_POLYNOMIALOffset CRC_POLYNOMIAL: Offset = Offset(),
    SIZE_IN_BITS: UInt32 = 0
  ) -> Offset {
    let __start = ContainerBinaryEncoding.startContainerBinaryEncoding(&fbb)
    ContainerBinaryEncoding.add(ERROR_DETECTION: ERROR_DETECTION, &fbb)
    ContainerBinaryEncoding.add(CRC_POLYNOMIAL: CRC_POLYNOMIAL, &fbb)
    ContainerBinaryEncoding.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    return ContainerBinaryEncoding.endContainerBinaryEncoding(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ERROR_DETECTION.p, fieldName: "ERROR_DETECTION", required: false, type: ErrorDetectionType.self)
    try _v.visit(field: VTOFFSET.CRC_POLYNOMIAL.p, fieldName: "CRC_POLYNOMIAL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt32.self)
    _v.finish()
  }
}

///  Sequence container (packet definition)
public struct SequenceContainer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SequenceContainer.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case ABSTRACT = 10
    case ENTRY_LIST = 12
    case BASE_CONTAINER = 14
    case BINARY_ENCODING = 16
    case RATE_IN_STREAM = 18
    case IDLE_PATTERN = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Container name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Abstract container (used as base only)
  public var ABSTRACT: Bool { let o = _accessor.offset(VTOFFSET.ABSTRACT.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Container entry list
  public var hasEntryList: Bool { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? false : true }
  public var ENTRY_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENTRY_LIST(at index: Int32) -> ContainerEntry? { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? nil : ContainerEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Base container (inheritance)
  public var BASE_CONTAINER: BaseContainer? { let o = _accessor.offset(VTOFFSET.BASE_CONTAINER.v); return o == 0 ? nil : BaseContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Binary encoding
  public var BINARY_ENCODING: ContainerBinaryEncoding? { let o = _accessor.offset(VTOFFSET.BINARY_ENCODING.v); return o == 0 ? nil : ContainerBinaryEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Rate in stream
  public var RATE_IN_STREAM: RateInStream? { let o = _accessor.offset(VTOFFSET.RATE_IN_STREAM.v); return o == 0 ? nil : RateInStream(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Idle pattern (hex string for padding)
  public var IDLE_PATTERN: String? { let o = _accessor.offset(VTOFFSET.IDLE_PATTERN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDLE_PATTERNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IDLE_PATTERN.v) }
  public static func startSequenceContainer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(ABSTRACT: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ABSTRACT, def: false,
   at: VTOFFSET.ABSTRACT.p) }
  public static func addVectorOf(ENTRY_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENTRY_LIST, at: VTOFFSET.ENTRY_LIST.p) }
  public static func add(BASE_CONTAINER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BASE_CONTAINER, at: VTOFFSET.BASE_CONTAINER.p) }
  public static func add(BINARY_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BINARY_ENCODING, at: VTOFFSET.BINARY_ENCODING.p) }
  public static func add(RATE_IN_STREAM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RATE_IN_STREAM, at: VTOFFSET.RATE_IN_STREAM.p) }
  public static func add(IDLE_PATTERN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IDLE_PATTERN, at: VTOFFSET.IDLE_PATTERN.p) }
  public static func endSequenceContainer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSequenceContainer(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    ABSTRACT: Bool = false,
    ENTRY_LISTVectorOffset ENTRY_LIST: Offset = Offset(),
    BASE_CONTAINEROffset BASE_CONTAINER: Offset = Offset(),
    BINARY_ENCODINGOffset BINARY_ENCODING: Offset = Offset(),
    RATE_IN_STREAMOffset RATE_IN_STREAM: Offset = Offset(),
    IDLE_PATTERNOffset IDLE_PATTERN: Offset = Offset()
  ) -> Offset {
    let __start = SequenceContainer.startSequenceContainer(&fbb)
    SequenceContainer.add(NAME: NAME, &fbb)
    SequenceContainer.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    SequenceContainer.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    SequenceContainer.add(ABSTRACT: ABSTRACT, &fbb)
    SequenceContainer.addVectorOf(ENTRY_LIST: ENTRY_LIST, &fbb)
    SequenceContainer.add(BASE_CONTAINER: BASE_CONTAINER, &fbb)
    SequenceContainer.add(BINARY_ENCODING: BINARY_ENCODING, &fbb)
    SequenceContainer.add(RATE_IN_STREAM: RATE_IN_STREAM, &fbb)
    SequenceContainer.add(IDLE_PATTERN: IDLE_PATTERN, &fbb)
    return SequenceContainer.endSequenceContainer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ABSTRACT.p, fieldName: "ABSTRACT", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.ENTRY_LIST.p, fieldName: "ENTRY_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<ContainerEntry>, ContainerEntry>>.self)
    try _v.visit(field: VTOFFSET.BASE_CONTAINER.p, fieldName: "BASE_CONTAINER", required: false, type: ForwardOffset<BaseContainer>.self)
    try _v.visit(field: VTOFFSET.BINARY_ENCODING.p, fieldName: "BINARY_ENCODING", required: false, type: ForwardOffset<ContainerBinaryEncoding>.self)
    try _v.visit(field: VTOFFSET.RATE_IN_STREAM.p, fieldName: "RATE_IN_STREAM", required: false, type: ForwardOffset<RateInStream>.self)
    try _v.visit(field: VTOFFSET.IDLE_PATTERN.p, fieldName: "IDLE_PATTERN", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of sequence containers
public struct ContainerSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContainerSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CONTAINERS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Sequence containers
  public var hasContainers: Bool { let o = _accessor.offset(VTOFFSET.CONTAINERS.v); return o == 0 ? false : true }
  public var CONTAINERSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTAINERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTAINERS(at index: Int32) -> SequenceContainer? { let o = _accessor.offset(VTOFFSET.CONTAINERS.v); return o == 0 ? nil : SequenceContainer(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startContainerSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(CONTAINERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINERS, at: VTOFFSET.CONTAINERS.p) }
  public static func endContainerSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContainerSet(
    _ fbb: inout FlatBufferBuilder,
    CONTAINERSVectorOffset CONTAINERS: Offset = Offset()
  ) -> Offset {
    let __start = ContainerSet.startContainerSet(&fbb)
    ContainerSet.addVectorOf(CONTAINERS: CONTAINERS, &fbb)
    return ContainerSet.endContainerSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CONTAINERS.p, fieldName: "CONTAINERS", required: false, type: ForwardOffset<Vector<ForwardOffset<SequenceContainer>, SequenceContainer>>.self)
    _v.finish()
  }
}

///  Algorithm input binding
public struct AlgorithmInput: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AlgorithmInput.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case INPUT_NAME = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Input name in algorithm
  public var INPUT_NAME: String? { let o = _accessor.offset(VTOFFSET.INPUT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INPUT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INPUT_NAME.v) }
  public static func startAlgorithmInput(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(INPUT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INPUT_NAME, at: VTOFFSET.INPUT_NAME.p) }
  public static func endAlgorithmInput(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAlgorithmInput(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    INPUT_NAMEOffset INPUT_NAME: Offset = Offset()
  ) -> Offset {
    let __start = AlgorithmInput.startAlgorithmInput(&fbb)
    AlgorithmInput.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    AlgorithmInput.add(INPUT_NAME: INPUT_NAME, &fbb)
    return AlgorithmInput.endAlgorithmInput(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INPUT_NAME.p, fieldName: "INPUT_NAME", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Algorithm output binding
public struct AlgorithmOutput: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AlgorithmOutput.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case OUTPUT_NAME = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Output name in algorithm
  public var OUTPUT_NAME: String? { let o = _accessor.offset(VTOFFSET.OUTPUT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OUTPUT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OUTPUT_NAME.v) }
  public static func startAlgorithmOutput(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(OUTPUT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTPUT_NAME, at: VTOFFSET.OUTPUT_NAME.p) }
  public static func endAlgorithmOutput(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAlgorithmOutput(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    OUTPUT_NAMEOffset OUTPUT_NAME: Offset = Offset()
  ) -> Offset {
    let __start = AlgorithmOutput.startAlgorithmOutput(&fbb)
    AlgorithmOutput.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    AlgorithmOutput.add(OUTPUT_NAME: OUTPUT_NAME, &fbb)
    return AlgorithmOutput.endAlgorithmOutput(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OUTPUT_NAME.p, fieldName: "OUTPUT_NAME", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Trigger condition for algorithm execution
public struct AlgorithmTrigger: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AlgorithmTrigger.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case CONTAINER_REF = 6
    case RATE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Trigger on parameter update
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Trigger on container reception
  public var CONTAINER_REF: String? { let o = _accessor.offset(VTOFFSET.CONTAINER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTAINER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTAINER_REF.v) }
  ///  Trigger rate (per second)
  public var RATE: Double { let o = _accessor.offset(VTOFFSET.RATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startAlgorithmTrigger(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(CONTAINER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REF, at: VTOFFSET.CONTAINER_REF.p) }
  public static func add(RATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RATE, def: 0.0, at: VTOFFSET.RATE.p) }
  public static func endAlgorithmTrigger(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAlgorithmTrigger(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    CONTAINER_REFOffset CONTAINER_REF: Offset = Offset(),
    RATE: Double = 0.0
  ) -> Offset {
    let __start = AlgorithmTrigger.startAlgorithmTrigger(&fbb)
    AlgorithmTrigger.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    AlgorithmTrigger.add(CONTAINER_REF: CONTAINER_REF, &fbb)
    AlgorithmTrigger.add(RATE: RATE, &fbb)
    return AlgorithmTrigger.endAlgorithmTrigger(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTAINER_REF.p, fieldName: "CONTAINER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RATE.p, fieldName: "RATE", required: false, type: Double.self)
    _v.finish()
  }
}

///  Custom algorithm definition
public struct CustomAlgorithm: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CustomAlgorithm.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case LANGUAGE = 10
    case ALGORITHM_TEXT = 12
    case EXTERNAL_ALGORITHM_REF = 14
    case INPUTS = 16
    case OUTPUTS = 18
    case TRIGGERS = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Algorithm name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Programming language
  public var LANGUAGE: String? { let o = _accessor.offset(VTOFFSET.LANGUAGE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LANGUAGESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LANGUAGE.v) }
  ///  Algorithm text/code
  public var ALGORITHM_TEXT: String? { let o = _accessor.offset(VTOFFSET.ALGORITHM_TEXT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ALGORITHM_TEXTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ALGORITHM_TEXT.v) }
  ///  External algorithm reference
  public var EXTERNAL_ALGORITHM_REF: String? { let o = _accessor.offset(VTOFFSET.EXTERNAL_ALGORITHM_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EXTERNAL_ALGORITHM_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EXTERNAL_ALGORITHM_REF.v) }
  ///  Input bindings
  public var hasInputs: Bool { let o = _accessor.offset(VTOFFSET.INPUTS.v); return o == 0 ? false : true }
  public var INPUTSCount: Int32 { let o = _accessor.offset(VTOFFSET.INPUTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INPUTS(at index: Int32) -> AlgorithmInput? { let o = _accessor.offset(VTOFFSET.INPUTS.v); return o == 0 ? nil : AlgorithmInput(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Output bindings
  public var hasOutputs: Bool { let o = _accessor.offset(VTOFFSET.OUTPUTS.v); return o == 0 ? false : true }
  public var OUTPUTSCount: Int32 { let o = _accessor.offset(VTOFFSET.OUTPUTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OUTPUTS(at index: Int32) -> AlgorithmOutput? { let o = _accessor.offset(VTOFFSET.OUTPUTS.v); return o == 0 ? nil : AlgorithmOutput(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Trigger conditions
  public var hasTriggers: Bool { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? false : true }
  public var TRIGGERSCount: Int32 { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TRIGGERS(at index: Int32) -> AlgorithmTrigger? { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? nil : AlgorithmTrigger(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startCustomAlgorithm(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(LANGUAGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LANGUAGE, at: VTOFFSET.LANGUAGE.p) }
  public static func add(ALGORITHM_TEXT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALGORITHM_TEXT, at: VTOFFSET.ALGORITHM_TEXT.p) }
  public static func add(EXTERNAL_ALGORITHM_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EXTERNAL_ALGORITHM_REF, at: VTOFFSET.EXTERNAL_ALGORITHM_REF.p) }
  public static func addVectorOf(INPUTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INPUTS, at: VTOFFSET.INPUTS.p) }
  public static func addVectorOf(OUTPUTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTPUTS, at: VTOFFSET.OUTPUTS.p) }
  public static func addVectorOf(TRIGGERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRIGGERS, at: VTOFFSET.TRIGGERS.p) }
  public static func endCustomAlgorithm(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCustomAlgorithm(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    LANGUAGEOffset LANGUAGE: Offset = Offset(),
    ALGORITHM_TEXTOffset ALGORITHM_TEXT: Offset = Offset(),
    EXTERNAL_ALGORITHM_REFOffset EXTERNAL_ALGORITHM_REF: Offset = Offset(),
    INPUTSVectorOffset INPUTS: Offset = Offset(),
    OUTPUTSVectorOffset OUTPUTS: Offset = Offset(),
    TRIGGERSVectorOffset TRIGGERS: Offset = Offset()
  ) -> Offset {
    let __start = CustomAlgorithm.startCustomAlgorithm(&fbb)
    CustomAlgorithm.add(NAME: NAME, &fbb)
    CustomAlgorithm.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    CustomAlgorithm.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    CustomAlgorithm.add(LANGUAGE: LANGUAGE, &fbb)
    CustomAlgorithm.add(ALGORITHM_TEXT: ALGORITHM_TEXT, &fbb)
    CustomAlgorithm.add(EXTERNAL_ALGORITHM_REF: EXTERNAL_ALGORITHM_REF, &fbb)
    CustomAlgorithm.addVectorOf(INPUTS: INPUTS, &fbb)
    CustomAlgorithm.addVectorOf(OUTPUTS: OUTPUTS, &fbb)
    CustomAlgorithm.addVectorOf(TRIGGERS: TRIGGERS, &fbb)
    return CustomAlgorithm.endCustomAlgorithm(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LANGUAGE.p, fieldName: "LANGUAGE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALGORITHM_TEXT.p, fieldName: "ALGORITHM_TEXT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EXTERNAL_ALGORITHM_REF.p, fieldName: "EXTERNAL_ALGORITHM_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INPUTS.p, fieldName: "INPUTS", required: false, type: ForwardOffset<Vector<ForwardOffset<AlgorithmInput>, AlgorithmInput>>.self)
    try _v.visit(field: VTOFFSET.OUTPUTS.p, fieldName: "OUTPUTS", required: false, type: ForwardOffset<Vector<ForwardOffset<AlgorithmOutput>, AlgorithmOutput>>.self)
    try _v.visit(field: VTOFFSET.TRIGGERS.p, fieldName: "TRIGGERS", required: false, type: ForwardOffset<Vector<ForwardOffset<AlgorithmTrigger>, AlgorithmTrigger>>.self)
    _v.finish()
  }
}

///  Math algorithm (inline calculation)
public struct MathAlgorithm: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MathAlgorithm.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case MATH_OPERATION = 8
    case OUTPUT_PARAMETER_REF = 10
    case TRIGGERS = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Algorithm name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Math operation in RPN
  public var MATH_OPERATION: String? { let o = _accessor.offset(VTOFFSET.MATH_OPERATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MATH_OPERATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MATH_OPERATION.v) }
  ///  Output parameter reference
  public var OUTPUT_PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.OUTPUT_PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OUTPUT_PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OUTPUT_PARAMETER_REF.v) }
  ///  Trigger conditions
  public var hasTriggers: Bool { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? false : true }
  public var TRIGGERSCount: Int32 { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TRIGGERS(at index: Int32) -> AlgorithmTrigger? { let o = _accessor.offset(VTOFFSET.TRIGGERS.v); return o == 0 ? nil : AlgorithmTrigger(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startMathAlgorithm(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(MATH_OPERATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATH_OPERATION, at: VTOFFSET.MATH_OPERATION.p) }
  public static func add(OUTPUT_PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTPUT_PARAMETER_REF, at: VTOFFSET.OUTPUT_PARAMETER_REF.p) }
  public static func addVectorOf(TRIGGERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRIGGERS, at: VTOFFSET.TRIGGERS.p) }
  public static func endMathAlgorithm(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMathAlgorithm(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    MATH_OPERATIONOffset MATH_OPERATION: Offset = Offset(),
    OUTPUT_PARAMETER_REFOffset OUTPUT_PARAMETER_REF: Offset = Offset(),
    TRIGGERSVectorOffset TRIGGERS: Offset = Offset()
  ) -> Offset {
    let __start = MathAlgorithm.startMathAlgorithm(&fbb)
    MathAlgorithm.add(NAME: NAME, &fbb)
    MathAlgorithm.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    MathAlgorithm.add(MATH_OPERATION: MATH_OPERATION, &fbb)
    MathAlgorithm.add(OUTPUT_PARAMETER_REF: OUTPUT_PARAMETER_REF, &fbb)
    MathAlgorithm.addVectorOf(TRIGGERS: TRIGGERS, &fbb)
    return MathAlgorithm.endMathAlgorithm(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MATH_OPERATION.p, fieldName: "MATH_OPERATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OUTPUT_PARAMETER_REF.p, fieldName: "OUTPUT_PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRIGGERS.p, fieldName: "TRIGGERS", required: false, type: ForwardOffset<Vector<ForwardOffset<AlgorithmTrigger>, AlgorithmTrigger>>.self)
    _v.finish()
  }
}

///  Collection of algorithms
public struct AlgorithmSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AlgorithmSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CUSTOM_ALGORITHMS = 4
    case MATH_ALGORITHMS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Custom algorithms
  public var hasCustomAlgorithms: Bool { let o = _accessor.offset(VTOFFSET.CUSTOM_ALGORITHMS.v); return o == 0 ? false : true }
  public var CUSTOM_ALGORITHMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CUSTOM_ALGORITHMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CUSTOM_ALGORITHMS(at index: Int32) -> CustomAlgorithm? { let o = _accessor.offset(VTOFFSET.CUSTOM_ALGORITHMS.v); return o == 0 ? nil : CustomAlgorithm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Math algorithms
  public var hasMathAlgorithms: Bool { let o = _accessor.offset(VTOFFSET.MATH_ALGORITHMS.v); return o == 0 ? false : true }
  public var MATH_ALGORITHMSCount: Int32 { let o = _accessor.offset(VTOFFSET.MATH_ALGORITHMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MATH_ALGORITHMS(at index: Int32) -> MathAlgorithm? { let o = _accessor.offset(VTOFFSET.MATH_ALGORITHMS.v); return o == 0 ? nil : MathAlgorithm(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startAlgorithmSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func addVectorOf(CUSTOM_ALGORITHMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CUSTOM_ALGORITHMS, at: VTOFFSET.CUSTOM_ALGORITHMS.p) }
  public static func addVectorOf(MATH_ALGORITHMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MATH_ALGORITHMS, at: VTOFFSET.MATH_ALGORITHMS.p) }
  public static func endAlgorithmSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAlgorithmSet(
    _ fbb: inout FlatBufferBuilder,
    CUSTOM_ALGORITHMSVectorOffset CUSTOM_ALGORITHMS: Offset = Offset(),
    MATH_ALGORITHMSVectorOffset MATH_ALGORITHMS: Offset = Offset()
  ) -> Offset {
    let __start = AlgorithmSet.startAlgorithmSet(&fbb)
    AlgorithmSet.addVectorOf(CUSTOM_ALGORITHMS: CUSTOM_ALGORITHMS, &fbb)
    AlgorithmSet.addVectorOf(MATH_ALGORITHMS: MATH_ALGORITHMS, &fbb)
    return AlgorithmSet.endAlgorithmSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CUSTOM_ALGORITHMS.p, fieldName: "CUSTOM_ALGORITHMS", required: false, type: ForwardOffset<Vector<ForwardOffset<CustomAlgorithm>, CustomAlgorithm>>.self)
    try _v.visit(field: VTOFFSET.MATH_ALGORITHMS.p, fieldName: "MATH_ALGORITHMS", required: false, type: ForwardOffset<Vector<ForwardOffset<MathAlgorithm>, MathAlgorithm>>.self)
    _v.finish()
  }
}

///  Integer argument type
public struct IntegerArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: IntegerArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case UNITS = 10
    case DATA_ENCODING = 12
    case VALID_MIN = 14
    case VALID_MAX = 16
    case SIGNED = 18
    case SIZE_IN_BITS = 20
    case INITIAL_VALUE = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Units
  public var hasUnits: Bool { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? false : true }
  public var UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func UNITS(at index: Int32) -> Unit? { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? nil : Unit(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Minimum valid value
  public var VALID_MIN: Int64 { let o = _accessor.offset(VTOFFSET.VALID_MIN.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Maximum valid value
  public var VALID_MAX: Int64 { let o = _accessor.offset(VTOFFSET.VALID_MAX.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  ///  Signed integer (true) or unsigned (false)
  public var SIGNED: Bool { let o = _accessor.offset(VTOFFSET.SIGNED.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Size in bits
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Initial/default value
  public var INITIAL_VALUE: Int64 { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public static func startIntegerArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UNITS, at: VTOFFSET.UNITS.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(VALID_MIN: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MIN, def: 0, at: VTOFFSET.VALID_MIN.p) }
  public static func add(VALID_MAX: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MAX, def: 0, at: VTOFFSET.VALID_MAX.p) }
  public static func add(SIGNED: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIGNED, def: false,
   at: VTOFFSET.SIGNED.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(INITIAL_VALUE: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: 0, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endIntegerArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createIntegerArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    UNITSVectorOffset UNITS: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    VALID_MIN: Int64 = 0,
    VALID_MAX: Int64 = 0,
    SIGNED: Bool = false,
    SIZE_IN_BITS: UInt16 = 0,
    INITIAL_VALUE: Int64 = 0
  ) -> Offset {
    let __start = IntegerArgumentType.startIntegerArgumentType(&fbb)
    IntegerArgumentType.add(NAME: NAME, &fbb)
    IntegerArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    IntegerArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    IntegerArgumentType.addVectorOf(UNITS: UNITS, &fbb)
    IntegerArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    IntegerArgumentType.add(VALID_MIN: VALID_MIN, &fbb)
    IntegerArgumentType.add(VALID_MAX: VALID_MAX, &fbb)
    IntegerArgumentType.add(SIGNED: SIGNED, &fbb)
    IntegerArgumentType.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    IntegerArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return IntegerArgumentType.endIntegerArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UNITS.p, fieldName: "UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<Unit>, Unit>>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.VALID_MIN.p, fieldName: "VALID_MIN", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.VALID_MAX.p, fieldName: "VALID_MAX", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.SIGNED.p, fieldName: "SIGNED", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Int64.self)
    _v.finish()
  }
}

///  Float argument type
public struct FloatArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FloatArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case UNITS = 10
    case DATA_ENCODING = 12
    case VALID_MIN = 14
    case VALID_MAX = 16
    case SIZE_IN_BITS = 18
    case INITIAL_VALUE = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Units
  public var hasUnits: Bool { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? false : true }
  public var UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func UNITS(at index: Int32) -> Unit? { let o = _accessor.offset(VTOFFSET.UNITS.v); return o == 0 ? nil : Unit(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data encoding
  public var DATA_ENCODING: FloatDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : FloatDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Minimum valid value
  public var VALID_MIN: Double { let o = _accessor.offset(VTOFFSET.VALID_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum valid value
  public var VALID_MAX: Double { let o = _accessor.offset(VTOFFSET.VALID_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Size in bits
  public var SIZE_IN_BITS: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Initial/default value
  public var INITIAL_VALUE: Double { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startFloatArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UNITS, at: VTOFFSET.UNITS.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(VALID_MIN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MIN, def: 0.0, at: VTOFFSET.VALID_MIN.p) }
  public static func add(VALID_MAX: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VALID_MAX, def: 0.0, at: VTOFFSET.VALID_MAX.p) }
  public static func add(SIZE_IN_BITS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_IN_BITS, def: 0, at: VTOFFSET.SIZE_IN_BITS.p) }
  public static func add(INITIAL_VALUE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: 0.0, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endFloatArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFloatArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    UNITSVectorOffset UNITS: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    VALID_MIN: Double = 0.0,
    VALID_MAX: Double = 0.0,
    SIZE_IN_BITS: UInt16 = 0,
    INITIAL_VALUE: Double = 0.0
  ) -> Offset {
    let __start = FloatArgumentType.startFloatArgumentType(&fbb)
    FloatArgumentType.add(NAME: NAME, &fbb)
    FloatArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    FloatArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    FloatArgumentType.addVectorOf(UNITS: UNITS, &fbb)
    FloatArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    FloatArgumentType.add(VALID_MIN: VALID_MIN, &fbb)
    FloatArgumentType.add(VALID_MAX: VALID_MAX, &fbb)
    FloatArgumentType.add(SIZE_IN_BITS: SIZE_IN_BITS, &fbb)
    FloatArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return FloatArgumentType.endFloatArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UNITS.p, fieldName: "UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<Unit>, Unit>>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<FloatDataEncoding>.self)
    try _v.visit(field: VTOFFSET.VALID_MIN.p, fieldName: "VALID_MIN", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VALID_MAX.p, fieldName: "VALID_MAX", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SIZE_IN_BITS.p, fieldName: "SIZE_IN_BITS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Double.self)
    _v.finish()
  }
}

///  String argument type
public struct StringArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StringArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case INITIAL_VALUE = 12
    case RESTRICTION_PATTERN = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: StringDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : StringDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Initial/default value
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  ///  Restriction pattern (regex)
  public var RESTRICTION_PATTERN: String? { let o = _accessor.offset(VTOFFSET.RESTRICTION_PATTERN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RESTRICTION_PATTERNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RESTRICTION_PATTERN.v) }
  public static func startStringArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func add(RESTRICTION_PATTERN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESTRICTION_PATTERN, at: VTOFFSET.RESTRICTION_PATTERN.p) }
  public static func endStringArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStringArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset(),
    RESTRICTION_PATTERNOffset RESTRICTION_PATTERN: Offset = Offset()
  ) -> Offset {
    let __start = StringArgumentType.startStringArgumentType(&fbb)
    StringArgumentType.add(NAME: NAME, &fbb)
    StringArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    StringArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    StringArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    StringArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    StringArgumentType.add(RESTRICTION_PATTERN: RESTRICTION_PATTERN, &fbb)
    return StringArgumentType.endStringArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<StringDataEncoding>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RESTRICTION_PATTERN.p, fieldName: "RESTRICTION_PATTERN", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Boolean argument type
public struct BooleanArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BooleanArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case ONE_STRING_VALUE = 12
    case ZERO_STRING_VALUE = 14
    case INITIAL_VALUE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  String representation of true value
  public var ONE_STRING_VALUE: String? { let o = _accessor.offset(VTOFFSET.ONE_STRING_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ONE_STRING_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ONE_STRING_VALUE.v) }
  ///  String representation of false value
  public var ZERO_STRING_VALUE: String? { let o = _accessor.offset(VTOFFSET.ZERO_STRING_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ZERO_STRING_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ZERO_STRING_VALUE.v) }
  ///  Initial/default value
  public var INITIAL_VALUE: Bool { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startBooleanArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(ONE_STRING_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ONE_STRING_VALUE, at: VTOFFSET.ONE_STRING_VALUE.p) }
  public static func add(ZERO_STRING_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ZERO_STRING_VALUE, at: VTOFFSET.ZERO_STRING_VALUE.p) }
  public static func add(INITIAL_VALUE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INITIAL_VALUE, def: false,
   at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endBooleanArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBooleanArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    ONE_STRING_VALUEOffset ONE_STRING_VALUE: Offset = Offset(),
    ZERO_STRING_VALUEOffset ZERO_STRING_VALUE: Offset = Offset(),
    INITIAL_VALUE: Bool = false
  ) -> Offset {
    let __start = BooleanArgumentType.startBooleanArgumentType(&fbb)
    BooleanArgumentType.add(NAME: NAME, &fbb)
    BooleanArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    BooleanArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    BooleanArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    BooleanArgumentType.add(ONE_STRING_VALUE: ONE_STRING_VALUE, &fbb)
    BooleanArgumentType.add(ZERO_STRING_VALUE: ZERO_STRING_VALUE, &fbb)
    BooleanArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return BooleanArgumentType.endBooleanArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.ONE_STRING_VALUE.p, fieldName: "ONE_STRING_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ZERO_STRING_VALUE.p, fieldName: "ZERO_STRING_VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Enumerated argument type
public struct EnumeratedArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EnumeratedArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case ENUMERATION_LIST = 12
    case INITIAL_VALUE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: IntegerDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : IntegerDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Enumeration values list
  public var hasEnumerationList: Bool { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? false : true }
  public var ENUMERATION_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENUMERATION_LIST(at index: Int32) -> EnumerationValue? { let o = _accessor.offset(VTOFFSET.ENUMERATION_LIST.v); return o == 0 ? nil : EnumerationValue(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Initial/default value label
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startEnumeratedArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func addVectorOf(ENUMERATION_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENUMERATION_LIST, at: VTOFFSET.ENUMERATION_LIST.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endEnumeratedArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEnumeratedArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    ENUMERATION_LISTVectorOffset ENUMERATION_LIST: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = EnumeratedArgumentType.startEnumeratedArgumentType(&fbb)
    EnumeratedArgumentType.add(NAME: NAME, &fbb)
    EnumeratedArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    EnumeratedArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    EnumeratedArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    EnumeratedArgumentType.addVectorOf(ENUMERATION_LIST: ENUMERATION_LIST, &fbb)
    EnumeratedArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return EnumeratedArgumentType.endEnumeratedArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<IntegerDataEncoding>.self)
    try _v.visit(field: VTOFFSET.ENUMERATION_LIST.p, fieldName: "ENUMERATION_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<EnumerationValue>, EnumerationValue>>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Binary argument type
public struct BinaryArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BinaryArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case DATA_ENCODING = 10
    case INITIAL_VALUE = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Data encoding
  public var DATA_ENCODING: BinaryDataEncoding? { let o = _accessor.offset(VTOFFSET.DATA_ENCODING.v); return o == 0 ? nil : BinaryDataEncoding(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Initial/default value (hex string)
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startBinaryArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(DATA_ENCODING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_ENCODING, at: VTOFFSET.DATA_ENCODING.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endBinaryArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBinaryArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    DATA_ENCODINGOffset DATA_ENCODING: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = BinaryArgumentType.startBinaryArgumentType(&fbb)
    BinaryArgumentType.add(NAME: NAME, &fbb)
    BinaryArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    BinaryArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    BinaryArgumentType.add(DATA_ENCODING: DATA_ENCODING, &fbb)
    BinaryArgumentType.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return BinaryArgumentType.endBinaryArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_ENCODING.p, fieldName: "DATA_ENCODING", required: false, type: ForwardOffset<BinaryDataEncoding>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Aggregate argument type
public struct AggregateArgumentType: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AggregateArgumentType.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case MEMBERS = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Member list
  public var hasMembers: Bool { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? false : true }
  public var MEMBERSCount: Int32 { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MEMBERS(at index: Int32) -> AggregateMember? { let o = _accessor.offset(VTOFFSET.MEMBERS.v); return o == 0 ? nil : AggregateMember(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startAggregateArgumentType(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(MEMBERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MEMBERS, at: VTOFFSET.MEMBERS.p) }
  public static func endAggregateArgumentType(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAggregateArgumentType(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    MEMBERSVectorOffset MEMBERS: Offset = Offset()
  ) -> Offset {
    let __start = AggregateArgumentType.startAggregateArgumentType(&fbb)
    AggregateArgumentType.add(NAME: NAME, &fbb)
    AggregateArgumentType.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    AggregateArgumentType.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    AggregateArgumentType.addVectorOf(MEMBERS: MEMBERS, &fbb)
    return AggregateArgumentType.endAggregateArgumentType(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MEMBERS.p, fieldName: "MEMBERS", required: false, type: ForwardOffset<Vector<ForwardOffset<AggregateMember>, AggregateMember>>.self)
    _v.finish()
  }
}

///  Collection of argument types
public struct ArgumentTypeSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArgumentTypeSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case INTEGER_TYPES = 4
    case FLOAT_TYPES = 6
    case STRING_TYPES = 8
    case BOOLEAN_TYPES = 10
    case ENUMERATED_TYPES = 12
    case BINARY_TYPES = 14
    case AGGREGATE_TYPES = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Integer argument types
  public var hasIntegerTypes: Bool { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? false : true }
  public var INTEGER_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INTEGER_TYPES(at index: Int32) -> IntegerArgumentType? { let o = _accessor.offset(VTOFFSET.INTEGER_TYPES.v); return o == 0 ? nil : IntegerArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Float argument types
  public var hasFloatTypes: Bool { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? false : true }
  public var FLOAT_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FLOAT_TYPES(at index: Int32) -> FloatArgumentType? { let o = _accessor.offset(VTOFFSET.FLOAT_TYPES.v); return o == 0 ? nil : FloatArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  String argument types
  public var hasStringTypes: Bool { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? false : true }
  public var STRING_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STRING_TYPES(at index: Int32) -> StringArgumentType? { let o = _accessor.offset(VTOFFSET.STRING_TYPES.v); return o == 0 ? nil : StringArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Boolean argument types
  public var hasBooleanTypes: Bool { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? false : true }
  public var BOOLEAN_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func BOOLEAN_TYPES(at index: Int32) -> BooleanArgumentType? { let o = _accessor.offset(VTOFFSET.BOOLEAN_TYPES.v); return o == 0 ? nil : BooleanArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Enumerated argument types
  public var hasEnumeratedTypes: Bool { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? false : true }
  public var ENUMERATED_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENUMERATED_TYPES(at index: Int32) -> EnumeratedArgumentType? { let o = _accessor.offset(VTOFFSET.ENUMERATED_TYPES.v); return o == 0 ? nil : EnumeratedArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Binary argument types
  public var hasBinaryTypes: Bool { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? false : true }
  public var BINARY_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func BINARY_TYPES(at index: Int32) -> BinaryArgumentType? { let o = _accessor.offset(VTOFFSET.BINARY_TYPES.v); return o == 0 ? nil : BinaryArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Aggregate argument types
  public var hasAggregateTypes: Bool { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? false : true }
  public var AGGREGATE_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func AGGREGATE_TYPES(at index: Int32) -> AggregateArgumentType? { let o = _accessor.offset(VTOFFSET.AGGREGATE_TYPES.v); return o == 0 ? nil : AggregateArgumentType(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startArgumentTypeSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func addVectorOf(INTEGER_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTEGER_TYPES, at: VTOFFSET.INTEGER_TYPES.p) }
  public static func addVectorOf(FLOAT_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FLOAT_TYPES, at: VTOFFSET.FLOAT_TYPES.p) }
  public static func addVectorOf(STRING_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STRING_TYPES, at: VTOFFSET.STRING_TYPES.p) }
  public static func addVectorOf(BOOLEAN_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BOOLEAN_TYPES, at: VTOFFSET.BOOLEAN_TYPES.p) }
  public static func addVectorOf(ENUMERATED_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENUMERATED_TYPES, at: VTOFFSET.ENUMERATED_TYPES.p) }
  public static func addVectorOf(BINARY_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BINARY_TYPES, at: VTOFFSET.BINARY_TYPES.p) }
  public static func addVectorOf(AGGREGATE_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AGGREGATE_TYPES, at: VTOFFSET.AGGREGATE_TYPES.p) }
  public static func endArgumentTypeSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgumentTypeSet(
    _ fbb: inout FlatBufferBuilder,
    INTEGER_TYPESVectorOffset INTEGER_TYPES: Offset = Offset(),
    FLOAT_TYPESVectorOffset FLOAT_TYPES: Offset = Offset(),
    STRING_TYPESVectorOffset STRING_TYPES: Offset = Offset(),
    BOOLEAN_TYPESVectorOffset BOOLEAN_TYPES: Offset = Offset(),
    ENUMERATED_TYPESVectorOffset ENUMERATED_TYPES: Offset = Offset(),
    BINARY_TYPESVectorOffset BINARY_TYPES: Offset = Offset(),
    AGGREGATE_TYPESVectorOffset AGGREGATE_TYPES: Offset = Offset()
  ) -> Offset {
    let __start = ArgumentTypeSet.startArgumentTypeSet(&fbb)
    ArgumentTypeSet.addVectorOf(INTEGER_TYPES: INTEGER_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(FLOAT_TYPES: FLOAT_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(STRING_TYPES: STRING_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(BOOLEAN_TYPES: BOOLEAN_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(ENUMERATED_TYPES: ENUMERATED_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(BINARY_TYPES: BINARY_TYPES, &fbb)
    ArgumentTypeSet.addVectorOf(AGGREGATE_TYPES: AGGREGATE_TYPES, &fbb)
    return ArgumentTypeSet.endArgumentTypeSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.INTEGER_TYPES.p, fieldName: "INTEGER_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<IntegerArgumentType>, IntegerArgumentType>>.self)
    try _v.visit(field: VTOFFSET.FLOAT_TYPES.p, fieldName: "FLOAT_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<FloatArgumentType>, FloatArgumentType>>.self)
    try _v.visit(field: VTOFFSET.STRING_TYPES.p, fieldName: "STRING_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<StringArgumentType>, StringArgumentType>>.self)
    try _v.visit(field: VTOFFSET.BOOLEAN_TYPES.p, fieldName: "BOOLEAN_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<BooleanArgumentType>, BooleanArgumentType>>.self)
    try _v.visit(field: VTOFFSET.ENUMERATED_TYPES.p, fieldName: "ENUMERATED_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<EnumeratedArgumentType>, EnumeratedArgumentType>>.self)
    try _v.visit(field: VTOFFSET.BINARY_TYPES.p, fieldName: "BINARY_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<BinaryArgumentType>, BinaryArgumentType>>.self)
    try _v.visit(field: VTOFFSET.AGGREGATE_TYPES.p, fieldName: "AGGREGATE_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<AggregateArgumentType>, AggregateArgumentType>>.self)
    _v.finish()
  }
}

///  Command argument definition
public struct Argument: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Argument.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case ARGUMENT_TYPE_REF = 6
    case SHORT_DESCRIPTION = 8
    case LONG_DESCRIPTION = 10
    case INITIAL_VALUE = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Argument name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Reference to argument type
  public var ARGUMENT_TYPE_REF: String? { let o = _accessor.offset(VTOFFSET.ARGUMENT_TYPE_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ARGUMENT_TYPE_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ARGUMENT_TYPE_REF.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Initial/default value
  public var INITIAL_VALUE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_VALUE.v) }
  public static func startArgument(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(ARGUMENT_TYPE_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_TYPE_REF, at: VTOFFSET.ARGUMENT_TYPE_REF.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(INITIAL_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_VALUE, at: VTOFFSET.INITIAL_VALUE.p) }
  public static func endArgument(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgument(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    ARGUMENT_TYPE_REFOffset ARGUMENT_TYPE_REF: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    INITIAL_VALUEOffset INITIAL_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = Argument.startArgument(&fbb)
    Argument.add(NAME: NAME, &fbb)
    Argument.add(ARGUMENT_TYPE_REF: ARGUMENT_TYPE_REF, &fbb)
    Argument.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    Argument.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    Argument.add(INITIAL_VALUE: INITIAL_VALUE, &fbb)
    return Argument.endArgument(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ARGUMENT_TYPE_REF.p, fieldName: "ARGUMENT_TYPE_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_VALUE.p, fieldName: "INITIAL_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Argument reference entry in command container
public struct ArgumentRefEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArgumentRefEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ARGUMENT_REF = 4
    case LOCATION = 6
    case SHORT_DESCRIPTION = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Argument reference
  public var ARGUMENT_REF: String? { let o = _accessor.offset(VTOFFSET.ARGUMENT_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ARGUMENT_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ARGUMENT_REF.v) }
  ///  Location in container
  public var LOCATION: LocationInContainer? { let o = _accessor.offset(VTOFFSET.LOCATION.v); return o == 0 ? nil : LocationInContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  public static func startArgumentRefEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ARGUMENT_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_REF, at: VTOFFSET.ARGUMENT_REF.p) }
  public static func add(LOCATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCATION, at: VTOFFSET.LOCATION.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func endArgumentRefEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgumentRefEntry(
    _ fbb: inout FlatBufferBuilder,
    ARGUMENT_REFOffset ARGUMENT_REF: Offset = Offset(),
    LOCATIONOffset LOCATION: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset()
  ) -> Offset {
    let __start = ArgumentRefEntry.startArgumentRefEntry(&fbb)
    ArgumentRefEntry.add(ARGUMENT_REF: ARGUMENT_REF, &fbb)
    ArgumentRefEntry.add(LOCATION: LOCATION, &fbb)
    ArgumentRefEntry.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    return ArgumentRefEntry.endArgumentRefEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ARGUMENT_REF.p, fieldName: "ARGUMENT_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCATION.p, fieldName: "LOCATION", required: false, type: ForwardOffset<LocationInContainer>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Command container entry
public struct CommandContainerEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CommandContainerEntry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ARGUMENT_REF_ENTRY = 4
    case PARAMETER_REF_ENTRY = 6
    case FIXED_VALUE_ENTRY = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Argument reference entry
  public var ARGUMENT_REF_ENTRY: ArgumentRefEntry? { let o = _accessor.offset(VTOFFSET.ARGUMENT_REF_ENTRY.v); return o == 0 ? nil : ArgumentRefEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Parameter reference entry
  public var PARAMETER_REF_ENTRY: ParameterRefEntry? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF_ENTRY.v); return o == 0 ? nil : ParameterRefEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Fixed value entry
  public var FIXED_VALUE_ENTRY: FixedValueEntry? { let o = _accessor.offset(VTOFFSET.FIXED_VALUE_ENTRY.v); return o == 0 ? nil : FixedValueEntry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCommandContainerEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ARGUMENT_REF_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_REF_ENTRY, at: VTOFFSET.ARGUMENT_REF_ENTRY.p) }
  public static func add(PARAMETER_REF_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF_ENTRY, at: VTOFFSET.PARAMETER_REF_ENTRY.p) }
  public static func add(FIXED_VALUE_ENTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FIXED_VALUE_ENTRY, at: VTOFFSET.FIXED_VALUE_ENTRY.p) }
  public static func endCommandContainerEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCommandContainerEntry(
    _ fbb: inout FlatBufferBuilder,
    ARGUMENT_REF_ENTRYOffset ARGUMENT_REF_ENTRY: Offset = Offset(),
    PARAMETER_REF_ENTRYOffset PARAMETER_REF_ENTRY: Offset = Offset(),
    FIXED_VALUE_ENTRYOffset FIXED_VALUE_ENTRY: Offset = Offset()
  ) -> Offset {
    let __start = CommandContainerEntry.startCommandContainerEntry(&fbb)
    CommandContainerEntry.add(ARGUMENT_REF_ENTRY: ARGUMENT_REF_ENTRY, &fbb)
    CommandContainerEntry.add(PARAMETER_REF_ENTRY: PARAMETER_REF_ENTRY, &fbb)
    CommandContainerEntry.add(FIXED_VALUE_ENTRY: FIXED_VALUE_ENTRY, &fbb)
    return CommandContainerEntry.endCommandContainerEntry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ARGUMENT_REF_ENTRY.p, fieldName: "ARGUMENT_REF_ENTRY", required: false, type: ForwardOffset<ArgumentRefEntry>.self)
    try _v.visit(field: VTOFFSET.PARAMETER_REF_ENTRY.p, fieldName: "PARAMETER_REF_ENTRY", required: false, type: ForwardOffset<ParameterRefEntry>.self)
    try _v.visit(field: VTOFFSET.FIXED_VALUE_ENTRY.p, fieldName: "FIXED_VALUE_ENTRY", required: false, type: ForwardOffset<FixedValueEntry>.self)
    _v.finish()
  }
}

///  Command container definition
public struct CommandContainer: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CommandContainer.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case ENTRY_LIST = 6
    case BASE_CONTAINER = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Container name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Entry list
  public var hasEntryList: Bool { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? false : true }
  public var ENTRY_LISTCount: Int32 { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENTRY_LIST(at index: Int32) -> CommandContainerEntry? { let o = _accessor.offset(VTOFFSET.ENTRY_LIST.v); return o == 0 ? nil : CommandContainerEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Base container reference
  public var BASE_CONTAINER: BaseContainer? { let o = _accessor.offset(VTOFFSET.BASE_CONTAINER.v); return o == 0 ? nil : BaseContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCommandContainer(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func addVectorOf(ENTRY_LIST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENTRY_LIST, at: VTOFFSET.ENTRY_LIST.p) }
  public static func add(BASE_CONTAINER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BASE_CONTAINER, at: VTOFFSET.BASE_CONTAINER.p) }
  public static func endCommandContainer(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCommandContainer(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    ENTRY_LISTVectorOffset ENTRY_LIST: Offset = Offset(),
    BASE_CONTAINEROffset BASE_CONTAINER: Offset = Offset()
  ) -> Offset {
    let __start = CommandContainer.startCommandContainer(&fbb)
    CommandContainer.add(NAME: NAME, &fbb)
    CommandContainer.addVectorOf(ENTRY_LIST: ENTRY_LIST, &fbb)
    CommandContainer.add(BASE_CONTAINER: BASE_CONTAINER, &fbb)
    return CommandContainer.endCommandContainer(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENTRY_LIST.p, fieldName: "ENTRY_LIST", required: false, type: ForwardOffset<Vector<ForwardOffset<CommandContainerEntry>, CommandContainerEntry>>.self)
    try _v.visit(field: VTOFFSET.BASE_CONTAINER.p, fieldName: "BASE_CONTAINER", required: false, type: ForwardOffset<BaseContainer>.self)
    _v.finish()
  }
}

///  Command verifier definition
public struct CommandVerifier: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CommandVerifier.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case VERIFIER_TYPE = 6
    case CONDITION = 8
    case CONTAINER_REF = 10
    case TIME_WINDOW_START = 12
    case TIME_WINDOW_STOP = 14
    case TIME_WINDOW_REF = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Verifier name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Verifier type
  public var VERIFIER_TYPE: VerifierType { let o = _accessor.offset(VTOFFSET.VERIFIER_TYPE.v); return o == 0 ? .start : VerifierType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .start }
  ///  Verification condition
  public var CONDITION: MatchCriteria? { let o = _accessor.offset(VTOFFSET.CONDITION.v); return o == 0 ? nil : MatchCriteria(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Container reference for verification
  public var CONTAINER_REF: String? { let o = _accessor.offset(VTOFFSET.CONTAINER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTAINER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTAINER_REF.v) }
  ///  Time window start (seconds)
  public var TIME_WINDOW_START: Double { let o = _accessor.offset(VTOFFSET.TIME_WINDOW_START.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time window stop (seconds)
  public var TIME_WINDOW_STOP: Double { let o = _accessor.offset(VTOFFSET.TIME_WINDOW_STOP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Time window reference type
  public var TIME_WINDOW_REF: TimeWindowRefType { let o = _accessor.offset(VTOFFSET.TIME_WINDOW_REF.v); return o == 0 ? .commandRelease : TimeWindowRefType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .commandRelease }
  public static func startCommandVerifier(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(VERIFIER_TYPE: VerifierType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VERIFIER_TYPE.rawValue, def: 0, at: VTOFFSET.VERIFIER_TYPE.p) }
  public static func add(CONDITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONDITION, at: VTOFFSET.CONDITION.p) }
  public static func add(CONTAINER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REF, at: VTOFFSET.CONTAINER_REF.p) }
  public static func add(TIME_WINDOW_START: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_WINDOW_START, def: 0.0, at: VTOFFSET.TIME_WINDOW_START.p) }
  public static func add(TIME_WINDOW_STOP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_WINDOW_STOP, def: 0.0, at: VTOFFSET.TIME_WINDOW_STOP.p) }
  public static func add(TIME_WINDOW_REF: TimeWindowRefType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_WINDOW_REF.rawValue, def: 0, at: VTOFFSET.TIME_WINDOW_REF.p) }
  public static func endCommandVerifier(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCommandVerifier(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    VERIFIER_TYPE: VerifierType = .start,
    CONDITIONOffset CONDITION: Offset = Offset(),
    CONTAINER_REFOffset CONTAINER_REF: Offset = Offset(),
    TIME_WINDOW_START: Double = 0.0,
    TIME_WINDOW_STOP: Double = 0.0,
    TIME_WINDOW_REF: TimeWindowRefType = .commandRelease
  ) -> Offset {
    let __start = CommandVerifier.startCommandVerifier(&fbb)
    CommandVerifier.add(NAME: NAME, &fbb)
    CommandVerifier.add(VERIFIER_TYPE: VERIFIER_TYPE, &fbb)
    CommandVerifier.add(CONDITION: CONDITION, &fbb)
    CommandVerifier.add(CONTAINER_REF: CONTAINER_REF, &fbb)
    CommandVerifier.add(TIME_WINDOW_START: TIME_WINDOW_START, &fbb)
    CommandVerifier.add(TIME_WINDOW_STOP: TIME_WINDOW_STOP, &fbb)
    CommandVerifier.add(TIME_WINDOW_REF: TIME_WINDOW_REF, &fbb)
    return CommandVerifier.endCommandVerifier(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VERIFIER_TYPE.p, fieldName: "VERIFIER_TYPE", required: false, type: VerifierType.self)
    try _v.visit(field: VTOFFSET.CONDITION.p, fieldName: "CONDITION", required: false, type: ForwardOffset<MatchCriteria>.self)
    try _v.visit(field: VTOFFSET.CONTAINER_REF.p, fieldName: "CONTAINER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_WINDOW_START.p, fieldName: "TIME_WINDOW_START", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TIME_WINDOW_STOP.p, fieldName: "TIME_WINDOW_STOP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TIME_WINDOW_REF.p, fieldName: "TIME_WINDOW_REF", required: false, type: TimeWindowRefType.self)
    _v.finish()
  }
}

///  Significance of command execution
public struct CommandSignificance: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CommandSignificance.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CONSEQUENCE_LEVEL = 4
    case REASON_FOR_WARNING = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Consequence level (1=lowest, higher=more severe)
  public var CONSEQUENCE_LEVEL: UInt8 { let o = _accessor.offset(VTOFFSET.CONSEQUENCE_LEVEL.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Reason for significance
  public var REASON_FOR_WARNING: String? { let o = _accessor.offset(VTOFFSET.REASON_FOR_WARNING.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var REASON_FOR_WARNINGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.REASON_FOR_WARNING.v) }
  public static func startCommandSignificance(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(CONSEQUENCE_LEVEL: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CONSEQUENCE_LEVEL, def: 0, at: VTOFFSET.CONSEQUENCE_LEVEL.p) }
  public static func add(REASON_FOR_WARNING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REASON_FOR_WARNING, at: VTOFFSET.REASON_FOR_WARNING.p) }
  public static func endCommandSignificance(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCommandSignificance(
    _ fbb: inout FlatBufferBuilder,
    CONSEQUENCE_LEVEL: UInt8 = 0,
    REASON_FOR_WARNINGOffset REASON_FOR_WARNING: Offset = Offset()
  ) -> Offset {
    let __start = CommandSignificance.startCommandSignificance(&fbb)
    CommandSignificance.add(CONSEQUENCE_LEVEL: CONSEQUENCE_LEVEL, &fbb)
    CommandSignificance.add(REASON_FOR_WARNING: REASON_FOR_WARNING, &fbb)
    return CommandSignificance.endCommandSignificance(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CONSEQUENCE_LEVEL.p, fieldName: "CONSEQUENCE_LEVEL", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.REASON_FOR_WARNING.p, fieldName: "REASON_FOR_WARNING", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Base metacommand reference
public struct BaseMetaCommand: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BaseMetaCommand.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case META_COMMAND_REF = 4
    case ARGUMENT_ASSIGNMENTS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  MetaCommand reference
  public var META_COMMAND_REF: String? { let o = _accessor.offset(VTOFFSET.META_COMMAND_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var META_COMMAND_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.META_COMMAND_REF.v) }
  ///  Argument assignments for inherited arguments
  public var hasArgumentAssignments: Bool { let o = _accessor.offset(VTOFFSET.ARGUMENT_ASSIGNMENTS.v); return o == 0 ? false : true }
  public var ARGUMENT_ASSIGNMENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.ARGUMENT_ASSIGNMENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ARGUMENT_ASSIGNMENTS(at index: Int32) -> ArgumentAssignment? { let o = _accessor.offset(VTOFFSET.ARGUMENT_ASSIGNMENTS.v); return o == 0 ? nil : ArgumentAssignment(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startBaseMetaCommand(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(META_COMMAND_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: META_COMMAND_REF, at: VTOFFSET.META_COMMAND_REF.p) }
  public static func addVectorOf(ARGUMENT_ASSIGNMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_ASSIGNMENTS, at: VTOFFSET.ARGUMENT_ASSIGNMENTS.p) }
  public static func endBaseMetaCommand(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBaseMetaCommand(
    _ fbb: inout FlatBufferBuilder,
    META_COMMAND_REFOffset META_COMMAND_REF: Offset = Offset(),
    ARGUMENT_ASSIGNMENTSVectorOffset ARGUMENT_ASSIGNMENTS: Offset = Offset()
  ) -> Offset {
    let __start = BaseMetaCommand.startBaseMetaCommand(&fbb)
    BaseMetaCommand.add(META_COMMAND_REF: META_COMMAND_REF, &fbb)
    BaseMetaCommand.addVectorOf(ARGUMENT_ASSIGNMENTS: ARGUMENT_ASSIGNMENTS, &fbb)
    return BaseMetaCommand.endBaseMetaCommand(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.META_COMMAND_REF.p, fieldName: "META_COMMAND_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ARGUMENT_ASSIGNMENTS.p, fieldName: "ARGUMENT_ASSIGNMENTS", required: false, type: ForwardOffset<Vector<ForwardOffset<ArgumentAssignment>, ArgumentAssignment>>.self)
    _v.finish()
  }
}

///  Argument assignment (value binding)
public struct ArgumentAssignment: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ArgumentAssignment.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ARGUMENT_NAME = 4
    case VALUE = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Argument name
  public var ARGUMENT_NAME: String? { let o = _accessor.offset(VTOFFSET.ARGUMENT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ARGUMENT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ARGUMENT_NAME.v) }
  ///  Assigned value
  public var VALUE: String? { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALUE.v) }
  public static func startArgumentAssignment(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(ARGUMENT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_NAME, at: VTOFFSET.ARGUMENT_NAME.p) }
  public static func add(VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALUE, at: VTOFFSET.VALUE.p) }
  public static func endArgumentAssignment(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createArgumentAssignment(
    _ fbb: inout FlatBufferBuilder,
    ARGUMENT_NAMEOffset ARGUMENT_NAME: Offset = Offset(),
    VALUEOffset VALUE: Offset = Offset()
  ) -> Offset {
    let __start = ArgumentAssignment.startArgumentAssignment(&fbb)
    ArgumentAssignment.add(ARGUMENT_NAME: ARGUMENT_NAME, &fbb)
    ArgumentAssignment.add(VALUE: VALUE, &fbb)
    return ArgumentAssignment.endArgumentAssignment(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ARGUMENT_NAME.p, fieldName: "ARGUMENT_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Interlock constraint
public struct Interlock: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Interlock.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_REF = 4
    case VALUE = 6
    case OPERATOR = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter reference
  public var PARAMETER_REF: String? { let o = _accessor.offset(VTOFFSET.PARAMETER_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAMETER_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAMETER_REF.v) }
  ///  Required value
  public var VALUE: String? { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALUE.v) }
  ///  Operator for comparison
  public var OPERATOR: ComparisonOperator { let o = _accessor.offset(VTOFFSET.OPERATOR.v); return o == 0 ? .eq : ComparisonOperator(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .eq }
  public static func startInterlock(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(PARAMETER_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_REF, at: VTOFFSET.PARAMETER_REF.p) }
  public static func add(VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALUE, at: VTOFFSET.VALUE.p) }
  public static func add(OPERATOR: ComparisonOperator, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OPERATOR.rawValue, def: 0, at: VTOFFSET.OPERATOR.p) }
  public static func endInterlock(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createInterlock(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_REFOffset PARAMETER_REF: Offset = Offset(),
    VALUEOffset VALUE: Offset = Offset(),
    OPERATOR: ComparisonOperator = .eq
  ) -> Offset {
    let __start = Interlock.startInterlock(&fbb)
    Interlock.add(PARAMETER_REF: PARAMETER_REF, &fbb)
    Interlock.add(VALUE: VALUE, &fbb)
    Interlock.add(OPERATOR: OPERATOR, &fbb)
    return Interlock.endInterlock(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_REF.p, fieldName: "PARAMETER_REF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OPERATOR.p, fieldName: "OPERATOR", required: false, type: ComparisonOperator.self)
    _v.finish()
  }
}

///  MetaCommand definition
public struct MetaCommand: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MetaCommand.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case ABSTRACT = 10
    case ARGUMENTS = 12
    case COMMAND_CONTAINER = 14
    case BASE_META_COMMAND = 16
    case VERIFIERS = 18
    case SIGNIFICANCE = 20
    case INTERLOCKS = 22
    case DEFAULT_SIGNIFICANCE = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Command name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Abstract command (base only)
  public var ABSTRACT: Bool { let o = _accessor.offset(VTOFFSET.ABSTRACT.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Argument list
  public var hasArguments: Bool { let o = _accessor.offset(VTOFFSET.ARGUMENTS.v); return o == 0 ? false : true }
  public var ARGUMENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.ARGUMENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ARGUMENTS(at index: Int32) -> Argument? { let o = _accessor.offset(VTOFFSET.ARGUMENTS.v); return o == 0 ? nil : Argument(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Command container
  public var COMMAND_CONTAINER: CommandContainer? { let o = _accessor.offset(VTOFFSET.COMMAND_CONTAINER.v); return o == 0 ? nil : CommandContainer(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Base metacommand (inheritance)
  public var BASE_META_COMMAND: BaseMetaCommand? { let o = _accessor.offset(VTOFFSET.BASE_META_COMMAND.v); return o == 0 ? nil : BaseMetaCommand(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Command verifiers
  public var hasVerifiers: Bool { let o = _accessor.offset(VTOFFSET.VERIFIERS.v); return o == 0 ? false : true }
  public var VERIFIERSCount: Int32 { let o = _accessor.offset(VTOFFSET.VERIFIERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func VERIFIERS(at index: Int32) -> CommandVerifier? { let o = _accessor.offset(VTOFFSET.VERIFIERS.v); return o == 0 ? nil : CommandVerifier(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Command significance
  public var SIGNIFICANCE: CommandSignificance? { let o = _accessor.offset(VTOFFSET.SIGNIFICANCE.v); return o == 0 ? nil : CommandSignificance(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Interlock constraints
  public var hasInterlocks: Bool { let o = _accessor.offset(VTOFFSET.INTERLOCKS.v); return o == 0 ? false : true }
  public var INTERLOCKSCount: Int32 { let o = _accessor.offset(VTOFFSET.INTERLOCKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INTERLOCKS(at index: Int32) -> Interlock? { let o = _accessor.offset(VTOFFSET.INTERLOCKS.v); return o == 0 ? nil : Interlock(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Default significance
  public var DEFAULT_SIGNIFICANCE: CommandSignificance? { let o = _accessor.offset(VTOFFSET.DEFAULT_SIGNIFICANCE.v); return o == 0 ? nil : CommandSignificance(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startMetaCommand(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(ABSTRACT: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ABSTRACT, def: false,
   at: VTOFFSET.ABSTRACT.p) }
  public static func addVectorOf(ARGUMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENTS, at: VTOFFSET.ARGUMENTS.p) }
  public static func add(COMMAND_CONTAINER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND_CONTAINER, at: VTOFFSET.COMMAND_CONTAINER.p) }
  public static func add(BASE_META_COMMAND: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BASE_META_COMMAND, at: VTOFFSET.BASE_META_COMMAND.p) }
  public static func addVectorOf(VERIFIERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERIFIERS, at: VTOFFSET.VERIFIERS.p) }
  public static func add(SIGNIFICANCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIGNIFICANCE, at: VTOFFSET.SIGNIFICANCE.p) }
  public static func addVectorOf(INTERLOCKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTERLOCKS, at: VTOFFSET.INTERLOCKS.p) }
  public static func add(DEFAULT_SIGNIFICANCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DEFAULT_SIGNIFICANCE, at: VTOFFSET.DEFAULT_SIGNIFICANCE.p) }
  public static func endMetaCommand(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMetaCommand(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    ABSTRACT: Bool = false,
    ARGUMENTSVectorOffset ARGUMENTS: Offset = Offset(),
    COMMAND_CONTAINEROffset COMMAND_CONTAINER: Offset = Offset(),
    BASE_META_COMMANDOffset BASE_META_COMMAND: Offset = Offset(),
    VERIFIERSVectorOffset VERIFIERS: Offset = Offset(),
    SIGNIFICANCEOffset SIGNIFICANCE: Offset = Offset(),
    INTERLOCKSVectorOffset INTERLOCKS: Offset = Offset(),
    DEFAULT_SIGNIFICANCEOffset DEFAULT_SIGNIFICANCE: Offset = Offset()
  ) -> Offset {
    let __start = MetaCommand.startMetaCommand(&fbb)
    MetaCommand.add(NAME: NAME, &fbb)
    MetaCommand.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    MetaCommand.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    MetaCommand.add(ABSTRACT: ABSTRACT, &fbb)
    MetaCommand.addVectorOf(ARGUMENTS: ARGUMENTS, &fbb)
    MetaCommand.add(COMMAND_CONTAINER: COMMAND_CONTAINER, &fbb)
    MetaCommand.add(BASE_META_COMMAND: BASE_META_COMMAND, &fbb)
    MetaCommand.addVectorOf(VERIFIERS: VERIFIERS, &fbb)
    MetaCommand.add(SIGNIFICANCE: SIGNIFICANCE, &fbb)
    MetaCommand.addVectorOf(INTERLOCKS: INTERLOCKS, &fbb)
    MetaCommand.add(DEFAULT_SIGNIFICANCE: DEFAULT_SIGNIFICANCE, &fbb)
    return MetaCommand.endMetaCommand(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ABSTRACT.p, fieldName: "ABSTRACT", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.ARGUMENTS.p, fieldName: "ARGUMENTS", required: false, type: ForwardOffset<Vector<ForwardOffset<Argument>, Argument>>.self)
    try _v.visit(field: VTOFFSET.COMMAND_CONTAINER.p, fieldName: "COMMAND_CONTAINER", required: false, type: ForwardOffset<CommandContainer>.self)
    try _v.visit(field: VTOFFSET.BASE_META_COMMAND.p, fieldName: "BASE_META_COMMAND", required: false, type: ForwardOffset<BaseMetaCommand>.self)
    try _v.visit(field: VTOFFSET.VERIFIERS.p, fieldName: "VERIFIERS", required: false, type: ForwardOffset<Vector<ForwardOffset<CommandVerifier>, CommandVerifier>>.self)
    try _v.visit(field: VTOFFSET.SIGNIFICANCE.p, fieldName: "SIGNIFICANCE", required: false, type: ForwardOffset<CommandSignificance>.self)
    try _v.visit(field: VTOFFSET.INTERLOCKS.p, fieldName: "INTERLOCKS", required: false, type: ForwardOffset<Vector<ForwardOffset<Interlock>, Interlock>>.self)
    try _v.visit(field: VTOFFSET.DEFAULT_SIGNIFICANCE.p, fieldName: "DEFAULT_SIGNIFICANCE", required: false, type: ForwardOffset<CommandSignificance>.self)
    _v.finish()
  }
}

///  Collection of metacommands
public struct MetaCommandSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MetaCommandSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case META_COMMANDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  MetaCommands
  public var hasMetaCommands: Bool { let o = _accessor.offset(VTOFFSET.META_COMMANDS.v); return o == 0 ? false : true }
  public var META_COMMANDSCount: Int32 { let o = _accessor.offset(VTOFFSET.META_COMMANDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func META_COMMANDS(at index: Int32) -> MetaCommand? { let o = _accessor.offset(VTOFFSET.META_COMMANDS.v); return o == 0 ? nil : MetaCommand(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startMetaCommandSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(META_COMMANDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: META_COMMANDS, at: VTOFFSET.META_COMMANDS.p) }
  public static func endMetaCommandSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMetaCommandSet(
    _ fbb: inout FlatBufferBuilder,
    META_COMMANDSVectorOffset META_COMMANDS: Offset = Offset()
  ) -> Offset {
    let __start = MetaCommandSet.startMetaCommandSet(&fbb)
    MetaCommandSet.addVectorOf(META_COMMANDS: META_COMMANDS, &fbb)
    return MetaCommandSet.endMetaCommandSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.META_COMMANDS.p, fieldName: "META_COMMANDS", required: false, type: ForwardOffset<Vector<ForwardOffset<MetaCommand>, MetaCommand>>.self)
    _v.finish()
  }
}

///  Fixed frame stream
public struct FixedFrameStream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FixedFrameStream.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case FRAME_SIZE_IN_BITS = 8
    case SYNC_PATTERN = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Stream name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Frame size in bits
  public var FRAME_SIZE_IN_BITS: UInt32 { let o = _accessor.offset(VTOFFSET.FRAME_SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Sync pattern (hex string)
  public var SYNC_PATTERN: String? { let o = _accessor.offset(VTOFFSET.SYNC_PATTERN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SYNC_PATTERNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SYNC_PATTERN.v) }
  public static func startFixedFrameStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(FRAME_SIZE_IN_BITS: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FRAME_SIZE_IN_BITS, def: 0, at: VTOFFSET.FRAME_SIZE_IN_BITS.p) }
  public static func add(SYNC_PATTERN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SYNC_PATTERN, at: VTOFFSET.SYNC_PATTERN.p) }
  public static func endFixedFrameStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFixedFrameStream(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    FRAME_SIZE_IN_BITS: UInt32 = 0,
    SYNC_PATTERNOffset SYNC_PATTERN: Offset = Offset()
  ) -> Offset {
    let __start = FixedFrameStream.startFixedFrameStream(&fbb)
    FixedFrameStream.add(NAME: NAME, &fbb)
    FixedFrameStream.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    FixedFrameStream.add(FRAME_SIZE_IN_BITS: FRAME_SIZE_IN_BITS, &fbb)
    FixedFrameStream.add(SYNC_PATTERN: SYNC_PATTERN, &fbb)
    return FixedFrameStream.endFixedFrameStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FRAME_SIZE_IN_BITS.p, fieldName: "FRAME_SIZE_IN_BITS", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.SYNC_PATTERN.p, fieldName: "SYNC_PATTERN", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Variable frame stream
public struct VariableFrameStream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: VariableFrameStream.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case MIN_FRAME_SIZE_IN_BITS = 8
    case MAX_FRAME_SIZE_IN_BITS = 10
    case SIZE_FIELD_OFFSET = 12
    case SIZE_FIELD_SIZE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Stream name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Minimum frame size in bits
  public var MIN_FRAME_SIZE_IN_BITS: UInt32 { let o = _accessor.offset(VTOFFSET.MIN_FRAME_SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Maximum frame size in bits
  public var MAX_FRAME_SIZE_IN_BITS: UInt32 { let o = _accessor.offset(VTOFFSET.MAX_FRAME_SIZE_IN_BITS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Size field location in bits
  public var SIZE_FIELD_OFFSET: UInt32 { let o = _accessor.offset(VTOFFSET.SIZE_FIELD_OFFSET.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Size field size in bits
  public var SIZE_FIELD_SIZE: UInt16 { let o = _accessor.offset(VTOFFSET.SIZE_FIELD_SIZE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public static func startVariableFrameStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(MIN_FRAME_SIZE_IN_BITS: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MIN_FRAME_SIZE_IN_BITS, def: 0, at: VTOFFSET.MIN_FRAME_SIZE_IN_BITS.p) }
  public static func add(MAX_FRAME_SIZE_IN_BITS: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_FRAME_SIZE_IN_BITS, def: 0, at: VTOFFSET.MAX_FRAME_SIZE_IN_BITS.p) }
  public static func add(SIZE_FIELD_OFFSET: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_FIELD_OFFSET, def: 0, at: VTOFFSET.SIZE_FIELD_OFFSET.p) }
  public static func add(SIZE_FIELD_SIZE: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SIZE_FIELD_SIZE, def: 0, at: VTOFFSET.SIZE_FIELD_SIZE.p) }
  public static func endVariableFrameStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVariableFrameStream(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    MIN_FRAME_SIZE_IN_BITS: UInt32 = 0,
    MAX_FRAME_SIZE_IN_BITS: UInt32 = 0,
    SIZE_FIELD_OFFSET: UInt32 = 0,
    SIZE_FIELD_SIZE: UInt16 = 0
  ) -> Offset {
    let __start = VariableFrameStream.startVariableFrameStream(&fbb)
    VariableFrameStream.add(NAME: NAME, &fbb)
    VariableFrameStream.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    VariableFrameStream.add(MIN_FRAME_SIZE_IN_BITS: MIN_FRAME_SIZE_IN_BITS, &fbb)
    VariableFrameStream.add(MAX_FRAME_SIZE_IN_BITS: MAX_FRAME_SIZE_IN_BITS, &fbb)
    VariableFrameStream.add(SIZE_FIELD_OFFSET: SIZE_FIELD_OFFSET, &fbb)
    VariableFrameStream.add(SIZE_FIELD_SIZE: SIZE_FIELD_SIZE, &fbb)
    return VariableFrameStream.endVariableFrameStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MIN_FRAME_SIZE_IN_BITS.p, fieldName: "MIN_FRAME_SIZE_IN_BITS", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.MAX_FRAME_SIZE_IN_BITS.p, fieldName: "MAX_FRAME_SIZE_IN_BITS", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.SIZE_FIELD_OFFSET.p, fieldName: "SIZE_FIELD_OFFSET", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.SIZE_FIELD_SIZE.p, fieldName: "SIZE_FIELD_SIZE", required: false, type: UInt16.self)
    _v.finish()
  }
}

///  Custom stream
public struct CustomStream: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CustomStream.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case ALGORITHM_REF = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Stream name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Algorithm reference for parsing
  public var ALGORITHM_REF: String? { let o = _accessor.offset(VTOFFSET.ALGORITHM_REF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ALGORITHM_REFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ALGORITHM_REF.v) }
  public static func startCustomStream(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(ALGORITHM_REF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALGORITHM_REF, at: VTOFFSET.ALGORITHM_REF.p) }
  public static func endCustomStream(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCustomStream(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    ALGORITHM_REFOffset ALGORITHM_REF: Offset = Offset()
  ) -> Offset {
    let __start = CustomStream.startCustomStream(&fbb)
    CustomStream.add(NAME: NAME, &fbb)
    CustomStream.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    CustomStream.add(ALGORITHM_REF: ALGORITHM_REF, &fbb)
    return CustomStream.endCustomStream(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALGORITHM_REF.p, fieldName: "ALGORITHM_REF", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of streams
public struct StreamSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StreamSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case FIXED_FRAME_STREAMS = 4
    case VARIABLE_FRAME_STREAMS = 6
    case CUSTOM_STREAMS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Fixed frame streams
  public var hasFixedFrameStreams: Bool { let o = _accessor.offset(VTOFFSET.FIXED_FRAME_STREAMS.v); return o == 0 ? false : true }
  public var FIXED_FRAME_STREAMSCount: Int32 { let o = _accessor.offset(VTOFFSET.FIXED_FRAME_STREAMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FIXED_FRAME_STREAMS(at index: Int32) -> FixedFrameStream? { let o = _accessor.offset(VTOFFSET.FIXED_FRAME_STREAMS.v); return o == 0 ? nil : FixedFrameStream(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Variable frame streams
  public var hasVariableFrameStreams: Bool { let o = _accessor.offset(VTOFFSET.VARIABLE_FRAME_STREAMS.v); return o == 0 ? false : true }
  public var VARIABLE_FRAME_STREAMSCount: Int32 { let o = _accessor.offset(VTOFFSET.VARIABLE_FRAME_STREAMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func VARIABLE_FRAME_STREAMS(at index: Int32) -> VariableFrameStream? { let o = _accessor.offset(VTOFFSET.VARIABLE_FRAME_STREAMS.v); return o == 0 ? nil : VariableFrameStream(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Custom streams
  public var hasCustomStreams: Bool { let o = _accessor.offset(VTOFFSET.CUSTOM_STREAMS.v); return o == 0 ? false : true }
  public var CUSTOM_STREAMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CUSTOM_STREAMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CUSTOM_STREAMS(at index: Int32) -> CustomStream? { let o = _accessor.offset(VTOFFSET.CUSTOM_STREAMS.v); return o == 0 ? nil : CustomStream(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startStreamSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(FIXED_FRAME_STREAMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FIXED_FRAME_STREAMS, at: VTOFFSET.FIXED_FRAME_STREAMS.p) }
  public static func addVectorOf(VARIABLE_FRAME_STREAMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VARIABLE_FRAME_STREAMS, at: VTOFFSET.VARIABLE_FRAME_STREAMS.p) }
  public static func addVectorOf(CUSTOM_STREAMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CUSTOM_STREAMS, at: VTOFFSET.CUSTOM_STREAMS.p) }
  public static func endStreamSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStreamSet(
    _ fbb: inout FlatBufferBuilder,
    FIXED_FRAME_STREAMSVectorOffset FIXED_FRAME_STREAMS: Offset = Offset(),
    VARIABLE_FRAME_STREAMSVectorOffset VARIABLE_FRAME_STREAMS: Offset = Offset(),
    CUSTOM_STREAMSVectorOffset CUSTOM_STREAMS: Offset = Offset()
  ) -> Offset {
    let __start = StreamSet.startStreamSet(&fbb)
    StreamSet.addVectorOf(FIXED_FRAME_STREAMS: FIXED_FRAME_STREAMS, &fbb)
    StreamSet.addVectorOf(VARIABLE_FRAME_STREAMS: VARIABLE_FRAME_STREAMS, &fbb)
    StreamSet.addVectorOf(CUSTOM_STREAMS: CUSTOM_STREAMS, &fbb)
    return StreamSet.endStreamSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.FIXED_FRAME_STREAMS.p, fieldName: "FIXED_FRAME_STREAMS", required: false, type: ForwardOffset<Vector<ForwardOffset<FixedFrameStream>, FixedFrameStream>>.self)
    try _v.visit(field: VTOFFSET.VARIABLE_FRAME_STREAMS.p, fieldName: "VARIABLE_FRAME_STREAMS", required: false, type: ForwardOffset<Vector<ForwardOffset<VariableFrameStream>, VariableFrameStream>>.self)
    try _v.visit(field: VTOFFSET.CUSTOM_STREAMS.p, fieldName: "CUSTOM_STREAMS", required: false, type: ForwardOffset<Vector<ForwardOffset<CustomStream>, CustomStream>>.self)
    _v.finish()
  }
}

///  Service definition
public struct Service: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Service.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case CONTAINER_REFS = 10
    case COMMAND_REFS = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Service name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Container references provided by this service
  public var hasContainerRefs: Bool { let o = _accessor.offset(VTOFFSET.CONTAINER_REFS.v); return o == 0 ? false : true }
  public var CONTAINER_REFSCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTAINER_REFS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTAINER_REFS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.CONTAINER_REFS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Command references accepted by this service
  public var hasCommandRefs: Bool { let o = _accessor.offset(VTOFFSET.COMMAND_REFS.v); return o == 0 ? false : true }
  public var COMMAND_REFSCount: Int32 { let o = _accessor.offset(VTOFFSET.COMMAND_REFS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMMAND_REFS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COMMAND_REFS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startService(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func addVectorOf(CONTAINER_REFS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_REFS, at: VTOFFSET.CONTAINER_REFS.p) }
  public static func addVectorOf(COMMAND_REFS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND_REFS, at: VTOFFSET.COMMAND_REFS.p) }
  public static func endService(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createService(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    CONTAINER_REFSVectorOffset CONTAINER_REFS: Offset = Offset(),
    COMMAND_REFSVectorOffset COMMAND_REFS: Offset = Offset()
  ) -> Offset {
    let __start = Service.startService(&fbb)
    Service.add(NAME: NAME, &fbb)
    Service.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    Service.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    Service.addVectorOf(CONTAINER_REFS: CONTAINER_REFS, &fbb)
    Service.addVectorOf(COMMAND_REFS: COMMAND_REFS, &fbb)
    return Service.endService(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTAINER_REFS.p, fieldName: "CONTAINER_REFS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.COMMAND_REFS.p, fieldName: "COMMAND_REFS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

///  Collection of services
public struct ServiceSet: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ServiceSet.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SERVICES = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Services
  public var hasServices: Bool { let o = _accessor.offset(VTOFFSET.SERVICES.v); return o == 0 ? false : true }
  public var SERVICESCount: Int32 { let o = _accessor.offset(VTOFFSET.SERVICES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SERVICES(at index: Int32) -> Service? { let o = _accessor.offset(VTOFFSET.SERVICES.v); return o == 0 ? nil : Service(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startServiceSet(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(SERVICES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SERVICES, at: VTOFFSET.SERVICES.p) }
  public static func endServiceSet(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createServiceSet(
    _ fbb: inout FlatBufferBuilder,
    SERVICESVectorOffset SERVICES: Offset = Offset()
  ) -> Offset {
    let __start = ServiceSet.startServiceSet(&fbb)
    ServiceSet.addVectorOf(SERVICES: SERVICES, &fbb)
    return ServiceSet.endServiceSet(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SERVICES.p, fieldName: "SERVICES", required: false, type: ForwardOffset<Vector<ForwardOffset<Service>, Service>>.self)
    _v.finish()
  }
}

///  Document header information
public struct XTCHeader: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: XTCHeader.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case VERSION = 4
    case DATE = 6
    case CLASSIFICATION = 8
    case VALIDATION_STATUS = 10
    case AUTHOR = 12
    case NOTES = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Version of this XTCE document
  public var VERSION: String? { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VERSION.v) }
  ///  Date of document creation (ISO 8601)
  public var DATE: String? { let o = _accessor.offset(VTOFFSET.DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DATE.v) }
  ///  Classification level
  public var CLASSIFICATION: String? { let o = _accessor.offset(VTOFFSET.CLASSIFICATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLASSIFICATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLASSIFICATION.v) }
  ///  Validation status
  public var VALIDATION_STATUS: String? { let o = _accessor.offset(VTOFFSET.VALIDATION_STATUS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALIDATION_STATUSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALIDATION_STATUS.v) }
  ///  Author information
  public var AUTHOR: String? { let o = _accessor.offset(VTOFFSET.AUTHOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AUTHORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AUTHOR.v) }
  ///  Notes/comments
  public var hasNotes: Bool { let o = _accessor.offset(VTOFFSET.NOTES.v); return o == 0 ? false : true }
  public var NOTESCount: Int32 { let o = _accessor.offset(VTOFFSET.NOTES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func NOTES(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.NOTES.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startXTCHeader(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERSION, at: VTOFFSET.VERSION.p) }
  public static func add(DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATE, at: VTOFFSET.DATE.p) }
  public static func add(CLASSIFICATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLASSIFICATION, at: VTOFFSET.CLASSIFICATION.p) }
  public static func add(VALIDATION_STATUS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALIDATION_STATUS, at: VTOFFSET.VALIDATION_STATUS.p) }
  public static func add(AUTHOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AUTHOR, at: VTOFFSET.AUTHOR.p) }
  public static func addVectorOf(NOTES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NOTES, at: VTOFFSET.NOTES.p) }
  public static func endXTCHeader(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createXTCHeader(
    _ fbb: inout FlatBufferBuilder,
    VERSIONOffset VERSION: Offset = Offset(),
    DATEOffset DATE: Offset = Offset(),
    CLASSIFICATIONOffset CLASSIFICATION: Offset = Offset(),
    VALIDATION_STATUSOffset VALIDATION_STATUS: Offset = Offset(),
    AUTHOROffset AUTHOR: Offset = Offset(),
    NOTESVectorOffset NOTES: Offset = Offset()
  ) -> Offset {
    let __start = XTCHeader.startXTCHeader(&fbb)
    XTCHeader.add(VERSION: VERSION, &fbb)
    XTCHeader.add(DATE: DATE, &fbb)
    XTCHeader.add(CLASSIFICATION: CLASSIFICATION, &fbb)
    XTCHeader.add(VALIDATION_STATUS: VALIDATION_STATUS, &fbb)
    XTCHeader.add(AUTHOR: AUTHOR, &fbb)
    XTCHeader.addVectorOf(NOTES: NOTES, &fbb)
    return XTCHeader.endXTCHeader(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATE.p, fieldName: "DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CLASSIFICATION.p, fieldName: "CLASSIFICATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALIDATION_STATUS.p, fieldName: "VALIDATION_STATUS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AUTHOR.p, fieldName: "AUTHOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NOTES.p, fieldName: "NOTES", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

///  Telemetry metadata collection
public struct TelemetryMetaData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TelemetryMetaData.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAMETER_TYPE_SET = 4
    case PARAMETER_SET = 6
    case CONTAINER_SET = 8
    case ALGORITHM_SET = 10
    case STREAM_SET = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Parameter type definitions
  public var PARAMETER_TYPE_SET: ParameterTypeSet? { let o = _accessor.offset(VTOFFSET.PARAMETER_TYPE_SET.v); return o == 0 ? nil : ParameterTypeSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Parameter definitions
  public var PARAMETER_SET: ParameterSet? { let o = _accessor.offset(VTOFFSET.PARAMETER_SET.v); return o == 0 ? nil : ParameterSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Container definitions
  public var CONTAINER_SET: ContainerSet? { let o = _accessor.offset(VTOFFSET.CONTAINER_SET.v); return o == 0 ? nil : ContainerSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Algorithm definitions
  public var ALGORITHM_SET: AlgorithmSet? { let o = _accessor.offset(VTOFFSET.ALGORITHM_SET.v); return o == 0 ? nil : AlgorithmSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Stream definitions
  public var STREAM_SET: StreamSet? { let o = _accessor.offset(VTOFFSET.STREAM_SET.v); return o == 0 ? nil : StreamSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startTelemetryMetaData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(PARAMETER_TYPE_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_TYPE_SET, at: VTOFFSET.PARAMETER_TYPE_SET.p) }
  public static func add(PARAMETER_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_SET, at: VTOFFSET.PARAMETER_SET.p) }
  public static func add(CONTAINER_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTAINER_SET, at: VTOFFSET.CONTAINER_SET.p) }
  public static func add(ALGORITHM_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALGORITHM_SET, at: VTOFFSET.ALGORITHM_SET.p) }
  public static func add(STREAM_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STREAM_SET, at: VTOFFSET.STREAM_SET.p) }
  public static func endTelemetryMetaData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTelemetryMetaData(
    _ fbb: inout FlatBufferBuilder,
    PARAMETER_TYPE_SETOffset PARAMETER_TYPE_SET: Offset = Offset(),
    PARAMETER_SETOffset PARAMETER_SET: Offset = Offset(),
    CONTAINER_SETOffset CONTAINER_SET: Offset = Offset(),
    ALGORITHM_SETOffset ALGORITHM_SET: Offset = Offset(),
    STREAM_SETOffset STREAM_SET: Offset = Offset()
  ) -> Offset {
    let __start = TelemetryMetaData.startTelemetryMetaData(&fbb)
    TelemetryMetaData.add(PARAMETER_TYPE_SET: PARAMETER_TYPE_SET, &fbb)
    TelemetryMetaData.add(PARAMETER_SET: PARAMETER_SET, &fbb)
    TelemetryMetaData.add(CONTAINER_SET: CONTAINER_SET, &fbb)
    TelemetryMetaData.add(ALGORITHM_SET: ALGORITHM_SET, &fbb)
    TelemetryMetaData.add(STREAM_SET: STREAM_SET, &fbb)
    return TelemetryMetaData.endTelemetryMetaData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAMETER_TYPE_SET.p, fieldName: "PARAMETER_TYPE_SET", required: false, type: ForwardOffset<ParameterTypeSet>.self)
    try _v.visit(field: VTOFFSET.PARAMETER_SET.p, fieldName: "PARAMETER_SET", required: false, type: ForwardOffset<ParameterSet>.self)
    try _v.visit(field: VTOFFSET.CONTAINER_SET.p, fieldName: "CONTAINER_SET", required: false, type: ForwardOffset<ContainerSet>.self)
    try _v.visit(field: VTOFFSET.ALGORITHM_SET.p, fieldName: "ALGORITHM_SET", required: false, type: ForwardOffset<AlgorithmSet>.self)
    try _v.visit(field: VTOFFSET.STREAM_SET.p, fieldName: "STREAM_SET", required: false, type: ForwardOffset<StreamSet>.self)
    _v.finish()
  }
}

///  Command metadata collection
public struct CommandMetaData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CommandMetaData.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ARGUMENT_TYPE_SET = 4
    case PARAMETER_TYPE_SET = 6
    case PARAMETER_SET = 8
    case META_COMMAND_SET = 10
    case COMMAND_CONTAINER_SET = 12
    case ALGORITHM_SET = 14
    case STREAM_SET = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Argument type definitions
  public var ARGUMENT_TYPE_SET: ArgumentTypeSet? { let o = _accessor.offset(VTOFFSET.ARGUMENT_TYPE_SET.v); return o == 0 ? nil : ArgumentTypeSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Parameter types used by commands
  public var PARAMETER_TYPE_SET: ParameterTypeSet? { let o = _accessor.offset(VTOFFSET.PARAMETER_TYPE_SET.v); return o == 0 ? nil : ParameterTypeSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Parameters used by commands
  public var PARAMETER_SET: ParameterSet? { let o = _accessor.offset(VTOFFSET.PARAMETER_SET.v); return o == 0 ? nil : ParameterSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  MetaCommand definitions
  public var META_COMMAND_SET: MetaCommandSet? { let o = _accessor.offset(VTOFFSET.META_COMMAND_SET.v); return o == 0 ? nil : MetaCommandSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Command container set
  public var COMMAND_CONTAINER_SET: ContainerSet? { let o = _accessor.offset(VTOFFSET.COMMAND_CONTAINER_SET.v); return o == 0 ? nil : ContainerSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Algorithm definitions
  public var ALGORITHM_SET: AlgorithmSet? { let o = _accessor.offset(VTOFFSET.ALGORITHM_SET.v); return o == 0 ? nil : AlgorithmSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Stream definitions
  public var STREAM_SET: StreamSet? { let o = _accessor.offset(VTOFFSET.STREAM_SET.v); return o == 0 ? nil : StreamSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCommandMetaData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(ARGUMENT_TYPE_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ARGUMENT_TYPE_SET, at: VTOFFSET.ARGUMENT_TYPE_SET.p) }
  public static func add(PARAMETER_TYPE_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_TYPE_SET, at: VTOFFSET.PARAMETER_TYPE_SET.p) }
  public static func add(PARAMETER_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAMETER_SET, at: VTOFFSET.PARAMETER_SET.p) }
  public static func add(META_COMMAND_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: META_COMMAND_SET, at: VTOFFSET.META_COMMAND_SET.p) }
  public static func add(COMMAND_CONTAINER_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND_CONTAINER_SET, at: VTOFFSET.COMMAND_CONTAINER_SET.p) }
  public static func add(ALGORITHM_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALGORITHM_SET, at: VTOFFSET.ALGORITHM_SET.p) }
  public static func add(STREAM_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STREAM_SET, at: VTOFFSET.STREAM_SET.p) }
  public static func endCommandMetaData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCommandMetaData(
    _ fbb: inout FlatBufferBuilder,
    ARGUMENT_TYPE_SETOffset ARGUMENT_TYPE_SET: Offset = Offset(),
    PARAMETER_TYPE_SETOffset PARAMETER_TYPE_SET: Offset = Offset(),
    PARAMETER_SETOffset PARAMETER_SET: Offset = Offset(),
    META_COMMAND_SETOffset META_COMMAND_SET: Offset = Offset(),
    COMMAND_CONTAINER_SETOffset COMMAND_CONTAINER_SET: Offset = Offset(),
    ALGORITHM_SETOffset ALGORITHM_SET: Offset = Offset(),
    STREAM_SETOffset STREAM_SET: Offset = Offset()
  ) -> Offset {
    let __start = CommandMetaData.startCommandMetaData(&fbb)
    CommandMetaData.add(ARGUMENT_TYPE_SET: ARGUMENT_TYPE_SET, &fbb)
    CommandMetaData.add(PARAMETER_TYPE_SET: PARAMETER_TYPE_SET, &fbb)
    CommandMetaData.add(PARAMETER_SET: PARAMETER_SET, &fbb)
    CommandMetaData.add(META_COMMAND_SET: META_COMMAND_SET, &fbb)
    CommandMetaData.add(COMMAND_CONTAINER_SET: COMMAND_CONTAINER_SET, &fbb)
    CommandMetaData.add(ALGORITHM_SET: ALGORITHM_SET, &fbb)
    CommandMetaData.add(STREAM_SET: STREAM_SET, &fbb)
    return CommandMetaData.endCommandMetaData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ARGUMENT_TYPE_SET.p, fieldName: "ARGUMENT_TYPE_SET", required: false, type: ForwardOffset<ArgumentTypeSet>.self)
    try _v.visit(field: VTOFFSET.PARAMETER_TYPE_SET.p, fieldName: "PARAMETER_TYPE_SET", required: false, type: ForwardOffset<ParameterTypeSet>.self)
    try _v.visit(field: VTOFFSET.PARAMETER_SET.p, fieldName: "PARAMETER_SET", required: false, type: ForwardOffset<ParameterSet>.self)
    try _v.visit(field: VTOFFSET.META_COMMAND_SET.p, fieldName: "META_COMMAND_SET", required: false, type: ForwardOffset<MetaCommandSet>.self)
    try _v.visit(field: VTOFFSET.COMMAND_CONTAINER_SET.p, fieldName: "COMMAND_CONTAINER_SET", required: false, type: ForwardOffset<ContainerSet>.self)
    try _v.visit(field: VTOFFSET.ALGORITHM_SET.p, fieldName: "ALGORITHM_SET", required: false, type: ForwardOffset<AlgorithmSet>.self)
    try _v.visit(field: VTOFFSET.STREAM_SET.p, fieldName: "STREAM_SET", required: false, type: ForwardOffset<StreamSet>.self)
    _v.finish()
  }
}

///  SpaceSystem - Root element for XTCE document
///  A SpaceSystem defines the telemetry and command configuration for a space
///  vehicle or subsystem. SpaceSystems can be nested hierarchically to represent
///  the structure of a spacecraft (e.g., spacecraft -> subsystem -> payload).
public struct XTC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$XTC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: XTC.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case SHORT_DESCRIPTION = 6
    case LONG_DESCRIPTION = 8
    case OPERATIONAL_STATUS = 10
    case HEADER = 12
    case TELEMETRY_META_DATA = 14
    case COMMAND_META_DATA = 16
    case SERVICE_SET = 18
    case CHILD_SYSTEMS = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of this space system
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Short description
  public var SHORT_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.SHORT_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SHORT_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SHORT_DESCRIPTION.v) }
  ///  Long description
  public var LONG_DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.LONG_DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LONG_DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LONG_DESCRIPTION.v) }
  ///  Operational status
  public var OPERATIONAL_STATUS: String? { let o = _accessor.offset(VTOFFSET.OPERATIONAL_STATUS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OPERATIONAL_STATUSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OPERATIONAL_STATUS.v) }
  ///  Document header
  public var HEADER: XTCHeader? { let o = _accessor.offset(VTOFFSET.HEADER.v); return o == 0 ? nil : XTCHeader(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Telemetry metadata
  public var TELEMETRY_META_DATA: TelemetryMetaData? { let o = _accessor.offset(VTOFFSET.TELEMETRY_META_DATA.v); return o == 0 ? nil : TelemetryMetaData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Command metadata
  public var COMMAND_META_DATA: CommandMetaData? { let o = _accessor.offset(VTOFFSET.COMMAND_META_DATA.v); return o == 0 ? nil : CommandMetaData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Service definitions
  public var SERVICE_SET: ServiceSet? { let o = _accessor.offset(VTOFFSET.SERVICE_SET.v); return o == 0 ? nil : ServiceSet(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Child space systems (hierarchical structure)
  public var hasChildSystems: Bool { let o = _accessor.offset(VTOFFSET.CHILD_SYSTEMS.v); return o == 0 ? false : true }
  public var CHILD_SYSTEMSCount: Int32 { let o = _accessor.offset(VTOFFSET.CHILD_SYSTEMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CHILD_SYSTEMS(at index: Int32) -> XTC? { let o = _accessor.offset(VTOFFSET.CHILD_SYSTEMS.v); return o == 0 ? nil : XTC(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startXTC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(SHORT_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SHORT_DESCRIPTION, at: VTOFFSET.SHORT_DESCRIPTION.p) }
  public static func add(LONG_DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LONG_DESCRIPTION, at: VTOFFSET.LONG_DESCRIPTION.p) }
  public static func add(OPERATIONAL_STATUS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OPERATIONAL_STATUS, at: VTOFFSET.OPERATIONAL_STATUS.p) }
  public static func add(HEADER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HEADER, at: VTOFFSET.HEADER.p) }
  public static func add(TELEMETRY_META_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TELEMETRY_META_DATA, at: VTOFFSET.TELEMETRY_META_DATA.p) }
  public static func add(COMMAND_META_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND_META_DATA, at: VTOFFSET.COMMAND_META_DATA.p) }
  public static func add(SERVICE_SET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SERVICE_SET, at: VTOFFSET.SERVICE_SET.p) }
  public static func addVectorOf(CHILD_SYSTEMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CHILD_SYSTEMS, at: VTOFFSET.CHILD_SYSTEMS.p) }
  public static func endXTC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createXTC(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    SHORT_DESCRIPTIONOffset SHORT_DESCRIPTION: Offset = Offset(),
    LONG_DESCRIPTIONOffset LONG_DESCRIPTION: Offset = Offset(),
    OPERATIONAL_STATUSOffset OPERATIONAL_STATUS: Offset = Offset(),
    HEADEROffset HEADER: Offset = Offset(),
    TELEMETRY_META_DATAOffset TELEMETRY_META_DATA: Offset = Offset(),
    COMMAND_META_DATAOffset COMMAND_META_DATA: Offset = Offset(),
    SERVICE_SETOffset SERVICE_SET: Offset = Offset(),
    CHILD_SYSTEMSVectorOffset CHILD_SYSTEMS: Offset = Offset()
  ) -> Offset {
    let __start = XTC.startXTC(&fbb)
    XTC.add(NAME: NAME, &fbb)
    XTC.add(SHORT_DESCRIPTION: SHORT_DESCRIPTION, &fbb)
    XTC.add(LONG_DESCRIPTION: LONG_DESCRIPTION, &fbb)
    XTC.add(OPERATIONAL_STATUS: OPERATIONAL_STATUS, &fbb)
    XTC.add(HEADER: HEADER, &fbb)
    XTC.add(TELEMETRY_META_DATA: TELEMETRY_META_DATA, &fbb)
    XTC.add(COMMAND_META_DATA: COMMAND_META_DATA, &fbb)
    XTC.add(SERVICE_SET: SERVICE_SET, &fbb)
    XTC.addVectorOf(CHILD_SYSTEMS: CHILD_SYSTEMS, &fbb)
    return XTC.endXTC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SHORT_DESCRIPTION.p, fieldName: "SHORT_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LONG_DESCRIPTION.p, fieldName: "LONG_DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OPERATIONAL_STATUS.p, fieldName: "OPERATIONAL_STATUS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HEADER.p, fieldName: "HEADER", required: false, type: ForwardOffset<XTCHeader>.self)
    try _v.visit(field: VTOFFSET.TELEMETRY_META_DATA.p, fieldName: "TELEMETRY_META_DATA", required: false, type: ForwardOffset<TelemetryMetaData>.self)
    try _v.visit(field: VTOFFSET.COMMAND_META_DATA.p, fieldName: "COMMAND_META_DATA", required: false, type: ForwardOffset<CommandMetaData>.self)
    try _v.visit(field: VTOFFSET.SERVICE_SET.p, fieldName: "SERVICE_SET", required: false, type: ForwardOffset<ServiceSet>.self)
    try _v.visit(field: VTOFFSET.CHILD_SYSTEMS.p, fieldName: "CHILD_SYSTEMS", required: false, type: ForwardOffset<Vector<ForwardOffset<XTC>, XTC>>.self)
    _v.finish()
  }
}

