// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Access type for data listings
public enum accessType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  One-time purchase
  case onetime = 0
  ///  Recurring subscription
  case subscription = 1
  ///  Real-time streaming access
  case streaming = 2
  ///  Query-based access
  case query = 3

  public static var max: accessType { return .query }
  public static var min: accessType { return .onetime }
}


///  Payment method accepted
public enum paymentMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Ethereum cryptocurrency
  case cryptoEth = 0
  ///  Solana cryptocurrency
  case cryptoSol = 1
  ///  Bitcoin cryptocurrency
  case cryptoBtc = 2
  ///  Internal SDN credits system
  case sdnCredits = 3
  ///  Fiat payment via Stripe
  case fiatStripe = 4
  ///  Free/open data
  case free = 5

  public static var max: paymentMethod { return .free }
  public static var min: paymentMethod { return .cryptoEth }
}


///  Spatial coverage definition
public struct SpatialCoverage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$STF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SpatialCoverage.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case TYPE = 4
    case REGIONS = 6
    case OBJECT_IDS = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type of coverage: "global", "region", "object_list"
  public var TYPE: String? { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE.v) }
  ///  Regions covered, e.g., ["LEO", "GEO", "MEO"]
  public var hasRegions: Bool { let o = _accessor.offset(VTOFFSET.REGIONS.v); return o == 0 ? false : true }
  public var REGIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.REGIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func REGIONS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.REGIONS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Specific NORAD IDs or catalog numbers
  public var hasObjectIds: Bool { let o = _accessor.offset(VTOFFSET.OBJECT_IDS.v); return o == 0 ? false : true }
  public var OBJECT_IDSCount: Int32 { let o = _accessor.offset(VTOFFSET.OBJECT_IDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OBJECT_IDS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.OBJECT_IDS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startSpatialCoverage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE, at: VTOFFSET.TYPE.p) }
  public static func addVectorOf(REGIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REGIONS, at: VTOFFSET.REGIONS.p) }
  public static func addVectorOf(OBJECT_IDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_IDS, at: VTOFFSET.OBJECT_IDS.p) }
  public static func endSpatialCoverage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSpatialCoverage(
    _ fbb: inout FlatBufferBuilder,
    TYPEOffset TYPE: Offset = Offset(),
    REGIONSVectorOffset REGIONS: Offset = Offset(),
    OBJECT_IDSVectorOffset OBJECT_IDS: Offset = Offset()
  ) -> Offset {
    let __start = SpatialCoverage.startSpatialCoverage(&fbb)
    SpatialCoverage.add(TYPE: TYPE, &fbb)
    SpatialCoverage.addVectorOf(REGIONS: REGIONS, &fbb)
    SpatialCoverage.addVectorOf(OBJECT_IDS: OBJECT_IDS, &fbb)
    return SpatialCoverage.endSpatialCoverage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REGIONS.p, fieldName: "REGIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OBJECT_IDS.p, fieldName: "OBJECT_IDS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

///  Temporal coverage definition
public struct TemporalCoverage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$STF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TemporalCoverage.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case START_EPOCH = 4
    case END_EPOCH = 6
    case UPDATE_FREQUENCY = 8
    case HISTORICAL_DEPTH = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Start epoch in ISO 8601 format
  public var START_EPOCH: String? { let o = _accessor.offset(VTOFFSET.START_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var START_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.START_EPOCH.v) }
  ///  End epoch in ISO 8601 format
  public var END_EPOCH: String? { let o = _accessor.offset(VTOFFSET.END_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var END_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.END_EPOCH.v) }
  ///  Update frequency: "realtime", "hourly", "daily"
  public var UPDATE_FREQUENCY: String? { let o = _accessor.offset(VTOFFSET.UPDATE_FREQUENCY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var UPDATE_FREQUENCYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.UPDATE_FREQUENCY.v) }
  ///  Days of historical data available
  public var HISTORICAL_DEPTH: UInt32 { let o = _accessor.offset(VTOFFSET.HISTORICAL_DEPTH.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public static func startTemporalCoverage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(START_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: START_EPOCH, at: VTOFFSET.START_EPOCH.p) }
  public static func add(END_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: END_EPOCH, at: VTOFFSET.END_EPOCH.p) }
  public static func add(UPDATE_FREQUENCY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UPDATE_FREQUENCY, at: VTOFFSET.UPDATE_FREQUENCY.p) }
  public static func add(HISTORICAL_DEPTH: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HISTORICAL_DEPTH, def: 0, at: VTOFFSET.HISTORICAL_DEPTH.p) }
  public static func endTemporalCoverage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTemporalCoverage(
    _ fbb: inout FlatBufferBuilder,
    START_EPOCHOffset START_EPOCH: Offset = Offset(),
    END_EPOCHOffset END_EPOCH: Offset = Offset(),
    UPDATE_FREQUENCYOffset UPDATE_FREQUENCY: Offset = Offset(),
    HISTORICAL_DEPTH: UInt32 = 0
  ) -> Offset {
    let __start = TemporalCoverage.startTemporalCoverage(&fbb)
    TemporalCoverage.add(START_EPOCH: START_EPOCH, &fbb)
    TemporalCoverage.add(END_EPOCH: END_EPOCH, &fbb)
    TemporalCoverage.add(UPDATE_FREQUENCY: UPDATE_FREQUENCY, &fbb)
    TemporalCoverage.add(HISTORICAL_DEPTH: HISTORICAL_DEPTH, &fbb)
    return TemporalCoverage.endTemporalCoverage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.START_EPOCH.p, fieldName: "START_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.END_EPOCH.p, fieldName: "END_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.UPDATE_FREQUENCY.p, fieldName: "UPDATE_FREQUENCY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HISTORICAL_DEPTH.p, fieldName: "HISTORICAL_DEPTH", required: false, type: UInt32.self)
    _v.finish()
  }
}

///  Data coverage combining spatial and temporal
public struct DataCoverage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$STF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: DataCoverage.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SPATIAL = 4
    case TEMPORAL = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Spatial coverage definition
  public var SPATIAL: SpatialCoverage? { let o = _accessor.offset(VTOFFSET.SPATIAL.v); return o == 0 ? nil : SpatialCoverage(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Temporal coverage definition
  public var TEMPORAL: TemporalCoverage? { let o = _accessor.offset(VTOFFSET.TEMPORAL.v); return o == 0 ? nil : TemporalCoverage(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startDataCoverage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(SPATIAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SPATIAL, at: VTOFFSET.SPATIAL.p) }
  public static func add(TEMPORAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TEMPORAL, at: VTOFFSET.TEMPORAL.p) }
  public static func endDataCoverage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createDataCoverage(
    _ fbb: inout FlatBufferBuilder,
    SPATIALOffset SPATIAL: Offset = Offset(),
    TEMPORALOffset TEMPORAL: Offset = Offset()
  ) -> Offset {
    let __start = DataCoverage.startDataCoverage(&fbb)
    DataCoverage.add(SPATIAL: SPATIAL, &fbb)
    DataCoverage.add(TEMPORAL: TEMPORAL, &fbb)
    return DataCoverage.endDataCoverage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SPATIAL.p, fieldName: "SPATIAL", required: false, type: ForwardOffset<SpatialCoverage>.self)
    try _v.visit(field: VTOFFSET.TEMPORAL.p, fieldName: "TEMPORAL", required: false, type: ForwardOffset<TemporalCoverage>.self)
    _v.finish()
  }
}

///  Pricing tier for a listing
public struct PricingTier: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$STF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PricingTier.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case PRICE_AMOUNT = 6
    case PRICE_CURRENCY = 8
    case DURATION_DAYS = 10
    case RATE_LIMIT = 12
    case FEATURES = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Tier name, e.g., "Basic", "Pro", "Enterprise"
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Price in smallest unit (cents, satoshis, etc.)
  public var PRICE_AMOUNT: UInt64 { let o = _accessor.offset(VTOFFSET.PRICE_AMOUNT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Currency code: "USD", "ETH", "SOL", "SDN_CREDITS"
  public var PRICE_CURRENCY: String? { let o = _accessor.offset(VTOFFSET.PRICE_CURRENCY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PRICE_CURRENCYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PRICE_CURRENCY.v) }
  ///  Duration in days (0 = one-time purchase)
  public var DURATION_DAYS: UInt32 { let o = _accessor.offset(VTOFFSET.DURATION_DAYS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Rate limit in requests per hour
  public var RATE_LIMIT: UInt32 { let o = _accessor.offset(VTOFFSET.RATE_LIMIT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  List of features included in this tier
  public var hasFeatures: Bool { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? false : true }
  public var FEATURESCount: Int32 { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FEATURES(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startPricingTier(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(PRICE_AMOUNT: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PRICE_AMOUNT, def: 0, at: VTOFFSET.PRICE_AMOUNT.p) }
  public static func add(PRICE_CURRENCY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PRICE_CURRENCY, at: VTOFFSET.PRICE_CURRENCY.p) }
  public static func add(DURATION_DAYS: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DURATION_DAYS, def: 0, at: VTOFFSET.DURATION_DAYS.p) }
  public static func add(RATE_LIMIT: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RATE_LIMIT, def: 0, at: VTOFFSET.RATE_LIMIT.p) }
  public static func addVectorOf(FEATURES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FEATURES, at: VTOFFSET.FEATURES.p) }
  public static func endPricingTier(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPricingTier(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    PRICE_AMOUNT: UInt64 = 0,
    PRICE_CURRENCYOffset PRICE_CURRENCY: Offset = Offset(),
    DURATION_DAYS: UInt32 = 0,
    RATE_LIMIT: UInt32 = 0,
    FEATURESVectorOffset FEATURES: Offset = Offset()
  ) -> Offset {
    let __start = PricingTier.startPricingTier(&fbb)
    PricingTier.add(NAME: NAME, &fbb)
    PricingTier.add(PRICE_AMOUNT: PRICE_AMOUNT, &fbb)
    PricingTier.add(PRICE_CURRENCY: PRICE_CURRENCY, &fbb)
    PricingTier.add(DURATION_DAYS: DURATION_DAYS, &fbb)
    PricingTier.add(RATE_LIMIT: RATE_LIMIT, &fbb)
    PricingTier.addVectorOf(FEATURES: FEATURES, &fbb)
    return PricingTier.endPricingTier(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PRICE_AMOUNT.p, fieldName: "PRICE_AMOUNT", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.PRICE_CURRENCY.p, fieldName: "PRICE_CURRENCY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DURATION_DAYS.p, fieldName: "DURATION_DAYS", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.RATE_LIMIT.p, fieldName: "RATE_LIMIT", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.FEATURES.p, fieldName: "FEATURES", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

///  Storefront Listing - Data marketplace listing
public struct STF: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$STF" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: STF.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LISTING_ID = 4
    case PROVIDER_PEER_ID = 6
    case PROVIDER_EPM_CID = 8
    case TITLE = 10
    case DESCRIPTION = 12
    case DATA_TYPES = 14
    case COVERAGE = 16
    case SAMPLE_CID = 18
    case ACCESS_TYPE = 20
    case ENCRYPTION_REQUIRED = 22
    case PRICING = 24
    case ACCEPTED_PAYMENTS = 26
    case CREATED_AT = 28
    case UPDATED_AT = 30
    case ACTIVE = 32
    case SIGNATURE = 34
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for the listing
  public var LISTING_ID: String! { let o = _accessor.offset(VTOFFSET.LISTING_ID.v); return _accessor.string(at: o) }
  public var LISTING_IDSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.LISTING_ID.v) }
  ///  Peer ID of the data provider
  public var PROVIDER_PEER_ID: String! { let o = _accessor.offset(VTOFFSET.PROVIDER_PEER_ID.v); return _accessor.string(at: o) }
  public var PROVIDER_PEER_IDSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.PROVIDER_PEER_ID.v) }
  ///  IPFS CID of provider's EPM (Entity Profile Message)
  public var PROVIDER_EPM_CID: String? { let o = _accessor.offset(VTOFFSET.PROVIDER_EPM_CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PROVIDER_EPM_CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PROVIDER_EPM_CID.v) }
  ///  Title of the data listing
  public var TITLE: String! { let o = _accessor.offset(VTOFFSET.TITLE.v); return _accessor.string(at: o) }
  public var TITLESegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.TITLE.v) }
  ///  Detailed description of the data offering
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
  public var hasDataTypes: Bool { let o = _accessor.offset(VTOFFSET.DATA_TYPES.v); return o == 0 ? false : true }
  public var DATA_TYPESCount: Int32 { let o = _accessor.offset(VTOFFSET.DATA_TYPES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DATA_TYPES(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.DATA_TYPES.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Coverage information (spatial and temporal)
  public var COVERAGE: DataCoverage? { let o = _accessor.offset(VTOFFSET.COVERAGE.v); return o == 0 ? nil : DataCoverage(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  IPFS CID of sample data
  public var SAMPLE_CID: String? { let o = _accessor.offset(VTOFFSET.SAMPLE_CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SAMPLE_CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SAMPLE_CID.v) }
  ///  Type of access offered
  public var ACCESS_TYPE: accessType { let o = _accessor.offset(VTOFFSET.ACCESS_TYPE.v); return o == 0 ? .onetime : accessType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .onetime }
  ///  Whether encryption is required for data delivery
  public var ENCRYPTION_REQUIRED: Bool { let o = _accessor.offset(VTOFFSET.ENCRYPTION_REQUIRED.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Available pricing tiers
  public var hasPricing: Bool { let o = _accessor.offset(VTOFFSET.PRICING.v); return o == 0 ? false : true }
  public var PRICINGCount: Int32 { let o = _accessor.offset(VTOFFSET.PRICING.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PRICING(at index: Int32) -> PricingTier? { let o = _accessor.offset(VTOFFSET.PRICING.v); return o == 0 ? nil : PricingTier(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Payment methods accepted
  public var hasAcceptedPayments: Bool { let o = _accessor.offset(VTOFFSET.ACCEPTED_PAYMENTS.v); return o == 0 ? false : true }
  public var ACCEPTED_PAYMENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.ACCEPTED_PAYMENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ACCEPTED_PAYMENTS(at index: Int32) -> paymentMethod? { let o = _accessor.offset(VTOFFSET.ACCEPTED_PAYMENTS.v); return o == 0 ? paymentMethod.cryptoEth : paymentMethod(rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1)) }
  ///  Unix timestamp when listing was created
  public var CREATED_AT: UInt64 { let o = _accessor.offset(VTOFFSET.CREATED_AT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Unix timestamp when listing was last updated
  public var UPDATED_AT: UInt64 { let o = _accessor.offset(VTOFFSET.UPDATED_AT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Whether the listing is currently active
  public var ACTIVE: Bool { let o = _accessor.offset(VTOFFSET.ACTIVE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Ed25519 signature from provider
  public var hasSignature: Bool { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? false : true }
  public var SIGNATURECount: Int32 { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SIGNATURE(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var SIGNATURE: [UInt8] { return _accessor.getVector(at: VTOFFSET.SIGNATURE.v) ?? [] }
  public static func startSTF(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 16) }
  public static func add(LISTING_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LISTING_ID, at: VTOFFSET.LISTING_ID.p) }
  public static func add(PROVIDER_PEER_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROVIDER_PEER_ID, at: VTOFFSET.PROVIDER_PEER_ID.p) }
  public static func add(PROVIDER_EPM_CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROVIDER_EPM_CID, at: VTOFFSET.PROVIDER_EPM_CID.p) }
  public static func add(TITLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TITLE, at: VTOFFSET.TITLE.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func addVectorOf(DATA_TYPES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_TYPES, at: VTOFFSET.DATA_TYPES.p) }
  public static func add(COVERAGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COVERAGE, at: VTOFFSET.COVERAGE.p) }
  public static func add(SAMPLE_CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SAMPLE_CID, at: VTOFFSET.SAMPLE_CID.p) }
  public static func add(ACCESS_TYPE: accessType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ACCESS_TYPE.rawValue, def: 0, at: VTOFFSET.ACCESS_TYPE.p) }
  public static func add(ENCRYPTION_REQUIRED: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENCRYPTION_REQUIRED, def: false,
   at: VTOFFSET.ENCRYPTION_REQUIRED.p) }
  public static func addVectorOf(PRICING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PRICING, at: VTOFFSET.PRICING.p) }
  public static func addVectorOf(ACCEPTED_PAYMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ACCEPTED_PAYMENTS, at: VTOFFSET.ACCEPTED_PAYMENTS.p) }
  public static func add(CREATED_AT: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CREATED_AT, def: 0, at: VTOFFSET.CREATED_AT.p) }
  public static func add(UPDATED_AT: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: UPDATED_AT, def: 0, at: VTOFFSET.UPDATED_AT.p) }
  public static func add(ACTIVE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ACTIVE, def: false,
   at: VTOFFSET.ACTIVE.p) }
  public static func addVectorOf(SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIGNATURE, at: VTOFFSET.SIGNATURE.p) }
  public static func endSTF(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 10]); return end }
  public static func createSTF(
    _ fbb: inout FlatBufferBuilder,
    LISTING_IDOffset LISTING_ID: Offset,
    PROVIDER_PEER_IDOffset PROVIDER_PEER_ID: Offset,
    PROVIDER_EPM_CIDOffset PROVIDER_EPM_CID: Offset = Offset(),
    TITLEOffset TITLE: Offset,
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    DATA_TYPESVectorOffset DATA_TYPES: Offset = Offset(),
    COVERAGEOffset COVERAGE: Offset = Offset(),
    SAMPLE_CIDOffset SAMPLE_CID: Offset = Offset(),
    ACCESS_TYPE: accessType = .onetime,
    ENCRYPTION_REQUIRED: Bool = false,
    PRICINGVectorOffset PRICING: Offset = Offset(),
    ACCEPTED_PAYMENTSVectorOffset ACCEPTED_PAYMENTS: Offset = Offset(),
    CREATED_AT: UInt64 = 0,
    UPDATED_AT: UInt64 = 0,
    ACTIVE: Bool = false,
    SIGNATUREVectorOffset SIGNATURE: Offset = Offset()
  ) -> Offset {
    let __start = STF.startSTF(&fbb)
    STF.add(LISTING_ID: LISTING_ID, &fbb)
    STF.add(PROVIDER_PEER_ID: PROVIDER_PEER_ID, &fbb)
    STF.add(PROVIDER_EPM_CID: PROVIDER_EPM_CID, &fbb)
    STF.add(TITLE: TITLE, &fbb)
    STF.add(DESCRIPTION: DESCRIPTION, &fbb)
    STF.addVectorOf(DATA_TYPES: DATA_TYPES, &fbb)
    STF.add(COVERAGE: COVERAGE, &fbb)
    STF.add(SAMPLE_CID: SAMPLE_CID, &fbb)
    STF.add(ACCESS_TYPE: ACCESS_TYPE, &fbb)
    STF.add(ENCRYPTION_REQUIRED: ENCRYPTION_REQUIRED, &fbb)
    STF.addVectorOf(PRICING: PRICING, &fbb)
    STF.addVectorOf(ACCEPTED_PAYMENTS: ACCEPTED_PAYMENTS, &fbb)
    STF.add(CREATED_AT: CREATED_AT, &fbb)
    STF.add(UPDATED_AT: UPDATED_AT, &fbb)
    STF.add(ACTIVE: ACTIVE, &fbb)
    STF.addVectorOf(SIGNATURE: SIGNATURE, &fbb)
    return STF.endSTF(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LISTING_ID.p, fieldName: "LISTING_ID", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROVIDER_PEER_ID.p, fieldName: "PROVIDER_PEER_ID", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROVIDER_EPM_CID.p, fieldName: "PROVIDER_EPM_CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TITLE.p, fieldName: "TITLE", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DATA_TYPES.p, fieldName: "DATA_TYPES", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.COVERAGE.p, fieldName: "COVERAGE", required: false, type: ForwardOffset<DataCoverage>.self)
    try _v.visit(field: VTOFFSET.SAMPLE_CID.p, fieldName: "SAMPLE_CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ACCESS_TYPE.p, fieldName: "ACCESS_TYPE", required: false, type: accessType.self)
    try _v.visit(field: VTOFFSET.ENCRYPTION_REQUIRED.p, fieldName: "ENCRYPTION_REQUIRED", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.PRICING.p, fieldName: "PRICING", required: false, type: ForwardOffset<Vector<ForwardOffset<PricingTier>, PricingTier>>.self)
    try _v.visit(field: VTOFFSET.ACCEPTED_PAYMENTS.p, fieldName: "ACCEPTED_PAYMENTS", required: false, type: ForwardOffset<Vector<paymentMethod, paymentMethod>>.self)
    try _v.visit(field: VTOFFSET.CREATED_AT.p, fieldName: "CREATED_AT", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.UPDATED_AT.p, fieldName: "UPDATED_AT", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.ACTIVE.p, fieldName: "ACTIVE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.SIGNATURE.p, fieldName: "SIGNATURE", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

