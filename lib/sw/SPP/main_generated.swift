// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum packetType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case tm = 0
  case tc = 1

  public static var max: packetType { return .tc }
  public static var min: packetType { return .tm }
}


///  Space Packet Protocol (CCSDS 133.0-B-1)
public struct SPP: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$SPP" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SPP.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case VERSION = 4
    case PACKET_TYPE = 6
    case SEC_HDR_FLAG = 8
    case APID = 10
    case SEQUENCE_FLAGS = 12
    case SEQUENCE_COUNT = 14
    case DATA_LENGTH = 16
    case DATA = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Packet version number
  public var VERSION: UInt8 { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Packet type (TM or TC)
  public var PACKET_TYPE: packetType { let o = _accessor.offset(VTOFFSET.PACKET_TYPE.v); return o == 0 ? .tm : packetType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .tm }
  ///  Secondary header flag
  public var SEC_HDR_FLAG: Bool { let o = _accessor.offset(VTOFFSET.SEC_HDR_FLAG.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Application Process Identifier
  public var APID: UInt16 { let o = _accessor.offset(VTOFFSET.APID.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Sequence flags (00=continuation, 01=first, 10=last, 11=standalone)
  public var SEQUENCE_FLAGS: UInt8 { let o = _accessor.offset(VTOFFSET.SEQUENCE_FLAGS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Sequence count
  public var SEQUENCE_COUNT: UInt16 { let o = _accessor.offset(VTOFFSET.SEQUENCE_COUNT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Data length minus 1
  public var DATA_LENGTH: UInt16 { let o = _accessor.offset(VTOFFSET.DATA_LENGTH.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Packet data zone
  public var hasData: Bool { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? false : true }
  public var DATACount: Int32 { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DATA(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var DATA: [UInt8] { return _accessor.getVector(at: VTOFFSET.DATA.v) ?? [] }
  public static func startSPP(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(VERSION: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VERSION, def: 0, at: VTOFFSET.VERSION.p) }
  public static func add(PACKET_TYPE: packetType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PACKET_TYPE.rawValue, def: 0, at: VTOFFSET.PACKET_TYPE.p) }
  public static func add(SEC_HDR_FLAG: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEC_HDR_FLAG, def: false,
   at: VTOFFSET.SEC_HDR_FLAG.p) }
  public static func add(APID: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: APID, def: 0, at: VTOFFSET.APID.p) }
  public static func add(SEQUENCE_FLAGS: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEQUENCE_FLAGS, def: 0, at: VTOFFSET.SEQUENCE_FLAGS.p) }
  public static func add(SEQUENCE_COUNT: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEQUENCE_COUNT, def: 0, at: VTOFFSET.SEQUENCE_COUNT.p) }
  public static func add(DATA_LENGTH: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DATA_LENGTH, def: 0, at: VTOFFSET.DATA_LENGTH.p) }
  public static func addVectorOf(DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA, at: VTOFFSET.DATA.p) }
  public static func endSPP(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSPP(
    _ fbb: inout FlatBufferBuilder,
    VERSION: UInt8 = 0,
    PACKET_TYPE: packetType = .tm,
    SEC_HDR_FLAG: Bool = false,
    APID: UInt16 = 0,
    SEQUENCE_FLAGS: UInt8 = 0,
    SEQUENCE_COUNT: UInt16 = 0,
    DATA_LENGTH: UInt16 = 0,
    DATAVectorOffset DATA: Offset = Offset()
  ) -> Offset {
    let __start = SPP.startSPP(&fbb)
    SPP.add(VERSION: VERSION, &fbb)
    SPP.add(PACKET_TYPE: PACKET_TYPE, &fbb)
    SPP.add(SEC_HDR_FLAG: SEC_HDR_FLAG, &fbb)
    SPP.add(APID: APID, &fbb)
    SPP.add(SEQUENCE_FLAGS: SEQUENCE_FLAGS, &fbb)
    SPP.add(SEQUENCE_COUNT: SEQUENCE_COUNT, &fbb)
    SPP.add(DATA_LENGTH: DATA_LENGTH, &fbb)
    SPP.addVectorOf(DATA: DATA, &fbb)
    return SPP.endSPP(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.PACKET_TYPE.p, fieldName: "PACKET_TYPE", required: false, type: packetType.self)
    try _v.visit(field: VTOFFSET.SEC_HDR_FLAG.p, fieldName: "SEC_HDR_FLAG", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.APID.p, fieldName: "APID", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.SEQUENCE_FLAGS.p, fieldName: "SEQUENCE_FLAGS", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.SEQUENCE_COUNT.p, fieldName: "SEQUENCE_COUNT", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.DATA_LENGTH.p, fieldName: "DATA_LENGTH", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.DATA.p, fieldName: "DATA", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

