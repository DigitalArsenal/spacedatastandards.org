// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public struct Header: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Header.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CCSDS_OCM_VERS = 4
    case COMMENT = 6
    case CLASSIFICATION = 8
    case CREATION_DATE = 10
    case ORIGINATOR = 12
    case MESSAGE_ID = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Format version in the form of 'x.y', where 'y' is incremented for minor changes, and 'x' for major changes.
  public var CCSDS_OCM_VERS: String? { let o = _accessor.offset(VTOFFSET.CCSDS_OCM_VERS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CCSDS_OCM_VERSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CCSDS_OCM_VERS.v) }
  ///  Comments (a contiguous set of one or more comment lines may be provided immediately after the version number).
  public var hasComment: Bool { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? false : true }
  public var COMMENTCount: Int32 { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMMENT(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  User-defined free-text message classification/caveats of this OCM.
  public var CLASSIFICATION: String? { let o = _accessor.offset(VTOFFSET.CLASSIFICATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLASSIFICATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLASSIFICATION.v) }
  ///  File creation date/time in UTC.
  public var CREATION_DATE: String? { let o = _accessor.offset(VTOFFSET.CREATION_DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CREATION_DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CREATION_DATE.v) }
  ///  Creating agency or operator.
  public var ORIGINATOR: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR.v) }
  ///  Free-text field containing an ID that uniquely identifies a message from this originator.
  public var MESSAGE_ID: String? { let o = _accessor.offset(VTOFFSET.MESSAGE_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MESSAGE_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MESSAGE_ID.v) }
  public static func startHeader(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(CCSDS_OCM_VERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CCSDS_OCM_VERS, at: VTOFFSET.CCSDS_OCM_VERS.p) }
  public static func addVectorOf(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(CLASSIFICATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLASSIFICATION, at: VTOFFSET.CLASSIFICATION.p) }
  public static func add(CREATION_DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CREATION_DATE, at: VTOFFSET.CREATION_DATE.p) }
  public static func add(ORIGINATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR, at: VTOFFSET.ORIGINATOR.p) }
  public static func add(MESSAGE_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MESSAGE_ID, at: VTOFFSET.MESSAGE_ID.p) }
  public static func endHeader(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createHeader(
    _ fbb: inout FlatBufferBuilder,
    CCSDS_OCM_VERSOffset CCSDS_OCM_VERS: Offset = Offset(),
    COMMENTVectorOffset COMMENT: Offset = Offset(),
    CLASSIFICATIONOffset CLASSIFICATION: Offset = Offset(),
    CREATION_DATEOffset CREATION_DATE: Offset = Offset(),
    ORIGINATOROffset ORIGINATOR: Offset = Offset(),
    MESSAGE_IDOffset MESSAGE_ID: Offset = Offset()
  ) -> Offset {
    let __start = Header.startHeader(&fbb)
    Header.add(CCSDS_OCM_VERS: CCSDS_OCM_VERS, &fbb)
    Header.addVectorOf(COMMENT: COMMENT, &fbb)
    Header.add(CLASSIFICATION: CLASSIFICATION, &fbb)
    Header.add(CREATION_DATE: CREATION_DATE, &fbb)
    Header.add(ORIGINATOR: ORIGINATOR, &fbb)
    Header.add(MESSAGE_ID: MESSAGE_ID, &fbb)
    return Header.endHeader(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CCSDS_OCM_VERS.p, fieldName: "CCSDS_OCM_VERS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.CLASSIFICATION.p, fieldName: "CLASSIFICATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CREATION_DATE.p, fieldName: "CREATION_DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR.p, fieldName: "ORIGINATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MESSAGE_ID.p, fieldName: "MESSAGE_ID", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Metadata: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Metadata.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMENT = 4
    case OBJECT_NAME = 6
    case INTERNATIONAL_DESIGNATOR = 8
    case CATALOG_NAME = 10
    case OBJECT_DESIGNATOR = 12
    case ALTERNATE_NAMES = 14
    case ORIGINATOR_POC = 16
    case ORIGINATOR_POSITION = 18
    case ORIGINATOR_PHONE = 20
    case ORIGINATOR_EMAIL = 22
    case ORIGINATOR_ADDRESS = 24
    case TECH_ORG = 26
    case TECH_POC = 28
    case TECH_POSITION = 30
    case TECH_PHONE = 32
    case TECH_EMAIL = 34
    case TECH_ADDRESS = 36
    case PREVIOUS_MESSAGE_ID = 38
    case NEXT_MESSAGE_ID = 40
    case ADM_MSG_LINK = 42
    case CDM_MSG_LINK = 44
    case PRM_MSG_LINK = 46
    case RDM_MSG_LINK = 48
    case TDM_MSG_LINK = 50
    case OPERATOR = 52
    case OWNER = 54
    case COUNTRY = 56
    case CONSTELLATION = 58
    case OBJECT_TYPE = 60
    case TIME_SYSTEM = 62
    case EPOCH_TZERO = 64
    case OPS_STATUS = 66
    case ORBIT_CATEGORY = 68
    case OCM_DATA_ELEMENTS = 70
    case SCLK_OFFSET_AT_EPOCH = 72
    case SCLK_SEC_PER_SI_SEC = 74
    case PREVIOUS_MESSAGE_EPOCH = 76
    case NEXT_MESSAGE_EPOCH = 78
    case START_TIME = 80
    case STOP_TIME = 82
    case TIME_SPAN = 84
    case TAIMUTC_AT_TZERO = 86
    case NEXT_LEAP_EPOCH = 88
    case NEXT_LEAP_TAIMUTC = 90
    case UT1MUTC_AT_TZERO = 92
    case EOP_SOURCE = 94
    case INTERP_METHOD_EOP = 96
    case CELESTIAL_SOURCE = 98
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Comments in the Metadata section.
  public var hasComment: Bool { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? false : true }
  public var COMMENTCount: Int32 { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMMENT(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Free-text field containing the name of the object.
  public var OBJECT_NAME: String? { let o = _accessor.offset(VTOFFSET.OBJECT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_NAME.v) }
  ///  International designator for the object as assigned by COSPAR.
  public var INTERNATIONAL_DESIGNATOR: String? { let o = _accessor.offset(VTOFFSET.INTERNATIONAL_DESIGNATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INTERNATIONAL_DESIGNATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INTERNATIONAL_DESIGNATOR.v) }
  ///  Satellite catalog source from which 'OBJECT_DESIGNATOR' was obtained.
  public var CATALOG_NAME: String? { let o = _accessor.offset(VTOFFSET.CATALOG_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CATALOG_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CATALOG_NAME.v) }
  ///  Unique satellite identification designator from the catalog.
  public var OBJECT_DESIGNATOR: String? { let o = _accessor.offset(VTOFFSET.OBJECT_DESIGNATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_DESIGNATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_DESIGNATOR.v) }
  ///  Alternate names of this space object.
  public var hasAlternateNames: Bool { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? false : true }
  public var ALTERNATE_NAMESCount: Int32 { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ALTERNATE_NAMES(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Originator or programmatic Point-of-Contact (PoC) for OCM.
  public var ORIGINATOR_POC: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR_POC.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATOR_POCSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR_POC.v) }
  ///  Contact position of the originator PoC.
  public var ORIGINATOR_POSITION: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR_POSITION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATOR_POSITIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR_POSITION.v) }
  ///  Originator PoC phone number.
  public var ORIGINATOR_PHONE: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR_PHONE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATOR_PHONESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR_PHONE.v) }
  ///  Originator PoC email address.
  public var ORIGINATOR_EMAIL: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR_EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATOR_EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR_EMAIL.v) }
  ///  Originator's physical address information.
  public var ORIGINATOR_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATOR_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR_ADDRESS.v) }
  ///  Creating agency or operator for technical contact.
  public var TECH_ORG: String? { let o = _accessor.offset(VTOFFSET.TECH_ORG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_ORGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_ORG.v) }
  ///  Technical Point-of-Contact (PoC) for OCM.
  public var TECH_POC: String? { let o = _accessor.offset(VTOFFSET.TECH_POC.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_POCSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_POC.v) }
  ///  Contact position of the technical PoC.
  public var TECH_POSITION: String? { let o = _accessor.offset(VTOFFSET.TECH_POSITION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_POSITIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_POSITION.v) }
  ///  Technical PoC phone number.
  public var TECH_PHONE: String? { let o = _accessor.offset(VTOFFSET.TECH_PHONE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_PHONESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_PHONE.v) }
  ///  Technical PoC email address.
  public var TECH_EMAIL: String? { let o = _accessor.offset(VTOFFSET.TECH_EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_EMAIL.v) }
  ///  Technical PoC physical address information.
  public var TECH_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.TECH_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TECH_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TECH_ADDRESS.v) }
  ///  ID that uniquely identifies the previous message from this originator.
  public var PREVIOUS_MESSAGE_ID: String? { let o = _accessor.offset(VTOFFSET.PREVIOUS_MESSAGE_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PREVIOUS_MESSAGE_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PREVIOUS_MESSAGE_ID.v) }
  ///  ID that uniquely identifies the next message from this originator.
  public var NEXT_MESSAGE_ID: String? { let o = _accessor.offset(VTOFFSET.NEXT_MESSAGE_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NEXT_MESSAGE_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NEXT_MESSAGE_ID.v) }
  ///  Unique identifier of Attitude Data Messages linked to this OCM.
  public var ADM_MSG_LINK: String? { let o = _accessor.offset(VTOFFSET.ADM_MSG_LINK.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADM_MSG_LINKSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADM_MSG_LINK.v) }
  ///  Unique identifier of Conjunction Data Messages linked to this OCM.
  public var CDM_MSG_LINK: String? { let o = _accessor.offset(VTOFFSET.CDM_MSG_LINK.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CDM_MSG_LINKSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CDM_MSG_LINK.v) }
  ///  Unique identifier of Pointing Request Messages linked to this OCM.
  public var PRM_MSG_LINK: String? { let o = _accessor.offset(VTOFFSET.PRM_MSG_LINK.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PRM_MSG_LINKSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PRM_MSG_LINK.v) }
  ///  Unique identifier of Reentry Data Messages linked to this OCM.
  public var RDM_MSG_LINK: String? { let o = _accessor.offset(VTOFFSET.RDM_MSG_LINK.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RDM_MSG_LINKSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RDM_MSG_LINK.v) }
  ///  List of Tracking Data Messages upon which this orbit determination is based.
  public var hasTdmMsgLink: Bool { let o = _accessor.offset(VTOFFSET.TDM_MSG_LINK.v); return o == 0 ? false : true }
  public var TDM_MSG_LINKCount: Int32 { let o = _accessor.offset(VTOFFSET.TDM_MSG_LINK.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TDM_MSG_LINK(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.TDM_MSG_LINK.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Operator of the space object.
  public var OPERATOR: String? { let o = _accessor.offset(VTOFFSET.OPERATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OPERATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OPERATOR.v) }
  ///  Owner of the space object.
  public var OWNER: String? { let o = _accessor.offset(VTOFFSET.OWNER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OWNERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OWNER.v) }
  ///  Country where the space object owner is based.
  public var COUNTRY: String? { let o = _accessor.offset(VTOFFSET.COUNTRY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COUNTRYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COUNTRY.v) }
  ///  Name of the constellation to which this space object belongs.
  public var CONSTELLATION: String? { let o = _accessor.offset(VTOFFSET.CONSTELLATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONSTELLATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONSTELLATION.v) }
  ///  Specification of the type of object (e.g., PAYLOAD, ROCKET BODY, DEBRIS).
  public var OBJECT_TYPE: String? { let o = _accessor.offset(VTOFFSET.OBJECT_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_TYPE.v) }
  ///  Time system for all absolute time stamps in this OCM, including EPOCH_TZERO.
  public var TIME_SYSTEM: String? { let o = _accessor.offset(VTOFFSET.TIME_SYSTEM.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIME_SYSTEMSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIME_SYSTEM.v) }
  ///  Default epoch to which all relative times are referenced in data blocks.
  public var EPOCH_TZERO: String? { let o = _accessor.offset(VTOFFSET.EPOCH_TZERO.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCH_TZEROSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH_TZERO.v) }
  ///  Specification of the operational status of the space object.
  public var OPS_STATUS: String? { let o = _accessor.offset(VTOFFSET.OPS_STATUS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OPS_STATUSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OPS_STATUS.v) }
  ///  Specification of the type of orbit (e.g., GEO, LEO).
  public var ORBIT_CATEGORY: String? { let o = _accessor.offset(VTOFFSET.ORBIT_CATEGORY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORBIT_CATEGORYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORBIT_CATEGORY.v) }
  ///  List of elements of information data blocks included in this message.
  public var hasOcmDataElements: Bool { let o = _accessor.offset(VTOFFSET.OCM_DATA_ELEMENTS.v); return o == 0 ? false : true }
  public var OCM_DATA_ELEMENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.OCM_DATA_ELEMENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OCM_DATA_ELEMENTS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.OCM_DATA_ELEMENTS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Number of spacecraft clock counts at EPOCH_TZERO (used if TIME_SYSTEM is SCLK).
  public var SCLK_OFFSET_AT_EPOCH: Double { let o = _accessor.offset(VTOFFSET.SCLK_OFFSET_AT_EPOCH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Number of clock seconds occurring during one SI second (used if TIME_SYSTEM is SCLK).
  public var SCLK_SEC_PER_SI_SEC: Double { let o = _accessor.offset(VTOFFSET.SCLK_SEC_PER_SI_SEC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Creation epoch of the previous message from this originator.
  public var PREVIOUS_MESSAGE_EPOCH: String? { let o = _accessor.offset(VTOFFSET.PREVIOUS_MESSAGE_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PREVIOUS_MESSAGE_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PREVIOUS_MESSAGE_EPOCH.v) }
  ///  Anticipated (or actual) epoch of the next message from this originator.
  public var NEXT_MESSAGE_EPOCH: String? { let o = _accessor.offset(VTOFFSET.NEXT_MESSAGE_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NEXT_MESSAGE_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NEXT_MESSAGE_EPOCH.v) }
  ///  Time of the earliest data contained in the OCM.
  public var START_TIME: String? { let o = _accessor.offset(VTOFFSET.START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.START_TIME.v) }
  ///  Time of the latest data contained in the OCM.
  public var STOP_TIME: String? { let o = _accessor.offset(VTOFFSET.STOP_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STOP_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STOP_TIME.v) }
  ///  Span of time that the OCM covers, measured in days.
  public var TIME_SPAN: Double { let o = _accessor.offset(VTOFFSET.TIME_SPAN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Difference (TAI - UTC) in seconds at EPOCH_TZERO.
  public var TAIMUTC_AT_TZERO: Double { let o = _accessor.offset(VTOFFSET.TAIMUTC_AT_TZERO.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Epoch of next leap second.
  public var NEXT_LEAP_EPOCH: String? { let o = _accessor.offset(VTOFFSET.NEXT_LEAP_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NEXT_LEAP_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NEXT_LEAP_EPOCH.v) }
  ///  Difference (TAI - UTC) in seconds at NEXT_LEAP_EPOCH.
  public var NEXT_LEAP_TAIMUTC: Double { let o = _accessor.offset(VTOFFSET.NEXT_LEAP_TAIMUTC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Difference (UT1 - UTC) in seconds at EPOCH_TZERO.
  public var UT1MUTC_AT_TZERO: Double { let o = _accessor.offset(VTOFFSET.UT1MUTC_AT_TZERO.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Source and version of Earth Orientation Parameters used.
  public var EOP_SOURCE: String? { let o = _accessor.offset(VTOFFSET.EOP_SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EOP_SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EOP_SOURCE.v) }
  ///  Method used to select or interpolate sequential EOP data.
  public var INTERP_METHOD_EOP: String? { let o = _accessor.offset(VTOFFSET.INTERP_METHOD_EOP.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INTERP_METHOD_EOPSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INTERP_METHOD_EOP.v) }
  ///  Source and version of celestial body ephemeris data used.
  public var CELESTIAL_SOURCE: String? { let o = _accessor.offset(VTOFFSET.CELESTIAL_SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CELESTIAL_SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CELESTIAL_SOURCE.v) }
  public static func startMetadata(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 48) }
  public static func addVectorOf(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(OBJECT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_NAME, at: VTOFFSET.OBJECT_NAME.p) }
  public static func add(INTERNATIONAL_DESIGNATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTERNATIONAL_DESIGNATOR, at: VTOFFSET.INTERNATIONAL_DESIGNATOR.p) }
  public static func add(CATALOG_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CATALOG_NAME, at: VTOFFSET.CATALOG_NAME.p) }
  public static func add(OBJECT_DESIGNATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_DESIGNATOR, at: VTOFFSET.OBJECT_DESIGNATOR.p) }
  public static func addVectorOf(ALTERNATE_NAMES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALTERNATE_NAMES, at: VTOFFSET.ALTERNATE_NAMES.p) }
  public static func add(ORIGINATOR_POC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR_POC, at: VTOFFSET.ORIGINATOR_POC.p) }
  public static func add(ORIGINATOR_POSITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR_POSITION, at: VTOFFSET.ORIGINATOR_POSITION.p) }
  public static func add(ORIGINATOR_PHONE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR_PHONE, at: VTOFFSET.ORIGINATOR_PHONE.p) }
  public static func add(ORIGINATOR_EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR_EMAIL, at: VTOFFSET.ORIGINATOR_EMAIL.p) }
  public static func add(ORIGINATOR_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR_ADDRESS, at: VTOFFSET.ORIGINATOR_ADDRESS.p) }
  public static func add(TECH_ORG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_ORG, at: VTOFFSET.TECH_ORG.p) }
  public static func add(TECH_POC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_POC, at: VTOFFSET.TECH_POC.p) }
  public static func add(TECH_POSITION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_POSITION, at: VTOFFSET.TECH_POSITION.p) }
  public static func add(TECH_PHONE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_PHONE, at: VTOFFSET.TECH_PHONE.p) }
  public static func add(TECH_EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_EMAIL, at: VTOFFSET.TECH_EMAIL.p) }
  public static func add(TECH_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TECH_ADDRESS, at: VTOFFSET.TECH_ADDRESS.p) }
  public static func add(PREVIOUS_MESSAGE_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PREVIOUS_MESSAGE_ID, at: VTOFFSET.PREVIOUS_MESSAGE_ID.p) }
  public static func add(NEXT_MESSAGE_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NEXT_MESSAGE_ID, at: VTOFFSET.NEXT_MESSAGE_ID.p) }
  public static func add(ADM_MSG_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADM_MSG_LINK, at: VTOFFSET.ADM_MSG_LINK.p) }
  public static func add(CDM_MSG_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CDM_MSG_LINK, at: VTOFFSET.CDM_MSG_LINK.p) }
  public static func add(PRM_MSG_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PRM_MSG_LINK, at: VTOFFSET.PRM_MSG_LINK.p) }
  public static func add(RDM_MSG_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RDM_MSG_LINK, at: VTOFFSET.RDM_MSG_LINK.p) }
  public static func addVectorOf(TDM_MSG_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TDM_MSG_LINK, at: VTOFFSET.TDM_MSG_LINK.p) }
  public static func add(OPERATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OPERATOR, at: VTOFFSET.OPERATOR.p) }
  public static func add(OWNER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OWNER, at: VTOFFSET.OWNER.p) }
  public static func add(COUNTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COUNTRY, at: VTOFFSET.COUNTRY.p) }
  public static func add(CONSTELLATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONSTELLATION, at: VTOFFSET.CONSTELLATION.p) }
  public static func add(OBJECT_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_TYPE, at: VTOFFSET.OBJECT_TYPE.p) }
  public static func add(TIME_SYSTEM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME_SYSTEM, at: VTOFFSET.TIME_SYSTEM.p) }
  public static func add(EPOCH_TZERO: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH_TZERO, at: VTOFFSET.EPOCH_TZERO.p) }
  public static func add(OPS_STATUS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OPS_STATUS, at: VTOFFSET.OPS_STATUS.p) }
  public static func add(ORBIT_CATEGORY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORBIT_CATEGORY, at: VTOFFSET.ORBIT_CATEGORY.p) }
  public static func addVectorOf(OCM_DATA_ELEMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OCM_DATA_ELEMENTS, at: VTOFFSET.OCM_DATA_ELEMENTS.p) }
  public static func add(SCLK_OFFSET_AT_EPOCH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCLK_OFFSET_AT_EPOCH, def: 0.0, at: VTOFFSET.SCLK_OFFSET_AT_EPOCH.p) }
  public static func add(SCLK_SEC_PER_SI_SEC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCLK_SEC_PER_SI_SEC, def: 0.0, at: VTOFFSET.SCLK_SEC_PER_SI_SEC.p) }
  public static func add(PREVIOUS_MESSAGE_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PREVIOUS_MESSAGE_EPOCH, at: VTOFFSET.PREVIOUS_MESSAGE_EPOCH.p) }
  public static func add(NEXT_MESSAGE_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NEXT_MESSAGE_EPOCH, at: VTOFFSET.NEXT_MESSAGE_EPOCH.p) }
  public static func add(START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: START_TIME, at: VTOFFSET.START_TIME.p) }
  public static func add(STOP_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STOP_TIME, at: VTOFFSET.STOP_TIME.p) }
  public static func add(TIME_SPAN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_SPAN, def: 0.0, at: VTOFFSET.TIME_SPAN.p) }
  public static func add(TAIMUTC_AT_TZERO: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TAIMUTC_AT_TZERO, def: 0.0, at: VTOFFSET.TAIMUTC_AT_TZERO.p) }
  public static func add(NEXT_LEAP_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NEXT_LEAP_EPOCH, at: VTOFFSET.NEXT_LEAP_EPOCH.p) }
  public static func add(NEXT_LEAP_TAIMUTC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NEXT_LEAP_TAIMUTC, def: 0.0, at: VTOFFSET.NEXT_LEAP_TAIMUTC.p) }
  public static func add(UT1MUTC_AT_TZERO: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: UT1MUTC_AT_TZERO, def: 0.0, at: VTOFFSET.UT1MUTC_AT_TZERO.p) }
  public static func add(EOP_SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EOP_SOURCE, at: VTOFFSET.EOP_SOURCE.p) }
  public static func add(INTERP_METHOD_EOP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTERP_METHOD_EOP, at: VTOFFSET.INTERP_METHOD_EOP.p) }
  public static func add(CELESTIAL_SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CELESTIAL_SOURCE, at: VTOFFSET.CELESTIAL_SOURCE.p) }
  public static func endMetadata(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMetadata(
    _ fbb: inout FlatBufferBuilder,
    COMMENTVectorOffset COMMENT: Offset = Offset(),
    OBJECT_NAMEOffset OBJECT_NAME: Offset = Offset(),
    INTERNATIONAL_DESIGNATOROffset INTERNATIONAL_DESIGNATOR: Offset = Offset(),
    CATALOG_NAMEOffset CATALOG_NAME: Offset = Offset(),
    OBJECT_DESIGNATOROffset OBJECT_DESIGNATOR: Offset = Offset(),
    ALTERNATE_NAMESVectorOffset ALTERNATE_NAMES: Offset = Offset(),
    ORIGINATOR_POCOffset ORIGINATOR_POC: Offset = Offset(),
    ORIGINATOR_POSITIONOffset ORIGINATOR_POSITION: Offset = Offset(),
    ORIGINATOR_PHONEOffset ORIGINATOR_PHONE: Offset = Offset(),
    ORIGINATOR_EMAILOffset ORIGINATOR_EMAIL: Offset = Offset(),
    ORIGINATOR_ADDRESSOffset ORIGINATOR_ADDRESS: Offset = Offset(),
    TECH_ORGOffset TECH_ORG: Offset = Offset(),
    TECH_POCOffset TECH_POC: Offset = Offset(),
    TECH_POSITIONOffset TECH_POSITION: Offset = Offset(),
    TECH_PHONEOffset TECH_PHONE: Offset = Offset(),
    TECH_EMAILOffset TECH_EMAIL: Offset = Offset(),
    TECH_ADDRESSOffset TECH_ADDRESS: Offset = Offset(),
    PREVIOUS_MESSAGE_IDOffset PREVIOUS_MESSAGE_ID: Offset = Offset(),
    NEXT_MESSAGE_IDOffset NEXT_MESSAGE_ID: Offset = Offset(),
    ADM_MSG_LINKOffset ADM_MSG_LINK: Offset = Offset(),
    CDM_MSG_LINKOffset CDM_MSG_LINK: Offset = Offset(),
    PRM_MSG_LINKOffset PRM_MSG_LINK: Offset = Offset(),
    RDM_MSG_LINKOffset RDM_MSG_LINK: Offset = Offset(),
    TDM_MSG_LINKVectorOffset TDM_MSG_LINK: Offset = Offset(),
    OPERATOROffset OPERATOR: Offset = Offset(),
    OWNEROffset OWNER: Offset = Offset(),
    COUNTRYOffset COUNTRY: Offset = Offset(),
    CONSTELLATIONOffset CONSTELLATION: Offset = Offset(),
    OBJECT_TYPEOffset OBJECT_TYPE: Offset = Offset(),
    TIME_SYSTEMOffset TIME_SYSTEM: Offset = Offset(),
    EPOCH_TZEROOffset EPOCH_TZERO: Offset = Offset(),
    OPS_STATUSOffset OPS_STATUS: Offset = Offset(),
    ORBIT_CATEGORYOffset ORBIT_CATEGORY: Offset = Offset(),
    OCM_DATA_ELEMENTSVectorOffset OCM_DATA_ELEMENTS: Offset = Offset(),
    SCLK_OFFSET_AT_EPOCH: Double = 0.0,
    SCLK_SEC_PER_SI_SEC: Double = 0.0,
    PREVIOUS_MESSAGE_EPOCHOffset PREVIOUS_MESSAGE_EPOCH: Offset = Offset(),
    NEXT_MESSAGE_EPOCHOffset NEXT_MESSAGE_EPOCH: Offset = Offset(),
    START_TIMEOffset START_TIME: Offset = Offset(),
    STOP_TIMEOffset STOP_TIME: Offset = Offset(),
    TIME_SPAN: Double = 0.0,
    TAIMUTC_AT_TZERO: Double = 0.0,
    NEXT_LEAP_EPOCHOffset NEXT_LEAP_EPOCH: Offset = Offset(),
    NEXT_LEAP_TAIMUTC: Double = 0.0,
    UT1MUTC_AT_TZERO: Double = 0.0,
    EOP_SOURCEOffset EOP_SOURCE: Offset = Offset(),
    INTERP_METHOD_EOPOffset INTERP_METHOD_EOP: Offset = Offset(),
    CELESTIAL_SOURCEOffset CELESTIAL_SOURCE: Offset = Offset()
  ) -> Offset {
    let __start = Metadata.startMetadata(&fbb)
    Metadata.addVectorOf(COMMENT: COMMENT, &fbb)
    Metadata.add(OBJECT_NAME: OBJECT_NAME, &fbb)
    Metadata.add(INTERNATIONAL_DESIGNATOR: INTERNATIONAL_DESIGNATOR, &fbb)
    Metadata.add(CATALOG_NAME: CATALOG_NAME, &fbb)
    Metadata.add(OBJECT_DESIGNATOR: OBJECT_DESIGNATOR, &fbb)
    Metadata.addVectorOf(ALTERNATE_NAMES: ALTERNATE_NAMES, &fbb)
    Metadata.add(ORIGINATOR_POC: ORIGINATOR_POC, &fbb)
    Metadata.add(ORIGINATOR_POSITION: ORIGINATOR_POSITION, &fbb)
    Metadata.add(ORIGINATOR_PHONE: ORIGINATOR_PHONE, &fbb)
    Metadata.add(ORIGINATOR_EMAIL: ORIGINATOR_EMAIL, &fbb)
    Metadata.add(ORIGINATOR_ADDRESS: ORIGINATOR_ADDRESS, &fbb)
    Metadata.add(TECH_ORG: TECH_ORG, &fbb)
    Metadata.add(TECH_POC: TECH_POC, &fbb)
    Metadata.add(TECH_POSITION: TECH_POSITION, &fbb)
    Metadata.add(TECH_PHONE: TECH_PHONE, &fbb)
    Metadata.add(TECH_EMAIL: TECH_EMAIL, &fbb)
    Metadata.add(TECH_ADDRESS: TECH_ADDRESS, &fbb)
    Metadata.add(PREVIOUS_MESSAGE_ID: PREVIOUS_MESSAGE_ID, &fbb)
    Metadata.add(NEXT_MESSAGE_ID: NEXT_MESSAGE_ID, &fbb)
    Metadata.add(ADM_MSG_LINK: ADM_MSG_LINK, &fbb)
    Metadata.add(CDM_MSG_LINK: CDM_MSG_LINK, &fbb)
    Metadata.add(PRM_MSG_LINK: PRM_MSG_LINK, &fbb)
    Metadata.add(RDM_MSG_LINK: RDM_MSG_LINK, &fbb)
    Metadata.addVectorOf(TDM_MSG_LINK: TDM_MSG_LINK, &fbb)
    Metadata.add(OPERATOR: OPERATOR, &fbb)
    Metadata.add(OWNER: OWNER, &fbb)
    Metadata.add(COUNTRY: COUNTRY, &fbb)
    Metadata.add(CONSTELLATION: CONSTELLATION, &fbb)
    Metadata.add(OBJECT_TYPE: OBJECT_TYPE, &fbb)
    Metadata.add(TIME_SYSTEM: TIME_SYSTEM, &fbb)
    Metadata.add(EPOCH_TZERO: EPOCH_TZERO, &fbb)
    Metadata.add(OPS_STATUS: OPS_STATUS, &fbb)
    Metadata.add(ORBIT_CATEGORY: ORBIT_CATEGORY, &fbb)
    Metadata.addVectorOf(OCM_DATA_ELEMENTS: OCM_DATA_ELEMENTS, &fbb)
    Metadata.add(SCLK_OFFSET_AT_EPOCH: SCLK_OFFSET_AT_EPOCH, &fbb)
    Metadata.add(SCLK_SEC_PER_SI_SEC: SCLK_SEC_PER_SI_SEC, &fbb)
    Metadata.add(PREVIOUS_MESSAGE_EPOCH: PREVIOUS_MESSAGE_EPOCH, &fbb)
    Metadata.add(NEXT_MESSAGE_EPOCH: NEXT_MESSAGE_EPOCH, &fbb)
    Metadata.add(START_TIME: START_TIME, &fbb)
    Metadata.add(STOP_TIME: STOP_TIME, &fbb)
    Metadata.add(TIME_SPAN: TIME_SPAN, &fbb)
    Metadata.add(TAIMUTC_AT_TZERO: TAIMUTC_AT_TZERO, &fbb)
    Metadata.add(NEXT_LEAP_EPOCH: NEXT_LEAP_EPOCH, &fbb)
    Metadata.add(NEXT_LEAP_TAIMUTC: NEXT_LEAP_TAIMUTC, &fbb)
    Metadata.add(UT1MUTC_AT_TZERO: UT1MUTC_AT_TZERO, &fbb)
    Metadata.add(EOP_SOURCE: EOP_SOURCE, &fbb)
    Metadata.add(INTERP_METHOD_EOP: INTERP_METHOD_EOP, &fbb)
    Metadata.add(CELESTIAL_SOURCE: CELESTIAL_SOURCE, &fbb)
    return Metadata.endMetadata(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OBJECT_NAME.p, fieldName: "OBJECT_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTERNATIONAL_DESIGNATOR.p, fieldName: "INTERNATIONAL_DESIGNATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CATALOG_NAME.p, fieldName: "CATALOG_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_DESIGNATOR.p, fieldName: "OBJECT_DESIGNATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALTERNATE_NAMES.p, fieldName: "ALTERNATE_NAMES", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR_POC.p, fieldName: "ORIGINATOR_POC", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR_POSITION.p, fieldName: "ORIGINATOR_POSITION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR_PHONE.p, fieldName: "ORIGINATOR_PHONE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR_EMAIL.p, fieldName: "ORIGINATOR_EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR_ADDRESS.p, fieldName: "ORIGINATOR_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_ORG.p, fieldName: "TECH_ORG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_POC.p, fieldName: "TECH_POC", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_POSITION.p, fieldName: "TECH_POSITION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_PHONE.p, fieldName: "TECH_PHONE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_EMAIL.p, fieldName: "TECH_EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TECH_ADDRESS.p, fieldName: "TECH_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PREVIOUS_MESSAGE_ID.p, fieldName: "PREVIOUS_MESSAGE_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NEXT_MESSAGE_ID.p, fieldName: "NEXT_MESSAGE_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADM_MSG_LINK.p, fieldName: "ADM_MSG_LINK", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CDM_MSG_LINK.p, fieldName: "CDM_MSG_LINK", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PRM_MSG_LINK.p, fieldName: "PRM_MSG_LINK", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RDM_MSG_LINK.p, fieldName: "RDM_MSG_LINK", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TDM_MSG_LINK.p, fieldName: "TDM_MSG_LINK", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OPERATOR.p, fieldName: "OPERATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OWNER.p, fieldName: "OWNER", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COUNTRY.p, fieldName: "COUNTRY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONSTELLATION.p, fieldName: "CONSTELLATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_TYPE.p, fieldName: "OBJECT_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_SYSTEM.p, fieldName: "TIME_SYSTEM", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EPOCH_TZERO.p, fieldName: "EPOCH_TZERO", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OPS_STATUS.p, fieldName: "OPS_STATUS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORBIT_CATEGORY.p, fieldName: "ORBIT_CATEGORY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OCM_DATA_ELEMENTS.p, fieldName: "OCM_DATA_ELEMENTS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.SCLK_OFFSET_AT_EPOCH.p, fieldName: "SCLK_OFFSET_AT_EPOCH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SCLK_SEC_PER_SI_SEC.p, fieldName: "SCLK_SEC_PER_SI_SEC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PREVIOUS_MESSAGE_EPOCH.p, fieldName: "PREVIOUS_MESSAGE_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NEXT_MESSAGE_EPOCH.p, fieldName: "NEXT_MESSAGE_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.START_TIME.p, fieldName: "START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STOP_TIME.p, fieldName: "STOP_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_SPAN.p, fieldName: "TIME_SPAN", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TAIMUTC_AT_TZERO.p, fieldName: "TAIMUTC_AT_TZERO", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NEXT_LEAP_EPOCH.p, fieldName: "NEXT_LEAP_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NEXT_LEAP_TAIMUTC.p, fieldName: "NEXT_LEAP_TAIMUTC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.UT1MUTC_AT_TZERO.p, fieldName: "UT1MUTC_AT_TZERO", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.EOP_SOURCE.p, fieldName: "EOP_SOURCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTERP_METHOD_EOP.p, fieldName: "INTERP_METHOD_EOP", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CELESTIAL_SOURCE.p, fieldName: "CELESTIAL_SOURCE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct StateVector: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: StateVector.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case X = 6
    case Y = 8
    case Z = 10
    case X_DOT = 12
    case Y_DOT = 14
    case Z_DOT = 16
    case X_DDOT = 18
    case Y_DDOT = 20
    case Z_DDOT = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Epoch of the state vector.
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  ///  X component of position in the specified reference frame.
  public var X: Double { let o = _accessor.offset(VTOFFSET.X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Y component of position.
  public var Y: Double { let o = _accessor.offset(VTOFFSET.Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Z component of position.
  public var Z: Double { let o = _accessor.offset(VTOFFSET.Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  X component of velocity.
  public var X_DOT: Double { let o = _accessor.offset(VTOFFSET.X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Y component of velocity.
  public var Y_DOT: Double { let o = _accessor.offset(VTOFFSET.Y_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Z component of velocity.
  public var Z_DOT: Double { let o = _accessor.offset(VTOFFSET.Z_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  X component of acceleration.
  public var X_DDOT: Double { let o = _accessor.offset(VTOFFSET.X_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Y component of acceleration.
  public var Y_DDOT: Double { let o = _accessor.offset(VTOFFSET.Y_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Z component of acceleration.
  public var Z_DDOT: Double { let o = _accessor.offset(VTOFFSET.Z_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startStateVector(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X, def: 0.0, at: VTOFFSET.X.p) }
  public static func add(Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y, def: 0.0, at: VTOFFSET.Y.p) }
  public static func add(Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z, def: 0.0, at: VTOFFSET.Z.p) }
  public static func add(X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X_DOT, def: 0.0, at: VTOFFSET.X_DOT.p) }
  public static func add(Y_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y_DOT, def: 0.0, at: VTOFFSET.Y_DOT.p) }
  public static func add(Z_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z_DOT, def: 0.0, at: VTOFFSET.Z_DOT.p) }
  public static func add(X_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X_DDOT, def: 0.0, at: VTOFFSET.X_DDOT.p) }
  public static func add(Y_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y_DDOT, def: 0.0, at: VTOFFSET.Y_DDOT.p) }
  public static func add(Z_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z_DDOT, def: 0.0, at: VTOFFSET.Z_DDOT.p) }
  public static func endStateVector(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStateVector(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    X: Double = 0.0,
    Y: Double = 0.0,
    Z: Double = 0.0,
    X_DOT: Double = 0.0,
    Y_DOT: Double = 0.0,
    Z_DOT: Double = 0.0,
    X_DDOT: Double = 0.0,
    Y_DDOT: Double = 0.0,
    Z_DDOT: Double = 0.0
  ) -> Offset {
    let __start = StateVector.startStateVector(&fbb)
    StateVector.add(EPOCH: EPOCH, &fbb)
    StateVector.add(X: X, &fbb)
    StateVector.add(Y: Y, &fbb)
    StateVector.add(Z: Z, &fbb)
    StateVector.add(X_DOT: X_DOT, &fbb)
    StateVector.add(Y_DOT: Y_DOT, &fbb)
    StateVector.add(Z_DOT: Z_DOT, &fbb)
    StateVector.add(X_DDOT: X_DDOT, &fbb)
    StateVector.add(Y_DDOT: Y_DDOT, &fbb)
    StateVector.add(Z_DDOT: Z_DDOT, &fbb)
    return StateVector.endStateVector(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.X.p, fieldName: "X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y.p, fieldName: "Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z.p, fieldName: "Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.X_DOT.p, fieldName: "X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y_DOT.p, fieldName: "Y_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z_DOT.p, fieldName: "Z_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.X_DDOT.p, fieldName: "X_DDOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y_DDOT.p, fieldName: "Y_DDOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z_DDOT.p, fieldName: "Z_DDOT", required: false, type: Double.self)
    _v.finish()
  }
}

public struct PhysicalProperties: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PhysicalProperties.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMENT = 4
    case WET_MASS = 6
    case DRY_MASS = 8
    case MASS_UNITS = 10
    case OEB_Q1 = 12
    case OEB_Q2 = 14
    case OEB_Q3 = 16
    case OEB_QC = 18
    case OEB_MAX = 20
    case OEB_INT = 22
    case OEB_MIN = 24
    case AREA_ALONG_OEB_MAX = 26
    case AREA_ALONG_OEB_INT = 28
    case AREA_ALONG_OEB_MIN = 30
    case AREA_UNITS = 32
    case DRAG_CONST_AREA = 34
    case DRAG_COEFF_NOM = 36
    case DRAG_UNCERTAINTY = 38
    case SRP_CONST_AREA = 40
    case SOLAR_RAD_COEFF = 42
    case SRP_UNCERTAINTY = 44
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Comments in the Physical Properties section.
  public var hasComment: Bool { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? false : true }
  public var COMMENTCount: Int32 { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMMENT(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Wet mass of the space object.
  public var WET_MASS: Double { let o = _accessor.offset(VTOFFSET.WET_MASS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Dry mass of the space object.
  public var DRY_MASS: Double { let o = _accessor.offset(VTOFFSET.DRY_MASS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Units for mass values.
  public var MASS_UNITS: String? { let o = _accessor.offset(VTOFFSET.MASS_UNITS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MASS_UNITSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MASS_UNITS.v) }
  ///  Quaternion component q1 of orientation from OEB to EME2000.
  public var OEB_Q1: Double { let o = _accessor.offset(VTOFFSET.OEB_Q1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion component q2.
  public var OEB_Q2: Double { let o = _accessor.offset(VTOFFSET.OEB_Q2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion component q3.
  public var OEB_Q3: Double { let o = _accessor.offset(VTOFFSET.OEB_Q3.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Quaternion scalar component qc.
  public var OEB_QC: Double { let o = _accessor.offset(VTOFFSET.OEB_QC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum dimension of the object along OEB frame axes.
  public var OEB_MAX: Double { let o = _accessor.offset(VTOFFSET.OEB_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Intermediate dimension along OEB frame axes.
  public var OEB_INT: Double { let o = _accessor.offset(VTOFFSET.OEB_INT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum dimension of the object along OEB frame axes.
  public var OEB_MIN: Double { let o = _accessor.offset(VTOFFSET.OEB_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Area along OEB_MAX axis.
  public var AREA_ALONG_OEB_MAX: Double { let o = _accessor.offset(VTOFFSET.AREA_ALONG_OEB_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Area along OEB_INT axis.
  public var AREA_ALONG_OEB_INT: Double { let o = _accessor.offset(VTOFFSET.AREA_ALONG_OEB_INT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Area along OEB_MIN axis.
  public var AREA_ALONG_OEB_MIN: Double { let o = _accessor.offset(VTOFFSET.AREA_ALONG_OEB_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Units for area values.
  public var AREA_UNITS: String? { let o = _accessor.offset(VTOFFSET.AREA_UNITS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AREA_UNITSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AREA_UNITS.v) }
  ///  Constant area for drag computations.
  public var DRAG_CONST_AREA: Double { let o = _accessor.offset(VTOFFSET.DRAG_CONST_AREA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Nominal drag coefficient.
  public var DRAG_COEFF_NOM: Double { let o = _accessor.offset(VTOFFSET.DRAG_COEFF_NOM.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Uncertainty in the drag coefficient.
  public var DRAG_UNCERTAINTY: Double { let o = _accessor.offset(VTOFFSET.DRAG_UNCERTAINTY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Constant area for solar radiation pressure computations.
  public var SRP_CONST_AREA: Double { let o = _accessor.offset(VTOFFSET.SRP_CONST_AREA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Nominal solar radiation pressure coefficient.
  public var SOLAR_RAD_COEFF: Double { let o = _accessor.offset(VTOFFSET.SOLAR_RAD_COEFF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Uncertainty in the solar radiation pressure coefficient.
  public var SRP_UNCERTAINTY: Double { let o = _accessor.offset(VTOFFSET.SRP_UNCERTAINTY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startPhysicalProperties(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 21) }
  public static func addVectorOf(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(WET_MASS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WET_MASS, def: 0.0, at: VTOFFSET.WET_MASS.p) }
  public static func add(DRY_MASS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRY_MASS, def: 0.0, at: VTOFFSET.DRY_MASS.p) }
  public static func add(MASS_UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MASS_UNITS, at: VTOFFSET.MASS_UNITS.p) }
  public static func add(OEB_Q1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_Q1, def: 0.0, at: VTOFFSET.OEB_Q1.p) }
  public static func add(OEB_Q2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_Q2, def: 0.0, at: VTOFFSET.OEB_Q2.p) }
  public static func add(OEB_Q3: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_Q3, def: 0.0, at: VTOFFSET.OEB_Q3.p) }
  public static func add(OEB_QC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_QC, def: 0.0, at: VTOFFSET.OEB_QC.p) }
  public static func add(OEB_MAX: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_MAX, def: 0.0, at: VTOFFSET.OEB_MAX.p) }
  public static func add(OEB_INT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_INT, def: 0.0, at: VTOFFSET.OEB_INT.p) }
  public static func add(OEB_MIN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OEB_MIN, def: 0.0, at: VTOFFSET.OEB_MIN.p) }
  public static func add(AREA_ALONG_OEB_MAX: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AREA_ALONG_OEB_MAX, def: 0.0, at: VTOFFSET.AREA_ALONG_OEB_MAX.p) }
  public static func add(AREA_ALONG_OEB_INT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AREA_ALONG_OEB_INT, def: 0.0, at: VTOFFSET.AREA_ALONG_OEB_INT.p) }
  public static func add(AREA_ALONG_OEB_MIN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AREA_ALONG_OEB_MIN, def: 0.0, at: VTOFFSET.AREA_ALONG_OEB_MIN.p) }
  public static func add(AREA_UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AREA_UNITS, at: VTOFFSET.AREA_UNITS.p) }
  public static func add(DRAG_CONST_AREA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRAG_CONST_AREA, def: 0.0, at: VTOFFSET.DRAG_CONST_AREA.p) }
  public static func add(DRAG_COEFF_NOM: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRAG_COEFF_NOM, def: 0.0, at: VTOFFSET.DRAG_COEFF_NOM.p) }
  public static func add(DRAG_UNCERTAINTY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRAG_UNCERTAINTY, def: 0.0, at: VTOFFSET.DRAG_UNCERTAINTY.p) }
  public static func add(SRP_CONST_AREA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SRP_CONST_AREA, def: 0.0, at: VTOFFSET.SRP_CONST_AREA.p) }
  public static func add(SOLAR_RAD_COEFF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOLAR_RAD_COEFF, def: 0.0, at: VTOFFSET.SOLAR_RAD_COEFF.p) }
  public static func add(SRP_UNCERTAINTY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SRP_UNCERTAINTY, def: 0.0, at: VTOFFSET.SRP_UNCERTAINTY.p) }
  public static func endPhysicalProperties(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPhysicalProperties(
    _ fbb: inout FlatBufferBuilder,
    COMMENTVectorOffset COMMENT: Offset = Offset(),
    WET_MASS: Double = 0.0,
    DRY_MASS: Double = 0.0,
    MASS_UNITSOffset MASS_UNITS: Offset = Offset(),
    OEB_Q1: Double = 0.0,
    OEB_Q2: Double = 0.0,
    OEB_Q3: Double = 0.0,
    OEB_QC: Double = 0.0,
    OEB_MAX: Double = 0.0,
    OEB_INT: Double = 0.0,
    OEB_MIN: Double = 0.0,
    AREA_ALONG_OEB_MAX: Double = 0.0,
    AREA_ALONG_OEB_INT: Double = 0.0,
    AREA_ALONG_OEB_MIN: Double = 0.0,
    AREA_UNITSOffset AREA_UNITS: Offset = Offset(),
    DRAG_CONST_AREA: Double = 0.0,
    DRAG_COEFF_NOM: Double = 0.0,
    DRAG_UNCERTAINTY: Double = 0.0,
    SRP_CONST_AREA: Double = 0.0,
    SOLAR_RAD_COEFF: Double = 0.0,
    SRP_UNCERTAINTY: Double = 0.0
  ) -> Offset {
    let __start = PhysicalProperties.startPhysicalProperties(&fbb)
    PhysicalProperties.addVectorOf(COMMENT: COMMENT, &fbb)
    PhysicalProperties.add(WET_MASS: WET_MASS, &fbb)
    PhysicalProperties.add(DRY_MASS: DRY_MASS, &fbb)
    PhysicalProperties.add(MASS_UNITS: MASS_UNITS, &fbb)
    PhysicalProperties.add(OEB_Q1: OEB_Q1, &fbb)
    PhysicalProperties.add(OEB_Q2: OEB_Q2, &fbb)
    PhysicalProperties.add(OEB_Q3: OEB_Q3, &fbb)
    PhysicalProperties.add(OEB_QC: OEB_QC, &fbb)
    PhysicalProperties.add(OEB_MAX: OEB_MAX, &fbb)
    PhysicalProperties.add(OEB_INT: OEB_INT, &fbb)
    PhysicalProperties.add(OEB_MIN: OEB_MIN, &fbb)
    PhysicalProperties.add(AREA_ALONG_OEB_MAX: AREA_ALONG_OEB_MAX, &fbb)
    PhysicalProperties.add(AREA_ALONG_OEB_INT: AREA_ALONG_OEB_INT, &fbb)
    PhysicalProperties.add(AREA_ALONG_OEB_MIN: AREA_ALONG_OEB_MIN, &fbb)
    PhysicalProperties.add(AREA_UNITS: AREA_UNITS, &fbb)
    PhysicalProperties.add(DRAG_CONST_AREA: DRAG_CONST_AREA, &fbb)
    PhysicalProperties.add(DRAG_COEFF_NOM: DRAG_COEFF_NOM, &fbb)
    PhysicalProperties.add(DRAG_UNCERTAINTY: DRAG_UNCERTAINTY, &fbb)
    PhysicalProperties.add(SRP_CONST_AREA: SRP_CONST_AREA, &fbb)
    PhysicalProperties.add(SOLAR_RAD_COEFF: SOLAR_RAD_COEFF, &fbb)
    PhysicalProperties.add(SRP_UNCERTAINTY: SRP_UNCERTAINTY, &fbb)
    return PhysicalProperties.endPhysicalProperties(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.WET_MASS.p, fieldName: "WET_MASS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DRY_MASS.p, fieldName: "DRY_MASS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MASS_UNITS.p, fieldName: "MASS_UNITS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OEB_Q1.p, fieldName: "OEB_Q1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_Q2.p, fieldName: "OEB_Q2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_Q3.p, fieldName: "OEB_Q3", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_QC.p, fieldName: "OEB_QC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_MAX.p, fieldName: "OEB_MAX", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_INT.p, fieldName: "OEB_INT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OEB_MIN.p, fieldName: "OEB_MIN", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AREA_ALONG_OEB_MAX.p, fieldName: "AREA_ALONG_OEB_MAX", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AREA_ALONG_OEB_INT.p, fieldName: "AREA_ALONG_OEB_INT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AREA_ALONG_OEB_MIN.p, fieldName: "AREA_ALONG_OEB_MIN", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AREA_UNITS.p, fieldName: "AREA_UNITS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DRAG_CONST_AREA.p, fieldName: "DRAG_CONST_AREA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DRAG_COEFF_NOM.p, fieldName: "DRAG_COEFF_NOM", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DRAG_UNCERTAINTY.p, fieldName: "DRAG_UNCERTAINTY", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SRP_CONST_AREA.p, fieldName: "SRP_CONST_AREA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SOLAR_RAD_COEFF.p, fieldName: "SOLAR_RAD_COEFF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SRP_UNCERTAINTY.p, fieldName: "SRP_UNCERTAINTY", required: false, type: Double.self)
    _v.finish()
  }
}

public struct Perturbations: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Perturbations.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMENT = 4
    case ATMOSPHERIC_MODEL = 6
    case GRAVITY_MODEL = 8
    case GRAVITY_DEGREE = 10
    case GRAVITY_ORDER = 12
    case GM = 14
    case N_BODY_PERTURBATIONS = 16
    case OCEAN_TIDES_MODEL = 18
    case SOLID_TIDES_MODEL = 20
    case ATMOSPHERIC_TIDES_MODEL = 22
    case GEOPOTENTIAL_MODEL = 24
    case SOLAR_RAD_PRESSURE = 26
    case ALBEDO = 28
    case THERMAL = 30
    case RELATIVITY = 32
    case ATMOSPHERIC_DRAG = 34
    case FIXED_GEOMAG_KP = 36
    case FIXED_F10P7 = 38
    case FIXED_F10P7_MEAN = 40
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Comments in the Perturbations section.
  public var hasComment: Bool { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? false : true }
  public var COMMENTCount: Int32 { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COMMENT(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Atmospheric model used.
  public var ATMOSPHERIC_MODEL: ATM? { let o = _accessor.offset(VTOFFSET.ATMOSPHERIC_MODEL.v); return o == 0 ? nil : ATM(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Gravity model used.
  public var GRAVITY_MODEL: String? { let o = _accessor.offset(VTOFFSET.GRAVITY_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GRAVITY_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GRAVITY_MODEL.v) }
  ///  Degree of the gravity model.
  public var GRAVITY_DEGREE: Int32 { let o = _accessor.offset(VTOFFSET.GRAVITY_DEGREE.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Order of the gravity model.
  public var GRAVITY_ORDER: Int32 { let o = _accessor.offset(VTOFFSET.GRAVITY_ORDER.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Gravitational constant times the mass of the central body.
  public var GM: Double { let o = _accessor.offset(VTOFFSET.GM.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  List of celestial bodies included in n-body perturbations.
  public var hasNBodyPerturbations: Bool { let o = _accessor.offset(VTOFFSET.N_BODY_PERTURBATIONS.v); return o == 0 ? false : true }
  public var N_BODY_PERTURBATIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.N_BODY_PERTURBATIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func N_BODY_PERTURBATIONS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.N_BODY_PERTURBATIONS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Ocean tides model used.
  public var OCEAN_TIDES_MODEL: String? { let o = _accessor.offset(VTOFFSET.OCEAN_TIDES_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OCEAN_TIDES_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OCEAN_TIDES_MODEL.v) }
  ///  Solid tides model used.
  public var SOLID_TIDES_MODEL: String? { let o = _accessor.offset(VTOFFSET.SOLID_TIDES_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOLID_TIDES_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOLID_TIDES_MODEL.v) }
  ///  Atmospheric tides model used.
  public var ATMOSPHERIC_TIDES_MODEL: String? { let o = _accessor.offset(VTOFFSET.ATMOSPHERIC_TIDES_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ATMOSPHERIC_TIDES_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ATMOSPHERIC_TIDES_MODEL.v) }
  ///  Geopotential model used.
  public var GEOPOTENTIAL_MODEL: String? { let o = _accessor.offset(VTOFFSET.GEOPOTENTIAL_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GEOPOTENTIAL_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GEOPOTENTIAL_MODEL.v) }
  ///  Solar radiation pressure model used.
  public var SOLAR_RAD_PRESSURE: String? { let o = _accessor.offset(VTOFFSET.SOLAR_RAD_PRESSURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOLAR_RAD_PRESSURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOLAR_RAD_PRESSURE.v) }
  ///  Albedo model used.
  public var ALBEDO: String? { let o = _accessor.offset(VTOFFSET.ALBEDO.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ALBEDOSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ALBEDO.v) }
  ///  Thermal model used.
  public var THERMAL: String? { let o = _accessor.offset(VTOFFSET.THERMAL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var THERMALSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.THERMAL.v) }
  ///  Relativity model used.
  public var RELATIVITY: String? { let o = _accessor.offset(VTOFFSET.RELATIVITY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RELATIVITYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RELATIVITY.v) }
  ///  Atmospheric drag model used.
  public var ATMOSPHERIC_DRAG: String? { let o = _accessor.offset(VTOFFSET.ATMOSPHERIC_DRAG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ATMOSPHERIC_DRAGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ATMOSPHERIC_DRAG.v) }
  ///  Fixed geomagnetic Kp index used.
  public var FIXED_GEOMAG_KP: Double { let o = _accessor.offset(VTOFFSET.FIXED_GEOMAG_KP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Fixed F10.7 solar flux value used.
  public var FIXED_F10P7: Double { let o = _accessor.offset(VTOFFSET.FIXED_F10P7.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Fixed mean F10.7 solar flux value used.
  public var FIXED_F10P7_MEAN: Double { let o = _accessor.offset(VTOFFSET.FIXED_F10P7_MEAN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startPerturbations(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 19) }
  public static func addVectorOf(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(ATMOSPHERIC_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ATMOSPHERIC_MODEL, at: VTOFFSET.ATMOSPHERIC_MODEL.p) }
  public static func add(GRAVITY_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GRAVITY_MODEL, at: VTOFFSET.GRAVITY_MODEL.p) }
  public static func add(GRAVITY_DEGREE: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GRAVITY_DEGREE, def: 0, at: VTOFFSET.GRAVITY_DEGREE.p) }
  public static func add(GRAVITY_ORDER: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GRAVITY_ORDER, def: 0, at: VTOFFSET.GRAVITY_ORDER.p) }
  public static func add(GM: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GM, def: 0.0, at: VTOFFSET.GM.p) }
  public static func addVectorOf(N_BODY_PERTURBATIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: N_BODY_PERTURBATIONS, at: VTOFFSET.N_BODY_PERTURBATIONS.p) }
  public static func add(OCEAN_TIDES_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OCEAN_TIDES_MODEL, at: VTOFFSET.OCEAN_TIDES_MODEL.p) }
  public static func add(SOLID_TIDES_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOLID_TIDES_MODEL, at: VTOFFSET.SOLID_TIDES_MODEL.p) }
  public static func add(ATMOSPHERIC_TIDES_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ATMOSPHERIC_TIDES_MODEL, at: VTOFFSET.ATMOSPHERIC_TIDES_MODEL.p) }
  public static func add(GEOPOTENTIAL_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GEOPOTENTIAL_MODEL, at: VTOFFSET.GEOPOTENTIAL_MODEL.p) }
  public static func add(SOLAR_RAD_PRESSURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOLAR_RAD_PRESSURE, at: VTOFFSET.SOLAR_RAD_PRESSURE.p) }
  public static func add(ALBEDO: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALBEDO, at: VTOFFSET.ALBEDO.p) }
  public static func add(THERMAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: THERMAL, at: VTOFFSET.THERMAL.p) }
  public static func add(RELATIVITY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RELATIVITY, at: VTOFFSET.RELATIVITY.p) }
  public static func add(ATMOSPHERIC_DRAG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ATMOSPHERIC_DRAG, at: VTOFFSET.ATMOSPHERIC_DRAG.p) }
  public static func add(FIXED_GEOMAG_KP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FIXED_GEOMAG_KP, def: 0.0, at: VTOFFSET.FIXED_GEOMAG_KP.p) }
  public static func add(FIXED_F10P7: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FIXED_F10P7, def: 0.0, at: VTOFFSET.FIXED_F10P7.p) }
  public static func add(FIXED_F10P7_MEAN: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FIXED_F10P7_MEAN, def: 0.0, at: VTOFFSET.FIXED_F10P7_MEAN.p) }
  public static func endPerturbations(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPerturbations(
    _ fbb: inout FlatBufferBuilder,
    COMMENTVectorOffset COMMENT: Offset = Offset(),
    ATMOSPHERIC_MODELOffset ATMOSPHERIC_MODEL: Offset = Offset(),
    GRAVITY_MODELOffset GRAVITY_MODEL: Offset = Offset(),
    GRAVITY_DEGREE: Int32 = 0,
    GRAVITY_ORDER: Int32 = 0,
    GM: Double = 0.0,
    N_BODY_PERTURBATIONSVectorOffset N_BODY_PERTURBATIONS: Offset = Offset(),
    OCEAN_TIDES_MODELOffset OCEAN_TIDES_MODEL: Offset = Offset(),
    SOLID_TIDES_MODELOffset SOLID_TIDES_MODEL: Offset = Offset(),
    ATMOSPHERIC_TIDES_MODELOffset ATMOSPHERIC_TIDES_MODEL: Offset = Offset(),
    GEOPOTENTIAL_MODELOffset GEOPOTENTIAL_MODEL: Offset = Offset(),
    SOLAR_RAD_PRESSUREOffset SOLAR_RAD_PRESSURE: Offset = Offset(),
    ALBEDOOffset ALBEDO: Offset = Offset(),
    THERMALOffset THERMAL: Offset = Offset(),
    RELATIVITYOffset RELATIVITY: Offset = Offset(),
    ATMOSPHERIC_DRAGOffset ATMOSPHERIC_DRAG: Offset = Offset(),
    FIXED_GEOMAG_KP: Double = 0.0,
    FIXED_F10P7: Double = 0.0,
    FIXED_F10P7_MEAN: Double = 0.0
  ) -> Offset {
    let __start = Perturbations.startPerturbations(&fbb)
    Perturbations.addVectorOf(COMMENT: COMMENT, &fbb)
    Perturbations.add(ATMOSPHERIC_MODEL: ATMOSPHERIC_MODEL, &fbb)
    Perturbations.add(GRAVITY_MODEL: GRAVITY_MODEL, &fbb)
    Perturbations.add(GRAVITY_DEGREE: GRAVITY_DEGREE, &fbb)
    Perturbations.add(GRAVITY_ORDER: GRAVITY_ORDER, &fbb)
    Perturbations.add(GM: GM, &fbb)
    Perturbations.addVectorOf(N_BODY_PERTURBATIONS: N_BODY_PERTURBATIONS, &fbb)
    Perturbations.add(OCEAN_TIDES_MODEL: OCEAN_TIDES_MODEL, &fbb)
    Perturbations.add(SOLID_TIDES_MODEL: SOLID_TIDES_MODEL, &fbb)
    Perturbations.add(ATMOSPHERIC_TIDES_MODEL: ATMOSPHERIC_TIDES_MODEL, &fbb)
    Perturbations.add(GEOPOTENTIAL_MODEL: GEOPOTENTIAL_MODEL, &fbb)
    Perturbations.add(SOLAR_RAD_PRESSURE: SOLAR_RAD_PRESSURE, &fbb)
    Perturbations.add(ALBEDO: ALBEDO, &fbb)
    Perturbations.add(THERMAL: THERMAL, &fbb)
    Perturbations.add(RELATIVITY: RELATIVITY, &fbb)
    Perturbations.add(ATMOSPHERIC_DRAG: ATMOSPHERIC_DRAG, &fbb)
    Perturbations.add(FIXED_GEOMAG_KP: FIXED_GEOMAG_KP, &fbb)
    Perturbations.add(FIXED_F10P7: FIXED_F10P7, &fbb)
    Perturbations.add(FIXED_F10P7_MEAN: FIXED_F10P7_MEAN, &fbb)
    return Perturbations.endPerturbations(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.ATMOSPHERIC_MODEL.p, fieldName: "ATMOSPHERIC_MODEL", required: false, type: ForwardOffset<ATM>.self)
    try _v.visit(field: VTOFFSET.GRAVITY_MODEL.p, fieldName: "GRAVITY_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GRAVITY_DEGREE.p, fieldName: "GRAVITY_DEGREE", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.GRAVITY_ORDER.p, fieldName: "GRAVITY_ORDER", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.GM.p, fieldName: "GM", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.N_BODY_PERTURBATIONS.p, fieldName: "N_BODY_PERTURBATIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OCEAN_TIDES_MODEL.p, fieldName: "OCEAN_TIDES_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOLID_TIDES_MODEL.p, fieldName: "SOLID_TIDES_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ATMOSPHERIC_TIDES_MODEL.p, fieldName: "ATMOSPHERIC_TIDES_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GEOPOTENTIAL_MODEL.p, fieldName: "GEOPOTENTIAL_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOLAR_RAD_PRESSURE.p, fieldName: "SOLAR_RAD_PRESSURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALBEDO.p, fieldName: "ALBEDO", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.THERMAL.p, fieldName: "THERMAL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RELATIVITY.p, fieldName: "RELATIVITY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ATMOSPHERIC_DRAG.p, fieldName: "ATMOSPHERIC_DRAG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FIXED_GEOMAG_KP.p, fieldName: "FIXED_GEOMAG_KP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FIXED_F10P7.p, fieldName: "FIXED_F10P7", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FIXED_F10P7_MEAN.p, fieldName: "FIXED_F10P7_MEAN", required: false, type: Double.self)
    _v.finish()
  }
}

public struct Maneuver: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Maneuver.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MAN_ID = 4
    case MAN_BASIS = 6
    case MAN_DEVICE_ID = 8
    case MAN_PREV_ID = 10
    case MAN_PURPOSE = 12
    case MAN_REF_FRAME = 14
    case MAN_FRAME_EPOCH = 16
    case MAN_TYPE = 18
    case MAN_EPOCH_START = 20
    case MAN_DURATION = 22
    case MAN_UNITS = 24
    case DATA = 26
    case MAN_COMMENT = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for the maneuver.
  public var MAN_ID: String? { let o = _accessor.offset(VTOFFSET.MAN_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_ID.v) }
  ///  Basis of the maneuver plan (e.g., planned, predicted, estimated).
  public var MAN_BASIS: String? { let o = _accessor.offset(VTOFFSET.MAN_BASIS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_BASISSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_BASIS.v) }
  ///  Identifier of the maneuver device.
  public var MAN_DEVICE_ID: String? { let o = _accessor.offset(VTOFFSET.MAN_DEVICE_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_DEVICE_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_DEVICE_ID.v) }
  ///  Identifier of the previous maneuver.
  public var MAN_PREV_ID: String? { let o = _accessor.offset(VTOFFSET.MAN_PREV_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_PREV_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_PREV_ID.v) }
  ///  Purpose of the maneuver.
  public var MAN_PURPOSE: String? { let o = _accessor.offset(VTOFFSET.MAN_PURPOSE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_PURPOSESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_PURPOSE.v) }
  ///  Reference frame for the maneuver data.
  public var MAN_REF_FRAME: String? { let o = _accessor.offset(VTOFFSET.MAN_REF_FRAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_REF_FRAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_REF_FRAME.v) }
  ///  Epoch of the maneuver reference frame.
  public var MAN_FRAME_EPOCH: String? { let o = _accessor.offset(VTOFFSET.MAN_FRAME_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_FRAME_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_FRAME_EPOCH.v) }
  ///  Type of maneuver (e.g., IMPULSIVE, FINITE).
  public var MAN_TYPE: String? { let o = _accessor.offset(VTOFFSET.MAN_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_TYPE.v) }
  ///  Start epoch of the maneuver.
  public var MAN_EPOCH_START: String? { let o = _accessor.offset(VTOFFSET.MAN_EPOCH_START.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MAN_EPOCH_STARTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAN_EPOCH_START.v) }
  ///  Duration of the maneuver.
  public var MAN_DURATION: Double { let o = _accessor.offset(VTOFFSET.MAN_DURATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Units for the maneuver data values.
  public var hasManUnits: Bool { let o = _accessor.offset(VTOFFSET.MAN_UNITS.v); return o == 0 ? false : true }
  public var MAN_UNITSCount: Int32 { let o = _accessor.offset(VTOFFSET.MAN_UNITS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MAN_UNITS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.MAN_UNITS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Data associated with the maneuver.
  public var hasData: Bool { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? false : true }
  public var DATACount: Int32 { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DATA(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.DATA.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Comments related to the maneuver.
  public var hasManComment: Bool { let o = _accessor.offset(VTOFFSET.MAN_COMMENT.v); return o == 0 ? false : true }
  public var MAN_COMMENTCount: Int32 { let o = _accessor.offset(VTOFFSET.MAN_COMMENT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MAN_COMMENT(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.MAN_COMMENT.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startManeuver(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  public static func add(MAN_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_ID, at: VTOFFSET.MAN_ID.p) }
  public static func add(MAN_BASIS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_BASIS, at: VTOFFSET.MAN_BASIS.p) }
  public static func add(MAN_DEVICE_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_DEVICE_ID, at: VTOFFSET.MAN_DEVICE_ID.p) }
  public static func add(MAN_PREV_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_PREV_ID, at: VTOFFSET.MAN_PREV_ID.p) }
  public static func add(MAN_PURPOSE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_PURPOSE, at: VTOFFSET.MAN_PURPOSE.p) }
  public static func add(MAN_REF_FRAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_REF_FRAME, at: VTOFFSET.MAN_REF_FRAME.p) }
  public static func add(MAN_FRAME_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_FRAME_EPOCH, at: VTOFFSET.MAN_FRAME_EPOCH.p) }
  public static func add(MAN_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_TYPE, at: VTOFFSET.MAN_TYPE.p) }
  public static func add(MAN_EPOCH_START: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_EPOCH_START, at: VTOFFSET.MAN_EPOCH_START.p) }
  public static func add(MAN_DURATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAN_DURATION, def: 0.0, at: VTOFFSET.MAN_DURATION.p) }
  public static func addVectorOf(MAN_UNITS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_UNITS, at: VTOFFSET.MAN_UNITS.p) }
  public static func addVectorOf(DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA, at: VTOFFSET.DATA.p) }
  public static func addVectorOf(MAN_COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAN_COMMENT, at: VTOFFSET.MAN_COMMENT.p) }
  public static func endManeuver(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createManeuver(
    _ fbb: inout FlatBufferBuilder,
    MAN_IDOffset MAN_ID: Offset = Offset(),
    MAN_BASISOffset MAN_BASIS: Offset = Offset(),
    MAN_DEVICE_IDOffset MAN_DEVICE_ID: Offset = Offset(),
    MAN_PREV_IDOffset MAN_PREV_ID: Offset = Offset(),
    MAN_PURPOSEOffset MAN_PURPOSE: Offset = Offset(),
    MAN_REF_FRAMEOffset MAN_REF_FRAME: Offset = Offset(),
    MAN_FRAME_EPOCHOffset MAN_FRAME_EPOCH: Offset = Offset(),
    MAN_TYPEOffset MAN_TYPE: Offset = Offset(),
    MAN_EPOCH_STARTOffset MAN_EPOCH_START: Offset = Offset(),
    MAN_DURATION: Double = 0.0,
    MAN_UNITSVectorOffset MAN_UNITS: Offset = Offset(),
    DATAVectorOffset DATA: Offset = Offset(),
    MAN_COMMENTVectorOffset MAN_COMMENT: Offset = Offset()
  ) -> Offset {
    let __start = Maneuver.startManeuver(&fbb)
    Maneuver.add(MAN_ID: MAN_ID, &fbb)
    Maneuver.add(MAN_BASIS: MAN_BASIS, &fbb)
    Maneuver.add(MAN_DEVICE_ID: MAN_DEVICE_ID, &fbb)
    Maneuver.add(MAN_PREV_ID: MAN_PREV_ID, &fbb)
    Maneuver.add(MAN_PURPOSE: MAN_PURPOSE, &fbb)
    Maneuver.add(MAN_REF_FRAME: MAN_REF_FRAME, &fbb)
    Maneuver.add(MAN_FRAME_EPOCH: MAN_FRAME_EPOCH, &fbb)
    Maneuver.add(MAN_TYPE: MAN_TYPE, &fbb)
    Maneuver.add(MAN_EPOCH_START: MAN_EPOCH_START, &fbb)
    Maneuver.add(MAN_DURATION: MAN_DURATION, &fbb)
    Maneuver.addVectorOf(MAN_UNITS: MAN_UNITS, &fbb)
    Maneuver.addVectorOf(DATA: DATA, &fbb)
    Maneuver.addVectorOf(MAN_COMMENT: MAN_COMMENT, &fbb)
    return Maneuver.endManeuver(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MAN_ID.p, fieldName: "MAN_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_BASIS.p, fieldName: "MAN_BASIS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_DEVICE_ID.p, fieldName: "MAN_DEVICE_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_PREV_ID.p, fieldName: "MAN_PREV_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_PURPOSE.p, fieldName: "MAN_PURPOSE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_REF_FRAME.p, fieldName: "MAN_REF_FRAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_FRAME_EPOCH.p, fieldName: "MAN_FRAME_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_TYPE.p, fieldName: "MAN_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_EPOCH_START.p, fieldName: "MAN_EPOCH_START", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAN_DURATION.p, fieldName: "MAN_DURATION", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MAN_UNITS.p, fieldName: "MAN_UNITS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.DATA.p, fieldName: "DATA", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.MAN_COMMENT.p, fieldName: "MAN_COMMENT", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

public struct OrbitDetermination: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: OrbitDetermination.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case OD_ID = 4
    case OD_PREV_ID = 6
    case OD_ALGORITHM = 8
    case OD_METHOD = 10
    case OD_EPOCH = 12
    case OD_TIME_TAG = 14
    case OD_PROCESS_NOISE = 16
    case OD_COV_REDUCTION = 18
    case OD_NOISE_MODELS = 20
    case OD_OBSERVATIONS_TYPE = 22
    case OD_OBSERVATIONS_USED = 24
    case OD_TRACKS_USED = 26
    case OD_DATA_WEIGHTING = 28
    case OD_CONVERGENCE_CRITERIA = 30
    case OD_EST_PARAMETERS = 32
    case OD_APRIORI_DATA = 34
    case OD_RESIDUALS = 36
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for the orbit determination.
  public var OD_ID: String? { let o = _accessor.offset(VTOFFSET.OD_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_ID.v) }
  ///  Identifier of the previous orbit determination.
  public var OD_PREV_ID: String? { let o = _accessor.offset(VTOFFSET.OD_PREV_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_PREV_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_PREV_ID.v) }
  ///  Algorithm used for orbit determination.
  public var OD_ALGORITHM: String? { let o = _accessor.offset(VTOFFSET.OD_ALGORITHM.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_ALGORITHMSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_ALGORITHM.v) }
  ///  Method used for orbit determination.
  public var OD_METHOD: String? { let o = _accessor.offset(VTOFFSET.OD_METHOD.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_METHODSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_METHOD.v) }
  ///  Epoch of the orbit determination.
  public var OD_EPOCH: String? { let o = _accessor.offset(VTOFFSET.OD_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_EPOCH.v) }
  ///  Time tag of the orbit determination.
  public var OD_TIME_TAG: String? { let o = _accessor.offset(VTOFFSET.OD_TIME_TAG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_TIME_TAGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_TIME_TAG.v) }
  ///  Process noise model used.
  public var OD_PROCESS_NOISE: String? { let o = _accessor.offset(VTOFFSET.OD_PROCESS_NOISE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_PROCESS_NOISESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_PROCESS_NOISE.v) }
  ///  Covariance reduction techniques used.
  public var OD_COV_REDUCTION: String? { let o = _accessor.offset(VTOFFSET.OD_COV_REDUCTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_COV_REDUCTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_COV_REDUCTION.v) }
  ///  Noise models used.
  public var OD_NOISE_MODELS: String? { let o = _accessor.offset(VTOFFSET.OD_NOISE_MODELS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_NOISE_MODELSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_NOISE_MODELS.v) }
  ///  Types of observations used (e.g., RANGE, DOPPLER).
  public var hasOdObservationsType: Bool { let o = _accessor.offset(VTOFFSET.OD_OBSERVATIONS_TYPE.v); return o == 0 ? false : true }
  public var OD_OBSERVATIONS_TYPECount: Int32 { let o = _accessor.offset(VTOFFSET.OD_OBSERVATIONS_TYPE.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OD_OBSERVATIONS_TYPE(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.OD_OBSERVATIONS_TYPE.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Number of observations used.
  public var OD_OBSERVATIONS_USED: Int32 { let o = _accessor.offset(VTOFFSET.OD_OBSERVATIONS_USED.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Number of tracks used.
  public var OD_TRACKS_USED: Int32 { let o = _accessor.offset(VTOFFSET.OD_TRACKS_USED.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Data weighting scheme used.
  public var OD_DATA_WEIGHTING: String? { let o = _accessor.offset(VTOFFSET.OD_DATA_WEIGHTING.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_DATA_WEIGHTINGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_DATA_WEIGHTING.v) }
  ///  Convergence criteria used.
  public var OD_CONVERGENCE_CRITERIA: String? { let o = _accessor.offset(VTOFFSET.OD_CONVERGENCE_CRITERIA.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_CONVERGENCE_CRITERIASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_CONVERGENCE_CRITERIA.v) }
  ///  Parameters estimated during orbit determination.
  public var hasOdEstParameters: Bool { let o = _accessor.offset(VTOFFSET.OD_EST_PARAMETERS.v); return o == 0 ? false : true }
  public var OD_EST_PARAMETERSCount: Int32 { let o = _accessor.offset(VTOFFSET.OD_EST_PARAMETERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OD_EST_PARAMETERS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.OD_EST_PARAMETERS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  A priori data used for orbit determination.
  public var OD_APRIORI_DATA: String? { let o = _accessor.offset(VTOFFSET.OD_APRIORI_DATA.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_APRIORI_DATASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_APRIORI_DATA.v) }
  ///  Residuals from the orbit determination.
  public var OD_RESIDUALS: String? { let o = _accessor.offset(VTOFFSET.OD_RESIDUALS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_RESIDUALSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_RESIDUALS.v) }
  public static func startOrbitDetermination(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 17) }
  public static func add(OD_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_ID, at: VTOFFSET.OD_ID.p) }
  public static func add(OD_PREV_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_PREV_ID, at: VTOFFSET.OD_PREV_ID.p) }
  public static func add(OD_ALGORITHM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_ALGORITHM, at: VTOFFSET.OD_ALGORITHM.p) }
  public static func add(OD_METHOD: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_METHOD, at: VTOFFSET.OD_METHOD.p) }
  public static func add(OD_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_EPOCH, at: VTOFFSET.OD_EPOCH.p) }
  public static func add(OD_TIME_TAG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_TIME_TAG, at: VTOFFSET.OD_TIME_TAG.p) }
  public static func add(OD_PROCESS_NOISE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_PROCESS_NOISE, at: VTOFFSET.OD_PROCESS_NOISE.p) }
  public static func add(OD_COV_REDUCTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_COV_REDUCTION, at: VTOFFSET.OD_COV_REDUCTION.p) }
  public static func add(OD_NOISE_MODELS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_NOISE_MODELS, at: VTOFFSET.OD_NOISE_MODELS.p) }
  public static func addVectorOf(OD_OBSERVATIONS_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_OBSERVATIONS_TYPE, at: VTOFFSET.OD_OBSERVATIONS_TYPE.p) }
  public static func add(OD_OBSERVATIONS_USED: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OD_OBSERVATIONS_USED, def: 0, at: VTOFFSET.OD_OBSERVATIONS_USED.p) }
  public static func add(OD_TRACKS_USED: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OD_TRACKS_USED, def: 0, at: VTOFFSET.OD_TRACKS_USED.p) }
  public static func add(OD_DATA_WEIGHTING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_DATA_WEIGHTING, at: VTOFFSET.OD_DATA_WEIGHTING.p) }
  public static func add(OD_CONVERGENCE_CRITERIA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_CONVERGENCE_CRITERIA, at: VTOFFSET.OD_CONVERGENCE_CRITERIA.p) }
  public static func addVectorOf(OD_EST_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_EST_PARAMETERS, at: VTOFFSET.OD_EST_PARAMETERS.p) }
  public static func add(OD_APRIORI_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_APRIORI_DATA, at: VTOFFSET.OD_APRIORI_DATA.p) }
  public static func add(OD_RESIDUALS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_RESIDUALS, at: VTOFFSET.OD_RESIDUALS.p) }
  public static func endOrbitDetermination(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOrbitDetermination(
    _ fbb: inout FlatBufferBuilder,
    OD_IDOffset OD_ID: Offset = Offset(),
    OD_PREV_IDOffset OD_PREV_ID: Offset = Offset(),
    OD_ALGORITHMOffset OD_ALGORITHM: Offset = Offset(),
    OD_METHODOffset OD_METHOD: Offset = Offset(),
    OD_EPOCHOffset OD_EPOCH: Offset = Offset(),
    OD_TIME_TAGOffset OD_TIME_TAG: Offset = Offset(),
    OD_PROCESS_NOISEOffset OD_PROCESS_NOISE: Offset = Offset(),
    OD_COV_REDUCTIONOffset OD_COV_REDUCTION: Offset = Offset(),
    OD_NOISE_MODELSOffset OD_NOISE_MODELS: Offset = Offset(),
    OD_OBSERVATIONS_TYPEVectorOffset OD_OBSERVATIONS_TYPE: Offset = Offset(),
    OD_OBSERVATIONS_USED: Int32 = 0,
    OD_TRACKS_USED: Int32 = 0,
    OD_DATA_WEIGHTINGOffset OD_DATA_WEIGHTING: Offset = Offset(),
    OD_CONVERGENCE_CRITERIAOffset OD_CONVERGENCE_CRITERIA: Offset = Offset(),
    OD_EST_PARAMETERSVectorOffset OD_EST_PARAMETERS: Offset = Offset(),
    OD_APRIORI_DATAOffset OD_APRIORI_DATA: Offset = Offset(),
    OD_RESIDUALSOffset OD_RESIDUALS: Offset = Offset()
  ) -> Offset {
    let __start = OrbitDetermination.startOrbitDetermination(&fbb)
    OrbitDetermination.add(OD_ID: OD_ID, &fbb)
    OrbitDetermination.add(OD_PREV_ID: OD_PREV_ID, &fbb)
    OrbitDetermination.add(OD_ALGORITHM: OD_ALGORITHM, &fbb)
    OrbitDetermination.add(OD_METHOD: OD_METHOD, &fbb)
    OrbitDetermination.add(OD_EPOCH: OD_EPOCH, &fbb)
    OrbitDetermination.add(OD_TIME_TAG: OD_TIME_TAG, &fbb)
    OrbitDetermination.add(OD_PROCESS_NOISE: OD_PROCESS_NOISE, &fbb)
    OrbitDetermination.add(OD_COV_REDUCTION: OD_COV_REDUCTION, &fbb)
    OrbitDetermination.add(OD_NOISE_MODELS: OD_NOISE_MODELS, &fbb)
    OrbitDetermination.addVectorOf(OD_OBSERVATIONS_TYPE: OD_OBSERVATIONS_TYPE, &fbb)
    OrbitDetermination.add(OD_OBSERVATIONS_USED: OD_OBSERVATIONS_USED, &fbb)
    OrbitDetermination.add(OD_TRACKS_USED: OD_TRACKS_USED, &fbb)
    OrbitDetermination.add(OD_DATA_WEIGHTING: OD_DATA_WEIGHTING, &fbb)
    OrbitDetermination.add(OD_CONVERGENCE_CRITERIA: OD_CONVERGENCE_CRITERIA, &fbb)
    OrbitDetermination.addVectorOf(OD_EST_PARAMETERS: OD_EST_PARAMETERS, &fbb)
    OrbitDetermination.add(OD_APRIORI_DATA: OD_APRIORI_DATA, &fbb)
    OrbitDetermination.add(OD_RESIDUALS: OD_RESIDUALS, &fbb)
    return OrbitDetermination.endOrbitDetermination(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.OD_ID.p, fieldName: "OD_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_PREV_ID.p, fieldName: "OD_PREV_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_ALGORITHM.p, fieldName: "OD_ALGORITHM", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_METHOD.p, fieldName: "OD_METHOD", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_EPOCH.p, fieldName: "OD_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_TIME_TAG.p, fieldName: "OD_TIME_TAG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_PROCESS_NOISE.p, fieldName: "OD_PROCESS_NOISE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_COV_REDUCTION.p, fieldName: "OD_COV_REDUCTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_NOISE_MODELS.p, fieldName: "OD_NOISE_MODELS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_OBSERVATIONS_TYPE.p, fieldName: "OD_OBSERVATIONS_TYPE", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OD_OBSERVATIONS_USED.p, fieldName: "OD_OBSERVATIONS_USED", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.OD_TRACKS_USED.p, fieldName: "OD_TRACKS_USED", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.OD_DATA_WEIGHTING.p, fieldName: "OD_DATA_WEIGHTING", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_CONVERGENCE_CRITERIA.p, fieldName: "OD_CONVERGENCE_CRITERIA", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_EST_PARAMETERS.p, fieldName: "OD_EST_PARAMETERS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OD_APRIORI_DATA.p, fieldName: "OD_APRIORI_DATA", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OD_RESIDUALS.p, fieldName: "OD_RESIDUALS", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct UserDefinedParameters: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: UserDefinedParameters.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PARAM_NAME = 4
    case PARAM_VALUE = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of the user-defined parameter.
  public var PARAM_NAME: String? { let o = _accessor.offset(VTOFFSET.PARAM_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAM_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAM_NAME.v) }
  ///  Value of the user-defined parameter.
  public var PARAM_VALUE: String? { let o = _accessor.offset(VTOFFSET.PARAM_VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARAM_VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARAM_VALUE.v) }
  public static func startUserDefinedParameters(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(PARAM_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAM_NAME, at: VTOFFSET.PARAM_NAME.p) }
  public static func add(PARAM_VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARAM_VALUE, at: VTOFFSET.PARAM_VALUE.p) }
  public static func endUserDefinedParameters(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUserDefinedParameters(
    _ fbb: inout FlatBufferBuilder,
    PARAM_NAMEOffset PARAM_NAME: Offset = Offset(),
    PARAM_VALUEOffset PARAM_VALUE: Offset = Offset()
  ) -> Offset {
    let __start = UserDefinedParameters.startUserDefinedParameters(&fbb)
    UserDefinedParameters.add(PARAM_NAME: PARAM_NAME, &fbb)
    UserDefinedParameters.add(PARAM_VALUE: PARAM_VALUE, &fbb)
    return UserDefinedParameters.endUserDefinedParameters(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PARAM_NAME.p, fieldName: "PARAM_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PARAM_VALUE.p, fieldName: "PARAM_VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Orbit Comprehensive Message
public struct OCM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OCM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: OCM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case HEADER = 4
    case METADATA = 6
    case TRAJ_TYPE = 8
    case STATE_DATA = 10
    case PHYSICAL_PROPERTIES = 12
    case COVARIANCE_DATA = 14
    case MANEUVER_DATA = 16
    case PERTURBATIONS = 18
    case ORBIT_DETERMINATION = 20
    case USER_DEFINED_PARAMETERS = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Header section of the OCM.
  public var HEADER: Header? { let o = _accessor.offset(VTOFFSET.HEADER.v); return o == 0 ? nil : Header(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Metadata section of the OCM.
  public var METADATA: Metadata? { let o = _accessor.offset(VTOFFSET.METADATA.v); return o == 0 ? nil : Metadata(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Trajectory type (e.g., PROPAGATED, ESTIMATED).
  public var TRAJ_TYPE: String? { let o = _accessor.offset(VTOFFSET.TRAJ_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRAJ_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRAJ_TYPE.v) }
  ///  State vector data.
  public var hasStateData: Bool { let o = _accessor.offset(VTOFFSET.STATE_DATA.v); return o == 0 ? false : true }
  public var STATE_DATACount: Int32 { let o = _accessor.offset(VTOFFSET.STATE_DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STATE_DATA(at index: Int32) -> StateVector? { let o = _accessor.offset(VTOFFSET.STATE_DATA.v); return o == 0 ? nil : StateVector(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Physical properties of the space object.
  public var PHYSICAL_PROPERTIES: PhysicalProperties? { let o = _accessor.offset(VTOFFSET.PHYSICAL_PROPERTIES.v); return o == 0 ? nil : PhysicalProperties(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Covariance data associated with the state vectors.
  public var hasCovarianceData: Bool { let o = _accessor.offset(VTOFFSET.COVARIANCE_DATA.v); return o == 0 ? false : true }
  public var COVARIANCE_DATACount: Int32 { let o = _accessor.offset(VTOFFSET.COVARIANCE_DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COVARIANCE_DATA(at index: Int32) -> StateVector? { let o = _accessor.offset(VTOFFSET.COVARIANCE_DATA.v); return o == 0 ? nil : StateVector(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Maneuver data.
  public var hasManeuverData: Bool { let o = _accessor.offset(VTOFFSET.MANEUVER_DATA.v); return o == 0 ? false : true }
  public var MANEUVER_DATACount: Int32 { let o = _accessor.offset(VTOFFSET.MANEUVER_DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MANEUVER_DATA(at index: Int32) -> Maneuver? { let o = _accessor.offset(VTOFFSET.MANEUVER_DATA.v); return o == 0 ? nil : Maneuver(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Perturbations parameters used.
  public var PERTURBATIONS: Perturbations? { let o = _accessor.offset(VTOFFSET.PERTURBATIONS.v); return o == 0 ? nil : Perturbations(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Orbit determination data.
  public var ORBIT_DETERMINATION: OrbitDetermination? { let o = _accessor.offset(VTOFFSET.ORBIT_DETERMINATION.v); return o == 0 ? nil : OrbitDetermination(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  User-defined parameters and supplemental comments.
  public var hasUserDefinedParameters: Bool { let o = _accessor.offset(VTOFFSET.USER_DEFINED_PARAMETERS.v); return o == 0 ? false : true }
  public var USER_DEFINED_PARAMETERSCount: Int32 { let o = _accessor.offset(VTOFFSET.USER_DEFINED_PARAMETERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func USER_DEFINED_PARAMETERS(at index: Int32) -> UserDefinedParameters? { let o = _accessor.offset(VTOFFSET.USER_DEFINED_PARAMETERS.v); return o == 0 ? nil : UserDefinedParameters(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startOCM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(HEADER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HEADER, at: VTOFFSET.HEADER.p) }
  public static func add(METADATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: METADATA, at: VTOFFSET.METADATA.p) }
  public static func add(TRAJ_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRAJ_TYPE, at: VTOFFSET.TRAJ_TYPE.p) }
  public static func addVectorOf(STATE_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STATE_DATA, at: VTOFFSET.STATE_DATA.p) }
  public static func add(PHYSICAL_PROPERTIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PHYSICAL_PROPERTIES, at: VTOFFSET.PHYSICAL_PROPERTIES.p) }
  public static func addVectorOf(COVARIANCE_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COVARIANCE_DATA, at: VTOFFSET.COVARIANCE_DATA.p) }
  public static func addVectorOf(MANEUVER_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MANEUVER_DATA, at: VTOFFSET.MANEUVER_DATA.p) }
  public static func add(PERTURBATIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PERTURBATIONS, at: VTOFFSET.PERTURBATIONS.p) }
  public static func add(ORBIT_DETERMINATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORBIT_DETERMINATION, at: VTOFFSET.ORBIT_DETERMINATION.p) }
  public static func addVectorOf(USER_DEFINED_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: USER_DEFINED_PARAMETERS, at: VTOFFSET.USER_DEFINED_PARAMETERS.p) }
  public static func endOCM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOCM(
    _ fbb: inout FlatBufferBuilder,
    HEADEROffset HEADER: Offset = Offset(),
    METADATAOffset METADATA: Offset = Offset(),
    TRAJ_TYPEOffset TRAJ_TYPE: Offset = Offset(),
    STATE_DATAVectorOffset STATE_DATA: Offset = Offset(),
    PHYSICAL_PROPERTIESOffset PHYSICAL_PROPERTIES: Offset = Offset(),
    COVARIANCE_DATAVectorOffset COVARIANCE_DATA: Offset = Offset(),
    MANEUVER_DATAVectorOffset MANEUVER_DATA: Offset = Offset(),
    PERTURBATIONSOffset PERTURBATIONS: Offset = Offset(),
    ORBIT_DETERMINATIONOffset ORBIT_DETERMINATION: Offset = Offset(),
    USER_DEFINED_PARAMETERSVectorOffset USER_DEFINED_PARAMETERS: Offset = Offset()
  ) -> Offset {
    let __start = OCM.startOCM(&fbb)
    OCM.add(HEADER: HEADER, &fbb)
    OCM.add(METADATA: METADATA, &fbb)
    OCM.add(TRAJ_TYPE: TRAJ_TYPE, &fbb)
    OCM.addVectorOf(STATE_DATA: STATE_DATA, &fbb)
    OCM.add(PHYSICAL_PROPERTIES: PHYSICAL_PROPERTIES, &fbb)
    OCM.addVectorOf(COVARIANCE_DATA: COVARIANCE_DATA, &fbb)
    OCM.addVectorOf(MANEUVER_DATA: MANEUVER_DATA, &fbb)
    OCM.add(PERTURBATIONS: PERTURBATIONS, &fbb)
    OCM.add(ORBIT_DETERMINATION: ORBIT_DETERMINATION, &fbb)
    OCM.addVectorOf(USER_DEFINED_PARAMETERS: USER_DEFINED_PARAMETERS, &fbb)
    return OCM.endOCM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.HEADER.p, fieldName: "HEADER", required: false, type: ForwardOffset<Header>.self)
    try _v.visit(field: VTOFFSET.METADATA.p, fieldName: "METADATA", required: false, type: ForwardOffset<Metadata>.self)
    try _v.visit(field: VTOFFSET.TRAJ_TYPE.p, fieldName: "TRAJ_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STATE_DATA.p, fieldName: "STATE_DATA", required: false, type: ForwardOffset<Vector<ForwardOffset<StateVector>, StateVector>>.self)
    try _v.visit(field: VTOFFSET.PHYSICAL_PROPERTIES.p, fieldName: "PHYSICAL_PROPERTIES", required: false, type: ForwardOffset<PhysicalProperties>.self)
    try _v.visit(field: VTOFFSET.COVARIANCE_DATA.p, fieldName: "COVARIANCE_DATA", required: false, type: ForwardOffset<Vector<ForwardOffset<StateVector>, StateVector>>.self)
    try _v.visit(field: VTOFFSET.MANEUVER_DATA.p, fieldName: "MANEUVER_DATA", required: false, type: ForwardOffset<Vector<ForwardOffset<Maneuver>, Maneuver>>.self)
    try _v.visit(field: VTOFFSET.PERTURBATIONS.p, fieldName: "PERTURBATIONS", required: false, type: ForwardOffset<Perturbations>.self)
    try _v.visit(field: VTOFFSET.ORBIT_DETERMINATION.p, fieldName: "ORBIT_DETERMINATION", required: false, type: ForwardOffset<OrbitDetermination>.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_PARAMETERS.p, fieldName: "USER_DEFINED_PARAMETERS", required: false, type: ForwardOffset<Vector<ForwardOffset<UserDefinedParameters>, UserDefinedParameters>>.self)
    _v.finish()
  }
}

