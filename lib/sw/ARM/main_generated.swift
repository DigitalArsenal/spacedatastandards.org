// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum ArmorMaterial: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case rha = 0
  case cha = 1
  case fha = 2
  case hha = 3
  case aluminum = 4
  case composite = 5
  case ceramic = 6
  case era = 7
  case nera = 8
  case spaced = 9
  case rubber = 10
  case structural = 11
  case titanium = 12
  case kevlar = 13
  case glass = 14

  public static var max: ArmorMaterial { return .glass }
  public static var min: ArmorMaterial { return .rha }
}


public enum AmmoType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case ap = 0
  case apc = 1
  case apcbc = 2
  case apcr = 3
  case apds = 4
  case apfsds = 5
  case heat = 6
  case heatFs = 7
  case hesh = 8
  case he = 9
  case heFrag = 10
  case hedp = 11
  case aphe = 12
  case sap = 13
  case atgm = 14
  case tandemHeat = 15
  case topAttack = 16
  case efp = 17

  public static var max: AmmoType { return .efp }
  public static var min: AmmoType { return .ap }
}


public enum PenResult: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case noPenetration = 0
  case partialPen = 1
  case fullPen = 2
  case ricochet = 3
  case shattered = 4
  case overMatch = 5

  public static var max: PenResult { return .overMatch }
  public static var min: PenResult { return .noPenetration }
}


///  Armor and Protection
public struct ARM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ARM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ARM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case THICKNESS = 4
    case ANGLE = 6
    case MATERIAL = 8
    case HARDNESS = 10
    case QUALITY = 12
    case ERA_TYPE = 14
    case ERA_EFFECTIVENESS = 16
    case ERA_VS_KE = 18
    case RHA_EQUIVALENT = 20
    case NORMAL_X = 22
    case NORMAL_Y = 24
    case NORMAL_Z = 26
    case RESERVED = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var THICKNESS: Double { let o = _accessor.offset(VTOFFSET.THICKNESS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ANGLE: Double { let o = _accessor.offset(VTOFFSET.ANGLE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MATERIAL: UInt8 { let o = _accessor.offset(VTOFFSET.MATERIAL.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var HARDNESS: UInt8 { let o = _accessor.offset(VTOFFSET.HARDNESS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var QUALITY: UInt8 { let o = _accessor.offset(VTOFFSET.QUALITY.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ERA_TYPE: UInt8 { let o = _accessor.offset(VTOFFSET.ERA_TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ERA_EFFECTIVENESS: Float32 { let o = _accessor.offset(VTOFFSET.ERA_EFFECTIVENESS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var ERA_VS_KE: Float32 { let o = _accessor.offset(VTOFFSET.ERA_VS_KE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var RHA_EQUIVALENT: Float32 { let o = _accessor.offset(VTOFFSET.RHA_EQUIVALENT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var NORMAL_X: Double { let o = _accessor.offset(VTOFFSET.NORMAL_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var NORMAL_Y: Double { let o = _accessor.offset(VTOFFSET.NORMAL_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var NORMAL_Z: Double { let o = _accessor.offset(VTOFFSET.NORMAL_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var hasReserved: Bool { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? false : true }
  public var RESERVEDCount: Int32 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RESERVED(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var RESERVED: [UInt8] { return _accessor.getVector(at: VTOFFSET.RESERVED.v) ?? [] }
  public static func startARM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  public static func add(THICKNESS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: THICKNESS, def: 0.0, at: VTOFFSET.THICKNESS.p) }
  public static func add(ANGLE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ANGLE, def: 0.0, at: VTOFFSET.ANGLE.p) }
  public static func add(MATERIAL: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MATERIAL, def: 0, at: VTOFFSET.MATERIAL.p) }
  public static func add(HARDNESS: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HARDNESS, def: 0, at: VTOFFSET.HARDNESS.p) }
  public static func add(QUALITY: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: QUALITY, def: 0, at: VTOFFSET.QUALITY.p) }
  public static func add(ERA_TYPE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ERA_TYPE, def: 0, at: VTOFFSET.ERA_TYPE.p) }
  public static func add(ERA_EFFECTIVENESS: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ERA_EFFECTIVENESS, def: 0.0, at: VTOFFSET.ERA_EFFECTIVENESS.p) }
  public static func add(ERA_VS_KE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ERA_VS_KE, def: 0.0, at: VTOFFSET.ERA_VS_KE.p) }
  public static func add(RHA_EQUIVALENT: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RHA_EQUIVALENT, def: 0.0, at: VTOFFSET.RHA_EQUIVALENT.p) }
  public static func add(NORMAL_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORMAL_X, def: 0.0, at: VTOFFSET.NORMAL_X.p) }
  public static func add(NORMAL_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORMAL_Y, def: 0.0, at: VTOFFSET.NORMAL_Y.p) }
  public static func add(NORMAL_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORMAL_Z, def: 0.0, at: VTOFFSET.NORMAL_Z.p) }
  public static func addVectorOf(RESERVED: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESERVED, at: VTOFFSET.RESERVED.p) }
  public static func endARM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createARM(
    _ fbb: inout FlatBufferBuilder,
    THICKNESS: Double = 0.0,
    ANGLE: Double = 0.0,
    MATERIAL: UInt8 = 0,
    HARDNESS: UInt8 = 0,
    QUALITY: UInt8 = 0,
    ERA_TYPE: UInt8 = 0,
    ERA_EFFECTIVENESS: Float32 = 0.0,
    ERA_VS_KE: Float32 = 0.0,
    RHA_EQUIVALENT: Float32 = 0.0,
    NORMAL_X: Double = 0.0,
    NORMAL_Y: Double = 0.0,
    NORMAL_Z: Double = 0.0,
    RESERVEDVectorOffset RESERVED: Offset = Offset()
  ) -> Offset {
    let __start = ARM.startARM(&fbb)
    ARM.add(THICKNESS: THICKNESS, &fbb)
    ARM.add(ANGLE: ANGLE, &fbb)
    ARM.add(MATERIAL: MATERIAL, &fbb)
    ARM.add(HARDNESS: HARDNESS, &fbb)
    ARM.add(QUALITY: QUALITY, &fbb)
    ARM.add(ERA_TYPE: ERA_TYPE, &fbb)
    ARM.add(ERA_EFFECTIVENESS: ERA_EFFECTIVENESS, &fbb)
    ARM.add(ERA_VS_KE: ERA_VS_KE, &fbb)
    ARM.add(RHA_EQUIVALENT: RHA_EQUIVALENT, &fbb)
    ARM.add(NORMAL_X: NORMAL_X, &fbb)
    ARM.add(NORMAL_Y: NORMAL_Y, &fbb)
    ARM.add(NORMAL_Z: NORMAL_Z, &fbb)
    ARM.addVectorOf(RESERVED: RESERVED, &fbb)
    return ARM.endARM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.THICKNESS.p, fieldName: "THICKNESS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ANGLE.p, fieldName: "ANGLE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MATERIAL.p, fieldName: "MATERIAL", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.HARDNESS.p, fieldName: "HARDNESS", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.QUALITY.p, fieldName: "QUALITY", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ERA_TYPE.p, fieldName: "ERA_TYPE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ERA_EFFECTIVENESS.p, fieldName: "ERA_EFFECTIVENESS", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ERA_VS_KE.p, fieldName: "ERA_VS_KE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.RHA_EQUIVALENT.p, fieldName: "RHA_EQUIVALENT", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.NORMAL_X.p, fieldName: "NORMAL_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NORMAL_Y.p, fieldName: "NORMAL_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NORMAL_Z.p, fieldName: "NORMAL_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.RESERVED.p, fieldName: "RESERVED", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

