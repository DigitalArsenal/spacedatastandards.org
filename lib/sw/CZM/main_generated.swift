// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum CZMHeightReference: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case clampToGround = 1
  case relativeToGround = 2

  public static var max: CZMHeightReference { return .relativeToGround }
  public static var min: CZMHeightReference { return .none_ }
}


public enum CZMClassificationType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case terrain = 0
  case cesium3dTile = 1
  case both = 2

  public static var max: CZMClassificationType { return .both }
  public static var min: CZMClassificationType { return .terrain }
}


public enum CZMLabelStyle: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case fill = 0
  case outline = 1
  case fillAndOutline = 2

  public static var max: CZMLabelStyle { return .fillAndOutline }
  public static var min: CZMLabelStyle { return .fill }
}


public enum CZMHorizontalOrigin: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case left_ = 0
  case center = 1
  case right_ = 2

  public static var max: CZMHorizontalOrigin { return .right_ }
  public static var min: CZMHorizontalOrigin { return .left_ }
}


public enum CZMVerticalOrigin: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case baseline = 0
  case bottom = 1
  case center = 2
  case top = 3

  public static var max: CZMVerticalOrigin { return .top }
  public static var min: CZMVerticalOrigin { return .baseline }
}


///  Time interval for time-dynamic properties
public struct CZMInterval: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMInterval.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case INTERVAL = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  ISO 8601 interval string (e.g. "2012-03-15T10:00:00Z/2012-03-16T10:00:00Z")
  public var INTERVAL: String? { let o = _accessor.offset(VTOFFSET.INTERVAL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INTERVALSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INTERVAL.v) }
  public static func startCZMInterval(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(INTERVAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTERVAL, at: VTOFFSET.INTERVAL.p) }
  public static func endCZMInterval(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMInterval(
    _ fbb: inout FlatBufferBuilder,
    INTERVALOffset INTERVAL: Offset = Offset()
  ) -> Offset {
    let __start = CZMInterval.startCZMInterval(&fbb)
    CZMInterval.add(INTERVAL: INTERVAL, &fbb)
    return CZMInterval.endCZMInterval(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.INTERVAL.p, fieldName: "INTERVAL", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Cartographic position (longitude, latitude, height in radians/meters)
public struct CZMCartographicDegrees: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMCartographicDegrees.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LONGITUDE = 4
    case LATITUDE = 6
    case HEIGHT = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Longitude in degrees
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Latitude in degrees
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height in meters above WGS84 ellipsoid
  public var HEIGHT: Double { let o = _accessor.offset(VTOFFSET.HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startCZMCartographicDegrees(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT, def: 0.0, at: VTOFFSET.HEIGHT.p) }
  public static func endCZMCartographicDegrees(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMCartographicDegrees(
    _ fbb: inout FlatBufferBuilder,
    LONGITUDE: Double = 0.0,
    LATITUDE: Double = 0.0,
    HEIGHT: Double = 0.0
  ) -> Offset {
    let __start = CZMCartographicDegrees.startCZMCartographicDegrees(&fbb)
    CZMCartographicDegrees.add(LONGITUDE: LONGITUDE, &fbb)
    CZMCartographicDegrees.add(LATITUDE: LATITUDE, &fbb)
    CZMCartographicDegrees.add(HEIGHT: HEIGHT, &fbb)
    return CZMCartographicDegrees.endCZMCartographicDegrees(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEIGHT.p, fieldName: "HEIGHT", required: false, type: Double.self)
    _v.finish()
  }
}

///  Cartesian position (X, Y, Z in meters)
public struct CZMCartesian: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMCartesian.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case X = 4
    case Y = 6
    case Z = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  X component in meters (Earth-fixed)
  public var X: Double { let o = _accessor.offset(VTOFFSET.X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Y component in meters (Earth-fixed)
  public var Y: Double { let o = _accessor.offset(VTOFFSET.Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Z component in meters (Earth-fixed)
  public var Z: Double { let o = _accessor.offset(VTOFFSET.Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startCZMCartesian(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X, def: 0.0, at: VTOFFSET.X.p) }
  public static func add(Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y, def: 0.0, at: VTOFFSET.Y.p) }
  public static func add(Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z, def: 0.0, at: VTOFFSET.Z.p) }
  public static func endCZMCartesian(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMCartesian(
    _ fbb: inout FlatBufferBuilder,
    X: Double = 0.0,
    Y: Double = 0.0,
    Z: Double = 0.0
  ) -> Offset {
    let __start = CZMCartesian.startCZMCartesian(&fbb)
    CZMCartesian.add(X: X, &fbb)
    CZMCartesian.add(Y: Y, &fbb)
    CZMCartesian.add(Z: Z, &fbb)
    return CZMCartesian.endCZMCartesian(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.X.p, fieldName: "X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y.p, fieldName: "Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z.p, fieldName: "Z", required: false, type: Double.self)
    _v.finish()
  }
}

///  RGBA color
public struct CZMColor: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMColor.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RED = 4
    case GREEN = 6
    case BLUE = 8
    case ALPHA = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Red component (0-255)
  public var RED: UInt8 { let o = _accessor.offset(VTOFFSET.RED.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Green component (0-255)
  public var GREEN: UInt8 { let o = _accessor.offset(VTOFFSET.GREEN.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Blue component (0-255)
  public var BLUE: UInt8 { let o = _accessor.offset(VTOFFSET.BLUE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Alpha component (0-255)
  public var ALPHA: UInt8 { let o = _accessor.offset(VTOFFSET.ALPHA.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startCZMColor(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(RED: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RED, def: 0, at: VTOFFSET.RED.p) }
  public static func add(GREEN: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GREEN, def: 0, at: VTOFFSET.GREEN.p) }
  public static func add(BLUE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BLUE, def: 0, at: VTOFFSET.BLUE.p) }
  public static func add(ALPHA: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALPHA, def: 0, at: VTOFFSET.ALPHA.p) }
  public static func endCZMColor(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMColor(
    _ fbb: inout FlatBufferBuilder,
    RED: UInt8 = 0,
    GREEN: UInt8 = 0,
    BLUE: UInt8 = 0,
    ALPHA: UInt8 = 0
  ) -> Offset {
    let __start = CZMColor.startCZMColor(&fbb)
    CZMColor.add(RED: RED, &fbb)
    CZMColor.add(GREEN: GREEN, &fbb)
    CZMColor.add(BLUE: BLUE, &fbb)
    CZMColor.add(ALPHA: ALPHA, &fbb)
    return CZMColor.endCZMColor(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RED.p, fieldName: "RED", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.GREEN.p, fieldName: "GREEN", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.BLUE.p, fieldName: "BLUE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ALPHA.p, fieldName: "ALPHA", required: false, type: UInt8.self)
    _v.finish()
  }
}

///  Near/Far scalar for distance-based display
public struct CZMNearFarScalar: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMNearFarScalar.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NEAR_DISTANCE = 4
    case NEAR_VALUE = 6
    case FAR_DISTANCE = 8
    case FAR_VALUE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Near distance in meters
  public var NEAR_DISTANCE: Double { let o = _accessor.offset(VTOFFSET.NEAR_DISTANCE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Value at near distance
  public var NEAR_VALUE: Double { let o = _accessor.offset(VTOFFSET.NEAR_VALUE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Far distance in meters
  public var FAR_DISTANCE: Double { let o = _accessor.offset(VTOFFSET.FAR_DISTANCE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Value at far distance
  public var FAR_VALUE: Double { let o = _accessor.offset(VTOFFSET.FAR_VALUE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startCZMNearFarScalar(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(NEAR_DISTANCE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NEAR_DISTANCE, def: 0.0, at: VTOFFSET.NEAR_DISTANCE.p) }
  public static func add(NEAR_VALUE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NEAR_VALUE, def: 0.0, at: VTOFFSET.NEAR_VALUE.p) }
  public static func add(FAR_DISTANCE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FAR_DISTANCE, def: 0.0, at: VTOFFSET.FAR_DISTANCE.p) }
  public static func add(FAR_VALUE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FAR_VALUE, def: 0.0, at: VTOFFSET.FAR_VALUE.p) }
  public static func endCZMNearFarScalar(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMNearFarScalar(
    _ fbb: inout FlatBufferBuilder,
    NEAR_DISTANCE: Double = 0.0,
    NEAR_VALUE: Double = 0.0,
    FAR_DISTANCE: Double = 0.0,
    FAR_VALUE: Double = 0.0
  ) -> Offset {
    let __start = CZMNearFarScalar.startCZMNearFarScalar(&fbb)
    CZMNearFarScalar.add(NEAR_DISTANCE: NEAR_DISTANCE, &fbb)
    CZMNearFarScalar.add(NEAR_VALUE: NEAR_VALUE, &fbb)
    CZMNearFarScalar.add(FAR_DISTANCE: FAR_DISTANCE, &fbb)
    CZMNearFarScalar.add(FAR_VALUE: FAR_VALUE, &fbb)
    return CZMNearFarScalar.endCZMNearFarScalar(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NEAR_DISTANCE.p, fieldName: "NEAR_DISTANCE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NEAR_VALUE.p, fieldName: "NEAR_VALUE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FAR_DISTANCE.p, fieldName: "FAR_DISTANCE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FAR_VALUE.p, fieldName: "FAR_VALUE", required: false, type: Double.self)
    _v.finish()
  }
}

///  Billboard (icon) properties
public struct CZMBillboard: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMBillboard.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case IMAGE = 6
    case SCALE = 8
    case COLOR = 10
    case HEIGHT_REFERENCE = 12
    case PIXEL_OFFSET_X = 14
    case PIXEL_OFFSET_Y = 16
    case HORIZONTAL_ORIGIN = 18
    case VERTICAL_ORIGIN = 20
    case TRANSLUCENCY_BY_DISTANCE = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the billboard is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  URI of the billboard image
  public var IMAGE: String? { let o = _accessor.offset(VTOFFSET.IMAGE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IMAGESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IMAGE.v) }
  ///  Scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Billboard color tint
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  ///  Pixel offset X
  public var PIXEL_OFFSET_X: Double { let o = _accessor.offset(VTOFFSET.PIXEL_OFFSET_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pixel offset Y
  public var PIXEL_OFFSET_Y: Double { let o = _accessor.offset(VTOFFSET.PIXEL_OFFSET_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Horizontal origin
  public var HORIZONTAL_ORIGIN: CZMHorizontalOrigin { let o = _accessor.offset(VTOFFSET.HORIZONTAL_ORIGIN.v); return o == 0 ? .left_ : CZMHorizontalOrigin(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .left_ }
  ///  Vertical origin
  public var VERTICAL_ORIGIN: CZMVerticalOrigin { let o = _accessor.offset(VTOFFSET.VERTICAL_ORIGIN.v); return o == 0 ? .baseline : CZMVerticalOrigin(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .baseline }
  ///  Translucency by distance
  public var TRANSLUCENCY_BY_DISTANCE: CZMNearFarScalar? { let o = _accessor.offset(VTOFFSET.TRANSLUCENCY_BY_DISTANCE.v); return o == 0 ? nil : CZMNearFarScalar(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCZMBillboard(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(IMAGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IMAGE, at: VTOFFSET.IMAGE.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func add(PIXEL_OFFSET_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PIXEL_OFFSET_X, def: 0.0, at: VTOFFSET.PIXEL_OFFSET_X.p) }
  public static func add(PIXEL_OFFSET_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PIXEL_OFFSET_Y, def: 0.0, at: VTOFFSET.PIXEL_OFFSET_Y.p) }
  public static func add(HORIZONTAL_ORIGIN: CZMHorizontalOrigin, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HORIZONTAL_ORIGIN.rawValue, def: 0, at: VTOFFSET.HORIZONTAL_ORIGIN.p) }
  public static func add(VERTICAL_ORIGIN: CZMVerticalOrigin, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VERTICAL_ORIGIN.rawValue, def: 0, at: VTOFFSET.VERTICAL_ORIGIN.p) }
  public static func add(TRANSLUCENCY_BY_DISTANCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRANSLUCENCY_BY_DISTANCE, at: VTOFFSET.TRANSLUCENCY_BY_DISTANCE.p) }
  public static func endCZMBillboard(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMBillboard(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    IMAGEOffset IMAGE: Offset = Offset(),
    SCALE: Double = 0.0,
    COLOROffset COLOR: Offset = Offset(),
    HEIGHT_REFERENCE: CZMHeightReference = .none_,
    PIXEL_OFFSET_X: Double = 0.0,
    PIXEL_OFFSET_Y: Double = 0.0,
    HORIZONTAL_ORIGIN: CZMHorizontalOrigin = .left_,
    VERTICAL_ORIGIN: CZMVerticalOrigin = .baseline,
    TRANSLUCENCY_BY_DISTANCEOffset TRANSLUCENCY_BY_DISTANCE: Offset = Offset()
  ) -> Offset {
    let __start = CZMBillboard.startCZMBillboard(&fbb)
    CZMBillboard.add(SHOW: SHOW, &fbb)
    CZMBillboard.add(IMAGE: IMAGE, &fbb)
    CZMBillboard.add(SCALE: SCALE, &fbb)
    CZMBillboard.add(COLOR: COLOR, &fbb)
    CZMBillboard.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    CZMBillboard.add(PIXEL_OFFSET_X: PIXEL_OFFSET_X, &fbb)
    CZMBillboard.add(PIXEL_OFFSET_Y: PIXEL_OFFSET_Y, &fbb)
    CZMBillboard.add(HORIZONTAL_ORIGIN: HORIZONTAL_ORIGIN, &fbb)
    CZMBillboard.add(VERTICAL_ORIGIN: VERTICAL_ORIGIN, &fbb)
    CZMBillboard.add(TRANSLUCENCY_BY_DISTANCE: TRANSLUCENCY_BY_DISTANCE, &fbb)
    return CZMBillboard.endCZMBillboard(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.IMAGE.p, fieldName: "IMAGE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    try _v.visit(field: VTOFFSET.PIXEL_OFFSET_X.p, fieldName: "PIXEL_OFFSET_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PIXEL_OFFSET_Y.p, fieldName: "PIXEL_OFFSET_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HORIZONTAL_ORIGIN.p, fieldName: "HORIZONTAL_ORIGIN", required: false, type: CZMHorizontalOrigin.self)
    try _v.visit(field: VTOFFSET.VERTICAL_ORIGIN.p, fieldName: "VERTICAL_ORIGIN", required: false, type: CZMVerticalOrigin.self)
    try _v.visit(field: VTOFFSET.TRANSLUCENCY_BY_DISTANCE.p, fieldName: "TRANSLUCENCY_BY_DISTANCE", required: false, type: ForwardOffset<CZMNearFarScalar>.self)
    _v.finish()
  }
}

///  Label properties
public struct CZMLabel: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMLabel.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case TEXT = 6
    case FONT = 8
    case STYLE = 10
    case FILL_COLOR = 12
    case OUTLINE_COLOR = 14
    case OUTLINE_WIDTH = 16
    case PIXEL_OFFSET_X = 18
    case PIXEL_OFFSET_Y = 20
    case SCALE = 22
    case HORIZONTAL_ORIGIN = 24
    case VERTICAL_ORIGIN = 26
    case HEIGHT_REFERENCE = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the label is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Label text
  public var TEXT: String? { let o = _accessor.offset(VTOFFSET.TEXT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TEXTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TEXT.v) }
  ///  Font CSS string (e.g. "12pt Lucida Console")
  public var FONT: String? { let o = _accessor.offset(VTOFFSET.FONT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FONTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FONT.v) }
  ///  Label style
  public var STYLE: CZMLabelStyle { let o = _accessor.offset(VTOFFSET.STYLE.v); return o == 0 ? .fill : CZMLabelStyle(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .fill }
  ///  Fill color
  public var FILL_COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.FILL_COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline color
  public var OUTLINE_COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.OUTLINE_COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline width in pixels
  public var OUTLINE_WIDTH: Double { let o = _accessor.offset(VTOFFSET.OUTLINE_WIDTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pixel offset X
  public var PIXEL_OFFSET_X: Double { let o = _accessor.offset(VTOFFSET.PIXEL_OFFSET_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pixel offset Y
  public var PIXEL_OFFSET_Y: Double { let o = _accessor.offset(VTOFFSET.PIXEL_OFFSET_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Horizontal origin
  public var HORIZONTAL_ORIGIN: CZMHorizontalOrigin { let o = _accessor.offset(VTOFFSET.HORIZONTAL_ORIGIN.v); return o == 0 ? .left_ : CZMHorizontalOrigin(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .left_ }
  ///  Vertical origin
  public var VERTICAL_ORIGIN: CZMVerticalOrigin { let o = _accessor.offset(VTOFFSET.VERTICAL_ORIGIN.v); return o == 0 ? .baseline : CZMVerticalOrigin(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .baseline }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startCZMLabel(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(TEXT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TEXT, at: VTOFFSET.TEXT.p) }
  public static func add(FONT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FONT, at: VTOFFSET.FONT.p) }
  public static func add(STYLE: CZMLabelStyle, _ fbb: inout FlatBufferBuilder) { fbb.add(element: STYLE.rawValue, def: 0, at: VTOFFSET.STYLE.p) }
  public static func add(FILL_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FILL_COLOR, at: VTOFFSET.FILL_COLOR.p) }
  public static func add(OUTLINE_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTLINE_COLOR, at: VTOFFSET.OUTLINE_COLOR.p) }
  public static func add(OUTLINE_WIDTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OUTLINE_WIDTH, def: 0.0, at: VTOFFSET.OUTLINE_WIDTH.p) }
  public static func add(PIXEL_OFFSET_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PIXEL_OFFSET_X, def: 0.0, at: VTOFFSET.PIXEL_OFFSET_X.p) }
  public static func add(PIXEL_OFFSET_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PIXEL_OFFSET_Y, def: 0.0, at: VTOFFSET.PIXEL_OFFSET_Y.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func add(HORIZONTAL_ORIGIN: CZMHorizontalOrigin, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HORIZONTAL_ORIGIN.rawValue, def: 0, at: VTOFFSET.HORIZONTAL_ORIGIN.p) }
  public static func add(VERTICAL_ORIGIN: CZMVerticalOrigin, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VERTICAL_ORIGIN.rawValue, def: 0, at: VTOFFSET.VERTICAL_ORIGIN.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func endCZMLabel(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMLabel(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    TEXTOffset TEXT: Offset = Offset(),
    FONTOffset FONT: Offset = Offset(),
    STYLE: CZMLabelStyle = .fill,
    FILL_COLOROffset FILL_COLOR: Offset = Offset(),
    OUTLINE_COLOROffset OUTLINE_COLOR: Offset = Offset(),
    OUTLINE_WIDTH: Double = 0.0,
    PIXEL_OFFSET_X: Double = 0.0,
    PIXEL_OFFSET_Y: Double = 0.0,
    SCALE: Double = 0.0,
    HORIZONTAL_ORIGIN: CZMHorizontalOrigin = .left_,
    VERTICAL_ORIGIN: CZMVerticalOrigin = .baseline,
    HEIGHT_REFERENCE: CZMHeightReference = .none_
  ) -> Offset {
    let __start = CZMLabel.startCZMLabel(&fbb)
    CZMLabel.add(SHOW: SHOW, &fbb)
    CZMLabel.add(TEXT: TEXT, &fbb)
    CZMLabel.add(FONT: FONT, &fbb)
    CZMLabel.add(STYLE: STYLE, &fbb)
    CZMLabel.add(FILL_COLOR: FILL_COLOR, &fbb)
    CZMLabel.add(OUTLINE_COLOR: OUTLINE_COLOR, &fbb)
    CZMLabel.add(OUTLINE_WIDTH: OUTLINE_WIDTH, &fbb)
    CZMLabel.add(PIXEL_OFFSET_X: PIXEL_OFFSET_X, &fbb)
    CZMLabel.add(PIXEL_OFFSET_Y: PIXEL_OFFSET_Y, &fbb)
    CZMLabel.add(SCALE: SCALE, &fbb)
    CZMLabel.add(HORIZONTAL_ORIGIN: HORIZONTAL_ORIGIN, &fbb)
    CZMLabel.add(VERTICAL_ORIGIN: VERTICAL_ORIGIN, &fbb)
    CZMLabel.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    return CZMLabel.endCZMLabel(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.TEXT.p, fieldName: "TEXT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FONT.p, fieldName: "FONT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STYLE.p, fieldName: "STYLE", required: false, type: CZMLabelStyle.self)
    try _v.visit(field: VTOFFSET.FILL_COLOR.p, fieldName: "FILL_COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE_COLOR.p, fieldName: "OUTLINE_COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE_WIDTH.p, fieldName: "OUTLINE_WIDTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PIXEL_OFFSET_X.p, fieldName: "PIXEL_OFFSET_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PIXEL_OFFSET_Y.p, fieldName: "PIXEL_OFFSET_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HORIZONTAL_ORIGIN.p, fieldName: "HORIZONTAL_ORIGIN", required: false, type: CZMHorizontalOrigin.self)
    try _v.visit(field: VTOFFSET.VERTICAL_ORIGIN.p, fieldName: "VERTICAL_ORIGIN", required: false, type: CZMVerticalOrigin.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    _v.finish()
  }
}

///  Point properties
public struct CZMPoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMPoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case COLOR = 6
    case OUTLINE_COLOR = 8
    case OUTLINE_WIDTH = 10
    case PIXEL_SIZE = 12
    case HEIGHT_REFERENCE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the point is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Point color
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline color
  public var OUTLINE_COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.OUTLINE_COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline width in pixels
  public var OUTLINE_WIDTH: Double { let o = _accessor.offset(VTOFFSET.OUTLINE_WIDTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Pixel size
  public var PIXEL_SIZE: Double { let o = _accessor.offset(VTOFFSET.PIXEL_SIZE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startCZMPoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(OUTLINE_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTLINE_COLOR, at: VTOFFSET.OUTLINE_COLOR.p) }
  public static func add(OUTLINE_WIDTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OUTLINE_WIDTH, def: 0.0, at: VTOFFSET.OUTLINE_WIDTH.p) }
  public static func add(PIXEL_SIZE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PIXEL_SIZE, def: 0.0, at: VTOFFSET.PIXEL_SIZE.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func endCZMPoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMPoint(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    COLOROffset COLOR: Offset = Offset(),
    OUTLINE_COLOROffset OUTLINE_COLOR: Offset = Offset(),
    OUTLINE_WIDTH: Double = 0.0,
    PIXEL_SIZE: Double = 0.0,
    HEIGHT_REFERENCE: CZMHeightReference = .none_
  ) -> Offset {
    let __start = CZMPoint.startCZMPoint(&fbb)
    CZMPoint.add(SHOW: SHOW, &fbb)
    CZMPoint.add(COLOR: COLOR, &fbb)
    CZMPoint.add(OUTLINE_COLOR: OUTLINE_COLOR, &fbb)
    CZMPoint.add(OUTLINE_WIDTH: OUTLINE_WIDTH, &fbb)
    CZMPoint.add(PIXEL_SIZE: PIXEL_SIZE, &fbb)
    CZMPoint.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    return CZMPoint.endCZMPoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE_COLOR.p, fieldName: "OUTLINE_COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE_WIDTH.p, fieldName: "OUTLINE_WIDTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PIXEL_SIZE.p, fieldName: "PIXEL_SIZE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    _v.finish()
  }
}

///  Polyline properties
public struct CZMPolyline: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMPolyline.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case POSITIONS_CARTOGRAPHIC_DEGREES = 6
    case POSITIONS_CARTESIAN = 8
    case WIDTH = 10
    case COLOR = 12
    case CLAMP_TO_GROUND = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the polyline is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Positions as cartographic degrees [lon, lat, height, lon, lat, height, ...]
  public var hasPositionsCartographicDegrees: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? false : true }
  public var POSITIONS_CARTOGRAPHIC_DEGREESCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS_CARTOGRAPHIC_DEGREES(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITIONS_CARTOGRAPHIC_DEGREES: [Double] { return _accessor.getVector(at: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v) ?? [] }
  ///  Positions as Cartesian [X, Y, Z, X, Y, Z, ...]
  public var hasPositionsCartesian: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? false : true }
  public var POSITIONS_CARTESIANCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS_CARTESIAN(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITIONS_CARTESIAN: [Double] { return _accessor.getVector(at: VTOFFSET.POSITIONS_CARTESIAN.v) ?? [] }
  ///  Line width in pixels
  public var WIDTH: Double { let o = _accessor.offset(VTOFFSET.WIDTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Line color (solid color material)
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Whether to clamp to ground
  public var CLAMP_TO_GROUND: Bool { let o = _accessor.offset(VTOFFSET.CLAMP_TO_GROUND.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startCZMPolyline(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func addVectorOf(POSITIONS_CARTOGRAPHIC_DEGREES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS_CARTOGRAPHIC_DEGREES, at: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.p) }
  public static func addVectorOf(POSITIONS_CARTESIAN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS_CARTESIAN, at: VTOFFSET.POSITIONS_CARTESIAN.p) }
  public static func add(WIDTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WIDTH, def: 0.0, at: VTOFFSET.WIDTH.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(CLAMP_TO_GROUND: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CLAMP_TO_GROUND, def: false,
   at: VTOFFSET.CLAMP_TO_GROUND.p) }
  public static func endCZMPolyline(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMPolyline(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    POSITIONS_CARTOGRAPHIC_DEGREESVectorOffset POSITIONS_CARTOGRAPHIC_DEGREES: Offset = Offset(),
    POSITIONS_CARTESIANVectorOffset POSITIONS_CARTESIAN: Offset = Offset(),
    WIDTH: Double = 0.0,
    COLOROffset COLOR: Offset = Offset(),
    CLAMP_TO_GROUND: Bool = false
  ) -> Offset {
    let __start = CZMPolyline.startCZMPolyline(&fbb)
    CZMPolyline.add(SHOW: SHOW, &fbb)
    CZMPolyline.addVectorOf(POSITIONS_CARTOGRAPHIC_DEGREES: POSITIONS_CARTOGRAPHIC_DEGREES, &fbb)
    CZMPolyline.addVectorOf(POSITIONS_CARTESIAN: POSITIONS_CARTESIAN, &fbb)
    CZMPolyline.add(WIDTH: WIDTH, &fbb)
    CZMPolyline.add(COLOR: COLOR, &fbb)
    CZMPolyline.add(CLAMP_TO_GROUND: CLAMP_TO_GROUND, &fbb)
    return CZMPolyline.endCZMPolyline(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.p, fieldName: "POSITIONS_CARTOGRAPHIC_DEGREES", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.POSITIONS_CARTESIAN.p, fieldName: "POSITIONS_CARTESIAN", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.WIDTH.p, fieldName: "WIDTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.CLAMP_TO_GROUND.p, fieldName: "CLAMP_TO_GROUND", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Polygon properties
public struct CZMPolygon: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMPolygon.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case POSITIONS_CARTOGRAPHIC_DEGREES = 6
    case POSITIONS_CARTESIAN = 8
    case FILL = 10
    case COLOR = 12
    case OUTLINE = 14
    case OUTLINE_COLOR = 16
    case EXTRUDED_HEIGHT = 18
    case HEIGHT_REFERENCE = 20
    case CLASSIFICATION_TYPE = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the polygon is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Positions as cartographic degrees [lon, lat, height, ...]
  public var hasPositionsCartographicDegrees: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? false : true }
  public var POSITIONS_CARTOGRAPHIC_DEGREESCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS_CARTOGRAPHIC_DEGREES(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITIONS_CARTOGRAPHIC_DEGREES: [Double] { return _accessor.getVector(at: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.v) ?? [] }
  ///  Positions as Cartesian [X, Y, Z, ...]
  public var hasPositionsCartesian: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? false : true }
  public var POSITIONS_CARTESIANCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS_CARTESIAN(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITIONS_CARTESIAN.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITIONS_CARTESIAN: [Double] { return _accessor.getVector(at: VTOFFSET.POSITIONS_CARTESIAN.v) ?? [] }
  ///  Fill flag
  public var FILL: Bool { let o = _accessor.offset(VTOFFSET.FILL.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Fill color (solid color material)
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline flag
  public var OUTLINE: Bool { let o = _accessor.offset(VTOFFSET.OUTLINE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Outline color
  public var OUTLINE_COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.OUTLINE_COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Extruded height in meters
  public var EXTRUDED_HEIGHT: Double { let o = _accessor.offset(VTOFFSET.EXTRUDED_HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  ///  Classification type
  public var CLASSIFICATION_TYPE: CZMClassificationType { let o = _accessor.offset(VTOFFSET.CLASSIFICATION_TYPE.v); return o == 0 ? .terrain : CZMClassificationType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .terrain }
  public static func startCZMPolygon(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func addVectorOf(POSITIONS_CARTOGRAPHIC_DEGREES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS_CARTOGRAPHIC_DEGREES, at: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.p) }
  public static func addVectorOf(POSITIONS_CARTESIAN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS_CARTESIAN, at: VTOFFSET.POSITIONS_CARTESIAN.p) }
  public static func add(FILL: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FILL, def: false,
   at: VTOFFSET.FILL.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(OUTLINE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OUTLINE, def: false,
   at: VTOFFSET.OUTLINE.p) }
  public static func add(OUTLINE_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTLINE_COLOR, at: VTOFFSET.OUTLINE_COLOR.p) }
  public static func add(EXTRUDED_HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRUDED_HEIGHT, def: 0.0, at: VTOFFSET.EXTRUDED_HEIGHT.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func add(CLASSIFICATION_TYPE: CZMClassificationType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CLASSIFICATION_TYPE.rawValue, def: 0, at: VTOFFSET.CLASSIFICATION_TYPE.p) }
  public static func endCZMPolygon(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMPolygon(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    POSITIONS_CARTOGRAPHIC_DEGREESVectorOffset POSITIONS_CARTOGRAPHIC_DEGREES: Offset = Offset(),
    POSITIONS_CARTESIANVectorOffset POSITIONS_CARTESIAN: Offset = Offset(),
    FILL: Bool = false,
    COLOROffset COLOR: Offset = Offset(),
    OUTLINE: Bool = false,
    OUTLINE_COLOROffset OUTLINE_COLOR: Offset = Offset(),
    EXTRUDED_HEIGHT: Double = 0.0,
    HEIGHT_REFERENCE: CZMHeightReference = .none_,
    CLASSIFICATION_TYPE: CZMClassificationType = .terrain
  ) -> Offset {
    let __start = CZMPolygon.startCZMPolygon(&fbb)
    CZMPolygon.add(SHOW: SHOW, &fbb)
    CZMPolygon.addVectorOf(POSITIONS_CARTOGRAPHIC_DEGREES: POSITIONS_CARTOGRAPHIC_DEGREES, &fbb)
    CZMPolygon.addVectorOf(POSITIONS_CARTESIAN: POSITIONS_CARTESIAN, &fbb)
    CZMPolygon.add(FILL: FILL, &fbb)
    CZMPolygon.add(COLOR: COLOR, &fbb)
    CZMPolygon.add(OUTLINE: OUTLINE, &fbb)
    CZMPolygon.add(OUTLINE_COLOR: OUTLINE_COLOR, &fbb)
    CZMPolygon.add(EXTRUDED_HEIGHT: EXTRUDED_HEIGHT, &fbb)
    CZMPolygon.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    CZMPolygon.add(CLASSIFICATION_TYPE: CLASSIFICATION_TYPE, &fbb)
    return CZMPolygon.endCZMPolygon(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.POSITIONS_CARTOGRAPHIC_DEGREES.p, fieldName: "POSITIONS_CARTOGRAPHIC_DEGREES", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.POSITIONS_CARTESIAN.p, fieldName: "POSITIONS_CARTESIAN", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.FILL.p, fieldName: "FILL", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE.p, fieldName: "OUTLINE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OUTLINE_COLOR.p, fieldName: "OUTLINE_COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.EXTRUDED_HEIGHT.p, fieldName: "EXTRUDED_HEIGHT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    try _v.visit(field: VTOFFSET.CLASSIFICATION_TYPE.p, fieldName: "CLASSIFICATION_TYPE", required: false, type: CZMClassificationType.self)
    _v.finish()
  }
}

///  Model properties (glTF)
public struct CZMModel: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMModel.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case GLTF = 6
    case SCALE = 8
    case MINIMUM_PIXEL_SIZE = 10
    case MAXIMUM_SCALE = 12
    case HEIGHT_REFERENCE = 14
    case COLOR = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the model is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  URI to the glTF model
  public var GLTF: String? { let o = _accessor.offset(VTOFFSET.GLTF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GLTFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GLTF.v) }
  ///  Scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum pixel size
  public var MINIMUM_PIXEL_SIZE: Double { let o = _accessor.offset(VTOFFSET.MINIMUM_PIXEL_SIZE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum scale
  public var MAXIMUM_SCALE: Double { let o = _accessor.offset(VTOFFSET.MAXIMUM_SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  ///  Color tint
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCZMModel(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(GLTF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GLTF, at: VTOFFSET.GLTF.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func add(MINIMUM_PIXEL_SIZE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MINIMUM_PIXEL_SIZE, def: 0.0, at: VTOFFSET.MINIMUM_PIXEL_SIZE.p) }
  public static func add(MAXIMUM_SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAXIMUM_SCALE, def: 0.0, at: VTOFFSET.MAXIMUM_SCALE.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func endCZMModel(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMModel(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    GLTFOffset GLTF: Offset = Offset(),
    SCALE: Double = 0.0,
    MINIMUM_PIXEL_SIZE: Double = 0.0,
    MAXIMUM_SCALE: Double = 0.0,
    HEIGHT_REFERENCE: CZMHeightReference = .none_,
    COLOROffset COLOR: Offset = Offset()
  ) -> Offset {
    let __start = CZMModel.startCZMModel(&fbb)
    CZMModel.add(SHOW: SHOW, &fbb)
    CZMModel.add(GLTF: GLTF, &fbb)
    CZMModel.add(SCALE: SCALE, &fbb)
    CZMModel.add(MINIMUM_PIXEL_SIZE: MINIMUM_PIXEL_SIZE, &fbb)
    CZMModel.add(MAXIMUM_SCALE: MAXIMUM_SCALE, &fbb)
    CZMModel.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    CZMModel.add(COLOR: COLOR, &fbb)
    return CZMModel.endCZMModel(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.GLTF.p, fieldName: "GLTF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MINIMUM_PIXEL_SIZE.p, fieldName: "MINIMUM_PIXEL_SIZE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MAXIMUM_SCALE.p, fieldName: "MAXIMUM_SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    _v.finish()
  }
}

///  Path properties (orbit trail)
public struct CZMPath: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMPath.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case LEAD_TIME = 6
    case TRAIL_TIME = 8
    case WIDTH = 10
    case COLOR = 12
    case RESOLUTION = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the path is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Trail time in seconds (how far behind)
  public var LEAD_TIME: Double { let o = _accessor.offset(VTOFFSET.LEAD_TIME.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Lead time in seconds (how far ahead)
  public var TRAIL_TIME: Double { let o = _accessor.offset(VTOFFSET.TRAIL_TIME.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Line width in pixels
  public var WIDTH: Double { let o = _accessor.offset(VTOFFSET.WIDTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Path color
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Resolution in seconds
  public var RESOLUTION: Double { let o = _accessor.offset(VTOFFSET.RESOLUTION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startCZMPath(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(LEAD_TIME: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LEAD_TIME, def: 0.0, at: VTOFFSET.LEAD_TIME.p) }
  public static func add(TRAIL_TIME: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRAIL_TIME, def: 0.0, at: VTOFFSET.TRAIL_TIME.p) }
  public static func add(WIDTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WIDTH, def: 0.0, at: VTOFFSET.WIDTH.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(RESOLUTION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RESOLUTION, def: 0.0, at: VTOFFSET.RESOLUTION.p) }
  public static func endCZMPath(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMPath(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    LEAD_TIME: Double = 0.0,
    TRAIL_TIME: Double = 0.0,
    WIDTH: Double = 0.0,
    COLOROffset COLOR: Offset = Offset(),
    RESOLUTION: Double = 0.0
  ) -> Offset {
    let __start = CZMPath.startCZMPath(&fbb)
    CZMPath.add(SHOW: SHOW, &fbb)
    CZMPath.add(LEAD_TIME: LEAD_TIME, &fbb)
    CZMPath.add(TRAIL_TIME: TRAIL_TIME, &fbb)
    CZMPath.add(WIDTH: WIDTH, &fbb)
    CZMPath.add(COLOR: COLOR, &fbb)
    CZMPath.add(RESOLUTION: RESOLUTION, &fbb)
    return CZMPath.endCZMPath(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.LEAD_TIME.p, fieldName: "LEAD_TIME", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TRAIL_TIME.p, fieldName: "TRAIL_TIME", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.WIDTH.p, fieldName: "WIDTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.RESOLUTION.p, fieldName: "RESOLUTION", required: false, type: Double.self)
    _v.finish()
  }
}

///  Ellipse properties (for ground circles/ellipses)
public struct CZMEllipse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMEllipse.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SHOW = 4
    case SEMI_MAJOR_AXIS = 6
    case SEMI_MINOR_AXIS = 8
    case ROTATION = 10
    case FILL = 12
    case COLOR = 14
    case OUTLINE = 16
    case OUTLINE_COLOR = 18
    case HEIGHT = 20
    case HEIGHT_REFERENCE = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Whether the ellipse is displayed
  public var SHOW: Bool { let o = _accessor.offset(VTOFFSET.SHOW.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Semi-major axis in meters
  public var SEMI_MAJOR_AXIS: Double { let o = _accessor.offset(VTOFFSET.SEMI_MAJOR_AXIS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Semi-minor axis in meters
  public var SEMI_MINOR_AXIS: Double { let o = _accessor.offset(VTOFFSET.SEMI_MINOR_AXIS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rotation from north in radians
  public var ROTATION: Double { let o = _accessor.offset(VTOFFSET.ROTATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Fill flag
  public var FILL: Bool { let o = _accessor.offset(VTOFFSET.FILL.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Fill color
  public var COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Outline flag
  public var OUTLINE: Bool { let o = _accessor.offset(VTOFFSET.OUTLINE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Outline color
  public var OUTLINE_COLOR: CZMColor? { let o = _accessor.offset(VTOFFSET.OUTLINE_COLOR.v); return o == 0 ? nil : CZMColor(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Height in meters
  public var HEIGHT: Double { let o = _accessor.offset(VTOFFSET.HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height reference
  public var HEIGHT_REFERENCE: CZMHeightReference { let o = _accessor.offset(VTOFFSET.HEIGHT_REFERENCE.v); return o == 0 ? .none_ : CZMHeightReference(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startCZMEllipse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(SHOW: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SHOW, def: false,
   at: VTOFFSET.SHOW.p) }
  public static func add(SEMI_MAJOR_AXIS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEMI_MAJOR_AXIS, def: 0.0, at: VTOFFSET.SEMI_MAJOR_AXIS.p) }
  public static func add(SEMI_MINOR_AXIS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEMI_MINOR_AXIS, def: 0.0, at: VTOFFSET.SEMI_MINOR_AXIS.p) }
  public static func add(ROTATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ROTATION, def: 0.0, at: VTOFFSET.ROTATION.p) }
  public static func add(FILL: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FILL, def: false,
   at: VTOFFSET.FILL.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(OUTLINE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OUTLINE, def: false,
   at: VTOFFSET.OUTLINE.p) }
  public static func add(OUTLINE_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTLINE_COLOR, at: VTOFFSET.OUTLINE_COLOR.p) }
  public static func add(HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT, def: 0.0, at: VTOFFSET.HEIGHT.p) }
  public static func add(HEIGHT_REFERENCE: CZMHeightReference, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEIGHT_REFERENCE.rawValue, def: 0, at: VTOFFSET.HEIGHT_REFERENCE.p) }
  public static func endCZMEllipse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMEllipse(
    _ fbb: inout FlatBufferBuilder,
    SHOW: Bool = false,
    SEMI_MAJOR_AXIS: Double = 0.0,
    SEMI_MINOR_AXIS: Double = 0.0,
    ROTATION: Double = 0.0,
    FILL: Bool = false,
    COLOROffset COLOR: Offset = Offset(),
    OUTLINE: Bool = false,
    OUTLINE_COLOROffset OUTLINE_COLOR: Offset = Offset(),
    HEIGHT: Double = 0.0,
    HEIGHT_REFERENCE: CZMHeightReference = .none_
  ) -> Offset {
    let __start = CZMEllipse.startCZMEllipse(&fbb)
    CZMEllipse.add(SHOW: SHOW, &fbb)
    CZMEllipse.add(SEMI_MAJOR_AXIS: SEMI_MAJOR_AXIS, &fbb)
    CZMEllipse.add(SEMI_MINOR_AXIS: SEMI_MINOR_AXIS, &fbb)
    CZMEllipse.add(ROTATION: ROTATION, &fbb)
    CZMEllipse.add(FILL: FILL, &fbb)
    CZMEllipse.add(COLOR: COLOR, &fbb)
    CZMEllipse.add(OUTLINE: OUTLINE, &fbb)
    CZMEllipse.add(OUTLINE_COLOR: OUTLINE_COLOR, &fbb)
    CZMEllipse.add(HEIGHT: HEIGHT, &fbb)
    CZMEllipse.add(HEIGHT_REFERENCE: HEIGHT_REFERENCE, &fbb)
    return CZMEllipse.endCZMEllipse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SHOW.p, fieldName: "SHOW", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.SEMI_MAJOR_AXIS.p, fieldName: "SEMI_MAJOR_AXIS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SEMI_MINOR_AXIS.p, fieldName: "SEMI_MINOR_AXIS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ROTATION.p, fieldName: "ROTATION", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FILL.p, fieldName: "FILL", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.OUTLINE.p, fieldName: "OUTLINE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OUTLINE_COLOR.p, fieldName: "OUTLINE_COLOR", required: false, type: ForwardOffset<CZMColor>.self)
    try _v.visit(field: VTOFFSET.HEIGHT.p, fieldName: "HEIGHT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEIGHT_REFERENCE.p, fieldName: "HEIGHT_REFERENCE", required: false, type: CZMHeightReference.self)
    _v.finish()
  }
}

///  A CZML Packet describing an entity and its properties
public struct CZMPacket: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZMPacket.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case NAME = 6
    case PARENT = 8
    case DESCRIPTION = 10
    case AVAILABILITY = 12
    case POSITION_CARTOGRAPHIC_DEGREES = 14
    case POSITION_CARTESIAN = 16
    case POSITION_EPOCH = 18
    case POSITION_CARTOGRAPHIC_DEGREES_ARRAY = 20
    case POSITION_CARTESIAN_ARRAY = 22
    case BILLBOARD = 24
    case LABEL = 26
    case POINT = 28
    case POLYLINE = 30
    case POLYGON = 32
    case MODEL = 34
    case PATH = 36
    case ELLIPSE = 38
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for this object
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Human-readable name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Parent packet ID
  public var PARENT: String? { let o = _accessor.offset(VTOFFSET.PARENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PARENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PARENT.v) }
  ///  Description (HTML allowed)
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Availability interval (ISO 8601 interval)
  public var AVAILABILITY: String? { let o = _accessor.offset(VTOFFSET.AVAILABILITY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AVAILABILITYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AVAILABILITY.v) }
  ///  Position as cartographic degrees
  public var POSITION_CARTOGRAPHIC_DEGREES: CZMCartographicDegrees? { let o = _accessor.offset(VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES.v); return o == 0 ? nil : CZMCartographicDegrees(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Position as Cartesian
  public var POSITION_CARTESIAN: CZMCartesian? { let o = _accessor.offset(VTOFFSET.POSITION_CARTESIAN.v); return o == 0 ? nil : CZMCartesian(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Time-tagged positions [time, lon, lat, height, time, lon, lat, height, ...]
  public var POSITION_EPOCH: String? { let o = _accessor.offset(VTOFFSET.POSITION_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POSITION_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POSITION_EPOCH.v) }
  ///  Time-tagged cartographic degree values
  public var hasPositionCartographicDegreesArray: Bool { let o = _accessor.offset(VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.v); return o == 0 ? false : true }
  public var POSITION_CARTOGRAPHIC_DEGREES_ARRAYCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITION_CARTOGRAPHIC_DEGREES_ARRAY(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITION_CARTOGRAPHIC_DEGREES_ARRAY: [Double] { return _accessor.getVector(at: VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.v) ?? [] }
  ///  Time-tagged Cartesian values
  public var hasPositionCartesianArray: Bool { let o = _accessor.offset(VTOFFSET.POSITION_CARTESIAN_ARRAY.v); return o == 0 ? false : true }
  public var POSITION_CARTESIAN_ARRAYCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITION_CARTESIAN_ARRAY.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITION_CARTESIAN_ARRAY(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.POSITION_CARTESIAN_ARRAY.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var POSITION_CARTESIAN_ARRAY: [Double] { return _accessor.getVector(at: VTOFFSET.POSITION_CARTESIAN_ARRAY.v) ?? [] }
  ///  Billboard properties
  public var BILLBOARD: CZMBillboard? { let o = _accessor.offset(VTOFFSET.BILLBOARD.v); return o == 0 ? nil : CZMBillboard(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Label properties
  public var LABEL: CZMLabel? { let o = _accessor.offset(VTOFFSET.LABEL.v); return o == 0 ? nil : CZMLabel(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Point properties
  public var POINT: CZMPoint? { let o = _accessor.offset(VTOFFSET.POINT.v); return o == 0 ? nil : CZMPoint(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Polyline properties
  public var POLYLINE: CZMPolyline? { let o = _accessor.offset(VTOFFSET.POLYLINE.v); return o == 0 ? nil : CZMPolyline(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Polygon properties
  public var POLYGON: CZMPolygon? { let o = _accessor.offset(VTOFFSET.POLYGON.v); return o == 0 ? nil : CZMPolygon(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Model properties
  public var MODEL: CZMModel? { let o = _accessor.offset(VTOFFSET.MODEL.v); return o == 0 ? nil : CZMModel(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Path properties
  public var PATH: CZMPath? { let o = _accessor.offset(VTOFFSET.PATH.v); return o == 0 ? nil : CZMPath(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Ellipse properties
  public var ELLIPSE: CZMEllipse? { let o = _accessor.offset(VTOFFSET.ELLIPSE.v); return o == 0 ? nil : CZMEllipse(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCZMPacket(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 18) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(PARENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PARENT, at: VTOFFSET.PARENT.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(AVAILABILITY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AVAILABILITY, at: VTOFFSET.AVAILABILITY.p) }
  public static func add(POSITION_CARTOGRAPHIC_DEGREES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_CARTOGRAPHIC_DEGREES, at: VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES.p) }
  public static func add(POSITION_CARTESIAN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_CARTESIAN, at: VTOFFSET.POSITION_CARTESIAN.p) }
  public static func add(POSITION_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_EPOCH, at: VTOFFSET.POSITION_EPOCH.p) }
  public static func addVectorOf(POSITION_CARTOGRAPHIC_DEGREES_ARRAY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_CARTOGRAPHIC_DEGREES_ARRAY, at: VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.p) }
  public static func addVectorOf(POSITION_CARTESIAN_ARRAY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_CARTESIAN_ARRAY, at: VTOFFSET.POSITION_CARTESIAN_ARRAY.p) }
  public static func add(BILLBOARD: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BILLBOARD, at: VTOFFSET.BILLBOARD.p) }
  public static func add(LABEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LABEL, at: VTOFFSET.LABEL.p) }
  public static func add(POINT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINT, at: VTOFFSET.POINT.p) }
  public static func add(POLYLINE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYLINE, at: VTOFFSET.POLYLINE.p) }
  public static func add(POLYGON: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYGON, at: VTOFFSET.POLYGON.p) }
  public static func add(MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MODEL, at: VTOFFSET.MODEL.p) }
  public static func add(PATH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PATH, at: VTOFFSET.PATH.p) }
  public static func add(ELLIPSE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ELLIPSE, at: VTOFFSET.ELLIPSE.p) }
  public static func endCZMPacket(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZMPacket(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    NAMEOffset NAME: Offset = Offset(),
    PARENTOffset PARENT: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    AVAILABILITYOffset AVAILABILITY: Offset = Offset(),
    POSITION_CARTOGRAPHIC_DEGREESOffset POSITION_CARTOGRAPHIC_DEGREES: Offset = Offset(),
    POSITION_CARTESIANOffset POSITION_CARTESIAN: Offset = Offset(),
    POSITION_EPOCHOffset POSITION_EPOCH: Offset = Offset(),
    POSITION_CARTOGRAPHIC_DEGREES_ARRAYVectorOffset POSITION_CARTOGRAPHIC_DEGREES_ARRAY: Offset = Offset(),
    POSITION_CARTESIAN_ARRAYVectorOffset POSITION_CARTESIAN_ARRAY: Offset = Offset(),
    BILLBOARDOffset BILLBOARD: Offset = Offset(),
    LABELOffset LABEL: Offset = Offset(),
    POINTOffset POINT: Offset = Offset(),
    POLYLINEOffset POLYLINE: Offset = Offset(),
    POLYGONOffset POLYGON: Offset = Offset(),
    MODELOffset MODEL: Offset = Offset(),
    PATHOffset PATH: Offset = Offset(),
    ELLIPSEOffset ELLIPSE: Offset = Offset()
  ) -> Offset {
    let __start = CZMPacket.startCZMPacket(&fbb)
    CZMPacket.add(ID: ID, &fbb)
    CZMPacket.add(NAME: NAME, &fbb)
    CZMPacket.add(PARENT: PARENT, &fbb)
    CZMPacket.add(DESCRIPTION: DESCRIPTION, &fbb)
    CZMPacket.add(AVAILABILITY: AVAILABILITY, &fbb)
    CZMPacket.add(POSITION_CARTOGRAPHIC_DEGREES: POSITION_CARTOGRAPHIC_DEGREES, &fbb)
    CZMPacket.add(POSITION_CARTESIAN: POSITION_CARTESIAN, &fbb)
    CZMPacket.add(POSITION_EPOCH: POSITION_EPOCH, &fbb)
    CZMPacket.addVectorOf(POSITION_CARTOGRAPHIC_DEGREES_ARRAY: POSITION_CARTOGRAPHIC_DEGREES_ARRAY, &fbb)
    CZMPacket.addVectorOf(POSITION_CARTESIAN_ARRAY: POSITION_CARTESIAN_ARRAY, &fbb)
    CZMPacket.add(BILLBOARD: BILLBOARD, &fbb)
    CZMPacket.add(LABEL: LABEL, &fbb)
    CZMPacket.add(POINT: POINT, &fbb)
    CZMPacket.add(POLYLINE: POLYLINE, &fbb)
    CZMPacket.add(POLYGON: POLYGON, &fbb)
    CZMPacket.add(MODEL: MODEL, &fbb)
    CZMPacket.add(PATH: PATH, &fbb)
    CZMPacket.add(ELLIPSE: ELLIPSE, &fbb)
    return CZMPacket.endCZMPacket(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PARENT.p, fieldName: "PARENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AVAILABILITY.p, fieldName: "AVAILABILITY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES.p, fieldName: "POSITION_CARTOGRAPHIC_DEGREES", required: false, type: ForwardOffset<CZMCartographicDegrees>.self)
    try _v.visit(field: VTOFFSET.POSITION_CARTESIAN.p, fieldName: "POSITION_CARTESIAN", required: false, type: ForwardOffset<CZMCartesian>.self)
    try _v.visit(field: VTOFFSET.POSITION_EPOCH.p, fieldName: "POSITION_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.p, fieldName: "POSITION_CARTOGRAPHIC_DEGREES_ARRAY", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.POSITION_CARTESIAN_ARRAY.p, fieldName: "POSITION_CARTESIAN_ARRAY", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.BILLBOARD.p, fieldName: "BILLBOARD", required: false, type: ForwardOffset<CZMBillboard>.self)
    try _v.visit(field: VTOFFSET.LABEL.p, fieldName: "LABEL", required: false, type: ForwardOffset<CZMLabel>.self)
    try _v.visit(field: VTOFFSET.POINT.p, fieldName: "POINT", required: false, type: ForwardOffset<CZMPoint>.self)
    try _v.visit(field: VTOFFSET.POLYLINE.p, fieldName: "POLYLINE", required: false, type: ForwardOffset<CZMPolyline>.self)
    try _v.visit(field: VTOFFSET.POLYGON.p, fieldName: "POLYGON", required: false, type: ForwardOffset<CZMPolygon>.self)
    try _v.visit(field: VTOFFSET.MODEL.p, fieldName: "MODEL", required: false, type: ForwardOffset<CZMModel>.self)
    try _v.visit(field: VTOFFSET.PATH.p, fieldName: "PATH", required: false, type: ForwardOffset<CZMPath>.self)
    try _v.visit(field: VTOFFSET.ELLIPSE.p, fieldName: "ELLIPSE", required: false, type: ForwardOffset<CZMEllipse>.self)
    _v.finish()
  }
}

///  CZML Document
public struct CZM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$CZM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CZM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case VERSION = 6
    case CLOCK_CURRENT_TIME = 8
    case CLOCK_INTERVAL = 10
    case CLOCK_MULTIPLIER = 12
    case PACKETS = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Document-level name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Document-level version
  public var VERSION: String? { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VERSION.v) }
  ///  Clock settings - current time (ISO 8601)
  public var CLOCK_CURRENT_TIME: String? { let o = _accessor.offset(VTOFFSET.CLOCK_CURRENT_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLOCK_CURRENT_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLOCK_CURRENT_TIME.v) }
  ///  Clock settings - interval (ISO 8601 interval)
  public var CLOCK_INTERVAL: String? { let o = _accessor.offset(VTOFFSET.CLOCK_INTERVAL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLOCK_INTERVALSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLOCK_INTERVAL.v) }
  ///  Clock settings - multiplier
  public var CLOCK_MULTIPLIER: Double { let o = _accessor.offset(VTOFFSET.CLOCK_MULTIPLIER.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  All packets in the document
  public var hasPackets: Bool { let o = _accessor.offset(VTOFFSET.PACKETS.v); return o == 0 ? false : true }
  public var PACKETSCount: Int32 { let o = _accessor.offset(VTOFFSET.PACKETS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PACKETS(at index: Int32) -> CZMPacket? { let o = _accessor.offset(VTOFFSET.PACKETS.v); return o == 0 ? nil : CZMPacket(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startCZM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERSION, at: VTOFFSET.VERSION.p) }
  public static func add(CLOCK_CURRENT_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLOCK_CURRENT_TIME, at: VTOFFSET.CLOCK_CURRENT_TIME.p) }
  public static func add(CLOCK_INTERVAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLOCK_INTERVAL, at: VTOFFSET.CLOCK_INTERVAL.p) }
  public static func add(CLOCK_MULTIPLIER: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CLOCK_MULTIPLIER, def: 0.0, at: VTOFFSET.CLOCK_MULTIPLIER.p) }
  public static func addVectorOf(PACKETS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PACKETS, at: VTOFFSET.PACKETS.p) }
  public static func endCZM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCZM(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    VERSIONOffset VERSION: Offset = Offset(),
    CLOCK_CURRENT_TIMEOffset CLOCK_CURRENT_TIME: Offset = Offset(),
    CLOCK_INTERVALOffset CLOCK_INTERVAL: Offset = Offset(),
    CLOCK_MULTIPLIER: Double = 0.0,
    PACKETSVectorOffset PACKETS: Offset = Offset()
  ) -> Offset {
    let __start = CZM.startCZM(&fbb)
    CZM.add(NAME: NAME, &fbb)
    CZM.add(VERSION: VERSION, &fbb)
    CZM.add(CLOCK_CURRENT_TIME: CLOCK_CURRENT_TIME, &fbb)
    CZM.add(CLOCK_INTERVAL: CLOCK_INTERVAL, &fbb)
    CZM.add(CLOCK_MULTIPLIER: CLOCK_MULTIPLIER, &fbb)
    CZM.addVectorOf(PACKETS: PACKETS, &fbb)
    return CZM.endCZM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CLOCK_CURRENT_TIME.p, fieldName: "CLOCK_CURRENT_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CLOCK_INTERVAL.p, fieldName: "CLOCK_INTERVAL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CLOCK_MULTIPLIER.p, fieldName: "CLOCK_MULTIPLIER", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PACKETS.p, fieldName: "PACKETS", required: false, type: ForwardOffset<Vector<ForwardOffset<CZMPacket>, CZMPacket>>.self)
    _v.finish()
  }
}

