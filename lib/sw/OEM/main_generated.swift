// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  A single ephemeris data line
public struct ephemerisDataLine: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OEM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ephemerisDataLine.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case X = 6
    case Y = 8
    case Z = 10
    case X_DOT = 12
    case Y_DOT = 14
    case Z_DOT = 16
    case X_DDOT = 18
    case Y_DDOT = 20
    case Z_DDOT = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Epoch time, in ISO 8601 UTC format
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  ///  Position vector X-component km
  public var X: Double { let o = _accessor.offset(VTOFFSET.X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Position vector Y-component km
  public var Y: Double { let o = _accessor.offset(VTOFFSET.Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Position vector Z-component km
  public var Z: Double { let o = _accessor.offset(VTOFFSET.Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Velocity vector X-component km/s
  public var X_DOT: Double { let o = _accessor.offset(VTOFFSET.X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Velocity vector Y-component km/s
  public var Y_DOT: Double { let o = _accessor.offset(VTOFFSET.Y_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Velocity vector Z-component km/s
  public var Z_DOT: Double { let o = _accessor.offset(VTOFFSET.Z_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Optional: Acceleration vector X-component km/s/s
  public var X_DDOT: Double { let o = _accessor.offset(VTOFFSET.X_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Optional: Acceleration vector Y-component km/s/s
  public var Y_DDOT: Double { let o = _accessor.offset(VTOFFSET.Y_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Optional: Acceleration vector Z-component km/s/s
  public var Z_DDOT: Double { let o = _accessor.offset(VTOFFSET.Z_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startephemerisDataLine(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X, def: 0.0, at: VTOFFSET.X.p) }
  public static func add(Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y, def: 0.0, at: VTOFFSET.Y.p) }
  public static func add(Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z, def: 0.0, at: VTOFFSET.Z.p) }
  public static func add(X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X_DOT, def: 0.0, at: VTOFFSET.X_DOT.p) }
  public static func add(Y_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y_DOT, def: 0.0, at: VTOFFSET.Y_DOT.p) }
  public static func add(Z_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z_DOT, def: 0.0, at: VTOFFSET.Z_DOT.p) }
  public static func add(X_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X_DDOT, def: 0.0, at: VTOFFSET.X_DDOT.p) }
  public static func add(Y_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y_DDOT, def: 0.0, at: VTOFFSET.Y_DDOT.p) }
  public static func add(Z_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z_DDOT, def: 0.0, at: VTOFFSET.Z_DDOT.p) }
  public static func endephemerisDataLine(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createephemerisDataLine(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    X: Double = 0.0,
    Y: Double = 0.0,
    Z: Double = 0.0,
    X_DOT: Double = 0.0,
    Y_DOT: Double = 0.0,
    Z_DOT: Double = 0.0,
    X_DDOT: Double = 0.0,
    Y_DDOT: Double = 0.0,
    Z_DDOT: Double = 0.0
  ) -> Offset {
    let __start = ephemerisDataLine.startephemerisDataLine(&fbb)
    ephemerisDataLine.add(EPOCH: EPOCH, &fbb)
    ephemerisDataLine.add(X: X, &fbb)
    ephemerisDataLine.add(Y: Y, &fbb)
    ephemerisDataLine.add(Z: Z, &fbb)
    ephemerisDataLine.add(X_DOT: X_DOT, &fbb)
    ephemerisDataLine.add(Y_DOT: Y_DOT, &fbb)
    ephemerisDataLine.add(Z_DOT: Z_DOT, &fbb)
    ephemerisDataLine.add(X_DDOT: X_DDOT, &fbb)
    ephemerisDataLine.add(Y_DDOT: Y_DDOT, &fbb)
    ephemerisDataLine.add(Z_DDOT: Z_DDOT, &fbb)
    return ephemerisDataLine.endephemerisDataLine(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.X.p, fieldName: "X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y.p, fieldName: "Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z.p, fieldName: "Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.X_DOT.p, fieldName: "X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y_DOT.p, fieldName: "Y_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z_DOT.p, fieldName: "Z_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.X_DDOT.p, fieldName: "X_DDOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y_DDOT.p, fieldName: "Y_DDOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z_DDOT.p, fieldName: "Z_DDOT", required: false, type: Double.self)
    _v.finish()
  }
}

///  Position/Velocity Covariance Matrix Line
public struct covarianceMatrixLine: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OEM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: covarianceMatrixLine.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case COV_REFERENCE_FRAME = 6
    case CX_X = 8
    case CY_X = 10
    case CY_Y = 12
    case CZ_X = 14
    case CZ_Y = 16
    case CZ_Z = 18
    case CX_DOT_X = 20
    case CX_DOT_Y = 22
    case CX_DOT_Z = 24
    case CX_DOT_X_DOT = 26
    case CY_DOT_X = 28
    case CY_DOT_Y = 30
    case CY_DOT_Z = 32
    case CY_DOT_X_DOT = 34
    case CY_DOT_Y_DOT = 36
    case CZ_DOT_X = 38
    case CZ_DOT_Y = 40
    case CZ_DOT_Z = 42
    case CZ_DOT_X_DOT = 44
    case CZ_DOT_Y_DOT = 46
    case CZ_DOT_Z_DOT = 48
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Epoch
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  ///  Reference frame for the covariance matrix
  public var COV_REFERENCE_FRAME: refFrame { let o = _accessor.offset(VTOFFSET.COV_REFERENCE_FRAME.v); return o == 0 ? .ecef : refFrame(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ecef }
  ///  Covariance matrix [1,1] km**2
  public var CX_X: Double { let o = _accessor.offset(VTOFFSET.CX_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [2,1] km**2
  public var CY_X: Double { let o = _accessor.offset(VTOFFSET.CY_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [2,2] km**2
  public var CY_Y: Double { let o = _accessor.offset(VTOFFSET.CY_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [3,1] km**2
  public var CZ_X: Double { let o = _accessor.offset(VTOFFSET.CZ_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [3,2] km**2
  public var CZ_Y: Double { let o = _accessor.offset(VTOFFSET.CZ_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [3,3] km**2
  public var CZ_Z: Double { let o = _accessor.offset(VTOFFSET.CZ_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [4,1] km**2/s
  public var CX_DOT_X: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [4,2] km**2/s
  public var CX_DOT_Y: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [4,3] km**2/s
  public var CX_DOT_Z: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [4,4] km**2/s**2
  public var CX_DOT_X_DOT: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [5,1] km**2/s
  public var CY_DOT_X: Double { let o = _accessor.offset(VTOFFSET.CY_DOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [5,2] km**2/s
  public var CY_DOT_Y: Double { let o = _accessor.offset(VTOFFSET.CY_DOT_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [5,3] km**2/s
  public var CY_DOT_Z: Double { let o = _accessor.offset(VTOFFSET.CY_DOT_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [5,4] km**2/s**2
  public var CY_DOT_X_DOT: Double { let o = _accessor.offset(VTOFFSET.CY_DOT_X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [5,5] km**2/s**2
  public var CY_DOT_Y_DOT: Double { let o = _accessor.offset(VTOFFSET.CY_DOT_Y_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,1] km**2/s
  public var CZ_DOT_X: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,2] km**2/s
  public var CZ_DOT_Y: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,3] km**2/s
  public var CZ_DOT_Z: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,4] km**2/s**2
  public var CZ_DOT_X_DOT: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,5] km**2/s**2
  public var CZ_DOT_Y_DOT: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_Y_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Covariance matrix [6,6] km**2/s**2
  public var CZ_DOT_Z_DOT: Double { let o = _accessor.offset(VTOFFSET.CZ_DOT_Z_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startcovarianceMatrixLine(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 23) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(COV_REFERENCE_FRAME: refFrame, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COV_REFERENCE_FRAME.rawValue, def: 0, at: VTOFFSET.COV_REFERENCE_FRAME.p) }
  public static func add(CX_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_X, def: 0.0, at: VTOFFSET.CX_X.p) }
  public static func add(CY_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_X, def: 0.0, at: VTOFFSET.CY_X.p) }
  public static func add(CY_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_Y, def: 0.0, at: VTOFFSET.CY_Y.p) }
  public static func add(CZ_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_X, def: 0.0, at: VTOFFSET.CZ_X.p) }
  public static func add(CZ_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_Y, def: 0.0, at: VTOFFSET.CZ_Y.p) }
  public static func add(CZ_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_Z, def: 0.0, at: VTOFFSET.CZ_Z.p) }
  public static func add(CX_DOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_X, def: 0.0, at: VTOFFSET.CX_DOT_X.p) }
  public static func add(CX_DOT_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_Y, def: 0.0, at: VTOFFSET.CX_DOT_Y.p) }
  public static func add(CX_DOT_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_Z, def: 0.0, at: VTOFFSET.CX_DOT_Z.p) }
  public static func add(CX_DOT_X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_X_DOT, def: 0.0, at: VTOFFSET.CX_DOT_X_DOT.p) }
  public static func add(CY_DOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_DOT_X, def: 0.0, at: VTOFFSET.CY_DOT_X.p) }
  public static func add(CY_DOT_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_DOT_Y, def: 0.0, at: VTOFFSET.CY_DOT_Y.p) }
  public static func add(CY_DOT_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_DOT_Z, def: 0.0, at: VTOFFSET.CY_DOT_Z.p) }
  public static func add(CY_DOT_X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_DOT_X_DOT, def: 0.0, at: VTOFFSET.CY_DOT_X_DOT.p) }
  public static func add(CY_DOT_Y_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_DOT_Y_DOT, def: 0.0, at: VTOFFSET.CY_DOT_Y_DOT.p) }
  public static func add(CZ_DOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_X, def: 0.0, at: VTOFFSET.CZ_DOT_X.p) }
  public static func add(CZ_DOT_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_Y, def: 0.0, at: VTOFFSET.CZ_DOT_Y.p) }
  public static func add(CZ_DOT_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_Z, def: 0.0, at: VTOFFSET.CZ_DOT_Z.p) }
  public static func add(CZ_DOT_X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_X_DOT, def: 0.0, at: VTOFFSET.CZ_DOT_X_DOT.p) }
  public static func add(CZ_DOT_Y_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_Y_DOT, def: 0.0, at: VTOFFSET.CZ_DOT_Y_DOT.p) }
  public static func add(CZ_DOT_Z_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_DOT_Z_DOT, def: 0.0, at: VTOFFSET.CZ_DOT_Z_DOT.p) }
  public static func endcovarianceMatrixLine(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createcovarianceMatrixLine(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    COV_REFERENCE_FRAME: refFrame = .ecef,
    CX_X: Double = 0.0,
    CY_X: Double = 0.0,
    CY_Y: Double = 0.0,
    CZ_X: Double = 0.0,
    CZ_Y: Double = 0.0,
    CZ_Z: Double = 0.0,
    CX_DOT_X: Double = 0.0,
    CX_DOT_Y: Double = 0.0,
    CX_DOT_Z: Double = 0.0,
    CX_DOT_X_DOT: Double = 0.0,
    CY_DOT_X: Double = 0.0,
    CY_DOT_Y: Double = 0.0,
    CY_DOT_Z: Double = 0.0,
    CY_DOT_X_DOT: Double = 0.0,
    CY_DOT_Y_DOT: Double = 0.0,
    CZ_DOT_X: Double = 0.0,
    CZ_DOT_Y: Double = 0.0,
    CZ_DOT_Z: Double = 0.0,
    CZ_DOT_X_DOT: Double = 0.0,
    CZ_DOT_Y_DOT: Double = 0.0,
    CZ_DOT_Z_DOT: Double = 0.0
  ) -> Offset {
    let __start = covarianceMatrixLine.startcovarianceMatrixLine(&fbb)
    covarianceMatrixLine.add(EPOCH: EPOCH, &fbb)
    covarianceMatrixLine.add(COV_REFERENCE_FRAME: COV_REFERENCE_FRAME, &fbb)
    covarianceMatrixLine.add(CX_X: CX_X, &fbb)
    covarianceMatrixLine.add(CY_X: CY_X, &fbb)
    covarianceMatrixLine.add(CY_Y: CY_Y, &fbb)
    covarianceMatrixLine.add(CZ_X: CZ_X, &fbb)
    covarianceMatrixLine.add(CZ_Y: CZ_Y, &fbb)
    covarianceMatrixLine.add(CZ_Z: CZ_Z, &fbb)
    covarianceMatrixLine.add(CX_DOT_X: CX_DOT_X, &fbb)
    covarianceMatrixLine.add(CX_DOT_Y: CX_DOT_Y, &fbb)
    covarianceMatrixLine.add(CX_DOT_Z: CX_DOT_Z, &fbb)
    covarianceMatrixLine.add(CX_DOT_X_DOT: CX_DOT_X_DOT, &fbb)
    covarianceMatrixLine.add(CY_DOT_X: CY_DOT_X, &fbb)
    covarianceMatrixLine.add(CY_DOT_Y: CY_DOT_Y, &fbb)
    covarianceMatrixLine.add(CY_DOT_Z: CY_DOT_Z, &fbb)
    covarianceMatrixLine.add(CY_DOT_X_DOT: CY_DOT_X_DOT, &fbb)
    covarianceMatrixLine.add(CY_DOT_Y_DOT: CY_DOT_Y_DOT, &fbb)
    covarianceMatrixLine.add(CZ_DOT_X: CZ_DOT_X, &fbb)
    covarianceMatrixLine.add(CZ_DOT_Y: CZ_DOT_Y, &fbb)
    covarianceMatrixLine.add(CZ_DOT_Z: CZ_DOT_Z, &fbb)
    covarianceMatrixLine.add(CZ_DOT_X_DOT: CZ_DOT_X_DOT, &fbb)
    covarianceMatrixLine.add(CZ_DOT_Y_DOT: CZ_DOT_Y_DOT, &fbb)
    covarianceMatrixLine.add(CZ_DOT_Z_DOT: CZ_DOT_Z_DOT, &fbb)
    return covarianceMatrixLine.endcovarianceMatrixLine(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COV_REFERENCE_FRAME.p, fieldName: "COV_REFERENCE_FRAME", required: false, type: refFrame.self)
    try _v.visit(field: VTOFFSET.CX_X.p, fieldName: "CX_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_X.p, fieldName: "CY_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_Y.p, fieldName: "CY_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_X.p, fieldName: "CZ_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_Y.p, fieldName: "CZ_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_Z.p, fieldName: "CZ_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_X.p, fieldName: "CX_DOT_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_Y.p, fieldName: "CX_DOT_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_Z.p, fieldName: "CX_DOT_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_X_DOT.p, fieldName: "CX_DOT_X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_DOT_X.p, fieldName: "CY_DOT_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_DOT_Y.p, fieldName: "CY_DOT_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_DOT_Z.p, fieldName: "CY_DOT_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_DOT_X_DOT.p, fieldName: "CY_DOT_X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_DOT_Y_DOT.p, fieldName: "CY_DOT_Y_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_X.p, fieldName: "CZ_DOT_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_Y.p, fieldName: "CZ_DOT_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_Z.p, fieldName: "CZ_DOT_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_X_DOT.p, fieldName: "CZ_DOT_X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_Y_DOT.p, fieldName: "CZ_DOT_Y_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_DOT_Z_DOT.p, fieldName: "CZ_DOT_Z_DOT", required: false, type: Double.self)
    _v.finish()
  }
}

///  OEM Ephemeris Data Block
public struct ephemerisDataBlock: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OEM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ephemerisDataBlock.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMENT = 4
    case OBJECT_NAME = 6
    case OBJECT_ID = 8
    case CENTER_NAME = 10
    case REFERENCE_FRAME = 12
    case REFERENCE_FRAME_EPOCH = 14
    case TIME_SYSTEM = 16
    case START_TIME = 18
    case USEABLE_START_TIME = 20
    case USEABLE_STOP_TIME = 22
    case STOP_TIME = 24
    case INTERPOLATION = 26
    case INTERPOLATION_DEGREE = 28
    case EPHEMERIS_DATA_LINES = 30
    case COVARIANCE_MATRIX_LINES = 32
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Plain-Text Comment
  public var COMMENT: String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMENT.v) }
  ///  Satellite Name(s)
  public var OBJECT_NAME: String? { let o = _accessor.offset(VTOFFSET.OBJECT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_NAME.v) }
  ///  International Designator (YYYY-NNNAAA)
  public var OBJECT_ID: String? { let o = _accessor.offset(VTOFFSET.OBJECT_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_ID.v) }
  ///  Origin of reference frame (EARTH, MARS, MOON, etc.)
  public var CENTER_NAME: String? { let o = _accessor.offset(VTOFFSET.CENTER_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CENTER_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CENTER_NAME.v) }
  ///  Name of the reference frame (TEME, EME2000, etc.)
  public var REFERENCE_FRAME: refFrame { let o = _accessor.offset(VTOFFSET.REFERENCE_FRAME.v); return o == 0 ? .ecef : refFrame(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ecef }
  ///  Epoch of reference frame, if not intrinsic to the definition of the reference frame
  public var REFERENCE_FRAME_EPOCH: String? { let o = _accessor.offset(VTOFFSET.REFERENCE_FRAME_EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var REFERENCE_FRAME_EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.REFERENCE_FRAME_EPOCH.v) }
  ///  Time system used for the orbit state and covariance matrix. (UTC)
  public var TIME_SYSTEM: timeSystem { let o = _accessor.offset(VTOFFSET.TIME_SYSTEM.v); return o == 0 ? .gmst : timeSystem(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .gmst }
  ///  Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  public var START_TIME: String? { let o = _accessor.offset(VTOFFSET.START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.START_TIME.v) }
  ///  Optional start USEABLE time span covered by ephemeris data (ISO 8601)
  public var USEABLE_START_TIME: String? { let o = _accessor.offset(VTOFFSET.USEABLE_START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var USEABLE_START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.USEABLE_START_TIME.v) }
  ///  Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
  public var USEABLE_STOP_TIME: String? { let o = _accessor.offset(VTOFFSET.USEABLE_STOP_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var USEABLE_STOP_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.USEABLE_STOP_TIME.v) }
  ///  End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  public var STOP_TIME: String? { let o = _accessor.offset(VTOFFSET.STOP_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STOP_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STOP_TIME.v) }
  ///  Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
  public var INTERPOLATION: String? { let o = _accessor.offset(VTOFFSET.INTERPOLATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INTERPOLATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INTERPOLATION.v) }
  ///  Recommended interpolation degree for ephemeris data
  public var INTERPOLATION_DEGREE: UInt32 { let o = _accessor.offset(VTOFFSET.INTERPOLATION_DEGREE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Array of ephemeris data lines
  public var hasEphemerisDataLines: Bool { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_LINES.v); return o == 0 ? false : true }
  public var EPHEMERIS_DATA_LINESCount: Int32 { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_LINES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func EPHEMERIS_DATA_LINES(at index: Int32) -> ephemerisDataLine? { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_LINES.v); return o == 0 ? nil : ephemerisDataLine(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Array of covariance matrix lines
  public var hasCovarianceMatrixLines: Bool { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX_LINES.v); return o == 0 ? false : true }
  public var COVARIANCE_MATRIX_LINESCount: Int32 { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX_LINES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COVARIANCE_MATRIX_LINES(at index: Int32) -> covarianceMatrixLine? { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX_LINES.v); return o == 0 ? nil : covarianceMatrixLine(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startephemerisDataBlock(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 15) }
  public static func add(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(OBJECT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_NAME, at: VTOFFSET.OBJECT_NAME.p) }
  public static func add(OBJECT_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_ID, at: VTOFFSET.OBJECT_ID.p) }
  public static func add(CENTER_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CENTER_NAME, at: VTOFFSET.CENTER_NAME.p) }
  public static func add(REFERENCE_FRAME: refFrame, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REFERENCE_FRAME.rawValue, def: 0, at: VTOFFSET.REFERENCE_FRAME.p) }
  public static func add(REFERENCE_FRAME_EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REFERENCE_FRAME_EPOCH, at: VTOFFSET.REFERENCE_FRAME_EPOCH.p) }
  public static func add(TIME_SYSTEM: timeSystem, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_SYSTEM.rawValue, def: 0, at: VTOFFSET.TIME_SYSTEM.p) }
  public static func add(START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: START_TIME, at: VTOFFSET.START_TIME.p) }
  public static func add(USEABLE_START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: USEABLE_START_TIME, at: VTOFFSET.USEABLE_START_TIME.p) }
  public static func add(USEABLE_STOP_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: USEABLE_STOP_TIME, at: VTOFFSET.USEABLE_STOP_TIME.p) }
  public static func add(STOP_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STOP_TIME, at: VTOFFSET.STOP_TIME.p) }
  public static func add(INTERPOLATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTERPOLATION, at: VTOFFSET.INTERPOLATION.p) }
  public static func add(INTERPOLATION_DEGREE: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INTERPOLATION_DEGREE, def: 0, at: VTOFFSET.INTERPOLATION_DEGREE.p) }
  public static func addVectorOf(EPHEMERIS_DATA_LINES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPHEMERIS_DATA_LINES, at: VTOFFSET.EPHEMERIS_DATA_LINES.p) }
  public static func addVectorOf(COVARIANCE_MATRIX_LINES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COVARIANCE_MATRIX_LINES, at: VTOFFSET.COVARIANCE_MATRIX_LINES.p) }
  public static func endephemerisDataBlock(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createephemerisDataBlock(
    _ fbb: inout FlatBufferBuilder,
    COMMENTOffset COMMENT: Offset = Offset(),
    OBJECT_NAMEOffset OBJECT_NAME: Offset = Offset(),
    OBJECT_IDOffset OBJECT_ID: Offset = Offset(),
    CENTER_NAMEOffset CENTER_NAME: Offset = Offset(),
    REFERENCE_FRAME: refFrame = .ecef,
    REFERENCE_FRAME_EPOCHOffset REFERENCE_FRAME_EPOCH: Offset = Offset(),
    TIME_SYSTEM: timeSystem = .gmst,
    START_TIMEOffset START_TIME: Offset = Offset(),
    USEABLE_START_TIMEOffset USEABLE_START_TIME: Offset = Offset(),
    USEABLE_STOP_TIMEOffset USEABLE_STOP_TIME: Offset = Offset(),
    STOP_TIMEOffset STOP_TIME: Offset = Offset(),
    INTERPOLATIONOffset INTERPOLATION: Offset = Offset(),
    INTERPOLATION_DEGREE: UInt32 = 0,
    EPHEMERIS_DATA_LINESVectorOffset EPHEMERIS_DATA_LINES: Offset = Offset(),
    COVARIANCE_MATRIX_LINESVectorOffset COVARIANCE_MATRIX_LINES: Offset = Offset()
  ) -> Offset {
    let __start = ephemerisDataBlock.startephemerisDataBlock(&fbb)
    ephemerisDataBlock.add(COMMENT: COMMENT, &fbb)
    ephemerisDataBlock.add(OBJECT_NAME: OBJECT_NAME, &fbb)
    ephemerisDataBlock.add(OBJECT_ID: OBJECT_ID, &fbb)
    ephemerisDataBlock.add(CENTER_NAME: CENTER_NAME, &fbb)
    ephemerisDataBlock.add(REFERENCE_FRAME: REFERENCE_FRAME, &fbb)
    ephemerisDataBlock.add(REFERENCE_FRAME_EPOCH: REFERENCE_FRAME_EPOCH, &fbb)
    ephemerisDataBlock.add(TIME_SYSTEM: TIME_SYSTEM, &fbb)
    ephemerisDataBlock.add(START_TIME: START_TIME, &fbb)
    ephemerisDataBlock.add(USEABLE_START_TIME: USEABLE_START_TIME, &fbb)
    ephemerisDataBlock.add(USEABLE_STOP_TIME: USEABLE_STOP_TIME, &fbb)
    ephemerisDataBlock.add(STOP_TIME: STOP_TIME, &fbb)
    ephemerisDataBlock.add(INTERPOLATION: INTERPOLATION, &fbb)
    ephemerisDataBlock.add(INTERPOLATION_DEGREE: INTERPOLATION_DEGREE, &fbb)
    ephemerisDataBlock.addVectorOf(EPHEMERIS_DATA_LINES: EPHEMERIS_DATA_LINES, &fbb)
    ephemerisDataBlock.addVectorOf(COVARIANCE_MATRIX_LINES: COVARIANCE_MATRIX_LINES, &fbb)
    return ephemerisDataBlock.endephemerisDataBlock(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_NAME.p, fieldName: "OBJECT_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_ID.p, fieldName: "OBJECT_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CENTER_NAME.p, fieldName: "CENTER_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REFERENCE_FRAME.p, fieldName: "REFERENCE_FRAME", required: false, type: refFrame.self)
    try _v.visit(field: VTOFFSET.REFERENCE_FRAME_EPOCH.p, fieldName: "REFERENCE_FRAME_EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_SYSTEM.p, fieldName: "TIME_SYSTEM", required: false, type: timeSystem.self)
    try _v.visit(field: VTOFFSET.START_TIME.p, fieldName: "START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.USEABLE_START_TIME.p, fieldName: "USEABLE_START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.USEABLE_STOP_TIME.p, fieldName: "USEABLE_STOP_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STOP_TIME.p, fieldName: "STOP_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTERPOLATION.p, fieldName: "INTERPOLATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTERPOLATION_DEGREE.p, fieldName: "INTERPOLATION_DEGREE", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.EPHEMERIS_DATA_LINES.p, fieldName: "EPHEMERIS_DATA_LINES", required: false, type: ForwardOffset<Vector<ForwardOffset<ephemerisDataLine>, ephemerisDataLine>>.self)
    try _v.visit(field: VTOFFSET.COVARIANCE_MATRIX_LINES.p, fieldName: "COVARIANCE_MATRIX_LINES", required: false, type: ForwardOffset<Vector<ForwardOffset<covarianceMatrixLine>, covarianceMatrixLine>>.self)
    _v.finish()
  }
}

///  Orbit Ephemeris Message
public struct OEM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OEM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: OEM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CCSDS_OEM_VERS = 4
    case CREATION_DATE = 6
    case ORIGINATOR = 8
    case EPHEMERIS_DATA_BLOCK = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  OEM Header
  ///  OEM Version
  public var CCSDS_OEM_VERS: Double { let o = _accessor.offset(VTOFFSET.CCSDS_OEM_VERS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Creation Date
  public var CREATION_DATE: String? { let o = _accessor.offset(VTOFFSET.CREATION_DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CREATION_DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CREATION_DATE.v) }
  ///  Originator
  public var ORIGINATOR: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR.v) }
  ///  Array of ephemeris data blocks
  public var hasEphemerisDataBlock: Bool { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_BLOCK.v); return o == 0 ? false : true }
  public var EPHEMERIS_DATA_BLOCKCount: Int32 { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_BLOCK.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func EPHEMERIS_DATA_BLOCK(at index: Int32) -> ephemerisDataBlock? { let o = _accessor.offset(VTOFFSET.EPHEMERIS_DATA_BLOCK.v); return o == 0 ? nil : ephemerisDataBlock(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startOEM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(CCSDS_OEM_VERS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CCSDS_OEM_VERS, def: 0.0, at: VTOFFSET.CCSDS_OEM_VERS.p) }
  public static func add(CREATION_DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CREATION_DATE, at: VTOFFSET.CREATION_DATE.p) }
  public static func add(ORIGINATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR, at: VTOFFSET.ORIGINATOR.p) }
  public static func addVectorOf(EPHEMERIS_DATA_BLOCK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPHEMERIS_DATA_BLOCK, at: VTOFFSET.EPHEMERIS_DATA_BLOCK.p) }
  public static func endOEM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOEM(
    _ fbb: inout FlatBufferBuilder,
    CCSDS_OEM_VERS: Double = 0.0,
    CREATION_DATEOffset CREATION_DATE: Offset = Offset(),
    ORIGINATOROffset ORIGINATOR: Offset = Offset(),
    EPHEMERIS_DATA_BLOCKVectorOffset EPHEMERIS_DATA_BLOCK: Offset = Offset()
  ) -> Offset {
    let __start = OEM.startOEM(&fbb)
    OEM.add(CCSDS_OEM_VERS: CCSDS_OEM_VERS, &fbb)
    OEM.add(CREATION_DATE: CREATION_DATE, &fbb)
    OEM.add(ORIGINATOR: ORIGINATOR, &fbb)
    OEM.addVectorOf(EPHEMERIS_DATA_BLOCK: EPHEMERIS_DATA_BLOCK, &fbb)
    return OEM.endOEM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CCSDS_OEM_VERS.p, fieldName: "CCSDS_OEM_VERS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CREATION_DATE.p, fieldName: "CREATION_DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR.p, fieldName: "ORIGINATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EPHEMERIS_DATA_BLOCK.p, fieldName: "EPHEMERIS_DATA_BLOCK", required: false, type: ForwardOffset<Vector<ForwardOffset<ephemerisDataBlock>, ephemerisDataBlock>>.self)
    _v.finish()
  }
}

///  Collection of OEM messages
public struct OEMCOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$OEM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: OEMCOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> OEM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : OEM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startOEMCOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endOEMCOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOEMCOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = OEMCOLLECTION.startOEMCOLLECTION(&fbb)
    OEMCOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return OEMCOLLECTION.endOEMCOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<OEM>, OEM>>.self)
    _v.finish()
  }
}

