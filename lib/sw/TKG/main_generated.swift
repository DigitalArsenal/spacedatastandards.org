// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum FilterType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case alphaBeta = 0
  case alphaBetaGamma = 1
  case kalman = 2
  case extendedKalman = 3
  case unscentedKalman = 4
  case particle = 5
  case imm = 6
  case jpda = 7
  case mht = 8
  case gnn = 9
  case nnkf = 10

  public static var max: FilterType { return .nnkf }
  public static var min: FilterType { return .alphaBeta }
}


public enum MotionModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case constantVelocity = 0
  case constantAcceleration = 1
  case coordinatedTurn = 2
  case singerAcceleration = 3
  case jumpMarkov = 4
  case ballistic = 5
  case orbital = 6
  case surfaceVehicle = 7
  case curvilinear = 8

  public static var max: MotionModel { return .curvilinear }
  public static var min: MotionModel { return .constantVelocity }
}


public enum MeasurementType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case position3d = 0
  case position2d = 1
  case rangeBearing = 2
  case rangeBearingElevation = 3
  case rangeOnly = 4
  case bearingOnly = 5
  case rangeRate = 6
  case anglesOnly = 7
  case tle = 8
  case gps = 9
  case radar = 10
  case adsb = 11
  case sonar = 12

  public static var max: MeasurementType { return .sonar }
  public static var min: MeasurementType { return .position3d }
}


public enum TrackStatus: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case tentative = 0
  case confirmed = 1
  case coasting = 2
  case lost = 3
  case deleted = 4

  public static var max: TrackStatus { return .deleted }
  public static var min: TrackStatus { return .tentative }
}


public enum AssociationMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case nearestNeighbor = 0
  case globalNearestNeighbor = 1
  case probabilisticData = 2
  case jointProbabilistic = 3
  case auction = 4
  case hungarian = 5
  case munkres = 6

  public static var max: AssociationMethod { return .munkres }
  public static var min: AssociationMethod { return .nearestNeighbor }
}


public enum FusionMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case simpleAverage = 0
  case weightedAverage = 1
  case covarianceIntersection = 2
  case barShalomCampo = 3
  case federated = 4
  case sequential = 5

  public static var max: FusionMethod { return .sequential }
  public static var min: FusionMethod { return .simpleAverage }
}


///  Tracking and Data Fusion
public struct TKG: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$TKG" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TKG.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMAND = 4
    case FILTER_CONFIG = 6
    case IMM_CONFIG = 8
    case MHT_CONFIG = 10
    case JPDA_CONFIG = 12
    case FUSION_CONFIG = 14
    case MEASUREMENTS = 16
    case INITIAL_STATE = 18
    case TRACK_TO_UPDATE = 20
    case TRACKS_TO_CORRELATE = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var COMMAND: String? { let o = _accessor.offset(VTOFFSET.COMMAND.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMANDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMAND.v) }
  public var FILTER_CONFIG: String? { let o = _accessor.offset(VTOFFSET.FILTER_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FILTER_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FILTER_CONFIG.v) }
  public var IMM_CONFIG: String? { let o = _accessor.offset(VTOFFSET.IMM_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IMM_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IMM_CONFIG.v) }
  public var MHT_CONFIG: String? { let o = _accessor.offset(VTOFFSET.MHT_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MHT_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MHT_CONFIG.v) }
  public var JPDA_CONFIG: String? { let o = _accessor.offset(VTOFFSET.JPDA_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var JPDA_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.JPDA_CONFIG.v) }
  public var FUSION_CONFIG: String? { let o = _accessor.offset(VTOFFSET.FUSION_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FUSION_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FUSION_CONFIG.v) }
  public var MEASUREMENTS: String? { let o = _accessor.offset(VTOFFSET.MEASUREMENTS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MEASUREMENTSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MEASUREMENTS.v) }
  public var INITIAL_STATE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_STATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_STATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_STATE.v) }
  public var TRACK_TO_UPDATE: String? { let o = _accessor.offset(VTOFFSET.TRACK_TO_UPDATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRACK_TO_UPDATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRACK_TO_UPDATE.v) }
  public var hasTracksToCorrelate: Bool { let o = _accessor.offset(VTOFFSET.TRACKS_TO_CORRELATE.v); return o == 0 ? false : true }
  public var TRACKS_TO_CORRELATECount: Int32 { let o = _accessor.offset(VTOFFSET.TRACKS_TO_CORRELATE.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TRACKS_TO_CORRELATE(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.TRACKS_TO_CORRELATE.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startTKG(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(COMMAND: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND, at: VTOFFSET.COMMAND.p) }
  public static func add(FILTER_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FILTER_CONFIG, at: VTOFFSET.FILTER_CONFIG.p) }
  public static func add(IMM_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IMM_CONFIG, at: VTOFFSET.IMM_CONFIG.p) }
  public static func add(MHT_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MHT_CONFIG, at: VTOFFSET.MHT_CONFIG.p) }
  public static func add(JPDA_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: JPDA_CONFIG, at: VTOFFSET.JPDA_CONFIG.p) }
  public static func add(FUSION_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FUSION_CONFIG, at: VTOFFSET.FUSION_CONFIG.p) }
  public static func add(MEASUREMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MEASUREMENTS, at: VTOFFSET.MEASUREMENTS.p) }
  public static func add(INITIAL_STATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_STATE, at: VTOFFSET.INITIAL_STATE.p) }
  public static func add(TRACK_TO_UPDATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRACK_TO_UPDATE, at: VTOFFSET.TRACK_TO_UPDATE.p) }
  public static func addVectorOf(TRACKS_TO_CORRELATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRACKS_TO_CORRELATE, at: VTOFFSET.TRACKS_TO_CORRELATE.p) }
  public static func endTKG(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTKG(
    _ fbb: inout FlatBufferBuilder,
    COMMANDOffset COMMAND: Offset = Offset(),
    FILTER_CONFIGOffset FILTER_CONFIG: Offset = Offset(),
    IMM_CONFIGOffset IMM_CONFIG: Offset = Offset(),
    MHT_CONFIGOffset MHT_CONFIG: Offset = Offset(),
    JPDA_CONFIGOffset JPDA_CONFIG: Offset = Offset(),
    FUSION_CONFIGOffset FUSION_CONFIG: Offset = Offset(),
    MEASUREMENTSOffset MEASUREMENTS: Offset = Offset(),
    INITIAL_STATEOffset INITIAL_STATE: Offset = Offset(),
    TRACK_TO_UPDATEOffset TRACK_TO_UPDATE: Offset = Offset(),
    TRACKS_TO_CORRELATEVectorOffset TRACKS_TO_CORRELATE: Offset = Offset()
  ) -> Offset {
    let __start = TKG.startTKG(&fbb)
    TKG.add(COMMAND: COMMAND, &fbb)
    TKG.add(FILTER_CONFIG: FILTER_CONFIG, &fbb)
    TKG.add(IMM_CONFIG: IMM_CONFIG, &fbb)
    TKG.add(MHT_CONFIG: MHT_CONFIG, &fbb)
    TKG.add(JPDA_CONFIG: JPDA_CONFIG, &fbb)
    TKG.add(FUSION_CONFIG: FUSION_CONFIG, &fbb)
    TKG.add(MEASUREMENTS: MEASUREMENTS, &fbb)
    TKG.add(INITIAL_STATE: INITIAL_STATE, &fbb)
    TKG.add(TRACK_TO_UPDATE: TRACK_TO_UPDATE, &fbb)
    TKG.addVectorOf(TRACKS_TO_CORRELATE: TRACKS_TO_CORRELATE, &fbb)
    return TKG.endTKG(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMAND.p, fieldName: "COMMAND", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FILTER_CONFIG.p, fieldName: "FILTER_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.IMM_CONFIG.p, fieldName: "IMM_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MHT_CONFIG.p, fieldName: "MHT_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.JPDA_CONFIG.p, fieldName: "JPDA_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FUSION_CONFIG.p, fieldName: "FUSION_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MEASUREMENTS.p, fieldName: "MEASUREMENTS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_STATE.p, fieldName: "INITIAL_STATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRACK_TO_UPDATE.p, fieldName: "TRACK_TO_UPDATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRACKS_TO_CORRELATE.p, fieldName: "TRACKS_TO_CORRELATE", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

