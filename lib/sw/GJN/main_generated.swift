// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum GJNGeometryType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case point = 0
  case multiPoint = 1
  case lineString = 2
  case multiLineString = 3
  case polygon = 4
  case multiPolygon = 5
  case geometryCollection = 6

  public static var max: GJNGeometryType { return .geometryCollection }
  public static var min: GJNGeometryType { return .point }
}


///  A single position (longitude, latitude, optional altitude)
public struct GJNPosition: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNPosition.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LONGITUDE = 4
    case LATITUDE = 6
    case ALTITUDE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Longitude in decimal degrees (WGS84)
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Latitude in decimal degrees (WGS84)
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude in meters above WGS84 ellipsoid (optional)
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startGJNPosition(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func endGJNPosition(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNPosition(
    _ fbb: inout FlatBufferBuilder,
    LONGITUDE: Double = 0.0,
    LATITUDE: Double = 0.0,
    ALTITUDE: Double = 0.0
  ) -> Offset {
    let __start = GJNPosition.startGJNPosition(&fbb)
    GJNPosition.add(LONGITUDE: LONGITUDE, &fbb)
    GJNPosition.add(LATITUDE: LATITUDE, &fbb)
    GJNPosition.add(ALTITUDE: ALTITUDE, &fbb)
    return GJNPosition.endGJNPosition(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    _v.finish()
  }
}

///  A linear ring is a closed LineString with 4+ positions (first = last)
public struct GJNLinearRing: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNLinearRing.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case POSITIONS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Ordered positions forming the ring
  public var hasPositions: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? false : true }
  public var POSITIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS(at index: Int32) -> GJNPosition? { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? nil : GJNPosition(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGJNLinearRing(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(POSITIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS, at: VTOFFSET.POSITIONS.p) }
  public static func endGJNLinearRing(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNLinearRing(
    _ fbb: inout FlatBufferBuilder,
    POSITIONSVectorOffset POSITIONS: Offset = Offset()
  ) -> Offset {
    let __start = GJNLinearRing.startGJNLinearRing(&fbb)
    GJNLinearRing.addVectorOf(POSITIONS: POSITIONS, &fbb)
    return GJNLinearRing.endGJNLinearRing(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.POSITIONS.p, fieldName: "POSITIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNPosition>, GJNPosition>>.self)
    _v.finish()
  }
}

///  A polygon represented as an array of rings (outer boundary + holes)
public struct GJNPolygonRings: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNPolygonRings.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RINGS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Rings: first is outer boundary, rest are holes
  public var hasRings: Bool { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? false : true }
  public var RINGSCount: Int32 { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RINGS(at index: Int32) -> GJNLinearRing? { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? nil : GJNLinearRing(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGJNPolygonRings(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RINGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RINGS, at: VTOFFSET.RINGS.p) }
  public static func endGJNPolygonRings(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNPolygonRings(
    _ fbb: inout FlatBufferBuilder,
    RINGSVectorOffset RINGS: Offset = Offset()
  ) -> Offset {
    let __start = GJNPolygonRings.startGJNPolygonRings(&fbb)
    GJNPolygonRings.addVectorOf(RINGS: RINGS, &fbb)
    return GJNPolygonRings.endGJNPolygonRings(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RINGS.p, fieldName: "RINGS", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNLinearRing>, GJNLinearRing>>.self)
    _v.finish()
  }
}

///  GeoJSON Geometry object
public struct GJNGeometry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNGeometry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case TYPE = 4
    case POINT = 6
    case POSITIONS = 8
    case RINGS = 10
    case POLYGON_RINGS = 12
    case GEOMETRIES = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Geometry type
  public var TYPE: GJNGeometryType { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? .point : GJNGeometryType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .point }
  ///  Single position (for Point)
  public var POINT: GJNPosition? { let o = _accessor.offset(VTOFFSET.POINT.v); return o == 0 ? nil : GJNPosition(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Array of positions (for MultiPoint, LineString)
  public var hasPositions: Bool { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? false : true }
  public var POSITIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POSITIONS(at index: Int32) -> GJNPosition? { let o = _accessor.offset(VTOFFSET.POSITIONS.v); return o == 0 ? nil : GJNPosition(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Array of position arrays (for MultiLineString, Polygon rings)
  public var hasRings: Bool { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? false : true }
  public var RINGSCount: Int32 { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RINGS(at index: Int32) -> GJNLinearRing? { let o = _accessor.offset(VTOFFSET.RINGS.v); return o == 0 ? nil : GJNLinearRing(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Array of polygons each as array of rings (for MultiPolygon)
  public var hasPolygonRings: Bool { let o = _accessor.offset(VTOFFSET.POLYGON_RINGS.v); return o == 0 ? false : true }
  public var POLYGON_RINGSCount: Int32 { let o = _accessor.offset(VTOFFSET.POLYGON_RINGS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POLYGON_RINGS(at index: Int32) -> GJNPolygonRings? { let o = _accessor.offset(VTOFFSET.POLYGON_RINGS.v); return o == 0 ? nil : GJNPolygonRings(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Child geometries (for GeometryCollection)
  public var hasGeometries: Bool { let o = _accessor.offset(VTOFFSET.GEOMETRIES.v); return o == 0 ? false : true }
  public var GEOMETRIESCount: Int32 { let o = _accessor.offset(VTOFFSET.GEOMETRIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func GEOMETRIES(at index: Int32) -> GJNGeometry? { let o = _accessor.offset(VTOFFSET.GEOMETRIES.v); return o == 0 ? nil : GJNGeometry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGJNGeometry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(TYPE: GJNGeometryType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TYPE.rawValue, def: 0, at: VTOFFSET.TYPE.p) }
  public static func add(POINT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINT, at: VTOFFSET.POINT.p) }
  public static func addVectorOf(POSITIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITIONS, at: VTOFFSET.POSITIONS.p) }
  public static func addVectorOf(RINGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RINGS, at: VTOFFSET.RINGS.p) }
  public static func addVectorOf(POLYGON_RINGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYGON_RINGS, at: VTOFFSET.POLYGON_RINGS.p) }
  public static func addVectorOf(GEOMETRIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GEOMETRIES, at: VTOFFSET.GEOMETRIES.p) }
  public static func endGJNGeometry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNGeometry(
    _ fbb: inout FlatBufferBuilder,
    TYPE: GJNGeometryType = .point,
    POINTOffset POINT: Offset = Offset(),
    POSITIONSVectorOffset POSITIONS: Offset = Offset(),
    RINGSVectorOffset RINGS: Offset = Offset(),
    POLYGON_RINGSVectorOffset POLYGON_RINGS: Offset = Offset(),
    GEOMETRIESVectorOffset GEOMETRIES: Offset = Offset()
  ) -> Offset {
    let __start = GJNGeometry.startGJNGeometry(&fbb)
    GJNGeometry.add(TYPE: TYPE, &fbb)
    GJNGeometry.add(POINT: POINT, &fbb)
    GJNGeometry.addVectorOf(POSITIONS: POSITIONS, &fbb)
    GJNGeometry.addVectorOf(RINGS: RINGS, &fbb)
    GJNGeometry.addVectorOf(POLYGON_RINGS: POLYGON_RINGS, &fbb)
    GJNGeometry.addVectorOf(GEOMETRIES: GEOMETRIES, &fbb)
    return GJNGeometry.endGJNGeometry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: GJNGeometryType.self)
    try _v.visit(field: VTOFFSET.POINT.p, fieldName: "POINT", required: false, type: ForwardOffset<GJNPosition>.self)
    try _v.visit(field: VTOFFSET.POSITIONS.p, fieldName: "POSITIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNPosition>, GJNPosition>>.self)
    try _v.visit(field: VTOFFSET.RINGS.p, fieldName: "RINGS", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNLinearRing>, GJNLinearRing>>.self)
    try _v.visit(field: VTOFFSET.POLYGON_RINGS.p, fieldName: "POLYGON_RINGS", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNPolygonRings>, GJNPolygonRings>>.self)
    try _v.visit(field: VTOFFSET.GEOMETRIES.p, fieldName: "GEOMETRIES", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNGeometry>, GJNGeometry>>.self)
    _v.finish()
  }
}

///  A key-value property entry for Feature properties
public struct GJNProperty: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNProperty.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case KEY = 4
    case VALUE = 6
    case NUM_VALUE = 8
    case IS_NUMERIC = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Property key
  public var KEY: String? { let o = _accessor.offset(VTOFFSET.KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KEY.v) }
  ///  Property value as string
  public var VALUE: String? { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALUE.v) }
  ///  Property value as number (use if numeric)
  public var NUM_VALUE: Double { let o = _accessor.offset(VTOFFSET.NUM_VALUE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True if NUM_VALUE should be used instead of VALUE
  public var IS_NUMERIC: Bool { let o = _accessor.offset(VTOFFSET.IS_NUMERIC.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startGJNProperty(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEY, at: VTOFFSET.KEY.p) }
  public static func add(VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALUE, at: VTOFFSET.VALUE.p) }
  public static func add(NUM_VALUE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NUM_VALUE, def: 0.0, at: VTOFFSET.NUM_VALUE.p) }
  public static func add(IS_NUMERIC: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: IS_NUMERIC, def: false,
   at: VTOFFSET.IS_NUMERIC.p) }
  public static func endGJNProperty(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNProperty(
    _ fbb: inout FlatBufferBuilder,
    KEYOffset KEY: Offset = Offset(),
    VALUEOffset VALUE: Offset = Offset(),
    NUM_VALUE: Double = 0.0,
    IS_NUMERIC: Bool = false
  ) -> Offset {
    let __start = GJNProperty.startGJNProperty(&fbb)
    GJNProperty.add(KEY: KEY, &fbb)
    GJNProperty.add(VALUE: VALUE, &fbb)
    GJNProperty.add(NUM_VALUE: NUM_VALUE, &fbb)
    GJNProperty.add(IS_NUMERIC: IS_NUMERIC, &fbb)
    return GJNProperty.endGJNProperty(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.KEY.p, fieldName: "KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NUM_VALUE.p, fieldName: "NUM_VALUE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.IS_NUMERIC.p, fieldName: "IS_NUMERIC", required: false, type: Bool.self)
    _v.finish()
  }
}

///  GeoJSON Feature object
public struct GJNFeature: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNFeature.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case GEOMETRY = 6
    case PROPERTIES = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Feature identifier (optional)
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Geometry of the feature
  public var GEOMETRY: GJNGeometry? { let o = _accessor.offset(VTOFFSET.GEOMETRY.v); return o == 0 ? nil : GJNGeometry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Properties as key-value pairs
  public var hasProperties: Bool { let o = _accessor.offset(VTOFFSET.PROPERTIES.v); return o == 0 ? false : true }
  public var PROPERTIESCount: Int32 { let o = _accessor.offset(VTOFFSET.PROPERTIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PROPERTIES(at index: Int32) -> GJNProperty? { let o = _accessor.offset(VTOFFSET.PROPERTIES.v); return o == 0 ? nil : GJNProperty(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGJNFeature(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(GEOMETRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GEOMETRY, at: VTOFFSET.GEOMETRY.p) }
  public static func addVectorOf(PROPERTIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROPERTIES, at: VTOFFSET.PROPERTIES.p) }
  public static func endGJNFeature(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNFeature(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    GEOMETRYOffset GEOMETRY: Offset = Offset(),
    PROPERTIESVectorOffset PROPERTIES: Offset = Offset()
  ) -> Offset {
    let __start = GJNFeature.startGJNFeature(&fbb)
    GJNFeature.add(ID: ID, &fbb)
    GJNFeature.add(GEOMETRY: GEOMETRY, &fbb)
    GJNFeature.addVectorOf(PROPERTIES: PROPERTIES, &fbb)
    return GJNFeature.endGJNFeature(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GEOMETRY.p, fieldName: "GEOMETRY", required: false, type: ForwardOffset<GJNGeometry>.self)
    try _v.visit(field: VTOFFSET.PROPERTIES.p, fieldName: "PROPERTIES", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNProperty>, GJNProperty>>.self)
    _v.finish()
  }
}

///  GeoJSON Bounding Box [west, south, east, north] or [west, south, min-alt, east, north, max-alt]
public struct GJNBoundingBox: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJNBoundingBox.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case WEST = 4
    case SOUTH = 6
    case EAST = 8
    case NORTH = 10
    case MIN_ALTITUDE = 12
    case MAX_ALTITUDE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Western longitude
  public var WEST: Double { let o = _accessor.offset(VTOFFSET.WEST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Southern latitude
  public var SOUTH: Double { let o = _accessor.offset(VTOFFSET.SOUTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Eastern longitude
  public var EAST: Double { let o = _accessor.offset(VTOFFSET.EAST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Northern latitude
  public var NORTH: Double { let o = _accessor.offset(VTOFFSET.NORTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum altitude (optional)
  public var MIN_ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.MIN_ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum altitude (optional)
  public var MAX_ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.MAX_ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startGJNBoundingBox(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(WEST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WEST, def: 0.0, at: VTOFFSET.WEST.p) }
  public static func add(SOUTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOUTH, def: 0.0, at: VTOFFSET.SOUTH.p) }
  public static func add(EAST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EAST, def: 0.0, at: VTOFFSET.EAST.p) }
  public static func add(NORTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORTH, def: 0.0, at: VTOFFSET.NORTH.p) }
  public static func add(MIN_ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MIN_ALTITUDE, def: 0.0, at: VTOFFSET.MIN_ALTITUDE.p) }
  public static func add(MAX_ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_ALTITUDE, def: 0.0, at: VTOFFSET.MAX_ALTITUDE.p) }
  public static func endGJNBoundingBox(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJNBoundingBox(
    _ fbb: inout FlatBufferBuilder,
    WEST: Double = 0.0,
    SOUTH: Double = 0.0,
    EAST: Double = 0.0,
    NORTH: Double = 0.0,
    MIN_ALTITUDE: Double = 0.0,
    MAX_ALTITUDE: Double = 0.0
  ) -> Offset {
    let __start = GJNBoundingBox.startGJNBoundingBox(&fbb)
    GJNBoundingBox.add(WEST: WEST, &fbb)
    GJNBoundingBox.add(SOUTH: SOUTH, &fbb)
    GJNBoundingBox.add(EAST: EAST, &fbb)
    GJNBoundingBox.add(NORTH: NORTH, &fbb)
    GJNBoundingBox.add(MIN_ALTITUDE: MIN_ALTITUDE, &fbb)
    GJNBoundingBox.add(MAX_ALTITUDE: MAX_ALTITUDE, &fbb)
    return GJNBoundingBox.endGJNBoundingBox(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.WEST.p, fieldName: "WEST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SOUTH.p, fieldName: "SOUTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.EAST.p, fieldName: "EAST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NORTH.p, fieldName: "NORTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MIN_ALTITUDE.p, fieldName: "MIN_ALTITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MAX_ALTITUDE.p, fieldName: "MAX_ALTITUDE", required: false, type: Double.self)
    _v.finish()
  }
}

///  GeoJSON FeatureCollection
public struct GJN: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GJN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GJN.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case FEATURES = 4
    case BBOX = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Features in the collection
  public var hasFeatures: Bool { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? false : true }
  public var FEATURESCount: Int32 { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FEATURES(at index: Int32) -> GJNFeature? { let o = _accessor.offset(VTOFFSET.FEATURES.v); return o == 0 ? nil : GJNFeature(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Bounding box (optional)
  public var BBOX: GJNBoundingBox? { let o = _accessor.offset(VTOFFSET.BBOX.v); return o == 0 ? nil : GJNBoundingBox(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startGJN(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func addVectorOf(FEATURES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FEATURES, at: VTOFFSET.FEATURES.p) }
  public static func add(BBOX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BBOX, at: VTOFFSET.BBOX.p) }
  public static func endGJN(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGJN(
    _ fbb: inout FlatBufferBuilder,
    FEATURESVectorOffset FEATURES: Offset = Offset(),
    BBOXOffset BBOX: Offset = Offset()
  ) -> Offset {
    let __start = GJN.startGJN(&fbb)
    GJN.addVectorOf(FEATURES: FEATURES, &fbb)
    GJN.add(BBOX: BBOX, &fbb)
    return GJN.endGJN(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.FEATURES.p, fieldName: "FEATURES", required: false, type: ForwardOffset<Vector<ForwardOffset<GJNFeature>, GJNFeature>>.self)
    try _v.visit(field: VTOFFSET.BBOX.p, fieldName: "BBOX", required: false, type: ForwardOffset<GJNBoundingBox>.self)
    _v.finish()
  }
}

