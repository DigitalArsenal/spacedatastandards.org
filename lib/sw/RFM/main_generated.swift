// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum refFrame: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Earth-Centered-Earth-Fixed: Rotates with Earth. X-axis at prime meridian, Y eastward, Z towards North Pole.
  case ecef = 0
  ///  International Celestial Reference Frame: Fixed relative to distant stars. Used in astronomy.
  case icrf = 1
  ///  True Equator Mean Equinox: Dynamic frame for SGP4 satellite tracking.
  case teme = 2
  ///  East-North-Up: Local tangent plane for surface points. Suitable for stationary objects.
  case enu = 3
  ///  North-East-Down: Aviation/navigation frame aligned with gravity.
  case ned = 4
  ///  North-East-Up: Similar to NED, with "Up" opposite gravity.
  case neu = 5
  ///  Radial-Intrack-Cross-track: Spacecraft orientation aligned with orbit.
  case ric = 6
  ///  Earth Mean Equator and Equinox of J2000: Fixed relative to stars, used for celestial mechanics.
  case j2000 = 7
  ///  Geocentric Celestial Reference Frame: Inertial Earth-centered frame.
  case gcrf = 8
  ///  Greenwich Rotating Coordinates: Rotates with Earth's true equator.
  case grc = 9
  ///  International Terrestrial Reference Frame 2000: Rotating Earth-fixed frame.
  case itrf2000 = 10
  ///  International Terrestrial Reference Frame 1993: Older ITRF realization.
  case itrf93 = 11
  ///  International Terrestrial Reference Frame 1997: Intermediate ITRF realization.
  case itrf97 = 12
  ///  True of Date, Rotating: Rotates with Earth's true equator.
  case tdr = 13
  ///  True of Date: Similar to TDR, without rotation.
  case tod = 14
  ///  Radial, Transverse, Normal: Orbit frame for spacecraft dynamics.
  case rtn = 15
  ///  Transverse, Velocity, Normal: Alternative orbit frame.
  case tvn = 16
  ///  Vehicle-Body-Local-Horizontal: Orbit frame aligned with spacecraft.
  case vvlh = 17
  ///  Vehicle-Local-Vertical-Local-Horizontal: Used in surface or proximity ops.
  case vlvh = 18
  ///  Local Tangent Plane: Surface-fixed frame for terrestrial uses.
  case ltp = 19
  ///  Local Vertical-Local Horizontal: Orbit frame with Z towards Earth center.
  case lvlh = 20
  ///  Polar-North-East: Polar coordinate frame.
  case pne = 21
  ///  Body-Fixed Reference Frame: Fixed to a spacecraft or celestial object.
  case brf = 22
  ///  Radial, Down-track, Cross-track: Alternate name for RTN.
  case rsw = 23
  ///  Tangential, Normal, Cross-track: Local orbit frame.
  case tnw = 24
  ///  Radial, Along-track, Cross-track: Satellite motion frame.
  case uvw = 25
  ///  Equinoctial Inertial: Frame with axes aligned to orbital properties.
  case eqwInertial = 26
  ///  Inertial version of LVLH.
  case lvlhInertial = 27
  ///  Rotating LVLH frame.
  case lvlhRotating = 28
  ///  Inertial Nadir-Sun-Normal frame.
  case nswInertial = 29
  ///  Rotating Nadir-Sun-Normal frame.
  case nswRotating = 30
  ///  Inertial Transverse-Velocity-Normal frame.
  case ntwInertial = 31
  ///  Rotating Transverse-Velocity-Normal frame.
  case ntwRotating = 32
  ///  Perifocal Coordinate System: Inertial frame aligned to periapsis.
  case pqwInertial = 33
  ///  Inertial Radial, Transverse, Normal frame.
  case rswInertial = 34
  ///  Rotating RSW frame: Aligned with orbit angular momentum.
  case rswRotating = 35
  ///  South/East/Zenith inertial frame.
  case sezInertial = 36
  ///  Rotating South/East/Zenith frame.
  case sezRotating = 37
  ///  Inertial Tangential, Normal, Cross-track frame.
  case tnwInertial = 38
  ///  Rotating Tangential, Normal, Cross-track frame.
  case tnwRotating = 39
  ///  Velocity, Normal, Co-normal inertial frame.
  case vncInertial = 40
  ///  Rotating Velocity, Normal, Co-normal frame.
  case vncRotating = 41
  ///  Central Body alignment inertial frame.
  case alignCb = 42
  ///  Earth alignment inertial frame.
  case alignEarth = 43
  ///  Inertial realization of B1950 epoch.
  case b1950 = 44
  ///  Celestial Intermediate Reference System.
  case cirs = 45
  ///  DTRF Inertial frame with corrections.
  case dtrfyyyy = 46
  ///  Earth-Fixed Greenwich rotating frame.
  case efg = 47
  ///  Earth Mean Equator and Equinox of 2000 epoch.
  case eme2000 = 48
  ///  Central Body fixed rotating frame.
  case fixedCb = 49
  ///  Earth-fixed rotating frame.
  case fixedEarth = 50
  ///  Geocentric Celestial Reference Frame with versioning.
  case gcrfn = 51
  ///  Greenwich True-of-Date rotating frame.
  case gtod = 52
  ///  Mean of Date for all central bodies except Earth and Moon.
  case modCb = 53
  ///  Mean of Date for Earth.
  case modEarth = 54
  ///  Mean of Date for Moon.
  case modMoon = 55
  ///  Mean of Epoch for central bodies.
  case moeCb = 56
  ///  Mean of Epoch for Earth.
  case moeEarth = 57
  ///  Lunar Moon Mean Earth reference frame.
  case moonMe = 58
  ///  Lunar Mean Equator and IAU Node reference frame.
  case moonMeiaue = 59
  ///  Lunar Principal Axis rotating frame.
  case moonPaxxx = 60
  ///  True Equator Mean Equinox of Date.
  case temeofdate = 61
  ///  True Equator Mean Equinox of Epoch.
  case temeofepoch = 62
  ///  Terrestrial Intermediate Reference System.
  case tirs = 63
  ///  True of Date for central bodies.
  case todCb = 64
  ///  True of Date for Earth.
  case todEarth = 65
  ///  True of Date for Moon.
  case todMoon = 66
  ///  True of Epoch for central bodies.
  case toeCb = 67
  ///  True of Epoch for Earth.
  case toeEarth = 68
  ///  True of Epoch for Moon.
  case toeMoon = 69
  ///  True Ecliptic reference frame.
  case trueEcliptic = 70
  ///  Launch go-inertial reference frame.
  case uvwGoInertial = 71
  ///  WGS 84 Earth-fixed terrestrial system.
  case wgs84 = 72
  ///  Accelerometer reference frame.
  case accI = 73
  ///  Actuator reference frame.
  case actuatorI = 74
  ///  Autonomous Star Tracker reference frame.
  case astI = 75
  ///  Coarse Sun Sensor reference frame.
  case cssI = 76
  ///  Digital Sun Sensor reference frame.
  case dssI = 77
  ///  Earth Sensor Assembly reference frame.
  case esaI = 78
  ///  Gyro reference frame.
  case gyroFrameI = 79
  ///  Inertial Measurement Unit reference frame.
  case imuFrameI = 80
  ///  Instrument reference frame.
  case instrumentI = 81
  ///  Magnetic Torque Assembly reference frame.
  case mtaI = 82
  ///  Reaction Wheel reference frame.
  case rwI = 83
  ///  Solar Array reference frame.
  case saI = 84
  ///  Spacecraft Body reference frame.
  case scBodyI = 85
  ///  Sensor reference frame.
  case sensorI = 86
  ///  Star Tracker reference frame.
  case startrackerI = 87
  ///  Three Axis Magnetometer reference frame.
  case tamI = 88

  public static var max: refFrame { return .tamI }
  public static var min: refFrame { return .ecef }
}


///  Reference Frame Message
public struct RFM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$RFM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RFM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case REFERENCE_FRAME = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var REFERENCE_FRAME: refFrame { let o = _accessor.offset(VTOFFSET.REFERENCE_FRAME.v); return o == 0 ? .ecef : refFrame(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ecef }
  public static func startRFM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(REFERENCE_FRAME: refFrame, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REFERENCE_FRAME.rawValue, def: 0, at: VTOFFSET.REFERENCE_FRAME.p) }
  public static func endRFM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRFM(
    _ fbb: inout FlatBufferBuilder,
    REFERENCE_FRAME: refFrame = .ecef
  ) -> Offset {
    let __start = RFM.startRFM(&fbb)
    RFM.add(REFERENCE_FRAME: REFERENCE_FRAME, &fbb)
    return RFM.endRFM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.REFERENCE_FRAME.p, fieldName: "REFERENCE_FRAME", required: false, type: refFrame.self)
    _v.finish()
  }
}

///  Collection of Reference Frame Messages
public struct RFMCOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$RFM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: RFMCOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> RFM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : RFM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startRFMCOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endRFMCOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRFMCOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = RFMCOLLECTION.startRFMCOLLECTION(&fbb)
    RFMCOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return RFMCOLLECTION.endRFMCOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<RFM>, RFM>>.self)
    _v.finish()
  }
}

