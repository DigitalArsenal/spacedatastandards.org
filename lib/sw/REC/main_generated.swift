// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum RecordType: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case acl = 1
  case acm = 2
  case acr = 3
  case aem = 4
  case ani = 5
  case aof = 6
  case apm = 7
  case arm = 8
  case ast = 9
  case atd = 10
  case atm = 11
  case bal = 12
  case bem = 13
  case bmc = 14
  case bov = 15
  case bus = 16
  case cat = 17
  case cdm = 18
  case cfp = 19
  case chn = 20
  case clt = 21
  case cms = 22
  case com = 23
  case cot = 24
  case crd = 25
  case crm = 26
  case csm = 27
  case ctr = 28
  case czm = 29
  case dfh = 30
  case dmg = 31
  case doa = 32
  case eme = 33
  case enc = 34
  case env = 35
  case eoo = 36
  case eop = 37
  case epm = 38
  case ewr = 39
  case fcs = 40
  case gdi = 41
  case geo = 42
  case gjn = 43
  case gno = 44
  case gpx = 45
  case grv = 46
  case gvh = 47
  case hel = 48
  case hyp = 49
  case idm = 50
  case ion = 51
  case iro = 52
  case kml = 53
  case lcc = 54
  case ldm = 55
  case lks = 56
  case lnd = 57
  case lne = 58
  case met = 59
  case mfe = 60
  case mnf = 61
  case mnv = 62
  case mpe = 63
  case msl = 64
  case mst = 65
  case mti = 66
  case nav = 67
  case obd = 68
  case obt = 69
  case ocm = 70
  case oem = 71
  case omm = 72
  case ooa = 73
  case oob = 74
  case ood = 75
  case ooe = 76
  case ooi = 77
  case ool = 78
  case oon = 79
  case oos = 80
  case oot = 81
  case opm = 82
  case osm = 83
  case pcf = 84
  case phy = 85
  case pld = 86
  case plg = 87
  case plk = 88
  case pnm = 89
  case prg = 90
  case pur = 91
  case raf = 92
  case rcf = 93
  case rdm = 94
  case rdo = 95
  case rev = 96
  case rfb = 97
  case rfe = 98
  case rfm = 99
  case rfo = 100
  case roc = 101
  case sar = 102
  case scm = 103
  case sdl = 104
  case sen = 105
  case seo = 106
  case sev = 107
  case sit = 108
  case ski = 109
  case snr = 110
  case soi = 111
  case son = 112
  case spp = 113
  case spw = 114
  case stf = 115
  case str = 116
  case stv = 117
  case swr = 118
  case tcf = 119
  case tdm = 120
  case tim = 121
  case tkg = 122
  case tme = 123
  case tmf = 124
  case tpn = 125
  case trk = 126
  case trn = 127
  case vcm = 128
  case wpn = 129
  case wth = 130
  case xtc = 131

  public static var max: RecordType { return .xtc }
  public static var min: RecordType { return .none_ }
}


///  Individual record wrapper for any standard type
public struct Record: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$REC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Record.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case valueType = 4
    case value = 6
    case standard = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var valueType: RecordType { let o = _accessor.offset(VTOFFSET.valueType.v); return o == 0 ? .none_ : RecordType(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  ///  The record data (union of all supported standards)
  public func value<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.union(o) }
  ///  Standard identifier (e.g., "OMM", "CDM", "CAT")
  public var standard: String? { let o = _accessor.offset(VTOFFSET.standard.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var standardSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.standard.v) }
  public static func startRecord(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(valueType: RecordType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: valueType.rawValue, def: 0, at: VTOFFSET.valueType.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func add(standard: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: standard, at: VTOFFSET.standard.p) }
  public static func endRecord(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRecord(
    _ fbb: inout FlatBufferBuilder,
    valueType: RecordType = .none_,
    valueOffset value: Offset = Offset(),
    standardOffset standard: Offset = Offset()
  ) -> Offset {
    let __start = Record.startRecord(&fbb)
    Record.add(valueType: valueType, &fbb)
    Record.add(value: value, &fbb)
    Record.add(standard: standard, &fbb)
    return Record.endRecord(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(unionKey: VTOFFSET.valueType.p, unionField: VTOFFSET.value.p, unionKeyName: "valueType", fieldName: "value", required: false, completion: { (verifier, key: RecordType, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .acl:
        try ForwardOffset<ACL>.verify(&verifier, at: pos, of: ACL.self)
      case .acm:
        try ForwardOffset<ACM>.verify(&verifier, at: pos, of: ACM.self)
      case .acr:
        try ForwardOffset<ACR>.verify(&verifier, at: pos, of: ACR.self)
      case .aem:
        try ForwardOffset<AEM>.verify(&verifier, at: pos, of: AEM.self)
      case .ani:
        try ForwardOffset<ANI>.verify(&verifier, at: pos, of: ANI.self)
      case .aof:
        try ForwardOffset<AOF>.verify(&verifier, at: pos, of: AOF.self)
      case .apm:
        try ForwardOffset<APM>.verify(&verifier, at: pos, of: APM.self)
      case .arm:
        try ForwardOffset<ARM>.verify(&verifier, at: pos, of: ARM.self)
      case .ast:
        try ForwardOffset<AST>.verify(&verifier, at: pos, of: AST.self)
      case .atd:
        try ForwardOffset<ATD>.verify(&verifier, at: pos, of: ATD.self)
      case .atm:
        try ForwardOffset<ATM>.verify(&verifier, at: pos, of: ATM.self)
      case .bal:
        try ForwardOffset<BAL>.verify(&verifier, at: pos, of: BAL.self)
      case .bem:
        try ForwardOffset<BEM>.verify(&verifier, at: pos, of: BEM.self)
      case .bmc:
        try ForwardOffset<BMC>.verify(&verifier, at: pos, of: BMC.self)
      case .bov:
        try ForwardOffset<BOV>.verify(&verifier, at: pos, of: BOV.self)
      case .bus:
        try ForwardOffset<BUS>.verify(&verifier, at: pos, of: BUS.self)
      case .cat:
        try ForwardOffset<CAT>.verify(&verifier, at: pos, of: CAT.self)
      case .cdm:
        try ForwardOffset<CDM>.verify(&verifier, at: pos, of: CDM.self)
      case .cfp:
        try ForwardOffset<CFP>.verify(&verifier, at: pos, of: CFP.self)
      case .chn:
        try ForwardOffset<CHN>.verify(&verifier, at: pos, of: CHN.self)
      case .clt:
        try ForwardOffset<CLT>.verify(&verifier, at: pos, of: CLT.self)
      case .cms:
        try ForwardOffset<CMS>.verify(&verifier, at: pos, of: CMS.self)
      case .com:
        try ForwardOffset<COM>.verify(&verifier, at: pos, of: COM.self)
      case .cot:
        try ForwardOffset<COT>.verify(&verifier, at: pos, of: COT.self)
      case .crd:
        try ForwardOffset<CRD>.verify(&verifier, at: pos, of: CRD.self)
      case .crm:
        try ForwardOffset<CRM>.verify(&verifier, at: pos, of: CRM.self)
      case .csm:
        try ForwardOffset<CSM>.verify(&verifier, at: pos, of: CSM.self)
      case .ctr:
        try ForwardOffset<CTR>.verify(&verifier, at: pos, of: CTR.self)
      case .czm:
        try ForwardOffset<CZM>.verify(&verifier, at: pos, of: CZM.self)
      case .dfh:
        try ForwardOffset<DFH>.verify(&verifier, at: pos, of: DFH.self)
      case .dmg:
        try ForwardOffset<DMG>.verify(&verifier, at: pos, of: DMG.self)
      case .doa:
        try ForwardOffset<DOA>.verify(&verifier, at: pos, of: DOA.self)
      case .eme:
        try ForwardOffset<EME>.verify(&verifier, at: pos, of: EME.self)
      case .enc:
        try ForwardOffset<ENC>.verify(&verifier, at: pos, of: ENC.self)
      case .env:
        try ForwardOffset<ENV>.verify(&verifier, at: pos, of: ENV.self)
      case .eoo:
        try ForwardOffset<EOO>.verify(&verifier, at: pos, of: EOO.self)
      case .eop:
        try ForwardOffset<EOP>.verify(&verifier, at: pos, of: EOP.self)
      case .epm:
        try ForwardOffset<EPM>.verify(&verifier, at: pos, of: EPM.self)
      case .ewr:
        try ForwardOffset<EWR>.verify(&verifier, at: pos, of: EWR.self)
      case .fcs:
        try ForwardOffset<FCS>.verify(&verifier, at: pos, of: FCS.self)
      case .gdi:
        try ForwardOffset<GDI>.verify(&verifier, at: pos, of: GDI.self)
      case .geo:
        try ForwardOffset<GEO>.verify(&verifier, at: pos, of: GEO.self)
      case .gjn:
        try ForwardOffset<GJN>.verify(&verifier, at: pos, of: GJN.self)
      case .gno:
        try ForwardOffset<GNO>.verify(&verifier, at: pos, of: GNO.self)
      case .gpx:
        try ForwardOffset<GPX>.verify(&verifier, at: pos, of: GPX.self)
      case .grv:
        try ForwardOffset<GRV>.verify(&verifier, at: pos, of: GRV.self)
      case .gvh:
        try ForwardOffset<GVH>.verify(&verifier, at: pos, of: GVH.self)
      case .hel:
        try ForwardOffset<HEL>.verify(&verifier, at: pos, of: HEL.self)
      case .hyp:
        try ForwardOffset<HYP>.verify(&verifier, at: pos, of: HYP.self)
      case .idm:
        try ForwardOffset<IDM>.verify(&verifier, at: pos, of: IDM.self)
      case .ion:
        try ForwardOffset<ION>.verify(&verifier, at: pos, of: ION.self)
      case .iro:
        try ForwardOffset<IRO>.verify(&verifier, at: pos, of: IRO.self)
      case .kml:
        try ForwardOffset<KML>.verify(&verifier, at: pos, of: KML.self)
      case .lcc:
        try ForwardOffset<LCC>.verify(&verifier, at: pos, of: LCC.self)
      case .ldm:
        try ForwardOffset<LDM>.verify(&verifier, at: pos, of: LDM.self)
      case .lks:
        try ForwardOffset<LKS>.verify(&verifier, at: pos, of: LKS.self)
      case .lnd:
        try ForwardOffset<LND>.verify(&verifier, at: pos, of: LND.self)
      case .lne:
        try ForwardOffset<LNE>.verify(&verifier, at: pos, of: LNE.self)
      case .met:
        try ForwardOffset<MET>.verify(&verifier, at: pos, of: MET.self)
      case .mfe:
        try ForwardOffset<MFE>.verify(&verifier, at: pos, of: MFE.self)
      case .mnf:
        try ForwardOffset<MNF>.verify(&verifier, at: pos, of: MNF.self)
      case .mnv:
        try ForwardOffset<MNV>.verify(&verifier, at: pos, of: MNV.self)
      case .mpe:
        try ForwardOffset<MPE>.verify(&verifier, at: pos, of: MPE.self)
      case .msl:
        try ForwardOffset<MSL>.verify(&verifier, at: pos, of: MSL.self)
      case .mst:
        try ForwardOffset<MST>.verify(&verifier, at: pos, of: MST.self)
      case .mti:
        try ForwardOffset<MTI>.verify(&verifier, at: pos, of: MTI.self)
      case .nav:
        try ForwardOffset<NAV>.verify(&verifier, at: pos, of: NAV.self)
      case .obd:
        try ForwardOffset<OBD>.verify(&verifier, at: pos, of: OBD.self)
      case .obt:
        try ForwardOffset<OBT>.verify(&verifier, at: pos, of: OBT.self)
      case .ocm:
        try ForwardOffset<OCM>.verify(&verifier, at: pos, of: OCM.self)
      case .oem:
        try ForwardOffset<OEM>.verify(&verifier, at: pos, of: OEM.self)
      case .omm:
        try ForwardOffset<OMM>.verify(&verifier, at: pos, of: OMM.self)
      case .ooa:
        try ForwardOffset<OOA>.verify(&verifier, at: pos, of: OOA.self)
      case .oob:
        try ForwardOffset<OOB>.verify(&verifier, at: pos, of: OOB.self)
      case .ood:
        try ForwardOffset<OOD>.verify(&verifier, at: pos, of: OOD.self)
      case .ooe:
        try ForwardOffset<OOE>.verify(&verifier, at: pos, of: OOE.self)
      case .ooi:
        try ForwardOffset<OOI>.verify(&verifier, at: pos, of: OOI.self)
      case .ool:
        try ForwardOffset<OOL>.verify(&verifier, at: pos, of: OOL.self)
      case .oon:
        try ForwardOffset<OON>.verify(&verifier, at: pos, of: OON.self)
      case .oos:
        try ForwardOffset<OOS>.verify(&verifier, at: pos, of: OOS.self)
      case .oot:
        try ForwardOffset<OOT>.verify(&verifier, at: pos, of: OOT.self)
      case .opm:
        try ForwardOffset<OPM>.verify(&verifier, at: pos, of: OPM.self)
      case .osm:
        try ForwardOffset<OSM>.verify(&verifier, at: pos, of: OSM.self)
      case .pcf:
        try ForwardOffset<PCF>.verify(&verifier, at: pos, of: PCF.self)
      case .phy:
        try ForwardOffset<PHY>.verify(&verifier, at: pos, of: PHY.self)
      case .pld:
        try ForwardOffset<PLD>.verify(&verifier, at: pos, of: PLD.self)
      case .plg:
        try ForwardOffset<PLG>.verify(&verifier, at: pos, of: PLG.self)
      case .plk:
        try ForwardOffset<PLK>.verify(&verifier, at: pos, of: PLK.self)
      case .pnm:
        try ForwardOffset<PNM>.verify(&verifier, at: pos, of: PNM.self)
      case .prg:
        try ForwardOffset<PRG>.verify(&verifier, at: pos, of: PRG.self)
      case .pur:
        try ForwardOffset<PUR>.verify(&verifier, at: pos, of: PUR.self)
      case .raf:
        try ForwardOffset<RAF>.verify(&verifier, at: pos, of: RAF.self)
      case .rcf:
        try ForwardOffset<RCF>.verify(&verifier, at: pos, of: RCF.self)
      case .rdm:
        try ForwardOffset<RDM>.verify(&verifier, at: pos, of: RDM.self)
      case .rdo:
        try ForwardOffset<RDO>.verify(&verifier, at: pos, of: RDO.self)
      case .rev:
        try ForwardOffset<REV>.verify(&verifier, at: pos, of: REV.self)
      case .rfb:
        try ForwardOffset<RFB>.verify(&verifier, at: pos, of: RFB.self)
      case .rfe:
        try ForwardOffset<RFE>.verify(&verifier, at: pos, of: RFE.self)
      case .rfm:
        try ForwardOffset<RFM>.verify(&verifier, at: pos, of: RFM.self)
      case .rfo:
        try ForwardOffset<RFO>.verify(&verifier, at: pos, of: RFO.self)
      case .roc:
        try ForwardOffset<ROC>.verify(&verifier, at: pos, of: ROC.self)
      case .sar:
        try ForwardOffset<SAR>.verify(&verifier, at: pos, of: SAR.self)
      case .scm:
        try ForwardOffset<SCM>.verify(&verifier, at: pos, of: SCM.self)
      case .sdl:
        try ForwardOffset<SDL>.verify(&verifier, at: pos, of: SDL.self)
      case .sen:
        try ForwardOffset<SEN>.verify(&verifier, at: pos, of: SEN.self)
      case .seo:
        try ForwardOffset<SEO>.verify(&verifier, at: pos, of: SEO.self)
      case .sev:
        try ForwardOffset<SEV>.verify(&verifier, at: pos, of: SEV.self)
      case .sit:
        try ForwardOffset<SIT>.verify(&verifier, at: pos, of: SIT.self)
      case .ski:
        try ForwardOffset<SKI>.verify(&verifier, at: pos, of: SKI.self)
      case .snr:
        try ForwardOffset<SNR>.verify(&verifier, at: pos, of: SNR.self)
      case .soi:
        try ForwardOffset<SOI>.verify(&verifier, at: pos, of: SOI.self)
      case .son:
        try ForwardOffset<SON>.verify(&verifier, at: pos, of: SON.self)
      case .spp:
        try ForwardOffset<SPP>.verify(&verifier, at: pos, of: SPP.self)
      case .spw:
        try ForwardOffset<SPW>.verify(&verifier, at: pos, of: SPW.self)
      case .stf:
        try ForwardOffset<STF>.verify(&verifier, at: pos, of: STF.self)
      case .str:
        try ForwardOffset<STR>.verify(&verifier, at: pos, of: STR.self)
      case .stv:
        try ForwardOffset<STV>.verify(&verifier, at: pos, of: STV.self)
      case .swr:
        try ForwardOffset<SWR>.verify(&verifier, at: pos, of: SWR.self)
      case .tcf:
        try ForwardOffset<TCF>.verify(&verifier, at: pos, of: TCF.self)
      case .tdm:
        try ForwardOffset<TDM>.verify(&verifier, at: pos, of: TDM.self)
      case .tim:
        try ForwardOffset<TIM>.verify(&verifier, at: pos, of: TIM.self)
      case .tkg:
        try ForwardOffset<TKG>.verify(&verifier, at: pos, of: TKG.self)
      case .tme:
        try ForwardOffset<TME>.verify(&verifier, at: pos, of: TME.self)
      case .tmf:
        try ForwardOffset<TMF>.verify(&verifier, at: pos, of: TMF.self)
      case .tpn:
        try ForwardOffset<TPN>.verify(&verifier, at: pos, of: TPN.self)
      case .trk:
        try ForwardOffset<TRK>.verify(&verifier, at: pos, of: TRK.self)
      case .trn:
        try ForwardOffset<TRN>.verify(&verifier, at: pos, of: TRN.self)
      case .vcm:
        try ForwardOffset<VCM>.verify(&verifier, at: pos, of: VCM.self)
      case .wpn:
        try ForwardOffset<WPN>.verify(&verifier, at: pos, of: WPN.self)
      case .wth:
        try ForwardOffset<WTH>.verify(&verifier, at: pos, of: WTH.self)
      case .xtc:
        try ForwardOffset<XTC>.verify(&verifier, at: pos, of: XTC.self)
      }
    })
    try _v.visit(field: VTOFFSET.standard.p, fieldName: "standard", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of Standard Records
public struct REC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$REC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: REC.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case version = 4
    case RECORDS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Schema version identifier
  public var version: String? { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.version.v) }
  ///  Array of heterogeneous records from any supported standard
  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> Record? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : Record(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startREC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endREC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createREC(
    _ fbb: inout FlatBufferBuilder,
    versionOffset version: Offset = Offset(),
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = REC.startREC(&fbb)
    REC.add(version: version, &fbb)
    REC.addVectorOf(RECORDS: RECORDS, &fbb)
    return REC.endREC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<Record>, Record>>.self)
    _v.finish()
  }
}

