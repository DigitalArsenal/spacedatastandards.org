// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum RecordType: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case atm = 1
  case bov = 2
  case cat = 3
  case cdm = 4
  case crm = 5
  case csm = 6
  case ctr = 7
  case eme = 8
  case eoo = 9
  case eop = 10
  case epm = 11
  case hyp = 12
  case idm = 13
  case lcc = 14
  case ldm = 15
  case met = 16
  case mpe = 17
  case ocm = 18
  case oem = 19
  case omm = 20
  case osm = 21
  case pld = 22
  case pnm = 23
  case prg = 24
  case rfm = 25
  case roc = 26
  case scm = 27
  case sit = 28
  case tdm = 29
  case tim = 30
  case vcm = 31

  public static var max: RecordType { return .vcm }
  public static var min: RecordType { return .none_ }
}


public struct Record: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$REC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Record.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case valueType = 4
    case value = 6
    case standard = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var valueType: RecordType { let o = _accessor.offset(VTOFFSET.valueType.v); return o == 0 ? .none_ : RecordType(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func value<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.union(o) }
  public var standard: String? { let o = _accessor.offset(VTOFFSET.standard.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var standardSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.standard.v) }
  public static func startRecord(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(valueType: RecordType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: valueType.rawValue, def: 0, at: VTOFFSET.valueType.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func add(standard: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: standard, at: VTOFFSET.standard.p) }
  public static func endRecord(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRecord(
    _ fbb: inout FlatBufferBuilder,
    valueType: RecordType = .none_,
    valueOffset value: Offset = Offset(),
    standardOffset standard: Offset = Offset()
  ) -> Offset {
    let __start = Record.startRecord(&fbb)
    Record.add(valueType: valueType, &fbb)
    Record.add(value: value, &fbb)
    Record.add(standard: standard, &fbb)
    return Record.endRecord(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(unionKey: VTOFFSET.valueType.p, unionField: VTOFFSET.value.p, unionKeyName: "valueType", fieldName: "value", required: false, completion: { (verifier, key: RecordType, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .atm:
        try ForwardOffset<ATM>.verify(&verifier, at: pos, of: ATM.self)
      case .bov:
        try ForwardOffset<BOV>.verify(&verifier, at: pos, of: BOV.self)
      case .cat:
        try ForwardOffset<CAT>.verify(&verifier, at: pos, of: CAT.self)
      case .cdm:
        try ForwardOffset<CDM>.verify(&verifier, at: pos, of: CDM.self)
      case .crm:
        try ForwardOffset<CRM>.verify(&verifier, at: pos, of: CRM.self)
      case .csm:
        try ForwardOffset<CSM>.verify(&verifier, at: pos, of: CSM.self)
      case .ctr:
        try ForwardOffset<CTR>.verify(&verifier, at: pos, of: CTR.self)
      case .eme:
        try ForwardOffset<EME>.verify(&verifier, at: pos, of: EME.self)
      case .eoo:
        try ForwardOffset<EOO>.verify(&verifier, at: pos, of: EOO.self)
      case .eop:
        try ForwardOffset<EOP>.verify(&verifier, at: pos, of: EOP.self)
      case .epm:
        try ForwardOffset<EPM>.verify(&verifier, at: pos, of: EPM.self)
      case .hyp:
        try ForwardOffset<HYP>.verify(&verifier, at: pos, of: HYP.self)
      case .idm:
        try ForwardOffset<IDM>.verify(&verifier, at: pos, of: IDM.self)
      case .lcc:
        try ForwardOffset<LCC>.verify(&verifier, at: pos, of: LCC.self)
      case .ldm:
        try ForwardOffset<LDM>.verify(&verifier, at: pos, of: LDM.self)
      case .met:
        try ForwardOffset<MET>.verify(&verifier, at: pos, of: MET.self)
      case .mpe:
        try ForwardOffset<MPE>.verify(&verifier, at: pos, of: MPE.self)
      case .ocm:
        try ForwardOffset<OCM>.verify(&verifier, at: pos, of: OCM.self)
      case .oem:
        try ForwardOffset<OEM>.verify(&verifier, at: pos, of: OEM.self)
      case .omm:
        try ForwardOffset<OMM>.verify(&verifier, at: pos, of: OMM.self)
      case .osm:
        try ForwardOffset<OSM>.verify(&verifier, at: pos, of: OSM.self)
      case .pld:
        try ForwardOffset<PLD>.verify(&verifier, at: pos, of: PLD.self)
      case .pnm:
        try ForwardOffset<PNM>.verify(&verifier, at: pos, of: PNM.self)
      case .prg:
        try ForwardOffset<PRG>.verify(&verifier, at: pos, of: PRG.self)
      case .rfm:
        try ForwardOffset<RFM>.verify(&verifier, at: pos, of: RFM.self)
      case .roc:
        try ForwardOffset<ROC>.verify(&verifier, at: pos, of: ROC.self)
      case .scm:
        try ForwardOffset<SCM>.verify(&verifier, at: pos, of: SCM.self)
      case .sit:
        try ForwardOffset<SIT>.verify(&verifier, at: pos, of: SIT.self)
      case .tdm:
        try ForwardOffset<TDM>.verify(&verifier, at: pos, of: TDM.self)
      case .tim:
        try ForwardOffset<TIM>.verify(&verifier, at: pos, of: TIM.self)
      case .vcm:
        try ForwardOffset<VCM>.verify(&verifier, at: pos, of: VCM.self)
      }
    })
    try _v.visit(field: VTOFFSET.standard.p, fieldName: "standard", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of Standard Records
public struct REC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$REC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: REC.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case version = 4
    case RECORDS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var version: String? { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.version.v) }
  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> Record? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : Record(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startREC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endREC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createREC(
    _ fbb: inout FlatBufferBuilder,
    versionOffset version: Offset = Offset(),
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = REC.startREC(&fbb)
    REC.add(version: version, &fbb)
    REC.addVectorOf(RECORDS: RECORDS, &fbb)
    return REC.endREC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<Record>, Record>>.self)
    _v.finish()
  }
}

