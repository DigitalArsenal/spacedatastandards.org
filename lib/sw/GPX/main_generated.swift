// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum GPXFixType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  ///  2D fix
  case fix2d = 1
  ///  3D fix
  case fix3d = 2
  ///  Differential GPS fix
  case dgps = 3
  ///  PPP fix
  case pps = 4

  public static var max: GPXFixType { return .pps }
  public static var min: GPXFixType { return .none_ }
}


///  GPX link to an external resource
public struct GPXLink: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPXLink.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case HREF = 4
    case TEXT = 6
    case TYPE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  URL
  public var HREF: String? { let o = _accessor.offset(VTOFFSET.HREF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HREFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HREF.v) }
  ///  Link text
  public var TEXT: String? { let o = _accessor.offset(VTOFFSET.TEXT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TEXTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TEXT.v) }
  ///  MIME type
  public var TYPE: String? { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE.v) }
  public static func startGPXLink(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(HREF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HREF, at: VTOFFSET.HREF.p) }
  public static func add(TEXT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TEXT, at: VTOFFSET.TEXT.p) }
  public static func add(TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE, at: VTOFFSET.TYPE.p) }
  public static func endGPXLink(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPXLink(
    _ fbb: inout FlatBufferBuilder,
    HREFOffset HREF: Offset = Offset(),
    TEXTOffset TEXT: Offset = Offset(),
    TYPEOffset TYPE: Offset = Offset()
  ) -> Offset {
    let __start = GPXLink.startGPXLink(&fbb)
    GPXLink.add(HREF: HREF, &fbb)
    GPXLink.add(TEXT: TEXT, &fbb)
    GPXLink.add(TYPE: TYPE, &fbb)
    return GPXLink.endGPXLink(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.HREF.p, fieldName: "HREF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TEXT.p, fieldName: "TEXT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  A waypoint, point of interest, or named feature
public struct GPXWaypoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPXWaypoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LATITUDE = 4
    case LONGITUDE = 6
    case ELEVATION = 8
    case TIME = 10
    case MAGVAR = 12
    case GEOID_HEIGHT = 14
    case NAME = 16
    case COMMENT = 18
    case DESCRIPTION = 20
    case SOURCE = 22
    case LINKS = 24
    case SYMBOL = 26
    case TYPE = 28
    case FIX = 30
    case SAT = 32
    case HDOP = 34
    case VDOP = 36
    case PDOP = 38
    case AGE_OF_DGPS_DATA = 40
    case DGPS_ID = 42
    case SPEED = 44
    case COURSE = 46
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Latitude in decimal degrees (WGS84)
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Longitude in decimal degrees (WGS84)
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Elevation in meters above WGS84 ellipsoid
  public var ELEVATION: Double { let o = _accessor.offset(VTOFFSET.ELEVATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  UTC timestamp (ISO 8601)
  public var TIME: String? { let o = _accessor.offset(VTOFFSET.TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIME.v) }
  ///  Magnetic variation in degrees
  public var MAGVAR: Double { let o = _accessor.offset(VTOFFSET.MAGVAR.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Height of geoid above WGS84 ellipsoid in meters
  public var GEOID_HEIGHT: Double { let o = _accessor.offset(VTOFFSET.GEOID_HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Waypoint name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Comment
  public var COMMENT: String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMENT.v) }
  ///  Description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Source of data
  public var SOURCE: String? { let o = _accessor.offset(VTOFFSET.SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOURCE.v) }
  ///  Links to additional information
  public var hasLinks: Bool { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? false : true }
  public var LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LINKS(at index: Int32) -> GPXLink? { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? nil : GPXLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Symbol name
  public var SYMBOL: String? { let o = _accessor.offset(VTOFFSET.SYMBOL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SYMBOLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SYMBOL.v) }
  ///  Type/category
  public var TYPE: String? { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE.v) }
  ///  Type of GPS fix
  public var FIX: GPXFixType { let o = _accessor.offset(VTOFFSET.FIX.v); return o == 0 ? .none_ : GPXFixType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  ///  Number of satellites used for fix
  public var SAT: UInt16 { let o = _accessor.offset(VTOFFSET.SAT.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Horizontal dilution of precision
  public var HDOP: Double { let o = _accessor.offset(VTOFFSET.HDOP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Vertical dilution of precision
  public var VDOP: Double { let o = _accessor.offset(VTOFFSET.VDOP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Position dilution of precision
  public var PDOP: Double { let o = _accessor.offset(VTOFFSET.PDOP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Age of DGPS data in seconds
  public var AGE_OF_DGPS_DATA: Double { let o = _accessor.offset(VTOFFSET.AGE_OF_DGPS_DATA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  DGPS station ID
  public var DGPS_ID: UInt16 { let o = _accessor.offset(VTOFFSET.DGPS_ID.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Speed in meters per second
  public var SPEED: Double { let o = _accessor.offset(VTOFFSET.SPEED.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Course/heading in degrees true
  public var COURSE: Double { let o = _accessor.offset(VTOFFSET.COURSE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startGPXWaypoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 22) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(ELEVATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ELEVATION, def: 0.0, at: VTOFFSET.ELEVATION.p) }
  public static func add(TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME, at: VTOFFSET.TIME.p) }
  public static func add(MAGVAR: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAGVAR, def: 0.0, at: VTOFFSET.MAGVAR.p) }
  public static func add(GEOID_HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GEOID_HEIGHT, def: 0.0, at: VTOFFSET.GEOID_HEIGHT.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOURCE, at: VTOFFSET.SOURCE.p) }
  public static func addVectorOf(LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINKS, at: VTOFFSET.LINKS.p) }
  public static func add(SYMBOL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SYMBOL, at: VTOFFSET.SYMBOL.p) }
  public static func add(TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE, at: VTOFFSET.TYPE.p) }
  public static func add(FIX: GPXFixType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FIX.rawValue, def: 0, at: VTOFFSET.FIX.p) }
  public static func add(SAT: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SAT, def: 0, at: VTOFFSET.SAT.p) }
  public static func add(HDOP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HDOP, def: 0.0, at: VTOFFSET.HDOP.p) }
  public static func add(VDOP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VDOP, def: 0.0, at: VTOFFSET.VDOP.p) }
  public static func add(PDOP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PDOP, def: 0.0, at: VTOFFSET.PDOP.p) }
  public static func add(AGE_OF_DGPS_DATA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AGE_OF_DGPS_DATA, def: 0.0, at: VTOFFSET.AGE_OF_DGPS_DATA.p) }
  public static func add(DGPS_ID: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DGPS_ID, def: 0, at: VTOFFSET.DGPS_ID.p) }
  public static func add(SPEED: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SPEED, def: 0.0, at: VTOFFSET.SPEED.p) }
  public static func add(COURSE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COURSE, def: 0.0, at: VTOFFSET.COURSE.p) }
  public static func endGPXWaypoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPXWaypoint(
    _ fbb: inout FlatBufferBuilder,
    LATITUDE: Double = 0.0,
    LONGITUDE: Double = 0.0,
    ELEVATION: Double = 0.0,
    TIMEOffset TIME: Offset = Offset(),
    MAGVAR: Double = 0.0,
    GEOID_HEIGHT: Double = 0.0,
    NAMEOffset NAME: Offset = Offset(),
    COMMENTOffset COMMENT: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    SOURCEOffset SOURCE: Offset = Offset(),
    LINKSVectorOffset LINKS: Offset = Offset(),
    SYMBOLOffset SYMBOL: Offset = Offset(),
    TYPEOffset TYPE: Offset = Offset(),
    FIX: GPXFixType = .none_,
    SAT: UInt16 = 0,
    HDOP: Double = 0.0,
    VDOP: Double = 0.0,
    PDOP: Double = 0.0,
    AGE_OF_DGPS_DATA: Double = 0.0,
    DGPS_ID: UInt16 = 0,
    SPEED: Double = 0.0,
    COURSE: Double = 0.0
  ) -> Offset {
    let __start = GPXWaypoint.startGPXWaypoint(&fbb)
    GPXWaypoint.add(LATITUDE: LATITUDE, &fbb)
    GPXWaypoint.add(LONGITUDE: LONGITUDE, &fbb)
    GPXWaypoint.add(ELEVATION: ELEVATION, &fbb)
    GPXWaypoint.add(TIME: TIME, &fbb)
    GPXWaypoint.add(MAGVAR: MAGVAR, &fbb)
    GPXWaypoint.add(GEOID_HEIGHT: GEOID_HEIGHT, &fbb)
    GPXWaypoint.add(NAME: NAME, &fbb)
    GPXWaypoint.add(COMMENT: COMMENT, &fbb)
    GPXWaypoint.add(DESCRIPTION: DESCRIPTION, &fbb)
    GPXWaypoint.add(SOURCE: SOURCE, &fbb)
    GPXWaypoint.addVectorOf(LINKS: LINKS, &fbb)
    GPXWaypoint.add(SYMBOL: SYMBOL, &fbb)
    GPXWaypoint.add(TYPE: TYPE, &fbb)
    GPXWaypoint.add(FIX: FIX, &fbb)
    GPXWaypoint.add(SAT: SAT, &fbb)
    GPXWaypoint.add(HDOP: HDOP, &fbb)
    GPXWaypoint.add(VDOP: VDOP, &fbb)
    GPXWaypoint.add(PDOP: PDOP, &fbb)
    GPXWaypoint.add(AGE_OF_DGPS_DATA: AGE_OF_DGPS_DATA, &fbb)
    GPXWaypoint.add(DGPS_ID: DGPS_ID, &fbb)
    GPXWaypoint.add(SPEED: SPEED, &fbb)
    GPXWaypoint.add(COURSE: COURSE, &fbb)
    return GPXWaypoint.endGPXWaypoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ELEVATION.p, fieldName: "ELEVATION", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TIME.p, fieldName: "TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAGVAR.p, fieldName: "MAGVAR", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.GEOID_HEIGHT.p, fieldName: "GEOID_HEIGHT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOURCE.p, fieldName: "SOURCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LINKS.p, fieldName: "LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXLink>, GPXLink>>.self)
    try _v.visit(field: VTOFFSET.SYMBOL.p, fieldName: "SYMBOL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FIX.p, fieldName: "FIX", required: false, type: GPXFixType.self)
    try _v.visit(field: VTOFFSET.SAT.p, fieldName: "SAT", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.HDOP.p, fieldName: "HDOP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VDOP.p, fieldName: "VDOP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PDOP.p, fieldName: "PDOP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AGE_OF_DGPS_DATA.p, fieldName: "AGE_OF_DGPS_DATA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DGPS_ID.p, fieldName: "DGPS_ID", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.SPEED.p, fieldName: "SPEED", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COURSE.p, fieldName: "COURSE", required: false, type: Double.self)
    _v.finish()
  }
}

///  Track segment (continuous span of track points)
public struct GPXTrackSegment: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPXTrackSegment.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case POINTS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Ordered track points in this segment
  public var hasPoints: Bool { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? false : true }
  public var POINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POINTS(at index: Int32) -> GPXWaypoint? { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? nil : GPXWaypoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGPXTrackSegment(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(POINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINTS, at: VTOFFSET.POINTS.p) }
  public static func endGPXTrackSegment(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPXTrackSegment(
    _ fbb: inout FlatBufferBuilder,
    POINTSVectorOffset POINTS: Offset = Offset()
  ) -> Offset {
    let __start = GPXTrackSegment.startGPXTrackSegment(&fbb)
    GPXTrackSegment.addVectorOf(POINTS: POINTS, &fbb)
    return GPXTrackSegment.endGPXTrackSegment(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.POINTS.p, fieldName: "POINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXWaypoint>, GPXWaypoint>>.self)
    _v.finish()
  }
}

///  Track (ordered list of track segments)
public struct GPXTrack: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPXTrack.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case COMMENT = 6
    case DESCRIPTION = 8
    case SOURCE = 10
    case LINKS = 12
    case NUMBER = 14
    case TYPE = 16
    case SEGMENTS = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Track name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Comment
  public var COMMENT: String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMENT.v) }
  ///  Description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Source of data
  public var SOURCE: String? { let o = _accessor.offset(VTOFFSET.SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOURCE.v) }
  ///  Links to additional information
  public var hasLinks: Bool { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? false : true }
  public var LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LINKS(at index: Int32) -> GPXLink? { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? nil : GPXLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Track number
  public var NUMBER: UInt32 { let o = _accessor.offset(VTOFFSET.NUMBER.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Type/category
  public var TYPE: String? { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE.v) }
  ///  Track segments
  public var hasSegments: Bool { let o = _accessor.offset(VTOFFSET.SEGMENTS.v); return o == 0 ? false : true }
  public var SEGMENTSCount: Int32 { let o = _accessor.offset(VTOFFSET.SEGMENTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SEGMENTS(at index: Int32) -> GPXTrackSegment? { let o = _accessor.offset(VTOFFSET.SEGMENTS.v); return o == 0 ? nil : GPXTrackSegment(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGPXTrack(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOURCE, at: VTOFFSET.SOURCE.p) }
  public static func addVectorOf(LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINKS, at: VTOFFSET.LINKS.p) }
  public static func add(NUMBER: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NUMBER, def: 0, at: VTOFFSET.NUMBER.p) }
  public static func add(TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE, at: VTOFFSET.TYPE.p) }
  public static func addVectorOf(SEGMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SEGMENTS, at: VTOFFSET.SEGMENTS.p) }
  public static func endGPXTrack(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPXTrack(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    COMMENTOffset COMMENT: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    SOURCEOffset SOURCE: Offset = Offset(),
    LINKSVectorOffset LINKS: Offset = Offset(),
    NUMBER: UInt32 = 0,
    TYPEOffset TYPE: Offset = Offset(),
    SEGMENTSVectorOffset SEGMENTS: Offset = Offset()
  ) -> Offset {
    let __start = GPXTrack.startGPXTrack(&fbb)
    GPXTrack.add(NAME: NAME, &fbb)
    GPXTrack.add(COMMENT: COMMENT, &fbb)
    GPXTrack.add(DESCRIPTION: DESCRIPTION, &fbb)
    GPXTrack.add(SOURCE: SOURCE, &fbb)
    GPXTrack.addVectorOf(LINKS: LINKS, &fbb)
    GPXTrack.add(NUMBER: NUMBER, &fbb)
    GPXTrack.add(TYPE: TYPE, &fbb)
    GPXTrack.addVectorOf(SEGMENTS: SEGMENTS, &fbb)
    return GPXTrack.endGPXTrack(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOURCE.p, fieldName: "SOURCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LINKS.p, fieldName: "LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXLink>, GPXLink>>.self)
    try _v.visit(field: VTOFFSET.NUMBER.p, fieldName: "NUMBER", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SEGMENTS.p, fieldName: "SEGMENTS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXTrackSegment>, GPXTrackSegment>>.self)
    _v.finish()
  }
}

///  Route (ordered list of waypoints for navigation)
public struct GPXRoute: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPXRoute.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case COMMENT = 6
    case DESCRIPTION = 8
    case SOURCE = 10
    case LINKS = 12
    case NUMBER = 14
    case TYPE = 16
    case POINTS = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Route name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Comment
  public var COMMENT: String? { let o = _accessor.offset(VTOFFSET.COMMENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMENT.v) }
  ///  Description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Source of data
  public var SOURCE: String? { let o = _accessor.offset(VTOFFSET.SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOURCE.v) }
  ///  Links to additional information
  public var hasLinks: Bool { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? false : true }
  public var LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LINKS(at index: Int32) -> GPXLink? { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? nil : GPXLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Route number
  public var NUMBER: UInt32 { let o = _accessor.offset(VTOFFSET.NUMBER.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  ///  Type/category
  public var TYPE: String? { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TYPE.v) }
  ///  Route points (ordered waypoints)
  public var hasPoints: Bool { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? false : true }
  public var POINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POINTS(at index: Int32) -> GPXWaypoint? { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? nil : GPXWaypoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGPXRoute(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(COMMENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMENT, at: VTOFFSET.COMMENT.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOURCE, at: VTOFFSET.SOURCE.p) }
  public static func addVectorOf(LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINKS, at: VTOFFSET.LINKS.p) }
  public static func add(NUMBER: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NUMBER, def: 0, at: VTOFFSET.NUMBER.p) }
  public static func add(TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TYPE, at: VTOFFSET.TYPE.p) }
  public static func addVectorOf(POINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINTS, at: VTOFFSET.POINTS.p) }
  public static func endGPXRoute(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPXRoute(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    COMMENTOffset COMMENT: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    SOURCEOffset SOURCE: Offset = Offset(),
    LINKSVectorOffset LINKS: Offset = Offset(),
    NUMBER: UInt32 = 0,
    TYPEOffset TYPE: Offset = Offset(),
    POINTSVectorOffset POINTS: Offset = Offset()
  ) -> Offset {
    let __start = GPXRoute.startGPXRoute(&fbb)
    GPXRoute.add(NAME: NAME, &fbb)
    GPXRoute.add(COMMENT: COMMENT, &fbb)
    GPXRoute.add(DESCRIPTION: DESCRIPTION, &fbb)
    GPXRoute.add(SOURCE: SOURCE, &fbb)
    GPXRoute.addVectorOf(LINKS: LINKS, &fbb)
    GPXRoute.add(NUMBER: NUMBER, &fbb)
    GPXRoute.add(TYPE: TYPE, &fbb)
    GPXRoute.addVectorOf(POINTS: POINTS, &fbb)
    return GPXRoute.endGPXRoute(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COMMENT.p, fieldName: "COMMENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOURCE.p, fieldName: "SOURCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LINKS.p, fieldName: "LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXLink>, GPXLink>>.self)
    try _v.visit(field: VTOFFSET.NUMBER.p, fieldName: "NUMBER", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POINTS.p, fieldName: "POINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXWaypoint>, GPXWaypoint>>.self)
    _v.finish()
  }
}

///  GPX Document
public struct GPX: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$GPX" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: GPX.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case VERSION = 4
    case CREATOR = 6
    case NAME = 8
    case DESCRIPTION = 10
    case AUTHOR_NAME = 12
    case AUTHOR_EMAIL = 14
    case AUTHOR_LINK = 16
    case COPYRIGHT_AUTHOR = 18
    case COPYRIGHT_YEAR = 20
    case COPYRIGHT_LICENSE = 22
    case LINKS = 24
    case TIME = 26
    case KEYWORDS = 28
    case BOUNDS_MIN_LAT = 30
    case BOUNDS_MIN_LON = 32
    case BOUNDS_MAX_LAT = 34
    case BOUNDS_MAX_LON = 36
    case WAYPOINTS = 38
    case ROUTES = 40
    case TRACKS = 42
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  GPX schema version
  public var VERSION: String? { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VERSIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VERSION.v) }
  ///  Creator software/organization
  public var CREATOR: String? { let o = _accessor.offset(VTOFFSET.CREATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CREATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CREATOR.v) }
  ///  File name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  File description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Person or organization who created the file
  public var AUTHOR_NAME: String? { let o = _accessor.offset(VTOFFSET.AUTHOR_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AUTHOR_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AUTHOR_NAME.v) }
  ///  Author email
  public var AUTHOR_EMAIL: String? { let o = _accessor.offset(VTOFFSET.AUTHOR_EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AUTHOR_EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AUTHOR_EMAIL.v) }
  ///  Author link
  public var AUTHOR_LINK: GPXLink? { let o = _accessor.offset(VTOFFSET.AUTHOR_LINK.v); return o == 0 ? nil : GPXLink(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Copyright holder
  public var COPYRIGHT_AUTHOR: String? { let o = _accessor.offset(VTOFFSET.COPYRIGHT_AUTHOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COPYRIGHT_AUTHORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COPYRIGHT_AUTHOR.v) }
  ///  Copyright year
  public var COPYRIGHT_YEAR: String? { let o = _accessor.offset(VTOFFSET.COPYRIGHT_YEAR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COPYRIGHT_YEARSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COPYRIGHT_YEAR.v) }
  ///  Copyright license URL
  public var COPYRIGHT_LICENSE: String? { let o = _accessor.offset(VTOFFSET.COPYRIGHT_LICENSE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COPYRIGHT_LICENSESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COPYRIGHT_LICENSE.v) }
  ///  Links to additional information
  public var hasLinks: Bool { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? false : true }
  public var LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LINKS(at index: Int32) -> GPXLink? { let o = _accessor.offset(VTOFFSET.LINKS.v); return o == 0 ? nil : GPXLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Creation timestamp (ISO 8601)
  public var TIME: String? { let o = _accessor.offset(VTOFFSET.TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIME.v) }
  ///  Keywords
  public var KEYWORDS: String? { let o = _accessor.offset(VTOFFSET.KEYWORDS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KEYWORDSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KEYWORDS.v) }
  ///  Minimum latitude of bounding box
  public var BOUNDS_MIN_LAT: Double { let o = _accessor.offset(VTOFFSET.BOUNDS_MIN_LAT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Minimum longitude of bounding box
  public var BOUNDS_MIN_LON: Double { let o = _accessor.offset(VTOFFSET.BOUNDS_MIN_LON.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum latitude of bounding box
  public var BOUNDS_MAX_LAT: Double { let o = _accessor.offset(VTOFFSET.BOUNDS_MAX_LAT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Maximum longitude of bounding box
  public var BOUNDS_MAX_LON: Double { let o = _accessor.offset(VTOFFSET.BOUNDS_MAX_LON.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Waypoints
  public var hasWaypoints: Bool { let o = _accessor.offset(VTOFFSET.WAYPOINTS.v); return o == 0 ? false : true }
  public var WAYPOINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.WAYPOINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func WAYPOINTS(at index: Int32) -> GPXWaypoint? { let o = _accessor.offset(VTOFFSET.WAYPOINTS.v); return o == 0 ? nil : GPXWaypoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Routes
  public var hasRoutes: Bool { let o = _accessor.offset(VTOFFSET.ROUTES.v); return o == 0 ? false : true }
  public var ROUTESCount: Int32 { let o = _accessor.offset(VTOFFSET.ROUTES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ROUTES(at index: Int32) -> GPXRoute? { let o = _accessor.offset(VTOFFSET.ROUTES.v); return o == 0 ? nil : GPXRoute(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Tracks
  public var hasTracks: Bool { let o = _accessor.offset(VTOFFSET.TRACKS.v); return o == 0 ? false : true }
  public var TRACKSCount: Int32 { let o = _accessor.offset(VTOFFSET.TRACKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TRACKS(at index: Int32) -> GPXTrack? { let o = _accessor.offset(VTOFFSET.TRACKS.v); return o == 0 ? nil : GPXTrack(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startGPX(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 20) }
  public static func add(VERSION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VERSION, at: VTOFFSET.VERSION.p) }
  public static func add(CREATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CREATOR, at: VTOFFSET.CREATOR.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(AUTHOR_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AUTHOR_NAME, at: VTOFFSET.AUTHOR_NAME.p) }
  public static func add(AUTHOR_EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AUTHOR_EMAIL, at: VTOFFSET.AUTHOR_EMAIL.p) }
  public static func add(AUTHOR_LINK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AUTHOR_LINK, at: VTOFFSET.AUTHOR_LINK.p) }
  public static func add(COPYRIGHT_AUTHOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COPYRIGHT_AUTHOR, at: VTOFFSET.COPYRIGHT_AUTHOR.p) }
  public static func add(COPYRIGHT_YEAR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COPYRIGHT_YEAR, at: VTOFFSET.COPYRIGHT_YEAR.p) }
  public static func add(COPYRIGHT_LICENSE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COPYRIGHT_LICENSE, at: VTOFFSET.COPYRIGHT_LICENSE.p) }
  public static func addVectorOf(LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINKS, at: VTOFFSET.LINKS.p) }
  public static func add(TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME, at: VTOFFSET.TIME.p) }
  public static func add(KEYWORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEYWORDS, at: VTOFFSET.KEYWORDS.p) }
  public static func add(BOUNDS_MIN_LAT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BOUNDS_MIN_LAT, def: 0.0, at: VTOFFSET.BOUNDS_MIN_LAT.p) }
  public static func add(BOUNDS_MIN_LON: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BOUNDS_MIN_LON, def: 0.0, at: VTOFFSET.BOUNDS_MIN_LON.p) }
  public static func add(BOUNDS_MAX_LAT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BOUNDS_MAX_LAT, def: 0.0, at: VTOFFSET.BOUNDS_MAX_LAT.p) }
  public static func add(BOUNDS_MAX_LON: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BOUNDS_MAX_LON, def: 0.0, at: VTOFFSET.BOUNDS_MAX_LON.p) }
  public static func addVectorOf(WAYPOINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WAYPOINTS, at: VTOFFSET.WAYPOINTS.p) }
  public static func addVectorOf(ROUTES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ROUTES, at: VTOFFSET.ROUTES.p) }
  public static func addVectorOf(TRACKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRACKS, at: VTOFFSET.TRACKS.p) }
  public static func endGPX(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGPX(
    _ fbb: inout FlatBufferBuilder,
    VERSIONOffset VERSION: Offset = Offset(),
    CREATOROffset CREATOR: Offset = Offset(),
    NAMEOffset NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    AUTHOR_NAMEOffset AUTHOR_NAME: Offset = Offset(),
    AUTHOR_EMAILOffset AUTHOR_EMAIL: Offset = Offset(),
    AUTHOR_LINKOffset AUTHOR_LINK: Offset = Offset(),
    COPYRIGHT_AUTHOROffset COPYRIGHT_AUTHOR: Offset = Offset(),
    COPYRIGHT_YEAROffset COPYRIGHT_YEAR: Offset = Offset(),
    COPYRIGHT_LICENSEOffset COPYRIGHT_LICENSE: Offset = Offset(),
    LINKSVectorOffset LINKS: Offset = Offset(),
    TIMEOffset TIME: Offset = Offset(),
    KEYWORDSOffset KEYWORDS: Offset = Offset(),
    BOUNDS_MIN_LAT: Double = 0.0,
    BOUNDS_MIN_LON: Double = 0.0,
    BOUNDS_MAX_LAT: Double = 0.0,
    BOUNDS_MAX_LON: Double = 0.0,
    WAYPOINTSVectorOffset WAYPOINTS: Offset = Offset(),
    ROUTESVectorOffset ROUTES: Offset = Offset(),
    TRACKSVectorOffset TRACKS: Offset = Offset()
  ) -> Offset {
    let __start = GPX.startGPX(&fbb)
    GPX.add(VERSION: VERSION, &fbb)
    GPX.add(CREATOR: CREATOR, &fbb)
    GPX.add(NAME: NAME, &fbb)
    GPX.add(DESCRIPTION: DESCRIPTION, &fbb)
    GPX.add(AUTHOR_NAME: AUTHOR_NAME, &fbb)
    GPX.add(AUTHOR_EMAIL: AUTHOR_EMAIL, &fbb)
    GPX.add(AUTHOR_LINK: AUTHOR_LINK, &fbb)
    GPX.add(COPYRIGHT_AUTHOR: COPYRIGHT_AUTHOR, &fbb)
    GPX.add(COPYRIGHT_YEAR: COPYRIGHT_YEAR, &fbb)
    GPX.add(COPYRIGHT_LICENSE: COPYRIGHT_LICENSE, &fbb)
    GPX.addVectorOf(LINKS: LINKS, &fbb)
    GPX.add(TIME: TIME, &fbb)
    GPX.add(KEYWORDS: KEYWORDS, &fbb)
    GPX.add(BOUNDS_MIN_LAT: BOUNDS_MIN_LAT, &fbb)
    GPX.add(BOUNDS_MIN_LON: BOUNDS_MIN_LON, &fbb)
    GPX.add(BOUNDS_MAX_LAT: BOUNDS_MAX_LAT, &fbb)
    GPX.add(BOUNDS_MAX_LON: BOUNDS_MAX_LON, &fbb)
    GPX.addVectorOf(WAYPOINTS: WAYPOINTS, &fbb)
    GPX.addVectorOf(ROUTES: ROUTES, &fbb)
    GPX.addVectorOf(TRACKS: TRACKS, &fbb)
    return GPX.endGPX(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CREATOR.p, fieldName: "CREATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AUTHOR_NAME.p, fieldName: "AUTHOR_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AUTHOR_EMAIL.p, fieldName: "AUTHOR_EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AUTHOR_LINK.p, fieldName: "AUTHOR_LINK", required: false, type: ForwardOffset<GPXLink>.self)
    try _v.visit(field: VTOFFSET.COPYRIGHT_AUTHOR.p, fieldName: "COPYRIGHT_AUTHOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COPYRIGHT_YEAR.p, fieldName: "COPYRIGHT_YEAR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COPYRIGHT_LICENSE.p, fieldName: "COPYRIGHT_LICENSE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LINKS.p, fieldName: "LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXLink>, GPXLink>>.self)
    try _v.visit(field: VTOFFSET.TIME.p, fieldName: "TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEYWORDS.p, fieldName: "KEYWORDS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.BOUNDS_MIN_LAT.p, fieldName: "BOUNDS_MIN_LAT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BOUNDS_MIN_LON.p, fieldName: "BOUNDS_MIN_LON", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BOUNDS_MAX_LAT.p, fieldName: "BOUNDS_MAX_LAT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BOUNDS_MAX_LON.p, fieldName: "BOUNDS_MAX_LON", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.WAYPOINTS.p, fieldName: "WAYPOINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXWaypoint>, GPXWaypoint>>.self)
    try _v.visit(field: VTOFFSET.ROUTES.p, fieldName: "ROUTES", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXRoute>, GPXRoute>>.self)
    try _v.visit(field: VTOFFSET.TRACKS.p, fieldName: "TRACKS", required: false, type: ForwardOffset<Vector<ForwardOffset<GPXTrack>, GPXTrack>>.self)
    _v.finish()
  }
}

