// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum FCSMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case off = 0
  case standby = 1
  case ranging = 2
  case tracking = 3
  case solution = 4
  case ccip = 5
  case ccrp = 6
  case manual = 7

  public static var max: FCSMode { return .manual }
  public static var min: FCSMode { return .off }
}


public enum LeadMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case predictive = 1
  case collision = 2
  case constantBearing = 3
  case pursuit = 4

  public static var max: LeadMethod { return .pursuit }
  public static var min: LeadMethod { return .none_ }
}


public enum RangefinderType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case stadiametric = 0
  case stereoscopic = 1
  case coincidence = 2
  case laser = 3
  case radar = 4

  public static var max: RangefinderType { return .radar }
  public static var min: RangefinderType { return .stadiametric }
}


///  Fire Control Systems
public struct FCS: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$FCS" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: FCS.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MODE = 4
    case LEAD_METHOD = 6
    case RANGEFINDER_TYPE = 8
    case AMMO_SELECTED = 10
    case TARGET = 12
    case SOLUTION = 14
    case LAST_RANGE = 16
    case RANGE_RATE = 18
    case ROUNDS_REMAINING = 20
    case TEMPERATURE = 22
    case RESERVED = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var MODE: UInt8 { let o = _accessor.offset(VTOFFSET.MODE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var LEAD_METHOD: UInt8 { let o = _accessor.offset(VTOFFSET.LEAD_METHOD.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var RANGEFINDER_TYPE: UInt8 { let o = _accessor.offset(VTOFFSET.RANGEFINDER_TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var AMMO_SELECTED: UInt8 { let o = _accessor.offset(VTOFFSET.AMMO_SELECTED.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var TARGET: String? { let o = _accessor.offset(VTOFFSET.TARGET.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TARGETSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TARGET.v) }
  public var SOLUTION: String? { let o = _accessor.offset(VTOFFSET.SOLUTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOLUTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOLUTION.v) }
  public var LAST_RANGE: Double { let o = _accessor.offset(VTOFFSET.LAST_RANGE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var RANGE_RATE: Double { let o = _accessor.offset(VTOFFSET.RANGE_RATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ROUNDS_REMAINING: UInt16 { let o = _accessor.offset(VTOFFSET.ROUNDS_REMAINING.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var TEMPERATURE: Float32 { let o = _accessor.offset(VTOFFSET.TEMPERATURE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var hasReserved: Bool { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? false : true }
  public var RESERVEDCount: Int32 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RESERVED(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var RESERVED: [UInt8] { return _accessor.getVector(at: VTOFFSET.RESERVED.v) ?? [] }
  public static func startFCS(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(MODE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MODE, def: 0, at: VTOFFSET.MODE.p) }
  public static func add(LEAD_METHOD: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LEAD_METHOD, def: 0, at: VTOFFSET.LEAD_METHOD.p) }
  public static func add(RANGEFINDER_TYPE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RANGEFINDER_TYPE, def: 0, at: VTOFFSET.RANGEFINDER_TYPE.p) }
  public static func add(AMMO_SELECTED: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AMMO_SELECTED, def: 0, at: VTOFFSET.AMMO_SELECTED.p) }
  public static func add(TARGET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TARGET, at: VTOFFSET.TARGET.p) }
  public static func add(SOLUTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOLUTION, at: VTOFFSET.SOLUTION.p) }
  public static func add(LAST_RANGE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LAST_RANGE, def: 0.0, at: VTOFFSET.LAST_RANGE.p) }
  public static func add(RANGE_RATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RANGE_RATE, def: 0.0, at: VTOFFSET.RANGE_RATE.p) }
  public static func add(ROUNDS_REMAINING: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ROUNDS_REMAINING, def: 0, at: VTOFFSET.ROUNDS_REMAINING.p) }
  public static func add(TEMPERATURE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TEMPERATURE, def: 0.0, at: VTOFFSET.TEMPERATURE.p) }
  public static func addVectorOf(RESERVED: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESERVED, at: VTOFFSET.RESERVED.p) }
  public static func endFCS(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFCS(
    _ fbb: inout FlatBufferBuilder,
    MODE: UInt8 = 0,
    LEAD_METHOD: UInt8 = 0,
    RANGEFINDER_TYPE: UInt8 = 0,
    AMMO_SELECTED: UInt8 = 0,
    TARGETOffset TARGET: Offset = Offset(),
    SOLUTIONOffset SOLUTION: Offset = Offset(),
    LAST_RANGE: Double = 0.0,
    RANGE_RATE: Double = 0.0,
    ROUNDS_REMAINING: UInt16 = 0,
    TEMPERATURE: Float32 = 0.0,
    RESERVEDVectorOffset RESERVED: Offset = Offset()
  ) -> Offset {
    let __start = FCS.startFCS(&fbb)
    FCS.add(MODE: MODE, &fbb)
    FCS.add(LEAD_METHOD: LEAD_METHOD, &fbb)
    FCS.add(RANGEFINDER_TYPE: RANGEFINDER_TYPE, &fbb)
    FCS.add(AMMO_SELECTED: AMMO_SELECTED, &fbb)
    FCS.add(TARGET: TARGET, &fbb)
    FCS.add(SOLUTION: SOLUTION, &fbb)
    FCS.add(LAST_RANGE: LAST_RANGE, &fbb)
    FCS.add(RANGE_RATE: RANGE_RATE, &fbb)
    FCS.add(ROUNDS_REMAINING: ROUNDS_REMAINING, &fbb)
    FCS.add(TEMPERATURE: TEMPERATURE, &fbb)
    FCS.addVectorOf(RESERVED: RESERVED, &fbb)
    return FCS.endFCS(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MODE.p, fieldName: "MODE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.LEAD_METHOD.p, fieldName: "LEAD_METHOD", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.RANGEFINDER_TYPE.p, fieldName: "RANGEFINDER_TYPE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.AMMO_SELECTED.p, fieldName: "AMMO_SELECTED", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.TARGET.p, fieldName: "TARGET", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOLUTION.p, fieldName: "SOLUTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LAST_RANGE.p, fieldName: "LAST_RANGE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.RANGE_RATE.p, fieldName: "RANGE_RATE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ROUNDS_REMAINING.p, fieldName: "ROUNDS_REMAINING", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.TEMPERATURE.p, fieldName: "TEMPERATURE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.RESERVED.p, fieldName: "RESERVED", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

