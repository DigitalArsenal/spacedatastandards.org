// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Burn Out Vector Message
public struct BOV: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$BOV" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BOV.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case E_COORDINATE = 4
    case F_COORDINATE = 6
    case G_COORDINATE = 8
    case E_DOT = 10
    case F_DOT = 12
    case G_DOT = 14
    case EPOCH_TIME = 16
    case TIME_FROM_LAUNCH = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var E_COORDINATE: Double { let o = _accessor.offset(VTOFFSET.E_COORDINATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var F_COORDINATE: Double { let o = _accessor.offset(VTOFFSET.F_COORDINATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var G_COORDINATE: Double { let o = _accessor.offset(VTOFFSET.G_COORDINATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var E_DOT: Double { let o = _accessor.offset(VTOFFSET.E_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var F_DOT: Double { let o = _accessor.offset(VTOFFSET.F_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var G_DOT: Double { let o = _accessor.offset(VTOFFSET.G_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var EPOCH_TIME: String? { let o = _accessor.offset(VTOFFSET.EPOCH_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCH_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH_TIME.v) }
  public var TIME_FROM_LAUNCH: Double { let o = _accessor.offset(VTOFFSET.TIME_FROM_LAUNCH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startBOV(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(E_COORDINATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: E_COORDINATE, def: 0.0, at: VTOFFSET.E_COORDINATE.p) }
  public static func add(F_COORDINATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: F_COORDINATE, def: 0.0, at: VTOFFSET.F_COORDINATE.p) }
  public static func add(G_COORDINATE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: G_COORDINATE, def: 0.0, at: VTOFFSET.G_COORDINATE.p) }
  public static func add(E_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: E_DOT, def: 0.0, at: VTOFFSET.E_DOT.p) }
  public static func add(F_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: F_DOT, def: 0.0, at: VTOFFSET.F_DOT.p) }
  public static func add(G_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: G_DOT, def: 0.0, at: VTOFFSET.G_DOT.p) }
  public static func add(EPOCH_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH_TIME, at: VTOFFSET.EPOCH_TIME.p) }
  public static func add(TIME_FROM_LAUNCH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_FROM_LAUNCH, def: 0.0, at: VTOFFSET.TIME_FROM_LAUNCH.p) }
  public static func endBOV(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBOV(
    _ fbb: inout FlatBufferBuilder,
    E_COORDINATE: Double = 0.0,
    F_COORDINATE: Double = 0.0,
    G_COORDINATE: Double = 0.0,
    E_DOT: Double = 0.0,
    F_DOT: Double = 0.0,
    G_DOT: Double = 0.0,
    EPOCH_TIMEOffset EPOCH_TIME: Offset = Offset(),
    TIME_FROM_LAUNCH: Double = 0.0
  ) -> Offset {
    let __start = BOV.startBOV(&fbb)
    BOV.add(E_COORDINATE: E_COORDINATE, &fbb)
    BOV.add(F_COORDINATE: F_COORDINATE, &fbb)
    BOV.add(G_COORDINATE: G_COORDINATE, &fbb)
    BOV.add(E_DOT: E_DOT, &fbb)
    BOV.add(F_DOT: F_DOT, &fbb)
    BOV.add(G_DOT: G_DOT, &fbb)
    BOV.add(EPOCH_TIME: EPOCH_TIME, &fbb)
    BOV.add(TIME_FROM_LAUNCH: TIME_FROM_LAUNCH, &fbb)
    return BOV.endBOV(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.E_COORDINATE.p, fieldName: "E_COORDINATE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.F_COORDINATE.p, fieldName: "F_COORDINATE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.G_COORDINATE.p, fieldName: "G_COORDINATE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.E_DOT.p, fieldName: "E_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.F_DOT.p, fieldName: "F_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.G_DOT.p, fieldName: "G_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.EPOCH_TIME.p, fieldName: "EPOCH_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_FROM_LAUNCH.p, fieldName: "TIME_FROM_LAUNCH", required: false, type: Double.self)
    _v.finish()
  }
}

public struct BOVCOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$BOV" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: BOVCOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> BOV? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : BOV(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startBOVCOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endBOVCOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBOVCOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = BOVCOLLECTION.startBOVCOLLECTION(&fbb)
    BOVCOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return BOVCOLLECTION.endBOVCOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<BOV>, BOV>>.self)
    _v.finish()
  }
}

