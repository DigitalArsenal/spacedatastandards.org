// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum trackStatus: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case active = 0
  case dropped = 1
  case tentative = 2
  case confirmed = 3
  case coasted = 4
  case dead = 5

  public static var max: trackStatus { return .dead }
  public static var min: trackStatus { return .active }
}


public enum trackEnvironment: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case space = 0
  case air = 1
  case surface = 2
  case subsurface = 3
  case land = 4
  case unknown = 5

  public static var max: trackEnvironment { return .unknown }
  public static var min: trackEnvironment { return .space }
}


///  Track
public struct TRK: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$TRK" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: TRK.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case CNTCT = 6
    case MSG_TS = 8
    case MSN_ID = 10
    case ASSET_NAT = 12
    case ASSET = 14
    case SENSOR_ID = 16
    case SEN_QUAL = 18
    case TRK_ID = 20
    case TRK_NUM = 22
    case TRK_STAT = 24
    case OBJ_NAT = 26
    case OBJ_ID = 28
    case OBJ_TYPE = 30
    case OBJ_SPEC = 32
    case OBJ_PLAT = 34
    case OBJ_ACT = 36
    case MOD_TYPE = 38
    case TRK_ITM_ID = 40
    case TS = 42
    case TRK_QUAL = 44
    case TRK_PT_TYPE = 46
    case OBJ_IDENT = 48
    case IDENT_CRED = 50
    case IDENT_REL = 52
    case IDENT_AMP = 54
    case ENVIRONMENT = 56
    case ENVIRONMENT_CONF = 58
    case TRK_CONF = 60
    case LAT = 62
    case LON = 64
    case ALT = 66
    case SPD = 68
    case HDNG = 70
    case COURSE = 72
    case SRC_TYPS = 74
    case SRC_IDS = 76
    case CALL_SIGN = 78
    case MULTI_SOURCE = 80
    case J_SERIES = 82
    case STRENGTH = 84
    case M1 = 86
    case M1V = 88
    case M2 = 90
    case M2V = 92
    case M3A = 94
    case M3AV = 96
    case TAGS = 98
    case TRACK_START_TIME = 100
    case TRACK_STEP_SIZE = 102
    case TRACK_COMPONENTS = 104
    case ECEF_POS = 106
    case ECEF_VEL = 108
    case ECEF_ACC = 110
    case LC_POS = 112
    case LC_VEL = 114
    case LC_ACC = 116
    case COV = 118
    case ERR_ELLP = 120
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Contact reference
  public var CNTCT: String? { let o = _accessor.offset(VTOFFSET.CNTCT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CNTCTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CNTCT.v) }
  ///  Message timestamp (ISO 8601)
  public var MSG_TS: String? { let o = _accessor.offset(VTOFFSET.MSG_TS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MSG_TSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MSG_TS.v) }
  ///  Mission identifier
  public var MSN_ID: String? { let o = _accessor.offset(VTOFFSET.MSN_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MSN_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MSN_ID.v) }
  ///  Asset nationality
  public var ASSET_NAT: String? { let o = _accessor.offset(VTOFFSET.ASSET_NAT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ASSET_NATSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ASSET_NAT.v) }
  ///  Asset identifier
  public var ASSET: String? { let o = _accessor.offset(VTOFFSET.ASSET.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ASSETSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ASSET.v) }
  ///  Sensor identifier
  public var SENSOR_ID: String? { let o = _accessor.offset(VTOFFSET.SENSOR_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SENSOR_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SENSOR_ID.v) }
  ///  Sensor quality assessment
  public var SEN_QUAL: String? { let o = _accessor.offset(VTOFFSET.SEN_QUAL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SEN_QUALSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SEN_QUAL.v) }
  ///  Track identifier
  public var TRK_ID: String? { let o = _accessor.offset(VTOFFSET.TRK_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRK_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRK_ID.v) }
  ///  Track number
  public var TRK_NUM: String? { let o = _accessor.offset(VTOFFSET.TRK_NUM.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRK_NUMSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRK_NUM.v) }
  ///  Track status
  public var TRK_STAT: trackStatus { let o = _accessor.offset(VTOFFSET.TRK_STAT.v); return o == 0 ? .active : trackStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .active }
  ///  Object nationality
  public var OBJ_NAT: String? { let o = _accessor.offset(VTOFFSET.OBJ_NAT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_NATSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_NAT.v) }
  ///  Object identifier
  public var OBJ_ID: String? { let o = _accessor.offset(VTOFFSET.OBJ_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_ID.v) }
  ///  Object type classification
  public var OBJ_TYPE: String? { let o = _accessor.offset(VTOFFSET.OBJ_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_TYPE.v) }
  ///  Object specific type
  public var OBJ_SPEC: String? { let o = _accessor.offset(VTOFFSET.OBJ_SPEC.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_SPECSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_SPEC.v) }
  ///  Object platform type
  public var OBJ_PLAT: String? { let o = _accessor.offset(VTOFFSET.OBJ_PLAT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_PLATSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_PLAT.v) }
  ///  Object activity
  public var OBJ_ACT: String? { let o = _accessor.offset(VTOFFSET.OBJ_ACT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_ACTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_ACT.v) }
  ///  Mode type
  public var MOD_TYPE: String? { let o = _accessor.offset(VTOFFSET.MOD_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MOD_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MOD_TYPE.v) }
  ///  Track item identifier
  public var TRK_ITM_ID: String? { let o = _accessor.offset(VTOFFSET.TRK_ITM_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRK_ITM_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRK_ITM_ID.v) }
  ///  Track point timestamp (ISO 8601)
  public var TS: String? { let o = _accessor.offset(VTOFFSET.TS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TS.v) }
  ///  Track quality (0-15)
  public var TRK_QUAL: UInt8 { let o = _accessor.offset(VTOFFSET.TRK_QUAL.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Track point type
  public var TRK_PT_TYPE: String? { let o = _accessor.offset(VTOFFSET.TRK_PT_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRK_PT_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRK_PT_TYPE.v) }
  ///  Object identity assessment
  public var OBJ_IDENT: String? { let o = _accessor.offset(VTOFFSET.OBJ_IDENT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJ_IDENTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJ_IDENT.v) }
  ///  Identity credibility (1-6)
  public var IDENT_CRED: UInt8 { let o = _accessor.offset(VTOFFSET.IDENT_CRED.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Identity reliability (A-F)
  public var IDENT_REL: UInt8 { let o = _accessor.offset(VTOFFSET.IDENT_REL.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Identity amplification
  public var IDENT_AMP: String? { let o = _accessor.offset(VTOFFSET.IDENT_AMP.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDENT_AMPSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IDENT_AMP.v) }
  ///  Track environment
  public var ENVIRONMENT: trackEnvironment { let o = _accessor.offset(VTOFFSET.ENVIRONMENT.v); return o == 0 ? .space : trackEnvironment(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .space }
  ///  Environment confidence (0-1)
  public var ENVIRONMENT_CONF: Double { let o = _accessor.offset(VTOFFSET.ENVIRONMENT_CONF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Track confidence (0-1)
  public var TRK_CONF: Double { let o = _accessor.offset(VTOFFSET.TRK_CONF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Latitude (degrees)
  public var LAT: Double { let o = _accessor.offset(VTOFFSET.LAT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Longitude (degrees)
  public var LON: Double { let o = _accessor.offset(VTOFFSET.LON.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude (km)
  public var ALT: Double { let o = _accessor.offset(VTOFFSET.ALT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Speed (km/s)
  public var SPD: Double { let o = _accessor.offset(VTOFFSET.SPD.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Heading (degrees from north)
  public var HDNG: Double { let o = _accessor.offset(VTOFFSET.HDNG.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Course (degrees from north)
  public var COURSE: Double { let o = _accessor.offset(VTOFFSET.COURSE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Source types
  public var hasSrcTyps: Bool { let o = _accessor.offset(VTOFFSET.SRC_TYPS.v); return o == 0 ? false : true }
  public var SRC_TYPSCount: Int32 { let o = _accessor.offset(VTOFFSET.SRC_TYPS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SRC_TYPS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.SRC_TYPS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Source identifiers
  public var hasSrcIds: Bool { let o = _accessor.offset(VTOFFSET.SRC_IDS.v); return o == 0 ? false : true }
  public var SRC_IDSCount: Int32 { let o = _accessor.offset(VTOFFSET.SRC_IDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SRC_IDS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.SRC_IDS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Call sign
  public var CALL_SIGN: String? { let o = _accessor.offset(VTOFFSET.CALL_SIGN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CALL_SIGNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CALL_SIGN.v) }
  ///  True if fused from multiple sources
  public var MULTI_SOURCE: Bool { let o = _accessor.offset(VTOFFSET.MULTI_SOURCE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  J-series message type
  public var J_SERIES: String? { let o = _accessor.offset(VTOFFSET.J_SERIES.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var J_SERIESSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.J_SERIES.v) }
  ///  Force strength indicator
  public var STRENGTH: UInt16 { let o = _accessor.offset(VTOFFSET.STRENGTH.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Mode 1 code
  public var M1: UInt16 { let o = _accessor.offset(VTOFFSET.M1.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Mode 1 validity
  public var M1V: UInt8 { let o = _accessor.offset(VTOFFSET.M1V.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Mode 2 code
  public var M2: UInt16 { let o = _accessor.offset(VTOFFSET.M2.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Mode 2 validity
  public var M2V: UInt8 { let o = _accessor.offset(VTOFFSET.M2V.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Mode 3A code
  public var M3A: UInt16 { let o = _accessor.offset(VTOFFSET.M3A.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Mode 3A validity
  public var M3AV: UInt8 { let o = _accessor.offset(VTOFFSET.M3AV.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Associated tags
  public var hasTags: Bool { let o = _accessor.offset(VTOFFSET.TAGS.v); return o == 0 ? false : true }
  public var TAGSCount: Int32 { let o = _accessor.offset(VTOFFSET.TAGS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func TAGS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.TAGS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Start time for track data (ISO 8601)
  public var TRACK_START_TIME: String? { let o = _accessor.offset(VTOFFSET.TRACK_START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRACK_START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRACK_START_TIME.v) }
  ///  Time interval between track points (seconds)
  public var TRACK_STEP_SIZE: Double { let o = _accessor.offset(VTOFFSET.TRACK_STEP_SIZE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Number of components per point (default 3 for X, Y, Z)
  public var TRACK_COMPONENTS: UInt8 { let o = _accessor.offset(VTOFFSET.TRACK_COMPONENTS.v); return o == 0 ? 3 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  ECEF position as flat array [X0, Y0, Z0, X1, Y1, Z1, ...]
  public var hasEcefPos: Bool { let o = _accessor.offset(VTOFFSET.ECEF_POS.v); return o == 0 ? false : true }
  public var ECEF_POSCount: Int32 { let o = _accessor.offset(VTOFFSET.ECEF_POS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ECEF_POS(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.ECEF_POS.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var ECEF_POS: [Double] { return _accessor.getVector(at: VTOFFSET.ECEF_POS.v) ?? [] }
  ///  ECEF velocity as flat array [VX0, VY0, VZ0, VX1, VY1, VZ1, ...]
  public var hasEcefVel: Bool { let o = _accessor.offset(VTOFFSET.ECEF_VEL.v); return o == 0 ? false : true }
  public var ECEF_VELCount: Int32 { let o = _accessor.offset(VTOFFSET.ECEF_VEL.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ECEF_VEL(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.ECEF_VEL.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var ECEF_VEL: [Double] { return _accessor.getVector(at: VTOFFSET.ECEF_VEL.v) ?? [] }
  ///  ECEF acceleration as flat array [AX0, AY0, AZ0, AX1, AY1, AZ1, ...]
  public var hasEcefAcc: Bool { let o = _accessor.offset(VTOFFSET.ECEF_ACC.v); return o == 0 ? false : true }
  public var ECEF_ACCCount: Int32 { let o = _accessor.offset(VTOFFSET.ECEF_ACC.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ECEF_ACC(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.ECEF_ACC.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var ECEF_ACC: [Double] { return _accessor.getVector(at: VTOFFSET.ECEF_ACC.v) ?? [] }
  ///  Local coordinate position as flat array
  public var hasLcPos: Bool { let o = _accessor.offset(VTOFFSET.LC_POS.v); return o == 0 ? false : true }
  public var LC_POSCount: Int32 { let o = _accessor.offset(VTOFFSET.LC_POS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LC_POS(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.LC_POS.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var LC_POS: [Double] { return _accessor.getVector(at: VTOFFSET.LC_POS.v) ?? [] }
  ///  Local coordinate velocity as flat array
  public var hasLcVel: Bool { let o = _accessor.offset(VTOFFSET.LC_VEL.v); return o == 0 ? false : true }
  public var LC_VELCount: Int32 { let o = _accessor.offset(VTOFFSET.LC_VEL.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LC_VEL(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.LC_VEL.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var LC_VEL: [Double] { return _accessor.getVector(at: VTOFFSET.LC_VEL.v) ?? [] }
  ///  Local coordinate acceleration as flat array
  public var hasLcAcc: Bool { let o = _accessor.offset(VTOFFSET.LC_ACC.v); return o == 0 ? false : true }
  public var LC_ACCCount: Int32 { let o = _accessor.offset(VTOFFSET.LC_ACC.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LC_ACC(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.LC_ACC.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var LC_ACC: [Double] { return _accessor.getVector(at: VTOFFSET.LC_ACC.v) ?? [] }
  ///  Covariance data (21 elements per point for 6x6 lower triangular)
  public var hasCov: Bool { let o = _accessor.offset(VTOFFSET.COV.v); return o == 0 ? false : true }
  public var COVCount: Int32 { let o = _accessor.offset(VTOFFSET.COV.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COV(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.COV.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var COV: [Double] { return _accessor.getVector(at: VTOFFSET.COV.v) ?? [] }
  ///  Error ellipse data (6 elements per point)
  public var hasErrEllp: Bool { let o = _accessor.offset(VTOFFSET.ERR_ELLP.v); return o == 0 ? false : true }
  public var ERR_ELLPCount: Int32 { let o = _accessor.offset(VTOFFSET.ERR_ELLP.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ERR_ELLP(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.ERR_ELLP.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var ERR_ELLP: [Double] { return _accessor.getVector(at: VTOFFSET.ERR_ELLP.v) ?? [] }
  public static func startTRK(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 59) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(CNTCT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CNTCT, at: VTOFFSET.CNTCT.p) }
  public static func add(MSG_TS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MSG_TS, at: VTOFFSET.MSG_TS.p) }
  public static func add(MSN_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MSN_ID, at: VTOFFSET.MSN_ID.p) }
  public static func add(ASSET_NAT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ASSET_NAT, at: VTOFFSET.ASSET_NAT.p) }
  public static func add(ASSET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ASSET, at: VTOFFSET.ASSET.p) }
  public static func add(SENSOR_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SENSOR_ID, at: VTOFFSET.SENSOR_ID.p) }
  public static func add(SEN_QUAL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SEN_QUAL, at: VTOFFSET.SEN_QUAL.p) }
  public static func add(TRK_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRK_ID, at: VTOFFSET.TRK_ID.p) }
  public static func add(TRK_NUM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRK_NUM, at: VTOFFSET.TRK_NUM.p) }
  public static func add(TRK_STAT: trackStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRK_STAT.rawValue, def: 0, at: VTOFFSET.TRK_STAT.p) }
  public static func add(OBJ_NAT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_NAT, at: VTOFFSET.OBJ_NAT.p) }
  public static func add(OBJ_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_ID, at: VTOFFSET.OBJ_ID.p) }
  public static func add(OBJ_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_TYPE, at: VTOFFSET.OBJ_TYPE.p) }
  public static func add(OBJ_SPEC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_SPEC, at: VTOFFSET.OBJ_SPEC.p) }
  public static func add(OBJ_PLAT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_PLAT, at: VTOFFSET.OBJ_PLAT.p) }
  public static func add(OBJ_ACT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_ACT, at: VTOFFSET.OBJ_ACT.p) }
  public static func add(MOD_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MOD_TYPE, at: VTOFFSET.MOD_TYPE.p) }
  public static func add(TRK_ITM_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRK_ITM_ID, at: VTOFFSET.TRK_ITM_ID.p) }
  public static func add(TS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TS, at: VTOFFSET.TS.p) }
  public static func add(TRK_QUAL: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRK_QUAL, def: 0, at: VTOFFSET.TRK_QUAL.p) }
  public static func add(TRK_PT_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRK_PT_TYPE, at: VTOFFSET.TRK_PT_TYPE.p) }
  public static func add(OBJ_IDENT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJ_IDENT, at: VTOFFSET.OBJ_IDENT.p) }
  public static func add(IDENT_CRED: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: IDENT_CRED, def: 0, at: VTOFFSET.IDENT_CRED.p) }
  public static func add(IDENT_REL: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: IDENT_REL, def: 0, at: VTOFFSET.IDENT_REL.p) }
  public static func add(IDENT_AMP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IDENT_AMP, at: VTOFFSET.IDENT_AMP.p) }
  public static func add(ENVIRONMENT: trackEnvironment, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENVIRONMENT.rawValue, def: 0, at: VTOFFSET.ENVIRONMENT.p) }
  public static func add(ENVIRONMENT_CONF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ENVIRONMENT_CONF, def: 0.0, at: VTOFFSET.ENVIRONMENT_CONF.p) }
  public static func add(TRK_CONF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRK_CONF, def: 0.0, at: VTOFFSET.TRK_CONF.p) }
  public static func add(LAT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LAT, def: 0.0, at: VTOFFSET.LAT.p) }
  public static func add(LON: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LON, def: 0.0, at: VTOFFSET.LON.p) }
  public static func add(ALT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALT, def: 0.0, at: VTOFFSET.ALT.p) }
  public static func add(SPD: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SPD, def: 0.0, at: VTOFFSET.SPD.p) }
  public static func add(HDNG: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HDNG, def: 0.0, at: VTOFFSET.HDNG.p) }
  public static func add(COURSE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COURSE, def: 0.0, at: VTOFFSET.COURSE.p) }
  public static func addVectorOf(SRC_TYPS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SRC_TYPS, at: VTOFFSET.SRC_TYPS.p) }
  public static func addVectorOf(SRC_IDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SRC_IDS, at: VTOFFSET.SRC_IDS.p) }
  public static func add(CALL_SIGN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CALL_SIGN, at: VTOFFSET.CALL_SIGN.p) }
  public static func add(MULTI_SOURCE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MULTI_SOURCE, def: false,
   at: VTOFFSET.MULTI_SOURCE.p) }
  public static func add(J_SERIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: J_SERIES, at: VTOFFSET.J_SERIES.p) }
  public static func add(STRENGTH: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: STRENGTH, def: 0, at: VTOFFSET.STRENGTH.p) }
  public static func add(M1: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M1, def: 0, at: VTOFFSET.M1.p) }
  public static func add(M1V: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M1V, def: 0, at: VTOFFSET.M1V.p) }
  public static func add(M2: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M2, def: 0, at: VTOFFSET.M2.p) }
  public static func add(M2V: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M2V, def: 0, at: VTOFFSET.M2V.p) }
  public static func add(M3A: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M3A, def: 0, at: VTOFFSET.M3A.p) }
  public static func add(M3AV: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: M3AV, def: 0, at: VTOFFSET.M3AV.p) }
  public static func addVectorOf(TAGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TAGS, at: VTOFFSET.TAGS.p) }
  public static func add(TRACK_START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRACK_START_TIME, at: VTOFFSET.TRACK_START_TIME.p) }
  public static func add(TRACK_STEP_SIZE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRACK_STEP_SIZE, def: 0.0, at: VTOFFSET.TRACK_STEP_SIZE.p) }
  public static func add(TRACK_COMPONENTS: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRACK_COMPONENTS, def: 3, at: VTOFFSET.TRACK_COMPONENTS.p) }
  public static func addVectorOf(ECEF_POS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ECEF_POS, at: VTOFFSET.ECEF_POS.p) }
  public static func addVectorOf(ECEF_VEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ECEF_VEL, at: VTOFFSET.ECEF_VEL.p) }
  public static func addVectorOf(ECEF_ACC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ECEF_ACC, at: VTOFFSET.ECEF_ACC.p) }
  public static func addVectorOf(LC_POS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LC_POS, at: VTOFFSET.LC_POS.p) }
  public static func addVectorOf(LC_VEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LC_VEL, at: VTOFFSET.LC_VEL.p) }
  public static func addVectorOf(LC_ACC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LC_ACC, at: VTOFFSET.LC_ACC.p) }
  public static func addVectorOf(COV: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COV, at: VTOFFSET.COV.p) }
  public static func addVectorOf(ERR_ELLP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ERR_ELLP, at: VTOFFSET.ERR_ELLP.p) }
  public static func endTRK(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTRK(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    CNTCTOffset CNTCT: Offset = Offset(),
    MSG_TSOffset MSG_TS: Offset = Offset(),
    MSN_IDOffset MSN_ID: Offset = Offset(),
    ASSET_NATOffset ASSET_NAT: Offset = Offset(),
    ASSETOffset ASSET: Offset = Offset(),
    SENSOR_IDOffset SENSOR_ID: Offset = Offset(),
    SEN_QUALOffset SEN_QUAL: Offset = Offset(),
    TRK_IDOffset TRK_ID: Offset = Offset(),
    TRK_NUMOffset TRK_NUM: Offset = Offset(),
    TRK_STAT: trackStatus = .active,
    OBJ_NATOffset OBJ_NAT: Offset = Offset(),
    OBJ_IDOffset OBJ_ID: Offset = Offset(),
    OBJ_TYPEOffset OBJ_TYPE: Offset = Offset(),
    OBJ_SPECOffset OBJ_SPEC: Offset = Offset(),
    OBJ_PLATOffset OBJ_PLAT: Offset = Offset(),
    OBJ_ACTOffset OBJ_ACT: Offset = Offset(),
    MOD_TYPEOffset MOD_TYPE: Offset = Offset(),
    TRK_ITM_IDOffset TRK_ITM_ID: Offset = Offset(),
    TSOffset TS: Offset = Offset(),
    TRK_QUAL: UInt8 = 0,
    TRK_PT_TYPEOffset TRK_PT_TYPE: Offset = Offset(),
    OBJ_IDENTOffset OBJ_IDENT: Offset = Offset(),
    IDENT_CRED: UInt8 = 0,
    IDENT_REL: UInt8 = 0,
    IDENT_AMPOffset IDENT_AMP: Offset = Offset(),
    ENVIRONMENT: trackEnvironment = .space,
    ENVIRONMENT_CONF: Double = 0.0,
    TRK_CONF: Double = 0.0,
    LAT: Double = 0.0,
    LON: Double = 0.0,
    ALT: Double = 0.0,
    SPD: Double = 0.0,
    HDNG: Double = 0.0,
    COURSE: Double = 0.0,
    SRC_TYPSVectorOffset SRC_TYPS: Offset = Offset(),
    SRC_IDSVectorOffset SRC_IDS: Offset = Offset(),
    CALL_SIGNOffset CALL_SIGN: Offset = Offset(),
    MULTI_SOURCE: Bool = false,
    J_SERIESOffset J_SERIES: Offset = Offset(),
    STRENGTH: UInt16 = 0,
    M1: UInt16 = 0,
    M1V: UInt8 = 0,
    M2: UInt16 = 0,
    M2V: UInt8 = 0,
    M3A: UInt16 = 0,
    M3AV: UInt8 = 0,
    TAGSVectorOffset TAGS: Offset = Offset(),
    TRACK_START_TIMEOffset TRACK_START_TIME: Offset = Offset(),
    TRACK_STEP_SIZE: Double = 0.0,
    TRACK_COMPONENTS: UInt8 = 3,
    ECEF_POSVectorOffset ECEF_POS: Offset = Offset(),
    ECEF_VELVectorOffset ECEF_VEL: Offset = Offset(),
    ECEF_ACCVectorOffset ECEF_ACC: Offset = Offset(),
    LC_POSVectorOffset LC_POS: Offset = Offset(),
    LC_VELVectorOffset LC_VEL: Offset = Offset(),
    LC_ACCVectorOffset LC_ACC: Offset = Offset(),
    COVVectorOffset COV: Offset = Offset(),
    ERR_ELLPVectorOffset ERR_ELLP: Offset = Offset()
  ) -> Offset {
    let __start = TRK.startTRK(&fbb)
    TRK.add(ID: ID, &fbb)
    TRK.add(CNTCT: CNTCT, &fbb)
    TRK.add(MSG_TS: MSG_TS, &fbb)
    TRK.add(MSN_ID: MSN_ID, &fbb)
    TRK.add(ASSET_NAT: ASSET_NAT, &fbb)
    TRK.add(ASSET: ASSET, &fbb)
    TRK.add(SENSOR_ID: SENSOR_ID, &fbb)
    TRK.add(SEN_QUAL: SEN_QUAL, &fbb)
    TRK.add(TRK_ID: TRK_ID, &fbb)
    TRK.add(TRK_NUM: TRK_NUM, &fbb)
    TRK.add(TRK_STAT: TRK_STAT, &fbb)
    TRK.add(OBJ_NAT: OBJ_NAT, &fbb)
    TRK.add(OBJ_ID: OBJ_ID, &fbb)
    TRK.add(OBJ_TYPE: OBJ_TYPE, &fbb)
    TRK.add(OBJ_SPEC: OBJ_SPEC, &fbb)
    TRK.add(OBJ_PLAT: OBJ_PLAT, &fbb)
    TRK.add(OBJ_ACT: OBJ_ACT, &fbb)
    TRK.add(MOD_TYPE: MOD_TYPE, &fbb)
    TRK.add(TRK_ITM_ID: TRK_ITM_ID, &fbb)
    TRK.add(TS: TS, &fbb)
    TRK.add(TRK_QUAL: TRK_QUAL, &fbb)
    TRK.add(TRK_PT_TYPE: TRK_PT_TYPE, &fbb)
    TRK.add(OBJ_IDENT: OBJ_IDENT, &fbb)
    TRK.add(IDENT_CRED: IDENT_CRED, &fbb)
    TRK.add(IDENT_REL: IDENT_REL, &fbb)
    TRK.add(IDENT_AMP: IDENT_AMP, &fbb)
    TRK.add(ENVIRONMENT: ENVIRONMENT, &fbb)
    TRK.add(ENVIRONMENT_CONF: ENVIRONMENT_CONF, &fbb)
    TRK.add(TRK_CONF: TRK_CONF, &fbb)
    TRK.add(LAT: LAT, &fbb)
    TRK.add(LON: LON, &fbb)
    TRK.add(ALT: ALT, &fbb)
    TRK.add(SPD: SPD, &fbb)
    TRK.add(HDNG: HDNG, &fbb)
    TRK.add(COURSE: COURSE, &fbb)
    TRK.addVectorOf(SRC_TYPS: SRC_TYPS, &fbb)
    TRK.addVectorOf(SRC_IDS: SRC_IDS, &fbb)
    TRK.add(CALL_SIGN: CALL_SIGN, &fbb)
    TRK.add(MULTI_SOURCE: MULTI_SOURCE, &fbb)
    TRK.add(J_SERIES: J_SERIES, &fbb)
    TRK.add(STRENGTH: STRENGTH, &fbb)
    TRK.add(M1: M1, &fbb)
    TRK.add(M1V: M1V, &fbb)
    TRK.add(M2: M2, &fbb)
    TRK.add(M2V: M2V, &fbb)
    TRK.add(M3A: M3A, &fbb)
    TRK.add(M3AV: M3AV, &fbb)
    TRK.addVectorOf(TAGS: TAGS, &fbb)
    TRK.add(TRACK_START_TIME: TRACK_START_TIME, &fbb)
    TRK.add(TRACK_STEP_SIZE: TRACK_STEP_SIZE, &fbb)
    TRK.add(TRACK_COMPONENTS: TRACK_COMPONENTS, &fbb)
    TRK.addVectorOf(ECEF_POS: ECEF_POS, &fbb)
    TRK.addVectorOf(ECEF_VEL: ECEF_VEL, &fbb)
    TRK.addVectorOf(ECEF_ACC: ECEF_ACC, &fbb)
    TRK.addVectorOf(LC_POS: LC_POS, &fbb)
    TRK.addVectorOf(LC_VEL: LC_VEL, &fbb)
    TRK.addVectorOf(LC_ACC: LC_ACC, &fbb)
    TRK.addVectorOf(COV: COV, &fbb)
    TRK.addVectorOf(ERR_ELLP: ERR_ELLP, &fbb)
    return TRK.endTRK(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CNTCT.p, fieldName: "CNTCT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MSG_TS.p, fieldName: "MSG_TS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MSN_ID.p, fieldName: "MSN_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ASSET_NAT.p, fieldName: "ASSET_NAT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ASSET.p, fieldName: "ASSET", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SENSOR_ID.p, fieldName: "SENSOR_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SEN_QUAL.p, fieldName: "SEN_QUAL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRK_ID.p, fieldName: "TRK_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRK_NUM.p, fieldName: "TRK_NUM", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRK_STAT.p, fieldName: "TRK_STAT", required: false, type: trackStatus.self)
    try _v.visit(field: VTOFFSET.OBJ_NAT.p, fieldName: "OBJ_NAT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_ID.p, fieldName: "OBJ_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_TYPE.p, fieldName: "OBJ_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_SPEC.p, fieldName: "OBJ_SPEC", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_PLAT.p, fieldName: "OBJ_PLAT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_ACT.p, fieldName: "OBJ_ACT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MOD_TYPE.p, fieldName: "MOD_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRK_ITM_ID.p, fieldName: "TRK_ITM_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TS.p, fieldName: "TS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRK_QUAL.p, fieldName: "TRK_QUAL", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.TRK_PT_TYPE.p, fieldName: "TRK_PT_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJ_IDENT.p, fieldName: "OBJ_IDENT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.IDENT_CRED.p, fieldName: "IDENT_CRED", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.IDENT_REL.p, fieldName: "IDENT_REL", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.IDENT_AMP.p, fieldName: "IDENT_AMP", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENVIRONMENT.p, fieldName: "ENVIRONMENT", required: false, type: trackEnvironment.self)
    try _v.visit(field: VTOFFSET.ENVIRONMENT_CONF.p, fieldName: "ENVIRONMENT_CONF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TRK_CONF.p, fieldName: "TRK_CONF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LAT.p, fieldName: "LAT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LON.p, fieldName: "LON", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALT.p, fieldName: "ALT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SPD.p, fieldName: "SPD", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HDNG.p, fieldName: "HDNG", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COURSE.p, fieldName: "COURSE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SRC_TYPS.p, fieldName: "SRC_TYPS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.SRC_IDS.p, fieldName: "SRC_IDS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.CALL_SIGN.p, fieldName: "CALL_SIGN", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MULTI_SOURCE.p, fieldName: "MULTI_SOURCE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.J_SERIES.p, fieldName: "J_SERIES", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STRENGTH.p, fieldName: "STRENGTH", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.M1.p, fieldName: "M1", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.M1V.p, fieldName: "M1V", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.M2.p, fieldName: "M2", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.M2V.p, fieldName: "M2V", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.M3A.p, fieldName: "M3A", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.M3AV.p, fieldName: "M3AV", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.TAGS.p, fieldName: "TAGS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.TRACK_START_TIME.p, fieldName: "TRACK_START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRACK_STEP_SIZE.p, fieldName: "TRACK_STEP_SIZE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TRACK_COMPONENTS.p, fieldName: "TRACK_COMPONENTS", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ECEF_POS.p, fieldName: "ECEF_POS", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.ECEF_VEL.p, fieldName: "ECEF_VEL", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.ECEF_ACC.p, fieldName: "ECEF_ACC", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.LC_POS.p, fieldName: "LC_POS", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.LC_VEL.p, fieldName: "LC_VEL", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.LC_ACC.p, fieldName: "LC_ACC", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.COV.p, fieldName: "COV", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.ERR_ELLP.p, fieldName: "ERR_ELLP", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    _v.finish()
  }
}

