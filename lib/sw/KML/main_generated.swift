// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum KMLAltitudeMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  ///  Altitude relative to ground surface
  case clampToGround = 0
  ///  Altitude relative to ground elevation
  case relativeToGround = 1
  ///  Altitude as absolute meters above WGS84 ellipsoid
  case absolute = 2
  ///  Clamp to sea floor
  case clampToSeaFloor = 3
  ///  Relative to sea floor
  case relativeToSeaFloor = 4

  public static var max: KMLAltitudeMode { return .relativeToSeaFloor }
  public static var min: KMLAltitudeMode { return .clampToGround }
}


public enum KMLColorMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case normal = 0
  case random = 1

  public static var max: KMLColorMode { return .random }
  public static var min: KMLColorMode { return .normal }
}


public enum KMLStyleState: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case normal = 0
  case highlight = 1

  public static var max: KMLStyleState { return .highlight }
  public static var min: KMLStyleState { return .normal }
}


public enum KMLUnits: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case pixels = 0
  case fraction = 1
  case insetPixels = 2

  public static var max: KMLUnits { return .insetPixels }
  public static var min: KMLUnits { return .pixels }
}


public enum KMLRefreshMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case onChange = 0
  case onInterval = 1
  case onExpire = 2

  public static var max: KMLRefreshMode { return .onExpire }
  public static var min: KMLRefreshMode { return .onChange }
}


public enum KMLViewRefreshMode: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case never = 0
  case onStop = 1
  case onRequest = 2
  case onRegion = 3

  public static var max: KMLViewRefreshMode { return .onRegion }
  public static var min: KMLViewRefreshMode { return .never }
}


///  KML coordinate (longitude, latitude, optional altitude)
public struct KMLCoordinate: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLCoordinate.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LONGITUDE = 4
    case LATITUDE = 6
    case ALTITUDE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Longitude in decimal degrees
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Latitude in decimal degrees
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude in meters
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startKMLCoordinate(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func endKMLCoordinate(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLCoordinate(
    _ fbb: inout FlatBufferBuilder,
    LONGITUDE: Double = 0.0,
    LATITUDE: Double = 0.0,
    ALTITUDE: Double = 0.0
  ) -> Offset {
    let __start = KMLCoordinate.startKMLCoordinate(&fbb)
    KMLCoordinate.add(LONGITUDE: LONGITUDE, &fbb)
    KMLCoordinate.add(LATITUDE: LATITUDE, &fbb)
    KMLCoordinate.add(ALTITUDE: ALTITUDE, &fbb)
    return KMLCoordinate.endKMLCoordinate(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    _v.finish()
  }
}

///  LookAt viewpoint
public struct KMLLookAt: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLLookAt.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LONGITUDE = 4
    case LATITUDE = 6
    case ALTITUDE = 8
    case HEADING = 10
    case TILT = 12
    case RANGE = 14
    case ALTITUDE_MODE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Longitude of the point being looked at
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Latitude of the point being looked at
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude of the point being looked at
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Heading in degrees (0=North)
  public var HEADING: Double { let o = _accessor.offset(VTOFFSET.HEADING.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Tilt in degrees from vertical (0=straight down)
  public var TILT: Double { let o = _accessor.offset(VTOFFSET.TILT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Range in meters from the point
  public var RANGE: Double { let o = _accessor.offset(VTOFFSET.RANGE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  public static func startKMLLookAt(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func add(HEADING: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEADING, def: 0.0, at: VTOFFSET.HEADING.p) }
  public static func add(TILT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TILT, def: 0.0, at: VTOFFSET.TILT.p) }
  public static func add(RANGE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RANGE, def: 0.0, at: VTOFFSET.RANGE.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func endKMLLookAt(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLLookAt(
    _ fbb: inout FlatBufferBuilder,
    LONGITUDE: Double = 0.0,
    LATITUDE: Double = 0.0,
    ALTITUDE: Double = 0.0,
    HEADING: Double = 0.0,
    TILT: Double = 0.0,
    RANGE: Double = 0.0,
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround
  ) -> Offset {
    let __start = KMLLookAt.startKMLLookAt(&fbb)
    KMLLookAt.add(LONGITUDE: LONGITUDE, &fbb)
    KMLLookAt.add(LATITUDE: LATITUDE, &fbb)
    KMLLookAt.add(ALTITUDE: ALTITUDE, &fbb)
    KMLLookAt.add(HEADING: HEADING, &fbb)
    KMLLookAt.add(TILT: TILT, &fbb)
    KMLLookAt.add(RANGE: RANGE, &fbb)
    KMLLookAt.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    return KMLLookAt.endKMLLookAt(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEADING.p, fieldName: "HEADING", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TILT.p, fieldName: "TILT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.RANGE.p, fieldName: "RANGE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    _v.finish()
  }
}

///  Camera viewpoint
public struct KMLCamera: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLCamera.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case LONGITUDE = 4
    case LATITUDE = 6
    case ALTITUDE = 8
    case HEADING = 10
    case TILT = 12
    case ROLL = 14
    case ALTITUDE_MODE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Camera longitude
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Camera latitude
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Camera altitude
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Heading in degrees (0=North)
  public var HEADING: Double { let o = _accessor.offset(VTOFFSET.HEADING.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Tilt in degrees from vertical
  public var TILT: Double { let o = _accessor.offset(VTOFFSET.TILT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Roll in degrees
  public var ROLL: Double { let o = _accessor.offset(VTOFFSET.ROLL.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  public static func startKMLCamera(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func add(HEADING: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEADING, def: 0.0, at: VTOFFSET.HEADING.p) }
  public static func add(TILT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TILT, def: 0.0, at: VTOFFSET.TILT.p) }
  public static func add(ROLL: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ROLL, def: 0.0, at: VTOFFSET.ROLL.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func endKMLCamera(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLCamera(
    _ fbb: inout FlatBufferBuilder,
    LONGITUDE: Double = 0.0,
    LATITUDE: Double = 0.0,
    ALTITUDE: Double = 0.0,
    HEADING: Double = 0.0,
    TILT: Double = 0.0,
    ROLL: Double = 0.0,
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround
  ) -> Offset {
    let __start = KMLCamera.startKMLCamera(&fbb)
    KMLCamera.add(LONGITUDE: LONGITUDE, &fbb)
    KMLCamera.add(LATITUDE: LATITUDE, &fbb)
    KMLCamera.add(ALTITUDE: ALTITUDE, &fbb)
    KMLCamera.add(HEADING: HEADING, &fbb)
    KMLCamera.add(TILT: TILT, &fbb)
    KMLCamera.add(ROLL: ROLL, &fbb)
    KMLCamera.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    return KMLCamera.endKMLCamera(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEADING.p, fieldName: "HEADING", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TILT.p, fieldName: "TILT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ROLL.p, fieldName: "ROLL", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    _v.finish()
  }
}

///  Icon style
public struct KMLIconStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLIconStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COLOR = 4
    case COLOR_MODE = 6
    case SCALE = 8
    case HEADING = 10
    case ICON_HREF = 12
    case HOTSPOT_X = 14
    case HOTSPOT_Y = 16
    case HOTSPOT_X_UNITS = 18
    case HOTSPOT_Y_UNITS = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  KML color in aabbggrr hex format
  public var COLOR: String? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLOR.v) }
  ///  Color mode
  public var COLOR_MODE: KMLColorMode { let o = _accessor.offset(VTOFFSET.COLOR_MODE.v); return o == 0 ? .normal : KMLColorMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  ///  Scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Heading in degrees
  public var HEADING: Double { let o = _accessor.offset(VTOFFSET.HEADING.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Icon href (URL)
  public var ICON_HREF: String? { let o = _accessor.offset(VTOFFSET.ICON_HREF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ICON_HREFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ICON_HREF.v) }
  ///  Hot spot X value
  public var HOTSPOT_X: Double { let o = _accessor.offset(VTOFFSET.HOTSPOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Hot spot Y value
  public var HOTSPOT_Y: Double { let o = _accessor.offset(VTOFFSET.HOTSPOT_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Hot spot X units
  public var HOTSPOT_X_UNITS: KMLUnits { let o = _accessor.offset(VTOFFSET.HOTSPOT_X_UNITS.v); return o == 0 ? .pixels : KMLUnits(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .pixels }
  ///  Hot spot Y units
  public var HOTSPOT_Y_UNITS: KMLUnits { let o = _accessor.offset(VTOFFSET.HOTSPOT_Y_UNITS.v); return o == 0 ? .pixels : KMLUnits(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .pixels }
  public static func startKMLIconStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(COLOR_MODE: KMLColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COLOR_MODE.rawValue, def: 0, at: VTOFFSET.COLOR_MODE.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func add(HEADING: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HEADING, def: 0.0, at: VTOFFSET.HEADING.p) }
  public static func add(ICON_HREF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ICON_HREF, at: VTOFFSET.ICON_HREF.p) }
  public static func add(HOTSPOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HOTSPOT_X, def: 0.0, at: VTOFFSET.HOTSPOT_X.p) }
  public static func add(HOTSPOT_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HOTSPOT_Y, def: 0.0, at: VTOFFSET.HOTSPOT_Y.p) }
  public static func add(HOTSPOT_X_UNITS: KMLUnits, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HOTSPOT_X_UNITS.rawValue, def: 0, at: VTOFFSET.HOTSPOT_X_UNITS.p) }
  public static func add(HOTSPOT_Y_UNITS: KMLUnits, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HOTSPOT_Y_UNITS.rawValue, def: 0, at: VTOFFSET.HOTSPOT_Y_UNITS.p) }
  public static func endKMLIconStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLIconStyle(
    _ fbb: inout FlatBufferBuilder,
    COLOROffset COLOR: Offset = Offset(),
    COLOR_MODE: KMLColorMode = .normal,
    SCALE: Double = 0.0,
    HEADING: Double = 0.0,
    ICON_HREFOffset ICON_HREF: Offset = Offset(),
    HOTSPOT_X: Double = 0.0,
    HOTSPOT_Y: Double = 0.0,
    HOTSPOT_X_UNITS: KMLUnits = .pixels,
    HOTSPOT_Y_UNITS: KMLUnits = .pixels
  ) -> Offset {
    let __start = KMLIconStyle.startKMLIconStyle(&fbb)
    KMLIconStyle.add(COLOR: COLOR, &fbb)
    KMLIconStyle.add(COLOR_MODE: COLOR_MODE, &fbb)
    KMLIconStyle.add(SCALE: SCALE, &fbb)
    KMLIconStyle.add(HEADING: HEADING, &fbb)
    KMLIconStyle.add(ICON_HREF: ICON_HREF, &fbb)
    KMLIconStyle.add(HOTSPOT_X: HOTSPOT_X, &fbb)
    KMLIconStyle.add(HOTSPOT_Y: HOTSPOT_Y, &fbb)
    KMLIconStyle.add(HOTSPOT_X_UNITS: HOTSPOT_X_UNITS, &fbb)
    KMLIconStyle.add(HOTSPOT_Y_UNITS: HOTSPOT_Y_UNITS, &fbb)
    return KMLIconStyle.endKMLIconStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLOR_MODE.p, fieldName: "COLOR_MODE", required: false, type: KMLColorMode.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HEADING.p, fieldName: "HEADING", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ICON_HREF.p, fieldName: "ICON_HREF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HOTSPOT_X.p, fieldName: "HOTSPOT_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HOTSPOT_Y.p, fieldName: "HOTSPOT_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HOTSPOT_X_UNITS.p, fieldName: "HOTSPOT_X_UNITS", required: false, type: KMLUnits.self)
    try _v.visit(field: VTOFFSET.HOTSPOT_Y_UNITS.p, fieldName: "HOTSPOT_Y_UNITS", required: false, type: KMLUnits.self)
    _v.finish()
  }
}

///  Line style
public struct KMLLineStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLLineStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COLOR = 4
    case COLOR_MODE = 6
    case WIDTH = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  KML color in aabbggrr hex format
  public var COLOR: String? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLOR.v) }
  ///  Color mode
  public var COLOR_MODE: KMLColorMode { let o = _accessor.offset(VTOFFSET.COLOR_MODE.v); return o == 0 ? .normal : KMLColorMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  ///  Width in pixels
  public var WIDTH: Double { let o = _accessor.offset(VTOFFSET.WIDTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startKMLLineStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(COLOR_MODE: KMLColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COLOR_MODE.rawValue, def: 0, at: VTOFFSET.COLOR_MODE.p) }
  public static func add(WIDTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WIDTH, def: 0.0, at: VTOFFSET.WIDTH.p) }
  public static func endKMLLineStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLLineStyle(
    _ fbb: inout FlatBufferBuilder,
    COLOROffset COLOR: Offset = Offset(),
    COLOR_MODE: KMLColorMode = .normal,
    WIDTH: Double = 0.0
  ) -> Offset {
    let __start = KMLLineStyle.startKMLLineStyle(&fbb)
    KMLLineStyle.add(COLOR: COLOR, &fbb)
    KMLLineStyle.add(COLOR_MODE: COLOR_MODE, &fbb)
    KMLLineStyle.add(WIDTH: WIDTH, &fbb)
    return KMLLineStyle.endKMLLineStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLOR_MODE.p, fieldName: "COLOR_MODE", required: false, type: KMLColorMode.self)
    try _v.visit(field: VTOFFSET.WIDTH.p, fieldName: "WIDTH", required: false, type: Double.self)
    _v.finish()
  }
}

///  Polygon style
public struct KMLPolyStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLPolyStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COLOR = 4
    case COLOR_MODE = 6
    case FILL = 8
    case OUTLINE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  KML color in aabbggrr hex format
  public var COLOR: String? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLOR.v) }
  ///  Color mode
  public var COLOR_MODE: KMLColorMode { let o = _accessor.offset(VTOFFSET.COLOR_MODE.v); return o == 0 ? .normal : KMLColorMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  ///  Whether to fill
  public var FILL: Bool { let o = _accessor.offset(VTOFFSET.FILL.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Whether to outline
  public var OUTLINE: Bool { let o = _accessor.offset(VTOFFSET.OUTLINE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startKMLPolyStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(COLOR_MODE: KMLColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COLOR_MODE.rawValue, def: 0, at: VTOFFSET.COLOR_MODE.p) }
  public static func add(FILL: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FILL, def: false,
   at: VTOFFSET.FILL.p) }
  public static func add(OUTLINE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OUTLINE, def: false,
   at: VTOFFSET.OUTLINE.p) }
  public static func endKMLPolyStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLPolyStyle(
    _ fbb: inout FlatBufferBuilder,
    COLOROffset COLOR: Offset = Offset(),
    COLOR_MODE: KMLColorMode = .normal,
    FILL: Bool = false,
    OUTLINE: Bool = false
  ) -> Offset {
    let __start = KMLPolyStyle.startKMLPolyStyle(&fbb)
    KMLPolyStyle.add(COLOR: COLOR, &fbb)
    KMLPolyStyle.add(COLOR_MODE: COLOR_MODE, &fbb)
    KMLPolyStyle.add(FILL: FILL, &fbb)
    KMLPolyStyle.add(OUTLINE: OUTLINE, &fbb)
    return KMLPolyStyle.endKMLPolyStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLOR_MODE.p, fieldName: "COLOR_MODE", required: false, type: KMLColorMode.self)
    try _v.visit(field: VTOFFSET.FILL.p, fieldName: "FILL", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OUTLINE.p, fieldName: "OUTLINE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Label style
public struct KMLLabelStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLLabelStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COLOR = 4
    case COLOR_MODE = 6
    case SCALE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  KML color in aabbggrr hex format
  public var COLOR: String? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLOR.v) }
  ///  Color mode
  public var COLOR_MODE: KMLColorMode { let o = _accessor.offset(VTOFFSET.COLOR_MODE.v); return o == 0 ? .normal : KMLColorMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  ///  Scale factor
  public var SCALE: Double { let o = _accessor.offset(VTOFFSET.SCALE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startKMLLabelStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(COLOR_MODE: KMLColorMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COLOR_MODE.rawValue, def: 0, at: VTOFFSET.COLOR_MODE.p) }
  public static func add(SCALE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SCALE, def: 0.0, at: VTOFFSET.SCALE.p) }
  public static func endKMLLabelStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLLabelStyle(
    _ fbb: inout FlatBufferBuilder,
    COLOROffset COLOR: Offset = Offset(),
    COLOR_MODE: KMLColorMode = .normal,
    SCALE: Double = 0.0
  ) -> Offset {
    let __start = KMLLabelStyle.startKMLLabelStyle(&fbb)
    KMLLabelStyle.add(COLOR: COLOR, &fbb)
    KMLLabelStyle.add(COLOR_MODE: COLOR_MODE, &fbb)
    KMLLabelStyle.add(SCALE: SCALE, &fbb)
    return KMLLabelStyle.endKMLLabelStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLOR_MODE.p, fieldName: "COLOR_MODE", required: false, type: KMLColorMode.self)
    try _v.visit(field: VTOFFSET.SCALE.p, fieldName: "SCALE", required: false, type: Double.self)
    _v.finish()
  }
}

///  Balloon style
public struct KMLBalloonStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLBalloonStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case BG_COLOR = 4
    case TEXT_COLOR = 6
    case TEXT = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Background color in aabbggrr hex format
  public var BG_COLOR: String? { let o = _accessor.offset(VTOFFSET.BG_COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var BG_COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.BG_COLOR.v) }
  ///  Text color in aabbggrr hex format
  public var TEXT_COLOR: String? { let o = _accessor.offset(VTOFFSET.TEXT_COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TEXT_COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TEXT_COLOR.v) }
  ///  Balloon text template (supports $[name], $[description])
  public var TEXT: String? { let o = _accessor.offset(VTOFFSET.TEXT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TEXTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TEXT.v) }
  public static func startKMLBalloonStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(BG_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BG_COLOR, at: VTOFFSET.BG_COLOR.p) }
  public static func add(TEXT_COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TEXT_COLOR, at: VTOFFSET.TEXT_COLOR.p) }
  public static func add(TEXT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TEXT, at: VTOFFSET.TEXT.p) }
  public static func endKMLBalloonStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLBalloonStyle(
    _ fbb: inout FlatBufferBuilder,
    BG_COLOROffset BG_COLOR: Offset = Offset(),
    TEXT_COLOROffset TEXT_COLOR: Offset = Offset(),
    TEXTOffset TEXT: Offset = Offset()
  ) -> Offset {
    let __start = KMLBalloonStyle.startKMLBalloonStyle(&fbb)
    KMLBalloonStyle.add(BG_COLOR: BG_COLOR, &fbb)
    KMLBalloonStyle.add(TEXT_COLOR: TEXT_COLOR, &fbb)
    KMLBalloonStyle.add(TEXT: TEXT, &fbb)
    return KMLBalloonStyle.endKMLBalloonStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.BG_COLOR.p, fieldName: "BG_COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TEXT_COLOR.p, fieldName: "TEXT_COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TEXT.p, fieldName: "TEXT", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Style definition
public struct KMLStyle: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLStyle.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case ICON_STYLE = 6
    case LABEL_STYLE = 8
    case LINE_STYLE = 10
    case POLY_STYLE = 12
    case BALLOON_STYLE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Style identifier
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Icon style
  public var ICON_STYLE: KMLIconStyle? { let o = _accessor.offset(VTOFFSET.ICON_STYLE.v); return o == 0 ? nil : KMLIconStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Label style
  public var LABEL_STYLE: KMLLabelStyle? { let o = _accessor.offset(VTOFFSET.LABEL_STYLE.v); return o == 0 ? nil : KMLLabelStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Line style
  public var LINE_STYLE: KMLLineStyle? { let o = _accessor.offset(VTOFFSET.LINE_STYLE.v); return o == 0 ? nil : KMLLineStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Polygon style
  public var POLY_STYLE: KMLPolyStyle? { let o = _accessor.offset(VTOFFSET.POLY_STYLE.v); return o == 0 ? nil : KMLPolyStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Balloon style
  public var BALLOON_STYLE: KMLBalloonStyle? { let o = _accessor.offset(VTOFFSET.BALLOON_STYLE.v); return o == 0 ? nil : KMLBalloonStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startKMLStyle(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(ICON_STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ICON_STYLE, at: VTOFFSET.ICON_STYLE.p) }
  public static func add(LABEL_STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LABEL_STYLE, at: VTOFFSET.LABEL_STYLE.p) }
  public static func add(LINE_STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINE_STYLE, at: VTOFFSET.LINE_STYLE.p) }
  public static func add(POLY_STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLY_STYLE, at: VTOFFSET.POLY_STYLE.p) }
  public static func add(BALLOON_STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BALLOON_STYLE, at: VTOFFSET.BALLOON_STYLE.p) }
  public static func endKMLStyle(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLStyle(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    ICON_STYLEOffset ICON_STYLE: Offset = Offset(),
    LABEL_STYLEOffset LABEL_STYLE: Offset = Offset(),
    LINE_STYLEOffset LINE_STYLE: Offset = Offset(),
    POLY_STYLEOffset POLY_STYLE: Offset = Offset(),
    BALLOON_STYLEOffset BALLOON_STYLE: Offset = Offset()
  ) -> Offset {
    let __start = KMLStyle.startKMLStyle(&fbb)
    KMLStyle.add(ID: ID, &fbb)
    KMLStyle.add(ICON_STYLE: ICON_STYLE, &fbb)
    KMLStyle.add(LABEL_STYLE: LABEL_STYLE, &fbb)
    KMLStyle.add(LINE_STYLE: LINE_STYLE, &fbb)
    KMLStyle.add(POLY_STYLE: POLY_STYLE, &fbb)
    KMLStyle.add(BALLOON_STYLE: BALLOON_STYLE, &fbb)
    return KMLStyle.endKMLStyle(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ICON_STYLE.p, fieldName: "ICON_STYLE", required: false, type: ForwardOffset<KMLIconStyle>.self)
    try _v.visit(field: VTOFFSET.LABEL_STYLE.p, fieldName: "LABEL_STYLE", required: false, type: ForwardOffset<KMLLabelStyle>.self)
    try _v.visit(field: VTOFFSET.LINE_STYLE.p, fieldName: "LINE_STYLE", required: false, type: ForwardOffset<KMLLineStyle>.self)
    try _v.visit(field: VTOFFSET.POLY_STYLE.p, fieldName: "POLY_STYLE", required: false, type: ForwardOffset<KMLPolyStyle>.self)
    try _v.visit(field: VTOFFSET.BALLOON_STYLE.p, fieldName: "BALLOON_STYLE", required: false, type: ForwardOffset<KMLBalloonStyle>.self)
    _v.finish()
  }
}

///  Style map pair
public struct KMLStyleMapPair: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLStyleMapPair.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case STATE = 4
    case STYLE_URL = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  State (normal or highlight)
  public var STATE: KMLStyleState { let o = _accessor.offset(VTOFFSET.STATE.v); return o == 0 ? .normal : KMLStyleState(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .normal }
  ///  Style URL or inline style ID
  public var STYLE_URL: String? { let o = _accessor.offset(VTOFFSET.STYLE_URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STYLE_URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STYLE_URL.v) }
  public static func startKMLStyleMapPair(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(STATE: KMLStyleState, _ fbb: inout FlatBufferBuilder) { fbb.add(element: STATE.rawValue, def: 0, at: VTOFFSET.STATE.p) }
  public static func add(STYLE_URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STYLE_URL, at: VTOFFSET.STYLE_URL.p) }
  public static func endKMLStyleMapPair(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLStyleMapPair(
    _ fbb: inout FlatBufferBuilder,
    STATE: KMLStyleState = .normal,
    STYLE_URLOffset STYLE_URL: Offset = Offset()
  ) -> Offset {
    let __start = KMLStyleMapPair.startKMLStyleMapPair(&fbb)
    KMLStyleMapPair.add(STATE: STATE, &fbb)
    KMLStyleMapPair.add(STYLE_URL: STYLE_URL, &fbb)
    return KMLStyleMapPair.endKMLStyleMapPair(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.STATE.p, fieldName: "STATE", required: false, type: KMLStyleState.self)
    try _v.visit(field: VTOFFSET.STYLE_URL.p, fieldName: "STYLE_URL", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Style map (normal/highlight pair)
public struct KMLStyleMap: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLStyleMap.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case PAIRS = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Style map identifier
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Pairs
  public var hasPairs: Bool { let o = _accessor.offset(VTOFFSET.PAIRS.v); return o == 0 ? false : true }
  public var PAIRSCount: Int32 { let o = _accessor.offset(VTOFFSET.PAIRS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PAIRS(at index: Int32) -> KMLStyleMapPair? { let o = _accessor.offset(VTOFFSET.PAIRS.v); return o == 0 ? nil : KMLStyleMapPair(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKMLStyleMap(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func addVectorOf(PAIRS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PAIRS, at: VTOFFSET.PAIRS.p) }
  public static func endKMLStyleMap(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLStyleMap(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    PAIRSVectorOffset PAIRS: Offset = Offset()
  ) -> Offset {
    let __start = KMLStyleMap.startKMLStyleMap(&fbb)
    KMLStyleMap.add(ID: ID, &fbb)
    KMLStyleMap.addVectorOf(PAIRS: PAIRS, &fbb)
    return KMLStyleMap.endKMLStyleMap(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PAIRS.p, fieldName: "PAIRS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLStyleMapPair>, KMLStyleMapPair>>.self)
    _v.finish()
  }
}

///  Point geometry
public struct KMLPoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLPoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COORDINATES = 4
    case ALTITUDE_MODE = 6
    case EXTRUDE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Coordinate
  public var COORDINATES: KMLCoordinate? { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? nil : KMLCoordinate(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  ///  Whether to extrude to ground
  public var EXTRUDE: Bool { let o = _accessor.offset(VTOFFSET.EXTRUDE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startKMLPoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(COORDINATES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COORDINATES, at: VTOFFSET.COORDINATES.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func add(EXTRUDE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRUDE, def: false,
   at: VTOFFSET.EXTRUDE.p) }
  public static func endKMLPoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLPoint(
    _ fbb: inout FlatBufferBuilder,
    COORDINATESOffset COORDINATES: Offset = Offset(),
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround,
    EXTRUDE: Bool = false
  ) -> Offset {
    let __start = KMLPoint.startKMLPoint(&fbb)
    KMLPoint.add(COORDINATES: COORDINATES, &fbb)
    KMLPoint.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    KMLPoint.add(EXTRUDE: EXTRUDE, &fbb)
    return KMLPoint.endKMLPoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COORDINATES.p, fieldName: "COORDINATES", required: false, type: ForwardOffset<KMLCoordinate>.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    try _v.visit(field: VTOFFSET.EXTRUDE.p, fieldName: "EXTRUDE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  LineString geometry
public struct KMLLineString: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLLineString.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COORDINATES = 4
    case ALTITUDE_MODE = 6
    case EXTRUDE = 8
    case TESSELLATE = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Coordinates
  public var hasCoordinates: Bool { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? false : true }
  public var COORDINATESCount: Int32 { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COORDINATES(at index: Int32) -> KMLCoordinate? { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? nil : KMLCoordinate(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  ///  Whether to extrude to ground
  public var EXTRUDE: Bool { let o = _accessor.offset(VTOFFSET.EXTRUDE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Whether to tessellate (follow terrain)
  public var TESSELLATE: Bool { let o = _accessor.offset(VTOFFSET.TESSELLATE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startKMLLineString(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func addVectorOf(COORDINATES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COORDINATES, at: VTOFFSET.COORDINATES.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func add(EXTRUDE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRUDE, def: false,
   at: VTOFFSET.EXTRUDE.p) }
  public static func add(TESSELLATE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TESSELLATE, def: false,
   at: VTOFFSET.TESSELLATE.p) }
  public static func endKMLLineString(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLLineString(
    _ fbb: inout FlatBufferBuilder,
    COORDINATESVectorOffset COORDINATES: Offset = Offset(),
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround,
    EXTRUDE: Bool = false,
    TESSELLATE: Bool = false
  ) -> Offset {
    let __start = KMLLineString.startKMLLineString(&fbb)
    KMLLineString.addVectorOf(COORDINATES: COORDINATES, &fbb)
    KMLLineString.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    KMLLineString.add(EXTRUDE: EXTRUDE, &fbb)
    KMLLineString.add(TESSELLATE: TESSELLATE, &fbb)
    return KMLLineString.endKMLLineString(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COORDINATES.p, fieldName: "COORDINATES", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLCoordinate>, KMLCoordinate>>.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    try _v.visit(field: VTOFFSET.EXTRUDE.p, fieldName: "EXTRUDE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.TESSELLATE.p, fieldName: "TESSELLATE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  LinearRing geometry
public struct KMLLinearRing: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLLinearRing.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COORDINATES = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Coordinates (first = last to close the ring)
  public var hasCoordinates: Bool { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? false : true }
  public var COORDINATESCount: Int32 { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COORDINATES(at index: Int32) -> KMLCoordinate? { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? nil : KMLCoordinate(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKMLLinearRing(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(COORDINATES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COORDINATES, at: VTOFFSET.COORDINATES.p) }
  public static func endKMLLinearRing(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLLinearRing(
    _ fbb: inout FlatBufferBuilder,
    COORDINATESVectorOffset COORDINATES: Offset = Offset()
  ) -> Offset {
    let __start = KMLLinearRing.startKMLLinearRing(&fbb)
    KMLLinearRing.addVectorOf(COORDINATES: COORDINATES, &fbb)
    return KMLLinearRing.endKMLLinearRing(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COORDINATES.p, fieldName: "COORDINATES", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLCoordinate>, KMLCoordinate>>.self)
    _v.finish()
  }
}

///  Polygon geometry
public struct KMLPolygon: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLPolygon.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case OUTER_BOUNDARY = 4
    case INNER_BOUNDARIES = 6
    case ALTITUDE_MODE = 8
    case EXTRUDE = 10
    case TESSELLATE = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Outer boundary
  public var OUTER_BOUNDARY: KMLLinearRing? { let o = _accessor.offset(VTOFFSET.OUTER_BOUNDARY.v); return o == 0 ? nil : KMLLinearRing(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Inner boundaries (holes)
  public var hasInnerBoundaries: Bool { let o = _accessor.offset(VTOFFSET.INNER_BOUNDARIES.v); return o == 0 ? false : true }
  public var INNER_BOUNDARIESCount: Int32 { let o = _accessor.offset(VTOFFSET.INNER_BOUNDARIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INNER_BOUNDARIES(at index: Int32) -> KMLLinearRing? { let o = _accessor.offset(VTOFFSET.INNER_BOUNDARIES.v); return o == 0 ? nil : KMLLinearRing(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  ///  Whether to extrude to ground
  public var EXTRUDE: Bool { let o = _accessor.offset(VTOFFSET.EXTRUDE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Whether to tessellate
  public var TESSELLATE: Bool { let o = _accessor.offset(VTOFFSET.TESSELLATE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startKMLPolygon(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(OUTER_BOUNDARY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OUTER_BOUNDARY, at: VTOFFSET.OUTER_BOUNDARY.p) }
  public static func addVectorOf(INNER_BOUNDARIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INNER_BOUNDARIES, at: VTOFFSET.INNER_BOUNDARIES.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func add(EXTRUDE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EXTRUDE, def: false,
   at: VTOFFSET.EXTRUDE.p) }
  public static func add(TESSELLATE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TESSELLATE, def: false,
   at: VTOFFSET.TESSELLATE.p) }
  public static func endKMLPolygon(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLPolygon(
    _ fbb: inout FlatBufferBuilder,
    OUTER_BOUNDARYOffset OUTER_BOUNDARY: Offset = Offset(),
    INNER_BOUNDARIESVectorOffset INNER_BOUNDARIES: Offset = Offset(),
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround,
    EXTRUDE: Bool = false,
    TESSELLATE: Bool = false
  ) -> Offset {
    let __start = KMLPolygon.startKMLPolygon(&fbb)
    KMLPolygon.add(OUTER_BOUNDARY: OUTER_BOUNDARY, &fbb)
    KMLPolygon.addVectorOf(INNER_BOUNDARIES: INNER_BOUNDARIES, &fbb)
    KMLPolygon.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    KMLPolygon.add(EXTRUDE: EXTRUDE, &fbb)
    KMLPolygon.add(TESSELLATE: TESSELLATE, &fbb)
    return KMLPolygon.endKMLPolygon(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.OUTER_BOUNDARY.p, fieldName: "OUTER_BOUNDARY", required: false, type: ForwardOffset<KMLLinearRing>.self)
    try _v.visit(field: VTOFFSET.INNER_BOUNDARIES.p, fieldName: "INNER_BOUNDARIES", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLLinearRing>, KMLLinearRing>>.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    try _v.visit(field: VTOFFSET.EXTRUDE.p, fieldName: "EXTRUDE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.TESSELLATE.p, fieldName: "TESSELLATE", required: false, type: Bool.self)
    _v.finish()
  }
}

///  MultiGeometry
public struct KMLMultiGeometry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLMultiGeometry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case POINTS = 4
    case LINE_STRINGS = 6
    case POLYGONS = 8
    case MULTI_GEOMETRIES = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Child points
  public var hasPoints: Bool { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? false : true }
  public var POINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POINTS(at index: Int32) -> KMLPoint? { let o = _accessor.offset(VTOFFSET.POINTS.v); return o == 0 ? nil : KMLPoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Child line strings
  public var hasLineStrings: Bool { let o = _accessor.offset(VTOFFSET.LINE_STRINGS.v); return o == 0 ? false : true }
  public var LINE_STRINGSCount: Int32 { let o = _accessor.offset(VTOFFSET.LINE_STRINGS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func LINE_STRINGS(at index: Int32) -> KMLLineString? { let o = _accessor.offset(VTOFFSET.LINE_STRINGS.v); return o == 0 ? nil : KMLLineString(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Child polygons
  public var hasPolygons: Bool { let o = _accessor.offset(VTOFFSET.POLYGONS.v); return o == 0 ? false : true }
  public var POLYGONSCount: Int32 { let o = _accessor.offset(VTOFFSET.POLYGONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func POLYGONS(at index: Int32) -> KMLPolygon? { let o = _accessor.offset(VTOFFSET.POLYGONS.v); return o == 0 ? nil : KMLPolygon(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Nested multi-geometries
  public var hasMultiGeometries: Bool { let o = _accessor.offset(VTOFFSET.MULTI_GEOMETRIES.v); return o == 0 ? false : true }
  public var MULTI_GEOMETRIESCount: Int32 { let o = _accessor.offset(VTOFFSET.MULTI_GEOMETRIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MULTI_GEOMETRIES(at index: Int32) -> KMLMultiGeometry? { let o = _accessor.offset(VTOFFSET.MULTI_GEOMETRIES.v); return o == 0 ? nil : KMLMultiGeometry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKMLMultiGeometry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func addVectorOf(POINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINTS, at: VTOFFSET.POINTS.p) }
  public static func addVectorOf(LINE_STRINGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINE_STRINGS, at: VTOFFSET.LINE_STRINGS.p) }
  public static func addVectorOf(POLYGONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYGONS, at: VTOFFSET.POLYGONS.p) }
  public static func addVectorOf(MULTI_GEOMETRIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MULTI_GEOMETRIES, at: VTOFFSET.MULTI_GEOMETRIES.p) }
  public static func endKMLMultiGeometry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLMultiGeometry(
    _ fbb: inout FlatBufferBuilder,
    POINTSVectorOffset POINTS: Offset = Offset(),
    LINE_STRINGSVectorOffset LINE_STRINGS: Offset = Offset(),
    POLYGONSVectorOffset POLYGONS: Offset = Offset(),
    MULTI_GEOMETRIESVectorOffset MULTI_GEOMETRIES: Offset = Offset()
  ) -> Offset {
    let __start = KMLMultiGeometry.startKMLMultiGeometry(&fbb)
    KMLMultiGeometry.addVectorOf(POINTS: POINTS, &fbb)
    KMLMultiGeometry.addVectorOf(LINE_STRINGS: LINE_STRINGS, &fbb)
    KMLMultiGeometry.addVectorOf(POLYGONS: POLYGONS, &fbb)
    KMLMultiGeometry.addVectorOf(MULTI_GEOMETRIES: MULTI_GEOMETRIES, &fbb)
    return KMLMultiGeometry.endKMLMultiGeometry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.POINTS.p, fieldName: "POINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLPoint>, KMLPoint>>.self)
    try _v.visit(field: VTOFFSET.LINE_STRINGS.p, fieldName: "LINE_STRINGS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLLineString>, KMLLineString>>.self)
    try _v.visit(field: VTOFFSET.POLYGONS.p, fieldName: "POLYGONS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLPolygon>, KMLPolygon>>.self)
    try _v.visit(field: VTOFFSET.MULTI_GEOMETRIES.p, fieldName: "MULTI_GEOMETRIES", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLMultiGeometry>, KMLMultiGeometry>>.self)
    _v.finish()
  }
}

///  TimeSpan
public struct KMLTimeSpan: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLTimeSpan.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case BEGIN = 4
    case END = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Begin time (ISO 8601)
  public var BEGIN: String? { let o = _accessor.offset(VTOFFSET.BEGIN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var BEGINSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.BEGIN.v) }
  ///  End time (ISO 8601)
  public var END: String? { let o = _accessor.offset(VTOFFSET.END.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ENDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.END.v) }
  public static func startKMLTimeSpan(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(BEGIN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BEGIN, at: VTOFFSET.BEGIN.p) }
  public static func add(END: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: END, at: VTOFFSET.END.p) }
  public static func endKMLTimeSpan(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLTimeSpan(
    _ fbb: inout FlatBufferBuilder,
    BEGINOffset BEGIN: Offset = Offset(),
    ENDOffset END: Offset = Offset()
  ) -> Offset {
    let __start = KMLTimeSpan.startKMLTimeSpan(&fbb)
    KMLTimeSpan.add(BEGIN: BEGIN, &fbb)
    KMLTimeSpan.add(END: END, &fbb)
    return KMLTimeSpan.endKMLTimeSpan(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.BEGIN.p, fieldName: "BEGIN", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.END.p, fieldName: "END", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  TimeStamp
public struct KMLTimeStamp: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLTimeStamp.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case WHEN = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Time (ISO 8601)
  public var WHEN: String? { let o = _accessor.offset(VTOFFSET.WHEN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var WHENSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.WHEN.v) }
  public static func startKMLTimeStamp(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(WHEN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: WHEN, at: VTOFFSET.WHEN.p) }
  public static func endKMLTimeStamp(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLTimeStamp(
    _ fbb: inout FlatBufferBuilder,
    WHENOffset WHEN: Offset = Offset()
  ) -> Offset {
    let __start = KMLTimeStamp.startKMLTimeStamp(&fbb)
    KMLTimeStamp.add(WHEN: WHEN, &fbb)
    return KMLTimeStamp.endKMLTimeStamp(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.WHEN.p, fieldName: "WHEN", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Extended data key-value pair
public struct KMLData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLData.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DISPLAY_NAME = 6
    case VALUE = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Data name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Display name
  public var DISPLAY_NAME: String? { let o = _accessor.offset(VTOFFSET.DISPLAY_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DISPLAY_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DISPLAY_NAME.v) }
  ///  Data value
  public var VALUE: String? { let o = _accessor.offset(VTOFFSET.VALUE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VALUESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VALUE.v) }
  public static func startKMLData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DISPLAY_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DISPLAY_NAME, at: VTOFFSET.DISPLAY_NAME.p) }
  public static func add(VALUE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VALUE, at: VTOFFSET.VALUE.p) }
  public static func endKMLData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLData(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    DISPLAY_NAMEOffset DISPLAY_NAME: Offset = Offset(),
    VALUEOffset VALUE: Offset = Offset()
  ) -> Offset {
    let __start = KMLData.startKMLData(&fbb)
    KMLData.add(NAME: NAME, &fbb)
    KMLData.add(DISPLAY_NAME: DISPLAY_NAME, &fbb)
    KMLData.add(VALUE: VALUE, &fbb)
    return KMLData.endKMLData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DISPLAY_NAME.p, fieldName: "DISPLAY_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VALUE.p, fieldName: "VALUE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Network link
public struct KMLNetworkLink: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLNetworkLink.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case VISIBILITY = 6
    case HREF = 8
    case REFRESH_MODE = 10
    case REFRESH_INTERVAL = 12
    case VIEW_REFRESH_MODE = 14
    case VIEW_REFRESH_TIME = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of the network link
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Whether the link is visible
  public var VISIBILITY: Bool { let o = _accessor.offset(VTOFFSET.VISIBILITY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Link URL
  public var HREF: String? { let o = _accessor.offset(VTOFFSET.HREF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HREFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HREF.v) }
  ///  Refresh mode
  public var REFRESH_MODE: KMLRefreshMode { let o = _accessor.offset(VTOFFSET.REFRESH_MODE.v); return o == 0 ? .onChange : KMLRefreshMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .onChange }
  ///  Refresh interval in seconds
  public var REFRESH_INTERVAL: Double { let o = _accessor.offset(VTOFFSET.REFRESH_INTERVAL.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  View refresh mode
  public var VIEW_REFRESH_MODE: KMLViewRefreshMode { let o = _accessor.offset(VTOFFSET.VIEW_REFRESH_MODE.v); return o == 0 ? .never : KMLViewRefreshMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .never }
  ///  View refresh time in seconds
  public var VIEW_REFRESH_TIME: Double { let o = _accessor.offset(VTOFFSET.VIEW_REFRESH_TIME.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startKMLNetworkLink(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(VISIBILITY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VISIBILITY, def: false,
   at: VTOFFSET.VISIBILITY.p) }
  public static func add(HREF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HREF, at: VTOFFSET.HREF.p) }
  public static func add(REFRESH_MODE: KMLRefreshMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REFRESH_MODE.rawValue, def: 0, at: VTOFFSET.REFRESH_MODE.p) }
  public static func add(REFRESH_INTERVAL: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REFRESH_INTERVAL, def: 0.0, at: VTOFFSET.REFRESH_INTERVAL.p) }
  public static func add(VIEW_REFRESH_MODE: KMLViewRefreshMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VIEW_REFRESH_MODE.rawValue, def: 0, at: VTOFFSET.VIEW_REFRESH_MODE.p) }
  public static func add(VIEW_REFRESH_TIME: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VIEW_REFRESH_TIME, def: 0.0, at: VTOFFSET.VIEW_REFRESH_TIME.p) }
  public static func endKMLNetworkLink(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLNetworkLink(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    VISIBILITY: Bool = false,
    HREFOffset HREF: Offset = Offset(),
    REFRESH_MODE: KMLRefreshMode = .onChange,
    REFRESH_INTERVAL: Double = 0.0,
    VIEW_REFRESH_MODE: KMLViewRefreshMode = .never,
    VIEW_REFRESH_TIME: Double = 0.0
  ) -> Offset {
    let __start = KMLNetworkLink.startKMLNetworkLink(&fbb)
    KMLNetworkLink.add(NAME: NAME, &fbb)
    KMLNetworkLink.add(VISIBILITY: VISIBILITY, &fbb)
    KMLNetworkLink.add(HREF: HREF, &fbb)
    KMLNetworkLink.add(REFRESH_MODE: REFRESH_MODE, &fbb)
    KMLNetworkLink.add(REFRESH_INTERVAL: REFRESH_INTERVAL, &fbb)
    KMLNetworkLink.add(VIEW_REFRESH_MODE: VIEW_REFRESH_MODE, &fbb)
    KMLNetworkLink.add(VIEW_REFRESH_TIME: VIEW_REFRESH_TIME, &fbb)
    return KMLNetworkLink.endKMLNetworkLink(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VISIBILITY.p, fieldName: "VISIBILITY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.HREF.p, fieldName: "HREF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REFRESH_MODE.p, fieldName: "REFRESH_MODE", required: false, type: KMLRefreshMode.self)
    try _v.visit(field: VTOFFSET.REFRESH_INTERVAL.p, fieldName: "REFRESH_INTERVAL", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VIEW_REFRESH_MODE.p, fieldName: "VIEW_REFRESH_MODE", required: false, type: KMLViewRefreshMode.self)
    try _v.visit(field: VTOFFSET.VIEW_REFRESH_TIME.p, fieldName: "VIEW_REFRESH_TIME", required: false, type: Double.self)
    _v.finish()
  }
}

///  Ground overlay
public struct KMLGroundOverlay: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLGroundOverlay.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DESCRIPTION = 6
    case VISIBILITY = 8
    case ICON_HREF = 10
    case COLOR = 12
    case NORTH = 14
    case SOUTH = 16
    case EAST = 18
    case WEST = 20
    case ROTATION = 22
    case ALTITUDE = 24
    case ALTITUDE_MODE = 26
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Visibility
  public var VISIBILITY: Bool { let o = _accessor.offset(VTOFFSET.VISIBILITY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Icon/image URL
  public var ICON_HREF: String? { let o = _accessor.offset(VTOFFSET.ICON_HREF.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ICON_HREFSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ICON_HREF.v) }
  ///  Color in aabbggrr hex format
  public var COLOR: String? { let o = _accessor.offset(VTOFFSET.COLOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLOR.v) }
  ///  North latitude of bounding box
  public var NORTH: Double { let o = _accessor.offset(VTOFFSET.NORTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  South latitude of bounding box
  public var SOUTH: Double { let o = _accessor.offset(VTOFFSET.SOUTH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  East longitude of bounding box
  public var EAST: Double { let o = _accessor.offset(VTOFFSET.EAST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  West longitude of bounding box
  public var WEST: Double { let o = _accessor.offset(VTOFFSET.WEST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Rotation in degrees
  public var ROTATION: Double { let o = _accessor.offset(VTOFFSET.ROTATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude in meters
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Altitude mode
  public var ALTITUDE_MODE: KMLAltitudeMode { let o = _accessor.offset(VTOFFSET.ALTITUDE_MODE.v); return o == 0 ? .clampToGround : KMLAltitudeMode(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .clampToGround }
  public static func startKMLGroundOverlay(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 12) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(VISIBILITY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VISIBILITY, def: false,
   at: VTOFFSET.VISIBILITY.p) }
  public static func add(ICON_HREF: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ICON_HREF, at: VTOFFSET.ICON_HREF.p) }
  public static func add(COLOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLOR, at: VTOFFSET.COLOR.p) }
  public static func add(NORTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORTH, def: 0.0, at: VTOFFSET.NORTH.p) }
  public static func add(SOUTH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOUTH, def: 0.0, at: VTOFFSET.SOUTH.p) }
  public static func add(EAST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EAST, def: 0.0, at: VTOFFSET.EAST.p) }
  public static func add(WEST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WEST, def: 0.0, at: VTOFFSET.WEST.p) }
  public static func add(ROTATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ROTATION, def: 0.0, at: VTOFFSET.ROTATION.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func add(ALTITUDE_MODE: KMLAltitudeMode, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE_MODE.rawValue, def: 0, at: VTOFFSET.ALTITUDE_MODE.p) }
  public static func endKMLGroundOverlay(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLGroundOverlay(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    VISIBILITY: Bool = false,
    ICON_HREFOffset ICON_HREF: Offset = Offset(),
    COLOROffset COLOR: Offset = Offset(),
    NORTH: Double = 0.0,
    SOUTH: Double = 0.0,
    EAST: Double = 0.0,
    WEST: Double = 0.0,
    ROTATION: Double = 0.0,
    ALTITUDE: Double = 0.0,
    ALTITUDE_MODE: KMLAltitudeMode = .clampToGround
  ) -> Offset {
    let __start = KMLGroundOverlay.startKMLGroundOverlay(&fbb)
    KMLGroundOverlay.add(NAME: NAME, &fbb)
    KMLGroundOverlay.add(DESCRIPTION: DESCRIPTION, &fbb)
    KMLGroundOverlay.add(VISIBILITY: VISIBILITY, &fbb)
    KMLGroundOverlay.add(ICON_HREF: ICON_HREF, &fbb)
    KMLGroundOverlay.add(COLOR: COLOR, &fbb)
    KMLGroundOverlay.add(NORTH: NORTH, &fbb)
    KMLGroundOverlay.add(SOUTH: SOUTH, &fbb)
    KMLGroundOverlay.add(EAST: EAST, &fbb)
    KMLGroundOverlay.add(WEST: WEST, &fbb)
    KMLGroundOverlay.add(ROTATION: ROTATION, &fbb)
    KMLGroundOverlay.add(ALTITUDE: ALTITUDE, &fbb)
    KMLGroundOverlay.add(ALTITUDE_MODE: ALTITUDE_MODE, &fbb)
    return KMLGroundOverlay.endKMLGroundOverlay(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VISIBILITY.p, fieldName: "VISIBILITY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.ICON_HREF.p, fieldName: "ICON_HREF", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLOR.p, fieldName: "COLOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NORTH.p, fieldName: "NORTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SOUTH.p, fieldName: "SOUTH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.EAST.p, fieldName: "EAST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.WEST.p, fieldName: "WEST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ROTATION.p, fieldName: "ROTATION", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE_MODE.p, fieldName: "ALTITUDE_MODE", required: false, type: KMLAltitudeMode.self)
    _v.finish()
  }
}

///  Placemark feature
public struct KMLPlacemark: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLPlacemark.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DESCRIPTION = 6
    case VISIBILITY = 8
    case STYLE_URL = 10
    case STYLE = 12
    case SNIPPET = 14
    case POINT = 16
    case LINE_STRING = 18
    case POLYGON = 20
    case MULTI_GEOMETRY = 22
    case LOOK_AT = 24
    case CAMERA = 26
    case TIME_SPAN = 28
    case TIME_STAMP = 30
    case EXTENDED_DATA = 32
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Placemark name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Description (may contain HTML)
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Visibility flag
  public var VISIBILITY: Bool { let o = _accessor.offset(VTOFFSET.VISIBILITY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Style URL reference
  public var STYLE_URL: String? { let o = _accessor.offset(VTOFFSET.STYLE_URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STYLE_URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STYLE_URL.v) }
  ///  Inline style
  public var STYLE: KMLStyle? { let o = _accessor.offset(VTOFFSET.STYLE.v); return o == 0 ? nil : KMLStyle(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Snippet (short description)
  public var SNIPPET: String? { let o = _accessor.offset(VTOFFSET.SNIPPET.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SNIPPETSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SNIPPET.v) }
  ///  Point geometry
  public var POINT: KMLPoint? { let o = _accessor.offset(VTOFFSET.POINT.v); return o == 0 ? nil : KMLPoint(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  LineString geometry
  public var LINE_STRING: KMLLineString? { let o = _accessor.offset(VTOFFSET.LINE_STRING.v); return o == 0 ? nil : KMLLineString(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Polygon geometry
  public var POLYGON: KMLPolygon? { let o = _accessor.offset(VTOFFSET.POLYGON.v); return o == 0 ? nil : KMLPolygon(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  MultiGeometry
  public var MULTI_GEOMETRY: KMLMultiGeometry? { let o = _accessor.offset(VTOFFSET.MULTI_GEOMETRY.v); return o == 0 ? nil : KMLMultiGeometry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  LookAt viewpoint
  public var LOOK_AT: KMLLookAt? { let o = _accessor.offset(VTOFFSET.LOOK_AT.v); return o == 0 ? nil : KMLLookAt(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Camera viewpoint
  public var CAMERA: KMLCamera? { let o = _accessor.offset(VTOFFSET.CAMERA.v); return o == 0 ? nil : KMLCamera(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  TimeSpan
  public var TIME_SPAN: KMLTimeSpan? { let o = _accessor.offset(VTOFFSET.TIME_SPAN.v); return o == 0 ? nil : KMLTimeSpan(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  TimeStamp
  public var TIME_STAMP: KMLTimeStamp? { let o = _accessor.offset(VTOFFSET.TIME_STAMP.v); return o == 0 ? nil : KMLTimeStamp(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Extended data
  public var hasExtendedData: Bool { let o = _accessor.offset(VTOFFSET.EXTENDED_DATA.v); return o == 0 ? false : true }
  public var EXTENDED_DATACount: Int32 { let o = _accessor.offset(VTOFFSET.EXTENDED_DATA.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func EXTENDED_DATA(at index: Int32) -> KMLData? { let o = _accessor.offset(VTOFFSET.EXTENDED_DATA.v); return o == 0 ? nil : KMLData(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKMLPlacemark(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 15) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(VISIBILITY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VISIBILITY, def: false,
   at: VTOFFSET.VISIBILITY.p) }
  public static func add(STYLE_URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STYLE_URL, at: VTOFFSET.STYLE_URL.p) }
  public static func add(STYLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STYLE, at: VTOFFSET.STYLE.p) }
  public static func add(SNIPPET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SNIPPET, at: VTOFFSET.SNIPPET.p) }
  public static func add(POINT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POINT, at: VTOFFSET.POINT.p) }
  public static func add(LINE_STRING: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LINE_STRING, at: VTOFFSET.LINE_STRING.p) }
  public static func add(POLYGON: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POLYGON, at: VTOFFSET.POLYGON.p) }
  public static func add(MULTI_GEOMETRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MULTI_GEOMETRY, at: VTOFFSET.MULTI_GEOMETRY.p) }
  public static func add(LOOK_AT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOOK_AT, at: VTOFFSET.LOOK_AT.p) }
  public static func add(CAMERA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CAMERA, at: VTOFFSET.CAMERA.p) }
  public static func add(TIME_SPAN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME_SPAN, at: VTOFFSET.TIME_SPAN.p) }
  public static func add(TIME_STAMP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME_STAMP, at: VTOFFSET.TIME_STAMP.p) }
  public static func addVectorOf(EXTENDED_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EXTENDED_DATA, at: VTOFFSET.EXTENDED_DATA.p) }
  public static func endKMLPlacemark(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLPlacemark(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    VISIBILITY: Bool = false,
    STYLE_URLOffset STYLE_URL: Offset = Offset(),
    STYLEOffset STYLE: Offset = Offset(),
    SNIPPETOffset SNIPPET: Offset = Offset(),
    POINTOffset POINT: Offset = Offset(),
    LINE_STRINGOffset LINE_STRING: Offset = Offset(),
    POLYGONOffset POLYGON: Offset = Offset(),
    MULTI_GEOMETRYOffset MULTI_GEOMETRY: Offset = Offset(),
    LOOK_ATOffset LOOK_AT: Offset = Offset(),
    CAMERAOffset CAMERA: Offset = Offset(),
    TIME_SPANOffset TIME_SPAN: Offset = Offset(),
    TIME_STAMPOffset TIME_STAMP: Offset = Offset(),
    EXTENDED_DATAVectorOffset EXTENDED_DATA: Offset = Offset()
  ) -> Offset {
    let __start = KMLPlacemark.startKMLPlacemark(&fbb)
    KMLPlacemark.add(NAME: NAME, &fbb)
    KMLPlacemark.add(DESCRIPTION: DESCRIPTION, &fbb)
    KMLPlacemark.add(VISIBILITY: VISIBILITY, &fbb)
    KMLPlacemark.add(STYLE_URL: STYLE_URL, &fbb)
    KMLPlacemark.add(STYLE: STYLE, &fbb)
    KMLPlacemark.add(SNIPPET: SNIPPET, &fbb)
    KMLPlacemark.add(POINT: POINT, &fbb)
    KMLPlacemark.add(LINE_STRING: LINE_STRING, &fbb)
    KMLPlacemark.add(POLYGON: POLYGON, &fbb)
    KMLPlacemark.add(MULTI_GEOMETRY: MULTI_GEOMETRY, &fbb)
    KMLPlacemark.add(LOOK_AT: LOOK_AT, &fbb)
    KMLPlacemark.add(CAMERA: CAMERA, &fbb)
    KMLPlacemark.add(TIME_SPAN: TIME_SPAN, &fbb)
    KMLPlacemark.add(TIME_STAMP: TIME_STAMP, &fbb)
    KMLPlacemark.addVectorOf(EXTENDED_DATA: EXTENDED_DATA, &fbb)
    return KMLPlacemark.endKMLPlacemark(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VISIBILITY.p, fieldName: "VISIBILITY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.STYLE_URL.p, fieldName: "STYLE_URL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STYLE.p, fieldName: "STYLE", required: false, type: ForwardOffset<KMLStyle>.self)
    try _v.visit(field: VTOFFSET.SNIPPET.p, fieldName: "SNIPPET", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POINT.p, fieldName: "POINT", required: false, type: ForwardOffset<KMLPoint>.self)
    try _v.visit(field: VTOFFSET.LINE_STRING.p, fieldName: "LINE_STRING", required: false, type: ForwardOffset<KMLLineString>.self)
    try _v.visit(field: VTOFFSET.POLYGON.p, fieldName: "POLYGON", required: false, type: ForwardOffset<KMLPolygon>.self)
    try _v.visit(field: VTOFFSET.MULTI_GEOMETRY.p, fieldName: "MULTI_GEOMETRY", required: false, type: ForwardOffset<KMLMultiGeometry>.self)
    try _v.visit(field: VTOFFSET.LOOK_AT.p, fieldName: "LOOK_AT", required: false, type: ForwardOffset<KMLLookAt>.self)
    try _v.visit(field: VTOFFSET.CAMERA.p, fieldName: "CAMERA", required: false, type: ForwardOffset<KMLCamera>.self)
    try _v.visit(field: VTOFFSET.TIME_SPAN.p, fieldName: "TIME_SPAN", required: false, type: ForwardOffset<KMLTimeSpan>.self)
    try _v.visit(field: VTOFFSET.TIME_STAMP.p, fieldName: "TIME_STAMP", required: false, type: ForwardOffset<KMLTimeStamp>.self)
    try _v.visit(field: VTOFFSET.EXTENDED_DATA.p, fieldName: "EXTENDED_DATA", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLData>, KMLData>>.self)
    _v.finish()
  }
}

///  Folder container
public struct KMLFolder: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KMLFolder.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DESCRIPTION = 6
    case VISIBILITY = 8
    case OPEN = 10
    case PLACEMARKS = 12
    case FOLDERS = 14
    case NETWORK_LINKS = 16
    case GROUND_OVERLAYS = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Folder name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Visibility flag
  public var VISIBILITY: Bool { let o = _accessor.offset(VTOFFSET.VISIBILITY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Whether folder is open in tree view
  public var OPEN: Bool { let o = _accessor.offset(VTOFFSET.OPEN.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Placemarks in this folder
  public var hasPlacemarks: Bool { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? false : true }
  public var PLACEMARKSCount: Int32 { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PLACEMARKS(at index: Int32) -> KMLPlacemark? { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? nil : KMLPlacemark(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Sub-folders
  public var hasFolders: Bool { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? false : true }
  public var FOLDERSCount: Int32 { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FOLDERS(at index: Int32) -> KMLFolder? { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? nil : KMLFolder(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Network links
  public var hasNetworkLinks: Bool { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? false : true }
  public var NETWORK_LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func NETWORK_LINKS(at index: Int32) -> KMLNetworkLink? { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? nil : KMLNetworkLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Ground overlays
  public var hasGroundOverlays: Bool { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? false : true }
  public var GROUND_OVERLAYSCount: Int32 { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func GROUND_OVERLAYS(at index: Int32) -> KMLGroundOverlay? { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? nil : KMLGroundOverlay(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKMLFolder(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(VISIBILITY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VISIBILITY, def: false,
   at: VTOFFSET.VISIBILITY.p) }
  public static func add(OPEN: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OPEN, def: false,
   at: VTOFFSET.OPEN.p) }
  public static func addVectorOf(PLACEMARKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PLACEMARKS, at: VTOFFSET.PLACEMARKS.p) }
  public static func addVectorOf(FOLDERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FOLDERS, at: VTOFFSET.FOLDERS.p) }
  public static func addVectorOf(NETWORK_LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NETWORK_LINKS, at: VTOFFSET.NETWORK_LINKS.p) }
  public static func addVectorOf(GROUND_OVERLAYS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GROUND_OVERLAYS, at: VTOFFSET.GROUND_OVERLAYS.p) }
  public static func endKMLFolder(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKMLFolder(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    VISIBILITY: Bool = false,
    OPEN: Bool = false,
    PLACEMARKSVectorOffset PLACEMARKS: Offset = Offset(),
    FOLDERSVectorOffset FOLDERS: Offset = Offset(),
    NETWORK_LINKSVectorOffset NETWORK_LINKS: Offset = Offset(),
    GROUND_OVERLAYSVectorOffset GROUND_OVERLAYS: Offset = Offset()
  ) -> Offset {
    let __start = KMLFolder.startKMLFolder(&fbb)
    KMLFolder.add(NAME: NAME, &fbb)
    KMLFolder.add(DESCRIPTION: DESCRIPTION, &fbb)
    KMLFolder.add(VISIBILITY: VISIBILITY, &fbb)
    KMLFolder.add(OPEN: OPEN, &fbb)
    KMLFolder.addVectorOf(PLACEMARKS: PLACEMARKS, &fbb)
    KMLFolder.addVectorOf(FOLDERS: FOLDERS, &fbb)
    KMLFolder.addVectorOf(NETWORK_LINKS: NETWORK_LINKS, &fbb)
    KMLFolder.addVectorOf(GROUND_OVERLAYS: GROUND_OVERLAYS, &fbb)
    return KMLFolder.endKMLFolder(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VISIBILITY.p, fieldName: "VISIBILITY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OPEN.p, fieldName: "OPEN", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.PLACEMARKS.p, fieldName: "PLACEMARKS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLPlacemark>, KMLPlacemark>>.self)
    try _v.visit(field: VTOFFSET.FOLDERS.p, fieldName: "FOLDERS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLFolder>, KMLFolder>>.self)
    try _v.visit(field: VTOFFSET.NETWORK_LINKS.p, fieldName: "NETWORK_LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLNetworkLink>, KMLNetworkLink>>.self)
    try _v.visit(field: VTOFFSET.GROUND_OVERLAYS.p, fieldName: "GROUND_OVERLAYS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLGroundOverlay>, KMLGroundOverlay>>.self)
    _v.finish()
  }
}

///  KML Document
public struct KML: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$KML" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: KML.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case DESCRIPTION = 6
    case VISIBILITY = 8
    case OPEN = 10
    case STYLES = 12
    case STYLE_MAPS = 14
    case PLACEMARKS = 16
    case FOLDERS = 18
    case NETWORK_LINKS = 20
    case GROUND_OVERLAYS = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Document name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Document description
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  Whether document is visible
  public var VISIBILITY: Bool { let o = _accessor.offset(VTOFFSET.VISIBILITY.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Whether document is open in tree view
  public var OPEN: Bool { let o = _accessor.offset(VTOFFSET.OPEN.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Shared styles
  public var hasStyles: Bool { let o = _accessor.offset(VTOFFSET.STYLES.v); return o == 0 ? false : true }
  public var STYLESCount: Int32 { let o = _accessor.offset(VTOFFSET.STYLES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STYLES(at index: Int32) -> KMLStyle? { let o = _accessor.offset(VTOFFSET.STYLES.v); return o == 0 ? nil : KMLStyle(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Style maps
  public var hasStyleMaps: Bool { let o = _accessor.offset(VTOFFSET.STYLE_MAPS.v); return o == 0 ? false : true }
  public var STYLE_MAPSCount: Int32 { let o = _accessor.offset(VTOFFSET.STYLE_MAPS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STYLE_MAPS(at index: Int32) -> KMLStyleMap? { let o = _accessor.offset(VTOFFSET.STYLE_MAPS.v); return o == 0 ? nil : KMLStyleMap(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Top-level placemarks
  public var hasPlacemarks: Bool { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? false : true }
  public var PLACEMARKSCount: Int32 { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func PLACEMARKS(at index: Int32) -> KMLPlacemark? { let o = _accessor.offset(VTOFFSET.PLACEMARKS.v); return o == 0 ? nil : KMLPlacemark(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Top-level folders
  public var hasFolders: Bool { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? false : true }
  public var FOLDERSCount: Int32 { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FOLDERS(at index: Int32) -> KMLFolder? { let o = _accessor.offset(VTOFFSET.FOLDERS.v); return o == 0 ? nil : KMLFolder(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Network links
  public var hasNetworkLinks: Bool { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? false : true }
  public var NETWORK_LINKSCount: Int32 { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func NETWORK_LINKS(at index: Int32) -> KMLNetworkLink? { let o = _accessor.offset(VTOFFSET.NETWORK_LINKS.v); return o == 0 ? nil : KMLNetworkLink(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Ground overlays
  public var hasGroundOverlays: Bool { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? false : true }
  public var GROUND_OVERLAYSCount: Int32 { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func GROUND_OVERLAYS(at index: Int32) -> KMLGroundOverlay? { let o = _accessor.offset(VTOFFSET.GROUND_OVERLAYS.v); return o == 0 ? nil : KMLGroundOverlay(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startKML(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(VISIBILITY: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VISIBILITY, def: false,
   at: VTOFFSET.VISIBILITY.p) }
  public static func add(OPEN: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OPEN, def: false,
   at: VTOFFSET.OPEN.p) }
  public static func addVectorOf(STYLES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STYLES, at: VTOFFSET.STYLES.p) }
  public static func addVectorOf(STYLE_MAPS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STYLE_MAPS, at: VTOFFSET.STYLE_MAPS.p) }
  public static func addVectorOf(PLACEMARKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PLACEMARKS, at: VTOFFSET.PLACEMARKS.p) }
  public static func addVectorOf(FOLDERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FOLDERS, at: VTOFFSET.FOLDERS.p) }
  public static func addVectorOf(NETWORK_LINKS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NETWORK_LINKS, at: VTOFFSET.NETWORK_LINKS.p) }
  public static func addVectorOf(GROUND_OVERLAYS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GROUND_OVERLAYS, at: VTOFFSET.GROUND_OVERLAYS.p) }
  public static func endKML(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createKML(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    VISIBILITY: Bool = false,
    OPEN: Bool = false,
    STYLESVectorOffset STYLES: Offset = Offset(),
    STYLE_MAPSVectorOffset STYLE_MAPS: Offset = Offset(),
    PLACEMARKSVectorOffset PLACEMARKS: Offset = Offset(),
    FOLDERSVectorOffset FOLDERS: Offset = Offset(),
    NETWORK_LINKSVectorOffset NETWORK_LINKS: Offset = Offset(),
    GROUND_OVERLAYSVectorOffset GROUND_OVERLAYS: Offset = Offset()
  ) -> Offset {
    let __start = KML.startKML(&fbb)
    KML.add(NAME: NAME, &fbb)
    KML.add(DESCRIPTION: DESCRIPTION, &fbb)
    KML.add(VISIBILITY: VISIBILITY, &fbb)
    KML.add(OPEN: OPEN, &fbb)
    KML.addVectorOf(STYLES: STYLES, &fbb)
    KML.addVectorOf(STYLE_MAPS: STYLE_MAPS, &fbb)
    KML.addVectorOf(PLACEMARKS: PLACEMARKS, &fbb)
    KML.addVectorOf(FOLDERS: FOLDERS, &fbb)
    KML.addVectorOf(NETWORK_LINKS: NETWORK_LINKS, &fbb)
    KML.addVectorOf(GROUND_OVERLAYS: GROUND_OVERLAYS, &fbb)
    return KML.endKML(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VISIBILITY.p, fieldName: "VISIBILITY", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OPEN.p, fieldName: "OPEN", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.STYLES.p, fieldName: "STYLES", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLStyle>, KMLStyle>>.self)
    try _v.visit(field: VTOFFSET.STYLE_MAPS.p, fieldName: "STYLE_MAPS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLStyleMap>, KMLStyleMap>>.self)
    try _v.visit(field: VTOFFSET.PLACEMARKS.p, fieldName: "PLACEMARKS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLPlacemark>, KMLPlacemark>>.self)
    try _v.visit(field: VTOFFSET.FOLDERS.p, fieldName: "FOLDERS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLFolder>, KMLFolder>>.self)
    try _v.visit(field: VTOFFSET.NETWORK_LINKS.p, fieldName: "NETWORK_LINKS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLNetworkLink>, KMLNetworkLink>>.self)
    try _v.visit(field: VTOFFSET.GROUND_OVERLAYS.p, fieldName: "GROUND_OVERLAYS", required: false, type: ForwardOffset<Vector<ForwardOffset<KMLGroundOverlay>, KMLGroundOverlay>>.self)
    _v.finish()
  }
}

