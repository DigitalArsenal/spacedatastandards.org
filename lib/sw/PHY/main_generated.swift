// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum IntegrationMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case euler = 0
  case eulerImproved = 1
  case rk2 = 2
  case rk4 = 3
  case rk45 = 4
  case rk78 = 5
  case verlet = 6
  case leapfrog = 7
  case adamsBashforth = 8
  case gaussJackson = 9

  public static var max: IntegrationMethod { return .gaussJackson }
  public static var min: IntegrationMethod { return .euler }
}


public enum CollisionShape: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case sphere = 0
  case box = 1
  case cylinder = 2
  case capsule = 3
  case cone = 4
  case convexHull = 5
  case mesh = 6
  case compound = 7

  public static var max: CollisionShape { return .compound }
  public static var min: CollisionShape { return .sphere }
}


public enum MaterialType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case steel = 0
  case aluminum = 1
  case titanium = 2
  case ceramic = 3
  case composite = 4
  case concrete = 5
  case wood = 6
  case rubber = 7
  case water = 8
  case air = 9
  case custom = 10

  public static var max: MaterialType { return .custom }
  public static var min: MaterialType { return .steel }
}


public enum ForceType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case gravity = 0
  case thrust = 1
  case drag = 2
  case lift = 3
  case friction = 4
  case spring = 5
  case damper = 6
  case contact = 7
  case magnetic = 8
  case electric = 9
  case custom = 10

  public static var max: ForceType { return .custom }
  public static var min: ForceType { return .gravity }
}


///  Physics and Rigid Body Dynamics
public struct PHY: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PHY" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PHY.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMAND = 4
    case SIMULATION_STEP = 6
    case RIGID_BODY = 8
    case INTEGRATION_CONFIG = 10
    case COLLISION_QUERY_A = 12
    case COLLISION_QUERY_B = 14
    case TRANSFORM_A = 16
    case TRANSFORM_B = 18
    case POSITION_A = 20
    case POSITION_B = 22
    case FLUID = 24
    case AERO_QUERY = 26
    case DRAG_MODEL = 28
    case THERMAL_STATE = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var COMMAND: String? { let o = _accessor.offset(VTOFFSET.COMMAND.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMANDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMAND.v) }
  public var SIMULATION_STEP: String? { let o = _accessor.offset(VTOFFSET.SIMULATION_STEP.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SIMULATION_STEPSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SIMULATION_STEP.v) }
  public var RIGID_BODY: String? { let o = _accessor.offset(VTOFFSET.RIGID_BODY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var RIGID_BODYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.RIGID_BODY.v) }
  public var INTEGRATION_CONFIG: String? { let o = _accessor.offset(VTOFFSET.INTEGRATION_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INTEGRATION_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INTEGRATION_CONFIG.v) }
  public var COLLISION_QUERY_A: String? { let o = _accessor.offset(VTOFFSET.COLLISION_QUERY_A.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLLISION_QUERY_ASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLLISION_QUERY_A.v) }
  public var COLLISION_QUERY_B: String? { let o = _accessor.offset(VTOFFSET.COLLISION_QUERY_B.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COLLISION_QUERY_BSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COLLISION_QUERY_B.v) }
  public var TRANSFORM_A: String? { let o = _accessor.offset(VTOFFSET.TRANSFORM_A.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRANSFORM_ASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRANSFORM_A.v) }
  public var TRANSFORM_B: String? { let o = _accessor.offset(VTOFFSET.TRANSFORM_B.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRANSFORM_BSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRANSFORM_B.v) }
  public var POSITION_A: String? { let o = _accessor.offset(VTOFFSET.POSITION_A.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POSITION_ASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POSITION_A.v) }
  public var POSITION_B: String? { let o = _accessor.offset(VTOFFSET.POSITION_B.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POSITION_BSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POSITION_B.v) }
  public var FLUID: String? { let o = _accessor.offset(VTOFFSET.FLUID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FLUIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FLUID.v) }
  public var AERO_QUERY: String? { let o = _accessor.offset(VTOFFSET.AERO_QUERY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AERO_QUERYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AERO_QUERY.v) }
  public var DRAG_MODEL: String? { let o = _accessor.offset(VTOFFSET.DRAG_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DRAG_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DRAG_MODEL.v) }
  public var THERMAL_STATE: String? { let o = _accessor.offset(VTOFFSET.THERMAL_STATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var THERMAL_STATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.THERMAL_STATE.v) }
  public static func startPHY(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(COMMAND: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND, at: VTOFFSET.COMMAND.p) }
  public static func add(SIMULATION_STEP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIMULATION_STEP, at: VTOFFSET.SIMULATION_STEP.p) }
  public static func add(RIGID_BODY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RIGID_BODY, at: VTOFFSET.RIGID_BODY.p) }
  public static func add(INTEGRATION_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTEGRATION_CONFIG, at: VTOFFSET.INTEGRATION_CONFIG.p) }
  public static func add(COLLISION_QUERY_A: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLLISION_QUERY_A, at: VTOFFSET.COLLISION_QUERY_A.p) }
  public static func add(COLLISION_QUERY_B: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COLLISION_QUERY_B, at: VTOFFSET.COLLISION_QUERY_B.p) }
  public static func add(TRANSFORM_A: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRANSFORM_A, at: VTOFFSET.TRANSFORM_A.p) }
  public static func add(TRANSFORM_B: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRANSFORM_B, at: VTOFFSET.TRANSFORM_B.p) }
  public static func add(POSITION_A: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_A, at: VTOFFSET.POSITION_A.p) }
  public static func add(POSITION_B: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSITION_B, at: VTOFFSET.POSITION_B.p) }
  public static func add(FLUID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FLUID, at: VTOFFSET.FLUID.p) }
  public static func add(AERO_QUERY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AERO_QUERY, at: VTOFFSET.AERO_QUERY.p) }
  public static func add(DRAG_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DRAG_MODEL, at: VTOFFSET.DRAG_MODEL.p) }
  public static func add(THERMAL_STATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: THERMAL_STATE, at: VTOFFSET.THERMAL_STATE.p) }
  public static func endPHY(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPHY(
    _ fbb: inout FlatBufferBuilder,
    COMMANDOffset COMMAND: Offset = Offset(),
    SIMULATION_STEPOffset SIMULATION_STEP: Offset = Offset(),
    RIGID_BODYOffset RIGID_BODY: Offset = Offset(),
    INTEGRATION_CONFIGOffset INTEGRATION_CONFIG: Offset = Offset(),
    COLLISION_QUERY_AOffset COLLISION_QUERY_A: Offset = Offset(),
    COLLISION_QUERY_BOffset COLLISION_QUERY_B: Offset = Offset(),
    TRANSFORM_AOffset TRANSFORM_A: Offset = Offset(),
    TRANSFORM_BOffset TRANSFORM_B: Offset = Offset(),
    POSITION_AOffset POSITION_A: Offset = Offset(),
    POSITION_BOffset POSITION_B: Offset = Offset(),
    FLUIDOffset FLUID: Offset = Offset(),
    AERO_QUERYOffset AERO_QUERY: Offset = Offset(),
    DRAG_MODELOffset DRAG_MODEL: Offset = Offset(),
    THERMAL_STATEOffset THERMAL_STATE: Offset = Offset()
  ) -> Offset {
    let __start = PHY.startPHY(&fbb)
    PHY.add(COMMAND: COMMAND, &fbb)
    PHY.add(SIMULATION_STEP: SIMULATION_STEP, &fbb)
    PHY.add(RIGID_BODY: RIGID_BODY, &fbb)
    PHY.add(INTEGRATION_CONFIG: INTEGRATION_CONFIG, &fbb)
    PHY.add(COLLISION_QUERY_A: COLLISION_QUERY_A, &fbb)
    PHY.add(COLLISION_QUERY_B: COLLISION_QUERY_B, &fbb)
    PHY.add(TRANSFORM_A: TRANSFORM_A, &fbb)
    PHY.add(TRANSFORM_B: TRANSFORM_B, &fbb)
    PHY.add(POSITION_A: POSITION_A, &fbb)
    PHY.add(POSITION_B: POSITION_B, &fbb)
    PHY.add(FLUID: FLUID, &fbb)
    PHY.add(AERO_QUERY: AERO_QUERY, &fbb)
    PHY.add(DRAG_MODEL: DRAG_MODEL, &fbb)
    PHY.add(THERMAL_STATE: THERMAL_STATE, &fbb)
    return PHY.endPHY(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMAND.p, fieldName: "COMMAND", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIMULATION_STEP.p, fieldName: "SIMULATION_STEP", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.RIGID_BODY.p, fieldName: "RIGID_BODY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTEGRATION_CONFIG.p, fieldName: "INTEGRATION_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLLISION_QUERY_A.p, fieldName: "COLLISION_QUERY_A", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COLLISION_QUERY_B.p, fieldName: "COLLISION_QUERY_B", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRANSFORM_A.p, fieldName: "TRANSFORM_A", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRANSFORM_B.p, fieldName: "TRANSFORM_B", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSITION_A.p, fieldName: "POSITION_A", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSITION_B.p, fieldName: "POSITION_B", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FLUID.p, fieldName: "FLUID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AERO_QUERY.p, fieldName: "AERO_QUERY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DRAG_MODEL.p, fieldName: "DRAG_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.THERMAL_STATE.p, fieldName: "THERMAL_STATE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

