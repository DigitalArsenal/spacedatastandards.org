// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum MissileType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case aamIr = 0
  case aamSarh = 1
  case aamArh = 2
  case samIr = 3
  case samSarh = 4
  case samCommand = 5
  case asmAr = 6
  case asmTv = 7
  case asmLaser = 8
  case atgmSaclos = 9
  case atgmBeam = 10
  case atgmTop = 11
  case cruise = 12
  case ballistic = 13
  case torpedo = 14

  public static var max: MissileType { return .torpedo }
  public static var min: MissileType { return .aamIr }
}


public enum SeekerType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case irUncooled = 1
  case irCooled = 2
  case irImaging = 3
  case ir2color = 4
  case radarSarh = 5
  case radarArh = 6
  case radarPassive = 7
  case tvOptical = 8
  case laserSh = 9
  case gpsIns = 10
  case acoustic = 11
  case wire = 12

  public static var max: SeekerType { return .wire }
  public static var min: SeekerType { return .none_ }
}


public enum GuidanceLaw: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case purePursuit = 1
  case leadPursuit = 2
  case proportionalNav = 3
  case augmentedPn = 4
  case optimalGuidance = 5
  case commandLos = 6
  case beamRiding = 7
  case tvm = 8
  case loft = 9
  case terrainFollow = 10

  public static var max: GuidanceLaw { return .terrainFollow }
  public static var min: GuidanceLaw { return .none_ }
}


public enum MissilePhase: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case captive = 0
  case launch = 1
  case boost = 2
  case sustain = 3
  case coast = 4
  case terminal = 5
  case intercept = 6
  case miss = 7
  case selfDestruct = 8

  public static var max: MissilePhase { return .selfDestruct }
  public static var min: MissilePhase { return .captive }
}


public enum SeekerStatus: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case off = 0
  case caged = 1
  case uncaged = 2
  case acquiring = 3
  case tracking = 4
  case memory = 5
  case jammed = 6

  public static var max: SeekerStatus { return .jammed }
  public static var min: SeekerStatus { return .off }
}


///  Guided Missiles
public struct MSL: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$MSL" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: MSL.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case POSITION_X = 4
    case POSITION_Y = 6
    case POSITION_Z = 8
    case VELOCITY_X = 10
    case VELOCITY_Y = 12
    case VELOCITY_Z = 14
    case ATTITUDE_X = 16
    case ATTITUDE_Y = 18
    case ATTITUDE_Z = 20
    case ATTITUDE_W = 22
    case OMEGA_X = 24
    case OMEGA_Y = 26
    case OMEGA_Z = 28
    case MASS = 30
    case MASS_INITIAL = 32
    case TARGET_POSITION_X = 34
    case TARGET_POSITION_Y = 36
    case TARGET_POSITION_Z = 38
    case TARGET_VELOCITY_X = 40
    case TARGET_VELOCITY_Y = 42
    case TARGET_VELOCITY_Z = 44
    case MISS_DISTANCE = 46
    case SEEKER = 48
    case MOTOR = 50
    case GUIDANCE_CMD = 52
    case PHASE = 54
    case GUIDANCE_LAW = 56
    case TYPE = 58
    case ARMED = 60
    case TIME_OF_FLIGHT = 62
    case MAX_G = 64
    case RESERVED = 66
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var POSITION_X: Double { let o = _accessor.offset(VTOFFSET.POSITION_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var POSITION_Y: Double { let o = _accessor.offset(VTOFFSET.POSITION_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var POSITION_Z: Double { let o = _accessor.offset(VTOFFSET.POSITION_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var VELOCITY_X: Double { let o = _accessor.offset(VTOFFSET.VELOCITY_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var VELOCITY_Y: Double { let o = _accessor.offset(VTOFFSET.VELOCITY_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var VELOCITY_Z: Double { let o = _accessor.offset(VTOFFSET.VELOCITY_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ATTITUDE_X: Double { let o = _accessor.offset(VTOFFSET.ATTITUDE_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ATTITUDE_Y: Double { let o = _accessor.offset(VTOFFSET.ATTITUDE_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ATTITUDE_Z: Double { let o = _accessor.offset(VTOFFSET.ATTITUDE_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ATTITUDE_W: Double { let o = _accessor.offset(VTOFFSET.ATTITUDE_W.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var OMEGA_X: Double { let o = _accessor.offset(VTOFFSET.OMEGA_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var OMEGA_Y: Double { let o = _accessor.offset(VTOFFSET.OMEGA_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var OMEGA_Z: Double { let o = _accessor.offset(VTOFFSET.OMEGA_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MASS: Double { let o = _accessor.offset(VTOFFSET.MASS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MASS_INITIAL: Double { let o = _accessor.offset(VTOFFSET.MASS_INITIAL.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_POSITION_X: Double { let o = _accessor.offset(VTOFFSET.TARGET_POSITION_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_POSITION_Y: Double { let o = _accessor.offset(VTOFFSET.TARGET_POSITION_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_POSITION_Z: Double { let o = _accessor.offset(VTOFFSET.TARGET_POSITION_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_VELOCITY_X: Double { let o = _accessor.offset(VTOFFSET.TARGET_VELOCITY_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_VELOCITY_Y: Double { let o = _accessor.offset(VTOFFSET.TARGET_VELOCITY_Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var TARGET_VELOCITY_Z: Double { let o = _accessor.offset(VTOFFSET.TARGET_VELOCITY_Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MISS_DISTANCE: Double { let o = _accessor.offset(VTOFFSET.MISS_DISTANCE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var SEEKER: String? { let o = _accessor.offset(VTOFFSET.SEEKER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SEEKERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SEEKER.v) }
  public var MOTOR: String? { let o = _accessor.offset(VTOFFSET.MOTOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MOTORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MOTOR.v) }
  public var GUIDANCE_CMD: String? { let o = _accessor.offset(VTOFFSET.GUIDANCE_CMD.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GUIDANCE_CMDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GUIDANCE_CMD.v) }
  public var PHASE: UInt8 { let o = _accessor.offset(VTOFFSET.PHASE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var GUIDANCE_LAW: UInt8 { let o = _accessor.offset(VTOFFSET.GUIDANCE_LAW.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var TYPE: UInt8 { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var ARMED: UInt8 { let o = _accessor.offset(VTOFFSET.ARMED.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var TIME_OF_FLIGHT: Float32 { let o = _accessor.offset(VTOFFSET.TIME_OF_FLIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var MAX_G: Float32 { let o = _accessor.offset(VTOFFSET.MAX_G.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var hasReserved: Bool { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? false : true }
  public var RESERVEDCount: Int32 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RESERVED(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var RESERVED: [UInt8] { return _accessor.getVector(at: VTOFFSET.RESERVED.v) ?? [] }
  public static func startMSL(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 32) }
  public static func add(POSITION_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: POSITION_X, def: 0.0, at: VTOFFSET.POSITION_X.p) }
  public static func add(POSITION_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: POSITION_Y, def: 0.0, at: VTOFFSET.POSITION_Y.p) }
  public static func add(POSITION_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: POSITION_Z, def: 0.0, at: VTOFFSET.POSITION_Z.p) }
  public static func add(VELOCITY_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VELOCITY_X, def: 0.0, at: VTOFFSET.VELOCITY_X.p) }
  public static func add(VELOCITY_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VELOCITY_Y, def: 0.0, at: VTOFFSET.VELOCITY_Y.p) }
  public static func add(VELOCITY_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VELOCITY_Z, def: 0.0, at: VTOFFSET.VELOCITY_Z.p) }
  public static func add(ATTITUDE_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ATTITUDE_X, def: 0.0, at: VTOFFSET.ATTITUDE_X.p) }
  public static func add(ATTITUDE_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ATTITUDE_Y, def: 0.0, at: VTOFFSET.ATTITUDE_Y.p) }
  public static func add(ATTITUDE_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ATTITUDE_Z, def: 0.0, at: VTOFFSET.ATTITUDE_Z.p) }
  public static func add(ATTITUDE_W: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ATTITUDE_W, def: 0.0, at: VTOFFSET.ATTITUDE_W.p) }
  public static func add(OMEGA_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OMEGA_X, def: 0.0, at: VTOFFSET.OMEGA_X.p) }
  public static func add(OMEGA_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OMEGA_Y, def: 0.0, at: VTOFFSET.OMEGA_Y.p) }
  public static func add(OMEGA_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OMEGA_Z, def: 0.0, at: VTOFFSET.OMEGA_Z.p) }
  public static func add(MASS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MASS, def: 0.0, at: VTOFFSET.MASS.p) }
  public static func add(MASS_INITIAL: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MASS_INITIAL, def: 0.0, at: VTOFFSET.MASS_INITIAL.p) }
  public static func add(TARGET_POSITION_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_POSITION_X, def: 0.0, at: VTOFFSET.TARGET_POSITION_X.p) }
  public static func add(TARGET_POSITION_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_POSITION_Y, def: 0.0, at: VTOFFSET.TARGET_POSITION_Y.p) }
  public static func add(TARGET_POSITION_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_POSITION_Z, def: 0.0, at: VTOFFSET.TARGET_POSITION_Z.p) }
  public static func add(TARGET_VELOCITY_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_VELOCITY_X, def: 0.0, at: VTOFFSET.TARGET_VELOCITY_X.p) }
  public static func add(TARGET_VELOCITY_Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_VELOCITY_Y, def: 0.0, at: VTOFFSET.TARGET_VELOCITY_Y.p) }
  public static func add(TARGET_VELOCITY_Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TARGET_VELOCITY_Z, def: 0.0, at: VTOFFSET.TARGET_VELOCITY_Z.p) }
  public static func add(MISS_DISTANCE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MISS_DISTANCE, def: 0.0, at: VTOFFSET.MISS_DISTANCE.p) }
  public static func add(SEEKER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SEEKER, at: VTOFFSET.SEEKER.p) }
  public static func add(MOTOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MOTOR, at: VTOFFSET.MOTOR.p) }
  public static func add(GUIDANCE_CMD: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GUIDANCE_CMD, at: VTOFFSET.GUIDANCE_CMD.p) }
  public static func add(PHASE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PHASE, def: 0, at: VTOFFSET.PHASE.p) }
  public static func add(GUIDANCE_LAW: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GUIDANCE_LAW, def: 0, at: VTOFFSET.GUIDANCE_LAW.p) }
  public static func add(TYPE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TYPE, def: 0, at: VTOFFSET.TYPE.p) }
  public static func add(ARMED: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ARMED, def: 0, at: VTOFFSET.ARMED.p) }
  public static func add(TIME_OF_FLIGHT: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_OF_FLIGHT, def: 0.0, at: VTOFFSET.TIME_OF_FLIGHT.p) }
  public static func add(MAX_G: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MAX_G, def: 0.0, at: VTOFFSET.MAX_G.p) }
  public static func addVectorOf(RESERVED: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESERVED, at: VTOFFSET.RESERVED.p) }
  public static func endMSL(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createMSL(
    _ fbb: inout FlatBufferBuilder,
    POSITION_X: Double = 0.0,
    POSITION_Y: Double = 0.0,
    POSITION_Z: Double = 0.0,
    VELOCITY_X: Double = 0.0,
    VELOCITY_Y: Double = 0.0,
    VELOCITY_Z: Double = 0.0,
    ATTITUDE_X: Double = 0.0,
    ATTITUDE_Y: Double = 0.0,
    ATTITUDE_Z: Double = 0.0,
    ATTITUDE_W: Double = 0.0,
    OMEGA_X: Double = 0.0,
    OMEGA_Y: Double = 0.0,
    OMEGA_Z: Double = 0.0,
    MASS: Double = 0.0,
    MASS_INITIAL: Double = 0.0,
    TARGET_POSITION_X: Double = 0.0,
    TARGET_POSITION_Y: Double = 0.0,
    TARGET_POSITION_Z: Double = 0.0,
    TARGET_VELOCITY_X: Double = 0.0,
    TARGET_VELOCITY_Y: Double = 0.0,
    TARGET_VELOCITY_Z: Double = 0.0,
    MISS_DISTANCE: Double = 0.0,
    SEEKEROffset SEEKER: Offset = Offset(),
    MOTOROffset MOTOR: Offset = Offset(),
    GUIDANCE_CMDOffset GUIDANCE_CMD: Offset = Offset(),
    PHASE: UInt8 = 0,
    GUIDANCE_LAW: UInt8 = 0,
    TYPE: UInt8 = 0,
    ARMED: UInt8 = 0,
    TIME_OF_FLIGHT: Float32 = 0.0,
    MAX_G: Float32 = 0.0,
    RESERVEDVectorOffset RESERVED: Offset = Offset()
  ) -> Offset {
    let __start = MSL.startMSL(&fbb)
    MSL.add(POSITION_X: POSITION_X, &fbb)
    MSL.add(POSITION_Y: POSITION_Y, &fbb)
    MSL.add(POSITION_Z: POSITION_Z, &fbb)
    MSL.add(VELOCITY_X: VELOCITY_X, &fbb)
    MSL.add(VELOCITY_Y: VELOCITY_Y, &fbb)
    MSL.add(VELOCITY_Z: VELOCITY_Z, &fbb)
    MSL.add(ATTITUDE_X: ATTITUDE_X, &fbb)
    MSL.add(ATTITUDE_Y: ATTITUDE_Y, &fbb)
    MSL.add(ATTITUDE_Z: ATTITUDE_Z, &fbb)
    MSL.add(ATTITUDE_W: ATTITUDE_W, &fbb)
    MSL.add(OMEGA_X: OMEGA_X, &fbb)
    MSL.add(OMEGA_Y: OMEGA_Y, &fbb)
    MSL.add(OMEGA_Z: OMEGA_Z, &fbb)
    MSL.add(MASS: MASS, &fbb)
    MSL.add(MASS_INITIAL: MASS_INITIAL, &fbb)
    MSL.add(TARGET_POSITION_X: TARGET_POSITION_X, &fbb)
    MSL.add(TARGET_POSITION_Y: TARGET_POSITION_Y, &fbb)
    MSL.add(TARGET_POSITION_Z: TARGET_POSITION_Z, &fbb)
    MSL.add(TARGET_VELOCITY_X: TARGET_VELOCITY_X, &fbb)
    MSL.add(TARGET_VELOCITY_Y: TARGET_VELOCITY_Y, &fbb)
    MSL.add(TARGET_VELOCITY_Z: TARGET_VELOCITY_Z, &fbb)
    MSL.add(MISS_DISTANCE: MISS_DISTANCE, &fbb)
    MSL.add(SEEKER: SEEKER, &fbb)
    MSL.add(MOTOR: MOTOR, &fbb)
    MSL.add(GUIDANCE_CMD: GUIDANCE_CMD, &fbb)
    MSL.add(PHASE: PHASE, &fbb)
    MSL.add(GUIDANCE_LAW: GUIDANCE_LAW, &fbb)
    MSL.add(TYPE: TYPE, &fbb)
    MSL.add(ARMED: ARMED, &fbb)
    MSL.add(TIME_OF_FLIGHT: TIME_OF_FLIGHT, &fbb)
    MSL.add(MAX_G: MAX_G, &fbb)
    MSL.addVectorOf(RESERVED: RESERVED, &fbb)
    return MSL.endMSL(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.POSITION_X.p, fieldName: "POSITION_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.POSITION_Y.p, fieldName: "POSITION_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.POSITION_Z.p, fieldName: "POSITION_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VELOCITY_X.p, fieldName: "VELOCITY_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VELOCITY_Y.p, fieldName: "VELOCITY_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VELOCITY_Z.p, fieldName: "VELOCITY_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ATTITUDE_X.p, fieldName: "ATTITUDE_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ATTITUDE_Y.p, fieldName: "ATTITUDE_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ATTITUDE_Z.p, fieldName: "ATTITUDE_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ATTITUDE_W.p, fieldName: "ATTITUDE_W", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OMEGA_X.p, fieldName: "OMEGA_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OMEGA_Y.p, fieldName: "OMEGA_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.OMEGA_Z.p, fieldName: "OMEGA_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MASS.p, fieldName: "MASS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MASS_INITIAL.p, fieldName: "MASS_INITIAL", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_POSITION_X.p, fieldName: "TARGET_POSITION_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_POSITION_Y.p, fieldName: "TARGET_POSITION_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_POSITION_Z.p, fieldName: "TARGET_POSITION_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_VELOCITY_X.p, fieldName: "TARGET_VELOCITY_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_VELOCITY_Y.p, fieldName: "TARGET_VELOCITY_Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TARGET_VELOCITY_Z.p, fieldName: "TARGET_VELOCITY_Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MISS_DISTANCE.p, fieldName: "MISS_DISTANCE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SEEKER.p, fieldName: "SEEKER", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MOTOR.p, fieldName: "MOTOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GUIDANCE_CMD.p, fieldName: "GUIDANCE_CMD", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PHASE.p, fieldName: "PHASE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.GUIDANCE_LAW.p, fieldName: "GUIDANCE_LAW", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.ARMED.p, fieldName: "ARMED", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.TIME_OF_FLIGHT.p, fieldName: "TIME_OF_FLIGHT", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.MAX_G.p, fieldName: "MAX_G", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.RESERVED.p, fieldName: "RESERVED", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

