// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Enumeration of Engine Types
public enum ENGINE_TYPE: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case liquid = 0
  case solid = 1
  case hybrid = 2
  case ion = 3
  case nuclearThermal = 4
  case other = 5

  public static var max: ENGINE_TYPE { return .other }
  public static var min: ENGINE_TYPE { return .liquid }
}


///  Rocket Configuration
public struct ROC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ROC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ROC.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case FAMILY = 6
    case VARIANT = 8
    case STAGES = 10
    case SUSTAINERS = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Rocket Name
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Rocket Family
  public var FAMILY: String? { let o = _accessor.offset(VTOFFSET.FAMILY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FAMILYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FAMILY.v) }
  ///  Rocket Variant
  public var VARIANT: String? { let o = _accessor.offset(VTOFFSET.VARIANT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var VARIANTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.VARIANT.v) }
  ///  Stages in the Rocket
  public var hasStages: Bool { let o = _accessor.offset(VTOFFSET.STAGES.v); return o == 0 ? false : true }
  public var STAGESCount: Int32 { let o = _accessor.offset(VTOFFSET.STAGES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func STAGES(at index: Int32) -> STAGE? { let o = _accessor.offset(VTOFFSET.STAGES.v); return o == 0 ? nil : STAGE(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Sustainers in the Rocket
  public var hasSustainers: Bool { let o = _accessor.offset(VTOFFSET.SUSTAINERS.v); return o == 0 ? false : true }
  public var SUSTAINERSCount: Int32 { let o = _accessor.offset(VTOFFSET.SUSTAINERS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SUSTAINERS(at index: Int32) -> SUSTAINER? { let o = _accessor.offset(VTOFFSET.SUSTAINERS.v); return o == 0 ? nil : SUSTAINER(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startROC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(FAMILY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FAMILY, at: VTOFFSET.FAMILY.p) }
  public static func add(VARIANT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: VARIANT, at: VTOFFSET.VARIANT.p) }
  public static func addVectorOf(STAGES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STAGES, at: VTOFFSET.STAGES.p) }
  public static func addVectorOf(SUSTAINERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SUSTAINERS, at: VTOFFSET.SUSTAINERS.p) }
  public static func endROC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createROC(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    FAMILYOffset FAMILY: Offset = Offset(),
    VARIANTOffset VARIANT: Offset = Offset(),
    STAGESVectorOffset STAGES: Offset = Offset(),
    SUSTAINERSVectorOffset SUSTAINERS: Offset = Offset()
  ) -> Offset {
    let __start = ROC.startROC(&fbb)
    ROC.add(NAME: NAME, &fbb)
    ROC.add(FAMILY: FAMILY, &fbb)
    ROC.add(VARIANT: VARIANT, &fbb)
    ROC.addVectorOf(STAGES: STAGES, &fbb)
    ROC.addVectorOf(SUSTAINERS: SUSTAINERS, &fbb)
    return ROC.endROC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FAMILY.p, fieldName: "FAMILY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.VARIANT.p, fieldName: "VARIANT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STAGES.p, fieldName: "STAGES", required: false, type: ForwardOffset<Vector<ForwardOffset<STAGE>, STAGE>>.self)
    try _v.visit(field: VTOFFSET.SUSTAINERS.p, fieldName: "SUSTAINERS", required: false, type: ForwardOffset<Vector<ForwardOffset<SUSTAINER>, SUSTAINER>>.self)
    _v.finish()
  }
}

///  Stage Details
public struct STAGE: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ROC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: STAGE.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case STAGE_NUMBER = 4
    case ENGINES = 6
    case FUEL_TYPE = 8
    case THRUST = 10
    case BURN_DURATION = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Stage Number
  public var STAGE_NUMBER: Int32 { let o = _accessor.offset(VTOFFSET.STAGE_NUMBER.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Engines Used in This Stage
  public var hasEngines: Bool { let o = _accessor.offset(VTOFFSET.ENGINES.v); return o == 0 ? false : true }
  public var ENGINESCount: Int32 { let o = _accessor.offset(VTOFFSET.ENGINES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENGINES(at index: Int32) -> ENGINE? { let o = _accessor.offset(VTOFFSET.ENGINES.v); return o == 0 ? nil : ENGINE(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Fuel Type Used in This Stage
  public var FUEL_TYPE: String? { let o = _accessor.offset(VTOFFSET.FUEL_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FUEL_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FUEL_TYPE.v) }
  ///  Thrust Produced by This Stage (in Newtons)
  public var THRUST: Double { let o = _accessor.offset(VTOFFSET.THRUST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Duration of the Burn (in Seconds)
  public var BURN_DURATION: Double { let o = _accessor.offset(VTOFFSET.BURN_DURATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startSTAGE(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(STAGE_NUMBER: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: STAGE_NUMBER, def: 0, at: VTOFFSET.STAGE_NUMBER.p) }
  public static func addVectorOf(ENGINES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENGINES, at: VTOFFSET.ENGINES.p) }
  public static func add(FUEL_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FUEL_TYPE, at: VTOFFSET.FUEL_TYPE.p) }
  public static func add(THRUST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: THRUST, def: 0.0, at: VTOFFSET.THRUST.p) }
  public static func add(BURN_DURATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BURN_DURATION, def: 0.0, at: VTOFFSET.BURN_DURATION.p) }
  public static func endSTAGE(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSTAGE(
    _ fbb: inout FlatBufferBuilder,
    STAGE_NUMBER: Int32 = 0,
    ENGINESVectorOffset ENGINES: Offset = Offset(),
    FUEL_TYPEOffset FUEL_TYPE: Offset = Offset(),
    THRUST: Double = 0.0,
    BURN_DURATION: Double = 0.0
  ) -> Offset {
    let __start = STAGE.startSTAGE(&fbb)
    STAGE.add(STAGE_NUMBER: STAGE_NUMBER, &fbb)
    STAGE.addVectorOf(ENGINES: ENGINES, &fbb)
    STAGE.add(FUEL_TYPE: FUEL_TYPE, &fbb)
    STAGE.add(THRUST: THRUST, &fbb)
    STAGE.add(BURN_DURATION: BURN_DURATION, &fbb)
    return STAGE.endSTAGE(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.STAGE_NUMBER.p, fieldName: "STAGE_NUMBER", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.ENGINES.p, fieldName: "ENGINES", required: false, type: ForwardOffset<Vector<ForwardOffset<ENGINE>, ENGINE>>.self)
    try _v.visit(field: VTOFFSET.FUEL_TYPE.p, fieldName: "FUEL_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.THRUST.p, fieldName: "THRUST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BURN_DURATION.p, fieldName: "BURN_DURATION", required: false, type: Double.self)
    _v.finish()
  }
}

///  Sustainer Details
public struct SUSTAINER: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ROC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SUSTAINER.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SUSTAINER_NAME = 4
    case THRUST = 6
    case BURN_DURATION = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of the Sustainer
  public var SUSTAINER_NAME: String? { let o = _accessor.offset(VTOFFSET.SUSTAINER_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SUSTAINER_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SUSTAINER_NAME.v) }
  ///  Thrust Produced by the Sustainer (in Newtons)
  public var THRUST: Double { let o = _accessor.offset(VTOFFSET.THRUST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Duration of the Burn (in Seconds)
  public var BURN_DURATION: Double { let o = _accessor.offset(VTOFFSET.BURN_DURATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startSUSTAINER(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(SUSTAINER_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SUSTAINER_NAME, at: VTOFFSET.SUSTAINER_NAME.p) }
  public static func add(THRUST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: THRUST, def: 0.0, at: VTOFFSET.THRUST.p) }
  public static func add(BURN_DURATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BURN_DURATION, def: 0.0, at: VTOFFSET.BURN_DURATION.p) }
  public static func endSUSTAINER(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSUSTAINER(
    _ fbb: inout FlatBufferBuilder,
    SUSTAINER_NAMEOffset SUSTAINER_NAME: Offset = Offset(),
    THRUST: Double = 0.0,
    BURN_DURATION: Double = 0.0
  ) -> Offset {
    let __start = SUSTAINER.startSUSTAINER(&fbb)
    SUSTAINER.add(SUSTAINER_NAME: SUSTAINER_NAME, &fbb)
    SUSTAINER.add(THRUST: THRUST, &fbb)
    SUSTAINER.add(BURN_DURATION: BURN_DURATION, &fbb)
    return SUSTAINER.endSUSTAINER(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SUSTAINER_NAME.p, fieldName: "SUSTAINER_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.THRUST.p, fieldName: "THRUST", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BURN_DURATION.p, fieldName: "BURN_DURATION", required: false, type: Double.self)
    _v.finish()
  }
}

///  Engine Details
public struct ENGINE: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ROC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ENGINE.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ENGINE_NAME = 4
    case TYPE = 6
    case THRUST = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Engine Name
  public var ENGINE_NAME: String? { let o = _accessor.offset(VTOFFSET.ENGINE_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ENGINE_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ENGINE_NAME.v) }
  ///  Type of Engine
  public var TYPE: ENGINE_TYPE { let o = _accessor.offset(VTOFFSET.TYPE.v); return o == 0 ? .liquid : ENGINE_TYPE(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .liquid }
  ///  Thrust Produced by the Engine (in Newtons)
  public var THRUST: Double { let o = _accessor.offset(VTOFFSET.THRUST.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startENGINE(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(ENGINE_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENGINE_NAME, at: VTOFFSET.ENGINE_NAME.p) }
  public static func add(TYPE: ENGINE_TYPE, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TYPE.rawValue, def: 0, at: VTOFFSET.TYPE.p) }
  public static func add(THRUST: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: THRUST, def: 0.0, at: VTOFFSET.THRUST.p) }
  public static func endENGINE(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createENGINE(
    _ fbb: inout FlatBufferBuilder,
    ENGINE_NAMEOffset ENGINE_NAME: Offset = Offset(),
    TYPE: ENGINE_TYPE = .liquid,
    THRUST: Double = 0.0
  ) -> Offset {
    let __start = ENGINE.startENGINE(&fbb)
    ENGINE.add(ENGINE_NAME: ENGINE_NAME, &fbb)
    ENGINE.add(TYPE: TYPE, &fbb)
    ENGINE.add(THRUST: THRUST, &fbb)
    return ENGINE.endENGINE(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ENGINE_NAME.p, fieldName: "ENGINE_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TYPE.p, fieldName: "TYPE", required: false, type: ENGINE_TYPE.self)
    try _v.visit(field: VTOFFSET.THRUST.p, fieldName: "THRUST", required: false, type: Double.self)
    _v.finish()
  }
}

