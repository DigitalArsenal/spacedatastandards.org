// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Enum for the type of site
public enum SiteType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case launchSite = 0
  case observationStation = 1
  case hobbyistObserver = 2
  case researchFacility = 3
  case satelliteGroundStation = 4
  case spaceport = 5
  case militaryBase = 6
  case weatherStation = 7
  case astronomicalObservatory = 8
  case educationalInstitute = 9
  case communicationHub = 10
  case powerPlant = 11
  case industrialComplex = 12
  case transportationHub = 13
  case urbanArea = 14
  case nationalPark = 15
  case historicalSite = 16
  case other = 17

  public static var max: SiteType { return .other }
  public static var min: SiteType { return .launchSite }
}


///  Geometry table with information about geometric properties
public struct Geometry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$SIT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Geometry.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case GEOMETRY_TYPE = 4
    case COORDINATES = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Type of geometry
  public var GEOMETRY_TYPE: String? { let o = _accessor.offset(VTOFFSET.GEOMETRY_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GEOMETRY_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GEOMETRY_TYPE.v) }
  ///  Coordinates of the geometry
  public var hasCoordinates: Bool { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? false : true }
  public var COORDINATESCount: Int32 { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COORDINATES(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.COORDINATES.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var COORDINATES: [Float32] { return _accessor.getVector(at: VTOFFSET.COORDINATES.v) ?? [] }
  public static func startGeometry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(GEOMETRY_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GEOMETRY_TYPE, at: VTOFFSET.GEOMETRY_TYPE.p) }
  public static func addVectorOf(COORDINATES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COORDINATES, at: VTOFFSET.COORDINATES.p) }
  public static func endGeometry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createGeometry(
    _ fbb: inout FlatBufferBuilder,
    GEOMETRY_TYPEOffset GEOMETRY_TYPE: Offset = Offset(),
    COORDINATESVectorOffset COORDINATES: Offset = Offset()
  ) -> Offset {
    let __start = Geometry.startGeometry(&fbb)
    Geometry.add(GEOMETRY_TYPE: GEOMETRY_TYPE, &fbb)
    Geometry.addVectorOf(COORDINATES: COORDINATES, &fbb)
    return Geometry.endGeometry(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.GEOMETRY_TYPE.p, fieldName: "GEOMETRY_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.COORDINATES.p, fieldName: "COORDINATES", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    _v.finish()
  }
}

///  Site Information Message
public struct SIT: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$SIT" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: SIT.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case NAME = 6
    case ABBREVIATION = 8
    case SITE_TYPE = 10
    case CATCODE = 12
    case NETWORK = 14
    case LATITUDE = 16
    case LONGITUDE = 18
    case ALTITUDE = 20
    case GEOMETRY = 22
    case CENTER_POINT_GEOMETRY = 24
    case CLASSIFICATION = 26
    case CTR_ID = 28
    case CREATED_BY = 30
    case DESCRIPTION = 32
    case MODEL_URL = 34
    case SOURCE = 36
    case TASKABLE = 38
    case OPERATIONAL_STATUS = 40
    case ESTABLISHMENT_DATE = 42
    case CONTACT_INFO = 44
    case ENVIRONMENTAL_IMPACT = 46
    case ACCESSIBILITY_INFRA = 48
    case INTEGRATED_DEVICES = 50
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier for the site, BE_NUMBER
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Name of the site
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Abbreviation
  public var ABBREVIATION: String? { let o = _accessor.offset(VTOFFSET.ABBREVIATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ABBREVIATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ABBREVIATION.v) }
  ///  Site type as defined in SiteType enum
  public var SITE_TYPE: SiteType { let o = _accessor.offset(VTOFFSET.SITE_TYPE.v); return o == 0 ? .launchSite : SiteType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .launchSite }
  ///  Site type CATCODE
  public var CATCODE: String? { let o = _accessor.offset(VTOFFSET.CATCODE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CATCODESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CATCODE.v) }
  ///  Network identifier
  public var NETWORK: String? { let o = _accessor.offset(VTOFFSET.NETWORK.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NETWORKSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NETWORK.v) }
  ///  Latitude of the site
  public var LATITUDE: Float32 { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Longitude of the site
  public var LONGITUDE: Float32 { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Altitude of the site
  public var ALTITUDE: Float32 { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  ///  Geometry of the site
  public var GEOMETRY: Geometry? { let o = _accessor.offset(VTOFFSET.GEOMETRY.v); return o == 0 ? nil : Geometry(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Center point geometry coordinates
  public var hasCenterPointGeometry: Bool { let o = _accessor.offset(VTOFFSET.CENTER_POINT_GEOMETRY.v); return o == 0 ? false : true }
  public var CENTER_POINT_GEOMETRYCount: Int32 { let o = _accessor.offset(VTOFFSET.CENTER_POINT_GEOMETRY.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CENTER_POINT_GEOMETRY(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.CENTER_POINT_GEOMETRY.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var CENTER_POINT_GEOMETRY: [Float32] { return _accessor.getVector(at: VTOFFSET.CENTER_POINT_GEOMETRY.v) ?? [] }
  ///  Classification marking of the site
  public var CLASSIFICATION: String? { let o = _accessor.offset(VTOFFSET.CLASSIFICATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLASSIFICATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLASSIFICATION.v) }
  ///  CTR ISO 3166 Numeric code as string
  public var CTR_ID: String? { let o = _accessor.offset(VTOFFSET.CTR_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CTR_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CTR_ID.v) }
  ///  Identifier of the user who created the site data
  public var CREATED_BY: String? { let o = _accessor.offset(VTOFFSET.CREATED_BY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CREATED_BYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CREATED_BY.v) }
  ///  Description of the site
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  URL for the 3D model of the site
  public var MODEL_URL: String? { let o = _accessor.offset(VTOFFSET.MODEL_URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MODEL_URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MODEL_URL.v) }
  ///  Source of the site data
  public var SOURCE: String? { let o = _accessor.offset(VTOFFSET.SOURCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOURCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOURCE.v) }
  ///  Indicates if the site is taskable
  public var TASKABLE: Bool { let o = _accessor.offset(VTOFFSET.TASKABLE.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  ///  Operational status of the site (e.g., active, inactive, under construction)
  public var OPERATIONAL_STATUS: String? { let o = _accessor.offset(VTOFFSET.OPERATIONAL_STATUS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OPERATIONAL_STATUSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OPERATIONAL_STATUS.v) }
  ///  Date of establishment
  public var ESTABLISHMENT_DATE: String? { let o = _accessor.offset(VTOFFSET.ESTABLISHMENT_DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ESTABLISHMENT_DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ESTABLISHMENT_DATE.v) }
  ///  Contact information for the site
  public var CONTACT_INFO: String? { let o = _accessor.offset(VTOFFSET.CONTACT_INFO.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTACT_INFOSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTACT_INFO.v) }
  ///  Environmental impact or considerations
  public var ENVIRONMENTAL_IMPACT: String? { let o = _accessor.offset(VTOFFSET.ENVIRONMENTAL_IMPACT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ENVIRONMENTAL_IMPACTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ENVIRONMENTAL_IMPACT.v) }
  ///  Accessibility and infrastructure details
  public var ACCESSIBILITY_INFRA: String? { let o = _accessor.offset(VTOFFSET.ACCESSIBILITY_INFRA.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ACCESSIBILITY_INFRASegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ACCESSIBILITY_INFRA.v) }
  ///  Vector of Integrated Devices (IDM)
  public var hasIntegratedDevices: Bool { let o = _accessor.offset(VTOFFSET.INTEGRATED_DEVICES.v); return o == 0 ? false : true }
  public var INTEGRATED_DEVICESCount: Int32 { let o = _accessor.offset(VTOFFSET.INTEGRATED_DEVICES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func INTEGRATED_DEVICES(at index: Int32) -> IDM? { let o = _accessor.offset(VTOFFSET.INTEGRATED_DEVICES.v); return o == 0 ? nil : IDM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startSIT(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 24) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(ABBREVIATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ABBREVIATION, at: VTOFFSET.ABBREVIATION.p) }
  public static func add(SITE_TYPE: SiteType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SITE_TYPE.rawValue, def: 0, at: VTOFFSET.SITE_TYPE.p) }
  public static func add(CATCODE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CATCODE, at: VTOFFSET.CATCODE.p) }
  public static func add(NETWORK: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NETWORK, at: VTOFFSET.NETWORK.p) }
  public static func add(LATITUDE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(LONGITUDE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(ALTITUDE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func add(GEOMETRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GEOMETRY, at: VTOFFSET.GEOMETRY.p) }
  public static func addVectorOf(CENTER_POINT_GEOMETRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CENTER_POINT_GEOMETRY, at: VTOFFSET.CENTER_POINT_GEOMETRY.p) }
  public static func add(CLASSIFICATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLASSIFICATION, at: VTOFFSET.CLASSIFICATION.p) }
  public static func add(CTR_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CTR_ID, at: VTOFFSET.CTR_ID.p) }
  public static func add(CREATED_BY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CREATED_BY, at: VTOFFSET.CREATED_BY.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(MODEL_URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MODEL_URL, at: VTOFFSET.MODEL_URL.p) }
  public static func add(SOURCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOURCE, at: VTOFFSET.SOURCE.p) }
  public static func add(TASKABLE: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TASKABLE, def: false,
   at: VTOFFSET.TASKABLE.p) }
  public static func add(OPERATIONAL_STATUS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OPERATIONAL_STATUS, at: VTOFFSET.OPERATIONAL_STATUS.p) }
  public static func add(ESTABLISHMENT_DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ESTABLISHMENT_DATE, at: VTOFFSET.ESTABLISHMENT_DATE.p) }
  public static func add(CONTACT_INFO: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTACT_INFO, at: VTOFFSET.CONTACT_INFO.p) }
  public static func add(ENVIRONMENTAL_IMPACT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENVIRONMENTAL_IMPACT, at: VTOFFSET.ENVIRONMENTAL_IMPACT.p) }
  public static func add(ACCESSIBILITY_INFRA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ACCESSIBILITY_INFRA, at: VTOFFSET.ACCESSIBILITY_INFRA.p) }
  public static func addVectorOf(INTEGRATED_DEVICES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INTEGRATED_DEVICES, at: VTOFFSET.INTEGRATED_DEVICES.p) }
  public static func endSIT(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSIT(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    NAMEOffset NAME: Offset = Offset(),
    ABBREVIATIONOffset ABBREVIATION: Offset = Offset(),
    SITE_TYPE: SiteType = .launchSite,
    CATCODEOffset CATCODE: Offset = Offset(),
    NETWORKOffset NETWORK: Offset = Offset(),
    LATITUDE: Float32 = 0.0,
    LONGITUDE: Float32 = 0.0,
    ALTITUDE: Float32 = 0.0,
    GEOMETRYOffset GEOMETRY: Offset = Offset(),
    CENTER_POINT_GEOMETRYVectorOffset CENTER_POINT_GEOMETRY: Offset = Offset(),
    CLASSIFICATIONOffset CLASSIFICATION: Offset = Offset(),
    CTR_IDOffset CTR_ID: Offset = Offset(),
    CREATED_BYOffset CREATED_BY: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    MODEL_URLOffset MODEL_URL: Offset = Offset(),
    SOURCEOffset SOURCE: Offset = Offset(),
    TASKABLE: Bool = false,
    OPERATIONAL_STATUSOffset OPERATIONAL_STATUS: Offset = Offset(),
    ESTABLISHMENT_DATEOffset ESTABLISHMENT_DATE: Offset = Offset(),
    CONTACT_INFOOffset CONTACT_INFO: Offset = Offset(),
    ENVIRONMENTAL_IMPACTOffset ENVIRONMENTAL_IMPACT: Offset = Offset(),
    ACCESSIBILITY_INFRAOffset ACCESSIBILITY_INFRA: Offset = Offset(),
    INTEGRATED_DEVICESVectorOffset INTEGRATED_DEVICES: Offset = Offset()
  ) -> Offset {
    let __start = SIT.startSIT(&fbb)
    SIT.add(ID: ID, &fbb)
    SIT.add(NAME: NAME, &fbb)
    SIT.add(ABBREVIATION: ABBREVIATION, &fbb)
    SIT.add(SITE_TYPE: SITE_TYPE, &fbb)
    SIT.add(CATCODE: CATCODE, &fbb)
    SIT.add(NETWORK: NETWORK, &fbb)
    SIT.add(LATITUDE: LATITUDE, &fbb)
    SIT.add(LONGITUDE: LONGITUDE, &fbb)
    SIT.add(ALTITUDE: ALTITUDE, &fbb)
    SIT.add(GEOMETRY: GEOMETRY, &fbb)
    SIT.addVectorOf(CENTER_POINT_GEOMETRY: CENTER_POINT_GEOMETRY, &fbb)
    SIT.add(CLASSIFICATION: CLASSIFICATION, &fbb)
    SIT.add(CTR_ID: CTR_ID, &fbb)
    SIT.add(CREATED_BY: CREATED_BY, &fbb)
    SIT.add(DESCRIPTION: DESCRIPTION, &fbb)
    SIT.add(MODEL_URL: MODEL_URL, &fbb)
    SIT.add(SOURCE: SOURCE, &fbb)
    SIT.add(TASKABLE: TASKABLE, &fbb)
    SIT.add(OPERATIONAL_STATUS: OPERATIONAL_STATUS, &fbb)
    SIT.add(ESTABLISHMENT_DATE: ESTABLISHMENT_DATE, &fbb)
    SIT.add(CONTACT_INFO: CONTACT_INFO, &fbb)
    SIT.add(ENVIRONMENTAL_IMPACT: ENVIRONMENTAL_IMPACT, &fbb)
    SIT.add(ACCESSIBILITY_INFRA: ACCESSIBILITY_INFRA, &fbb)
    SIT.addVectorOf(INTEGRATED_DEVICES: INTEGRATED_DEVICES, &fbb)
    return SIT.endSIT(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ABBREVIATION.p, fieldName: "ABBREVIATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SITE_TYPE.p, fieldName: "SITE_TYPE", required: false, type: SiteType.self)
    try _v.visit(field: VTOFFSET.CATCODE.p, fieldName: "CATCODE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NETWORK.p, fieldName: "NETWORK", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.GEOMETRY.p, fieldName: "GEOMETRY", required: false, type: ForwardOffset<Geometry>.self)
    try _v.visit(field: VTOFFSET.CENTER_POINT_GEOMETRY.p, fieldName: "CENTER_POINT_GEOMETRY", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.CLASSIFICATION.p, fieldName: "CLASSIFICATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CTR_ID.p, fieldName: "CTR_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CREATED_BY.p, fieldName: "CREATED_BY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MODEL_URL.p, fieldName: "MODEL_URL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOURCE.p, fieldName: "SOURCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TASKABLE.p, fieldName: "TASKABLE", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.OPERATIONAL_STATUS.p, fieldName: "OPERATIONAL_STATUS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ESTABLISHMENT_DATE.p, fieldName: "ESTABLISHMENT_DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTACT_INFO.p, fieldName: "CONTACT_INFO", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENVIRONMENTAL_IMPACT.p, fieldName: "ENVIRONMENTAL_IMPACT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ACCESSIBILITY_INFRA.p, fieldName: "ACCESSIBILITY_INFRA", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INTEGRATED_DEVICES.p, fieldName: "INTEGRATED_DEVICES", required: false, type: ForwardOffset<Vector<ForwardOffset<IDM>, IDM>>.self)
    _v.finish()
  }
}

