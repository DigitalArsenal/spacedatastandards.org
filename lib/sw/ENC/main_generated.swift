// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Encryption Header for FlatBuffers field-level encryption
///  Key exchange algorithm used to derive the shared secret
public enum KeyExchange: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case x25519 = 0
  case secp256k1 = 1
  case p256 = 2

  public static var max: KeyExchange { return .p256 }
  public static var min: KeyExchange { return .x25519 }
}


///  Symmetric encryption algorithm
public enum SymmetricAlgo: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case aes256Ctr = 0

  public static var max: SymmetricAlgo { return .aes256Ctr }
  public static var min: SymmetricAlgo { return .aes256Ctr }
}


///  Key derivation function
public enum KDF: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case hkdfSha256 = 0

  public static var max: KDF { return .hkdfSha256 }
  public static var min: KDF { return .hkdfSha256 }
}


///  Encryption Header containing all parameters needed for decryption
public struct ENC: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ENC" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ENC.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case VERSION = 4
    case KEY_EXCHANGE = 6
    case SYMMETRIC = 8
    case KEY_DERIVATION = 10
    case EPHEMERAL_PUBLIC_KEY = 12
    case NONCE_START = 14
    case RECIPIENT_KEY_ID = 16
    case CONTEXT = 18
    case SCHEMA_HASH = 20
    case ROOT_TYPE = 22
    case TIMESTAMP = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Schema version for forward compatibility
  public var VERSION: UInt8 { let o = _accessor.offset(VTOFFSET.VERSION.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Key exchange algorithm used
  public var KEY_EXCHANGE: KeyExchange { let o = _accessor.offset(VTOFFSET.KEY_EXCHANGE.v); return o == 0 ? .x25519 : KeyExchange(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .x25519 }
  ///  Symmetric encryption algorithm used
  public var SYMMETRIC: SymmetricAlgo { let o = _accessor.offset(VTOFFSET.SYMMETRIC.v); return o == 0 ? .aes256Ctr : SymmetricAlgo(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .aes256Ctr }
  ///  Key derivation function used
  public var KEY_DERIVATION: KDF { let o = _accessor.offset(VTOFFSET.KEY_DERIVATION.v); return o == 0 ? .hkdfSha256 : KDF(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .hkdfSha256 }
  ///  Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
  public var hasEphemeralPublicKey: Bool { let o = _accessor.offset(VTOFFSET.EPHEMERAL_PUBLIC_KEY.v); return o == 0 ? false : true }
  public var EPHEMERAL_PUBLIC_KEYCount: Int32 { let o = _accessor.offset(VTOFFSET.EPHEMERAL_PUBLIC_KEY.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func EPHEMERAL_PUBLIC_KEY(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.EPHEMERAL_PUBLIC_KEY.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var EPHEMERAL_PUBLIC_KEY: [UInt8] { return _accessor.getVector(at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.v) ?? [] }
  ///  Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  public var hasNonceStart: Bool { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? false : true }
  public var NONCE_STARTCount: Int32 { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func NONCE_START(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var NONCE_START: [UInt8] { return _accessor.getVector(at: VTOFFSET.NONCE_START.v) ?? [] }
  ///  Optional identifier for the recipient's public key (up to 32 bytes)
  public var hasRecipientKeyId: Bool { let o = _accessor.offset(VTOFFSET.RECIPIENT_KEY_ID.v); return o == 0 ? false : true }
  public var RECIPIENT_KEY_IDCount: Int32 { let o = _accessor.offset(VTOFFSET.RECIPIENT_KEY_ID.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECIPIENT_KEY_ID(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.RECIPIENT_KEY_ID.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var RECIPIENT_KEY_ID: [UInt8] { return _accessor.getVector(at: VTOFFSET.RECIPIENT_KEY_ID.v) ?? [] }
  ///  Optional domain separation context string
  public var CONTEXT: String? { let o = _accessor.offset(VTOFFSET.CONTEXT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTEXTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTEXT.v) }
  ///  Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
  public var hasSchemaHash: Bool { let o = _accessor.offset(VTOFFSET.SCHEMA_HASH.v); return o == 0 ? false : true }
  public var SCHEMA_HASHCount: Int32 { let o = _accessor.offset(VTOFFSET.SCHEMA_HASH.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func SCHEMA_HASH(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.SCHEMA_HASH.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var SCHEMA_HASH: [UInt8] { return _accessor.getVector(at: VTOFFSET.SCHEMA_HASH.v) ?? [] }
  ///  Optional root type name from the schema
  public var ROOT_TYPE: String? { let o = _accessor.offset(VTOFFSET.ROOT_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ROOT_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ROOT_TYPE.v) }
  ///  Optional Unix timestamp (milliseconds) when encryption was performed
  public var TIMESTAMP: UInt64 { let o = _accessor.offset(VTOFFSET.TIMESTAMP.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public static func startENC(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(VERSION: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VERSION, def: 1, at: VTOFFSET.VERSION.p) }
  public static func add(KEY_EXCHANGE: KeyExchange, _ fbb: inout FlatBufferBuilder) { fbb.add(element: KEY_EXCHANGE.rawValue, def: 0, at: VTOFFSET.KEY_EXCHANGE.p) }
  public static func add(SYMMETRIC: SymmetricAlgo, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SYMMETRIC.rawValue, def: 0, at: VTOFFSET.SYMMETRIC.p) }
  public static func add(KEY_DERIVATION: KDF, _ fbb: inout FlatBufferBuilder) { fbb.add(element: KEY_DERIVATION.rawValue, def: 0, at: VTOFFSET.KEY_DERIVATION.p) }
  public static func addVectorOf(EPHEMERAL_PUBLIC_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPHEMERAL_PUBLIC_KEY, at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p) }
  public static func addVectorOf(NONCE_START: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NONCE_START, at: VTOFFSET.NONCE_START.p) }
  public static func addVectorOf(RECIPIENT_KEY_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECIPIENT_KEY_ID, at: VTOFFSET.RECIPIENT_KEY_ID.p) }
  public static func add(CONTEXT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTEXT, at: VTOFFSET.CONTEXT.p) }
  public static func addVectorOf(SCHEMA_HASH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SCHEMA_HASH, at: VTOFFSET.SCHEMA_HASH.p) }
  public static func add(ROOT_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ROOT_TYPE, at: VTOFFSET.ROOT_TYPE.p) }
  public static func add(TIMESTAMP: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIMESTAMP, def: 0, at: VTOFFSET.TIMESTAMP.p) }
  public static func endENC(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [12, 14]); return end }
  public static func createENC(
    _ fbb: inout FlatBufferBuilder,
    VERSION: UInt8 = 1,
    KEY_EXCHANGE: KeyExchange = .x25519,
    SYMMETRIC: SymmetricAlgo = .aes256Ctr,
    KEY_DERIVATION: KDF = .hkdfSha256,
    EPHEMERAL_PUBLIC_KEYVectorOffset EPHEMERAL_PUBLIC_KEY: Offset,
    NONCE_STARTVectorOffset NONCE_START: Offset,
    RECIPIENT_KEY_IDVectorOffset RECIPIENT_KEY_ID: Offset = Offset(),
    CONTEXTOffset CONTEXT: Offset = Offset(),
    SCHEMA_HASHVectorOffset SCHEMA_HASH: Offset = Offset(),
    ROOT_TYPEOffset ROOT_TYPE: Offset = Offset(),
    TIMESTAMP: UInt64 = 0
  ) -> Offset {
    let __start = ENC.startENC(&fbb)
    ENC.add(VERSION: VERSION, &fbb)
    ENC.add(KEY_EXCHANGE: KEY_EXCHANGE, &fbb)
    ENC.add(SYMMETRIC: SYMMETRIC, &fbb)
    ENC.add(KEY_DERIVATION: KEY_DERIVATION, &fbb)
    ENC.addVectorOf(EPHEMERAL_PUBLIC_KEY: EPHEMERAL_PUBLIC_KEY, &fbb)
    ENC.addVectorOf(NONCE_START: NONCE_START, &fbb)
    ENC.addVectorOf(RECIPIENT_KEY_ID: RECIPIENT_KEY_ID, &fbb)
    ENC.add(CONTEXT: CONTEXT, &fbb)
    ENC.addVectorOf(SCHEMA_HASH: SCHEMA_HASH, &fbb)
    ENC.add(ROOT_TYPE: ROOT_TYPE, &fbb)
    ENC.add(TIMESTAMP: TIMESTAMP, &fbb)
    return ENC.endENC(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.VERSION.p, fieldName: "VERSION", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.KEY_EXCHANGE.p, fieldName: "KEY_EXCHANGE", required: false, type: KeyExchange.self)
    try _v.visit(field: VTOFFSET.SYMMETRIC.p, fieldName: "SYMMETRIC", required: false, type: SymmetricAlgo.self)
    try _v.visit(field: VTOFFSET.KEY_DERIVATION.p, fieldName: "KEY_DERIVATION", required: false, type: KDF.self)
    try _v.visit(field: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p, fieldName: "EPHEMERAL_PUBLIC_KEY", required: true, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.NONCE_START.p, fieldName: "NONCE_START", required: true, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.RECIPIENT_KEY_ID.p, fieldName: "RECIPIENT_KEY_ID", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.CONTEXT.p, fieldName: "CONTEXT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SCHEMA_HASH.p, fieldName: "SCHEMA_HASH", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.ROOT_TYPE.p, fieldName: "ROOT_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIMESTAMP.p, fieldName: "TIMESTAMP", required: false, type: UInt64.self)
    _v.finish()
  }
}

