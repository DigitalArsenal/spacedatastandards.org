// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum ionoLayer: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case d = 0
  case e = 1
  case es = 2
  case f = 3
  case f1 = 4
  case f2 = 5
  case topside = 6

  public static var max: ionoLayer { return .topside }
  public static var min: ionoLayer { return .d }
}


public enum ionoSource: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case ionosonde = 0
  case gpsTec = 1
  case beacon = 2
  case isr = 3
  case altimeter = 4
  case radioOccultation = 5
  case model = 6

  public static var max: ionoSource { return .model }
  public static var min: ionoSource { return .ionosonde }
}


///  Ionospheric Observation Data Point
public struct ionoDataPoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ION" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ionoDataPoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case LAYER = 6
    case CRITICAL_FREQ = 8
    case VIRTUAL_HEIGHT = 10
    case TRUE_HEIGHT = 12
    case PEAK_DENSITY = 14
    case TEC = 16
    case TEC_UNCERTAINTY = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Observation epoch (ISO 8601)
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  ///  Ionospheric layer
  public var LAYER: ionoLayer { let o = _accessor.offset(VTOFFSET.LAYER.v); return o == 0 ? .d : ionoLayer(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .d }
  ///  Critical frequency in MHz
  public var CRITICAL_FREQ: Double { let o = _accessor.offset(VTOFFSET.CRITICAL_FREQ.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Virtual height in km
  public var VIRTUAL_HEIGHT: Double { let o = _accessor.offset(VTOFFSET.VIRTUAL_HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  True height in km
  public var TRUE_HEIGHT: Double { let o = _accessor.offset(VTOFFSET.TRUE_HEIGHT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Peak electron density in electrons/m^3
  public var PEAK_DENSITY: Double { let o = _accessor.offset(VTOFFSET.PEAK_DENSITY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Total electron content in TECU
  public var TEC: Double { let o = _accessor.offset(VTOFFSET.TEC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  TEC uncertainty in TECU
  public var TEC_UNCERTAINTY: Double { let o = _accessor.offset(VTOFFSET.TEC_UNCERTAINTY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startionoDataPoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(LAYER: ionoLayer, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LAYER.rawValue, def: 0, at: VTOFFSET.LAYER.p) }
  public static func add(CRITICAL_FREQ: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CRITICAL_FREQ, def: 0.0, at: VTOFFSET.CRITICAL_FREQ.p) }
  public static func add(VIRTUAL_HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VIRTUAL_HEIGHT, def: 0.0, at: VTOFFSET.VIRTUAL_HEIGHT.p) }
  public static func add(TRUE_HEIGHT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRUE_HEIGHT, def: 0.0, at: VTOFFSET.TRUE_HEIGHT.p) }
  public static func add(PEAK_DENSITY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PEAK_DENSITY, def: 0.0, at: VTOFFSET.PEAK_DENSITY.p) }
  public static func add(TEC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TEC, def: 0.0, at: VTOFFSET.TEC.p) }
  public static func add(TEC_UNCERTAINTY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TEC_UNCERTAINTY, def: 0.0, at: VTOFFSET.TEC_UNCERTAINTY.p) }
  public static func endionoDataPoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createionoDataPoint(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    LAYER: ionoLayer = .d,
    CRITICAL_FREQ: Double = 0.0,
    VIRTUAL_HEIGHT: Double = 0.0,
    TRUE_HEIGHT: Double = 0.0,
    PEAK_DENSITY: Double = 0.0,
    TEC: Double = 0.0,
    TEC_UNCERTAINTY: Double = 0.0
  ) -> Offset {
    let __start = ionoDataPoint.startionoDataPoint(&fbb)
    ionoDataPoint.add(EPOCH: EPOCH, &fbb)
    ionoDataPoint.add(LAYER: LAYER, &fbb)
    ionoDataPoint.add(CRITICAL_FREQ: CRITICAL_FREQ, &fbb)
    ionoDataPoint.add(VIRTUAL_HEIGHT: VIRTUAL_HEIGHT, &fbb)
    ionoDataPoint.add(TRUE_HEIGHT: TRUE_HEIGHT, &fbb)
    ionoDataPoint.add(PEAK_DENSITY: PEAK_DENSITY, &fbb)
    ionoDataPoint.add(TEC: TEC, &fbb)
    ionoDataPoint.add(TEC_UNCERTAINTY: TEC_UNCERTAINTY, &fbb)
    return ionoDataPoint.endionoDataPoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LAYER.p, fieldName: "LAYER", required: false, type: ionoLayer.self)
    try _v.visit(field: VTOFFSET.CRITICAL_FREQ.p, fieldName: "CRITICAL_FREQ", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VIRTUAL_HEIGHT.p, fieldName: "VIRTUAL_HEIGHT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TRUE_HEIGHT.p, fieldName: "TRUE_HEIGHT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PEAK_DENSITY.p, fieldName: "PEAK_DENSITY", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TEC.p, fieldName: "TEC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.TEC_UNCERTAINTY.p, fieldName: "TEC_UNCERTAINTY", required: false, type: Double.self)
    _v.finish()
  }
}

///  Ionospheric Electron Density Profile
public struct ionoDensityProfile: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ION" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ionoDensityProfile.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case ALTITUDES = 6
    case DENSITIES = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Observation epoch (ISO 8601)
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  ///  Altitudes in km
  public var hasAltitudes: Bool { let o = _accessor.offset(VTOFFSET.ALTITUDES.v); return o == 0 ? false : true }
  public var ALTITUDESCount: Int32 { let o = _accessor.offset(VTOFFSET.ALTITUDES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ALTITUDES(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.ALTITUDES.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var ALTITUDES: [Double] { return _accessor.getVector(at: VTOFFSET.ALTITUDES.v) ?? [] }
  ///  Electron densities at each altitude in electrons/m^3
  public var hasDensities: Bool { let o = _accessor.offset(VTOFFSET.DENSITIES.v); return o == 0 ? false : true }
  public var DENSITIESCount: Int32 { let o = _accessor.offset(VTOFFSET.DENSITIES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DENSITIES(at index: Int32) -> Double { let o = _accessor.offset(VTOFFSET.DENSITIES.v); return o == 0 ? 0 : _accessor.directRead(of: Double.self, offset: _accessor.vector(at: o) + index * 8) }
  public var DENSITIES: [Double] { return _accessor.getVector(at: VTOFFSET.DENSITIES.v) ?? [] }
  public static func startionoDensityProfile(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func addVectorOf(ALTITUDES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALTITUDES, at: VTOFFSET.ALTITUDES.p) }
  public static func addVectorOf(DENSITIES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DENSITIES, at: VTOFFSET.DENSITIES.p) }
  public static func endionoDensityProfile(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createionoDensityProfile(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    ALTITUDESVectorOffset ALTITUDES: Offset = Offset(),
    DENSITIESVectorOffset DENSITIES: Offset = Offset()
  ) -> Offset {
    let __start = ionoDensityProfile.startionoDensityProfile(&fbb)
    ionoDensityProfile.add(EPOCH: EPOCH, &fbb)
    ionoDensityProfile.addVectorOf(ALTITUDES: ALTITUDES, &fbb)
    ionoDensityProfile.addVectorOf(DENSITIES: DENSITIES, &fbb)
    return ionoDensityProfile.endionoDensityProfile(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALTITUDES.p, fieldName: "ALTITUDES", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    try _v.visit(field: VTOFFSET.DENSITIES.p, fieldName: "DENSITIES", required: false, type: ForwardOffset<Vector<Double, Double>>.self)
    _v.finish()
  }
}

///  Ionospheric Observation
public struct ION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$ION" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ID = 4
    case SOURCE = 6
    case STATION_ID = 8
    case STATION_NAME = 10
    case LATITUDE = 12
    case LONGITUDE = 14
    case ALTITUDE = 16
    case START_TIME = 18
    case STOP_TIME = 20
    case FOF2 = 22
    case FOF1 = 24
    case FOE = 26
    case FOES = 28
    case HMF2 = 30
    case HMF1 = 32
    case HME = 34
    case NMF2 = 36
    case VTEC = 38
    case STEC = 40
    case S4 = 42
    case DATA_POINTS = 44
    case DENSITY_PROFILES = 46
    case QUALITY = 48
    case NOTES = 50
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique identifier
  public var ID: String? { let o = _accessor.offset(VTOFFSET.ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ID.v) }
  ///  Data source type
  public var SOURCE: ionoSource { let o = _accessor.offset(VTOFFSET.SOURCE.v); return o == 0 ? .ionosonde : ionoSource(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ionosonde }
  ///  Station or sensor identifier
  public var STATION_ID: String? { let o = _accessor.offset(VTOFFSET.STATION_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STATION_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STATION_ID.v) }
  ///  Station name
  public var STATION_NAME: String? { let o = _accessor.offset(VTOFFSET.STATION_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STATION_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STATION_NAME.v) }
  ///  Station geodetic latitude in degrees
  public var LATITUDE: Double { let o = _accessor.offset(VTOFFSET.LATITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Station geodetic longitude in degrees
  public var LONGITUDE: Double { let o = _accessor.offset(VTOFFSET.LONGITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Station altitude in meters
  public var ALTITUDE: Double { let o = _accessor.offset(VTOFFSET.ALTITUDE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Observation start time (ISO 8601)
  public var START_TIME: String? { let o = _accessor.offset(VTOFFSET.START_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var START_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.START_TIME.v) }
  ///  Observation stop time (ISO 8601)
  public var STOP_TIME: String? { let o = _accessor.offset(VTOFFSET.STOP_TIME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STOP_TIMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STOP_TIME.v) }
  ///  foF2 critical frequency in MHz
  public var FOF2: Double { let o = _accessor.offset(VTOFFSET.FOF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  foF1 critical frequency in MHz
  public var FOF1: Double { let o = _accessor.offset(VTOFFSET.FOF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  foE critical frequency in MHz
  public var FOE: Double { let o = _accessor.offset(VTOFFSET.FOE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  foEs sporadic E critical frequency in MHz
  public var FOES: Double { let o = _accessor.offset(VTOFFSET.FOES.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  hmF2 peak height of F2 layer in km
  public var HMF2: Double { let o = _accessor.offset(VTOFFSET.HMF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  hmF1 peak height of F1 layer in km
  public var HMF1: Double { let o = _accessor.offset(VTOFFSET.HMF1.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  hmE peak height of E layer in km
  public var HME: Double { let o = _accessor.offset(VTOFFSET.HME.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  NmF2 peak density of F2 layer in electrons/m^3
  public var NMF2: Double { let o = _accessor.offset(VTOFFSET.NMF2.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Vertical TEC in TECU
  public var VTEC: Double { let o = _accessor.offset(VTOFFSET.VTEC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Slant TEC in TECU
  public var STEC: Double { let o = _accessor.offset(VTOFFSET.STEC.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Scintillation index S4
  public var S4: Double { let o = _accessor.offset(VTOFFSET.S4.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  ///  Observation data points
  public var hasDataPoints: Bool { let o = _accessor.offset(VTOFFSET.DATA_POINTS.v); return o == 0 ? false : true }
  public var DATA_POINTSCount: Int32 { let o = _accessor.offset(VTOFFSET.DATA_POINTS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DATA_POINTS(at index: Int32) -> ionoDataPoint? { let o = _accessor.offset(VTOFFSET.DATA_POINTS.v); return o == 0 ? nil : ionoDataPoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Electron density profiles
  public var hasDensityProfiles: Bool { let o = _accessor.offset(VTOFFSET.DENSITY_PROFILES.v); return o == 0 ? false : true }
  public var DENSITY_PROFILESCount: Int32 { let o = _accessor.offset(VTOFFSET.DENSITY_PROFILES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func DENSITY_PROFILES(at index: Int32) -> ionoDensityProfile? { let o = _accessor.offset(VTOFFSET.DENSITY_PROFILES.v); return o == 0 ? nil : ionoDensityProfile(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Data quality indicator (0-9, 9=best)
  public var QUALITY: UInt8 { let o = _accessor.offset(VTOFFSET.QUALITY.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  ///  Additional notes
  public var NOTES: String? { let o = _accessor.offset(VTOFFSET.NOTES.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NOTESSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NOTES.v) }
  public static func startION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 24) }
  public static func add(ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ID, at: VTOFFSET.ID.p) }
  public static func add(SOURCE: ionoSource, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOURCE.rawValue, def: 0, at: VTOFFSET.SOURCE.p) }
  public static func add(STATION_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STATION_ID, at: VTOFFSET.STATION_ID.p) }
  public static func add(STATION_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STATION_NAME, at: VTOFFSET.STATION_NAME.p) }
  public static func add(LATITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LATITUDE, def: 0.0, at: VTOFFSET.LATITUDE.p) }
  public static func add(LONGITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LONGITUDE, def: 0.0, at: VTOFFSET.LONGITUDE.p) }
  public static func add(ALTITUDE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ALTITUDE, def: 0.0, at: VTOFFSET.ALTITUDE.p) }
  public static func add(START_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: START_TIME, at: VTOFFSET.START_TIME.p) }
  public static func add(STOP_TIME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STOP_TIME, at: VTOFFSET.STOP_TIME.p) }
  public static func add(FOF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FOF2, def: 0.0, at: VTOFFSET.FOF2.p) }
  public static func add(FOF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FOF1, def: 0.0, at: VTOFFSET.FOF1.p) }
  public static func add(FOE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FOE, def: 0.0, at: VTOFFSET.FOE.p) }
  public static func add(FOES: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FOES, def: 0.0, at: VTOFFSET.FOES.p) }
  public static func add(HMF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HMF2, def: 0.0, at: VTOFFSET.HMF2.p) }
  public static func add(HMF1: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HMF1, def: 0.0, at: VTOFFSET.HMF1.p) }
  public static func add(HME: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: HME, def: 0.0, at: VTOFFSET.HME.p) }
  public static func add(NMF2: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NMF2, def: 0.0, at: VTOFFSET.NMF2.p) }
  public static func add(VTEC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VTEC, def: 0.0, at: VTOFFSET.VTEC.p) }
  public static func add(STEC: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: STEC, def: 0.0, at: VTOFFSET.STEC.p) }
  public static func add(S4: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: S4, def: 0.0, at: VTOFFSET.S4.p) }
  public static func addVectorOf(DATA_POINTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DATA_POINTS, at: VTOFFSET.DATA_POINTS.p) }
  public static func addVectorOf(DENSITY_PROFILES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DENSITY_PROFILES, at: VTOFFSET.DENSITY_PROFILES.p) }
  public static func add(QUALITY: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: QUALITY, def: 0, at: VTOFFSET.QUALITY.p) }
  public static func add(NOTES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NOTES, at: VTOFFSET.NOTES.p) }
  public static func endION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createION(
    _ fbb: inout FlatBufferBuilder,
    IDOffset ID: Offset = Offset(),
    SOURCE: ionoSource = .ionosonde,
    STATION_IDOffset STATION_ID: Offset = Offset(),
    STATION_NAMEOffset STATION_NAME: Offset = Offset(),
    LATITUDE: Double = 0.0,
    LONGITUDE: Double = 0.0,
    ALTITUDE: Double = 0.0,
    START_TIMEOffset START_TIME: Offset = Offset(),
    STOP_TIMEOffset STOP_TIME: Offset = Offset(),
    FOF2: Double = 0.0,
    FOF1: Double = 0.0,
    FOE: Double = 0.0,
    FOES: Double = 0.0,
    HMF2: Double = 0.0,
    HMF1: Double = 0.0,
    HME: Double = 0.0,
    NMF2: Double = 0.0,
    VTEC: Double = 0.0,
    STEC: Double = 0.0,
    S4: Double = 0.0,
    DATA_POINTSVectorOffset DATA_POINTS: Offset = Offset(),
    DENSITY_PROFILESVectorOffset DENSITY_PROFILES: Offset = Offset(),
    QUALITY: UInt8 = 0,
    NOTESOffset NOTES: Offset = Offset()
  ) -> Offset {
    let __start = ION.startION(&fbb)
    ION.add(ID: ID, &fbb)
    ION.add(SOURCE: SOURCE, &fbb)
    ION.add(STATION_ID: STATION_ID, &fbb)
    ION.add(STATION_NAME: STATION_NAME, &fbb)
    ION.add(LATITUDE: LATITUDE, &fbb)
    ION.add(LONGITUDE: LONGITUDE, &fbb)
    ION.add(ALTITUDE: ALTITUDE, &fbb)
    ION.add(START_TIME: START_TIME, &fbb)
    ION.add(STOP_TIME: STOP_TIME, &fbb)
    ION.add(FOF2: FOF2, &fbb)
    ION.add(FOF1: FOF1, &fbb)
    ION.add(FOE: FOE, &fbb)
    ION.add(FOES: FOES, &fbb)
    ION.add(HMF2: HMF2, &fbb)
    ION.add(HMF1: HMF1, &fbb)
    ION.add(HME: HME, &fbb)
    ION.add(NMF2: NMF2, &fbb)
    ION.add(VTEC: VTEC, &fbb)
    ION.add(STEC: STEC, &fbb)
    ION.add(S4: S4, &fbb)
    ION.addVectorOf(DATA_POINTS: DATA_POINTS, &fbb)
    ION.addVectorOf(DENSITY_PROFILES: DENSITY_PROFILES, &fbb)
    ION.add(QUALITY: QUALITY, &fbb)
    ION.add(NOTES: NOTES, &fbb)
    return ION.endION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ID.p, fieldName: "ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOURCE.p, fieldName: "SOURCE", required: false, type: ionoSource.self)
    try _v.visit(field: VTOFFSET.STATION_ID.p, fieldName: "STATION_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STATION_NAME.p, fieldName: "STATION_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LATITUDE.p, fieldName: "LATITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.LONGITUDE.p, fieldName: "LONGITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ALTITUDE.p, fieldName: "ALTITUDE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.START_TIME.p, fieldName: "START_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STOP_TIME.p, fieldName: "STOP_TIME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FOF2.p, fieldName: "FOF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FOF1.p, fieldName: "FOF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FOE.p, fieldName: "FOE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.FOES.p, fieldName: "FOES", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HMF2.p, fieldName: "HMF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HMF1.p, fieldName: "HMF1", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.HME.p, fieldName: "HME", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.NMF2.p, fieldName: "NMF2", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VTEC.p, fieldName: "VTEC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.STEC.p, fieldName: "STEC", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.S4.p, fieldName: "S4", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DATA_POINTS.p, fieldName: "DATA_POINTS", required: false, type: ForwardOffset<Vector<ForwardOffset<ionoDataPoint>, ionoDataPoint>>.self)
    try _v.visit(field: VTOFFSET.DENSITY_PROFILES.p, fieldName: "DENSITY_PROFILES", required: false, type: ForwardOffset<Vector<ForwardOffset<ionoDensityProfile>, ionoDensityProfile>>.self)
    try _v.visit(field: VTOFFSET.QUALITY.p, fieldName: "QUALITY", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.NOTES.p, fieldName: "NOTES", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

