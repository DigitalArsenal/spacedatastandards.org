// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum WeaponType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case mgSmall = 0
  case mgHeavy = 1
  case autocannon = 2
  case cannon = 3
  case tankGun = 4
  case artillery = 5
  case mortar = 6
  case rocketUnguided = 7
  case bombDumb = 8
  case bombGuided = 9
  case torpedo = 10
  case depthCharge = 11
  case mine = 12
  case grenade = 13

  public static var max: WeaponType { return .grenade }
  public static var min: WeaponType { return .mgSmall }
}


public enum FuzeType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case contact = 0
  case delay = 1
  case timed = 2
  case proximity = 3
  case airburst = 4
  case magnetic = 5
  case pressure = 6
  case seismic = 7

  public static var max: FuzeType { return .seismic }
  public static var min: FuzeType { return .contact }
}


public enum ProjectilePhase: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case loaded = 0
  case inFlight = 1
  case detonated = 2
  case dud = 3
  case impact = 4

  public static var max: ProjectilePhase { return .impact }
  public static var min: ProjectilePhase { return .loaded }
}


///  Weapons and Munitions
public struct WPN: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$WPN" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: WPN.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CALIBER = 4
    case MUZZLE_VELOCITY = 6
    case RATE_OF_FIRE = 8
    case DISPERSION = 10
    case AMMO_CAPACITY = 12
    case BURST_LENGTH = 14
    case RELOAD_TIME = 16
    case OVERHEAT_ROUNDS = 18
    case COOLDOWN_RATE = 20
    case ELEVATION_MIN = 22
    case ELEVATION_MAX = 24
    case TRAVERSE_MIN = 26
    case TRAVERSE_MAX = 28
    case SLEW_RATE = 30
    case WEAPON_TYPE = 32
    case FUZE_TYPE = 34
    case RESERVED = 36
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var CALIBER: Float32 { let o = _accessor.offset(VTOFFSET.CALIBER.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var MUZZLE_VELOCITY: Float32 { let o = _accessor.offset(VTOFFSET.MUZZLE_VELOCITY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var RATE_OF_FIRE: Float32 { let o = _accessor.offset(VTOFFSET.RATE_OF_FIRE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var DISPERSION: Float32 { let o = _accessor.offset(VTOFFSET.DISPERSION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var AMMO_CAPACITY: UInt16 { let o = _accessor.offset(VTOFFSET.AMMO_CAPACITY.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var BURST_LENGTH: UInt16 { let o = _accessor.offset(VTOFFSET.BURST_LENGTH.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var RELOAD_TIME: Float32 { let o = _accessor.offset(VTOFFSET.RELOAD_TIME.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var OVERHEAT_ROUNDS: UInt16 { let o = _accessor.offset(VTOFFSET.OVERHEAT_ROUNDS.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt16.self, at: o) }
  public var COOLDOWN_RATE: Float32 { let o = _accessor.offset(VTOFFSET.COOLDOWN_RATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var ELEVATION_MIN: Float32 { let o = _accessor.offset(VTOFFSET.ELEVATION_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var ELEVATION_MAX: Float32 { let o = _accessor.offset(VTOFFSET.ELEVATION_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var TRAVERSE_MIN: Float32 { let o = _accessor.offset(VTOFFSET.TRAVERSE_MIN.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var TRAVERSE_MAX: Float32 { let o = _accessor.offset(VTOFFSET.TRAVERSE_MAX.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var SLEW_RATE: Float32 { let o = _accessor.offset(VTOFFSET.SLEW_RATE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var WEAPON_TYPE: UInt8 { let o = _accessor.offset(VTOFFSET.WEAPON_TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var FUZE_TYPE: UInt8 { let o = _accessor.offset(VTOFFSET.FUZE_TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var hasReserved: Bool { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? false : true }
  public var RESERVEDCount: Int32 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RESERVED(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.RESERVED.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var RESERVED: [UInt8] { return _accessor.getVector(at: VTOFFSET.RESERVED.v) ?? [] }
  public static func startWPN(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 17) }
  public static func add(CALIBER: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CALIBER, def: 0.0, at: VTOFFSET.CALIBER.p) }
  public static func add(MUZZLE_VELOCITY: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MUZZLE_VELOCITY, def: 0.0, at: VTOFFSET.MUZZLE_VELOCITY.p) }
  public static func add(RATE_OF_FIRE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RATE_OF_FIRE, def: 0.0, at: VTOFFSET.RATE_OF_FIRE.p) }
  public static func add(DISPERSION: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DISPERSION, def: 0.0, at: VTOFFSET.DISPERSION.p) }
  public static func add(AMMO_CAPACITY: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AMMO_CAPACITY, def: 0, at: VTOFFSET.AMMO_CAPACITY.p) }
  public static func add(BURST_LENGTH: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BURST_LENGTH, def: 0, at: VTOFFSET.BURST_LENGTH.p) }
  public static func add(RELOAD_TIME: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RELOAD_TIME, def: 0.0, at: VTOFFSET.RELOAD_TIME.p) }
  public static func add(OVERHEAT_ROUNDS: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: OVERHEAT_ROUNDS, def: 0, at: VTOFFSET.OVERHEAT_ROUNDS.p) }
  public static func add(COOLDOWN_RATE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: COOLDOWN_RATE, def: 0.0, at: VTOFFSET.COOLDOWN_RATE.p) }
  public static func add(ELEVATION_MIN: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ELEVATION_MIN, def: 0.0, at: VTOFFSET.ELEVATION_MIN.p) }
  public static func add(ELEVATION_MAX: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ELEVATION_MAX, def: 0.0, at: VTOFFSET.ELEVATION_MAX.p) }
  public static func add(TRAVERSE_MIN: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRAVERSE_MIN, def: 0.0, at: VTOFFSET.TRAVERSE_MIN.p) }
  public static func add(TRAVERSE_MAX: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TRAVERSE_MAX, def: 0.0, at: VTOFFSET.TRAVERSE_MAX.p) }
  public static func add(SLEW_RATE: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SLEW_RATE, def: 0.0, at: VTOFFSET.SLEW_RATE.p) }
  public static func add(WEAPON_TYPE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WEAPON_TYPE, def: 0, at: VTOFFSET.WEAPON_TYPE.p) }
  public static func add(FUZE_TYPE: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: FUZE_TYPE, def: 0, at: VTOFFSET.FUZE_TYPE.p) }
  public static func addVectorOf(RESERVED: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RESERVED, at: VTOFFSET.RESERVED.p) }
  public static func endWPN(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createWPN(
    _ fbb: inout FlatBufferBuilder,
    CALIBER: Float32 = 0.0,
    MUZZLE_VELOCITY: Float32 = 0.0,
    RATE_OF_FIRE: Float32 = 0.0,
    DISPERSION: Float32 = 0.0,
    AMMO_CAPACITY: UInt16 = 0,
    BURST_LENGTH: UInt16 = 0,
    RELOAD_TIME: Float32 = 0.0,
    OVERHEAT_ROUNDS: UInt16 = 0,
    COOLDOWN_RATE: Float32 = 0.0,
    ELEVATION_MIN: Float32 = 0.0,
    ELEVATION_MAX: Float32 = 0.0,
    TRAVERSE_MIN: Float32 = 0.0,
    TRAVERSE_MAX: Float32 = 0.0,
    SLEW_RATE: Float32 = 0.0,
    WEAPON_TYPE: UInt8 = 0,
    FUZE_TYPE: UInt8 = 0,
    RESERVEDVectorOffset RESERVED: Offset = Offset()
  ) -> Offset {
    let __start = WPN.startWPN(&fbb)
    WPN.add(CALIBER: CALIBER, &fbb)
    WPN.add(MUZZLE_VELOCITY: MUZZLE_VELOCITY, &fbb)
    WPN.add(RATE_OF_FIRE: RATE_OF_FIRE, &fbb)
    WPN.add(DISPERSION: DISPERSION, &fbb)
    WPN.add(AMMO_CAPACITY: AMMO_CAPACITY, &fbb)
    WPN.add(BURST_LENGTH: BURST_LENGTH, &fbb)
    WPN.add(RELOAD_TIME: RELOAD_TIME, &fbb)
    WPN.add(OVERHEAT_ROUNDS: OVERHEAT_ROUNDS, &fbb)
    WPN.add(COOLDOWN_RATE: COOLDOWN_RATE, &fbb)
    WPN.add(ELEVATION_MIN: ELEVATION_MIN, &fbb)
    WPN.add(ELEVATION_MAX: ELEVATION_MAX, &fbb)
    WPN.add(TRAVERSE_MIN: TRAVERSE_MIN, &fbb)
    WPN.add(TRAVERSE_MAX: TRAVERSE_MAX, &fbb)
    WPN.add(SLEW_RATE: SLEW_RATE, &fbb)
    WPN.add(WEAPON_TYPE: WEAPON_TYPE, &fbb)
    WPN.add(FUZE_TYPE: FUZE_TYPE, &fbb)
    WPN.addVectorOf(RESERVED: RESERVED, &fbb)
    return WPN.endWPN(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CALIBER.p, fieldName: "CALIBER", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.MUZZLE_VELOCITY.p, fieldName: "MUZZLE_VELOCITY", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.RATE_OF_FIRE.p, fieldName: "RATE_OF_FIRE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.DISPERSION.p, fieldName: "DISPERSION", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.AMMO_CAPACITY.p, fieldName: "AMMO_CAPACITY", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.BURST_LENGTH.p, fieldName: "BURST_LENGTH", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.RELOAD_TIME.p, fieldName: "RELOAD_TIME", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.OVERHEAT_ROUNDS.p, fieldName: "OVERHEAT_ROUNDS", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.COOLDOWN_RATE.p, fieldName: "COOLDOWN_RATE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ELEVATION_MIN.p, fieldName: "ELEVATION_MIN", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.ELEVATION_MAX.p, fieldName: "ELEVATION_MAX", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.TRAVERSE_MIN.p, fieldName: "TRAVERSE_MIN", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.TRAVERSE_MAX.p, fieldName: "TRAVERSE_MAX", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.SLEW_RATE.p, fieldName: "SLEW_RATE", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.WEAPON_TYPE.p, fieldName: "WEAPON_TYPE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.FUZE_TYPE.p, fieldName: "FUZE_TYPE", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.RESERVED.p, fieldName: "RESERVED", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

