// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Encrypted Message Envelope
public struct EME: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EME" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EME.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ENCRYPTED_BLOB = 4
    case EPHEMERAL_PUBLIC_KEY = 6
    case MAC = 8
    case NONCE = 10
    case TAG = 12
    case IV = 14
    case PUBLIC_KEY_IDENTIFIER = 16
    case CIPHER_SUITE = 18
    case KDF_PARAMETERS = 20
    case ENCRYPTION_ALGORITHM_PARAMETERS = 22
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Encrypted data blob, containing the ciphertext of the original plaintext message.
  public var hasEncryptedBlob: Bool { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? false : true }
  public var ENCRYPTED_BLOBCount: Int32 { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENCRYPTED_BLOB(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var ENCRYPTED_BLOB: [UInt8] { return _accessor.getVector(at: VTOFFSET.ENCRYPTED_BLOB.v) ?? [] }
  ///  Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  public var EPHEMERAL_PUBLIC_KEY: String? { let o = _accessor.offset(VTOFFSET.EPHEMERAL_PUBLIC_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPHEMERAL_PUBLIC_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.v) }
  ///  Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  public var MAC: String? { let o = _accessor.offset(VTOFFSET.MAC.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MACSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAC.v) }
  ///  Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
  public var NONCE: String? { let o = _accessor.offset(VTOFFSET.NONCE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NONCESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NONCE.v) }
  ///  Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  public var TAG: String? { let o = _accessor.offset(VTOFFSET.TAG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TAGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TAG.v) }
  ///  Initialization vector used to introduce randomness in the encryption process, enhancing security.
  public var IV: String? { let o = _accessor.offset(VTOFFSET.IV.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IVSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IV.v) }
  ///  Identifier for the public key used, aiding in recipient key management and message decryption.
  public var PUBLIC_KEY_IDENTIFIER: String? { let o = _accessor.offset(VTOFFSET.PUBLIC_KEY_IDENTIFIER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PUBLIC_KEY_IDENTIFIERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PUBLIC_KEY_IDENTIFIER.v) }
  ///  Specifies the set of cryptographic algorithms used in the encryption process.
  public var CIPHER_SUITE: String? { let o = _accessor.offset(VTOFFSET.CIPHER_SUITE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CIPHER_SUITESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CIPHER_SUITE.v) }
  ///  Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  public var KDF_PARAMETERS: String? { let o = _accessor.offset(VTOFFSET.KDF_PARAMETERS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KDF_PARAMETERSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KDF_PARAMETERS.v) }
  ///  Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  public var ENCRYPTION_ALGORITHM_PARAMETERS: String? { let o = _accessor.offset(VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ENCRYPTION_ALGORITHM_PARAMETERSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.v) }
  public static func startEME(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 10) }
  public static func addVectorOf(ENCRYPTED_BLOB: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENCRYPTED_BLOB, at: VTOFFSET.ENCRYPTED_BLOB.p) }
  public static func add(EPHEMERAL_PUBLIC_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPHEMERAL_PUBLIC_KEY, at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p) }
  public static func add(MAC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAC, at: VTOFFSET.MAC.p) }
  public static func add(NONCE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NONCE, at: VTOFFSET.NONCE.p) }
  public static func add(TAG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TAG, at: VTOFFSET.TAG.p) }
  public static func add(IV: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IV, at: VTOFFSET.IV.p) }
  public static func add(PUBLIC_KEY_IDENTIFIER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PUBLIC_KEY_IDENTIFIER, at: VTOFFSET.PUBLIC_KEY_IDENTIFIER.p) }
  public static func add(CIPHER_SUITE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CIPHER_SUITE, at: VTOFFSET.CIPHER_SUITE.p) }
  public static func add(KDF_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KDF_PARAMETERS, at: VTOFFSET.KDF_PARAMETERS.p) }
  public static func add(ENCRYPTION_ALGORITHM_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENCRYPTION_ALGORITHM_PARAMETERS, at: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.p) }
  public static func endEME(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEME(
    _ fbb: inout FlatBufferBuilder,
    ENCRYPTED_BLOBVectorOffset ENCRYPTED_BLOB: Offset = Offset(),
    EPHEMERAL_PUBLIC_KEYOffset EPHEMERAL_PUBLIC_KEY: Offset = Offset(),
    MACOffset MAC: Offset = Offset(),
    NONCEOffset NONCE: Offset = Offset(),
    TAGOffset TAG: Offset = Offset(),
    IVOffset IV: Offset = Offset(),
    PUBLIC_KEY_IDENTIFIEROffset PUBLIC_KEY_IDENTIFIER: Offset = Offset(),
    CIPHER_SUITEOffset CIPHER_SUITE: Offset = Offset(),
    KDF_PARAMETERSOffset KDF_PARAMETERS: Offset = Offset(),
    ENCRYPTION_ALGORITHM_PARAMETERSOffset ENCRYPTION_ALGORITHM_PARAMETERS: Offset = Offset()
  ) -> Offset {
    let __start = EME.startEME(&fbb)
    EME.addVectorOf(ENCRYPTED_BLOB: ENCRYPTED_BLOB, &fbb)
    EME.add(EPHEMERAL_PUBLIC_KEY: EPHEMERAL_PUBLIC_KEY, &fbb)
    EME.add(MAC: MAC, &fbb)
    EME.add(NONCE: NONCE, &fbb)
    EME.add(TAG: TAG, &fbb)
    EME.add(IV: IV, &fbb)
    EME.add(PUBLIC_KEY_IDENTIFIER: PUBLIC_KEY_IDENTIFIER, &fbb)
    EME.add(CIPHER_SUITE: CIPHER_SUITE, &fbb)
    EME.add(KDF_PARAMETERS: KDF_PARAMETERS, &fbb)
    EME.add(ENCRYPTION_ALGORITHM_PARAMETERS: ENCRYPTION_ALGORITHM_PARAMETERS, &fbb)
    return EME.endEME(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ENCRYPTED_BLOB.p, fieldName: "ENCRYPTED_BLOB", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p, fieldName: "EPHEMERAL_PUBLIC_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAC.p, fieldName: "MAC", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NONCE.p, fieldName: "NONCE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TAG.p, fieldName: "TAG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.IV.p, fieldName: "IV", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PUBLIC_KEY_IDENTIFIER.p, fieldName: "PUBLIC_KEY_IDENTIFIER", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CIPHER_SUITE.p, fieldName: "CIPHER_SUITE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KDF_PARAMETERS.p, fieldName: "KDF_PARAMETERS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.p, fieldName: "ENCRYPTION_ALGORITHM_PARAMETERS", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of Encrypted Message Envelopes
public struct EMECOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EME" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EMECOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> EME? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : EME(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startEMECOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endEMECOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEMECOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = EMECOLLECTION.startEMECOLLECTION(&fbb)
    EMECOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return EMECOLLECTION.endEMECOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<EME>, EME>>.self)
    _v.finish()
  }
}

