// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Encrypted Message Envelope
public struct EME: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EME" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EME.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ENCRYPTED_BLOB = 4
    case EPHEMERAL_PUBLIC_KEY = 6
    case MAC = 8
    case NONCE_START = 10
    case TAG = 12
    case IV = 14
    case SALT = 16
    case PUBLIC_KEY_IDENTIFIER = 18
    case CIPHER_SUITE = 20
    case KDF_PARAMETERS = 22
    case ENCRYPTION_ALGORITHM_PARAMETERS = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Encrypted data blob, containing the ciphertext of the original plaintext message.
  public var hasEncryptedBlob: Bool { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? false : true }
  public var ENCRYPTED_BLOBCount: Int32 { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ENCRYPTED_BLOB(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.ENCRYPTED_BLOB.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var ENCRYPTED_BLOB: [UInt8] { return _accessor.getVector(at: VTOFFSET.ENCRYPTED_BLOB.v) ?? [] }
  ///  Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  public var EPHEMERAL_PUBLIC_KEY: String? { let o = _accessor.offset(VTOFFSET.EPHEMERAL_PUBLIC_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPHEMERAL_PUBLIC_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.v) }
  ///  Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  public var MAC: String? { let o = _accessor.offset(VTOFFSET.MAC.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MACSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MAC.v) }
  ///  Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  public var hasNonceStart: Bool { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? false : true }
  public var NONCE_STARTCount: Int32 { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func NONCE_START(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.NONCE_START.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var NONCE_START: [UInt8] { return _accessor.getVector(at: VTOFFSET.NONCE_START.v) ?? [] }
  ///  Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  public var TAG: String? { let o = _accessor.offset(VTOFFSET.TAG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TAGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TAG.v) }
  ///  Initialization vector used to introduce randomness in the encryption process, enhancing security.
  public var IV: String? { let o = _accessor.offset(VTOFFSET.IV.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IVSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IV.v) }
  ///  Cryptographic salt used in key derivation (e.g. HKDF) to ensure unique key material per session.
  public var SALT: String? { let o = _accessor.offset(VTOFFSET.SALT.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SALTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SALT.v) }
  ///  Identifier for the public key used, aiding in recipient key management and message decryption.
  public var PUBLIC_KEY_IDENTIFIER: String? { let o = _accessor.offset(VTOFFSET.PUBLIC_KEY_IDENTIFIER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PUBLIC_KEY_IDENTIFIERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PUBLIC_KEY_IDENTIFIER.v) }
  ///  Specifies the set of cryptographic algorithms used in the encryption process.
  public var CIPHER_SUITE: String? { let o = _accessor.offset(VTOFFSET.CIPHER_SUITE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CIPHER_SUITESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CIPHER_SUITE.v) }
  ///  Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  public var KDF_PARAMETERS: String? { let o = _accessor.offset(VTOFFSET.KDF_PARAMETERS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KDF_PARAMETERSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KDF_PARAMETERS.v) }
  ///  Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  public var ENCRYPTION_ALGORITHM_PARAMETERS: String? { let o = _accessor.offset(VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ENCRYPTION_ALGORITHM_PARAMETERSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.v) }
  public static func startEME(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func addVectorOf(ENCRYPTED_BLOB: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENCRYPTED_BLOB, at: VTOFFSET.ENCRYPTED_BLOB.p) }
  public static func add(EPHEMERAL_PUBLIC_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPHEMERAL_PUBLIC_KEY, at: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p) }
  public static func add(MAC: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MAC, at: VTOFFSET.MAC.p) }
  public static func addVectorOf(NONCE_START: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NONCE_START, at: VTOFFSET.NONCE_START.p) }
  public static func add(TAG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TAG, at: VTOFFSET.TAG.p) }
  public static func add(IV: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IV, at: VTOFFSET.IV.p) }
  public static func add(SALT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SALT, at: VTOFFSET.SALT.p) }
  public static func add(PUBLIC_KEY_IDENTIFIER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PUBLIC_KEY_IDENTIFIER, at: VTOFFSET.PUBLIC_KEY_IDENTIFIER.p) }
  public static func add(CIPHER_SUITE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CIPHER_SUITE, at: VTOFFSET.CIPHER_SUITE.p) }
  public static func add(KDF_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KDF_PARAMETERS, at: VTOFFSET.KDF_PARAMETERS.p) }
  public static func add(ENCRYPTION_ALGORITHM_PARAMETERS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENCRYPTION_ALGORITHM_PARAMETERS, at: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.p) }
  public static func endEME(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEME(
    _ fbb: inout FlatBufferBuilder,
    ENCRYPTED_BLOBVectorOffset ENCRYPTED_BLOB: Offset = Offset(),
    EPHEMERAL_PUBLIC_KEYOffset EPHEMERAL_PUBLIC_KEY: Offset = Offset(),
    MACOffset MAC: Offset = Offset(),
    NONCE_STARTVectorOffset NONCE_START: Offset = Offset(),
    TAGOffset TAG: Offset = Offset(),
    IVOffset IV: Offset = Offset(),
    SALTOffset SALT: Offset = Offset(),
    PUBLIC_KEY_IDENTIFIEROffset PUBLIC_KEY_IDENTIFIER: Offset = Offset(),
    CIPHER_SUITEOffset CIPHER_SUITE: Offset = Offset(),
    KDF_PARAMETERSOffset KDF_PARAMETERS: Offset = Offset(),
    ENCRYPTION_ALGORITHM_PARAMETERSOffset ENCRYPTION_ALGORITHM_PARAMETERS: Offset = Offset()
  ) -> Offset {
    let __start = EME.startEME(&fbb)
    EME.addVectorOf(ENCRYPTED_BLOB: ENCRYPTED_BLOB, &fbb)
    EME.add(EPHEMERAL_PUBLIC_KEY: EPHEMERAL_PUBLIC_KEY, &fbb)
    EME.add(MAC: MAC, &fbb)
    EME.addVectorOf(NONCE_START: NONCE_START, &fbb)
    EME.add(TAG: TAG, &fbb)
    EME.add(IV: IV, &fbb)
    EME.add(SALT: SALT, &fbb)
    EME.add(PUBLIC_KEY_IDENTIFIER: PUBLIC_KEY_IDENTIFIER, &fbb)
    EME.add(CIPHER_SUITE: CIPHER_SUITE, &fbb)
    EME.add(KDF_PARAMETERS: KDF_PARAMETERS, &fbb)
    EME.add(ENCRYPTION_ALGORITHM_PARAMETERS: ENCRYPTION_ALGORITHM_PARAMETERS, &fbb)
    return EME.endEME(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ENCRYPTED_BLOB.p, fieldName: "ENCRYPTED_BLOB", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.EPHEMERAL_PUBLIC_KEY.p, fieldName: "EPHEMERAL_PUBLIC_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.MAC.p, fieldName: "MAC", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NONCE_START.p, fieldName: "NONCE_START", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.TAG.p, fieldName: "TAG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.IV.p, fieldName: "IV", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SALT.p, fieldName: "SALT", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PUBLIC_KEY_IDENTIFIER.p, fieldName: "PUBLIC_KEY_IDENTIFIER", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CIPHER_SUITE.p, fieldName: "CIPHER_SUITE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KDF_PARAMETERS.p, fieldName: "KDF_PARAMETERS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ENCRYPTION_ALGORITHM_PARAMETERS.p, fieldName: "ENCRYPTION_ALGORITHM_PARAMETERS", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

