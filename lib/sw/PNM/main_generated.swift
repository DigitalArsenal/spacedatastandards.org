// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Publish Notification Message
public struct PNM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PNM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PNM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case IPFS_CID = 4
    case KEY_ADDRESS = 6
    case ETH_DIGITAL_SIGNATURE = 8
    case BTC_DIGITAL_SIGNATURE = 10
    case LTC_DIGITAL_SIGNATURE = 12
    case XRP_DIGITAL_SIGNATURE = 14
    case ADA_DIGITAL_SIGNATURE = 16
    case XLM_DIGITAL_SIGNATURE = 18
    case DOGE_DIGITAL_SIGNATURE = 20
    case XMR_DIGITAL_SIGNATURE = 22
    case DOT_DIGITAL_SIGNATURE = 24
    case FIL_DIGITAL_SIGNATURE = 26
    case XTZ_DIGITAL_SIGNATURE = 28
    case ATOM_DIGITAL_SIGNATURE = 30
    case TRX_DIGITAL_SIGNATURE = 32
    case BNB_DIGITAL_SIGNATURE = 34
    case AVAX_DIGITAL_SIGNATURE = 36
    case SOL_DIGITAL_SIGNATURE = 38
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  IPFS Content Identifier (CID)
  ///  The hash of a file stored on the InterPlanetary File System (IPFS).
  ///  Refer to the section on IPFS integration for details.
  public var IPFS_CID: String? { let o = _accessor.offset(VTOFFSET.IPFS_CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IPFS_CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IPFS_CID.v) }
  ///  Unique identifier generated from the data provider's public key
  public var KEY_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.KEY_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KEY_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KEY_ADDRESS.v) }
  ///  Ethereum Digital Signature
  ///  Digital signature of the IPFS file hash using Ethereum's signing mechanism.
  ///  Refer to the Ethereum Blockchain integration section for details.
  public var ETH_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.ETH_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ETH_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ETH_DIGITAL_SIGNATURE.v) }
  ///  Bitcoin Digital Signature
  ///  Digital signature of the IPFS file hash using Bitcoin's signing mechanism.
  ///  Refer to the Bitcoin Blockchain integration section for details.
  public var BTC_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.BTC_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var BTC_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.BTC_DIGITAL_SIGNATURE.v) }
  ///  Litecoin Digital Signature
  ///  Digital signature of the IPFS file hash using Litecoin's signing mechanism.
  ///  Refer to the Litecoin Blockchain integration section for details.
  public var LTC_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.LTC_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LTC_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LTC_DIGITAL_SIGNATURE.v) }
  ///  Ripple Digital Signature
  ///  Digital signature of the IPFS file hash using Ripple's signing mechanism.
  ///  Refer to the Ripple Blockchain integration section for details.
  public var XRP_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.XRP_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XRP_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XRP_DIGITAL_SIGNATURE.v) }
  ///  Cardano Digital Signature
  ///  Digital signature of the IPFS file hash using Cardano's signing mechanism.
  ///  Refer to the Cardano Blockchain integration section for details.
  public var ADA_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.ADA_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADA_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADA_DIGITAL_SIGNATURE.v) }
  ///  Stellar Digital Signature
  ///  Digital signature of the IPFS file hash using Stellar's signing mechanism.
  ///  Refer to the Stellar Blockchain integration section for details.
  public var XLM_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.XLM_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XLM_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XLM_DIGITAL_SIGNATURE.v) }
  ///  Dogecoin Digital Signature
  ///  Digital signature of the IPFS file hash using Dogecoin's signing mechanism.
  ///  Refer to the Dogecoin Blockchain integration section for details.
  public var DOGE_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.DOGE_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DOGE_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DOGE_DIGITAL_SIGNATURE.v) }
  ///  Monero Digital Signature
  ///  Digital signature of the IPFS file hash using Monero's signing mechanism.
  ///  Refer to the Monero Blockchain integration section for details.
  public var XMR_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.XMR_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XMR_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XMR_DIGITAL_SIGNATURE.v) }
  ///  Polkadot Digital Signature
  ///  Digital signature of the IPFS file hash using Polkadot's signing mechanism.
  ///  Refer to the Polkadot Blockchain integration section for details.
  public var DOT_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.DOT_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DOT_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DOT_DIGITAL_SIGNATURE.v) }
  ///  Filecoin Digital Signature
  ///  Digital signature of the IPFS file hash using Filecoin's signing mechanism.
  ///  Refer to the Filecoin Blockchain integration section for details.
  public var FIL_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.FIL_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FIL_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FIL_DIGITAL_SIGNATURE.v) }
  ///  Tezos Digital Signature
  ///  Digital signature of the IPFS file hash using Tezos's signing mechanism.
  ///  Refer to the Tezos Blockchain integration section for details.
  public var XTZ_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.XTZ_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XTZ_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XTZ_DIGITAL_SIGNATURE.v) }
  ///  Cosmos Digital Signature
  ///  Digital signature of the IPFS file hash using Cosmos's signing mechanism.
  ///  Refer to the Cosmos Blockchain integration section for details.
  public var ATOM_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.ATOM_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ATOM_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ATOM_DIGITAL_SIGNATURE.v) }
  ///  Tron Digital Signature
  ///  Digital signature of the IPFS file hash using Tron's signing mechanism.
  ///  Refer to the Tron Blockchain integration section for details.
  public var TRX_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.TRX_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TRX_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TRX_DIGITAL_SIGNATURE.v) }
  ///  Binance Coin Digital Signature
  ///  Digital signature of the IPFS file hash using Binance Coin's signing mechanism.
  ///  Refer to the Binance Coin Blockchain integration section for details.
  public var BNB_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.BNB_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var BNB_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.BNB_DIGITAL_SIGNATURE.v) }
  ///  Avalanche Digital Signature
  ///  Digital signature of the IPFS file hash using Avalanche's signing mechanism.
  ///  Refer to the Avalanche Blockchain integration section for details.
  public var AVAX_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.AVAX_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AVAX_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AVAX_DIGITAL_SIGNATURE.v) }
  ///  Solana Digital Signature
  ///  Digital signature of the IPFS file hash using Solana's signing mechanism.
  ///  Refer to the Solana Blockchain integration section for details.
  public var SOL_DIGITAL_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.SOL_DIGITAL_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SOL_DIGITAL_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SOL_DIGITAL_SIGNATURE.v) }
  public static func startPNM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 18) }
  public static func add(IPFS_CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IPFS_CID, at: VTOFFSET.IPFS_CID.p) }
  public static func add(KEY_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEY_ADDRESS, at: VTOFFSET.KEY_ADDRESS.p) }
  public static func add(ETH_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ETH_DIGITAL_SIGNATURE, at: VTOFFSET.ETH_DIGITAL_SIGNATURE.p) }
  public static func add(BTC_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BTC_DIGITAL_SIGNATURE, at: VTOFFSET.BTC_DIGITAL_SIGNATURE.p) }
  public static func add(LTC_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LTC_DIGITAL_SIGNATURE, at: VTOFFSET.LTC_DIGITAL_SIGNATURE.p) }
  public static func add(XRP_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XRP_DIGITAL_SIGNATURE, at: VTOFFSET.XRP_DIGITAL_SIGNATURE.p) }
  public static func add(ADA_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADA_DIGITAL_SIGNATURE, at: VTOFFSET.ADA_DIGITAL_SIGNATURE.p) }
  public static func add(XLM_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XLM_DIGITAL_SIGNATURE, at: VTOFFSET.XLM_DIGITAL_SIGNATURE.p) }
  public static func add(DOGE_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DOGE_DIGITAL_SIGNATURE, at: VTOFFSET.DOGE_DIGITAL_SIGNATURE.p) }
  public static func add(XMR_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XMR_DIGITAL_SIGNATURE, at: VTOFFSET.XMR_DIGITAL_SIGNATURE.p) }
  public static func add(DOT_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DOT_DIGITAL_SIGNATURE, at: VTOFFSET.DOT_DIGITAL_SIGNATURE.p) }
  public static func add(FIL_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FIL_DIGITAL_SIGNATURE, at: VTOFFSET.FIL_DIGITAL_SIGNATURE.p) }
  public static func add(XTZ_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XTZ_DIGITAL_SIGNATURE, at: VTOFFSET.XTZ_DIGITAL_SIGNATURE.p) }
  public static func add(ATOM_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ATOM_DIGITAL_SIGNATURE, at: VTOFFSET.ATOM_DIGITAL_SIGNATURE.p) }
  public static func add(TRX_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TRX_DIGITAL_SIGNATURE, at: VTOFFSET.TRX_DIGITAL_SIGNATURE.p) }
  public static func add(BNB_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: BNB_DIGITAL_SIGNATURE, at: VTOFFSET.BNB_DIGITAL_SIGNATURE.p) }
  public static func add(AVAX_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AVAX_DIGITAL_SIGNATURE, at: VTOFFSET.AVAX_DIGITAL_SIGNATURE.p) }
  public static func add(SOL_DIGITAL_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SOL_DIGITAL_SIGNATURE, at: VTOFFSET.SOL_DIGITAL_SIGNATURE.p) }
  public static func endPNM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPNM(
    _ fbb: inout FlatBufferBuilder,
    IPFS_CIDOffset IPFS_CID: Offset = Offset(),
    KEY_ADDRESSOffset KEY_ADDRESS: Offset = Offset(),
    ETH_DIGITAL_SIGNATUREOffset ETH_DIGITAL_SIGNATURE: Offset = Offset(),
    BTC_DIGITAL_SIGNATUREOffset BTC_DIGITAL_SIGNATURE: Offset = Offset(),
    LTC_DIGITAL_SIGNATUREOffset LTC_DIGITAL_SIGNATURE: Offset = Offset(),
    XRP_DIGITAL_SIGNATUREOffset XRP_DIGITAL_SIGNATURE: Offset = Offset(),
    ADA_DIGITAL_SIGNATUREOffset ADA_DIGITAL_SIGNATURE: Offset = Offset(),
    XLM_DIGITAL_SIGNATUREOffset XLM_DIGITAL_SIGNATURE: Offset = Offset(),
    DOGE_DIGITAL_SIGNATUREOffset DOGE_DIGITAL_SIGNATURE: Offset = Offset(),
    XMR_DIGITAL_SIGNATUREOffset XMR_DIGITAL_SIGNATURE: Offset = Offset(),
    DOT_DIGITAL_SIGNATUREOffset DOT_DIGITAL_SIGNATURE: Offset = Offset(),
    FIL_DIGITAL_SIGNATUREOffset FIL_DIGITAL_SIGNATURE: Offset = Offset(),
    XTZ_DIGITAL_SIGNATUREOffset XTZ_DIGITAL_SIGNATURE: Offset = Offset(),
    ATOM_DIGITAL_SIGNATUREOffset ATOM_DIGITAL_SIGNATURE: Offset = Offset(),
    TRX_DIGITAL_SIGNATUREOffset TRX_DIGITAL_SIGNATURE: Offset = Offset(),
    BNB_DIGITAL_SIGNATUREOffset BNB_DIGITAL_SIGNATURE: Offset = Offset(),
    AVAX_DIGITAL_SIGNATUREOffset AVAX_DIGITAL_SIGNATURE: Offset = Offset(),
    SOL_DIGITAL_SIGNATUREOffset SOL_DIGITAL_SIGNATURE: Offset = Offset()
  ) -> Offset {
    let __start = PNM.startPNM(&fbb)
    PNM.add(IPFS_CID: IPFS_CID, &fbb)
    PNM.add(KEY_ADDRESS: KEY_ADDRESS, &fbb)
    PNM.add(ETH_DIGITAL_SIGNATURE: ETH_DIGITAL_SIGNATURE, &fbb)
    PNM.add(BTC_DIGITAL_SIGNATURE: BTC_DIGITAL_SIGNATURE, &fbb)
    PNM.add(LTC_DIGITAL_SIGNATURE: LTC_DIGITAL_SIGNATURE, &fbb)
    PNM.add(XRP_DIGITAL_SIGNATURE: XRP_DIGITAL_SIGNATURE, &fbb)
    PNM.add(ADA_DIGITAL_SIGNATURE: ADA_DIGITAL_SIGNATURE, &fbb)
    PNM.add(XLM_DIGITAL_SIGNATURE: XLM_DIGITAL_SIGNATURE, &fbb)
    PNM.add(DOGE_DIGITAL_SIGNATURE: DOGE_DIGITAL_SIGNATURE, &fbb)
    PNM.add(XMR_DIGITAL_SIGNATURE: XMR_DIGITAL_SIGNATURE, &fbb)
    PNM.add(DOT_DIGITAL_SIGNATURE: DOT_DIGITAL_SIGNATURE, &fbb)
    PNM.add(FIL_DIGITAL_SIGNATURE: FIL_DIGITAL_SIGNATURE, &fbb)
    PNM.add(XTZ_DIGITAL_SIGNATURE: XTZ_DIGITAL_SIGNATURE, &fbb)
    PNM.add(ATOM_DIGITAL_SIGNATURE: ATOM_DIGITAL_SIGNATURE, &fbb)
    PNM.add(TRX_DIGITAL_SIGNATURE: TRX_DIGITAL_SIGNATURE, &fbb)
    PNM.add(BNB_DIGITAL_SIGNATURE: BNB_DIGITAL_SIGNATURE, &fbb)
    PNM.add(AVAX_DIGITAL_SIGNATURE: AVAX_DIGITAL_SIGNATURE, &fbb)
    PNM.add(SOL_DIGITAL_SIGNATURE: SOL_DIGITAL_SIGNATURE, &fbb)
    return PNM.endPNM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.IPFS_CID.p, fieldName: "IPFS_CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEY_ADDRESS.p, fieldName: "KEY_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ETH_DIGITAL_SIGNATURE.p, fieldName: "ETH_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.BTC_DIGITAL_SIGNATURE.p, fieldName: "BTC_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LTC_DIGITAL_SIGNATURE.p, fieldName: "LTC_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XRP_DIGITAL_SIGNATURE.p, fieldName: "XRP_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADA_DIGITAL_SIGNATURE.p, fieldName: "ADA_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XLM_DIGITAL_SIGNATURE.p, fieldName: "XLM_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DOGE_DIGITAL_SIGNATURE.p, fieldName: "DOGE_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XMR_DIGITAL_SIGNATURE.p, fieldName: "XMR_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DOT_DIGITAL_SIGNATURE.p, fieldName: "DOT_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FIL_DIGITAL_SIGNATURE.p, fieldName: "FIL_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XTZ_DIGITAL_SIGNATURE.p, fieldName: "XTZ_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ATOM_DIGITAL_SIGNATURE.p, fieldName: "ATOM_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TRX_DIGITAL_SIGNATURE.p, fieldName: "TRX_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.BNB_DIGITAL_SIGNATURE.p, fieldName: "BNB_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AVAX_DIGITAL_SIGNATURE.p, fieldName: "AVAX_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SOL_DIGITAL_SIGNATURE.p, fieldName: "SOL_DIGITAL_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Collection of Publish Notification Messages
///  This table groups multiple PNM records for batch processing and management.
public struct PNM_COLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PNM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PNM_COLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> PNM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : PNM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startPNM_COLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endPNM_COLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPNM_COLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = PNM_COLLECTION.startPNM_COLLECTION(&fbb)
    PNM_COLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return PNM_COLLECTION.endPNM_COLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<PNM>, PNM>>.self)
    _v.finish()
  }
}

