// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Publish Notification Message
public struct PNM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PNM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PNM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case MULTIFORMAT_ADDRESS = 4
    case PUBLISH_TIMESTAMP = 6
    case CID = 8
    case FILE_NAME = 10
    case FILE_ID = 12
    case SIGNATURE = 14
    case TIMESTAMP_SIGNATURE = 16
    case SIGNATURE_TYPE = 18
    case TIMESTAMP_SIGNATURE_TYPE = 20
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Multiformat Address
  ///  https://multiformats.io/multiaddr/
  ///  A universal address format for representing multiple network protocols. Examples include:
  ///  - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
  ///  - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
  ///  - /dns4/example.com for a domain name resolvable only to IPv4 addresses
  ///  - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
  public var MULTIFORMAT_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.MULTIFORMAT_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MULTIFORMAT_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MULTIFORMAT_ADDRESS.v) }
  ///  Publish Time OF THE Publish Notification Message
  public var PUBLISH_TIMESTAMP: String? { let o = _accessor.offset(VTOFFSET.PUBLISH_TIMESTAMP.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PUBLISH_TIMESTAMPSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PUBLISH_TIMESTAMP.v) }
  ///  Concatenated Content Identifier (CID)
  ///  This field is a unique ID for distributed systems (CID).
  ///  The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
  public var CID: String? { let o = _accessor.offset(VTOFFSET.CID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CIDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CID.v) }
  ///  File ID
  ///  This field is the Name
  public var FILE_NAME: String? { let o = _accessor.offset(VTOFFSET.FILE_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FILE_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FILE_NAME.v) }
  ///  File ID
  ///  This field is the file ID / Standard Type
  public var FILE_ID: String? { let o = _accessor.offset(VTOFFSET.FILE_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FILE_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FILE_ID.v) }
  ///  Digital Signature of the CID
  ///  This is the digital signature of the CID, signed using the specified cryptographic method.
  public var SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SIGNATURE.v) }
  ///  Timestamp Signature
  ///  Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
  public var TIMESTAMP_SIGNATURE: String? { let o = _accessor.offset(VTOFFSET.TIMESTAMP_SIGNATURE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIMESTAMP_SIGNATURESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIMESTAMP_SIGNATURE.v) }
  ///  Type of Cryptographic Signature Used
  ///  Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  public var SIGNATURE_TYPE: String? { let o = _accessor.offset(VTOFFSET.SIGNATURE_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SIGNATURE_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SIGNATURE_TYPE.v) }
  ///  Type of Cryptographic Signature Used for Timestamp
  ///  Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  public var TIMESTAMP_SIGNATURE_TYPE: String? { let o = _accessor.offset(VTOFFSET.TIMESTAMP_SIGNATURE_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIMESTAMP_SIGNATURE_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIMESTAMP_SIGNATURE_TYPE.v) }
  public static func startPNM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 9) }
  public static func add(MULTIFORMAT_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MULTIFORMAT_ADDRESS, at: VTOFFSET.MULTIFORMAT_ADDRESS.p) }
  public static func add(PUBLISH_TIMESTAMP: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PUBLISH_TIMESTAMP, at: VTOFFSET.PUBLISH_TIMESTAMP.p) }
  public static func add(CID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CID, at: VTOFFSET.CID.p) }
  public static func add(FILE_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FILE_NAME, at: VTOFFSET.FILE_NAME.p) }
  public static func add(FILE_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FILE_ID, at: VTOFFSET.FILE_ID.p) }
  public static func add(SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIGNATURE, at: VTOFFSET.SIGNATURE.p) }
  public static func add(TIMESTAMP_SIGNATURE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIMESTAMP_SIGNATURE, at: VTOFFSET.TIMESTAMP_SIGNATURE.p) }
  public static func add(SIGNATURE_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SIGNATURE_TYPE, at: VTOFFSET.SIGNATURE_TYPE.p) }
  public static func add(TIMESTAMP_SIGNATURE_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIMESTAMP_SIGNATURE_TYPE, at: VTOFFSET.TIMESTAMP_SIGNATURE_TYPE.p) }
  public static func endPNM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPNM(
    _ fbb: inout FlatBufferBuilder,
    MULTIFORMAT_ADDRESSOffset MULTIFORMAT_ADDRESS: Offset = Offset(),
    PUBLISH_TIMESTAMPOffset PUBLISH_TIMESTAMP: Offset = Offset(),
    CIDOffset CID: Offset = Offset(),
    FILE_NAMEOffset FILE_NAME: Offset = Offset(),
    FILE_IDOffset FILE_ID: Offset = Offset(),
    SIGNATUREOffset SIGNATURE: Offset = Offset(),
    TIMESTAMP_SIGNATUREOffset TIMESTAMP_SIGNATURE: Offset = Offset(),
    SIGNATURE_TYPEOffset SIGNATURE_TYPE: Offset = Offset(),
    TIMESTAMP_SIGNATURE_TYPEOffset TIMESTAMP_SIGNATURE_TYPE: Offset = Offset()
  ) -> Offset {
    let __start = PNM.startPNM(&fbb)
    PNM.add(MULTIFORMAT_ADDRESS: MULTIFORMAT_ADDRESS, &fbb)
    PNM.add(PUBLISH_TIMESTAMP: PUBLISH_TIMESTAMP, &fbb)
    PNM.add(CID: CID, &fbb)
    PNM.add(FILE_NAME: FILE_NAME, &fbb)
    PNM.add(FILE_ID: FILE_ID, &fbb)
    PNM.add(SIGNATURE: SIGNATURE, &fbb)
    PNM.add(TIMESTAMP_SIGNATURE: TIMESTAMP_SIGNATURE, &fbb)
    PNM.add(SIGNATURE_TYPE: SIGNATURE_TYPE, &fbb)
    PNM.add(TIMESTAMP_SIGNATURE_TYPE: TIMESTAMP_SIGNATURE_TYPE, &fbb)
    return PNM.endPNM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.MULTIFORMAT_ADDRESS.p, fieldName: "MULTIFORMAT_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PUBLISH_TIMESTAMP.p, fieldName: "PUBLISH_TIMESTAMP", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CID.p, fieldName: "CID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FILE_NAME.p, fieldName: "FILE_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FILE_ID.p, fieldName: "FILE_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIGNATURE.p, fieldName: "SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIMESTAMP_SIGNATURE.p, fieldName: "TIMESTAMP_SIGNATURE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SIGNATURE_TYPE.p, fieldName: "SIGNATURE_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIMESTAMP_SIGNATURE_TYPE.p, fieldName: "TIMESTAMP_SIGNATURE_TYPE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct PNMCOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$PNM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: PNMCOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> PNM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : PNM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startPNMCOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endPNMCOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPNMCOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = PNMCOLLECTION.startPNMCOLLECTION(&fbb)
    PNMCOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return PNMCOLLECTION.endPNMCOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<PNM>, PNM>>.self)
    _v.finish()
  }
}

