// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

///  Union type for Entity, which can be either a Person or an Organization
public enum Entity: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case person = 1
  case organization = 2

  public static var max: Entity { return .organization }
  public static var min: Entity { return .none_ }
}


///  Crypto Key Information
public struct CryptoKey: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CryptoKey.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PUBLIC_KEY = 4
    case XPUB = 6
    case PRIVATE_KEY = 8
    case XPRIV = 10
    case KEY_ADDRESS = 12
    case ADDRESS_TYPE = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Public part of the cryptographic key
  public var PUBLIC_KEY: String? { let o = _accessor.offset(VTOFFSET.PUBLIC_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PUBLIC_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PUBLIC_KEY.v) }
  ///  Extended public key
  public var XPUB: String? { let o = _accessor.offset(VTOFFSET.XPUB.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XPUBSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XPUB.v) }
  ///  Private part of the cryptographic key, should be kept secret
  public var PRIVATE_KEY: String? { let o = _accessor.offset(VTOFFSET.PRIVATE_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PRIVATE_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PRIVATE_KEY.v) }
  ///  Extended private key
  public var XPRIV: String? { let o = _accessor.offset(VTOFFSET.XPRIV.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XPRIVSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XPRIV.v) }
  ///  Address generated from the cryptographic key
  public var KEY_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.KEY_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KEY_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KEY_ADDRESS.v) }
  ///  Numerical type of the address generated from the cryptographic key
  public var ADDRESS_TYPE: String? { let o = _accessor.offset(VTOFFSET.ADDRESS_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDRESS_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDRESS_TYPE.v) }
  public static func startCryptoKey(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(PUBLIC_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PUBLIC_KEY, at: VTOFFSET.PUBLIC_KEY.p) }
  public static func add(XPUB: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XPUB, at: VTOFFSET.XPUB.p) }
  public static func add(PRIVATE_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PRIVATE_KEY, at: VTOFFSET.PRIVATE_KEY.p) }
  public static func add(XPRIV: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XPRIV, at: VTOFFSET.XPRIV.p) }
  public static func add(KEY_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEY_ADDRESS, at: VTOFFSET.KEY_ADDRESS.p) }
  public static func add(ADDRESS_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS_TYPE, at: VTOFFSET.ADDRESS_TYPE.p) }
  public static func endCryptoKey(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCryptoKey(
    _ fbb: inout FlatBufferBuilder,
    PUBLIC_KEYOffset PUBLIC_KEY: Offset = Offset(),
    XPUBOffset XPUB: Offset = Offset(),
    PRIVATE_KEYOffset PRIVATE_KEY: Offset = Offset(),
    XPRIVOffset XPRIV: Offset = Offset(),
    KEY_ADDRESSOffset KEY_ADDRESS: Offset = Offset(),
    ADDRESS_TYPEOffset ADDRESS_TYPE: Offset = Offset()
  ) -> Offset {
    let __start = CryptoKey.startCryptoKey(&fbb)
    CryptoKey.add(PUBLIC_KEY: PUBLIC_KEY, &fbb)
    CryptoKey.add(XPUB: XPUB, &fbb)
    CryptoKey.add(PRIVATE_KEY: PRIVATE_KEY, &fbb)
    CryptoKey.add(XPRIV: XPRIV, &fbb)
    CryptoKey.add(KEY_ADDRESS: KEY_ADDRESS, &fbb)
    CryptoKey.add(ADDRESS_TYPE: ADDRESS_TYPE, &fbb)
    return CryptoKey.endCryptoKey(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PUBLIC_KEY.p, fieldName: "PUBLIC_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XPUB.p, fieldName: "XPUB", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PRIVATE_KEY.p, fieldName: "PRIVATE_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XPRIV.p, fieldName: "XPRIV", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEY_ADDRESS.p, fieldName: "KEY_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDRESS_TYPE.p, fieldName: "ADDRESS_TYPE", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Information about a contact point
public struct ContactPoint: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: ContactPoint.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case CONTACT_TYPE = 6
    case EMAIL = 8
    case TELEPHONE = 10
    case CONTACT_OPTION = 12
    case AREA_SERVED = 14
    case AVAILABLE_LANGUAGE = 16
    case ADDRESS_COUNTRY = 18
    case ADDRESS_REGION = 20
    case ADDRESS_LOCALITY = 22
    case POSTAL_CODE = 24
    case STREET_ADDRESS = 26
    case POST_OFFICE_BOX_NUMBER = 28
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of the contact point or person
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Type of contact (e.g., customer service, technical support)
  public var CONTACT_TYPE: String? { let o = _accessor.offset(VTOFFSET.CONTACT_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTACT_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTACT_TYPE.v) }
  ///  Email address
  public var EMAIL: String? { let o = _accessor.offset(VTOFFSET.EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EMAIL.v) }
  ///  Telephone number
  public var TELEPHONE: String? { let o = _accessor.offset(VTOFFSET.TELEPHONE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TELEPHONESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TELEPHONE.v) }
  ///  Available contact options (e.g., HearingImpairedSupported)
  public var CONTACT_OPTION: String? { let o = _accessor.offset(VTOFFSET.CONTACT_OPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONTACT_OPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONTACT_OPTION.v) }
  ///  Geographic area where the service is available
  public var AREA_SERVED: String? { let o = _accessor.offset(VTOFFSET.AREA_SERVED.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AREA_SERVEDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AREA_SERVED.v) }
  ///  Language available for communication
  public var AVAILABLE_LANGUAGE: String? { let o = _accessor.offset(VTOFFSET.AVAILABLE_LANGUAGE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var AVAILABLE_LANGUAGESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.AVAILABLE_LANGUAGE.v) }
  ///  Country of the address
  public var ADDRESS_COUNTRY: String? { let o = _accessor.offset(VTOFFSET.ADDRESS_COUNTRY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDRESS_COUNTRYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDRESS_COUNTRY.v) }
  ///  Region of the address (e.g., state or province)
  public var ADDRESS_REGION: String? { let o = _accessor.offset(VTOFFSET.ADDRESS_REGION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDRESS_REGIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDRESS_REGION.v) }
  ///  Locality of the address (e.g., city or town)
  public var ADDRESS_LOCALITY: String? { let o = _accessor.offset(VTOFFSET.ADDRESS_LOCALITY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDRESS_LOCALITYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDRESS_LOCALITY.v) }
  ///  Postal code of the address
  public var POSTAL_CODE: String? { let o = _accessor.offset(VTOFFSET.POSTAL_CODE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POSTAL_CODESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POSTAL_CODE.v) }
  ///  Street address
  public var STREET_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.STREET_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STREET_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STREET_ADDRESS.v) }
  ///  Post office box number
  public var POST_OFFICE_BOX_NUMBER: String? { let o = _accessor.offset(VTOFFSET.POST_OFFICE_BOX_NUMBER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POST_OFFICE_BOX_NUMBERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POST_OFFICE_BOX_NUMBER.v) }
  public static func startContactPoint(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 13) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(CONTACT_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTACT_TYPE, at: VTOFFSET.CONTACT_TYPE.p) }
  public static func add(EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EMAIL, at: VTOFFSET.EMAIL.p) }
  public static func add(TELEPHONE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TELEPHONE, at: VTOFFSET.TELEPHONE.p) }
  public static func add(CONTACT_OPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTACT_OPTION, at: VTOFFSET.CONTACT_OPTION.p) }
  public static func add(AREA_SERVED: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AREA_SERVED, at: VTOFFSET.AREA_SERVED.p) }
  public static func add(AVAILABLE_LANGUAGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: AVAILABLE_LANGUAGE, at: VTOFFSET.AVAILABLE_LANGUAGE.p) }
  public static func add(ADDRESS_COUNTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS_COUNTRY, at: VTOFFSET.ADDRESS_COUNTRY.p) }
  public static func add(ADDRESS_REGION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS_REGION, at: VTOFFSET.ADDRESS_REGION.p) }
  public static func add(ADDRESS_LOCALITY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS_LOCALITY, at: VTOFFSET.ADDRESS_LOCALITY.p) }
  public static func add(POSTAL_CODE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSTAL_CODE, at: VTOFFSET.POSTAL_CODE.p) }
  public static func add(STREET_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STREET_ADDRESS, at: VTOFFSET.STREET_ADDRESS.p) }
  public static func add(POST_OFFICE_BOX_NUMBER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POST_OFFICE_BOX_NUMBER, at: VTOFFSET.POST_OFFICE_BOX_NUMBER.p) }
  public static func endContactPoint(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createContactPoint(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    CONTACT_TYPEOffset CONTACT_TYPE: Offset = Offset(),
    EMAILOffset EMAIL: Offset = Offset(),
    TELEPHONEOffset TELEPHONE: Offset = Offset(),
    CONTACT_OPTIONOffset CONTACT_OPTION: Offset = Offset(),
    AREA_SERVEDOffset AREA_SERVED: Offset = Offset(),
    AVAILABLE_LANGUAGEOffset AVAILABLE_LANGUAGE: Offset = Offset(),
    ADDRESS_COUNTRYOffset ADDRESS_COUNTRY: Offset = Offset(),
    ADDRESS_REGIONOffset ADDRESS_REGION: Offset = Offset(),
    ADDRESS_LOCALITYOffset ADDRESS_LOCALITY: Offset = Offset(),
    POSTAL_CODEOffset POSTAL_CODE: Offset = Offset(),
    STREET_ADDRESSOffset STREET_ADDRESS: Offset = Offset(),
    POST_OFFICE_BOX_NUMBEROffset POST_OFFICE_BOX_NUMBER: Offset = Offset()
  ) -> Offset {
    let __start = ContactPoint.startContactPoint(&fbb)
    ContactPoint.add(NAME: NAME, &fbb)
    ContactPoint.add(CONTACT_TYPE: CONTACT_TYPE, &fbb)
    ContactPoint.add(EMAIL: EMAIL, &fbb)
    ContactPoint.add(TELEPHONE: TELEPHONE, &fbb)
    ContactPoint.add(CONTACT_OPTION: CONTACT_OPTION, &fbb)
    ContactPoint.add(AREA_SERVED: AREA_SERVED, &fbb)
    ContactPoint.add(AVAILABLE_LANGUAGE: AVAILABLE_LANGUAGE, &fbb)
    ContactPoint.add(ADDRESS_COUNTRY: ADDRESS_COUNTRY, &fbb)
    ContactPoint.add(ADDRESS_REGION: ADDRESS_REGION, &fbb)
    ContactPoint.add(ADDRESS_LOCALITY: ADDRESS_LOCALITY, &fbb)
    ContactPoint.add(POSTAL_CODE: POSTAL_CODE, &fbb)
    ContactPoint.add(STREET_ADDRESS: STREET_ADDRESS, &fbb)
    ContactPoint.add(POST_OFFICE_BOX_NUMBER: POST_OFFICE_BOX_NUMBER, &fbb)
    return ContactPoint.endContactPoint(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTACT_TYPE.p, fieldName: "CONTACT_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EMAIL.p, fieldName: "EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TELEPHONE.p, fieldName: "TELEPHONE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONTACT_OPTION.p, fieldName: "CONTACT_OPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AREA_SERVED.p, fieldName: "AREA_SERVED", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.AVAILABLE_LANGUAGE.p, fieldName: "AVAILABLE_LANGUAGE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDRESS_COUNTRY.p, fieldName: "ADDRESS_COUNTRY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDRESS_REGION.p, fieldName: "ADDRESS_REGION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDRESS_LOCALITY.p, fieldName: "ADDRESS_LOCALITY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSTAL_CODE.p, fieldName: "POSTAL_CODE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STREET_ADDRESS.p, fieldName: "STREET_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POST_OFFICE_BOX_NUMBER.p, fieldName: "POST_OFFICE_BOX_NUMBER", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Basic information about an organization
public struct Organization: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Organization.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case LEGAL_NAME = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Common name of the organization
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Legal name of the organization
  public var LEGAL_NAME: String? { let o = _accessor.offset(VTOFFSET.LEGAL_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LEGAL_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LEGAL_NAME.v) }
  public static func startOrganization(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(LEGAL_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LEGAL_NAME, at: VTOFFSET.LEGAL_NAME.p) }
  public static func endOrganization(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOrganization(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    LEGAL_NAMEOffset LEGAL_NAME: Offset = Offset()
  ) -> Offset {
    let __start = Organization.startOrganization(&fbb)
    Organization.add(NAME: NAME, &fbb)
    Organization.add(LEGAL_NAME: LEGAL_NAME, &fbb)
    return Organization.endOrganization(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LEGAL_NAME.p, fieldName: "LEGAL_NAME", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Information about a person's occupation
public struct Occupation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Occupation.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Name of the occupation
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  public static func startOccupation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func endOccupation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createOccupation(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset()
  ) -> Offset {
    let __start = Occupation.startOccupation(&fbb)
    Occupation.add(NAME: NAME, &fbb)
    return Occupation.endOccupation(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Information about a person
public struct Person: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Person.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case FAMILY_NAME = 4
    case GIVEN_NAME = 6
    case ADDITIONAL_NAME = 8
    case HONORIFIC_PREFIX = 10
    case HONORIFIC_SUFFIX = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Family name or surname of the person
  public var FAMILY_NAME: String? { let o = _accessor.offset(VTOFFSET.FAMILY_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FAMILY_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FAMILY_NAME.v) }
  ///  Given name or first name of the person
  public var GIVEN_NAME: String? { let o = _accessor.offset(VTOFFSET.GIVEN_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GIVEN_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GIVEN_NAME.v) }
  ///  Additional name or middle name of the person
  public var ADDITIONAL_NAME: String? { let o = _accessor.offset(VTOFFSET.ADDITIONAL_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDITIONAL_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDITIONAL_NAME.v) }
  ///  Honorific prefix preceding the person's name
  public var HONORIFIC_PREFIX: String? { let o = _accessor.offset(VTOFFSET.HONORIFIC_PREFIX.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HONORIFIC_PREFIXSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HONORIFIC_PREFIX.v) }
  ///  Honorific suffix following the person's name
  public var HONORIFIC_SUFFIX: String? { let o = _accessor.offset(VTOFFSET.HONORIFIC_SUFFIX.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HONORIFIC_SUFFIXSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HONORIFIC_SUFFIX.v) }
  public static func startPerson(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(FAMILY_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FAMILY_NAME, at: VTOFFSET.FAMILY_NAME.p) }
  public static func add(GIVEN_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GIVEN_NAME, at: VTOFFSET.GIVEN_NAME.p) }
  public static func add(ADDITIONAL_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDITIONAL_NAME, at: VTOFFSET.ADDITIONAL_NAME.p) }
  public static func add(HONORIFIC_PREFIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HONORIFIC_PREFIX, at: VTOFFSET.HONORIFIC_PREFIX.p) }
  public static func add(HONORIFIC_SUFFIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HONORIFIC_SUFFIX, at: VTOFFSET.HONORIFIC_SUFFIX.p) }
  public static func endPerson(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPerson(
    _ fbb: inout FlatBufferBuilder,
    FAMILY_NAMEOffset FAMILY_NAME: Offset = Offset(),
    GIVEN_NAMEOffset GIVEN_NAME: Offset = Offset(),
    ADDITIONAL_NAMEOffset ADDITIONAL_NAME: Offset = Offset(),
    HONORIFIC_PREFIXOffset HONORIFIC_PREFIX: Offset = Offset(),
    HONORIFIC_SUFFIXOffset HONORIFIC_SUFFIX: Offset = Offset()
  ) -> Offset {
    let __start = Person.startPerson(&fbb)
    Person.add(FAMILY_NAME: FAMILY_NAME, &fbb)
    Person.add(GIVEN_NAME: GIVEN_NAME, &fbb)
    Person.add(ADDITIONAL_NAME: ADDITIONAL_NAME, &fbb)
    Person.add(HONORIFIC_PREFIX: HONORIFIC_PREFIX, &fbb)
    Person.add(HONORIFIC_SUFFIX: HONORIFIC_SUFFIX, &fbb)
    return Person.endPerson(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.FAMILY_NAME.p, fieldName: "FAMILY_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GIVEN_NAME.p, fieldName: "GIVEN_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDITIONAL_NAME.p, fieldName: "ADDITIONAL_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HONORIFIC_PREFIX.p, fieldName: "HONORIFIC_PREFIX", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HONORIFIC_SUFFIX.p, fieldName: "HONORIFIC_SUFFIX", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Entity Profile Message
public struct EPM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EPM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case NAME = 4
    case ALTERNATE_NAME = 6
    case DESCRIPTION = 8
    case IMAGE = 10
    case SAME_AS = 12
    case URL = 14
    case TELEPHONE = 16
    case EMAIL = 18
    case KEY = 20
    case CONTACT_POINT = 22
    case ADDRESS = 24
    case JOB_TITLE = 26
    case entityType = 28
    case ENTITY = 30
    case HAS_OCCUPATION = 32
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Common name of the entity (person or organization)
  public var NAME: String? { let o = _accessor.offset(VTOFFSET.NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.NAME.v) }
  ///  Alternate name for the entity
  public var ALTERNATE_NAME: String? { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ALTERNATE_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ALTERNATE_NAME.v) }
  ///  Description of the entity
  public var DESCRIPTION: String? { let o = _accessor.offset(VTOFFSET.DESCRIPTION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DESCRIPTIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DESCRIPTION.v) }
  ///  URL of an image representing the entity
  public var IMAGE: String? { let o = _accessor.offset(VTOFFSET.IMAGE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var IMAGESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.IMAGE.v) }
  ///  URL of a webpage that unambiguously indicates the entity's identity
  public var SAME_AS: String? { let o = _accessor.offset(VTOFFSET.SAME_AS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var SAME_ASSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.SAME_AS.v) }
  ///  URL of the entity's website
  public var URL: String? { let o = _accessor.offset(VTOFFSET.URL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var URLSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.URL.v) }
  ///  Telephone number for the entity
  public var TELEPHONE: String? { let o = _accessor.offset(VTOFFSET.TELEPHONE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TELEPHONESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TELEPHONE.v) }
  ///  Email address for the entity
  public var EMAIL: String? { let o = _accessor.offset(VTOFFSET.EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EMAIL.v) }
  ///  Cryptographic key information associated with the entity
  public var hasKey: Bool { let o = _accessor.offset(VTOFFSET.KEY.v); return o == 0 ? false : true }
  public var KEYCount: Int32 { let o = _accessor.offset(VTOFFSET.KEY.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func KEY(at index: Int32) -> CryptoKey? { let o = _accessor.offset(VTOFFSET.KEY.v); return o == 0 ? nil : CryptoKey(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Contact points for the entity
  public var hasContactPoint: Bool { let o = _accessor.offset(VTOFFSET.CONTACT_POINT.v); return o == 0 ? false : true }
  public var CONTACT_POINTCount: Int32 { let o = _accessor.offset(VTOFFSET.CONTACT_POINT.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func CONTACT_POINT(at index: Int32) -> ContactPoint? { let o = _accessor.offset(VTOFFSET.CONTACT_POINT.v); return o == 0 ? nil : ContactPoint(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Address of the entity, using the ContactPoint structure
  public var ADDRESS: ContactPoint? { let o = _accessor.offset(VTOFFSET.ADDRESS.v); return o == 0 ? nil : ContactPoint(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  ///  Job title of the entity (applicable to persons)
  public var JOB_TITLE: String? { let o = _accessor.offset(VTOFFSET.JOB_TITLE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var JOB_TITLESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.JOB_TITLE.v) }
  public var entityType: Entity { let o = _accessor.offset(VTOFFSET.entityType.v); return o == 0 ? .none_ : Entity(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  ///  Union type to represent either a person or an organization
  public func ENTITY<T: FlatbuffersInitializable>(type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.ENTITY.v); return o == 0 ? nil : _accessor.union(o) }
  ///  Occupation of the entity (applicable to persons)
  public var HAS_OCCUPATION: Occupation? { let o = _accessor.offset(VTOFFSET.HAS_OCCUPATION.v); return o == 0 ? nil : Occupation(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startEPM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 15) }
  public static func add(NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: NAME, at: VTOFFSET.NAME.p) }
  public static func add(ALTERNATE_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALTERNATE_NAME, at: VTOFFSET.ALTERNATE_NAME.p) }
  public static func add(DESCRIPTION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DESCRIPTION, at: VTOFFSET.DESCRIPTION.p) }
  public static func add(IMAGE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: IMAGE, at: VTOFFSET.IMAGE.p) }
  public static func add(SAME_AS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: SAME_AS, at: VTOFFSET.SAME_AS.p) }
  public static func add(URL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: URL, at: VTOFFSET.URL.p) }
  public static func add(TELEPHONE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TELEPHONE, at: VTOFFSET.TELEPHONE.p) }
  public static func add(EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EMAIL, at: VTOFFSET.EMAIL.p) }
  public static func addVectorOf(KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEY, at: VTOFFSET.KEY.p) }
  public static func addVectorOf(CONTACT_POINT: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONTACT_POINT, at: VTOFFSET.CONTACT_POINT.p) }
  public static func add(ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS, at: VTOFFSET.ADDRESS.p) }
  public static func add(JOB_TITLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: JOB_TITLE, at: VTOFFSET.JOB_TITLE.p) }
  public static func add(entityType: Entity, _ fbb: inout FlatBufferBuilder) { fbb.add(element: entityType.rawValue, def: 0, at: VTOFFSET.entityType.p) }
  public static func add(ENTITY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ENTITY, at: VTOFFSET.ENTITY.p) }
  public static func add(HAS_OCCUPATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HAS_OCCUPATION, at: VTOFFSET.HAS_OCCUPATION.p) }
  public static func endEPM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEPM(
    _ fbb: inout FlatBufferBuilder,
    NAMEOffset NAME: Offset = Offset(),
    ALTERNATE_NAMEOffset ALTERNATE_NAME: Offset = Offset(),
    DESCRIPTIONOffset DESCRIPTION: Offset = Offset(),
    IMAGEOffset IMAGE: Offset = Offset(),
    SAME_ASOffset SAME_AS: Offset = Offset(),
    URLOffset URL: Offset = Offset(),
    TELEPHONEOffset TELEPHONE: Offset = Offset(),
    EMAILOffset EMAIL: Offset = Offset(),
    KEYVectorOffset KEY: Offset = Offset(),
    CONTACT_POINTVectorOffset CONTACT_POINT: Offset = Offset(),
    ADDRESSOffset ADDRESS: Offset = Offset(),
    JOB_TITLEOffset JOB_TITLE: Offset = Offset(),
    entityType: Entity = .none_,
    ENTITYOffset ENTITY: Offset = Offset(),
    HAS_OCCUPATIONOffset HAS_OCCUPATION: Offset = Offset()
  ) -> Offset {
    let __start = EPM.startEPM(&fbb)
    EPM.add(NAME: NAME, &fbb)
    EPM.add(ALTERNATE_NAME: ALTERNATE_NAME, &fbb)
    EPM.add(DESCRIPTION: DESCRIPTION, &fbb)
    EPM.add(IMAGE: IMAGE, &fbb)
    EPM.add(SAME_AS: SAME_AS, &fbb)
    EPM.add(URL: URL, &fbb)
    EPM.add(TELEPHONE: TELEPHONE, &fbb)
    EPM.add(EMAIL: EMAIL, &fbb)
    EPM.addVectorOf(KEY: KEY, &fbb)
    EPM.addVectorOf(CONTACT_POINT: CONTACT_POINT, &fbb)
    EPM.add(ADDRESS: ADDRESS, &fbb)
    EPM.add(JOB_TITLE: JOB_TITLE, &fbb)
    EPM.add(entityType: entityType, &fbb)
    EPM.add(ENTITY: ENTITY, &fbb)
    EPM.add(HAS_OCCUPATION: HAS_OCCUPATION, &fbb)
    return EPM.endEPM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.NAME.p, fieldName: "NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALTERNATE_NAME.p, fieldName: "ALTERNATE_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.DESCRIPTION.p, fieldName: "DESCRIPTION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.IMAGE.p, fieldName: "IMAGE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.SAME_AS.p, fieldName: "SAME_AS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.URL.p, fieldName: "URL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TELEPHONE.p, fieldName: "TELEPHONE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EMAIL.p, fieldName: "EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEY.p, fieldName: "KEY", required: false, type: ForwardOffset<Vector<ForwardOffset<CryptoKey>, CryptoKey>>.self)
    try _v.visit(field: VTOFFSET.CONTACT_POINT.p, fieldName: "CONTACT_POINT", required: false, type: ForwardOffset<Vector<ForwardOffset<ContactPoint>, ContactPoint>>.self)
    try _v.visit(field: VTOFFSET.ADDRESS.p, fieldName: "ADDRESS", required: false, type: ForwardOffset<ContactPoint>.self)
    try _v.visit(field: VTOFFSET.JOB_TITLE.p, fieldName: "JOB_TITLE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(unionKey: VTOFFSET.ENTITYType.p, unionField: VTOFFSET.ENTITY.p, unionKeyName: "ENTITYType", fieldName: "ENTITY", required: false, completion: { (verifier, key: Entity, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .person:
        try ForwardOffset<Person>.verify(&verifier, at: pos, of: Person.self)
      case .organization:
        try ForwardOffset<Organization>.verify(&verifier, at: pos, of: Organization.self)
      }
    })
    try _v.visit(field: VTOFFSET.HAS_OCCUPATION.p, fieldName: "HAS_OCCUPATION", required: false, type: ForwardOffset<Occupation>.self)
    _v.finish()
  }
}

public struct EPMCOLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EPMCOLLECTION.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Records of Entity Profile Messages
  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> EPM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : EPM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startEPMCOLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endEPMCOLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEPMCOLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = EPMCOLLECTION.startEPMCOLLECTION(&fbb)
    EPMCOLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return EPMCOLLECTION.endEPMCOLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<EPM>, EPM>>.self)
    _v.finish()
  }
}

