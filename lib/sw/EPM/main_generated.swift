// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum KeyType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case signing = 0
  case encryption = 1

  public static var max: KeyType { return .encryption }
  public static var min: KeyType { return .signing }
}


///  Represents cryptographic key information
public struct CryptoKey: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: CryptoKey.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PUBLIC_KEY = 4
    case XPUB = 6
    case PRIVATE_KEY = 8
    case XPRIV = 10
    case KEY_ADDRESS = 12
    case ADDRESS_TYPE = 14
    case KEY_TYPE = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Public part of the cryptographic key
  public var PUBLIC_KEY: String? { let o = _accessor.offset(VTOFFSET.PUBLIC_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PUBLIC_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PUBLIC_KEY.v) }
  ///  Extended public key
  public var XPUB: String? { let o = _accessor.offset(VTOFFSET.XPUB.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XPUBSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XPUB.v) }
  ///  Private part of the cryptographic key, should be kept secret
  public var PRIVATE_KEY: String? { let o = _accessor.offset(VTOFFSET.PRIVATE_KEY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PRIVATE_KEYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PRIVATE_KEY.v) }
  ///  Extended private key
  public var XPRIV: String? { let o = _accessor.offset(VTOFFSET.XPRIV.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var XPRIVSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.XPRIV.v) }
  ///  Address generated from the cryptographic key
  public var KEY_ADDRESS: String? { let o = _accessor.offset(VTOFFSET.KEY_ADDRESS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var KEY_ADDRESSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.KEY_ADDRESS.v) }
  ///  Type of the address generated from the cryptographic key
  public var ADDRESS_TYPE: String? { let o = _accessor.offset(VTOFFSET.ADDRESS_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDRESS_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDRESS_TYPE.v) }
  ///  Type of the cryptographic key (signing or encryption)
  public var KEY_TYPE: KeyType { let o = _accessor.offset(VTOFFSET.KEY_TYPE.v); return o == 0 ? .signing : KeyType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .signing }
  public static func startCryptoKey(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(PUBLIC_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PUBLIC_KEY, at: VTOFFSET.PUBLIC_KEY.p) }
  public static func add(XPUB: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XPUB, at: VTOFFSET.XPUB.p) }
  public static func add(PRIVATE_KEY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PRIVATE_KEY, at: VTOFFSET.PRIVATE_KEY.p) }
  public static func add(XPRIV: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: XPRIV, at: VTOFFSET.XPRIV.p) }
  public static func add(KEY_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEY_ADDRESS, at: VTOFFSET.KEY_ADDRESS.p) }
  public static func add(ADDRESS_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDRESS_TYPE, at: VTOFFSET.ADDRESS_TYPE.p) }
  public static func add(KEY_TYPE: KeyType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: KEY_TYPE.rawValue, def: 0, at: VTOFFSET.KEY_TYPE.p) }
  public static func endCryptoKey(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createCryptoKey(
    _ fbb: inout FlatBufferBuilder,
    PUBLIC_KEYOffset PUBLIC_KEY: Offset = Offset(),
    XPUBOffset XPUB: Offset = Offset(),
    PRIVATE_KEYOffset PRIVATE_KEY: Offset = Offset(),
    XPRIVOffset XPRIV: Offset = Offset(),
    KEY_ADDRESSOffset KEY_ADDRESS: Offset = Offset(),
    ADDRESS_TYPEOffset ADDRESS_TYPE: Offset = Offset(),
    KEY_TYPE: KeyType = .signing
  ) -> Offset {
    let __start = CryptoKey.startCryptoKey(&fbb)
    CryptoKey.add(PUBLIC_KEY: PUBLIC_KEY, &fbb)
    CryptoKey.add(XPUB: XPUB, &fbb)
    CryptoKey.add(PRIVATE_KEY: PRIVATE_KEY, &fbb)
    CryptoKey.add(XPRIV: XPRIV, &fbb)
    CryptoKey.add(KEY_ADDRESS: KEY_ADDRESS, &fbb)
    CryptoKey.add(ADDRESS_TYPE: ADDRESS_TYPE, &fbb)
    CryptoKey.add(KEY_TYPE: KEY_TYPE, &fbb)
    return CryptoKey.endCryptoKey(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PUBLIC_KEY.p, fieldName: "PUBLIC_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XPUB.p, fieldName: "XPUB", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PRIVATE_KEY.p, fieldName: "PRIVATE_KEY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.XPRIV.p, fieldName: "XPRIV", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEY_ADDRESS.p, fieldName: "KEY_ADDRESS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDRESS_TYPE.p, fieldName: "ADDRESS_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEY_TYPE.p, fieldName: "KEY_TYPE", required: false, type: KeyType.self)
    _v.finish()
  }
}

///  Represents a geographic address
public struct Address: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: Address.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COUNTRY = 4
    case REGION = 6
    case LOCALITY = 8
    case POSTAL_CODE = 10
    case STREET = 12
    case POST_OFFICE_BOX_NUMBER = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Country of the address
  public var COUNTRY: String? { let o = _accessor.offset(VTOFFSET.COUNTRY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COUNTRYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COUNTRY.v) }
  ///  Region of the address (e.g., state or province)
  public var REGION: String? { let o = _accessor.offset(VTOFFSET.REGION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var REGIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.REGION.v) }
  ///  Locality of the address (e.g., city or town)
  public var LOCALITY: String? { let o = _accessor.offset(VTOFFSET.LOCALITY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LOCALITYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LOCALITY.v) }
  ///  Postal code of the address
  public var POSTAL_CODE: String? { let o = _accessor.offset(VTOFFSET.POSTAL_CODE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POSTAL_CODESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POSTAL_CODE.v) }
  ///  Street address
  public var STREET: String? { let o = _accessor.offset(VTOFFSET.STREET.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var STREETSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.STREET.v) }
  ///  Post office box number
  public var POST_OFFICE_BOX_NUMBER: String? { let o = _accessor.offset(VTOFFSET.POST_OFFICE_BOX_NUMBER.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var POST_OFFICE_BOX_NUMBERSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.POST_OFFICE_BOX_NUMBER.v) }
  public static func startAddress(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(COUNTRY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COUNTRY, at: VTOFFSET.COUNTRY.p) }
  public static func add(REGION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REGION, at: VTOFFSET.REGION.p) }
  public static func add(LOCALITY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LOCALITY, at: VTOFFSET.LOCALITY.p) }
  public static func add(POSTAL_CODE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POSTAL_CODE, at: VTOFFSET.POSTAL_CODE.p) }
  public static func add(STREET: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STREET, at: VTOFFSET.STREET.p) }
  public static func add(POST_OFFICE_BOX_NUMBER: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: POST_OFFICE_BOX_NUMBER, at: VTOFFSET.POST_OFFICE_BOX_NUMBER.p) }
  public static func endAddress(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAddress(
    _ fbb: inout FlatBufferBuilder,
    COUNTRYOffset COUNTRY: Offset = Offset(),
    REGIONOffset REGION: Offset = Offset(),
    LOCALITYOffset LOCALITY: Offset = Offset(),
    POSTAL_CODEOffset POSTAL_CODE: Offset = Offset(),
    STREETOffset STREET: Offset = Offset(),
    POST_OFFICE_BOX_NUMBEROffset POST_OFFICE_BOX_NUMBER: Offset = Offset()
  ) -> Offset {
    let __start = Address.startAddress(&fbb)
    Address.add(COUNTRY: COUNTRY, &fbb)
    Address.add(REGION: REGION, &fbb)
    Address.add(LOCALITY: LOCALITY, &fbb)
    Address.add(POSTAL_CODE: POSTAL_CODE, &fbb)
    Address.add(STREET: STREET, &fbb)
    Address.add(POST_OFFICE_BOX_NUMBER: POST_OFFICE_BOX_NUMBER, &fbb)
    return Address.endAddress(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COUNTRY.p, fieldName: "COUNTRY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REGION.p, fieldName: "REGION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LOCALITY.p, fieldName: "LOCALITY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POSTAL_CODE.p, fieldName: "POSTAL_CODE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STREET.p, fieldName: "STREET", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.POST_OFFICE_BOX_NUMBER.p, fieldName: "POST_OFFICE_BOX_NUMBER", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

///  Entity Profile Message
public struct EPM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_3_3() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$EPM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: EPM.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case DN = 4
    case LEGAL_NAME = 6
    case FAMILY_NAME = 8
    case GIVEN_NAME = 10
    case ADDITIONAL_NAME = 12
    case HONORIFIC_PREFIX = 14
    case HONORIFIC_SUFFIX = 16
    case JOB_TITLE = 18
    case OCCUPATION = 20
    case ALTERNATE_NAMES = 22
    case EMAIL = 24
    case TELEPHONE = 26
    case KEYS = 28
    case MULTIFORMAT_ADDRESS = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Distinguished Name of the entity
  public var DN: String? { let o = _accessor.offset(VTOFFSET.DN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var DNSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.DN.v) }
  ///  Common name of the entity (person or organization)
  public var LEGAL_NAME: String? { let o = _accessor.offset(VTOFFSET.LEGAL_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var LEGAL_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.LEGAL_NAME.v) }
  ///  Family name or surname of the person
  public var FAMILY_NAME: String? { let o = _accessor.offset(VTOFFSET.FAMILY_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FAMILY_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FAMILY_NAME.v) }
  ///  Given name or first name of the person
  public var GIVEN_NAME: String? { let o = _accessor.offset(VTOFFSET.GIVEN_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GIVEN_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GIVEN_NAME.v) }
  ///  Additional name or middle name of the person
  public var ADDITIONAL_NAME: String? { let o = _accessor.offset(VTOFFSET.ADDITIONAL_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ADDITIONAL_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ADDITIONAL_NAME.v) }
  ///  Honorific prefix preceding the person's name (e.g., Mr., Dr.)
  public var HONORIFIC_PREFIX: String? { let o = _accessor.offset(VTOFFSET.HONORIFIC_PREFIX.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HONORIFIC_PREFIXSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HONORIFIC_PREFIX.v) }
  ///  Honorific suffix following the person's name (e.g., Jr., Sr.)
  public var HONORIFIC_SUFFIX: String? { let o = _accessor.offset(VTOFFSET.HONORIFIC_SUFFIX.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var HONORIFIC_SUFFIXSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.HONORIFIC_SUFFIX.v) }
  ///  Job title of the person
  public var JOB_TITLE: String? { let o = _accessor.offset(VTOFFSET.JOB_TITLE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var JOB_TITLESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.JOB_TITLE.v) }
  ///  Occupation of the person
  public var OCCUPATION: String? { let o = _accessor.offset(VTOFFSET.OCCUPATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OCCUPATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OCCUPATION.v) }
  ///  Alternate names for the entity
  public var hasAlternateNames: Bool { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? false : true }
  public var ALTERNATE_NAMESCount: Int32 { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ALTERNATE_NAMES(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.ALTERNATE_NAMES.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  ///  Email address of the entity
  public var EMAIL: String? { let o = _accessor.offset(VTOFFSET.EMAIL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EMAILSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EMAIL.v) }
  ///  Telephone number of the entity
  public var TELEPHONE: String? { let o = _accessor.offset(VTOFFSET.TELEPHONE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TELEPHONESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TELEPHONE.v) }
  ///  Cryptographic keys associated with the entity
  public var hasKeys: Bool { let o = _accessor.offset(VTOFFSET.KEYS.v); return o == 0 ? false : true }
  public var KEYSCount: Int32 { let o = _accessor.offset(VTOFFSET.KEYS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func KEYS(at index: Int32) -> CryptoKey? { let o = _accessor.offset(VTOFFSET.KEYS.v); return o == 0 ? nil : CryptoKey(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  ///  Multiformat addresses associated with the entity
  public var hasMultiformatAddress: Bool { let o = _accessor.offset(VTOFFSET.MULTIFORMAT_ADDRESS.v); return o == 0 ? false : true }
  public var MULTIFORMAT_ADDRESSCount: Int32 { let o = _accessor.offset(VTOFFSET.MULTIFORMAT_ADDRESS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func MULTIFORMAT_ADDRESS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.MULTIFORMAT_ADDRESS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startEPM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(DN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: DN, at: VTOFFSET.DN.p) }
  public static func add(LEGAL_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: LEGAL_NAME, at: VTOFFSET.LEGAL_NAME.p) }
  public static func add(FAMILY_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FAMILY_NAME, at: VTOFFSET.FAMILY_NAME.p) }
  public static func add(GIVEN_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GIVEN_NAME, at: VTOFFSET.GIVEN_NAME.p) }
  public static func add(ADDITIONAL_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ADDITIONAL_NAME, at: VTOFFSET.ADDITIONAL_NAME.p) }
  public static func add(HONORIFIC_PREFIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HONORIFIC_PREFIX, at: VTOFFSET.HONORIFIC_PREFIX.p) }
  public static func add(HONORIFIC_SUFFIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: HONORIFIC_SUFFIX, at: VTOFFSET.HONORIFIC_SUFFIX.p) }
  public static func add(JOB_TITLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: JOB_TITLE, at: VTOFFSET.JOB_TITLE.p) }
  public static func add(OCCUPATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OCCUPATION, at: VTOFFSET.OCCUPATION.p) }
  public static func addVectorOf(ALTERNATE_NAMES: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ALTERNATE_NAMES, at: VTOFFSET.ALTERNATE_NAMES.p) }
  public static func add(EMAIL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EMAIL, at: VTOFFSET.EMAIL.p) }
  public static func add(TELEPHONE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TELEPHONE, at: VTOFFSET.TELEPHONE.p) }
  public static func addVectorOf(KEYS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEYS, at: VTOFFSET.KEYS.p) }
  public static func addVectorOf(MULTIFORMAT_ADDRESS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MULTIFORMAT_ADDRESS, at: VTOFFSET.MULTIFORMAT_ADDRESS.p) }
  public static func endEPM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEPM(
    _ fbb: inout FlatBufferBuilder,
    DNOffset DN: Offset = Offset(),
    LEGAL_NAMEOffset LEGAL_NAME: Offset = Offset(),
    FAMILY_NAMEOffset FAMILY_NAME: Offset = Offset(),
    GIVEN_NAMEOffset GIVEN_NAME: Offset = Offset(),
    ADDITIONAL_NAMEOffset ADDITIONAL_NAME: Offset = Offset(),
    HONORIFIC_PREFIXOffset HONORIFIC_PREFIX: Offset = Offset(),
    HONORIFIC_SUFFIXOffset HONORIFIC_SUFFIX: Offset = Offset(),
    JOB_TITLEOffset JOB_TITLE: Offset = Offset(),
    OCCUPATIONOffset OCCUPATION: Offset = Offset(),
    ALTERNATE_NAMESVectorOffset ALTERNATE_NAMES: Offset = Offset(),
    EMAILOffset EMAIL: Offset = Offset(),
    TELEPHONEOffset TELEPHONE: Offset = Offset(),
    KEYSVectorOffset KEYS: Offset = Offset(),
    MULTIFORMAT_ADDRESSVectorOffset MULTIFORMAT_ADDRESS: Offset = Offset()
  ) -> Offset {
    let __start = EPM.startEPM(&fbb)
    EPM.add(DN: DN, &fbb)
    EPM.add(LEGAL_NAME: LEGAL_NAME, &fbb)
    EPM.add(FAMILY_NAME: FAMILY_NAME, &fbb)
    EPM.add(GIVEN_NAME: GIVEN_NAME, &fbb)
    EPM.add(ADDITIONAL_NAME: ADDITIONAL_NAME, &fbb)
    EPM.add(HONORIFIC_PREFIX: HONORIFIC_PREFIX, &fbb)
    EPM.add(HONORIFIC_SUFFIX: HONORIFIC_SUFFIX, &fbb)
    EPM.add(JOB_TITLE: JOB_TITLE, &fbb)
    EPM.add(OCCUPATION: OCCUPATION, &fbb)
    EPM.addVectorOf(ALTERNATE_NAMES: ALTERNATE_NAMES, &fbb)
    EPM.add(EMAIL: EMAIL, &fbb)
    EPM.add(TELEPHONE: TELEPHONE, &fbb)
    EPM.addVectorOf(KEYS: KEYS, &fbb)
    EPM.addVectorOf(MULTIFORMAT_ADDRESS: MULTIFORMAT_ADDRESS, &fbb)
    return EPM.endEPM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.DN.p, fieldName: "DN", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.LEGAL_NAME.p, fieldName: "LEGAL_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FAMILY_NAME.p, fieldName: "FAMILY_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GIVEN_NAME.p, fieldName: "GIVEN_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ADDITIONAL_NAME.p, fieldName: "ADDITIONAL_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HONORIFIC_PREFIX.p, fieldName: "HONORIFIC_PREFIX", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.HONORIFIC_SUFFIX.p, fieldName: "HONORIFIC_SUFFIX", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.JOB_TITLE.p, fieldName: "JOB_TITLE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OCCUPATION.p, fieldName: "OCCUPATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ALTERNATE_NAMES.p, fieldName: "ALTERNATE_NAMES", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.EMAIL.p, fieldName: "EMAIL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TELEPHONE.p, fieldName: "TELEPHONE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.KEYS.p, fieldName: "KEYS", required: false, type: ForwardOffset<Vector<ForwardOffset<CryptoKey>, CryptoKey>>.self)
    try _v.visit(field: VTOFFSET.MULTIFORMAT_ADDRESS.p, fieldName: "MULTIFORMAT_ADDRESS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

