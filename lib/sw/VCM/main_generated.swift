// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum elementType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case osculating = 0
  case mean = 1

  public static var max: elementType { return .mean }
  public static var min: elementType { return .osculating }
}


public enum anomalyType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case trueAnomaly = 0
  case meanAnomaly = 1

  public static var max: anomalyType { return .meanAnomaly }
  public static var min: anomalyType { return .trueAnomaly }
}


///  Enum to represent common atmospheric models
public enum atmosphericModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case jacchia70 = 1
  case jb2008 = 2
  case nrlmsise00 = 3
  case dtm2000 = 4
  case hwm14 = 5
  case hasdm = 6

  public static var max: atmosphericModel { return .hasdm }
  public static var min: atmosphericModel { return .none_ }
}


///  Enum to represent common geopotential models
public enum geopotentialModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case egm96 = 1
  case wgs84 = 2
  case jgm2 = 3
  case gemt3 = 4
  case egm96J5 = 5

  public static var max: geopotentialModel { return .egm96J5 }
  public static var min: geopotentialModel { return .none_ }
}


///  Enum to represent zonal harmonics
public enum zonalHarmonic: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case j2 = 1
  case j3 = 2
  case j4 = 3
  case j5 = 4
  case j6 = 5
  case j7 = 6
  case j8 = 7
  case j9 = 8
  case j10 = 9
  case j11 = 10
  case j12 = 11

  public static var max: zonalHarmonic { return .j12 }
  public static var min: zonalHarmonic { return .none_ }
}


///  Enum to represent solar radiation pressure models
public enum solarRadiationPressureModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case sphericalModel = 1
  case flatPlateModel = 2

  public static var max: solarRadiationPressureModel { return .flatPlateModel }
  public static var min: solarRadiationPressureModel { return .none_ }
}


///  Enum to represent common lunar perturbation models
public enum lunarPerturbationModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case de430 = 1
  case de431 = 2
  case lp150q = 3

  public static var max: lunarPerturbationModel { return .lp150q }
  public static var min: lunarPerturbationModel { return .none_ }
}


///  Enum to represent various solar perturbation models
public enum solarPerturbationModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case de430 = 1
  case de431 = 2

  public static var max: solarPerturbationModel { return .de431 }
  public static var min: solarPerturbationModel { return .none_ }
}


///  Enum to represent resonance models
public enum resonanceModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case highAltitudeResonance = 1
  case lowAltitudeResonance = 2
  case lunarResonance = 3
  case solarResonance = 4

  public static var max: resonanceModel { return .solarResonance }
  public static var min: resonanceModel { return .none_ }
}


///  Enum to represent the status of various perturbations (ON/OFF)
public enum perturbationStatus: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case off = 0
  case on = 1

  public static var max: perturbationStatus { return .on }
  public static var min: perturbationStatus { return .off }
}


///  Enum to represent propagator types
public enum propagatorType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case semiAnalytical = 1
  case vinti = 2
  case sgp4 = 3
  case cowell = 4
  case rk4 = 5
  case nyx = 6
  case gmat = 7
  case spice = 8
  case sgp = 9
  case sdp4 = 10
  case sgp8 = 11
  case sdp8 = 12

  public static var max: propagatorType { return .sdp8 }
  public static var min: propagatorType { return .none_ }
}


///  Propagator configuration structure to describe propagation settings
public struct propagatorConfig: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case PROPAGATOR_NAME = 4
    case PROPAGATOR_TYPE = 6
    case FORCE_MODELS = 8
    case EPOCH = 10
    case TIME_STEP = 12
    case ZONAL_HARMONIC_TERMS = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var PROPAGATOR_NAME: String? { let o = _accessor.offset(VTOFFSET.PROPAGATOR_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PROPAGATOR_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PROPAGATOR_NAME.v) }
  public var PROPAGATOR_TYPE: propagatorType { let o = _accessor.offset(VTOFFSET.PROPAGATOR_TYPE.v); return o == 0 ? .none_ : propagatorType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var hasForceModels: Bool { let o = _accessor.offset(VTOFFSET.FORCE_MODELS.v); return o == 0 ? false : true }
  public var FORCE_MODELSCount: Int32 { let o = _accessor.offset(VTOFFSET.FORCE_MODELS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func FORCE_MODELS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.FORCE_MODELS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  public var TIME_STEP: Double { let o = _accessor.offset(VTOFFSET.TIME_STEP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var hasZonalHarmonicTerms: Bool { let o = _accessor.offset(VTOFFSET.ZONAL_HARMONIC_TERMS.v); return o == 0 ? false : true }
  public var ZONAL_HARMONIC_TERMSCount: Int32 { let o = _accessor.offset(VTOFFSET.ZONAL_HARMONIC_TERMS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ZONAL_HARMONIC_TERMS(at index: Int32) -> zonalHarmonic? { let o = _accessor.offset(VTOFFSET.ZONAL_HARMONIC_TERMS.v); return o == 0 ? zonalHarmonic.none_ : zonalHarmonic(rawValue: _accessor.directRead(of: Int8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public static func startpropagatorConfig(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(PROPAGATOR_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROPAGATOR_NAME, at: VTOFFSET.PROPAGATOR_NAME.p) }
  public static func add(PROPAGATOR_TYPE: propagatorType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PROPAGATOR_TYPE.rawValue, def: 0, at: VTOFFSET.PROPAGATOR_TYPE.p) }
  public static func addVectorOf(FORCE_MODELS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FORCE_MODELS, at: VTOFFSET.FORCE_MODELS.p) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(TIME_STEP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: TIME_STEP, def: 0.0, at: VTOFFSET.TIME_STEP.p) }
  public static func addVectorOf(ZONAL_HARMONIC_TERMS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ZONAL_HARMONIC_TERMS, at: VTOFFSET.ZONAL_HARMONIC_TERMS.p) }
  public static func endpropagatorConfig(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createpropagatorConfig(
    _ fbb: inout FlatBufferBuilder,
    PROPAGATOR_NAMEOffset PROPAGATOR_NAME: Offset = Offset(),
    PROPAGATOR_TYPE: propagatorType = .none_,
    FORCE_MODELSVectorOffset FORCE_MODELS: Offset = Offset(),
    EPOCHOffset EPOCH: Offset = Offset(),
    TIME_STEP: Double = 0.0,
    ZONAL_HARMONIC_TERMSVectorOffset ZONAL_HARMONIC_TERMS: Offset = Offset()
  ) -> Offset {
    let __start = propagatorConfig.startpropagatorConfig(&fbb)
    propagatorConfig.add(PROPAGATOR_NAME: PROPAGATOR_NAME, &fbb)
    propagatorConfig.add(PROPAGATOR_TYPE: PROPAGATOR_TYPE, &fbb)
    propagatorConfig.addVectorOf(FORCE_MODELS: FORCE_MODELS, &fbb)
    propagatorConfig.add(EPOCH: EPOCH, &fbb)
    propagatorConfig.add(TIME_STEP: TIME_STEP, &fbb)
    propagatorConfig.addVectorOf(ZONAL_HARMONIC_TERMS: ZONAL_HARMONIC_TERMS, &fbb)
    return propagatorConfig.endpropagatorConfig(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.PROPAGATOR_NAME.p, fieldName: "PROPAGATOR_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROPAGATOR_TYPE.p, fieldName: "PROPAGATOR_TYPE", required: false, type: propagatorType.self)
    try _v.visit(field: VTOFFSET.FORCE_MODELS.p, fieldName: "FORCE_MODELS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_STEP.p, fieldName: "TIME_STEP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ZONAL_HARMONIC_TERMS.p, fieldName: "ZONAL_HARMONIC_TERMS", required: false, type: ForwardOffset<Vector<zonalHarmonic, zonalHarmonic>>.self)
    _v.finish()
  }
}

///  VCM State Vector (position and velocity)
public struct VCMStateVector: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case EPOCH = 4
    case X = 6
    case Y = 8
    case Z = 10
    case X_DOT = 12
    case Y_DOT = 14
    case Z_DOT = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var EPOCH: String? { let o = _accessor.offset(VTOFFSET.EPOCH.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var EPOCHSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.EPOCH.v) }
  public var X: Double { let o = _accessor.offset(VTOFFSET.X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var Y: Double { let o = _accessor.offset(VTOFFSET.Y.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var Z: Double { let o = _accessor.offset(VTOFFSET.Z.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var X_DOT: Double { let o = _accessor.offset(VTOFFSET.X_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var Y_DOT: Double { let o = _accessor.offset(VTOFFSET.Y_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var Z_DOT: Double { let o = _accessor.offset(VTOFFSET.Z_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startVCMStateVector(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(EPOCH: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EPOCH, at: VTOFFSET.EPOCH.p) }
  public static func add(X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X, def: 0.0, at: VTOFFSET.X.p) }
  public static func add(Y: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y, def: 0.0, at: VTOFFSET.Y.p) }
  public static func add(Z: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z, def: 0.0, at: VTOFFSET.Z.p) }
  public static func add(X_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: X_DOT, def: 0.0, at: VTOFFSET.X_DOT.p) }
  public static func add(Y_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Y_DOT, def: 0.0, at: VTOFFSET.Y_DOT.p) }
  public static func add(Z_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: Z_DOT, def: 0.0, at: VTOFFSET.Z_DOT.p) }
  public static func endVCMStateVector(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVCMStateVector(
    _ fbb: inout FlatBufferBuilder,
    EPOCHOffset EPOCH: Offset = Offset(),
    X: Double = 0.0,
    Y: Double = 0.0,
    Z: Double = 0.0,
    X_DOT: Double = 0.0,
    Y_DOT: Double = 0.0,
    Z_DOT: Double = 0.0
  ) -> Offset {
    let __start = VCMStateVector.startVCMStateVector(&fbb)
    VCMStateVector.add(EPOCH: EPOCH, &fbb)
    VCMStateVector.add(X: X, &fbb)
    VCMStateVector.add(Y: Y, &fbb)
    VCMStateVector.add(Z: Z, &fbb)
    VCMStateVector.add(X_DOT: X_DOT, &fbb)
    VCMStateVector.add(Y_DOT: Y_DOT, &fbb)
    VCMStateVector.add(Z_DOT: Z_DOT, &fbb)
    return VCMStateVector.endVCMStateVector(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.EPOCH.p, fieldName: "EPOCH", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.X.p, fieldName: "X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y.p, fieldName: "Y", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z.p, fieldName: "Z", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.X_DOT.p, fieldName: "X_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Y_DOT.p, fieldName: "Y_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.Z_DOT.p, fieldName: "Z_DOT", required: false, type: Double.self)
    _v.finish()
  }
}

///  VCM Covariance Matrix Line
public struct VCMCovarianceMatrixLine: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CX_X = 4
    case CY_X = 6
    case CZ_X = 8
    case CX_DOT_X = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var CX_X: Double { let o = _accessor.offset(VTOFFSET.CX_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CY_X: Double { let o = _accessor.offset(VTOFFSET.CY_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CZ_X: Double { let o = _accessor.offset(VTOFFSET.CZ_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CX_DOT_X: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startVCMCovarianceMatrixLine(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(CX_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_X, def: 0.0, at: VTOFFSET.CX_X.p) }
  public static func add(CY_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_X, def: 0.0, at: VTOFFSET.CY_X.p) }
  public static func add(CZ_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_X, def: 0.0, at: VTOFFSET.CZ_X.p) }
  public static func add(CX_DOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_X, def: 0.0, at: VTOFFSET.CX_DOT_X.p) }
  public static func endVCMCovarianceMatrixLine(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVCMCovarianceMatrixLine(
    _ fbb: inout FlatBufferBuilder,
    CX_X: Double = 0.0,
    CY_X: Double = 0.0,
    CZ_X: Double = 0.0,
    CX_DOT_X: Double = 0.0
  ) -> Offset {
    let __start = VCMCovarianceMatrixLine.startVCMCovarianceMatrixLine(&fbb)
    VCMCovarianceMatrixLine.add(CX_X: CX_X, &fbb)
    VCMCovarianceMatrixLine.add(CY_X: CY_X, &fbb)
    VCMCovarianceMatrixLine.add(CZ_X: CZ_X, &fbb)
    VCMCovarianceMatrixLine.add(CX_DOT_X: CX_DOT_X, &fbb)
    return VCMCovarianceMatrixLine.endVCMCovarianceMatrixLine(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CX_X.p, fieldName: "CX_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_X.p, fieldName: "CY_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_X.p, fieldName: "CZ_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_X.p, fieldName: "CX_DOT_X", required: false, type: Double.self)
    _v.finish()
  }
}

///  Keplerian Elements
public struct keplerianElements: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case SEMI_MAJOR_AXIS = 4
    case ECCENTRICITY = 6
    case INCLINATION = 8
    case RA_OF_ASC_NODE = 10
    case ARG_OF_PERICENTER = 12
    case ANOMALY_TYPE = 14
    case ANOMALY = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var SEMI_MAJOR_AXIS: Double { let o = _accessor.offset(VTOFFSET.SEMI_MAJOR_AXIS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ECCENTRICITY: Double { let o = _accessor.offset(VTOFFSET.ECCENTRICITY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var INCLINATION: Double { let o = _accessor.offset(VTOFFSET.INCLINATION.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var RA_OF_ASC_NODE: Double { let o = _accessor.offset(VTOFFSET.RA_OF_ASC_NODE.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ARG_OF_PERICENTER: Double { let o = _accessor.offset(VTOFFSET.ARG_OF_PERICENTER.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ANOMALY_TYPE: anomalyType { let o = _accessor.offset(VTOFFSET.ANOMALY_TYPE.v); return o == 0 ? .trueAnomaly : anomalyType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .trueAnomaly }
  public var ANOMALY: Double { let o = _accessor.offset(VTOFFSET.ANOMALY.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startkeplerianElements(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(SEMI_MAJOR_AXIS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SEMI_MAJOR_AXIS, def: 0.0, at: VTOFFSET.SEMI_MAJOR_AXIS.p) }
  public static func add(ECCENTRICITY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ECCENTRICITY, def: 0.0, at: VTOFFSET.ECCENTRICITY.p) }
  public static func add(INCLINATION: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: INCLINATION, def: 0.0, at: VTOFFSET.INCLINATION.p) }
  public static func add(RA_OF_ASC_NODE: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RA_OF_ASC_NODE, def: 0.0, at: VTOFFSET.RA_OF_ASC_NODE.p) }
  public static func add(ARG_OF_PERICENTER: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ARG_OF_PERICENTER, def: 0.0, at: VTOFFSET.ARG_OF_PERICENTER.p) }
  public static func add(ANOMALY_TYPE: anomalyType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ANOMALY_TYPE.rawValue, def: 0, at: VTOFFSET.ANOMALY_TYPE.p) }
  public static func add(ANOMALY: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ANOMALY, def: 0.0, at: VTOFFSET.ANOMALY.p) }
  public static func endkeplerianElements(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createkeplerianElements(
    _ fbb: inout FlatBufferBuilder,
    SEMI_MAJOR_AXIS: Double = 0.0,
    ECCENTRICITY: Double = 0.0,
    INCLINATION: Double = 0.0,
    RA_OF_ASC_NODE: Double = 0.0,
    ARG_OF_PERICENTER: Double = 0.0,
    ANOMALY_TYPE: anomalyType = .trueAnomaly,
    ANOMALY: Double = 0.0
  ) -> Offset {
    let __start = keplerianElements.startkeplerianElements(&fbb)
    keplerianElements.add(SEMI_MAJOR_AXIS: SEMI_MAJOR_AXIS, &fbb)
    keplerianElements.add(ECCENTRICITY: ECCENTRICITY, &fbb)
    keplerianElements.add(INCLINATION: INCLINATION, &fbb)
    keplerianElements.add(RA_OF_ASC_NODE: RA_OF_ASC_NODE, &fbb)
    keplerianElements.add(ARG_OF_PERICENTER: ARG_OF_PERICENTER, &fbb)
    keplerianElements.add(ANOMALY_TYPE: ANOMALY_TYPE, &fbb)
    keplerianElements.add(ANOMALY: ANOMALY, &fbb)
    return keplerianElements.endkeplerianElements(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.SEMI_MAJOR_AXIS.p, fieldName: "SEMI_MAJOR_AXIS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ECCENTRICITY.p, fieldName: "ECCENTRICITY", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.INCLINATION.p, fieldName: "INCLINATION", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.RA_OF_ASC_NODE.p, fieldName: "RA_OF_ASC_NODE", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ARG_OF_PERICENTER.p, fieldName: "ARG_OF_PERICENTER", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ANOMALY_TYPE.p, fieldName: "ANOMALY_TYPE", required: false, type: anomalyType.self)
    try _v.visit(field: VTOFFSET.ANOMALY.p, fieldName: "ANOMALY", required: false, type: Double.self)
    _v.finish()
  }
}

///  Equinoctial Elements
public struct equinoctialElements: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case AF = 4
    case AG = 6
    case L = 8
    case N = 10
    case CHI = 12
    case PSI = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var AF: Double { let o = _accessor.offset(VTOFFSET.AF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var AG: Double { let o = _accessor.offset(VTOFFSET.AG.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var L: Double { let o = _accessor.offset(VTOFFSET.L.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var N: Double { let o = _accessor.offset(VTOFFSET.N.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CHI: Double { let o = _accessor.offset(VTOFFSET.CHI.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var PSI: Double { let o = _accessor.offset(VTOFFSET.PSI.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startequinoctialElements(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(AF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AF, def: 0.0, at: VTOFFSET.AF.p) }
  public static func add(AG: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: AG, def: 0.0, at: VTOFFSET.AG.p) }
  public static func add(L: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: L, def: 0.0, at: VTOFFSET.L.p) }
  public static func add(N: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: N, def: 0.0, at: VTOFFSET.N.p) }
  public static func add(CHI: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CHI, def: 0.0, at: VTOFFSET.CHI.p) }
  public static func add(PSI: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: PSI, def: 0.0, at: VTOFFSET.PSI.p) }
  public static func endequinoctialElements(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createequinoctialElements(
    _ fbb: inout FlatBufferBuilder,
    AF: Double = 0.0,
    AG: Double = 0.0,
    L: Double = 0.0,
    N: Double = 0.0,
    CHI: Double = 0.0,
    PSI: Double = 0.0
  ) -> Offset {
    let __start = equinoctialElements.startequinoctialElements(&fbb)
    equinoctialElements.add(AF: AF, &fbb)
    equinoctialElements.add(AG: AG, &fbb)
    equinoctialElements.add(L: L, &fbb)
    equinoctialElements.add(N: N, &fbb)
    equinoctialElements.add(CHI: CHI, &fbb)
    equinoctialElements.add(PSI: PSI, &fbb)
    return equinoctialElements.endequinoctialElements(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.AF.p, fieldName: "AF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.AG.p, fieldName: "AG", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.L.p, fieldName: "L", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.N.p, fieldName: "N", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CHI.p, fieldName: "CHI", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.PSI.p, fieldName: "PSI", required: false, type: Double.self)
    _v.finish()
  }
}

///  UVW Sigmas (Covariance matrix in UVW frame)
public struct uvwSigmas: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case U_SIGMA = 4
    case V_SIGMA = 6
    case W_SIGMA = 8
    case UD_SIGMA = 10
    case VD_SIGMA = 12
    case WD_SIGMA = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var U_SIGMA: Double { let o = _accessor.offset(VTOFFSET.U_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var V_SIGMA: Double { let o = _accessor.offset(VTOFFSET.V_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var W_SIGMA: Double { let o = _accessor.offset(VTOFFSET.W_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var UD_SIGMA: Double { let o = _accessor.offset(VTOFFSET.UD_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var VD_SIGMA: Double { let o = _accessor.offset(VTOFFSET.VD_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var WD_SIGMA: Double { let o = _accessor.offset(VTOFFSET.WD_SIGMA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startuvwSigmas(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(U_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: U_SIGMA, def: 0.0, at: VTOFFSET.U_SIGMA.p) }
  public static func add(V_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: V_SIGMA, def: 0.0, at: VTOFFSET.V_SIGMA.p) }
  public static func add(W_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: W_SIGMA, def: 0.0, at: VTOFFSET.W_SIGMA.p) }
  public static func add(UD_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: UD_SIGMA, def: 0.0, at: VTOFFSET.UD_SIGMA.p) }
  public static func add(VD_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: VD_SIGMA, def: 0.0, at: VTOFFSET.VD_SIGMA.p) }
  public static func add(WD_SIGMA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: WD_SIGMA, def: 0.0, at: VTOFFSET.WD_SIGMA.p) }
  public static func enduvwSigmas(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createuvwSigmas(
    _ fbb: inout FlatBufferBuilder,
    U_SIGMA: Double = 0.0,
    V_SIGMA: Double = 0.0,
    W_SIGMA: Double = 0.0,
    UD_SIGMA: Double = 0.0,
    VD_SIGMA: Double = 0.0,
    WD_SIGMA: Double = 0.0
  ) -> Offset {
    let __start = uvwSigmas.startuvwSigmas(&fbb)
    uvwSigmas.add(U_SIGMA: U_SIGMA, &fbb)
    uvwSigmas.add(V_SIGMA: V_SIGMA, &fbb)
    uvwSigmas.add(W_SIGMA: W_SIGMA, &fbb)
    uvwSigmas.add(UD_SIGMA: UD_SIGMA, &fbb)
    uvwSigmas.add(VD_SIGMA: VD_SIGMA, &fbb)
    uvwSigmas.add(WD_SIGMA: WD_SIGMA, &fbb)
    return uvwSigmas.enduvwSigmas(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.U_SIGMA.p, fieldName: "U_SIGMA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.V_SIGMA.p, fieldName: "V_SIGMA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.W_SIGMA.p, fieldName: "W_SIGMA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.UD_SIGMA.p, fieldName: "UD_SIGMA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.VD_SIGMA.p, fieldName: "VD_SIGMA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.WD_SIGMA.p, fieldName: "WD_SIGMA", required: false, type: Double.self)
    _v.finish()
  }
}

///  VCM Atmospheric and Perturbation Model Data
public struct VCMAtmosphericModelData: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case ATMOSPHERIC_MODEL = 4
    case GEOPOTENTIAL_MODEL = 6
    case LUNAR_SOLAR_PERTURBATION = 8
    case LUNAR_PERTURBATION_MODEL = 10
    case SOLAR_PERTURBATION_MODEL = 12
    case SOLAR_RADIATION_PRESSURE = 14
    case SRP_MODEL = 16
    case RESONANCE_MODEL = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var ATMOSPHERIC_MODEL: atmosphericModel { let o = _accessor.offset(VTOFFSET.ATMOSPHERIC_MODEL.v); return o == 0 ? .none_ : atmosphericModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var GEOPOTENTIAL_MODEL: geopotentialModel { let o = _accessor.offset(VTOFFSET.GEOPOTENTIAL_MODEL.v); return o == 0 ? .none_ : geopotentialModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var LUNAR_SOLAR_PERTURBATION: perturbationStatus { let o = _accessor.offset(VTOFFSET.LUNAR_SOLAR_PERTURBATION.v); return o == 0 ? .off : perturbationStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .off }
  public var LUNAR_PERTURBATION_MODEL: lunarPerturbationModel { let o = _accessor.offset(VTOFFSET.LUNAR_PERTURBATION_MODEL.v); return o == 0 ? .none_ : lunarPerturbationModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var SOLAR_PERTURBATION_MODEL: solarPerturbationModel { let o = _accessor.offset(VTOFFSET.SOLAR_PERTURBATION_MODEL.v); return o == 0 ? .none_ : solarPerturbationModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var SOLAR_RADIATION_PRESSURE: perturbationStatus { let o = _accessor.offset(VTOFFSET.SOLAR_RADIATION_PRESSURE.v); return o == 0 ? .off : perturbationStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .off }
  public var SRP_MODEL: solarRadiationPressureModel { let o = _accessor.offset(VTOFFSET.SRP_MODEL.v); return o == 0 ? .none_ : solarRadiationPressureModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var RESONANCE_MODEL: resonanceModel { let o = _accessor.offset(VTOFFSET.RESONANCE_MODEL.v); return o == 0 ? .none_ : resonanceModel(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public static func startVCMAtmosphericModelData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(ATMOSPHERIC_MODEL: atmosphericModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ATMOSPHERIC_MODEL.rawValue, def: 0, at: VTOFFSET.ATMOSPHERIC_MODEL.p) }
  public static func add(GEOPOTENTIAL_MODEL: geopotentialModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GEOPOTENTIAL_MODEL.rawValue, def: 0, at: VTOFFSET.GEOPOTENTIAL_MODEL.p) }
  public static func add(LUNAR_SOLAR_PERTURBATION: perturbationStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LUNAR_SOLAR_PERTURBATION.rawValue, def: 0, at: VTOFFSET.LUNAR_SOLAR_PERTURBATION.p) }
  public static func add(LUNAR_PERTURBATION_MODEL: lunarPerturbationModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: LUNAR_PERTURBATION_MODEL.rawValue, def: 0, at: VTOFFSET.LUNAR_PERTURBATION_MODEL.p) }
  public static func add(SOLAR_PERTURBATION_MODEL: solarPerturbationModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOLAR_PERTURBATION_MODEL.rawValue, def: 0, at: VTOFFSET.SOLAR_PERTURBATION_MODEL.p) }
  public static func add(SOLAR_RADIATION_PRESSURE: perturbationStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOLAR_RADIATION_PRESSURE.rawValue, def: 0, at: VTOFFSET.SOLAR_RADIATION_PRESSURE.p) }
  public static func add(SRP_MODEL: solarRadiationPressureModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SRP_MODEL.rawValue, def: 0, at: VTOFFSET.SRP_MODEL.p) }
  public static func add(RESONANCE_MODEL: resonanceModel, _ fbb: inout FlatBufferBuilder) { fbb.add(element: RESONANCE_MODEL.rawValue, def: 0, at: VTOFFSET.RESONANCE_MODEL.p) }
  public static func endVCMAtmosphericModelData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVCMAtmosphericModelData(
    _ fbb: inout FlatBufferBuilder,
    ATMOSPHERIC_MODEL: atmosphericModel = .none_,
    GEOPOTENTIAL_MODEL: geopotentialModel = .none_,
    LUNAR_SOLAR_PERTURBATION: perturbationStatus = .off,
    LUNAR_PERTURBATION_MODEL: lunarPerturbationModel = .none_,
    SOLAR_PERTURBATION_MODEL: solarPerturbationModel = .none_,
    SOLAR_RADIATION_PRESSURE: perturbationStatus = .off,
    SRP_MODEL: solarRadiationPressureModel = .none_,
    RESONANCE_MODEL: resonanceModel = .none_
  ) -> Offset {
    let __start = VCMAtmosphericModelData.startVCMAtmosphericModelData(&fbb)
    VCMAtmosphericModelData.add(ATMOSPHERIC_MODEL: ATMOSPHERIC_MODEL, &fbb)
    VCMAtmosphericModelData.add(GEOPOTENTIAL_MODEL: GEOPOTENTIAL_MODEL, &fbb)
    VCMAtmosphericModelData.add(LUNAR_SOLAR_PERTURBATION: LUNAR_SOLAR_PERTURBATION, &fbb)
    VCMAtmosphericModelData.add(LUNAR_PERTURBATION_MODEL: LUNAR_PERTURBATION_MODEL, &fbb)
    VCMAtmosphericModelData.add(SOLAR_PERTURBATION_MODEL: SOLAR_PERTURBATION_MODEL, &fbb)
    VCMAtmosphericModelData.add(SOLAR_RADIATION_PRESSURE: SOLAR_RADIATION_PRESSURE, &fbb)
    VCMAtmosphericModelData.add(SRP_MODEL: SRP_MODEL, &fbb)
    VCMAtmosphericModelData.add(RESONANCE_MODEL: RESONANCE_MODEL, &fbb)
    return VCMAtmosphericModelData.endVCMAtmosphericModelData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.ATMOSPHERIC_MODEL.p, fieldName: "ATMOSPHERIC_MODEL", required: false, type: atmosphericModel.self)
    try _v.visit(field: VTOFFSET.GEOPOTENTIAL_MODEL.p, fieldName: "GEOPOTENTIAL_MODEL", required: false, type: geopotentialModel.self)
    try _v.visit(field: VTOFFSET.LUNAR_SOLAR_PERTURBATION.p, fieldName: "LUNAR_SOLAR_PERTURBATION", required: false, type: perturbationStatus.self)
    try _v.visit(field: VTOFFSET.LUNAR_PERTURBATION_MODEL.p, fieldName: "LUNAR_PERTURBATION_MODEL", required: false, type: lunarPerturbationModel.self)
    try _v.visit(field: VTOFFSET.SOLAR_PERTURBATION_MODEL.p, fieldName: "SOLAR_PERTURBATION_MODEL", required: false, type: solarPerturbationModel.self)
    try _v.visit(field: VTOFFSET.SOLAR_RADIATION_PRESSURE.p, fieldName: "SOLAR_RADIATION_PRESSURE", required: false, type: perturbationStatus.self)
    try _v.visit(field: VTOFFSET.SRP_MODEL.p, fieldName: "SRP_MODEL", required: false, type: solarRadiationPressureModel.self)
    try _v.visit(field: VTOFFSET.RESONANCE_MODEL.p, fieldName: "RESONANCE_MODEL", required: false, type: resonanceModel.self)
    _v.finish()
  }
}

///  Vector Covariance Message
public struct VCM: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case CCSDS_OMM_VERS = 4
    case CREATION_DATE = 6
    case ORIGINATOR = 8
    case OBJECT_NAME = 10
    case OBJECT_ID = 12
    case CENTER_NAME = 14
    case REF_FRAME = 16
    case TIME_SYSTEM = 18
    case STATE_VECTOR = 20
    case KEPLERIAN_ELEMENTS = 22
    case EQUINOCTIAL_ELEMENTS = 24
    case GM = 26
    case ATMOSPHERIC_MODEL_DATA = 28
    case PROPAGATOR_SETTINGS = 30
    case COVARIANCE_MATRIX = 32
    case UVW_SIGMAS = 34
    case MASS = 36
    case SOLAR_RAD_AREA = 38
    case SOLAR_RAD_COEFF = 40
    case DRAG_AREA = 42
    case DRAG_COEFF = 44
    case SRP = 46
    case CLASSIFICATION_TYPE = 48
    case NORAD_CAT_ID = 50
    case ELEMENT_SET_NO = 52
    case REV_AT_EPOCH = 54
    case BSTAR = 56
    case MEAN_MOTION_DOT = 58
    case MEAN_MOTION_DDOT = 60
    case COV_REFERENCE_FRAME = 62
    case CX_X = 64
    case CY_X = 66
    case CZ_X = 68
    case CX_DOT_X = 70
    case USER_DEFINED_BIP_0044_TYPE = 72
    case USER_DEFINED_OBJECT_DESIGNATOR = 74
    case USER_DEFINED_EARTH_MODEL = 76
    case USER_DEFINED_EPOCH_TIMESTAMP = 78
    case USER_DEFINED_MICROSECONDS = 80
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var CCSDS_OMM_VERS: Double { let o = _accessor.offset(VTOFFSET.CCSDS_OMM_VERS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CREATION_DATE: String? { let o = _accessor.offset(VTOFFSET.CREATION_DATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CREATION_DATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CREATION_DATE.v) }
  public var ORIGINATOR: String? { let o = _accessor.offset(VTOFFSET.ORIGINATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var ORIGINATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ORIGINATOR.v) }
  public var OBJECT_NAME: String? { let o = _accessor.offset(VTOFFSET.OBJECT_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_NAME.v) }
  public var OBJECT_ID: String? { let o = _accessor.offset(VTOFFSET.OBJECT_ID.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OBJECT_IDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OBJECT_ID.v) }
  public var CENTER_NAME: String? { let o = _accessor.offset(VTOFFSET.CENTER_NAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CENTER_NAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CENTER_NAME.v) }
  public var REF_FRAME: String? { let o = _accessor.offset(VTOFFSET.REF_FRAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var REF_FRAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.REF_FRAME.v) }
  public var TIME_SYSTEM: String? { let o = _accessor.offset(VTOFFSET.TIME_SYSTEM.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TIME_SYSTEMSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TIME_SYSTEM.v) }
  public var STATE_VECTOR: VCMStateVector? { let o = _accessor.offset(VTOFFSET.STATE_VECTOR.v); return o == 0 ? nil : VCMStateVector(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var KEPLERIAN_ELEMENTS: keplerianElements? { let o = _accessor.offset(VTOFFSET.KEPLERIAN_ELEMENTS.v); return o == 0 ? nil : keplerianElements(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var EQUINOCTIAL_ELEMENTS: equinoctialElements? { let o = _accessor.offset(VTOFFSET.EQUINOCTIAL_ELEMENTS.v); return o == 0 ? nil : equinoctialElements(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var GM: Double { let o = _accessor.offset(VTOFFSET.GM.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var ATMOSPHERIC_MODEL_DATA: VCMAtmosphericModelData? { let o = _accessor.offset(VTOFFSET.ATMOSPHERIC_MODEL_DATA.v); return o == 0 ? nil : VCMAtmosphericModelData(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var PROPAGATOR_SETTINGS: propagatorConfig? { let o = _accessor.offset(VTOFFSET.PROPAGATOR_SETTINGS.v); return o == 0 ? nil : propagatorConfig(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var hasCovarianceMatrix: Bool { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX.v); return o == 0 ? false : true }
  public var COVARIANCE_MATRIXCount: Int32 { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func COVARIANCE_MATRIX(at index: Int32) -> VCMCovarianceMatrixLine? { let o = _accessor.offset(VTOFFSET.COVARIANCE_MATRIX.v); return o == 0 ? nil : VCMCovarianceMatrixLine(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var UVW_SIGMAS: uvwSigmas? { let o = _accessor.offset(VTOFFSET.UVW_SIGMAS.v); return o == 0 ? nil : uvwSigmas(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var MASS: Double { let o = _accessor.offset(VTOFFSET.MASS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var SOLAR_RAD_AREA: Double { let o = _accessor.offset(VTOFFSET.SOLAR_RAD_AREA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var SOLAR_RAD_COEFF: Double { let o = _accessor.offset(VTOFFSET.SOLAR_RAD_COEFF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var DRAG_AREA: Double { let o = _accessor.offset(VTOFFSET.DRAG_AREA.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var DRAG_COEFF: Double { let o = _accessor.offset(VTOFFSET.DRAG_COEFF.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var SRP: perturbationStatus { let o = _accessor.offset(VTOFFSET.SRP.v); return o == 0 ? .off : perturbationStatus(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .off }
  public var CLASSIFICATION_TYPE: String? { let o = _accessor.offset(VTOFFSET.CLASSIFICATION_TYPE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CLASSIFICATION_TYPESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CLASSIFICATION_TYPE.v) }
  public var NORAD_CAT_ID: UInt32 { let o = _accessor.offset(VTOFFSET.NORAD_CAT_ID.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var ELEMENT_SET_NO: UInt32 { let o = _accessor.offset(VTOFFSET.ELEMENT_SET_NO.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var REV_AT_EPOCH: Double { let o = _accessor.offset(VTOFFSET.REV_AT_EPOCH.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var BSTAR: Double { let o = _accessor.offset(VTOFFSET.BSTAR.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MEAN_MOTION_DOT: Double { let o = _accessor.offset(VTOFFSET.MEAN_MOTION_DOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var MEAN_MOTION_DDOT: Double { let o = _accessor.offset(VTOFFSET.MEAN_MOTION_DDOT.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var COV_REFERENCE_FRAME: String? { let o = _accessor.offset(VTOFFSET.COV_REFERENCE_FRAME.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COV_REFERENCE_FRAMESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COV_REFERENCE_FRAME.v) }
  public var CX_X: Double { let o = _accessor.offset(VTOFFSET.CX_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CY_X: Double { let o = _accessor.offset(VTOFFSET.CY_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CZ_X: Double { let o = _accessor.offset(VTOFFSET.CZ_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var CX_DOT_X: Double { let o = _accessor.offset(VTOFFSET.CX_DOT_X.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var USER_DEFINED_BIP_0044_TYPE: UInt32 { let o = _accessor.offset(VTOFFSET.USER_DEFINED_BIP_0044_TYPE.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt32.self, at: o) }
  public var USER_DEFINED_OBJECT_DESIGNATOR: String? { let o = _accessor.offset(VTOFFSET.USER_DEFINED_OBJECT_DESIGNATOR.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var USER_DEFINED_OBJECT_DESIGNATORSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.USER_DEFINED_OBJECT_DESIGNATOR.v) }
  public var USER_DEFINED_EARTH_MODEL: String? { let o = _accessor.offset(VTOFFSET.USER_DEFINED_EARTH_MODEL.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var USER_DEFINED_EARTH_MODELSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.USER_DEFINED_EARTH_MODEL.v) }
  public var USER_DEFINED_EPOCH_TIMESTAMP: Double { let o = _accessor.offset(VTOFFSET.USER_DEFINED_EPOCH_TIMESTAMP.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public var USER_DEFINED_MICROSECONDS: Double { let o = _accessor.offset(VTOFFSET.USER_DEFINED_MICROSECONDS.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Double.self, at: o) }
  public static func startVCM(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 39) }
  public static func add(CCSDS_OMM_VERS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CCSDS_OMM_VERS, def: 0.0, at: VTOFFSET.CCSDS_OMM_VERS.p) }
  public static func add(CREATION_DATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CREATION_DATE, at: VTOFFSET.CREATION_DATE.p) }
  public static func add(ORIGINATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ORIGINATOR, at: VTOFFSET.ORIGINATOR.p) }
  public static func add(OBJECT_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_NAME, at: VTOFFSET.OBJECT_NAME.p) }
  public static func add(OBJECT_ID: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBJECT_ID, at: VTOFFSET.OBJECT_ID.p) }
  public static func add(CENTER_NAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CENTER_NAME, at: VTOFFSET.CENTER_NAME.p) }
  public static func add(REF_FRAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: REF_FRAME, at: VTOFFSET.REF_FRAME.p) }
  public static func add(TIME_SYSTEM: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TIME_SYSTEM, at: VTOFFSET.TIME_SYSTEM.p) }
  public static func add(STATE_VECTOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: STATE_VECTOR, at: VTOFFSET.STATE_VECTOR.p) }
  public static func add(KEPLERIAN_ELEMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: KEPLERIAN_ELEMENTS, at: VTOFFSET.KEPLERIAN_ELEMENTS.p) }
  public static func add(EQUINOCTIAL_ELEMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: EQUINOCTIAL_ELEMENTS, at: VTOFFSET.EQUINOCTIAL_ELEMENTS.p) }
  public static func add(GM: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: GM, def: 0.0, at: VTOFFSET.GM.p) }
  public static func add(ATMOSPHERIC_MODEL_DATA: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ATMOSPHERIC_MODEL_DATA, at: VTOFFSET.ATMOSPHERIC_MODEL_DATA.p) }
  public static func add(PROPAGATOR_SETTINGS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROPAGATOR_SETTINGS, at: VTOFFSET.PROPAGATOR_SETTINGS.p) }
  public static func addVectorOf(COVARIANCE_MATRIX: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COVARIANCE_MATRIX, at: VTOFFSET.COVARIANCE_MATRIX.p) }
  public static func add(UVW_SIGMAS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: UVW_SIGMAS, at: VTOFFSET.UVW_SIGMAS.p) }
  public static func add(MASS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MASS, def: 0.0, at: VTOFFSET.MASS.p) }
  public static func add(SOLAR_RAD_AREA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOLAR_RAD_AREA, def: 0.0, at: VTOFFSET.SOLAR_RAD_AREA.p) }
  public static func add(SOLAR_RAD_COEFF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SOLAR_RAD_COEFF, def: 0.0, at: VTOFFSET.SOLAR_RAD_COEFF.p) }
  public static func add(DRAG_AREA: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRAG_AREA, def: 0.0, at: VTOFFSET.DRAG_AREA.p) }
  public static func add(DRAG_COEFF: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: DRAG_COEFF, def: 0.0, at: VTOFFSET.DRAG_COEFF.p) }
  public static func add(SRP: perturbationStatus, _ fbb: inout FlatBufferBuilder) { fbb.add(element: SRP.rawValue, def: 0, at: VTOFFSET.SRP.p) }
  public static func add(CLASSIFICATION_TYPE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CLASSIFICATION_TYPE, at: VTOFFSET.CLASSIFICATION_TYPE.p) }
  public static func add(NORAD_CAT_ID: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: NORAD_CAT_ID, def: 0, at: VTOFFSET.NORAD_CAT_ID.p) }
  public static func add(ELEMENT_SET_NO: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ELEMENT_SET_NO, def: 0, at: VTOFFSET.ELEMENT_SET_NO.p) }
  public static func add(REV_AT_EPOCH: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: REV_AT_EPOCH, def: 0.0, at: VTOFFSET.REV_AT_EPOCH.p) }
  public static func add(BSTAR: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: BSTAR, def: 0.0, at: VTOFFSET.BSTAR.p) }
  public static func add(MEAN_MOTION_DOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MEAN_MOTION_DOT, def: 0.0, at: VTOFFSET.MEAN_MOTION_DOT.p) }
  public static func add(MEAN_MOTION_DDOT: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: MEAN_MOTION_DDOT, def: 0.0, at: VTOFFSET.MEAN_MOTION_DDOT.p) }
  public static func add(COV_REFERENCE_FRAME: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COV_REFERENCE_FRAME, at: VTOFFSET.COV_REFERENCE_FRAME.p) }
  public static func add(CX_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_X, def: 0.0, at: VTOFFSET.CX_X.p) }
  public static func add(CY_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CY_X, def: 0.0, at: VTOFFSET.CY_X.p) }
  public static func add(CZ_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CZ_X, def: 0.0, at: VTOFFSET.CZ_X.p) }
  public static func add(CX_DOT_X: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: CX_DOT_X, def: 0.0, at: VTOFFSET.CX_DOT_X.p) }
  public static func add(USER_DEFINED_BIP_0044_TYPE: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: USER_DEFINED_BIP_0044_TYPE, def: 0, at: VTOFFSET.USER_DEFINED_BIP_0044_TYPE.p) }
  public static func add(USER_DEFINED_OBJECT_DESIGNATOR: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: USER_DEFINED_OBJECT_DESIGNATOR, at: VTOFFSET.USER_DEFINED_OBJECT_DESIGNATOR.p) }
  public static func add(USER_DEFINED_EARTH_MODEL: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: USER_DEFINED_EARTH_MODEL, at: VTOFFSET.USER_DEFINED_EARTH_MODEL.p) }
  public static func add(USER_DEFINED_EPOCH_TIMESTAMP: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: USER_DEFINED_EPOCH_TIMESTAMP, def: 0.0, at: VTOFFSET.USER_DEFINED_EPOCH_TIMESTAMP.p) }
  public static func add(USER_DEFINED_MICROSECONDS: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: USER_DEFINED_MICROSECONDS, def: 0.0, at: VTOFFSET.USER_DEFINED_MICROSECONDS.p) }
  public static func endVCM(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVCM(
    _ fbb: inout FlatBufferBuilder,
    CCSDS_OMM_VERS: Double = 0.0,
    CREATION_DATEOffset CREATION_DATE: Offset = Offset(),
    ORIGINATOROffset ORIGINATOR: Offset = Offset(),
    OBJECT_NAMEOffset OBJECT_NAME: Offset = Offset(),
    OBJECT_IDOffset OBJECT_ID: Offset = Offset(),
    CENTER_NAMEOffset CENTER_NAME: Offset = Offset(),
    REF_FRAMEOffset REF_FRAME: Offset = Offset(),
    TIME_SYSTEMOffset TIME_SYSTEM: Offset = Offset(),
    STATE_VECTOROffset STATE_VECTOR: Offset = Offset(),
    KEPLERIAN_ELEMENTSOffset KEPLERIAN_ELEMENTS: Offset = Offset(),
    EQUINOCTIAL_ELEMENTSOffset EQUINOCTIAL_ELEMENTS: Offset = Offset(),
    GM: Double = 0.0,
    ATMOSPHERIC_MODEL_DATAOffset ATMOSPHERIC_MODEL_DATA: Offset = Offset(),
    PROPAGATOR_SETTINGSOffset PROPAGATOR_SETTINGS: Offset = Offset(),
    COVARIANCE_MATRIXVectorOffset COVARIANCE_MATRIX: Offset = Offset(),
    UVW_SIGMASOffset UVW_SIGMAS: Offset = Offset(),
    MASS: Double = 0.0,
    SOLAR_RAD_AREA: Double = 0.0,
    SOLAR_RAD_COEFF: Double = 0.0,
    DRAG_AREA: Double = 0.0,
    DRAG_COEFF: Double = 0.0,
    SRP: perturbationStatus = .off,
    CLASSIFICATION_TYPEOffset CLASSIFICATION_TYPE: Offset = Offset(),
    NORAD_CAT_ID: UInt32 = 0,
    ELEMENT_SET_NO: UInt32 = 0,
    REV_AT_EPOCH: Double = 0.0,
    BSTAR: Double = 0.0,
    MEAN_MOTION_DOT: Double = 0.0,
    MEAN_MOTION_DDOT: Double = 0.0,
    COV_REFERENCE_FRAMEOffset COV_REFERENCE_FRAME: Offset = Offset(),
    CX_X: Double = 0.0,
    CY_X: Double = 0.0,
    CZ_X: Double = 0.0,
    CX_DOT_X: Double = 0.0,
    USER_DEFINED_BIP_0044_TYPE: UInt32 = 0,
    USER_DEFINED_OBJECT_DESIGNATOROffset USER_DEFINED_OBJECT_DESIGNATOR: Offset = Offset(),
    USER_DEFINED_EARTH_MODELOffset USER_DEFINED_EARTH_MODEL: Offset = Offset(),
    USER_DEFINED_EPOCH_TIMESTAMP: Double = 0.0,
    USER_DEFINED_MICROSECONDS: Double = 0.0
  ) -> Offset {
    let __start = VCM.startVCM(&fbb)
    VCM.add(CCSDS_OMM_VERS: CCSDS_OMM_VERS, &fbb)
    VCM.add(CREATION_DATE: CREATION_DATE, &fbb)
    VCM.add(ORIGINATOR: ORIGINATOR, &fbb)
    VCM.add(OBJECT_NAME: OBJECT_NAME, &fbb)
    VCM.add(OBJECT_ID: OBJECT_ID, &fbb)
    VCM.add(CENTER_NAME: CENTER_NAME, &fbb)
    VCM.add(REF_FRAME: REF_FRAME, &fbb)
    VCM.add(TIME_SYSTEM: TIME_SYSTEM, &fbb)
    VCM.add(STATE_VECTOR: STATE_VECTOR, &fbb)
    VCM.add(KEPLERIAN_ELEMENTS: KEPLERIAN_ELEMENTS, &fbb)
    VCM.add(EQUINOCTIAL_ELEMENTS: EQUINOCTIAL_ELEMENTS, &fbb)
    VCM.add(GM: GM, &fbb)
    VCM.add(ATMOSPHERIC_MODEL_DATA: ATMOSPHERIC_MODEL_DATA, &fbb)
    VCM.add(PROPAGATOR_SETTINGS: PROPAGATOR_SETTINGS, &fbb)
    VCM.addVectorOf(COVARIANCE_MATRIX: COVARIANCE_MATRIX, &fbb)
    VCM.add(UVW_SIGMAS: UVW_SIGMAS, &fbb)
    VCM.add(MASS: MASS, &fbb)
    VCM.add(SOLAR_RAD_AREA: SOLAR_RAD_AREA, &fbb)
    VCM.add(SOLAR_RAD_COEFF: SOLAR_RAD_COEFF, &fbb)
    VCM.add(DRAG_AREA: DRAG_AREA, &fbb)
    VCM.add(DRAG_COEFF: DRAG_COEFF, &fbb)
    VCM.add(SRP: SRP, &fbb)
    VCM.add(CLASSIFICATION_TYPE: CLASSIFICATION_TYPE, &fbb)
    VCM.add(NORAD_CAT_ID: NORAD_CAT_ID, &fbb)
    VCM.add(ELEMENT_SET_NO: ELEMENT_SET_NO, &fbb)
    VCM.add(REV_AT_EPOCH: REV_AT_EPOCH, &fbb)
    VCM.add(BSTAR: BSTAR, &fbb)
    VCM.add(MEAN_MOTION_DOT: MEAN_MOTION_DOT, &fbb)
    VCM.add(MEAN_MOTION_DDOT: MEAN_MOTION_DDOT, &fbb)
    VCM.add(COV_REFERENCE_FRAME: COV_REFERENCE_FRAME, &fbb)
    VCM.add(CX_X: CX_X, &fbb)
    VCM.add(CY_X: CY_X, &fbb)
    VCM.add(CZ_X: CZ_X, &fbb)
    VCM.add(CX_DOT_X: CX_DOT_X, &fbb)
    VCM.add(USER_DEFINED_BIP_0044_TYPE: USER_DEFINED_BIP_0044_TYPE, &fbb)
    VCM.add(USER_DEFINED_OBJECT_DESIGNATOR: USER_DEFINED_OBJECT_DESIGNATOR, &fbb)
    VCM.add(USER_DEFINED_EARTH_MODEL: USER_DEFINED_EARTH_MODEL, &fbb)
    VCM.add(USER_DEFINED_EPOCH_TIMESTAMP: USER_DEFINED_EPOCH_TIMESTAMP, &fbb)
    VCM.add(USER_DEFINED_MICROSECONDS: USER_DEFINED_MICROSECONDS, &fbb)
    return VCM.endVCM(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.CCSDS_OMM_VERS.p, fieldName: "CCSDS_OMM_VERS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CREATION_DATE.p, fieldName: "CREATION_DATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ORIGINATOR.p, fieldName: "ORIGINATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_NAME.p, fieldName: "OBJECT_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBJECT_ID.p, fieldName: "OBJECT_ID", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CENTER_NAME.p, fieldName: "CENTER_NAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.REF_FRAME.p, fieldName: "REF_FRAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TIME_SYSTEM.p, fieldName: "TIME_SYSTEM", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.STATE_VECTOR.p, fieldName: "STATE_VECTOR", required: false, type: ForwardOffset<VCMStateVector>.self)
    try _v.visit(field: VTOFFSET.KEPLERIAN_ELEMENTS.p, fieldName: "KEPLERIAN_ELEMENTS", required: false, type: ForwardOffset<keplerianElements>.self)
    try _v.visit(field: VTOFFSET.EQUINOCTIAL_ELEMENTS.p, fieldName: "EQUINOCTIAL_ELEMENTS", required: false, type: ForwardOffset<equinoctialElements>.self)
    try _v.visit(field: VTOFFSET.GM.p, fieldName: "GM", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.ATMOSPHERIC_MODEL_DATA.p, fieldName: "ATMOSPHERIC_MODEL_DATA", required: false, type: ForwardOffset<VCMAtmosphericModelData>.self)
    try _v.visit(field: VTOFFSET.PROPAGATOR_SETTINGS.p, fieldName: "PROPAGATOR_SETTINGS", required: false, type: ForwardOffset<propagatorConfig>.self)
    try _v.visit(field: VTOFFSET.COVARIANCE_MATRIX.p, fieldName: "COVARIANCE_MATRIX", required: false, type: ForwardOffset<Vector<ForwardOffset<VCMCovarianceMatrixLine>, VCMCovarianceMatrixLine>>.self)
    try _v.visit(field: VTOFFSET.UVW_SIGMAS.p, fieldName: "UVW_SIGMAS", required: false, type: ForwardOffset<uvwSigmas>.self)
    try _v.visit(field: VTOFFSET.MASS.p, fieldName: "MASS", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SOLAR_RAD_AREA.p, fieldName: "SOLAR_RAD_AREA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SOLAR_RAD_COEFF.p, fieldName: "SOLAR_RAD_COEFF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DRAG_AREA.p, fieldName: "DRAG_AREA", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.DRAG_COEFF.p, fieldName: "DRAG_COEFF", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.SRP.p, fieldName: "SRP", required: false, type: perturbationStatus.self)
    try _v.visit(field: VTOFFSET.CLASSIFICATION_TYPE.p, fieldName: "CLASSIFICATION_TYPE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.NORAD_CAT_ID.p, fieldName: "NORAD_CAT_ID", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.ELEMENT_SET_NO.p, fieldName: "ELEMENT_SET_NO", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.REV_AT_EPOCH.p, fieldName: "REV_AT_EPOCH", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.BSTAR.p, fieldName: "BSTAR", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MEAN_MOTION_DOT.p, fieldName: "MEAN_MOTION_DOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.MEAN_MOTION_DDOT.p, fieldName: "MEAN_MOTION_DDOT", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.COV_REFERENCE_FRAME.p, fieldName: "COV_REFERENCE_FRAME", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CX_X.p, fieldName: "CX_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CY_X.p, fieldName: "CY_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CZ_X.p, fieldName: "CZ_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.CX_DOT_X.p, fieldName: "CX_DOT_X", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_BIP_0044_TYPE.p, fieldName: "USER_DEFINED_BIP_0044_TYPE", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_OBJECT_DESIGNATOR.p, fieldName: "USER_DEFINED_OBJECT_DESIGNATOR", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_EARTH_MODEL.p, fieldName: "USER_DEFINED_EARTH_MODEL", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_EPOCH_TIMESTAMP.p, fieldName: "USER_DEFINED_EPOCH_TIMESTAMP", required: false, type: Double.self)
    try _v.visit(field: VTOFFSET.USER_DEFINED_MICROSECONDS.p, fieldName: "USER_DEFINED_MICROSECONDS", required: false, type: Double.self)
    _v.finish()
  }
}

///  Collection of VCM records
public struct VCM_COLLECTION: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case RECORDS = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasRecords: Bool { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? false : true }
  public var RECORDSCount: Int32 { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func RECORDS(at index: Int32) -> VCM? { let o = _accessor.offset(VTOFFSET.RECORDS.v); return o == 0 ? nil : VCM(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startVCM_COLLECTION(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(RECORDS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: RECORDS, at: VTOFFSET.RECORDS.p) }
  public static func endVCM_COLLECTION(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createVCM_COLLECTION(
    _ fbb: inout FlatBufferBuilder,
    RECORDSVectorOffset RECORDS: Offset = Offset()
  ) -> Offset {
    let __start = VCM_COLLECTION.startVCM_COLLECTION(&fbb)
    VCM_COLLECTION.addVectorOf(RECORDS: RECORDS, &fbb)
    return VCM_COLLECTION.endVCM_COLLECTION(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.RECORDS.p, fieldName: "RECORDS", required: false, type: ForwardOffset<Vector<ForwardOffset<VCM>, VCM>>.self)
    _v.finish()
  }
}

