// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum PropagatorMethod: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case kepler = 0
  case sgp4 = 1
  case sdp4 = 2
  case hpop = 3
  case cowell = 4
  case encke = 5
  case gaussJackson = 6
  case rk78 = 7
  case brouwer = 8
  case kozai = 9
  case dsst = 10

  public static var max: PropagatorMethod { return .dsst }
  public static var min: PropagatorMethod { return .kepler }
}


public enum ForceModel: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case pointMass = 0
  case j2 = 1
  case j2J4 = 2
  case sphericalHarmonics = 3
  case thirdBodySun = 4
  case thirdBodyMoon = 5
  case atmosphericDrag = 6
  case solarRadiationPressure = 7
  case relativistic = 8
  case solidTides = 9
  case oceanTides = 10
  case maneuver = 11

  public static var max: ForceModel { return .maneuver }
  public static var min: ForceModel { return .pointMass }
}


public enum OrbitalRegime: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case leo = 0
  case meo = 1
  case geo = 2
  case heo = 3
  case sso = 4
  case molniya = 5
  case tundra = 6
  case polar = 7
  case equatorial = 8
  case hyperbolic = 9
  case parabolic = 10

  public static var max: OrbitalRegime { return .parabolic }
  public static var min: OrbitalRegime { return .leo }
}


public enum TimeReference: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case utc = 0
  case tai = 1
  case tt = 2
  case tdb = 3
  case gpsTime = 4
  case julianDate = 5
  case modifiedJulianDate = 6

  public static var max: TimeReference { return .modifiedJulianDate }
  public static var min: TimeReference { return .utc }
}


public enum ReferenceFrame: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case eciJ2000 = 0
  case ecef = 1
  case teme = 2
  case gcrf = 3
  case itrf = 4
  case ric = 5
  case vnc = 6
  case ntw = 7
  case sez = 8
  case lvlh = 9

  public static var max: ReferenceFrame { return .lvlh }
  public static var min: ReferenceFrame { return .eciJ2000 }
}


///  Astrodynamics
public struct AST: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "$AST" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: AST.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case COMMAND = 4
    case PROPAGATION_REQUEST = 6
    case TLE = 8
    case INITIAL_ELEMENTS = 10
    case INITIAL_STATE = 12
    case EPOCH_MS = 14
    case MANEUVER_PLAN = 16
    case CONJUNCTION_PRIMARY = 18
    case CONJUNCTION_SECONDARY = 20
    case OBSERVATIONS = 22
    case OD_CONFIG = 24
    case GROUND_STATION = 26
    case FORMATION_CONFIG = 28
    case TARGET_ELEMENTS = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var COMMAND: String? { let o = _accessor.offset(VTOFFSET.COMMAND.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var COMMANDSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.COMMAND.v) }
  public var PROPAGATION_REQUEST: String? { let o = _accessor.offset(VTOFFSET.PROPAGATION_REQUEST.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var PROPAGATION_REQUESTSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.PROPAGATION_REQUEST.v) }
  public var TLE: String? { let o = _accessor.offset(VTOFFSET.TLE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TLESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TLE.v) }
  public var INITIAL_ELEMENTS: String? { let o = _accessor.offset(VTOFFSET.INITIAL_ELEMENTS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_ELEMENTSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_ELEMENTS.v) }
  public var INITIAL_STATE: String? { let o = _accessor.offset(VTOFFSET.INITIAL_STATE.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var INITIAL_STATESegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.INITIAL_STATE.v) }
  public var EPOCH_MS: Int64 { let o = _accessor.offset(VTOFFSET.EPOCH_MS.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var MANEUVER_PLAN: String? { let o = _accessor.offset(VTOFFSET.MANEUVER_PLAN.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var MANEUVER_PLANSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.MANEUVER_PLAN.v) }
  public var CONJUNCTION_PRIMARY: String? { let o = _accessor.offset(VTOFFSET.CONJUNCTION_PRIMARY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONJUNCTION_PRIMARYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONJUNCTION_PRIMARY.v) }
  public var CONJUNCTION_SECONDARY: String? { let o = _accessor.offset(VTOFFSET.CONJUNCTION_SECONDARY.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var CONJUNCTION_SECONDARYSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.CONJUNCTION_SECONDARY.v) }
  public var hasObservations: Bool { let o = _accessor.offset(VTOFFSET.OBSERVATIONS.v); return o == 0 ? false : true }
  public var OBSERVATIONSCount: Int32 { let o = _accessor.offset(VTOFFSET.OBSERVATIONS.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func OBSERVATIONS(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.OBSERVATIONS.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var OD_CONFIG: String? { let o = _accessor.offset(VTOFFSET.OD_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var OD_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.OD_CONFIG.v) }
  public var GROUND_STATION: String? { let o = _accessor.offset(VTOFFSET.GROUND_STATION.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var GROUND_STATIONSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.GROUND_STATION.v) }
  public var FORMATION_CONFIG: String? { let o = _accessor.offset(VTOFFSET.FORMATION_CONFIG.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var FORMATION_CONFIGSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.FORMATION_CONFIG.v) }
  public var TARGET_ELEMENTS: String? { let o = _accessor.offset(VTOFFSET.TARGET_ELEMENTS.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var TARGET_ELEMENTSSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.TARGET_ELEMENTS.v) }
  public static func startAST(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(COMMAND: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: COMMAND, at: VTOFFSET.COMMAND.p) }
  public static func add(PROPAGATION_REQUEST: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: PROPAGATION_REQUEST, at: VTOFFSET.PROPAGATION_REQUEST.p) }
  public static func add(TLE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TLE, at: VTOFFSET.TLE.p) }
  public static func add(INITIAL_ELEMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_ELEMENTS, at: VTOFFSET.INITIAL_ELEMENTS.p) }
  public static func add(INITIAL_STATE: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: INITIAL_STATE, at: VTOFFSET.INITIAL_STATE.p) }
  public static func add(EPOCH_MS: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: EPOCH_MS, def: 0, at: VTOFFSET.EPOCH_MS.p) }
  public static func add(MANEUVER_PLAN: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: MANEUVER_PLAN, at: VTOFFSET.MANEUVER_PLAN.p) }
  public static func add(CONJUNCTION_PRIMARY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONJUNCTION_PRIMARY, at: VTOFFSET.CONJUNCTION_PRIMARY.p) }
  public static func add(CONJUNCTION_SECONDARY: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: CONJUNCTION_SECONDARY, at: VTOFFSET.CONJUNCTION_SECONDARY.p) }
  public static func addVectorOf(OBSERVATIONS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OBSERVATIONS, at: VTOFFSET.OBSERVATIONS.p) }
  public static func add(OD_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: OD_CONFIG, at: VTOFFSET.OD_CONFIG.p) }
  public static func add(GROUND_STATION: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: GROUND_STATION, at: VTOFFSET.GROUND_STATION.p) }
  public static func add(FORMATION_CONFIG: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: FORMATION_CONFIG, at: VTOFFSET.FORMATION_CONFIG.p) }
  public static func add(TARGET_ELEMENTS: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: TARGET_ELEMENTS, at: VTOFFSET.TARGET_ELEMENTS.p) }
  public static func endAST(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAST(
    _ fbb: inout FlatBufferBuilder,
    COMMANDOffset COMMAND: Offset = Offset(),
    PROPAGATION_REQUESTOffset PROPAGATION_REQUEST: Offset = Offset(),
    TLEOffset TLE: Offset = Offset(),
    INITIAL_ELEMENTSOffset INITIAL_ELEMENTS: Offset = Offset(),
    INITIAL_STATEOffset INITIAL_STATE: Offset = Offset(),
    EPOCH_MS: Int64 = 0,
    MANEUVER_PLANOffset MANEUVER_PLAN: Offset = Offset(),
    CONJUNCTION_PRIMARYOffset CONJUNCTION_PRIMARY: Offset = Offset(),
    CONJUNCTION_SECONDARYOffset CONJUNCTION_SECONDARY: Offset = Offset(),
    OBSERVATIONSVectorOffset OBSERVATIONS: Offset = Offset(),
    OD_CONFIGOffset OD_CONFIG: Offset = Offset(),
    GROUND_STATIONOffset GROUND_STATION: Offset = Offset(),
    FORMATION_CONFIGOffset FORMATION_CONFIG: Offset = Offset(),
    TARGET_ELEMENTSOffset TARGET_ELEMENTS: Offset = Offset()
  ) -> Offset {
    let __start = AST.startAST(&fbb)
    AST.add(COMMAND: COMMAND, &fbb)
    AST.add(PROPAGATION_REQUEST: PROPAGATION_REQUEST, &fbb)
    AST.add(TLE: TLE, &fbb)
    AST.add(INITIAL_ELEMENTS: INITIAL_ELEMENTS, &fbb)
    AST.add(INITIAL_STATE: INITIAL_STATE, &fbb)
    AST.add(EPOCH_MS: EPOCH_MS, &fbb)
    AST.add(MANEUVER_PLAN: MANEUVER_PLAN, &fbb)
    AST.add(CONJUNCTION_PRIMARY: CONJUNCTION_PRIMARY, &fbb)
    AST.add(CONJUNCTION_SECONDARY: CONJUNCTION_SECONDARY, &fbb)
    AST.addVectorOf(OBSERVATIONS: OBSERVATIONS, &fbb)
    AST.add(OD_CONFIG: OD_CONFIG, &fbb)
    AST.add(GROUND_STATION: GROUND_STATION, &fbb)
    AST.add(FORMATION_CONFIG: FORMATION_CONFIG, &fbb)
    AST.add(TARGET_ELEMENTS: TARGET_ELEMENTS, &fbb)
    return AST.endAST(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.COMMAND.p, fieldName: "COMMAND", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.PROPAGATION_REQUEST.p, fieldName: "PROPAGATION_REQUEST", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TLE.p, fieldName: "TLE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_ELEMENTS.p, fieldName: "INITIAL_ELEMENTS", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.INITIAL_STATE.p, fieldName: "INITIAL_STATE", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.EPOCH_MS.p, fieldName: "EPOCH_MS", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.MANEUVER_PLAN.p, fieldName: "MANEUVER_PLAN", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONJUNCTION_PRIMARY.p, fieldName: "CONJUNCTION_PRIMARY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.CONJUNCTION_SECONDARY.p, fieldName: "CONJUNCTION_SECONDARY", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.OBSERVATIONS.p, fieldName: "OBSERVATIONS", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.OD_CONFIG.p, fieldName: "OD_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.GROUND_STATION.p, fieldName: "GROUND_STATION", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.FORMATION_CONFIG.p, fieldName: "FORMATION_CONFIG", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.TARGET_ELEMENTS.p, fieldName: "TARGET_ELEMENTS", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

