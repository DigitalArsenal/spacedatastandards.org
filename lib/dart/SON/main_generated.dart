// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class SonarType {
  final int value;
  const SonarType._(this.value);

  factory SonarType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SonarType');
    }
    return result;
  }

  static SonarType? _createOrNull(int? value) => 
      value == null ? null : SonarType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 10;
  static bool containsValue(int value) => values.containsKey(value);

  static const SonarType ACTIVE_HULL = SonarType._(0);
  static const SonarType ACTIVE_VDS = SonarType._(1);
  static const SonarType ACTIVE_DIPPING = SonarType._(2);
  static const SonarType PASSIVE_HULL = SonarType._(3);
  static const SonarType PASSIVE_TOWED = SonarType._(4);
  static const SonarType PASSIVE_SONOBUOY = SonarType._(5);
  static const SonarType MINE_HUNTING = SonarType._(6);
  static const SonarType SIDESCAN = SonarType._(7);
  static const SonarType BOTTOM_PROFILER = SonarType._(8);
  static const SonarType INTERCEPT = SonarType._(9);
  static const SonarType TORPEDO = SonarType._(10);
  static const Map<int, SonarType> values = {
    0: ACTIVE_HULL,
    1: ACTIVE_VDS,
    2: ACTIVE_DIPPING,
    3: PASSIVE_HULL,
    4: PASSIVE_TOWED,
    5: PASSIVE_SONOBUOY,
    6: MINE_HUNTING,
    7: SIDESCAN,
    8: BOTTOM_PROFILER,
    9: INTERCEPT,
    10: TORPEDO};

  static const fb.Reader<SonarType> reader = _SonarTypeReader();

  @override
  String toString() {
    return 'SonarType{value: $value}';
  }
}

class _SonarTypeReader extends fb.Reader<SonarType> {
  const _SonarTypeReader();

  @override
  int get size => 1;

  @override
  SonarType read(fb.BufferContext bc, int offset) =>
      SonarType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class SonpropagationModel {
  final int value;
  const SonpropagationModel._(this.value);

  factory SonpropagationModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SonpropagationModel');
    }
    return result;
  }

  static SonpropagationModel? _createOrNull(int? value) => 
      value == null ? null : SonpropagationModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  static const SonpropagationModel RAY_TRACING = SonpropagationModel._(0);
  static const SonpropagationModel PARABOLIC_EQUATION = SonpropagationModel._(1);
  static const SonpropagationModel NORMAL_MODES = SonpropagationModel._(2);
  static const SonpropagationModel ISOVELOCITY = SonpropagationModel._(3);
  static const SonpropagationModel RANGE_DEPENDENT = SonpropagationModel._(4);
  static const SonpropagationModel FAST_FIELD = SonpropagationModel._(5);
  static const Map<int, SonpropagationModel> values = {
    0: RAY_TRACING,
    1: PARABOLIC_EQUATION,
    2: NORMAL_MODES,
    3: ISOVELOCITY,
    4: RANGE_DEPENDENT,
    5: FAST_FIELD};

  static const fb.Reader<SonpropagationModel> reader = _SonpropagationModelReader();

  @override
  String toString() {
    return 'SonpropagationModel{value: $value}';
  }
}

class _SonpropagationModelReader extends fb.Reader<SonpropagationModel> {
  const _SonpropagationModelReader();

  @override
  int get size => 1;

  @override
  SonpropagationModel read(fb.BufferContext bc, int offset) =>
      SonpropagationModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

class BottomType {
  final int value;
  const BottomType._(this.value);

  factory BottomType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum BottomType');
    }
    return result;
  }

  static BottomType? _createOrNull(int? value) => 
      value == null ? null : BottomType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 8;
  static bool containsValue(int value) => values.containsKey(value);

  static const BottomType HARD_ROCK = BottomType._(0);
  static const BottomType SOFT_ROCK = BottomType._(1);
  static const BottomType SAND = BottomType._(2);
  static const BottomType SILT = BottomType._(3);
  static const BottomType CLAY = BottomType._(4);
  static const BottomType MUD = BottomType._(5);
  static const BottomType GRAVEL = BottomType._(6);
  static const BottomType CORAL = BottomType._(7);
  static const BottomType MIXED = BottomType._(8);
  static const Map<int, BottomType> values = {
    0: HARD_ROCK,
    1: SOFT_ROCK,
    2: SAND,
    3: SILT,
    4: CLAY,
    5: MUD,
    6: GRAVEL,
    7: CORAL,
    8: MIXED};

  static const fb.Reader<BottomType> reader = _BottomTypeReader();

  @override
  String toString() {
    return 'BottomType{value: $value}';
  }
}

class _BottomTypeReader extends fb.Reader<BottomType> {
  const _BottomTypeReader();

  @override
  int get size => 1;

  @override
  BottomType read(fb.BufferContext bc, int offset) =>
      BottomType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class SeaState {
  final int value;
  const SeaState._(this.value);

  factory SeaState.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SeaState');
    }
    return result;
  }

  static SeaState? _createOrNull(int? value) => 
      value == null ? null : SeaState.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 9;
  static bool containsValue(int value) => values.containsKey(value);

  static const SeaState SS0 = SeaState._(0);
  static const SeaState SS1 = SeaState._(1);
  static const SeaState SS2 = SeaState._(2);
  static const SeaState SS3 = SeaState._(3);
  static const SeaState SS4 = SeaState._(4);
  static const SeaState SS5 = SeaState._(5);
  static const SeaState SS6 = SeaState._(6);
  static const SeaState SS7 = SeaState._(7);
  static const SeaState SS8 = SeaState._(8);
  static const SeaState SS9 = SeaState._(9);
  static const Map<int, SeaState> values = {
    0: SS0,
    1: SS1,
    2: SS2,
    3: SS3,
    4: SS4,
    5: SS5,
    6: SS6,
    7: SS7,
    8: SS8,
    9: SS9};

  static const fb.Reader<SeaState> reader = _SeaStateReader();

  @override
  String toString() {
    return 'SeaState{value: $value}';
  }
}

class _SeaStateReader extends fb.Reader<SeaState> {
  const _SeaStateReader();

  @override
  int get size => 1;

  @override
  SeaState read(fb.BufferContext bc, int offset) =>
      SeaState.fromValue(const fb.Int8Reader().read(bc, offset));
}

class NoiseSource {
  final int value;
  const NoiseSource._(this.value);

  factory NoiseSource.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum NoiseSource');
    }
    return result;
  }

  static NoiseSource? _createOrNull(int? value) => 
      value == null ? null : NoiseSource.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 9;
  static bool containsValue(int value) => values.containsKey(value);

  static const NoiseSource AMBIENT = NoiseSource._(0);
  static const NoiseSource SHIPPING = NoiseSource._(1);
  static const NoiseSource BIOLOGICAL = NoiseSource._(2);
  static const NoiseSource WIND = NoiseSource._(3);
  static const NoiseSource RAIN = NoiseSource._(4);
  static const NoiseSource ICE = NoiseSource._(5);
  static const NoiseSource SEISMIC = NoiseSource._(6);
  static const NoiseSource MACHINERY = NoiseSource._(7);
  static const NoiseSource FLOW = NoiseSource._(8);
  static const NoiseSource SELF_NOISE = NoiseSource._(9);
  static const Map<int, NoiseSource> values = {
    0: AMBIENT,
    1: SHIPPING,
    2: BIOLOGICAL,
    3: WIND,
    4: RAIN,
    5: ICE,
    6: SEISMIC,
    7: MACHINERY,
    8: FLOW,
    9: SELF_NOISE};

  static const fb.Reader<NoiseSource> reader = _NoiseSourceReader();

  @override
  String toString() {
    return 'NoiseSource{value: $value}';
  }
}

class _NoiseSourceReader extends fb.Reader<NoiseSource> {
  const _NoiseSourceReader();

  @override
  int get size => 1;

  @override
  NoiseSource read(fb.BufferContext bc, int offset) =>
      NoiseSource.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TargetType {
  final int value;
  const TargetType._(this.value);

  factory TargetType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TargetType');
    }
    return result;
  }

  static TargetType? _createOrNull(int? value) => 
      value == null ? null : TargetType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 6;
  static bool containsValue(int value) => values.containsKey(value);

  static const TargetType SUBMARINE = TargetType._(0);
  static const TargetType SURFACE_SHIP = TargetType._(1);
  static const TargetType TORPEDO = TargetType._(2);
  static const TargetType MINE = TargetType._(3);
  static const TargetType BIOLOGICAL = TargetType._(4);
  static const TargetType WRECK = TargetType._(5);
  static const TargetType UNKNOWN = TargetType._(6);
  static const Map<int, TargetType> values = {
    0: SUBMARINE,
    1: SURFACE_SHIP,
    2: TORPEDO,
    3: MINE,
    4: BIOLOGICAL,
    5: WRECK,
    6: UNKNOWN};

  static const fb.Reader<TargetType> reader = _TargetTypeReader();

  @override
  String toString() {
    return 'TargetType{value: $value}';
  }
}

class _TargetTypeReader extends fb.Reader<TargetType> {
  const _TargetTypeReader();

  @override
  int get size => 1;

  @override
  TargetType read(fb.BufferContext bc, int offset) =>
      TargetType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TorpedoGuidanceMode {
  final int value;
  const TorpedoGuidanceMode._(this.value);

  factory TorpedoGuidanceMode.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TorpedoGuidanceMode');
    }
    return result;
  }

  static TorpedoGuidanceMode? _createOrNull(int? value) => 
      value == null ? null : TorpedoGuidanceMode.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 6;
  static bool containsValue(int value) => values.containsKey(value);

  static const TorpedoGuidanceMode WIRE_GUIDED = TorpedoGuidanceMode._(0);
  static const TorpedoGuidanceMode ACTIVE_HOMING = TorpedoGuidanceMode._(1);
  static const TorpedoGuidanceMode PASSIVE_HOMING = TorpedoGuidanceMode._(2);
  static const TorpedoGuidanceMode WAKE_HOMING = TorpedoGuidanceMode._(3);
  static const TorpedoGuidanceMode PATTERN_SEARCH = TorpedoGuidanceMode._(4);
  static const TorpedoGuidanceMode SNAKE_SEARCH = TorpedoGuidanceMode._(5);
  static const TorpedoGuidanceMode CEILING_BOUNCE = TorpedoGuidanceMode._(6);
  static const Map<int, TorpedoGuidanceMode> values = {
    0: WIRE_GUIDED,
    1: ACTIVE_HOMING,
    2: PASSIVE_HOMING,
    3: WAKE_HOMING,
    4: PATTERN_SEARCH,
    5: SNAKE_SEARCH,
    6: CEILING_BOUNCE};

  static const fb.Reader<TorpedoGuidanceMode> reader = _TorpedoGuidanceModeReader();

  @override
  String toString() {
    return 'TorpedoGuidanceMode{value: $value}';
  }
}

class _TorpedoGuidanceModeReader extends fb.Reader<TorpedoGuidanceMode> {
  const _TorpedoGuidanceModeReader();

  @override
  int get size => 1;

  @override
  TorpedoGuidanceMode read(fb.BufferContext bc, int offset) =>
      TorpedoGuidanceMode.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Sonar and Underwater Acoustics
class SON {
  SON._(this._bc, this._bcOffset);
  factory SON(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SON> reader = _SONReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get COMMAND => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get ACTIVE_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  String? get PASSIVE_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  String? get TL_REQUEST => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
  String? get ENVIRONMENT => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get TARGET_SIGNATURE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  String? get TMA_INPUT => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 16);
  String? get TORPEDO_SEEKER => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);

  @override
  String toString() {
    return 'SON{COMMAND: ${COMMAND}, ACTIVE_CONFIG: ${ACTIVE_CONFIG}, PASSIVE_CONFIG: ${PASSIVE_CONFIG}, TL_REQUEST: ${TL_REQUEST}, ENVIRONMENT: ${ENVIRONMENT}, TARGET_SIGNATURE: ${TARGET_SIGNATURE}, TMA_INPUT: ${TMA_INPUT}, TORPEDO_SEEKER: ${TORPEDO_SEEKER}}';
  }
}

class _SONReader extends fb.TableReader<SON> {
  const _SONReader();

  @override
  SON createObject(fb.BufferContext bc, int offset) => 
    SON._(bc, offset);
}

class SONBuilder {
  SONBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(8);
  }

  int addCommandOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addActiveConfigOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addPassiveConfigOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addTlRequestOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addEnvironmentOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addTargetSignatureOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addTmaInputOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addTorpedoSeekerOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SONObjectBuilder extends fb.ObjectBuilder {
  final String? _COMMAND;
  final String? _ACTIVE_CONFIG;
  final String? _PASSIVE_CONFIG;
  final String? _TL_REQUEST;
  final String? _ENVIRONMENT;
  final String? _TARGET_SIGNATURE;
  final String? _TMA_INPUT;
  final String? _TORPEDO_SEEKER;

  SONObjectBuilder({
    String? COMMAND,
    String? ACTIVE_CONFIG,
    String? PASSIVE_CONFIG,
    String? TL_REQUEST,
    String? ENVIRONMENT,
    String? TARGET_SIGNATURE,
    String? TMA_INPUT,
    String? TORPEDO_SEEKER,
  })
      : _COMMAND = COMMAND,
        _ACTIVE_CONFIG = ACTIVE_CONFIG,
        _PASSIVE_CONFIG = PASSIVE_CONFIG,
        _TL_REQUEST = TL_REQUEST,
        _ENVIRONMENT = ENVIRONMENT,
        _TARGET_SIGNATURE = TARGET_SIGNATURE,
        _TMA_INPUT = TMA_INPUT,
        _TORPEDO_SEEKER = TORPEDO_SEEKER;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? COMMANDOffset = _COMMAND == null ? null
        : fbBuilder.writeString(_COMMAND!);
    final int? ACTIVE_CONFIGOffset = _ACTIVE_CONFIG == null ? null
        : fbBuilder.writeString(_ACTIVE_CONFIG!);
    final int? PASSIVE_CONFIGOffset = _PASSIVE_CONFIG == null ? null
        : fbBuilder.writeString(_PASSIVE_CONFIG!);
    final int? TL_REQUESTOffset = _TL_REQUEST == null ? null
        : fbBuilder.writeString(_TL_REQUEST!);
    final int? ENVIRONMENTOffset = _ENVIRONMENT == null ? null
        : fbBuilder.writeString(_ENVIRONMENT!);
    final int? TARGET_SIGNATUREOffset = _TARGET_SIGNATURE == null ? null
        : fbBuilder.writeString(_TARGET_SIGNATURE!);
    final int? TMA_INPUTOffset = _TMA_INPUT == null ? null
        : fbBuilder.writeString(_TMA_INPUT!);
    final int? TORPEDO_SEEKEROffset = _TORPEDO_SEEKER == null ? null
        : fbBuilder.writeString(_TORPEDO_SEEKER!);
    fbBuilder.startTable(8);
    fbBuilder.addOffset(0, COMMANDOffset);
    fbBuilder.addOffset(1, ACTIVE_CONFIGOffset);
    fbBuilder.addOffset(2, PASSIVE_CONFIGOffset);
    fbBuilder.addOffset(3, TL_REQUESTOffset);
    fbBuilder.addOffset(4, ENVIRONMENTOffset);
    fbBuilder.addOffset(5, TARGET_SIGNATUREOffset);
    fbBuilder.addOffset(6, TMA_INPUTOffset);
    fbBuilder.addOffset(7, TORPEDO_SEEKEROffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
