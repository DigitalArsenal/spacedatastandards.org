// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class Fcsmode {
  final int value;
  const Fcsmode._(this.value);

  factory Fcsmode.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum Fcsmode');
    }
    return result;
  }

  static Fcsmode? _createOrNull(int? value) => 
      value == null ? null : Fcsmode.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 7;
  static bool containsValue(int value) => values.containsKey(value);

  static const Fcsmode OFF = Fcsmode._(0);
  static const Fcsmode STANDBY = Fcsmode._(1);
  static const Fcsmode RANGING = Fcsmode._(2);
  static const Fcsmode TRACKING = Fcsmode._(3);
  static const Fcsmode SOLUTION = Fcsmode._(4);
  static const Fcsmode CCIP = Fcsmode._(5);
  static const Fcsmode CCRP = Fcsmode._(6);
  static const Fcsmode MANUAL = Fcsmode._(7);
  static const Map<int, Fcsmode> values = {
    0: OFF,
    1: STANDBY,
    2: RANGING,
    3: TRACKING,
    4: SOLUTION,
    5: CCIP,
    6: CCRP,
    7: MANUAL};

  static const fb.Reader<Fcsmode> reader = _FcsmodeReader();

  @override
  String toString() {
    return 'Fcsmode{value: $value}';
  }
}

class _FcsmodeReader extends fb.Reader<Fcsmode> {
  const _FcsmodeReader();

  @override
  int get size => 1;

  @override
  Fcsmode read(fb.BufferContext bc, int offset) =>
      Fcsmode.fromValue(const fb.Int8Reader().read(bc, offset));
}

class LeadMethod {
  final int value;
  const LeadMethod._(this.value);

  factory LeadMethod.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum LeadMethod');
    }
    return result;
  }

  static LeadMethod? _createOrNull(int? value) => 
      value == null ? null : LeadMethod.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const LeadMethod NONE = LeadMethod._(0);
  static const LeadMethod PREDICTIVE = LeadMethod._(1);
  static const LeadMethod COLLISION = LeadMethod._(2);
  static const LeadMethod CONSTANT_BEARING = LeadMethod._(3);
  static const LeadMethod PURSUIT = LeadMethod._(4);
  static const Map<int, LeadMethod> values = {
    0: NONE,
    1: PREDICTIVE,
    2: COLLISION,
    3: CONSTANT_BEARING,
    4: PURSUIT};

  static const fb.Reader<LeadMethod> reader = _LeadMethodReader();

  @override
  String toString() {
    return 'LeadMethod{value: $value}';
  }
}

class _LeadMethodReader extends fb.Reader<LeadMethod> {
  const _LeadMethodReader();

  @override
  int get size => 1;

  @override
  LeadMethod read(fb.BufferContext bc, int offset) =>
      LeadMethod.fromValue(const fb.Int8Reader().read(bc, offset));
}

class RangefinderType {
  final int value;
  const RangefinderType._(this.value);

  factory RangefinderType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum RangefinderType');
    }
    return result;
  }

  static RangefinderType? _createOrNull(int? value) => 
      value == null ? null : RangefinderType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const RangefinderType STADIAMETRIC = RangefinderType._(0);
  static const RangefinderType STEREOSCOPIC = RangefinderType._(1);
  static const RangefinderType COINCIDENCE = RangefinderType._(2);
  static const RangefinderType LASER = RangefinderType._(3);
  static const RangefinderType RADAR = RangefinderType._(4);
  static const Map<int, RangefinderType> values = {
    0: STADIAMETRIC,
    1: STEREOSCOPIC,
    2: COINCIDENCE,
    3: LASER,
    4: RADAR};

  static const fb.Reader<RangefinderType> reader = _RangefinderTypeReader();

  @override
  String toString() {
    return 'RangefinderType{value: $value}';
  }
}

class _RangefinderTypeReader extends fb.Reader<RangefinderType> {
  const _RangefinderTypeReader();

  @override
  int get size => 1;

  @override
  RangefinderType read(fb.BufferContext bc, int offset) =>
      RangefinderType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Fire Control Systems
class FCS {
  FCS._(this._bc, this._bcOffset);
  factory FCS(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<FCS> reader = _FCSReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get MODE => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 0);
  int get LEAD_METHOD => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 6, 0);
  int get RANGEFINDER_TYPE => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 8, 0);
  int get AMMO_SELECTED => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 10, 0);
  String? get TARGET => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get SOLUTION => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  double get LAST_RANGE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  double get RANGE_RATE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  int get ROUNDS_REMAINING => const fb.Uint16Reader().vTableGet(_bc, _bcOffset, 20, 0);
  double get TEMPERATURE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  List<int>? get RESERVED => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 24);

  @override
  String toString() {
    return 'FCS{MODE: ${MODE}, LEAD_METHOD: ${LEAD_METHOD}, RANGEFINDER_TYPE: ${RANGEFINDER_TYPE}, AMMO_SELECTED: ${AMMO_SELECTED}, TARGET: ${TARGET}, SOLUTION: ${SOLUTION}, LAST_RANGE: ${LAST_RANGE}, RANGE_RATE: ${RANGE_RATE}, ROUNDS_REMAINING: ${ROUNDS_REMAINING}, TEMPERATURE: ${TEMPERATURE}, RESERVED: ${RESERVED}}';
  }
}

class _FCSReader extends fb.TableReader<FCS> {
  const _FCSReader();

  @override
  FCS createObject(fb.BufferContext bc, int offset) => 
    FCS._(bc, offset);
}

class FCSBuilder {
  FCSBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(11);
  }

  int addMode(int? MODE) {
    fbBuilder.addUint8(0, MODE);
    return fbBuilder.offset;
  }
  int addLeadMethod(int? LEAD_METHOD) {
    fbBuilder.addUint8(1, LEAD_METHOD);
    return fbBuilder.offset;
  }
  int addRangefinderType(int? RANGEFINDER_TYPE) {
    fbBuilder.addUint8(2, RANGEFINDER_TYPE);
    return fbBuilder.offset;
  }
  int addAmmoSelected(int? AMMO_SELECTED) {
    fbBuilder.addUint8(3, AMMO_SELECTED);
    return fbBuilder.offset;
  }
  int addTargetOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addSolutionOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addLastRange(double? LAST_RANGE) {
    fbBuilder.addFloat64(6, LAST_RANGE);
    return fbBuilder.offset;
  }
  int addRangeRate(double? RANGE_RATE) {
    fbBuilder.addFloat64(7, RANGE_RATE);
    return fbBuilder.offset;
  }
  int addRoundsRemaining(int? ROUNDS_REMAINING) {
    fbBuilder.addUint16(8, ROUNDS_REMAINING);
    return fbBuilder.offset;
  }
  int addTemperature(double? TEMPERATURE) {
    fbBuilder.addFloat32(9, TEMPERATURE);
    return fbBuilder.offset;
  }
  int addReservedOffset(int? offset) {
    fbBuilder.addOffset(10, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FCSObjectBuilder extends fb.ObjectBuilder {
  final int? _MODE;
  final int? _LEAD_METHOD;
  final int? _RANGEFINDER_TYPE;
  final int? _AMMO_SELECTED;
  final String? _TARGET;
  final String? _SOLUTION;
  final double? _LAST_RANGE;
  final double? _RANGE_RATE;
  final int? _ROUNDS_REMAINING;
  final double? _TEMPERATURE;
  final List<int>? _RESERVED;

  FCSObjectBuilder({
    int? MODE,
    int? LEAD_METHOD,
    int? RANGEFINDER_TYPE,
    int? AMMO_SELECTED,
    String? TARGET,
    String? SOLUTION,
    double? LAST_RANGE,
    double? RANGE_RATE,
    int? ROUNDS_REMAINING,
    double? TEMPERATURE,
    List<int>? RESERVED,
  })
      : _MODE = MODE,
        _LEAD_METHOD = LEAD_METHOD,
        _RANGEFINDER_TYPE = RANGEFINDER_TYPE,
        _AMMO_SELECTED = AMMO_SELECTED,
        _TARGET = TARGET,
        _SOLUTION = SOLUTION,
        _LAST_RANGE = LAST_RANGE,
        _RANGE_RATE = RANGE_RATE,
        _ROUNDS_REMAINING = ROUNDS_REMAINING,
        _TEMPERATURE = TEMPERATURE,
        _RESERVED = RESERVED;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? TARGETOffset = _TARGET == null ? null
        : fbBuilder.writeString(_TARGET!);
    final int? SOLUTIONOffset = _SOLUTION == null ? null
        : fbBuilder.writeString(_SOLUTION!);
    final int? RESERVEDOffset = _RESERVED == null ? null
        : fbBuilder.writeListUint8(_RESERVED!);
    fbBuilder.startTable(11);
    fbBuilder.addUint8(0, _MODE);
    fbBuilder.addUint8(1, _LEAD_METHOD);
    fbBuilder.addUint8(2, _RANGEFINDER_TYPE);
    fbBuilder.addUint8(3, _AMMO_SELECTED);
    fbBuilder.addOffset(4, TARGETOffset);
    fbBuilder.addOffset(5, SOLUTIONOffset);
    fbBuilder.addFloat64(6, _LAST_RANGE);
    fbBuilder.addFloat64(7, _RANGE_RATE);
    fbBuilder.addUint16(8, _ROUNDS_REMAINING);
    fbBuilder.addFloat32(9, _TEMPERATURE);
    fbBuilder.addOffset(10, RESERVEDOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
