// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class FilterType {
  final int value;
  const FilterType._(this.value);

  factory FilterType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum FilterType');
    }
    return result;
  }

  static FilterType? _createOrNull(int? value) => 
      value == null ? null : FilterType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 10;
  static bool containsValue(int value) => values.containsKey(value);

  static const FilterType ALPHA_BETA = FilterType._(0);
  static const FilterType ALPHA_BETA_GAMMA = FilterType._(1);
  static const FilterType KALMAN = FilterType._(2);
  static const FilterType EXTENDED_KALMAN = FilterType._(3);
  static const FilterType UNSCENTED_KALMAN = FilterType._(4);
  static const FilterType PARTICLE = FilterType._(5);
  static const FilterType IMM = FilterType._(6);
  static const FilterType JPDA = FilterType._(7);
  static const FilterType MHT = FilterType._(8);
  static const FilterType GNN = FilterType._(9);
  static const FilterType NNKF = FilterType._(10);
  static const Map<int, FilterType> values = {
    0: ALPHA_BETA,
    1: ALPHA_BETA_GAMMA,
    2: KALMAN,
    3: EXTENDED_KALMAN,
    4: UNSCENTED_KALMAN,
    5: PARTICLE,
    6: IMM,
    7: JPDA,
    8: MHT,
    9: GNN,
    10: NNKF};

  static const fb.Reader<FilterType> reader = _FilterTypeReader();

  @override
  String toString() {
    return 'FilterType{value: $value}';
  }
}

class _FilterTypeReader extends fb.Reader<FilterType> {
  const _FilterTypeReader();

  @override
  int get size => 1;

  @override
  FilterType read(fb.BufferContext bc, int offset) =>
      FilterType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class MotionModel {
  final int value;
  const MotionModel._(this.value);

  factory MotionModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum MotionModel');
    }
    return result;
  }

  static MotionModel? _createOrNull(int? value) => 
      value == null ? null : MotionModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 8;
  static bool containsValue(int value) => values.containsKey(value);

  static const MotionModel CONSTANT_VELOCITY = MotionModel._(0);
  static const MotionModel CONSTANT_ACCELERATION = MotionModel._(1);
  static const MotionModel COORDINATED_TURN = MotionModel._(2);
  static const MotionModel SINGER_ACCELERATION = MotionModel._(3);
  static const MotionModel JUMP_MARKOV = MotionModel._(4);
  static const MotionModel BALLISTIC = MotionModel._(5);
  static const MotionModel ORBITAL = MotionModel._(6);
  static const MotionModel SURFACE_VEHICLE = MotionModel._(7);
  static const MotionModel CURVILINEAR = MotionModel._(8);
  static const Map<int, MotionModel> values = {
    0: CONSTANT_VELOCITY,
    1: CONSTANT_ACCELERATION,
    2: COORDINATED_TURN,
    3: SINGER_ACCELERATION,
    4: JUMP_MARKOV,
    5: BALLISTIC,
    6: ORBITAL,
    7: SURFACE_VEHICLE,
    8: CURVILINEAR};

  static const fb.Reader<MotionModel> reader = _MotionModelReader();

  @override
  String toString() {
    return 'MotionModel{value: $value}';
  }
}

class _MotionModelReader extends fb.Reader<MotionModel> {
  const _MotionModelReader();

  @override
  int get size => 1;

  @override
  MotionModel read(fb.BufferContext bc, int offset) =>
      MotionModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

class MeasurementType {
  final int value;
  const MeasurementType._(this.value);

  factory MeasurementType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum MeasurementType');
    }
    return result;
  }

  static MeasurementType? _createOrNull(int? value) => 
      value == null ? null : MeasurementType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 12;
  static bool containsValue(int value) => values.containsKey(value);

  static const MeasurementType POSITION_3D = MeasurementType._(0);
  static const MeasurementType POSITION_2D = MeasurementType._(1);
  static const MeasurementType RANGE_BEARING = MeasurementType._(2);
  static const MeasurementType RANGE_BEARING_ELEVATION = MeasurementType._(3);
  static const MeasurementType RANGE_ONLY = MeasurementType._(4);
  static const MeasurementType BEARING_ONLY = MeasurementType._(5);
  static const MeasurementType RANGE_RATE = MeasurementType._(6);
  static const MeasurementType ANGLES_ONLY = MeasurementType._(7);
  static const MeasurementType TLE = MeasurementType._(8);
  static const MeasurementType GPS = MeasurementType._(9);
  static const MeasurementType RADAR = MeasurementType._(10);
  static const MeasurementType ADSB = MeasurementType._(11);
  static const MeasurementType SONAR = MeasurementType._(12);
  static const Map<int, MeasurementType> values = {
    0: POSITION_3D,
    1: POSITION_2D,
    2: RANGE_BEARING,
    3: RANGE_BEARING_ELEVATION,
    4: RANGE_ONLY,
    5: BEARING_ONLY,
    6: RANGE_RATE,
    7: ANGLES_ONLY,
    8: TLE,
    9: GPS,
    10: RADAR,
    11: ADSB,
    12: SONAR};

  static const fb.Reader<MeasurementType> reader = _MeasurementTypeReader();

  @override
  String toString() {
    return 'MeasurementType{value: $value}';
  }
}

class _MeasurementTypeReader extends fb.Reader<MeasurementType> {
  const _MeasurementTypeReader();

  @override
  int get size => 1;

  @override
  MeasurementType read(fb.BufferContext bc, int offset) =>
      MeasurementType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TkgTrackStatus {
  final int value;
  const TkgTrackStatus._(this.value);

  factory TkgTrackStatus.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TkgTrackStatus');
    }
    return result;
  }

  static TkgTrackStatus? _createOrNull(int? value) => 
      value == null ? null : TkgTrackStatus.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const TkgTrackStatus TENTATIVE = TkgTrackStatus._(0);
  static const TkgTrackStatus CONFIRMED = TkgTrackStatus._(1);
  static const TkgTrackStatus COASTING = TkgTrackStatus._(2);
  static const TkgTrackStatus LOST = TkgTrackStatus._(3);
  static const TkgTrackStatus DELETED = TkgTrackStatus._(4);
  static const Map<int, TkgTrackStatus> values = {
    0: TENTATIVE,
    1: CONFIRMED,
    2: COASTING,
    3: LOST,
    4: DELETED};

  static const fb.Reader<TkgTrackStatus> reader = _TkgTrackStatusReader();

  @override
  String toString() {
    return 'TkgTrackStatus{value: $value}';
  }
}

class _TkgTrackStatusReader extends fb.Reader<TkgTrackStatus> {
  const _TkgTrackStatusReader();

  @override
  int get size => 1;

  @override
  TkgTrackStatus read(fb.BufferContext bc, int offset) =>
      TkgTrackStatus.fromValue(const fb.Int8Reader().read(bc, offset));
}

class AssociationMethod {
  final int value;
  const AssociationMethod._(this.value);

  factory AssociationMethod.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum AssociationMethod');
    }
    return result;
  }

  static AssociationMethod? _createOrNull(int? value) => 
      value == null ? null : AssociationMethod.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 6;
  static bool containsValue(int value) => values.containsKey(value);

  static const AssociationMethod NEAREST_NEIGHBOR = AssociationMethod._(0);
  static const AssociationMethod GLOBAL_NEAREST_NEIGHBOR = AssociationMethod._(1);
  static const AssociationMethod PROBABILISTIC_DATA = AssociationMethod._(2);
  static const AssociationMethod JOINT_PROBABILISTIC = AssociationMethod._(3);
  static const AssociationMethod AUCTION = AssociationMethod._(4);
  static const AssociationMethod HUNGARIAN = AssociationMethod._(5);
  static const AssociationMethod MUNKRES = AssociationMethod._(6);
  static const Map<int, AssociationMethod> values = {
    0: NEAREST_NEIGHBOR,
    1: GLOBAL_NEAREST_NEIGHBOR,
    2: PROBABILISTIC_DATA,
    3: JOINT_PROBABILISTIC,
    4: AUCTION,
    5: HUNGARIAN,
    6: MUNKRES};

  static const fb.Reader<AssociationMethod> reader = _AssociationMethodReader();

  @override
  String toString() {
    return 'AssociationMethod{value: $value}';
  }
}

class _AssociationMethodReader extends fb.Reader<AssociationMethod> {
  const _AssociationMethodReader();

  @override
  int get size => 1;

  @override
  AssociationMethod read(fb.BufferContext bc, int offset) =>
      AssociationMethod.fromValue(const fb.Int8Reader().read(bc, offset));
}

class FusionMethod {
  final int value;
  const FusionMethod._(this.value);

  factory FusionMethod.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum FusionMethod');
    }
    return result;
  }

  static FusionMethod? _createOrNull(int? value) => 
      value == null ? null : FusionMethod.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  static const FusionMethod SIMPLE_AVERAGE = FusionMethod._(0);
  static const FusionMethod WEIGHTED_AVERAGE = FusionMethod._(1);
  static const FusionMethod COVARIANCE_INTERSECTION = FusionMethod._(2);
  static const FusionMethod BAR_SHALOM_CAMPO = FusionMethod._(3);
  static const FusionMethod FEDERATED = FusionMethod._(4);
  static const FusionMethod SEQUENTIAL = FusionMethod._(5);
  static const Map<int, FusionMethod> values = {
    0: SIMPLE_AVERAGE,
    1: WEIGHTED_AVERAGE,
    2: COVARIANCE_INTERSECTION,
    3: BAR_SHALOM_CAMPO,
    4: FEDERATED,
    5: SEQUENTIAL};

  static const fb.Reader<FusionMethod> reader = _FusionMethodReader();

  @override
  String toString() {
    return 'FusionMethod{value: $value}';
  }
}

class _FusionMethodReader extends fb.Reader<FusionMethod> {
  const _FusionMethodReader();

  @override
  int get size => 1;

  @override
  FusionMethod read(fb.BufferContext bc, int offset) =>
      FusionMethod.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Tracking and Data Fusion
class TKG {
  TKG._(this._bc, this._bcOffset);
  factory TKG(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<TKG> reader = _TKGReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get COMMAND => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get FILTER_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  String? get IMM_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  String? get MHT_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
  String? get JPDA_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get FUSION_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  String? get MEASUREMENTS => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 16);
  String? get INITIAL_STATE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);
  String? get TRACK_TO_UPDATE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 20);
  List<String>? get TRACKS_TO_CORRELATE => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 22);

  @override
  String toString() {
    return 'TKG{COMMAND: ${COMMAND}, FILTER_CONFIG: ${FILTER_CONFIG}, IMM_CONFIG: ${IMM_CONFIG}, MHT_CONFIG: ${MHT_CONFIG}, JPDA_CONFIG: ${JPDA_CONFIG}, FUSION_CONFIG: ${FUSION_CONFIG}, MEASUREMENTS: ${MEASUREMENTS}, INITIAL_STATE: ${INITIAL_STATE}, TRACK_TO_UPDATE: ${TRACK_TO_UPDATE}, TRACKS_TO_CORRELATE: ${TRACKS_TO_CORRELATE}}';
  }
}

class _TKGReader extends fb.TableReader<TKG> {
  const _TKGReader();

  @override
  TKG createObject(fb.BufferContext bc, int offset) => 
    TKG._(bc, offset);
}

class TKGBuilder {
  TKGBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(10);
  }

  int addCommandOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addFilterConfigOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addImmConfigOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addMhtConfigOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addJpdaConfigOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addFusionConfigOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addMeasurementsOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addInitialStateOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }
  int addTrackToUpdateOffset(int? offset) {
    fbBuilder.addOffset(8, offset);
    return fbBuilder.offset;
  }
  int addTracksToCorrelateOffset(int? offset) {
    fbBuilder.addOffset(9, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TKGObjectBuilder extends fb.ObjectBuilder {
  final String? _COMMAND;
  final String? _FILTER_CONFIG;
  final String? _IMM_CONFIG;
  final String? _MHT_CONFIG;
  final String? _JPDA_CONFIG;
  final String? _FUSION_CONFIG;
  final String? _MEASUREMENTS;
  final String? _INITIAL_STATE;
  final String? _TRACK_TO_UPDATE;
  final List<String>? _TRACKS_TO_CORRELATE;

  TKGObjectBuilder({
    String? COMMAND,
    String? FILTER_CONFIG,
    String? IMM_CONFIG,
    String? MHT_CONFIG,
    String? JPDA_CONFIG,
    String? FUSION_CONFIG,
    String? MEASUREMENTS,
    String? INITIAL_STATE,
    String? TRACK_TO_UPDATE,
    List<String>? TRACKS_TO_CORRELATE,
  })
      : _COMMAND = COMMAND,
        _FILTER_CONFIG = FILTER_CONFIG,
        _IMM_CONFIG = IMM_CONFIG,
        _MHT_CONFIG = MHT_CONFIG,
        _JPDA_CONFIG = JPDA_CONFIG,
        _FUSION_CONFIG = FUSION_CONFIG,
        _MEASUREMENTS = MEASUREMENTS,
        _INITIAL_STATE = INITIAL_STATE,
        _TRACK_TO_UPDATE = TRACK_TO_UPDATE,
        _TRACKS_TO_CORRELATE = TRACKS_TO_CORRELATE;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? COMMANDOffset = _COMMAND == null ? null
        : fbBuilder.writeString(_COMMAND!);
    final int? FILTER_CONFIGOffset = _FILTER_CONFIG == null ? null
        : fbBuilder.writeString(_FILTER_CONFIG!);
    final int? IMM_CONFIGOffset = _IMM_CONFIG == null ? null
        : fbBuilder.writeString(_IMM_CONFIG!);
    final int? MHT_CONFIGOffset = _MHT_CONFIG == null ? null
        : fbBuilder.writeString(_MHT_CONFIG!);
    final int? JPDA_CONFIGOffset = _JPDA_CONFIG == null ? null
        : fbBuilder.writeString(_JPDA_CONFIG!);
    final int? FUSION_CONFIGOffset = _FUSION_CONFIG == null ? null
        : fbBuilder.writeString(_FUSION_CONFIG!);
    final int? MEASUREMENTSOffset = _MEASUREMENTS == null ? null
        : fbBuilder.writeString(_MEASUREMENTS!);
    final int? INITIAL_STATEOffset = _INITIAL_STATE == null ? null
        : fbBuilder.writeString(_INITIAL_STATE!);
    final int? TRACK_TO_UPDATEOffset = _TRACK_TO_UPDATE == null ? null
        : fbBuilder.writeString(_TRACK_TO_UPDATE!);
    final int? TRACKS_TO_CORRELATEOffset = _TRACKS_TO_CORRELATE == null ? null
        : fbBuilder.writeList(_TRACKS_TO_CORRELATE!.map(fbBuilder.writeString).toList());
    fbBuilder.startTable(10);
    fbBuilder.addOffset(0, COMMANDOffset);
    fbBuilder.addOffset(1, FILTER_CONFIGOffset);
    fbBuilder.addOffset(2, IMM_CONFIGOffset);
    fbBuilder.addOffset(3, MHT_CONFIGOffset);
    fbBuilder.addOffset(4, JPDA_CONFIGOffset);
    fbBuilder.addOffset(5, FUSION_CONFIGOffset);
    fbBuilder.addOffset(6, MEASUREMENTSOffset);
    fbBuilder.addOffset(7, INITIAL_STATEOffset);
    fbBuilder.addOffset(8, TRACK_TO_UPDATEOffset);
    fbBuilder.addOffset(9, TRACKS_TO_CORRELATEOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
