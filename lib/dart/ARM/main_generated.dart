// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class ArmorMaterial {
  final int value;
  const ArmorMaterial._(this.value);

  factory ArmorMaterial.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum ArmorMaterial');
    }
    return result;
  }

  static ArmorMaterial? _createOrNull(int? value) => 
      value == null ? null : ArmorMaterial.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 14;
  static bool containsValue(int value) => values.containsKey(value);

  static const ArmorMaterial RHA = ArmorMaterial._(0);
  static const ArmorMaterial CHA = ArmorMaterial._(1);
  static const ArmorMaterial FHA = ArmorMaterial._(2);
  static const ArmorMaterial HHA = ArmorMaterial._(3);
  static const ArmorMaterial ALUMINUM = ArmorMaterial._(4);
  static const ArmorMaterial COMPOSITE = ArmorMaterial._(5);
  static const ArmorMaterial CERAMIC = ArmorMaterial._(6);
  static const ArmorMaterial ERA = ArmorMaterial._(7);
  static const ArmorMaterial NERA = ArmorMaterial._(8);
  static const ArmorMaterial SPACED = ArmorMaterial._(9);
  static const ArmorMaterial RUBBER = ArmorMaterial._(10);
  static const ArmorMaterial STRUCTURAL = ArmorMaterial._(11);
  static const ArmorMaterial TITANIUM = ArmorMaterial._(12);
  static const ArmorMaterial KEVLAR = ArmorMaterial._(13);
  static const ArmorMaterial GLASS = ArmorMaterial._(14);
  static const Map<int, ArmorMaterial> values = {
    0: RHA,
    1: CHA,
    2: FHA,
    3: HHA,
    4: ALUMINUM,
    5: COMPOSITE,
    6: CERAMIC,
    7: ERA,
    8: NERA,
    9: SPACED,
    10: RUBBER,
    11: STRUCTURAL,
    12: TITANIUM,
    13: KEVLAR,
    14: GLASS};

  static const fb.Reader<ArmorMaterial> reader = _ArmorMaterialReader();

  @override
  String toString() {
    return 'ArmorMaterial{value: $value}';
  }
}

class _ArmorMaterialReader extends fb.Reader<ArmorMaterial> {
  const _ArmorMaterialReader();

  @override
  int get size => 1;

  @override
  ArmorMaterial read(fb.BufferContext bc, int offset) =>
      ArmorMaterial.fromValue(const fb.Int8Reader().read(bc, offset));
}

class AmmoType {
  final int value;
  const AmmoType._(this.value);

  factory AmmoType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum AmmoType');
    }
    return result;
  }

  static AmmoType? _createOrNull(int? value) => 
      value == null ? null : AmmoType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 17;
  static bool containsValue(int value) => values.containsKey(value);

  static const AmmoType AP = AmmoType._(0);
  static const AmmoType APC = AmmoType._(1);
  static const AmmoType APCBC = AmmoType._(2);
  static const AmmoType APCR = AmmoType._(3);
  static const AmmoType APDS = AmmoType._(4);
  static const AmmoType APFSDS = AmmoType._(5);
  static const AmmoType HEAT = AmmoType._(6);
  static const AmmoType HEAT_FS = AmmoType._(7);
  static const AmmoType HESH = AmmoType._(8);
  static const AmmoType HE = AmmoType._(9);
  static const AmmoType HE_FRAG = AmmoType._(10);
  static const AmmoType HEDP = AmmoType._(11);
  static const AmmoType APHE = AmmoType._(12);
  static const AmmoType SAP = AmmoType._(13);
  static const AmmoType ATGM = AmmoType._(14);
  static const AmmoType TANDEM_HEAT = AmmoType._(15);
  static const AmmoType TOP_ATTACK = AmmoType._(16);
  static const AmmoType EFP = AmmoType._(17);
  static const Map<int, AmmoType> values = {
    0: AP,
    1: APC,
    2: APCBC,
    3: APCR,
    4: APDS,
    5: APFSDS,
    6: HEAT,
    7: HEAT_FS,
    8: HESH,
    9: HE,
    10: HE_FRAG,
    11: HEDP,
    12: APHE,
    13: SAP,
    14: ATGM,
    15: TANDEM_HEAT,
    16: TOP_ATTACK,
    17: EFP};

  static const fb.Reader<AmmoType> reader = _AmmoTypeReader();

  @override
  String toString() {
    return 'AmmoType{value: $value}';
  }
}

class _AmmoTypeReader extends fb.Reader<AmmoType> {
  const _AmmoTypeReader();

  @override
  int get size => 1;

  @override
  AmmoType read(fb.BufferContext bc, int offset) =>
      AmmoType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class PenResult {
  final int value;
  const PenResult._(this.value);

  factory PenResult.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum PenResult');
    }
    return result;
  }

  static PenResult? _createOrNull(int? value) => 
      value == null ? null : PenResult.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  static const PenResult NO_PENETRATION = PenResult._(0);
  static const PenResult PARTIAL_PEN = PenResult._(1);
  static const PenResult FULL_PEN = PenResult._(2);
  static const PenResult RICOCHET = PenResult._(3);
  static const PenResult SHATTERED = PenResult._(4);
  static const PenResult OVER_MATCH = PenResult._(5);
  static const Map<int, PenResult> values = {
    0: NO_PENETRATION,
    1: PARTIAL_PEN,
    2: FULL_PEN,
    3: RICOCHET,
    4: SHATTERED,
    5: OVER_MATCH};

  static const fb.Reader<PenResult> reader = _PenResultReader();

  @override
  String toString() {
    return 'PenResult{value: $value}';
  }
}

class _PenResultReader extends fb.Reader<PenResult> {
  const _PenResultReader();

  @override
  int get size => 1;

  @override
  PenResult read(fb.BufferContext bc, int offset) =>
      PenResult.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Armor and Protection
class ARM {
  ARM._(this._bc, this._bcOffset);
  factory ARM(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<ARM> reader = _ARMReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get THICKNESS => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 4, 0.0);
  double get ANGLE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 6, 0.0);
  int get MATERIAL => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 8, 0);
  int get HARDNESS => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 10, 0);
  int get QUALITY => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 12, 0);
  int get ERA_TYPE => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 14, 0);
  double get ERA_EFFECTIVENESS => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  double get ERA_VS_KE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  double get RHA_EQUIVALENT => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
  double get NORMAL_X => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  double get NORMAL_Y => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  double get NORMAL_Z => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 26, 0.0);
  List<int>? get RESERVED => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 28);

  @override
  String toString() {
    return 'ARM{THICKNESS: ${THICKNESS}, ANGLE: ${ANGLE}, MATERIAL: ${MATERIAL}, HARDNESS: ${HARDNESS}, QUALITY: ${QUALITY}, ERA_TYPE: ${ERA_TYPE}, ERA_EFFECTIVENESS: ${ERA_EFFECTIVENESS}, ERA_VS_KE: ${ERA_VS_KE}, RHA_EQUIVALENT: ${RHA_EQUIVALENT}, NORMAL_X: ${NORMAL_X}, NORMAL_Y: ${NORMAL_Y}, NORMAL_Z: ${NORMAL_Z}, RESERVED: ${RESERVED}}';
  }
}

class _ARMReader extends fb.TableReader<ARM> {
  const _ARMReader();

  @override
  ARM createObject(fb.BufferContext bc, int offset) => 
    ARM._(bc, offset);
}

class ARMBuilder {
  ARMBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(13);
  }

  int addThickness(double? THICKNESS) {
    fbBuilder.addFloat64(0, THICKNESS);
    return fbBuilder.offset;
  }
  int addAngle(double? ANGLE) {
    fbBuilder.addFloat64(1, ANGLE);
    return fbBuilder.offset;
  }
  int addMaterial(int? MATERIAL) {
    fbBuilder.addUint8(2, MATERIAL);
    return fbBuilder.offset;
  }
  int addHardness(int? HARDNESS) {
    fbBuilder.addUint8(3, HARDNESS);
    return fbBuilder.offset;
  }
  int addQuality(int? QUALITY) {
    fbBuilder.addUint8(4, QUALITY);
    return fbBuilder.offset;
  }
  int addEraType(int? ERA_TYPE) {
    fbBuilder.addUint8(5, ERA_TYPE);
    return fbBuilder.offset;
  }
  int addEraEffectiveness(double? ERA_EFFECTIVENESS) {
    fbBuilder.addFloat32(6, ERA_EFFECTIVENESS);
    return fbBuilder.offset;
  }
  int addEraVsKe(double? ERA_VS_KE) {
    fbBuilder.addFloat32(7, ERA_VS_KE);
    return fbBuilder.offset;
  }
  int addRhaEquivalent(double? RHA_EQUIVALENT) {
    fbBuilder.addFloat32(8, RHA_EQUIVALENT);
    return fbBuilder.offset;
  }
  int addNormalX(double? NORMAL_X) {
    fbBuilder.addFloat64(9, NORMAL_X);
    return fbBuilder.offset;
  }
  int addNormalY(double? NORMAL_Y) {
    fbBuilder.addFloat64(10, NORMAL_Y);
    return fbBuilder.offset;
  }
  int addNormalZ(double? NORMAL_Z) {
    fbBuilder.addFloat64(11, NORMAL_Z);
    return fbBuilder.offset;
  }
  int addReservedOffset(int? offset) {
    fbBuilder.addOffset(12, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class ARMObjectBuilder extends fb.ObjectBuilder {
  final double? _THICKNESS;
  final double? _ANGLE;
  final int? _MATERIAL;
  final int? _HARDNESS;
  final int? _QUALITY;
  final int? _ERA_TYPE;
  final double? _ERA_EFFECTIVENESS;
  final double? _ERA_VS_KE;
  final double? _RHA_EQUIVALENT;
  final double? _NORMAL_X;
  final double? _NORMAL_Y;
  final double? _NORMAL_Z;
  final List<int>? _RESERVED;

  ARMObjectBuilder({
    double? THICKNESS,
    double? ANGLE,
    int? MATERIAL,
    int? HARDNESS,
    int? QUALITY,
    int? ERA_TYPE,
    double? ERA_EFFECTIVENESS,
    double? ERA_VS_KE,
    double? RHA_EQUIVALENT,
    double? NORMAL_X,
    double? NORMAL_Y,
    double? NORMAL_Z,
    List<int>? RESERVED,
  })
      : _THICKNESS = THICKNESS,
        _ANGLE = ANGLE,
        _MATERIAL = MATERIAL,
        _HARDNESS = HARDNESS,
        _QUALITY = QUALITY,
        _ERA_TYPE = ERA_TYPE,
        _ERA_EFFECTIVENESS = ERA_EFFECTIVENESS,
        _ERA_VS_KE = ERA_VS_KE,
        _RHA_EQUIVALENT = RHA_EQUIVALENT,
        _NORMAL_X = NORMAL_X,
        _NORMAL_Y = NORMAL_Y,
        _NORMAL_Z = NORMAL_Z,
        _RESERVED = RESERVED;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? RESERVEDOffset = _RESERVED == null ? null
        : fbBuilder.writeListUint8(_RESERVED!);
    fbBuilder.startTable(13);
    fbBuilder.addFloat64(0, _THICKNESS);
    fbBuilder.addFloat64(1, _ANGLE);
    fbBuilder.addUint8(2, _MATERIAL);
    fbBuilder.addUint8(3, _HARDNESS);
    fbBuilder.addUint8(4, _QUALITY);
    fbBuilder.addUint8(5, _ERA_TYPE);
    fbBuilder.addFloat32(6, _ERA_EFFECTIVENESS);
    fbBuilder.addFloat32(7, _ERA_VS_KE);
    fbBuilder.addFloat32(8, _RHA_EQUIVALENT);
    fbBuilder.addFloat64(9, _NORMAL_X);
    fbBuilder.addFloat64(10, _NORMAL_Y);
    fbBuilder.addFloat64(11, _NORMAL_Z);
    fbBuilder.addOffset(12, RESERVEDOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
