// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class AtmosphereModel {
  final int value;
  const AtmosphereModel._(this.value);

  factory AtmosphereModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum AtmosphereModel');
    }
    return result;
  }

  static AtmosphereModel? _createOrNull(int? value) => 
      value == null ? null : AtmosphereModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const AtmosphereModel ISA = AtmosphereModel._(0);
  static const AtmosphereModel US_STD_1976 = AtmosphereModel._(1);
  static const AtmosphereModel NRLMSISE_00 = AtmosphereModel._(2);
  static const AtmosphereModel SIMPLE = AtmosphereModel._(3);
  static const AtmosphereModel CUSTOM = AtmosphereModel._(4);
  static const Map<int, AtmosphereModel> values = {
    0: ISA,
    1: US_STD_1976,
    2: NRLMSISE_00,
    3: SIMPLE,
    4: CUSTOM};

  static const fb.Reader<AtmosphereModel> reader = _AtmosphereModelReader();

  @override
  String toString() {
    return 'AtmosphereModel{value: $value}';
  }
}

class _AtmosphereModelReader extends fb.Reader<AtmosphereModel> {
  const _AtmosphereModelReader();

  @override
  int get size => 1;

  @override
  AtmosphereModel read(fb.BufferContext bc, int offset) =>
      AtmosphereModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

class WeatherCondition {
  final int value;
  const WeatherCondition._(this.value);

  factory WeatherCondition.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum WeatherCondition');
    }
    return result;
  }

  static WeatherCondition? _createOrNull(int? value) => 
      value == null ? null : WeatherCondition.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 15;
  static bool containsValue(int value) => values.containsKey(value);

  static const WeatherCondition CLEAR = WeatherCondition._(0);
  static const WeatherCondition FEW_CLOUDS = WeatherCondition._(1);
  static const WeatherCondition SCATTERED = WeatherCondition._(2);
  static const WeatherCondition BROKEN = WeatherCondition._(3);
  static const WeatherCondition OVERCAST = WeatherCondition._(4);
  static const WeatherCondition RAIN_LIGHT = WeatherCondition._(5);
  static const WeatherCondition RAIN_MODERATE = WeatherCondition._(6);
  static const WeatherCondition RAIN_HEAVY = WeatherCondition._(7);
  static const WeatherCondition SNOW_LIGHT = WeatherCondition._(8);
  static const WeatherCondition SNOW_MODERATE = WeatherCondition._(9);
  static const WeatherCondition SNOW_HEAVY = WeatherCondition._(10);
  static const WeatherCondition FOG = WeatherCondition._(11);
  static const WeatherCondition MIST = WeatherCondition._(12);
  static const WeatherCondition HAZE = WeatherCondition._(13);
  static const WeatherCondition THUNDERSTORM = WeatherCondition._(14);
  static const WeatherCondition SANDSTORM = WeatherCondition._(15);
  static const Map<int, WeatherCondition> values = {
    0: CLEAR,
    1: FEW_CLOUDS,
    2: SCATTERED,
    3: BROKEN,
    4: OVERCAST,
    5: RAIN_LIGHT,
    6: RAIN_MODERATE,
    7: RAIN_HEAVY,
    8: SNOW_LIGHT,
    9: SNOW_MODERATE,
    10: SNOW_HEAVY,
    11: FOG,
    12: MIST,
    13: HAZE,
    14: THUNDERSTORM,
    15: SANDSTORM};

  static const fb.Reader<WeatherCondition> reader = _WeatherConditionReader();

  @override
  String toString() {
    return 'WeatherCondition{value: $value}';
  }
}

class _WeatherConditionReader extends fb.Reader<WeatherCondition> {
  const _WeatherConditionReader();

  @override
  int get size => 1;

  @override
  WeatherCondition read(fb.BufferContext bc, int offset) =>
      WeatherCondition.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TerrainType {
  final int value;
  const TerrainType._(this.value);

  factory TerrainType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TerrainType');
    }
    return result;
  }

  static TerrainType? _createOrNull(int? value) => 
      value == null ? null : TerrainType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 11;
  static bool containsValue(int value) => values.containsKey(value);

  static const TerrainType OCEAN = TerrainType._(0);
  static const TerrainType WATER_FRESH = TerrainType._(1);
  static const TerrainType SAND = TerrainType._(2);
  static const TerrainType GRASS = TerrainType._(3);
  static const TerrainType FOREST = TerrainType._(4);
  static const TerrainType CONCRETE = TerrainType._(5);
  static const TerrainType ASPHALT = TerrainType._(6);
  static const TerrainType SNOW = TerrainType._(7);
  static const TerrainType ICE = TerrainType._(8);
  static const TerrainType ROCK = TerrainType._(9);
  static const TerrainType MARSH = TerrainType._(10);
  static const TerrainType URBAN = TerrainType._(11);
  static const Map<int, TerrainType> values = {
    0: OCEAN,
    1: WATER_FRESH,
    2: SAND,
    3: GRASS,
    4: FOREST,
    5: CONCRETE,
    6: ASPHALT,
    7: SNOW,
    8: ICE,
    9: ROCK,
    10: MARSH,
    11: URBAN};

  static const fb.Reader<TerrainType> reader = _TerrainTypeReader();

  @override
  String toString() {
    return 'TerrainType{value: $value}';
  }
}

class _TerrainTypeReader extends fb.Reader<TerrainType> {
  const _TerrainTypeReader();

  @override
  int get size => 1;

  @override
  TerrainType read(fb.BufferContext bc, int offset) =>
      TerrainType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Atmosphere and Environment
class ENV {
  ENV._(this._bc, this._bcOffset);
  factory ENV(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<ENV> reader = _ENVReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get ATMOSPHERE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get WEATHER => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  double get TIME_UTC => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 8, 0.0);
  double get LATITUDE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 10, 0.0);
  double get LONGITUDE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 12, 0.0);
  double get SUN_AZIMUTH => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 14, 0.0);
  double get SUN_ELEVATION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  double get MOON_PHASE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  double get ILLUMINATION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
  double get MAGNETIC_DECLINATION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  double get MAGNETIC_INCLINATION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  List<int>? get RESERVED => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 26);

  @override
  String toString() {
    return 'ENV{ATMOSPHERE: ${ATMOSPHERE}, WEATHER: ${WEATHER}, TIME_UTC: ${TIME_UTC}, LATITUDE: ${LATITUDE}, LONGITUDE: ${LONGITUDE}, SUN_AZIMUTH: ${SUN_AZIMUTH}, SUN_ELEVATION: ${SUN_ELEVATION}, MOON_PHASE: ${MOON_PHASE}, ILLUMINATION: ${ILLUMINATION}, MAGNETIC_DECLINATION: ${MAGNETIC_DECLINATION}, MAGNETIC_INCLINATION: ${MAGNETIC_INCLINATION}, RESERVED: ${RESERVED}}';
  }
}

class _ENVReader extends fb.TableReader<ENV> {
  const _ENVReader();

  @override
  ENV createObject(fb.BufferContext bc, int offset) => 
    ENV._(bc, offset);
}

class ENVBuilder {
  ENVBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(12);
  }

  int addAtmosphereOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addWeatherOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addTimeUtc(double? TIME_UTC) {
    fbBuilder.addFloat64(2, TIME_UTC);
    return fbBuilder.offset;
  }
  int addLatitude(double? LATITUDE) {
    fbBuilder.addFloat64(3, LATITUDE);
    return fbBuilder.offset;
  }
  int addLongitude(double? LONGITUDE) {
    fbBuilder.addFloat64(4, LONGITUDE);
    return fbBuilder.offset;
  }
  int addSunAzimuth(double? SUN_AZIMUTH) {
    fbBuilder.addFloat32(5, SUN_AZIMUTH);
    return fbBuilder.offset;
  }
  int addSunElevation(double? SUN_ELEVATION) {
    fbBuilder.addFloat32(6, SUN_ELEVATION);
    return fbBuilder.offset;
  }
  int addMoonPhase(double? MOON_PHASE) {
    fbBuilder.addFloat32(7, MOON_PHASE);
    return fbBuilder.offset;
  }
  int addIllumination(double? ILLUMINATION) {
    fbBuilder.addFloat32(8, ILLUMINATION);
    return fbBuilder.offset;
  }
  int addMagneticDeclination(double? MAGNETIC_DECLINATION) {
    fbBuilder.addFloat32(9, MAGNETIC_DECLINATION);
    return fbBuilder.offset;
  }
  int addMagneticInclination(double? MAGNETIC_INCLINATION) {
    fbBuilder.addFloat32(10, MAGNETIC_INCLINATION);
    return fbBuilder.offset;
  }
  int addReservedOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class ENVObjectBuilder extends fb.ObjectBuilder {
  final String? _ATMOSPHERE;
  final String? _WEATHER;
  final double? _TIME_UTC;
  final double? _LATITUDE;
  final double? _LONGITUDE;
  final double? _SUN_AZIMUTH;
  final double? _SUN_ELEVATION;
  final double? _MOON_PHASE;
  final double? _ILLUMINATION;
  final double? _MAGNETIC_DECLINATION;
  final double? _MAGNETIC_INCLINATION;
  final List<int>? _RESERVED;

  ENVObjectBuilder({
    String? ATMOSPHERE,
    String? WEATHER,
    double? TIME_UTC,
    double? LATITUDE,
    double? LONGITUDE,
    double? SUN_AZIMUTH,
    double? SUN_ELEVATION,
    double? MOON_PHASE,
    double? ILLUMINATION,
    double? MAGNETIC_DECLINATION,
    double? MAGNETIC_INCLINATION,
    List<int>? RESERVED,
  })
      : _ATMOSPHERE = ATMOSPHERE,
        _WEATHER = WEATHER,
        _TIME_UTC = TIME_UTC,
        _LATITUDE = LATITUDE,
        _LONGITUDE = LONGITUDE,
        _SUN_AZIMUTH = SUN_AZIMUTH,
        _SUN_ELEVATION = SUN_ELEVATION,
        _MOON_PHASE = MOON_PHASE,
        _ILLUMINATION = ILLUMINATION,
        _MAGNETIC_DECLINATION = MAGNETIC_DECLINATION,
        _MAGNETIC_INCLINATION = MAGNETIC_INCLINATION,
        _RESERVED = RESERVED;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? ATMOSPHEREOffset = _ATMOSPHERE == null ? null
        : fbBuilder.writeString(_ATMOSPHERE!);
    final int? WEATHEROffset = _WEATHER == null ? null
        : fbBuilder.writeString(_WEATHER!);
    final int? RESERVEDOffset = _RESERVED == null ? null
        : fbBuilder.writeListUint8(_RESERVED!);
    fbBuilder.startTable(12);
    fbBuilder.addOffset(0, ATMOSPHEREOffset);
    fbBuilder.addOffset(1, WEATHEROffset);
    fbBuilder.addFloat64(2, _TIME_UTC);
    fbBuilder.addFloat64(3, _LATITUDE);
    fbBuilder.addFloat64(4, _LONGITUDE);
    fbBuilder.addFloat32(5, _SUN_AZIMUTH);
    fbBuilder.addFloat32(6, _SUN_ELEVATION);
    fbBuilder.addFloat32(7, _MOON_PHASE);
    fbBuilder.addFloat32(8, _ILLUMINATION);
    fbBuilder.addFloat32(9, _MAGNETIC_DECLINATION);
    fbBuilder.addFloat32(10, _MAGNETIC_INCLINATION);
    fbBuilder.addOffset(11, RESERVEDOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
