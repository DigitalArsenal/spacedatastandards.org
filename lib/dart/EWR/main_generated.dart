// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class JammingType {
  final int value;
  const JammingType._(this.value);

  factory JammingType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum JammingType');
    }
    return result;
  }

  static JammingType? _createOrNull(int? value) => 
      value == null ? null : JammingType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 13;
  static bool containsValue(int value) => values.containsKey(value);

  static const JammingType NOISE_BARRAGE = JammingType._(0);
  static const JammingType NOISE_SPOT = JammingType._(1);
  static const JammingType NOISE_SWEPT = JammingType._(2);
  static const JammingType DECEPTION_RANGE_GATE = JammingType._(3);
  static const JammingType DECEPTION_VELOCITY_GATE = JammingType._(4);
  static const JammingType DECEPTION_ANGLE = JammingType._(5);
  static const JammingType DECEPTION_FALSE_TARGET = JammingType._(6);
  static const JammingType DRFM = JammingType._(7);
  static const JammingType REPEATER = JammingType._(8);
  static const JammingType CROSS_EYE = JammingType._(9);
  static const JammingType CROSS_POLARIZATION = JammingType._(10);
  static const JammingType CHAFF = JammingType._(11);
  static const JammingType FLARE = JammingType._(12);
  static const JammingType TOWED_DECOY = JammingType._(13);
  static const Map<int, JammingType> values = {
    0: NOISE_BARRAGE,
    1: NOISE_SPOT,
    2: NOISE_SWEPT,
    3: DECEPTION_RANGE_GATE,
    4: DECEPTION_VELOCITY_GATE,
    5: DECEPTION_ANGLE,
    6: DECEPTION_FALSE_TARGET,
    7: DRFM,
    8: REPEATER,
    9: CROSS_EYE,
    10: CROSS_POLARIZATION,
    11: CHAFF,
    12: FLARE,
    13: TOWED_DECOY};

  static const fb.Reader<JammingType> reader = _JammingTypeReader();

  @override
  String toString() {
    return 'JammingType{value: $value}';
  }
}

class _JammingTypeReader extends fb.Reader<JammingType> {
  const _JammingTypeReader();

  @override
  int get size => 1;

  @override
  JammingType read(fb.BufferContext bc, int offset) =>
      JammingType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class ThreatCategory {
  final int value;
  const ThreatCategory._(this.value);

  factory ThreatCategory.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum ThreatCategory');
    }
    return result;
  }

  static ThreatCategory? _createOrNull(int? value) => 
      value == null ? null : ThreatCategory.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 14;
  static bool containsValue(int value) => values.containsKey(value);

  static const ThreatCategory UNKNOWN = ThreatCategory._(0);
  static const ThreatCategory EARLY_WARNING = ThreatCategory._(1);
  static const ThreatCategory ACQUISITION = ThreatCategory._(2);
  static const ThreatCategory TRACKING = ThreatCategory._(3);
  static const ThreatCategory GUIDANCE = ThreatCategory._(4);
  static const ThreatCategory HEIGHT_FINDER = ThreatCategory._(5);
  static const ThreatCategory GCI = ThreatCategory._(6);
  static const ThreatCategory AIRBORNE_INTERCEPT = ThreatCategory._(7);
  static const ThreatCategory SURFACE_SEARCH = ThreatCategory._(8);
  static const ThreatCategory AIR_SEARCH = ThreatCategory._(9);
  static const ThreatCategory NAVIGATION = ThreatCategory._(10);
  static const ThreatCategory WEATHER = ThreatCategory._(11);
  static const ThreatCategory CIVIL = ThreatCategory._(12);
  static const ThreatCategory FRIENDLY = ThreatCategory._(13);
  static const ThreatCategory IFF = ThreatCategory._(14);
  static const Map<int, ThreatCategory> values = {
    0: UNKNOWN,
    1: EARLY_WARNING,
    2: ACQUISITION,
    3: TRACKING,
    4: GUIDANCE,
    5: HEIGHT_FINDER,
    6: GCI,
    7: AIRBORNE_INTERCEPT,
    8: SURFACE_SEARCH,
    9: AIR_SEARCH,
    10: NAVIGATION,
    11: WEATHER,
    12: CIVIL,
    13: FRIENDLY,
    14: IFF};

  static const fb.Reader<ThreatCategory> reader = _ThreatCategoryReader();

  @override
  String toString() {
    return 'ThreatCategory{value: $value}';
  }
}

class _ThreatCategoryReader extends fb.Reader<ThreatCategory> {
  const _ThreatCategoryReader();

  @override
  int get size => 1;

  @override
  ThreatCategory read(fb.BufferContext bc, int offset) =>
      ThreatCategory.fromValue(const fb.Int8Reader().read(bc, offset));
}

class Esmfunction {
  final int value;
  const Esmfunction._(this.value);

  factory Esmfunction.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum Esmfunction');
    }
    return result;
  }

  static Esmfunction? _createOrNull(int? value) => 
      value == null ? null : Esmfunction.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 6;
  static bool containsValue(int value) => values.containsKey(value);

  static const Esmfunction SEARCH = Esmfunction._(0);
  static const Esmfunction CLASSIFICATION = Esmfunction._(1);
  static const Esmfunction IDENTIFICATION = Esmfunction._(2);
  static const Esmfunction DIRECTION_FINDING = Esmfunction._(3);
  static const Esmfunction LOCATION = Esmfunction._(4);
  static const Esmfunction RECORDING = Esmfunction._(5);
  static const Esmfunction SITUATIONAL_AWARENESS = Esmfunction._(6);
  static const Map<int, Esmfunction> values = {
    0: SEARCH,
    1: CLASSIFICATION,
    2: IDENTIFICATION,
    3: DIRECTION_FINDING,
    4: LOCATION,
    5: RECORDING,
    6: SITUATIONAL_AWARENESS};

  static const fb.Reader<Esmfunction> reader = _EsmfunctionReader();

  @override
  String toString() {
    return 'Esmfunction{value: $value}';
  }
}

class _EsmfunctionReader extends fb.Reader<Esmfunction> {
  const _EsmfunctionReader();

  @override
  int get size => 1;

  @override
  Esmfunction read(fb.BufferContext bc, int offset) =>
      Esmfunction.fromValue(const fb.Int8Reader().read(bc, offset));
}

class CountermeasureStatus {
  final int value;
  const CountermeasureStatus._(this.value);

  factory CountermeasureStatus.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum CountermeasureStatus');
    }
    return result;
  }

  static CountermeasureStatus? _createOrNull(int? value) => 
      value == null ? null : CountermeasureStatus.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  static const CountermeasureStatus READY = CountermeasureStatus._(0);
  static const CountermeasureStatus DEPLOYING = CountermeasureStatus._(1);
  static const CountermeasureStatus ACTIVE = CountermeasureStatus._(2);
  static const CountermeasureStatus EXPENDED = CountermeasureStatus._(3);
  static const CountermeasureStatus RELOADING = CountermeasureStatus._(4);
  static const CountermeasureStatus FAILED = CountermeasureStatus._(5);
  static const Map<int, CountermeasureStatus> values = {
    0: READY,
    1: DEPLOYING,
    2: ACTIVE,
    3: EXPENDED,
    4: RELOADING,
    5: FAILED};

  static const fb.Reader<CountermeasureStatus> reader = _CountermeasureStatusReader();

  @override
  String toString() {
    return 'CountermeasureStatus{value: $value}';
  }
}

class _CountermeasureStatusReader extends fb.Reader<CountermeasureStatus> {
  const _CountermeasureStatusReader();

  @override
  int get size => 1;

  @override
  CountermeasureStatus read(fb.BufferContext bc, int offset) =>
      CountermeasureStatus.fromValue(const fb.Int8Reader().read(bc, offset));
}

class WaveformType {
  final int value;
  const WaveformType._(this.value);

  factory WaveformType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum WaveformType');
    }
    return result;
  }

  static WaveformType? _createOrNull(int? value) => 
      value == null ? null : WaveformType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 9;
  static bool containsValue(int value) => values.containsKey(value);

  static const WaveformType CW = WaveformType._(0);
  static const WaveformType PULSED = WaveformType._(1);
  static const WaveformType PULSE_DOPPLER = WaveformType._(2);
  static const WaveformType FM_CW = WaveformType._(3);
  static const WaveformType CHIRP = WaveformType._(4);
  static const WaveformType PHASE_CODED = WaveformType._(5);
  static const WaveformType FREQUENCY_AGILE = WaveformType._(6);
  static const WaveformType PRI_AGILE = WaveformType._(7);
  static const WaveformType COMPLEX = WaveformType._(8);
  static const WaveformType LPI = WaveformType._(9);
  static const Map<int, WaveformType> values = {
    0: CW,
    1: PULSED,
    2: PULSE_DOPPLER,
    3: FM_CW,
    4: CHIRP,
    5: PHASE_CODED,
    6: FREQUENCY_AGILE,
    7: PRI_AGILE,
    8: COMPLEX,
    9: LPI};

  static const fb.Reader<WaveformType> reader = _WaveformTypeReader();

  @override
  String toString() {
    return 'WaveformType{value: $value}';
  }
}

class _WaveformTypeReader extends fb.Reader<WaveformType> {
  const _WaveformTypeReader();

  @override
  int get size => 1;

  @override
  WaveformType read(fb.BufferContext bc, int offset) =>
      WaveformType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Electronic Warfare
class EWR {
  EWR._(this._bc, this._bcOffset);
  factory EWR(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<EWR> reader = _EWRReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get SYSTEM_ID => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 4, 0);
  int get ENTITY_ID => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 6, 0);
  bool get ESM_ACTIVE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 8, false);
  bool get ECM_ACTIVE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 10, false);
  bool get RWR_ACTIVE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 12, false);
  List<String>? get ESM_CONTACTS => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 14);
  List<String>? get ACTIVE_JAMMING => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 16);
  String? get COUNTERMEASURES => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);
  List<String>? get THREAT_WARNINGS => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 20);
  int get EMCON_LEVEL => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 22, 0);
  int get LAST_UPDATE_MS => const fb.Int64Reader().vTableGet(_bc, _bcOffset, 24, 0);

  @override
  String toString() {
    return 'EWR{SYSTEM_ID: ${SYSTEM_ID}, ENTITY_ID: ${ENTITY_ID}, ESM_ACTIVE: ${ESM_ACTIVE}, ECM_ACTIVE: ${ECM_ACTIVE}, RWR_ACTIVE: ${RWR_ACTIVE}, ESM_CONTACTS: ${ESM_CONTACTS}, ACTIVE_JAMMING: ${ACTIVE_JAMMING}, COUNTERMEASURES: ${COUNTERMEASURES}, THREAT_WARNINGS: ${THREAT_WARNINGS}, EMCON_LEVEL: ${EMCON_LEVEL}, LAST_UPDATE_MS: ${LAST_UPDATE_MS}}';
  }
}

class _EWRReader extends fb.TableReader<EWR> {
  const _EWRReader();

  @override
  EWR createObject(fb.BufferContext bc, int offset) => 
    EWR._(bc, offset);
}

class EWRBuilder {
  EWRBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(11);
  }

  int addSystemId(int? SYSTEM_ID) {
    fbBuilder.addUint32(0, SYSTEM_ID);
    return fbBuilder.offset;
  }
  int addEntityId(int? ENTITY_ID) {
    fbBuilder.addUint32(1, ENTITY_ID);
    return fbBuilder.offset;
  }
  int addEsmActive(bool? ESM_ACTIVE) {
    fbBuilder.addBool(2, ESM_ACTIVE);
    return fbBuilder.offset;
  }
  int addEcmActive(bool? ECM_ACTIVE) {
    fbBuilder.addBool(3, ECM_ACTIVE);
    return fbBuilder.offset;
  }
  int addRwrActive(bool? RWR_ACTIVE) {
    fbBuilder.addBool(4, RWR_ACTIVE);
    return fbBuilder.offset;
  }
  int addEsmContactsOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addActiveJammingOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addCountermeasuresOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }
  int addThreatWarningsOffset(int? offset) {
    fbBuilder.addOffset(8, offset);
    return fbBuilder.offset;
  }
  int addEmconLevel(int? EMCON_LEVEL) {
    fbBuilder.addUint8(9, EMCON_LEVEL);
    return fbBuilder.offset;
  }
  int addLastUpdateMs(int? LAST_UPDATE_MS) {
    fbBuilder.addInt64(10, LAST_UPDATE_MS);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class EWRObjectBuilder extends fb.ObjectBuilder {
  final int? _SYSTEM_ID;
  final int? _ENTITY_ID;
  final bool? _ESM_ACTIVE;
  final bool? _ECM_ACTIVE;
  final bool? _RWR_ACTIVE;
  final List<String>? _ESM_CONTACTS;
  final List<String>? _ACTIVE_JAMMING;
  final String? _COUNTERMEASURES;
  final List<String>? _THREAT_WARNINGS;
  final int? _EMCON_LEVEL;
  final int? _LAST_UPDATE_MS;

  EWRObjectBuilder({
    int? SYSTEM_ID,
    int? ENTITY_ID,
    bool? ESM_ACTIVE,
    bool? ECM_ACTIVE,
    bool? RWR_ACTIVE,
    List<String>? ESM_CONTACTS,
    List<String>? ACTIVE_JAMMING,
    String? COUNTERMEASURES,
    List<String>? THREAT_WARNINGS,
    int? EMCON_LEVEL,
    int? LAST_UPDATE_MS,
  })
      : _SYSTEM_ID = SYSTEM_ID,
        _ENTITY_ID = ENTITY_ID,
        _ESM_ACTIVE = ESM_ACTIVE,
        _ECM_ACTIVE = ECM_ACTIVE,
        _RWR_ACTIVE = RWR_ACTIVE,
        _ESM_CONTACTS = ESM_CONTACTS,
        _ACTIVE_JAMMING = ACTIVE_JAMMING,
        _COUNTERMEASURES = COUNTERMEASURES,
        _THREAT_WARNINGS = THREAT_WARNINGS,
        _EMCON_LEVEL = EMCON_LEVEL,
        _LAST_UPDATE_MS = LAST_UPDATE_MS;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? ESM_CONTACTSOffset = _ESM_CONTACTS == null ? null
        : fbBuilder.writeList(_ESM_CONTACTS!.map(fbBuilder.writeString).toList());
    final int? ACTIVE_JAMMINGOffset = _ACTIVE_JAMMING == null ? null
        : fbBuilder.writeList(_ACTIVE_JAMMING!.map(fbBuilder.writeString).toList());
    final int? COUNTERMEASURESOffset = _COUNTERMEASURES == null ? null
        : fbBuilder.writeString(_COUNTERMEASURES!);
    final int? THREAT_WARNINGSOffset = _THREAT_WARNINGS == null ? null
        : fbBuilder.writeList(_THREAT_WARNINGS!.map(fbBuilder.writeString).toList());
    fbBuilder.startTable(11);
    fbBuilder.addUint32(0, _SYSTEM_ID);
    fbBuilder.addUint32(1, _ENTITY_ID);
    fbBuilder.addBool(2, _ESM_ACTIVE);
    fbBuilder.addBool(3, _ECM_ACTIVE);
    fbBuilder.addBool(4, _RWR_ACTIVE);
    fbBuilder.addOffset(5, ESM_CONTACTSOffset);
    fbBuilder.addOffset(6, ACTIVE_JAMMINGOffset);
    fbBuilder.addOffset(7, COUNTERMEASURESOffset);
    fbBuilder.addOffset(8, THREAT_WARNINGSOffset);
    fbBuilder.addUint8(9, _EMCON_LEVEL);
    fbBuilder.addInt64(10, _LAST_UPDATE_MS);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
