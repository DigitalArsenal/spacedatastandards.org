// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class DragModel {
  final int value;
  const DragModel._(this.value);

  factory DragModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum DragModel');
    }
    return result;
  }

  static DragModel? _createOrNull(int? value) => 
      value == null ? null : DragModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 10;
  static bool containsValue(int value) => values.containsKey(value);

  static const DragModel G1 = DragModel._(0);
  static const DragModel G2 = DragModel._(1);
  static const DragModel G5 = DragModel._(2);
  static const DragModel G6 = DragModel._(3);
  static const DragModel G7 = DragModel._(4);
  static const DragModel G8 = DragModel._(5);
  static const DragModel GI = DragModel._(6);
  static const DragModel GL = DragModel._(7);
  static const DragModel GS = DragModel._(8);
  static const DragModel RA4 = DragModel._(9);
  static const DragModel CUSTOM = DragModel._(10);
  static const Map<int, DragModel> values = {
    0: G1,
    1: G2,
    2: G5,
    3: G6,
    4: G7,
    5: G8,
    6: GI,
    7: GL,
    8: GS,
    9: RA4,
    10: CUSTOM};

  static const fb.Reader<DragModel> reader = _DragModelReader();

  @override
  String toString() {
    return 'DragModel{value: $value}';
  }
}

class _DragModelReader extends fb.Reader<DragModel> {
  const _DragModelReader();

  @override
  int get size => 1;

  @override
  DragModel read(fb.BufferContext bc, int offset) =>
      DragModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

class BallisticModel {
  final int value;
  const BallisticModel._(this.value);

  factory BallisticModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum BallisticModel');
    }
    return result;
  }

  static BallisticModel? _createOrNull(int? value) => 
      value == null ? null : BallisticModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const BallisticModel POINT_MASS_2D = BallisticModel._(0);
  static const BallisticModel POINT_MASS_3D = BallisticModel._(1);
  static const BallisticModel MODIFIED_POINT_MASS = BallisticModel._(2);
  static const BallisticModel SIX_DOF = BallisticModel._(3);
  static const Map<int, BallisticModel> values = {
    0: POINT_MASS_2D,
    1: POINT_MASS_3D,
    2: MODIFIED_POINT_MASS,
    3: SIX_DOF};

  static const fb.Reader<BallisticModel> reader = _BallisticModelReader();

  @override
  String toString() {
    return 'BallisticModel{value: $value}';
  }
}

class _BallisticModelReader extends fb.Reader<BallisticModel> {
  const _BallisticModelReader();

  @override
  int get size => 1;

  @override
  BallisticModel read(fb.BufferContext bc, int offset) =>
      BallisticModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

class ProjectileType {
  final int value;
  const ProjectileType._(this.value);

  factory ProjectileType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum ProjectileType');
    }
    return result;
  }

  static ProjectileType? _createOrNull(int? value) => 
      value == null ? null : ProjectileType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 15;
  static bool containsValue(int value) => values.containsKey(value);

  static const ProjectileType BALL = ProjectileType._(0);
  static const ProjectileType HOLLOW_POINT = ProjectileType._(1);
  static const ProjectileType BOAT_TAIL = ProjectileType._(2);
  static const ProjectileType ARMOR_PIERCING = ProjectileType._(3);
  static const ProjectileType ARMOR_PIERCING_INCENDIARY = ProjectileType._(4);
  static const ProjectileType TRACER = ProjectileType._(5);
  static const ProjectileType SABOT = ProjectileType._(6);
  static const ProjectileType SUBCALIBER = ProjectileType._(7);
  static const ProjectileType HEAT = ProjectileType._(8);
  static const ProjectileType HESH = ProjectileType._(9);
  static const ProjectileType HE = ProjectileType._(10);
  static const ProjectileType APFSDS = ProjectileType._(11);
  static const ProjectileType ARTILLERY_HE = ProjectileType._(12);
  static const ProjectileType MORTAR = ProjectileType._(13);
  static const ProjectileType GRENADE = ProjectileType._(14);
  static const ProjectileType ROCKET = ProjectileType._(15);
  static const Map<int, ProjectileType> values = {
    0: BALL,
    1: HOLLOW_POINT,
    2: BOAT_TAIL,
    3: ARMOR_PIERCING,
    4: ARMOR_PIERCING_INCENDIARY,
    5: TRACER,
    6: SABOT,
    7: SUBCALIBER,
    8: HEAT,
    9: HESH,
    10: HE,
    11: APFSDS,
    12: ARTILLERY_HE,
    13: MORTAR,
    14: GRENADE,
    15: ROCKET};

  static const fb.Reader<ProjectileType> reader = _ProjectileTypeReader();

  @override
  String toString() {
    return 'ProjectileType{value: $value}';
  }
}

class _ProjectileTypeReader extends fb.Reader<ProjectileType> {
  const _ProjectileTypeReader();

  @override
  int get size => 1;

  @override
  ProjectileType read(fb.BufferContext bc, int offset) =>
      ProjectileType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class BalStabilizationType {
  final int value;
  const BalStabilizationType._(this.value);

  factory BalStabilizationType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum BalStabilizationType');
    }
    return result;
  }

  static BalStabilizationType? _createOrNull(int? value) => 
      value == null ? null : BalStabilizationType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const BalStabilizationType SPIN = BalStabilizationType._(0);
  static const BalStabilizationType FIN = BalStabilizationType._(1);
  static const BalStabilizationType DUAL = BalStabilizationType._(2);
  static const Map<int, BalStabilizationType> values = {
    0: SPIN,
    1: FIN,
    2: DUAL};

  static const fb.Reader<BalStabilizationType> reader = _BalStabilizationTypeReader();

  @override
  String toString() {
    return 'BalStabilizationType{value: $value}';
  }
}

class _BalStabilizationTypeReader extends fb.Reader<BalStabilizationType> {
  const _BalStabilizationTypeReader();

  @override
  int get size => 1;

  @override
  BalStabilizationType read(fb.BufferContext bc, int offset) =>
      BalStabilizationType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class PenetrationModel {
  final int value;
  const PenetrationModel._(this.value);

  factory PenetrationModel.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum PenetrationModel');
    }
    return result;
  }

  static PenetrationModel? _createOrNull(int? value) => 
      value == null ? null : PenetrationModel.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 4;
  static bool containsValue(int value) => values.containsKey(value);

  static const PenetrationModel DE_MARRE = PenetrationModel._(0);
  static const PenetrationModel THOR = PenetrationModel._(1);
  static const PenetrationModel ODERMATT = PenetrationModel._(2);
  static const PenetrationModel ANDERSON = PenetrationModel._(3);
  static const PenetrationModel BRL = PenetrationModel._(4);
  static const Map<int, PenetrationModel> values = {
    0: DE_MARRE,
    1: THOR,
    2: ODERMATT,
    3: ANDERSON,
    4: BRL};

  static const fb.Reader<PenetrationModel> reader = _PenetrationModelReader();

  @override
  String toString() {
    return 'PenetrationModel{value: $value}';
  }
}

class _PenetrationModelReader extends fb.Reader<PenetrationModel> {
  const _PenetrationModelReader();

  @override
  int get size => 1;

  @override
  PenetrationModel read(fb.BufferContext bc, int offset) =>
      PenetrationModel.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Ballistics
class BAL {
  BAL._(this._bc, this._bcOffset);
  factory BAL(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<BAL> reader = _BALReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get COMMAND => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get TRAJECTORY_REQUEST => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  String? get TABLE_REQUEST => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  String? get FIRE_CONTROL => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
  String? get PENETRATION_PROJECTILE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get PENETRATION_ARMOR => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  double get IMPACT_VELOCITY_MPS => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  double get IMPACT_ANGLE_DEG => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 18, 0.0);

  @override
  String toString() {
    return 'BAL{COMMAND: ${COMMAND}, TRAJECTORY_REQUEST: ${TRAJECTORY_REQUEST}, TABLE_REQUEST: ${TABLE_REQUEST}, FIRE_CONTROL: ${FIRE_CONTROL}, PENETRATION_PROJECTILE: ${PENETRATION_PROJECTILE}, PENETRATION_ARMOR: ${PENETRATION_ARMOR}, IMPACT_VELOCITY_MPS: ${IMPACT_VELOCITY_MPS}, IMPACT_ANGLE_DEG: ${IMPACT_ANGLE_DEG}}';
  }
}

class _BALReader extends fb.TableReader<BAL> {
  const _BALReader();

  @override
  BAL createObject(fb.BufferContext bc, int offset) => 
    BAL._(bc, offset);
}

class BALBuilder {
  BALBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(8);
  }

  int addCommandOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addTrajectoryRequestOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addTableRequestOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addFireControlOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addPenetrationProjectileOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addPenetrationArmorOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addImpactVelocityMps(double? IMPACT_VELOCITY_MPS) {
    fbBuilder.addFloat64(6, IMPACT_VELOCITY_MPS);
    return fbBuilder.offset;
  }
  int addImpactAngleDeg(double? IMPACT_ANGLE_DEG) {
    fbBuilder.addFloat64(7, IMPACT_ANGLE_DEG);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class BALObjectBuilder extends fb.ObjectBuilder {
  final String? _COMMAND;
  final String? _TRAJECTORY_REQUEST;
  final String? _TABLE_REQUEST;
  final String? _FIRE_CONTROL;
  final String? _PENETRATION_PROJECTILE;
  final String? _PENETRATION_ARMOR;
  final double? _IMPACT_VELOCITY_MPS;
  final double? _IMPACT_ANGLE_DEG;

  BALObjectBuilder({
    String? COMMAND,
    String? TRAJECTORY_REQUEST,
    String? TABLE_REQUEST,
    String? FIRE_CONTROL,
    String? PENETRATION_PROJECTILE,
    String? PENETRATION_ARMOR,
    double? IMPACT_VELOCITY_MPS,
    double? IMPACT_ANGLE_DEG,
  })
      : _COMMAND = COMMAND,
        _TRAJECTORY_REQUEST = TRAJECTORY_REQUEST,
        _TABLE_REQUEST = TABLE_REQUEST,
        _FIRE_CONTROL = FIRE_CONTROL,
        _PENETRATION_PROJECTILE = PENETRATION_PROJECTILE,
        _PENETRATION_ARMOR = PENETRATION_ARMOR,
        _IMPACT_VELOCITY_MPS = IMPACT_VELOCITY_MPS,
        _IMPACT_ANGLE_DEG = IMPACT_ANGLE_DEG;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? COMMANDOffset = _COMMAND == null ? null
        : fbBuilder.writeString(_COMMAND!);
    final int? TRAJECTORY_REQUESTOffset = _TRAJECTORY_REQUEST == null ? null
        : fbBuilder.writeString(_TRAJECTORY_REQUEST!);
    final int? TABLE_REQUESTOffset = _TABLE_REQUEST == null ? null
        : fbBuilder.writeString(_TABLE_REQUEST!);
    final int? FIRE_CONTROLOffset = _FIRE_CONTROL == null ? null
        : fbBuilder.writeString(_FIRE_CONTROL!);
    final int? PENETRATION_PROJECTILEOffset = _PENETRATION_PROJECTILE == null ? null
        : fbBuilder.writeString(_PENETRATION_PROJECTILE!);
    final int? PENETRATION_ARMOROffset = _PENETRATION_ARMOR == null ? null
        : fbBuilder.writeString(_PENETRATION_ARMOR!);
    fbBuilder.startTable(8);
    fbBuilder.addOffset(0, COMMANDOffset);
    fbBuilder.addOffset(1, TRAJECTORY_REQUESTOffset);
    fbBuilder.addOffset(2, TABLE_REQUESTOffset);
    fbBuilder.addOffset(3, FIRE_CONTROLOffset);
    fbBuilder.addOffset(4, PENETRATION_PROJECTILEOffset);
    fbBuilder.addOffset(5, PENETRATION_ARMOROffset);
    fbBuilder.addFloat64(6, _IMPACT_VELOCITY_MPS);
    fbBuilder.addFloat64(7, _IMPACT_ANGLE_DEG);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
