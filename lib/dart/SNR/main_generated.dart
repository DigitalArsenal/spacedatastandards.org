// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class SensorType {
  final int value;
  const SensorType._(this.value);

  factory SensorType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SensorType');
    }
    return result;
  }

  static SensorType? _createOrNull(int? value) => 
      value == null ? null : SensorType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 15;
  static bool containsValue(int value) => values.containsKey(value);

  static const SensorType RADAR_PULSE = SensorType._(0);
  static const SensorType RADAR_DOPPLER = SensorType._(1);
  static const SensorType RADAR_CW = SensorType._(2);
  static const SensorType RADAR_AESA = SensorType._(3);
  static const SensorType RADAR_PESA = SensorType._(4);
  static const SensorType IR_SEARCH = SensorType._(5);
  static const SensorType IR_IMAGING = SensorType._(6);
  static const SensorType EO_TV = SensorType._(7);
  static const SensorType EO_LLLTV = SensorType._(8);
  static const SensorType LASER_DESIGNATOR = SensorType._(9);
  static const SensorType LASER_RANGEFINDER = SensorType._(10);
  static const SensorType RWR = SensorType._(11);
  static const SensorType MAW = SensorType._(12);
  static const SensorType SONAR_ACTIVE = SensorType._(13);
  static const SensorType SONAR_PASSIVE = SensorType._(14);
  static const SensorType ACOUSTIC = SensorType._(15);
  static const Map<int, SensorType> values = {
    0: RADAR_PULSE,
    1: RADAR_DOPPLER,
    2: RADAR_CW,
    3: RADAR_AESA,
    4: RADAR_PESA,
    5: IR_SEARCH,
    6: IR_IMAGING,
    7: EO_TV,
    8: EO_LLLTV,
    9: LASER_DESIGNATOR,
    10: LASER_RANGEFINDER,
    11: RWR,
    12: MAW,
    13: SONAR_ACTIVE,
    14: SONAR_PASSIVE,
    15: ACOUSTIC};

  static const fb.Reader<SensorType> reader = _SensorTypeReader();

  @override
  String toString() {
    return 'SensorType{value: $value}';
  }
}

class _SensorTypeReader extends fb.Reader<SensorType> {
  const _SensorTypeReader();

  @override
  int get size => 1;

  @override
  SensorType read(fb.BufferContext bc, int offset) =>
      SensorType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class SensorMode {
  final int value;
  const SensorMode._(this.value);

  factory SensorMode.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SensorMode');
    }
    return result;
  }

  static SensorMode? _createOrNull(int? value) => 
      value == null ? null : SensorMode.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 7;
  static bool containsValue(int value) => values.containsKey(value);

  static const SensorMode OFF = SensorMode._(0);
  static const SensorMode STANDBY = SensorMode._(1);
  static const SensorMode SEARCH = SensorMode._(2);
  static const SensorMode ACQUISITION = SensorMode._(3);
  static const SensorMode TRACK = SensorMode._(4);
  static const SensorMode TRACK_WHILE_SCAN = SensorMode._(5);
  static const SensorMode DESIGNATE = SensorMode._(6);
  static const SensorMode JAMMED = SensorMode._(7);
  static const Map<int, SensorMode> values = {
    0: OFF,
    1: STANDBY,
    2: SEARCH,
    3: ACQUISITION,
    4: TRACK,
    5: TRACK_WHILE_SCAN,
    6: DESIGNATE,
    7: JAMMED};

  static const fb.Reader<SensorMode> reader = _SensorModeReader();

  @override
  String toString() {
    return 'SensorMode{value: $value}';
  }
}

class _SensorModeReader extends fb.Reader<SensorMode> {
  const _SensorModeReader();

  @override
  int get size => 1;

  @override
  SensorMode read(fb.BufferContext bc, int offset) =>
      SensorMode.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TrackQuality {
  final int value;
  const TrackQuality._(this.value);

  factory TrackQuality.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TrackQuality');
    }
    return result;
  }

  static TrackQuality? _createOrNull(int? value) => 
      value == null ? null : TrackQuality.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  static const TrackQuality NONE = TrackQuality._(0);
  static const TrackQuality TENTATIVE = TrackQuality._(1);
  static const TrackQuality FIRM = TrackQuality._(2);
  static const TrackQuality LOCKED = TrackQuality._(3);
  static const TrackQuality COASTING = TrackQuality._(4);
  static const TrackQuality LOST = TrackQuality._(5);
  static const Map<int, TrackQuality> values = {
    0: NONE,
    1: TENTATIVE,
    2: FIRM,
    3: LOCKED,
    4: COASTING,
    5: LOST};

  static const fb.Reader<TrackQuality> reader = _TrackQualityReader();

  @override
  String toString() {
    return 'TrackQuality{value: $value}';
  }
}

class _TrackQualityReader extends fb.Reader<TrackQuality> {
  const _TrackQualityReader();

  @override
  int get size => 1;

  @override
  TrackQuality read(fb.BufferContext bc, int offset) =>
      TrackQuality.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Sensor Systems
class SNR {
  SNR._(this._bc, this._bcOffset);
  factory SNR(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SNR> reader = _SNRReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get TYPE => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 0);
  int get MODE => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 6, 0);
  int get RESERVED1 => const fb.Uint16Reader().vTableGet(_bc, _bcOffset, 8, 0);
  double get MAX_RANGE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 10, 0.0);
  double get MIN_RANGE => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 12, 0.0);
  double get FOV_AZIMUTH => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 14, 0.0);
  double get FOV_ELEVATION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 16, 0.0);
  double get ANGULAR_RESOLUTION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 18, 0.0);
  double get RANGE_RESOLUTION => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
  double get UPDATE_RATE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
  double get DETECTION_THRESHOLD => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  double get AZIMUTH_SCAN_RATE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 26, 0.0);
  double get ELEVATION_SCAN_RATE => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 28, 0.0);
  double get POWER => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 30, 0.0);
  double get FREQUENCY => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 32, 0.0);
  List<int>? get RESERVED => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 34);

  @override
  String toString() {
    return 'SNR{TYPE: ${TYPE}, MODE: ${MODE}, RESERVED1: ${RESERVED1}, MAX_RANGE: ${MAX_RANGE}, MIN_RANGE: ${MIN_RANGE}, FOV_AZIMUTH: ${FOV_AZIMUTH}, FOV_ELEVATION: ${FOV_ELEVATION}, ANGULAR_RESOLUTION: ${ANGULAR_RESOLUTION}, RANGE_RESOLUTION: ${RANGE_RESOLUTION}, UPDATE_RATE: ${UPDATE_RATE}, DETECTION_THRESHOLD: ${DETECTION_THRESHOLD}, AZIMUTH_SCAN_RATE: ${AZIMUTH_SCAN_RATE}, ELEVATION_SCAN_RATE: ${ELEVATION_SCAN_RATE}, POWER: ${POWER}, FREQUENCY: ${FREQUENCY}, RESERVED: ${RESERVED}}';
  }
}

class _SNRReader extends fb.TableReader<SNR> {
  const _SNRReader();

  @override
  SNR createObject(fb.BufferContext bc, int offset) => 
    SNR._(bc, offset);
}

class SNRBuilder {
  SNRBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(16);
  }

  int addType(int? TYPE) {
    fbBuilder.addUint8(0, TYPE);
    return fbBuilder.offset;
  }
  int addMode(int? MODE) {
    fbBuilder.addUint8(1, MODE);
    return fbBuilder.offset;
  }
  int addReserved1(int? RESERVED1) {
    fbBuilder.addUint16(2, RESERVED1);
    return fbBuilder.offset;
  }
  int addMaxRange(double? MAX_RANGE) {
    fbBuilder.addFloat64(3, MAX_RANGE);
    return fbBuilder.offset;
  }
  int addMinRange(double? MIN_RANGE) {
    fbBuilder.addFloat64(4, MIN_RANGE);
    return fbBuilder.offset;
  }
  int addFovAzimuth(double? FOV_AZIMUTH) {
    fbBuilder.addFloat32(5, FOV_AZIMUTH);
    return fbBuilder.offset;
  }
  int addFovElevation(double? FOV_ELEVATION) {
    fbBuilder.addFloat32(6, FOV_ELEVATION);
    return fbBuilder.offset;
  }
  int addAngularResolution(double? ANGULAR_RESOLUTION) {
    fbBuilder.addFloat32(7, ANGULAR_RESOLUTION);
    return fbBuilder.offset;
  }
  int addRangeResolution(double? RANGE_RESOLUTION) {
    fbBuilder.addFloat32(8, RANGE_RESOLUTION);
    return fbBuilder.offset;
  }
  int addUpdateRate(double? UPDATE_RATE) {
    fbBuilder.addFloat32(9, UPDATE_RATE);
    return fbBuilder.offset;
  }
  int addDetectionThreshold(double? DETECTION_THRESHOLD) {
    fbBuilder.addFloat32(10, DETECTION_THRESHOLD);
    return fbBuilder.offset;
  }
  int addAzimuthScanRate(double? AZIMUTH_SCAN_RATE) {
    fbBuilder.addFloat32(11, AZIMUTH_SCAN_RATE);
    return fbBuilder.offset;
  }
  int addElevationScanRate(double? ELEVATION_SCAN_RATE) {
    fbBuilder.addFloat32(12, ELEVATION_SCAN_RATE);
    return fbBuilder.offset;
  }
  int addPower(double? POWER) {
    fbBuilder.addFloat32(13, POWER);
    return fbBuilder.offset;
  }
  int addFrequency(double? FREQUENCY) {
    fbBuilder.addFloat32(14, FREQUENCY);
    return fbBuilder.offset;
  }
  int addReservedOffset(int? offset) {
    fbBuilder.addOffset(15, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SNRObjectBuilder extends fb.ObjectBuilder {
  final int? _TYPE;
  final int? _MODE;
  final int? _RESERVED1;
  final double? _MAX_RANGE;
  final double? _MIN_RANGE;
  final double? _FOV_AZIMUTH;
  final double? _FOV_ELEVATION;
  final double? _ANGULAR_RESOLUTION;
  final double? _RANGE_RESOLUTION;
  final double? _UPDATE_RATE;
  final double? _DETECTION_THRESHOLD;
  final double? _AZIMUTH_SCAN_RATE;
  final double? _ELEVATION_SCAN_RATE;
  final double? _POWER;
  final double? _FREQUENCY;
  final List<int>? _RESERVED;

  SNRObjectBuilder({
    int? TYPE,
    int? MODE,
    int? RESERVED1,
    double? MAX_RANGE,
    double? MIN_RANGE,
    double? FOV_AZIMUTH,
    double? FOV_ELEVATION,
    double? ANGULAR_RESOLUTION,
    double? RANGE_RESOLUTION,
    double? UPDATE_RATE,
    double? DETECTION_THRESHOLD,
    double? AZIMUTH_SCAN_RATE,
    double? ELEVATION_SCAN_RATE,
    double? POWER,
    double? FREQUENCY,
    List<int>? RESERVED,
  })
      : _TYPE = TYPE,
        _MODE = MODE,
        _RESERVED1 = RESERVED1,
        _MAX_RANGE = MAX_RANGE,
        _MIN_RANGE = MIN_RANGE,
        _FOV_AZIMUTH = FOV_AZIMUTH,
        _FOV_ELEVATION = FOV_ELEVATION,
        _ANGULAR_RESOLUTION = ANGULAR_RESOLUTION,
        _RANGE_RESOLUTION = RANGE_RESOLUTION,
        _UPDATE_RATE = UPDATE_RATE,
        _DETECTION_THRESHOLD = DETECTION_THRESHOLD,
        _AZIMUTH_SCAN_RATE = AZIMUTH_SCAN_RATE,
        _ELEVATION_SCAN_RATE = ELEVATION_SCAN_RATE,
        _POWER = POWER,
        _FREQUENCY = FREQUENCY,
        _RESERVED = RESERVED;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? RESERVEDOffset = _RESERVED == null ? null
        : fbBuilder.writeListUint8(_RESERVED!);
    fbBuilder.startTable(16);
    fbBuilder.addUint8(0, _TYPE);
    fbBuilder.addUint8(1, _MODE);
    fbBuilder.addUint16(2, _RESERVED1);
    fbBuilder.addFloat64(3, _MAX_RANGE);
    fbBuilder.addFloat64(4, _MIN_RANGE);
    fbBuilder.addFloat32(5, _FOV_AZIMUTH);
    fbBuilder.addFloat32(6, _FOV_ELEVATION);
    fbBuilder.addFloat32(7, _ANGULAR_RESOLUTION);
    fbBuilder.addFloat32(8, _RANGE_RESOLUTION);
    fbBuilder.addFloat32(9, _UPDATE_RATE);
    fbBuilder.addFloat32(10, _DETECTION_THRESHOLD);
    fbBuilder.addFloat32(11, _AZIMUTH_SCAN_RATE);
    fbBuilder.addFloat32(12, _ELEVATION_SCAN_RATE);
    fbBuilder.addFloat32(13, _POWER);
    fbBuilder.addFloat32(14, _FREQUENCY);
    fbBuilder.addOffset(15, RESERVEDOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
