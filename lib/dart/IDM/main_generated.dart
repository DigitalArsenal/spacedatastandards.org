// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


///  Different types of polarization in EMT
class PolarizationType {
  final int value;
  const PolarizationType._(this.value);

  factory PolarizationType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum PolarizationType');
    }
    return result;
  }

  static PolarizationType? _createOrNull(int? value) => 
      value == null ? null : PolarizationType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const PolarizationType linear = PolarizationType._(0);
  static const PolarizationType circular = PolarizationType._(1);
  static const PolarizationType elliptical = PolarizationType._(2);
  static const PolarizationType unpolarized = PolarizationType._(3);
  static const Map<int, PolarizationType> values = {
    0: linear,
    1: circular,
    2: elliptical,
    3: unpolarized};

  static const fb.Reader<PolarizationType> reader = _PolarizationTypeReader();

  @override
  String toString() {
    return 'PolarizationType{value: $value}';
  }
}

class _PolarizationTypeReader extends fb.Reader<PolarizationType> {
  const _PolarizationTypeReader();

  @override
  int get size => 1;

  @override
  PolarizationType read(fb.BufferContext bc, int offset) =>
      PolarizationType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Simple polarization types
class SimplePolarization {
  final int value;
  const SimplePolarization._(this.value);

  factory SimplePolarization.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SimplePolarization');
    }
    return result;
  }

  static SimplePolarization? _createOrNull(int? value) => 
      value == null ? null : SimplePolarization.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const SimplePolarization vertical = SimplePolarization._(0);
  static const SimplePolarization horizontal = SimplePolarization._(1);
  static const SimplePolarization leftHandCircular = SimplePolarization._(2);
  static const SimplePolarization rightHandCircular = SimplePolarization._(3);
  static const Map<int, SimplePolarization> values = {
    0: vertical,
    1: horizontal,
    2: leftHandCircular,
    3: rightHandCircular};

  static const fb.Reader<SimplePolarization> reader = _SimplePolarizationReader();

  @override
  String toString() {
    return 'SimplePolarization{value: $value}';
  }
}

class _SimplePolarizationReader extends fb.Reader<SimplePolarization> {
  const _SimplePolarizationReader();

  @override
  int get size => 1;

  @override
  SimplePolarization read(fb.BufferContext bc, int offset) =>
      SimplePolarization.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Enum for the mode of data (real, simulated, synthetic)
class DataMode {
  final int value;
  const DataMode._(this.value);

  factory DataMode.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum DataMode');
    }
    return result;
  }

  static DataMode? _createOrNull(int? value) => 
      value == null ? null : DataMode.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const DataMode REAL = DataMode._(0);
  static const DataMode SIMULATED = DataMode._(1);
  static const DataMode SYNTHETIC = DataMode._(2);
  static const Map<int, DataMode> values = {
    0: REAL,
    1: SIMULATED,
    2: SYNTHETIC};

  static const fb.Reader<DataMode> reader = _DataModeReader();

  @override
  String toString() {
    return 'DataMode{value: $value}';
  }
}

class _DataModeReader extends fb.Reader<DataMode> {
  const _DataModeReader();

  @override
  int get size => 1;

  @override
  DataMode read(fb.BufferContext bc, int offset) =>
      DataMode.fromValue(const fb.Int8Reader().read(bc, offset));
}

class DeviceType {
  final int value;
  const DeviceType._(this.value);

  factory DeviceType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum DeviceType');
    }
    return result;
  }

  static DeviceType? _createOrNull(int? value) => 
      value == null ? null : DeviceType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 45;
  static bool containsValue(int value) => values.containsKey(value);

  ///  Basic or undefined sensor type
  static const DeviceType UNKNOWN = DeviceType._(0);

  ///  General optical sensors
  static const DeviceType OPTICAL = DeviceType._(1);

  ///  Detects infrared radiation
  static const DeviceType INFRARED_SENSOR = DeviceType._(2);

  ///  Sensitive to ultraviolet light
  static const DeviceType ULTRAVIOLET_SENSOR = DeviceType._(3);

  ///  For X-ray detection
  static const DeviceType X_RAY_SENSOR = DeviceType._(4);

  ///  For gamma-ray detection
  static const DeviceType GAMMA_RAY_SENSOR = DeviceType._(5);

  ///  Basic radar systems
  static const DeviceType RADAR = DeviceType._(6);

  ///  Advanced radar with phased array technology
  static const DeviceType PHASED_ARRAY_RADAR = DeviceType._(7);

  ///  For high-resolution imaging
  static const DeviceType SYNTHETIC_APERTURE_RADAR = DeviceType._(8);

  ///  For astronomical observations using bistatic setup
  static const DeviceType BISTATIC_RADIO_TELESCOPE = DeviceType._(9);

  ///  For radio astronomy
  static const DeviceType RADIO_TELESCOPE = DeviceType._(10);

  ///  For atmospheric studies
  static const DeviceType ATMOSPHERIC_SENSOR = DeviceType._(11);

  ///  For observing space weather phenomena
  static const DeviceType SPACE_WEATHER_SENSOR = DeviceType._(12);

  ///  General environmental monitoring
  static const DeviceType ENVIRONMENTAL_SENSOR = DeviceType._(13);

  ///  For measuring seismic activities
  static const DeviceType SEISMIC_SENSOR = DeviceType._(14);

  ///  For gravity measurements
  static const DeviceType GRAVIMETRIC_SENSOR = DeviceType._(15);

  ///  For magnetic field detection
  static const DeviceType MAGNETIC_SENSOR = DeviceType._(16);

  ///  For electromagnetic field analysis
  static const DeviceType ELECTROMAGNETIC_SENSOR = DeviceType._(17);

  ///  For temperature and heat detection
  static const DeviceType THERMAL_SENSOR = DeviceType._(18);

  ///  For detecting chemicals and substances
  static const DeviceType CHEMICAL_SENSOR = DeviceType._(19);

  ///  For biological research and detection
  static const DeviceType BIOLOGICAL_SENSOR = DeviceType._(20);

  ///  For detecting ionizing radiation
  static const DeviceType RADIATION_SENSOR = DeviceType._(21);

  ///  For detecting subatomic particles
  static const DeviceType PARTICLE_DETECTOR = DeviceType._(22);

  ///  Light Detection and Ranging
  static const DeviceType LIDAR = DeviceType._(23);

  ///  Sound Navigation and Ranging
  static const DeviceType SONAR = DeviceType._(24);

  ///  General telescopes for astronomical observations
  static const DeviceType TELESCOPE = DeviceType._(25);

  ///  For spectral analysis
  static const DeviceType SPECTROSCOPIC_SENSOR = DeviceType._(26);

  ///  For measuring light intensity
  static const DeviceType PHOTOMETRIC_SENSOR = DeviceType._(27);

  ///  For analyzing polarization of light
  static const DeviceType POLARIMETRIC_SENSOR = DeviceType._(28);

  ///  For detailed imaging using interference
  static const DeviceType INTERFEROMETRIC_SENSOR = DeviceType._(29);

  ///  Capturing image data at multiple wavelengths
  static const DeviceType MULTISPECTRAL_SENSOR = DeviceType._(30);

  ///  Advanced imaging across many spectral bands
  static const DeviceType HYPERSPECTRAL_SENSOR = DeviceType._(31);

  ///  For Global Positioning System reception
  static const DeviceType GPS_RECEIVER = DeviceType._(32);

  ///  Standard radio communication device
  static const DeviceType RADIO_COMMUNICATIONS = DeviceType._(33);

  ///  Advanced laser communication system
  static const DeviceType LASER_COMMUNICATIONS = DeviceType._(34);

  ///  Satellite communication system
  static const DeviceType SATELLITE_COMMUNICATIONS = DeviceType._(35);

  ///  Device for laser-based experiments and measurements
  static const DeviceType LASER_INSTRUMENT = DeviceType._(36);

  ///  Radio frequency analysis and measurement device
  static const DeviceType RF_ANALYZER = DeviceType._(37);

  ///  Device for ionospheric research
  static const DeviceType IONOSPHERIC_SENSOR = DeviceType._(38);

  ///  Device for laser-based imaging
  static const DeviceType LASER_IMAGING = DeviceType._(39);

  ///  Advanced optical telescope
  static const DeviceType OPTICAL_TELESCOPE = DeviceType._(40);

  ///  Device for high-resolution optical observations
  static const DeviceType HIGH_RESOLUTION_OPTICAL = DeviceType._(41);
  static const DeviceType RADIO = DeviceType._(42);

  ///  Microwave communication device
  static const DeviceType MICROWAVE_TRANSMITTER = DeviceType._(43);

  ///  Device for radio frequency monitoring
  static const DeviceType RF_MONITOR = DeviceType._(44);

  ///  High-frequency radio communication device
  static const DeviceType HF_RADIO_COMMUNICATIONS = DeviceType._(45);
  static const Map<int, DeviceType> values = {
    0: UNKNOWN,
    1: OPTICAL,
    2: INFRARED_SENSOR,
    3: ULTRAVIOLET_SENSOR,
    4: X_RAY_SENSOR,
    5: GAMMA_RAY_SENSOR,
    6: RADAR,
    7: PHASED_ARRAY_RADAR,
    8: SYNTHETIC_APERTURE_RADAR,
    9: BISTATIC_RADIO_TELESCOPE,
    10: RADIO_TELESCOPE,
    11: ATMOSPHERIC_SENSOR,
    12: SPACE_WEATHER_SENSOR,
    13: ENVIRONMENTAL_SENSOR,
    14: SEISMIC_SENSOR,
    15: GRAVIMETRIC_SENSOR,
    16: MAGNETIC_SENSOR,
    17: ELECTROMAGNETIC_SENSOR,
    18: THERMAL_SENSOR,
    19: CHEMICAL_SENSOR,
    20: BIOLOGICAL_SENSOR,
    21: RADIATION_SENSOR,
    22: PARTICLE_DETECTOR,
    23: LIDAR,
    24: SONAR,
    25: TELESCOPE,
    26: SPECTROSCOPIC_SENSOR,
    27: PHOTOMETRIC_SENSOR,
    28: POLARIMETRIC_SENSOR,
    29: INTERFEROMETRIC_SENSOR,
    30: MULTISPECTRAL_SENSOR,
    31: HYPERSPECTRAL_SENSOR,
    32: GPS_RECEIVER,
    33: RADIO_COMMUNICATIONS,
    34: LASER_COMMUNICATIONS,
    35: SATELLITE_COMMUNICATIONS,
    36: LASER_INSTRUMENT,
    37: RF_ANALYZER,
    38: IONOSPHERIC_SENSOR,
    39: LASER_IMAGING,
    40: OPTICAL_TELESCOPE,
    41: HIGH_RESOLUTION_OPTICAL,
    42: RADIO,
    43: MICROWAVE_TRANSMITTER,
    44: RF_MONITOR,
    45: HF_RADIO_COMMUNICATIONS};

  static const fb.Reader<DeviceType> reader = _DeviceTypeReader();

  @override
  String toString() {
    return 'DeviceType{value: $value}';
  }
}

class _DeviceTypeReader extends fb.Reader<DeviceType> {
  const _DeviceTypeReader();

  @override
  int get size => 1;

  @override
  DeviceType read(fb.BufferContext bc, int offset) =>
      DeviceType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Frequency range with lower and upper limits
class FrequencyRange {
  FrequencyRange._(this._bc, this._bcOffset);
  factory FrequencyRange(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<FrequencyRange> reader = _FrequencyRangeReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Lower frequency in MHz
  double get LOWER => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 4, 0.0);
  ///  Upper frequency in MHz
  double get UPPER => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 6, 0.0);

  @override
  String toString() {
    return 'FrequencyRange{LOWER: ${LOWER}, UPPER: ${UPPER}}';
  }
}

class _FrequencyRangeReader extends fb.TableReader<FrequencyRange> {
  const _FrequencyRangeReader();

  @override
  FrequencyRange createObject(fb.BufferContext bc, int offset) => 
    FrequencyRange._(bc, offset);
}

class FrequencyRangeBuilder {
  FrequencyRangeBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addLower(double? LOWER) {
    fbBuilder.addFloat64(0, LOWER);
    return fbBuilder.offset;
  }
  int addUpper(double? UPPER) {
    fbBuilder.addFloat64(1, UPPER);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class FrequencyRangeObjectBuilder extends fb.ObjectBuilder {
  final double? _LOWER;
  final double? _UPPER;

  FrequencyRangeObjectBuilder({
    double? LOWER,
    double? UPPER,
  })
      : _LOWER = LOWER,
        _UPPER = UPPER;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(2);
    fbBuilder.addFloat64(0, _LOWER);
    fbBuilder.addFloat64(1, _UPPER);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Stokes parameters, representing different aspects of polarization
class StokesParameters {
  StokesParameters._(this._bc, this._bcOffset);
  factory StokesParameters(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<StokesParameters> reader = _StokesParametersReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Intensity
  double get I => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 4, 0.0);
  ///  Linear polarization
  double get Q => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 6, 0.0);
  ///  Another linear polarization, orthogonal to Q
  double get U => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 8, 0.0);
  ///  Circular polarization
  double get V => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 10, 0.0);

  @override
  String toString() {
    return 'StokesParameters{I: ${I}, Q: ${Q}, U: ${U}, V: ${V}}';
  }
}

class _StokesParametersReader extends fb.TableReader<StokesParameters> {
  const _StokesParametersReader();

  @override
  StokesParameters createObject(fb.BufferContext bc, int offset) => 
    StokesParameters._(bc, offset);
}

class StokesParametersBuilder {
  StokesParametersBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addI(double? I) {
    fbBuilder.addFloat64(0, I);
    return fbBuilder.offset;
  }
  int addQ(double? Q) {
    fbBuilder.addFloat64(1, Q);
    return fbBuilder.offset;
  }
  int addU(double? U) {
    fbBuilder.addFloat64(2, U);
    return fbBuilder.offset;
  }
  int addV(double? V) {
    fbBuilder.addFloat64(3, V);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class StokesParametersObjectBuilder extends fb.ObjectBuilder {
  final double? _I;
  final double? _Q;
  final double? _U;
  final double? _V;

  StokesParametersObjectBuilder({
    double? I,
    double? Q,
    double? U,
    double? V,
  })
      : _I = I,
        _Q = Q,
        _U = U,
        _V = V;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(4);
    fbBuilder.addFloat64(0, _I);
    fbBuilder.addFloat64(1, _Q);
    fbBuilder.addFloat64(2, _U);
    fbBuilder.addFloat64(3, _V);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Table representing a frequency band with a name and frequency range
class Band {
  Band._(this._bc, this._bcOffset);
  factory Band(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Band> reader = _BandReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Name of the band
  String? get NAME => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Frequency range of the band
  FrequencyRange? get FREQUENCY_RANGE => FrequencyRange.reader.vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'Band{NAME: ${NAME}, FREQUENCY_RANGE: ${FREQUENCY_RANGE}}';
  }
}

class _BandReader extends fb.TableReader<Band> {
  const _BandReader();

  @override
  Band createObject(fb.BufferContext bc, int offset) => 
    Band._(bc, offset);
}

class BandBuilder {
  BandBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addNameOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addFrequencyRangeOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class BandObjectBuilder extends fb.ObjectBuilder {
  final String? _NAME;
  final FrequencyRangeObjectBuilder? _FREQUENCY_RANGE;

  BandObjectBuilder({
    String? NAME,
    FrequencyRangeObjectBuilder? FREQUENCY_RANGE,
  })
      : _NAME = NAME,
        _FREQUENCY_RANGE = FREQUENCY_RANGE;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? NAMEOffset = _NAME == null ? null
        : fbBuilder.writeString(_NAME!);
    final int? FREQUENCY_RANGEOffset = _FREQUENCY_RANGE?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, NAMEOffset);
    fbBuilder.addOffset(1, FREQUENCY_RANGEOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Integrated Device Message
class IDM {
  IDM._(this._bc, this._bcOffset);
  factory IDM(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<IDM> reader = _IDMReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Unique identifier for the EMT
  String? get ID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Name of the EMT
  String? get NAME => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  ///  Mode of the data (real, simulated, synthetic)
  DataMode get DATA_MODE => DataMode.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 8, 0));
  ///  Uplink frequency range
  FrequencyRange? get UPLINK => FrequencyRange.reader.vTableGetNullable(_bc, _bcOffset, 10);
  ///  Downlink frequency range
  FrequencyRange? get DOWNLINK => FrequencyRange.reader.vTableGetNullable(_bc, _bcOffset, 12);
  ///  Beacon frequency range
  FrequencyRange? get BEACON => FrequencyRange.reader.vTableGetNullable(_bc, _bcOffset, 14);
  ///  Bands associated with the EMT
  List<Band>? get BAND => const fb.ListReader<Band>(Band.reader).vTableGetNullable(_bc, _bcOffset, 16);
  ///  Type of polarization used
  PolarizationType get POLARIZATION_TYPE => PolarizationType.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 18, 0));
  ///  Simple polarization configuration
  SimplePolarization get SIMPLE_POLARIZATION => SimplePolarization.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 20, 0));
  ///  Stokes parameters for polarization characterization
  StokesParameters? get STOKES_PARAMETERS => StokesParameters.reader.vTableGetNullable(_bc, _bcOffset, 22);
  ///  Power required in Watts
  double get POWER_REQUIRED => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 24, 0.0);
  ///  Type of power (eg. AC or DC)
  String? get POWER_TYPE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 26);
  ///  Indicates if the EMT can transmit
  bool get TRANSMIT => const fb.BoolReader().vTableGet(_bc, _bcOffset, 28, false);
  ///  Indicates if the EMT can receive
  bool get RECEIVE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 30, false);
  ///  Type of the sensor
  DeviceType get SENSOR_TYPE => DeviceType.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 32, 0));
  ///  Source of the data
  String? get SOURCE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 34);
  ///  Timestamp of the last observation
  String? get LAST_OB_TIME => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 36);
  ///  Lower left elevation limit
  double get LOWER_LEFT_ELEVATION_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 38, 0.0);
  ///  Upper left azimuth limit
  double get UPPER_LEFT_AZIMUTH_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 40, 0.0);
  ///  Lower right elevation limit
  double get LOWER_RIGHT_ELEVATION_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 42, 0.0);
  ///  Lower left azimuth limit
  double get LOWER_LEFT_AZIMUTH_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 44, 0.0);
  ///  Upper right elevation limit
  double get UPPER_RIGHT_ELEVATION_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 46, 0.0);
  ///  Upper right azimuth limit
  double get UPPER_RIGHT_AZIMUTH_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 48, 0.0);
  ///  Lower right azimuth limit
  double get LOWER_RIGHT_AZIMUTH_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 50, 0.0);
  ///  Upper left elevation limit
  double get UPPER_LEFT_ELEVATION_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 52, 0.0);
  ///  Right geostationary belt limit
  double get RIGHT_GEO_BELT_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 54, 0.0);
  ///  Left geostationary belt limit
  double get LEFT_GEO_BELT_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 56, 0.0);
  ///  Magnitude limit of the sensor
  double get MAGNITUDE_LIMIT => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 58, 0.0);
  ///  Indicates if the site is taskable
  bool get TASKABLE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 60, false);

  @override
  String toString() {
    return 'IDM{ID: ${ID}, NAME: ${NAME}, DATA_MODE: ${DATA_MODE}, UPLINK: ${UPLINK}, DOWNLINK: ${DOWNLINK}, BEACON: ${BEACON}, BAND: ${BAND}, POLARIZATION_TYPE: ${POLARIZATION_TYPE}, SIMPLE_POLARIZATION: ${SIMPLE_POLARIZATION}, STOKES_PARAMETERS: ${STOKES_PARAMETERS}, POWER_REQUIRED: ${POWER_REQUIRED}, POWER_TYPE: ${POWER_TYPE}, TRANSMIT: ${TRANSMIT}, RECEIVE: ${RECEIVE}, SENSOR_TYPE: ${SENSOR_TYPE}, SOURCE: ${SOURCE}, LAST_OB_TIME: ${LAST_OB_TIME}, LOWER_LEFT_ELEVATION_LIMIT: ${LOWER_LEFT_ELEVATION_LIMIT}, UPPER_LEFT_AZIMUTH_LIMIT: ${UPPER_LEFT_AZIMUTH_LIMIT}, LOWER_RIGHT_ELEVATION_LIMIT: ${LOWER_RIGHT_ELEVATION_LIMIT}, LOWER_LEFT_AZIMUTH_LIMIT: ${LOWER_LEFT_AZIMUTH_LIMIT}, UPPER_RIGHT_ELEVATION_LIMIT: ${UPPER_RIGHT_ELEVATION_LIMIT}, UPPER_RIGHT_AZIMUTH_LIMIT: ${UPPER_RIGHT_AZIMUTH_LIMIT}, LOWER_RIGHT_AZIMUTH_LIMIT: ${LOWER_RIGHT_AZIMUTH_LIMIT}, UPPER_LEFT_ELEVATION_LIMIT: ${UPPER_LEFT_ELEVATION_LIMIT}, RIGHT_GEO_BELT_LIMIT: ${RIGHT_GEO_BELT_LIMIT}, LEFT_GEO_BELT_LIMIT: ${LEFT_GEO_BELT_LIMIT}, MAGNITUDE_LIMIT: ${MAGNITUDE_LIMIT}, TASKABLE: ${TASKABLE}}';
  }
}

class _IDMReader extends fb.TableReader<IDM> {
  const _IDMReader();

  @override
  IDM createObject(fb.BufferContext bc, int offset) => 
    IDM._(bc, offset);
}

class IDMBuilder {
  IDMBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(29);
  }

  int addIdOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addNameOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addDataMode(DataMode? DATA_MODE) {
    fbBuilder.addInt8(2, DATA_MODE?.value);
    return fbBuilder.offset;
  }
  int addUplinkOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addDownlinkOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addBeaconOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addBandOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addPolarizationType(PolarizationType? POLARIZATION_TYPE) {
    fbBuilder.addInt8(7, POLARIZATION_TYPE?.value);
    return fbBuilder.offset;
  }
  int addSimplePolarization(SimplePolarization? SIMPLE_POLARIZATION) {
    fbBuilder.addInt8(8, SIMPLE_POLARIZATION?.value);
    return fbBuilder.offset;
  }
  int addStokesParametersOffset(int? offset) {
    fbBuilder.addOffset(9, offset);
    return fbBuilder.offset;
  }
  int addPowerRequired(double? POWER_REQUIRED) {
    fbBuilder.addFloat64(10, POWER_REQUIRED);
    return fbBuilder.offset;
  }
  int addPowerTypeOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }
  int addTransmit(bool? TRANSMIT) {
    fbBuilder.addBool(12, TRANSMIT);
    return fbBuilder.offset;
  }
  int addReceive(bool? RECEIVE) {
    fbBuilder.addBool(13, RECEIVE);
    return fbBuilder.offset;
  }
  int addSensorType(DeviceType? SENSOR_TYPE) {
    fbBuilder.addInt8(14, SENSOR_TYPE?.value);
    return fbBuilder.offset;
  }
  int addSourceOffset(int? offset) {
    fbBuilder.addOffset(15, offset);
    return fbBuilder.offset;
  }
  int addLastObTimeOffset(int? offset) {
    fbBuilder.addOffset(16, offset);
    return fbBuilder.offset;
  }
  int addLowerLeftElevationLimit(double? LOWER_LEFT_ELEVATION_LIMIT) {
    fbBuilder.addFloat64(17, LOWER_LEFT_ELEVATION_LIMIT);
    return fbBuilder.offset;
  }
  int addUpperLeftAzimuthLimit(double? UPPER_LEFT_AZIMUTH_LIMIT) {
    fbBuilder.addFloat64(18, UPPER_LEFT_AZIMUTH_LIMIT);
    return fbBuilder.offset;
  }
  int addLowerRightElevationLimit(double? LOWER_RIGHT_ELEVATION_LIMIT) {
    fbBuilder.addFloat64(19, LOWER_RIGHT_ELEVATION_LIMIT);
    return fbBuilder.offset;
  }
  int addLowerLeftAzimuthLimit(double? LOWER_LEFT_AZIMUTH_LIMIT) {
    fbBuilder.addFloat64(20, LOWER_LEFT_AZIMUTH_LIMIT);
    return fbBuilder.offset;
  }
  int addUpperRightElevationLimit(double? UPPER_RIGHT_ELEVATION_LIMIT) {
    fbBuilder.addFloat64(21, UPPER_RIGHT_ELEVATION_LIMIT);
    return fbBuilder.offset;
  }
  int addUpperRightAzimuthLimit(double? UPPER_RIGHT_AZIMUTH_LIMIT) {
    fbBuilder.addFloat64(22, UPPER_RIGHT_AZIMUTH_LIMIT);
    return fbBuilder.offset;
  }
  int addLowerRightAzimuthLimit(double? LOWER_RIGHT_AZIMUTH_LIMIT) {
    fbBuilder.addFloat64(23, LOWER_RIGHT_AZIMUTH_LIMIT);
    return fbBuilder.offset;
  }
  int addUpperLeftElevationLimit(double? UPPER_LEFT_ELEVATION_LIMIT) {
    fbBuilder.addFloat64(24, UPPER_LEFT_ELEVATION_LIMIT);
    return fbBuilder.offset;
  }
  int addRightGeoBeltLimit(double? RIGHT_GEO_BELT_LIMIT) {
    fbBuilder.addFloat64(25, RIGHT_GEO_BELT_LIMIT);
    return fbBuilder.offset;
  }
  int addLeftGeoBeltLimit(double? LEFT_GEO_BELT_LIMIT) {
    fbBuilder.addFloat64(26, LEFT_GEO_BELT_LIMIT);
    return fbBuilder.offset;
  }
  int addMagnitudeLimit(double? MAGNITUDE_LIMIT) {
    fbBuilder.addFloat64(27, MAGNITUDE_LIMIT);
    return fbBuilder.offset;
  }
  int addTaskable(bool? TASKABLE) {
    fbBuilder.addBool(28, TASKABLE);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class IDMObjectBuilder extends fb.ObjectBuilder {
  final String? _ID;
  final String? _NAME;
  final DataMode? _DATA_MODE;
  final FrequencyRangeObjectBuilder? _UPLINK;
  final FrequencyRangeObjectBuilder? _DOWNLINK;
  final FrequencyRangeObjectBuilder? _BEACON;
  final List<BandObjectBuilder>? _BAND;
  final PolarizationType? _POLARIZATION_TYPE;
  final SimplePolarization? _SIMPLE_POLARIZATION;
  final StokesParametersObjectBuilder? _STOKES_PARAMETERS;
  final double? _POWER_REQUIRED;
  final String? _POWER_TYPE;
  final bool? _TRANSMIT;
  final bool? _RECEIVE;
  final DeviceType? _SENSOR_TYPE;
  final String? _SOURCE;
  final String? _LAST_OB_TIME;
  final double? _LOWER_LEFT_ELEVATION_LIMIT;
  final double? _UPPER_LEFT_AZIMUTH_LIMIT;
  final double? _LOWER_RIGHT_ELEVATION_LIMIT;
  final double? _LOWER_LEFT_AZIMUTH_LIMIT;
  final double? _UPPER_RIGHT_ELEVATION_LIMIT;
  final double? _UPPER_RIGHT_AZIMUTH_LIMIT;
  final double? _LOWER_RIGHT_AZIMUTH_LIMIT;
  final double? _UPPER_LEFT_ELEVATION_LIMIT;
  final double? _RIGHT_GEO_BELT_LIMIT;
  final double? _LEFT_GEO_BELT_LIMIT;
  final double? _MAGNITUDE_LIMIT;
  final bool? _TASKABLE;

  IDMObjectBuilder({
    String? ID,
    String? NAME,
    DataMode? DATA_MODE,
    FrequencyRangeObjectBuilder? UPLINK,
    FrequencyRangeObjectBuilder? DOWNLINK,
    FrequencyRangeObjectBuilder? BEACON,
    List<BandObjectBuilder>? BAND,
    PolarizationType? POLARIZATION_TYPE,
    SimplePolarization? SIMPLE_POLARIZATION,
    StokesParametersObjectBuilder? STOKES_PARAMETERS,
    double? POWER_REQUIRED,
    String? POWER_TYPE,
    bool? TRANSMIT,
    bool? RECEIVE,
    DeviceType? SENSOR_TYPE,
    String? SOURCE,
    String? LAST_OB_TIME,
    double? LOWER_LEFT_ELEVATION_LIMIT,
    double? UPPER_LEFT_AZIMUTH_LIMIT,
    double? LOWER_RIGHT_ELEVATION_LIMIT,
    double? LOWER_LEFT_AZIMUTH_LIMIT,
    double? UPPER_RIGHT_ELEVATION_LIMIT,
    double? UPPER_RIGHT_AZIMUTH_LIMIT,
    double? LOWER_RIGHT_AZIMUTH_LIMIT,
    double? UPPER_LEFT_ELEVATION_LIMIT,
    double? RIGHT_GEO_BELT_LIMIT,
    double? LEFT_GEO_BELT_LIMIT,
    double? MAGNITUDE_LIMIT,
    bool? TASKABLE,
  })
      : _ID = ID,
        _NAME = NAME,
        _DATA_MODE = DATA_MODE,
        _UPLINK = UPLINK,
        _DOWNLINK = DOWNLINK,
        _BEACON = BEACON,
        _BAND = BAND,
        _POLARIZATION_TYPE = POLARIZATION_TYPE,
        _SIMPLE_POLARIZATION = SIMPLE_POLARIZATION,
        _STOKES_PARAMETERS = STOKES_PARAMETERS,
        _POWER_REQUIRED = POWER_REQUIRED,
        _POWER_TYPE = POWER_TYPE,
        _TRANSMIT = TRANSMIT,
        _RECEIVE = RECEIVE,
        _SENSOR_TYPE = SENSOR_TYPE,
        _SOURCE = SOURCE,
        _LAST_OB_TIME = LAST_OB_TIME,
        _LOWER_LEFT_ELEVATION_LIMIT = LOWER_LEFT_ELEVATION_LIMIT,
        _UPPER_LEFT_AZIMUTH_LIMIT = UPPER_LEFT_AZIMUTH_LIMIT,
        _LOWER_RIGHT_ELEVATION_LIMIT = LOWER_RIGHT_ELEVATION_LIMIT,
        _LOWER_LEFT_AZIMUTH_LIMIT = LOWER_LEFT_AZIMUTH_LIMIT,
        _UPPER_RIGHT_ELEVATION_LIMIT = UPPER_RIGHT_ELEVATION_LIMIT,
        _UPPER_RIGHT_AZIMUTH_LIMIT = UPPER_RIGHT_AZIMUTH_LIMIT,
        _LOWER_RIGHT_AZIMUTH_LIMIT = LOWER_RIGHT_AZIMUTH_LIMIT,
        _UPPER_LEFT_ELEVATION_LIMIT = UPPER_LEFT_ELEVATION_LIMIT,
        _RIGHT_GEO_BELT_LIMIT = RIGHT_GEO_BELT_LIMIT,
        _LEFT_GEO_BELT_LIMIT = LEFT_GEO_BELT_LIMIT,
        _MAGNITUDE_LIMIT = MAGNITUDE_LIMIT,
        _TASKABLE = TASKABLE;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? IDOffset = _ID == null ? null
        : fbBuilder.writeString(_ID!);
    final int? NAMEOffset = _NAME == null ? null
        : fbBuilder.writeString(_NAME!);
    final int? UPLINKOffset = _UPLINK?.getOrCreateOffset(fbBuilder);
    final int? DOWNLINKOffset = _DOWNLINK?.getOrCreateOffset(fbBuilder);
    final int? BEACONOffset = _BEACON?.getOrCreateOffset(fbBuilder);
    final int? BANDOffset = _BAND == null ? null
        : fbBuilder.writeList(_BAND!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? STOKES_PARAMETERSOffset = _STOKES_PARAMETERS?.getOrCreateOffset(fbBuilder);
    final int? POWER_TYPEOffset = _POWER_TYPE == null ? null
        : fbBuilder.writeString(_POWER_TYPE!);
    final int? SOURCEOffset = _SOURCE == null ? null
        : fbBuilder.writeString(_SOURCE!);
    final int? LAST_OB_TIMEOffset = _LAST_OB_TIME == null ? null
        : fbBuilder.writeString(_LAST_OB_TIME!);
    fbBuilder.startTable(29);
    fbBuilder.addOffset(0, IDOffset);
    fbBuilder.addOffset(1, NAMEOffset);
    fbBuilder.addInt8(2, _DATA_MODE?.value);
    fbBuilder.addOffset(3, UPLINKOffset);
    fbBuilder.addOffset(4, DOWNLINKOffset);
    fbBuilder.addOffset(5, BEACONOffset);
    fbBuilder.addOffset(6, BANDOffset);
    fbBuilder.addInt8(7, _POLARIZATION_TYPE?.value);
    fbBuilder.addInt8(8, _SIMPLE_POLARIZATION?.value);
    fbBuilder.addOffset(9, STOKES_PARAMETERSOffset);
    fbBuilder.addFloat64(10, _POWER_REQUIRED);
    fbBuilder.addOffset(11, POWER_TYPEOffset);
    fbBuilder.addBool(12, _TRANSMIT);
    fbBuilder.addBool(13, _RECEIVE);
    fbBuilder.addInt8(14, _SENSOR_TYPE?.value);
    fbBuilder.addOffset(15, SOURCEOffset);
    fbBuilder.addOffset(16, LAST_OB_TIMEOffset);
    fbBuilder.addFloat64(17, _LOWER_LEFT_ELEVATION_LIMIT);
    fbBuilder.addFloat64(18, _UPPER_LEFT_AZIMUTH_LIMIT);
    fbBuilder.addFloat64(19, _LOWER_RIGHT_ELEVATION_LIMIT);
    fbBuilder.addFloat64(20, _LOWER_LEFT_AZIMUTH_LIMIT);
    fbBuilder.addFloat64(21, _UPPER_RIGHT_ELEVATION_LIMIT);
    fbBuilder.addFloat64(22, _UPPER_RIGHT_AZIMUTH_LIMIT);
    fbBuilder.addFloat64(23, _LOWER_RIGHT_AZIMUTH_LIMIT);
    fbBuilder.addFloat64(24, _UPPER_LEFT_ELEVATION_LIMIT);
    fbBuilder.addFloat64(25, _RIGHT_GEO_BELT_LIMIT);
    fbBuilder.addFloat64(26, _LEFT_GEO_BELT_LIMIT);
    fbBuilder.addFloat64(27, _MAGNITUDE_LIMIT);
    fbBuilder.addBool(28, _TASKABLE);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
class IDMCOLLECTION {
  IDMCOLLECTION._(this._bc, this._bcOffset);
  factory IDMCOLLECTION(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<IDMCOLLECTION> reader = _IDMCOLLECTIONReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<IDM>? get RECORDS => const fb.ListReader<IDM>(IDM.reader).vTableGetNullable(_bc, _bcOffset, 4);

  @override
  String toString() {
    return 'IDMCOLLECTION{RECORDS: ${RECORDS}}';
  }
}

class _IDMCOLLECTIONReader extends fb.TableReader<IDMCOLLECTION> {
  const _IDMCOLLECTIONReader();

  @override
  IDMCOLLECTION createObject(fb.BufferContext bc, int offset) => 
    IDMCOLLECTION._(bc, offset);
}

class IDMCOLLECTIONBuilder {
  IDMCOLLECTIONBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addRecordsOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class IDMCOLLECTIONObjectBuilder extends fb.ObjectBuilder {
  final List<IDMObjectBuilder>? _RECORDS;

  IDMCOLLECTIONObjectBuilder({
    List<IDMObjectBuilder>? RECORDS,
  })
      : _RECORDS = RECORDS;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? RECORDSOffset = _RECORDS == null ? null
        : fbBuilder.writeList(_RECORDS!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, RECORDSOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
