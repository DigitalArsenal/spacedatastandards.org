// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


///  Access type for data listings
class AccessType {
  final int value;
  const AccessType._(this.value);

  factory AccessType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum AccessType');
    }
    return result;
  }

  static AccessType? _createOrNull(int? value) => 
      value == null ? null : AccessType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  ///  One-time purchase
  static const AccessType OneTime = AccessType._(0);

  ///  Recurring subscription
  static const AccessType Subscription = AccessType._(1);

  ///  Real-time streaming access
  static const AccessType Streaming = AccessType._(2);

  ///  Query-based access
  static const AccessType Query = AccessType._(3);
  static const Map<int, AccessType> values = {
    0: OneTime,
    1: Subscription,
    2: Streaming,
    3: Query};

  static const fb.Reader<AccessType> reader = _AccessTypeReader();

  @override
  String toString() {
    return 'AccessType{value: $value}';
  }
}

class _AccessTypeReader extends fb.Reader<AccessType> {
  const _AccessTypeReader();

  @override
  int get size => 1;

  @override
  AccessType read(fb.BufferContext bc, int offset) =>
      AccessType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Payment method accepted
class PaymentMethod {
  final int value;
  const PaymentMethod._(this.value);

  factory PaymentMethod.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum PaymentMethod');
    }
    return result;
  }

  static PaymentMethod? _createOrNull(int? value) => 
      value == null ? null : PaymentMethod.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 5;
  static bool containsValue(int value) => values.containsKey(value);

  ///  Ethereum cryptocurrency
  static const PaymentMethod Crypto_ETH = PaymentMethod._(0);

  ///  Solana cryptocurrency
  static const PaymentMethod Crypto_SOL = PaymentMethod._(1);

  ///  Bitcoin cryptocurrency
  static const PaymentMethod Crypto_BTC = PaymentMethod._(2);

  ///  Internal SDN credits system
  static const PaymentMethod SDN_Credits = PaymentMethod._(3);

  ///  Fiat payment via Stripe
  static const PaymentMethod Fiat_Stripe = PaymentMethod._(4);

  ///  Free/open data
  static const PaymentMethod Free = PaymentMethod._(5);
  static const Map<int, PaymentMethod> values = {
    0: Crypto_ETH,
    1: Crypto_SOL,
    2: Crypto_BTC,
    3: SDN_Credits,
    4: Fiat_Stripe,
    5: Free};

  static const fb.Reader<PaymentMethod> reader = _PaymentMethodReader();

  @override
  String toString() {
    return 'PaymentMethod{value: $value}';
  }
}

class _PaymentMethodReader extends fb.Reader<PaymentMethod> {
  const _PaymentMethodReader();

  @override
  int get size => 1;

  @override
  PaymentMethod read(fb.BufferContext bc, int offset) =>
      PaymentMethod.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Spatial coverage definition
class SpatialCoverage {
  SpatialCoverage._(this._bc, this._bcOffset);
  factory SpatialCoverage(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SpatialCoverage> reader = _SpatialCoverageReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Type of coverage: "global", "region", "object_list"
  String? get TYPE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Regions covered, e.g., ["LEO", "GEO", "MEO"]
  List<String>? get REGIONS => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 6);
  ///  Specific NORAD IDs or catalog numbers
  List<String>? get OBJECT_IDS => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 8);

  @override
  String toString() {
    return 'SpatialCoverage{TYPE: ${TYPE}, REGIONS: ${REGIONS}, OBJECT_IDS: ${OBJECT_IDS}}';
  }
}

class _SpatialCoverageReader extends fb.TableReader<SpatialCoverage> {
  const _SpatialCoverageReader();

  @override
  SpatialCoverage createObject(fb.BufferContext bc, int offset) => 
    SpatialCoverage._(bc, offset);
}

class SpatialCoverageBuilder {
  SpatialCoverageBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(3);
  }

  int addTypeOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addRegionsOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addObjectIdsOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SpatialCoverageObjectBuilder extends fb.ObjectBuilder {
  final String? _TYPE;
  final List<String>? _REGIONS;
  final List<String>? _OBJECT_IDS;

  SpatialCoverageObjectBuilder({
    String? TYPE,
    List<String>? REGIONS,
    List<String>? OBJECT_IDS,
  })
      : _TYPE = TYPE,
        _REGIONS = REGIONS,
        _OBJECT_IDS = OBJECT_IDS;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? TYPEOffset = _TYPE == null ? null
        : fbBuilder.writeString(_TYPE!);
    final int? REGIONSOffset = _REGIONS == null ? null
        : fbBuilder.writeList(_REGIONS!.map(fbBuilder.writeString).toList());
    final int? OBJECT_IDSOffset = _OBJECT_IDS == null ? null
        : fbBuilder.writeList(_OBJECT_IDS!.map(fbBuilder.writeString).toList());
    fbBuilder.startTable(3);
    fbBuilder.addOffset(0, TYPEOffset);
    fbBuilder.addOffset(1, REGIONSOffset);
    fbBuilder.addOffset(2, OBJECT_IDSOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Temporal coverage definition
class TemporalCoverage {
  TemporalCoverage._(this._bc, this._bcOffset);
  factory TemporalCoverage(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<TemporalCoverage> reader = _TemporalCoverageReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Start epoch in ISO 8601 format
  String? get START_EPOCH => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  End epoch in ISO 8601 format
  String? get END_EPOCH => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  ///  Update frequency: "realtime", "hourly", "daily"
  String? get UPDATE_FREQUENCY => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  ///  Days of historical data available
  int get HISTORICAL_DEPTH => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 10, 0);

  @override
  String toString() {
    return 'TemporalCoverage{START_EPOCH: ${START_EPOCH}, END_EPOCH: ${END_EPOCH}, UPDATE_FREQUENCY: ${UPDATE_FREQUENCY}, HISTORICAL_DEPTH: ${HISTORICAL_DEPTH}}';
  }
}

class _TemporalCoverageReader extends fb.TableReader<TemporalCoverage> {
  const _TemporalCoverageReader();

  @override
  TemporalCoverage createObject(fb.BufferContext bc, int offset) => 
    TemporalCoverage._(bc, offset);
}

class TemporalCoverageBuilder {
  TemporalCoverageBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addStartEpochOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addEndEpochOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addUpdateFrequencyOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addHistoricalDepth(int? HISTORICAL_DEPTH) {
    fbBuilder.addUint32(3, HISTORICAL_DEPTH);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TemporalCoverageObjectBuilder extends fb.ObjectBuilder {
  final String? _START_EPOCH;
  final String? _END_EPOCH;
  final String? _UPDATE_FREQUENCY;
  final int? _HISTORICAL_DEPTH;

  TemporalCoverageObjectBuilder({
    String? START_EPOCH,
    String? END_EPOCH,
    String? UPDATE_FREQUENCY,
    int? HISTORICAL_DEPTH,
  })
      : _START_EPOCH = START_EPOCH,
        _END_EPOCH = END_EPOCH,
        _UPDATE_FREQUENCY = UPDATE_FREQUENCY,
        _HISTORICAL_DEPTH = HISTORICAL_DEPTH;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? START_EPOCHOffset = _START_EPOCH == null ? null
        : fbBuilder.writeString(_START_EPOCH!);
    final int? END_EPOCHOffset = _END_EPOCH == null ? null
        : fbBuilder.writeString(_END_EPOCH!);
    final int? UPDATE_FREQUENCYOffset = _UPDATE_FREQUENCY == null ? null
        : fbBuilder.writeString(_UPDATE_FREQUENCY!);
    fbBuilder.startTable(4);
    fbBuilder.addOffset(0, START_EPOCHOffset);
    fbBuilder.addOffset(1, END_EPOCHOffset);
    fbBuilder.addOffset(2, UPDATE_FREQUENCYOffset);
    fbBuilder.addUint32(3, _HISTORICAL_DEPTH);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Data coverage combining spatial and temporal
class DataCoverage {
  DataCoverage._(this._bc, this._bcOffset);
  factory DataCoverage(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<DataCoverage> reader = _DataCoverageReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Spatial coverage definition
  SpatialCoverage? get SPATIAL => SpatialCoverage.reader.vTableGetNullable(_bc, _bcOffset, 4);
  ///  Temporal coverage definition
  TemporalCoverage? get TEMPORAL => TemporalCoverage.reader.vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'DataCoverage{SPATIAL: ${SPATIAL}, TEMPORAL: ${TEMPORAL}}';
  }
}

class _DataCoverageReader extends fb.TableReader<DataCoverage> {
  const _DataCoverageReader();

  @override
  DataCoverage createObject(fb.BufferContext bc, int offset) => 
    DataCoverage._(bc, offset);
}

class DataCoverageBuilder {
  DataCoverageBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addSpatialOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addTemporalOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class DataCoverageObjectBuilder extends fb.ObjectBuilder {
  final SpatialCoverageObjectBuilder? _SPATIAL;
  final TemporalCoverageObjectBuilder? _TEMPORAL;

  DataCoverageObjectBuilder({
    SpatialCoverageObjectBuilder? SPATIAL,
    TemporalCoverageObjectBuilder? TEMPORAL,
  })
      : _SPATIAL = SPATIAL,
        _TEMPORAL = TEMPORAL;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? SPATIALOffset = _SPATIAL?.getOrCreateOffset(fbBuilder);
    final int? TEMPORALOffset = _TEMPORAL?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, SPATIALOffset);
    fbBuilder.addOffset(1, TEMPORALOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Pricing tier for a listing
class PricingTier {
  PricingTier._(this._bc, this._bcOffset);
  factory PricingTier(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<PricingTier> reader = _PricingTierReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Tier name, e.g., "Basic", "Pro", "Enterprise"
  String? get NAME => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Price in smallest unit (cents, satoshis, etc.)
  int get PRICE_AMOUNT => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 6, 0);
  ///  Currency code: "USD", "ETH", "SOL", "SDN_CREDITS"
  String? get PRICE_CURRENCY => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  ///  Duration in days (0 = one-time purchase)
  int get DURATION_DAYS => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 10, 0);
  ///  Rate limit in requests per hour
  int get RATE_LIMIT => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 12, 0);
  ///  List of features included in this tier
  List<String>? get FEATURES => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 14);

  @override
  String toString() {
    return 'PricingTier{NAME: ${NAME}, PRICE_AMOUNT: ${PRICE_AMOUNT}, PRICE_CURRENCY: ${PRICE_CURRENCY}, DURATION_DAYS: ${DURATION_DAYS}, RATE_LIMIT: ${RATE_LIMIT}, FEATURES: ${FEATURES}}';
  }
}

class _PricingTierReader extends fb.TableReader<PricingTier> {
  const _PricingTierReader();

  @override
  PricingTier createObject(fb.BufferContext bc, int offset) => 
    PricingTier._(bc, offset);
}

class PricingTierBuilder {
  PricingTierBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(6);
  }

  int addNameOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addPriceAmount(int? PRICE_AMOUNT) {
    fbBuilder.addUint64(1, PRICE_AMOUNT);
    return fbBuilder.offset;
  }
  int addPriceCurrencyOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addDurationDays(int? DURATION_DAYS) {
    fbBuilder.addUint32(3, DURATION_DAYS);
    return fbBuilder.offset;
  }
  int addRateLimit(int? RATE_LIMIT) {
    fbBuilder.addUint32(4, RATE_LIMIT);
    return fbBuilder.offset;
  }
  int addFeaturesOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class PricingTierObjectBuilder extends fb.ObjectBuilder {
  final String? _NAME;
  final int? _PRICE_AMOUNT;
  final String? _PRICE_CURRENCY;
  final int? _DURATION_DAYS;
  final int? _RATE_LIMIT;
  final List<String>? _FEATURES;

  PricingTierObjectBuilder({
    String? NAME,
    int? PRICE_AMOUNT,
    String? PRICE_CURRENCY,
    int? DURATION_DAYS,
    int? RATE_LIMIT,
    List<String>? FEATURES,
  })
      : _NAME = NAME,
        _PRICE_AMOUNT = PRICE_AMOUNT,
        _PRICE_CURRENCY = PRICE_CURRENCY,
        _DURATION_DAYS = DURATION_DAYS,
        _RATE_LIMIT = RATE_LIMIT,
        _FEATURES = FEATURES;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? NAMEOffset = _NAME == null ? null
        : fbBuilder.writeString(_NAME!);
    final int? PRICE_CURRENCYOffset = _PRICE_CURRENCY == null ? null
        : fbBuilder.writeString(_PRICE_CURRENCY!);
    final int? FEATURESOffset = _FEATURES == null ? null
        : fbBuilder.writeList(_FEATURES!.map(fbBuilder.writeString).toList());
    fbBuilder.startTable(6);
    fbBuilder.addOffset(0, NAMEOffset);
    fbBuilder.addUint64(1, _PRICE_AMOUNT);
    fbBuilder.addOffset(2, PRICE_CURRENCYOffset);
    fbBuilder.addUint32(3, _DURATION_DAYS);
    fbBuilder.addUint32(4, _RATE_LIMIT);
    fbBuilder.addOffset(5, FEATURESOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
///  Storefront Listing - Data marketplace listing
class STF {
  STF._(this._bc, this._bcOffset);
  factory STF(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<STF> reader = _STFReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Unique identifier for the listing
  String? get LISTING_ID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  ///  Peer ID of the data provider
  String? get PROVIDER_PEER_ID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  ///  IPFS CID of provider's EPM (Entity Profile Message)
  String? get PROVIDER_EPM_CID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  ///  Title of the data listing
  String? get TITLE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
  ///  Detailed description of the data offering
  String? get DESCRIPTION => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  ///  SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
  List<String>? get DATA_TYPES => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 14);
  ///  Coverage information (spatial and temporal)
  DataCoverage? get COVERAGE => DataCoverage.reader.vTableGetNullable(_bc, _bcOffset, 16);
  ///  IPFS CID of sample data
  String? get SAMPLE_CID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);
  ///  Type of access offered
  AccessType get ACCESS_TYPE => AccessType.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 20, 0));
  ///  Whether encryption is required for data delivery
  bool get ENCRYPTION_REQUIRED => const fb.BoolReader().vTableGet(_bc, _bcOffset, 22, false);
  ///  Available pricing tiers
  List<PricingTier>? get PRICING => const fb.ListReader<PricingTier>(PricingTier.reader).vTableGetNullable(_bc, _bcOffset, 24);
  ///  Payment methods accepted
  List<PaymentMethod>? get ACCEPTED_PAYMENTS => const fb.ListReader<PaymentMethod>(PaymentMethod.reader).vTableGetNullable(_bc, _bcOffset, 26);
  ///  Unix timestamp when listing was created
  int get CREATED_AT => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 28, 0);
  ///  Unix timestamp when listing was last updated
  int get UPDATED_AT => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 30, 0);
  ///  Whether the listing is currently active
  bool get ACTIVE => const fb.BoolReader().vTableGet(_bc, _bcOffset, 32, false);
  ///  Ed25519 signature from provider
  List<int>? get SIGNATURE => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 34);

  @override
  String toString() {
    return 'STF{LISTING_ID: ${LISTING_ID}, PROVIDER_PEER_ID: ${PROVIDER_PEER_ID}, PROVIDER_EPM_CID: ${PROVIDER_EPM_CID}, TITLE: ${TITLE}, DESCRIPTION: ${DESCRIPTION}, DATA_TYPES: ${DATA_TYPES}, COVERAGE: ${COVERAGE}, SAMPLE_CID: ${SAMPLE_CID}, ACCESS_TYPE: ${ACCESS_TYPE}, ENCRYPTION_REQUIRED: ${ENCRYPTION_REQUIRED}, PRICING: ${PRICING}, ACCEPTED_PAYMENTS: ${ACCEPTED_PAYMENTS}, CREATED_AT: ${CREATED_AT}, UPDATED_AT: ${UPDATED_AT}, ACTIVE: ${ACTIVE}, SIGNATURE: ${SIGNATURE}}';
  }
}

class _STFReader extends fb.TableReader<STF> {
  const _STFReader();

  @override
  STF createObject(fb.BufferContext bc, int offset) => 
    STF._(bc, offset);
}

class STFBuilder {
  STFBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(16);
  }

  int addListingIdOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addProviderPeerIdOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addProviderEpmCidOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addTitleOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addDescriptionOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addDataTypesOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addCoverageOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addSampleCidOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }
  int addAccessType(AccessType? ACCESS_TYPE) {
    fbBuilder.addInt8(8, ACCESS_TYPE?.value);
    return fbBuilder.offset;
  }
  int addEncryptionRequired(bool? ENCRYPTION_REQUIRED) {
    fbBuilder.addBool(9, ENCRYPTION_REQUIRED);
    return fbBuilder.offset;
  }
  int addPricingOffset(int? offset) {
    fbBuilder.addOffset(10, offset);
    return fbBuilder.offset;
  }
  int addAcceptedPaymentsOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }
  int addCreatedAt(int? CREATED_AT) {
    fbBuilder.addUint64(12, CREATED_AT);
    return fbBuilder.offset;
  }
  int addUpdatedAt(int? UPDATED_AT) {
    fbBuilder.addUint64(13, UPDATED_AT);
    return fbBuilder.offset;
  }
  int addActive(bool? ACTIVE) {
    fbBuilder.addBool(14, ACTIVE);
    return fbBuilder.offset;
  }
  int addSignatureOffset(int? offset) {
    fbBuilder.addOffset(15, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class STFObjectBuilder extends fb.ObjectBuilder {
  final String? _LISTING_ID;
  final String? _PROVIDER_PEER_ID;
  final String? _PROVIDER_EPM_CID;
  final String? _TITLE;
  final String? _DESCRIPTION;
  final List<String>? _DATA_TYPES;
  final DataCoverageObjectBuilder? _COVERAGE;
  final String? _SAMPLE_CID;
  final AccessType? _ACCESS_TYPE;
  final bool? _ENCRYPTION_REQUIRED;
  final List<PricingTierObjectBuilder>? _PRICING;
  final List<PaymentMethod>? _ACCEPTED_PAYMENTS;
  final int? _CREATED_AT;
  final int? _UPDATED_AT;
  final bool? _ACTIVE;
  final List<int>? _SIGNATURE;

  STFObjectBuilder({
    String? LISTING_ID,
    String? PROVIDER_PEER_ID,
    String? PROVIDER_EPM_CID,
    String? TITLE,
    String? DESCRIPTION,
    List<String>? DATA_TYPES,
    DataCoverageObjectBuilder? COVERAGE,
    String? SAMPLE_CID,
    AccessType? ACCESS_TYPE,
    bool? ENCRYPTION_REQUIRED,
    List<PricingTierObjectBuilder>? PRICING,
    List<PaymentMethod>? ACCEPTED_PAYMENTS,
    int? CREATED_AT,
    int? UPDATED_AT,
    bool? ACTIVE,
    List<int>? SIGNATURE,
  })
      : _LISTING_ID = LISTING_ID,
        _PROVIDER_PEER_ID = PROVIDER_PEER_ID,
        _PROVIDER_EPM_CID = PROVIDER_EPM_CID,
        _TITLE = TITLE,
        _DESCRIPTION = DESCRIPTION,
        _DATA_TYPES = DATA_TYPES,
        _COVERAGE = COVERAGE,
        _SAMPLE_CID = SAMPLE_CID,
        _ACCESS_TYPE = ACCESS_TYPE,
        _ENCRYPTION_REQUIRED = ENCRYPTION_REQUIRED,
        _PRICING = PRICING,
        _ACCEPTED_PAYMENTS = ACCEPTED_PAYMENTS,
        _CREATED_AT = CREATED_AT,
        _UPDATED_AT = UPDATED_AT,
        _ACTIVE = ACTIVE,
        _SIGNATURE = SIGNATURE;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? LISTING_IDOffset = _LISTING_ID == null ? null
        : fbBuilder.writeString(_LISTING_ID!);
    final int? PROVIDER_PEER_IDOffset = _PROVIDER_PEER_ID == null ? null
        : fbBuilder.writeString(_PROVIDER_PEER_ID!);
    final int? PROVIDER_EPM_CIDOffset = _PROVIDER_EPM_CID == null ? null
        : fbBuilder.writeString(_PROVIDER_EPM_CID!);
    final int? TITLEOffset = _TITLE == null ? null
        : fbBuilder.writeString(_TITLE!);
    final int? DESCRIPTIONOffset = _DESCRIPTION == null ? null
        : fbBuilder.writeString(_DESCRIPTION!);
    final int? DATA_TYPESOffset = _DATA_TYPES == null ? null
        : fbBuilder.writeList(_DATA_TYPES!.map(fbBuilder.writeString).toList());
    final int? COVERAGEOffset = _COVERAGE?.getOrCreateOffset(fbBuilder);
    final int? SAMPLE_CIDOffset = _SAMPLE_CID == null ? null
        : fbBuilder.writeString(_SAMPLE_CID!);
    final int? PRICINGOffset = _PRICING == null ? null
        : fbBuilder.writeList(_PRICING!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? ACCEPTED_PAYMENTSOffset = _ACCEPTED_PAYMENTS == null ? null
        : fbBuilder.writeListInt8(_ACCEPTED_PAYMENTS!.map((f) => f.value).toList());
    final int? SIGNATUREOffset = _SIGNATURE == null ? null
        : fbBuilder.writeListUint8(_SIGNATURE!);
    fbBuilder.startTable(16);
    fbBuilder.addOffset(0, LISTING_IDOffset);
    fbBuilder.addOffset(1, PROVIDER_PEER_IDOffset);
    fbBuilder.addOffset(2, PROVIDER_EPM_CIDOffset);
    fbBuilder.addOffset(3, TITLEOffset);
    fbBuilder.addOffset(4, DESCRIPTIONOffset);
    fbBuilder.addOffset(5, DATA_TYPESOffset);
    fbBuilder.addOffset(6, COVERAGEOffset);
    fbBuilder.addOffset(7, SAMPLE_CIDOffset);
    fbBuilder.addInt8(8, _ACCESS_TYPE?.value);
    fbBuilder.addBool(9, _ENCRYPTION_REQUIRED);
    fbBuilder.addOffset(10, PRICINGOffset);
    fbBuilder.addOffset(11, ACCEPTED_PAYMENTSOffset);
    fbBuilder.addUint64(12, _CREATED_AT);
    fbBuilder.addUint64(13, _UPDATED_AT);
    fbBuilder.addBool(14, _ACTIVE);
    fbBuilder.addOffset(15, SIGNATUREOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
