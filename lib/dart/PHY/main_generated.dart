// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class IntegrationMethod {
  final int value;
  const IntegrationMethod._(this.value);

  factory IntegrationMethod.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum IntegrationMethod');
    }
    return result;
  }

  static IntegrationMethod? _createOrNull(int? value) => 
      value == null ? null : IntegrationMethod.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 9;
  static bool containsValue(int value) => values.containsKey(value);

  static const IntegrationMethod EULER = IntegrationMethod._(0);
  static const IntegrationMethod EULER_IMPROVED = IntegrationMethod._(1);
  static const IntegrationMethod RK2 = IntegrationMethod._(2);
  static const IntegrationMethod RK4 = IntegrationMethod._(3);
  static const IntegrationMethod RK45 = IntegrationMethod._(4);
  static const IntegrationMethod RK78 = IntegrationMethod._(5);
  static const IntegrationMethod VERLET = IntegrationMethod._(6);
  static const IntegrationMethod LEAPFROG = IntegrationMethod._(7);
  static const IntegrationMethod ADAMS_BASHFORTH = IntegrationMethod._(8);
  static const IntegrationMethod GAUSS_JACKSON = IntegrationMethod._(9);
  static const Map<int, IntegrationMethod> values = {
    0: EULER,
    1: EULER_IMPROVED,
    2: RK2,
    3: RK4,
    4: RK45,
    5: RK78,
    6: VERLET,
    7: LEAPFROG,
    8: ADAMS_BASHFORTH,
    9: GAUSS_JACKSON};

  static const fb.Reader<IntegrationMethod> reader = _IntegrationMethodReader();

  @override
  String toString() {
    return 'IntegrationMethod{value: $value}';
  }
}

class _IntegrationMethodReader extends fb.Reader<IntegrationMethod> {
  const _IntegrationMethodReader();

  @override
  int get size => 1;

  @override
  IntegrationMethod read(fb.BufferContext bc, int offset) =>
      IntegrationMethod.fromValue(const fb.Int8Reader().read(bc, offset));
}

class CollisionShape {
  final int value;
  const CollisionShape._(this.value);

  factory CollisionShape.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum CollisionShape');
    }
    return result;
  }

  static CollisionShape? _createOrNull(int? value) => 
      value == null ? null : CollisionShape.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 7;
  static bool containsValue(int value) => values.containsKey(value);

  static const CollisionShape SPHERE = CollisionShape._(0);
  static const CollisionShape BOX = CollisionShape._(1);
  static const CollisionShape CYLINDER = CollisionShape._(2);
  static const CollisionShape CAPSULE = CollisionShape._(3);
  static const CollisionShape CONE = CollisionShape._(4);
  static const CollisionShape CONVEX_HULL = CollisionShape._(5);
  static const CollisionShape MESH = CollisionShape._(6);
  static const CollisionShape COMPOUND = CollisionShape._(7);
  static const Map<int, CollisionShape> values = {
    0: SPHERE,
    1: BOX,
    2: CYLINDER,
    3: CAPSULE,
    4: CONE,
    5: CONVEX_HULL,
    6: MESH,
    7: COMPOUND};

  static const fb.Reader<CollisionShape> reader = _CollisionShapeReader();

  @override
  String toString() {
    return 'CollisionShape{value: $value}';
  }
}

class _CollisionShapeReader extends fb.Reader<CollisionShape> {
  const _CollisionShapeReader();

  @override
  int get size => 1;

  @override
  CollisionShape read(fb.BufferContext bc, int offset) =>
      CollisionShape.fromValue(const fb.Int8Reader().read(bc, offset));
}

class MaterialType {
  final int value;
  const MaterialType._(this.value);

  factory MaterialType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum MaterialType');
    }
    return result;
  }

  static MaterialType? _createOrNull(int? value) => 
      value == null ? null : MaterialType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 10;
  static bool containsValue(int value) => values.containsKey(value);

  static const MaterialType STEEL = MaterialType._(0);
  static const MaterialType ALUMINUM = MaterialType._(1);
  static const MaterialType TITANIUM = MaterialType._(2);
  static const MaterialType CERAMIC = MaterialType._(3);
  static const MaterialType COMPOSITE = MaterialType._(4);
  static const MaterialType CONCRETE = MaterialType._(5);
  static const MaterialType WOOD = MaterialType._(6);
  static const MaterialType RUBBER = MaterialType._(7);
  static const MaterialType WATER = MaterialType._(8);
  static const MaterialType AIR = MaterialType._(9);
  static const MaterialType CUSTOM = MaterialType._(10);
  static const Map<int, MaterialType> values = {
    0: STEEL,
    1: ALUMINUM,
    2: TITANIUM,
    3: CERAMIC,
    4: COMPOSITE,
    5: CONCRETE,
    6: WOOD,
    7: RUBBER,
    8: WATER,
    9: AIR,
    10: CUSTOM};

  static const fb.Reader<MaterialType> reader = _MaterialTypeReader();

  @override
  String toString() {
    return 'MaterialType{value: $value}';
  }
}

class _MaterialTypeReader extends fb.Reader<MaterialType> {
  const _MaterialTypeReader();

  @override
  int get size => 1;

  @override
  MaterialType read(fb.BufferContext bc, int offset) =>
      MaterialType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class ForceType {
  final int value;
  const ForceType._(this.value);

  factory ForceType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum ForceType');
    }
    return result;
  }

  static ForceType? _createOrNull(int? value) => 
      value == null ? null : ForceType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 10;
  static bool containsValue(int value) => values.containsKey(value);

  static const ForceType GRAVITY = ForceType._(0);
  static const ForceType THRUST = ForceType._(1);
  static const ForceType DRAG = ForceType._(2);
  static const ForceType LIFT = ForceType._(3);
  static const ForceType FRICTION = ForceType._(4);
  static const ForceType SPRING = ForceType._(5);
  static const ForceType DAMPER = ForceType._(6);
  static const ForceType CONTACT = ForceType._(7);
  static const ForceType MAGNETIC = ForceType._(8);
  static const ForceType ELECTRIC = ForceType._(9);
  static const ForceType CUSTOM = ForceType._(10);
  static const Map<int, ForceType> values = {
    0: GRAVITY,
    1: THRUST,
    2: DRAG,
    3: LIFT,
    4: FRICTION,
    5: SPRING,
    6: DAMPER,
    7: CONTACT,
    8: MAGNETIC,
    9: ELECTRIC,
    10: CUSTOM};

  static const fb.Reader<ForceType> reader = _ForceTypeReader();

  @override
  String toString() {
    return 'ForceType{value: $value}';
  }
}

class _ForceTypeReader extends fb.Reader<ForceType> {
  const _ForceTypeReader();

  @override
  int get size => 1;

  @override
  ForceType read(fb.BufferContext bc, int offset) =>
      ForceType.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Physics and Rigid Body Dynamics
class PHY {
  PHY._(this._bc, this._bcOffset);
  factory PHY(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<PHY> reader = _PHYReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get COMMAND => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  String? get SIMULATION_STEP => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 6);
  String? get RIGID_BODY => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 8);
  String? get INTEGRATION_CONFIG => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
  String? get COLLISION_QUERY_A => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 12);
  String? get COLLISION_QUERY_B => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 14);
  String? get TRANSFORM_A => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 16);
  String? get TRANSFORM_B => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);
  String? get POSITION_A => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 20);
  String? get POSITION_B => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 22);
  String? get FLUID => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 24);
  String? get AERO_QUERY => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 26);
  String? get DRAG_MODEL => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 28);
  String? get THERMAL_STATE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 30);

  @override
  String toString() {
    return 'PHY{COMMAND: ${COMMAND}, SIMULATION_STEP: ${SIMULATION_STEP}, RIGID_BODY: ${RIGID_BODY}, INTEGRATION_CONFIG: ${INTEGRATION_CONFIG}, COLLISION_QUERY_A: ${COLLISION_QUERY_A}, COLLISION_QUERY_B: ${COLLISION_QUERY_B}, TRANSFORM_A: ${TRANSFORM_A}, TRANSFORM_B: ${TRANSFORM_B}, POSITION_A: ${POSITION_A}, POSITION_B: ${POSITION_B}, FLUID: ${FLUID}, AERO_QUERY: ${AERO_QUERY}, DRAG_MODEL: ${DRAG_MODEL}, THERMAL_STATE: ${THERMAL_STATE}}';
  }
}

class _PHYReader extends fb.TableReader<PHY> {
  const _PHYReader();

  @override
  PHY createObject(fb.BufferContext bc, int offset) => 
    PHY._(bc, offset);
}

class PHYBuilder {
  PHYBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(14);
  }

  int addCommandOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addSimulationStepOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }
  int addRigidBodyOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }
  int addIntegrationConfigOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }
  int addCollisionQueryAOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addCollisionQueryBOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addTransformAOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addTransformBOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }
  int addPositionAOffset(int? offset) {
    fbBuilder.addOffset(8, offset);
    return fbBuilder.offset;
  }
  int addPositionBOffset(int? offset) {
    fbBuilder.addOffset(9, offset);
    return fbBuilder.offset;
  }
  int addFluidOffset(int? offset) {
    fbBuilder.addOffset(10, offset);
    return fbBuilder.offset;
  }
  int addAeroQueryOffset(int? offset) {
    fbBuilder.addOffset(11, offset);
    return fbBuilder.offset;
  }
  int addDragModelOffset(int? offset) {
    fbBuilder.addOffset(12, offset);
    return fbBuilder.offset;
  }
  int addThermalStateOffset(int? offset) {
    fbBuilder.addOffset(13, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class PHYObjectBuilder extends fb.ObjectBuilder {
  final String? _COMMAND;
  final String? _SIMULATION_STEP;
  final String? _RIGID_BODY;
  final String? _INTEGRATION_CONFIG;
  final String? _COLLISION_QUERY_A;
  final String? _COLLISION_QUERY_B;
  final String? _TRANSFORM_A;
  final String? _TRANSFORM_B;
  final String? _POSITION_A;
  final String? _POSITION_B;
  final String? _FLUID;
  final String? _AERO_QUERY;
  final String? _DRAG_MODEL;
  final String? _THERMAL_STATE;

  PHYObjectBuilder({
    String? COMMAND,
    String? SIMULATION_STEP,
    String? RIGID_BODY,
    String? INTEGRATION_CONFIG,
    String? COLLISION_QUERY_A,
    String? COLLISION_QUERY_B,
    String? TRANSFORM_A,
    String? TRANSFORM_B,
    String? POSITION_A,
    String? POSITION_B,
    String? FLUID,
    String? AERO_QUERY,
    String? DRAG_MODEL,
    String? THERMAL_STATE,
  })
      : _COMMAND = COMMAND,
        _SIMULATION_STEP = SIMULATION_STEP,
        _RIGID_BODY = RIGID_BODY,
        _INTEGRATION_CONFIG = INTEGRATION_CONFIG,
        _COLLISION_QUERY_A = COLLISION_QUERY_A,
        _COLLISION_QUERY_B = COLLISION_QUERY_B,
        _TRANSFORM_A = TRANSFORM_A,
        _TRANSFORM_B = TRANSFORM_B,
        _POSITION_A = POSITION_A,
        _POSITION_B = POSITION_B,
        _FLUID = FLUID,
        _AERO_QUERY = AERO_QUERY,
        _DRAG_MODEL = DRAG_MODEL,
        _THERMAL_STATE = THERMAL_STATE;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? COMMANDOffset = _COMMAND == null ? null
        : fbBuilder.writeString(_COMMAND!);
    final int? SIMULATION_STEPOffset = _SIMULATION_STEP == null ? null
        : fbBuilder.writeString(_SIMULATION_STEP!);
    final int? RIGID_BODYOffset = _RIGID_BODY == null ? null
        : fbBuilder.writeString(_RIGID_BODY!);
    final int? INTEGRATION_CONFIGOffset = _INTEGRATION_CONFIG == null ? null
        : fbBuilder.writeString(_INTEGRATION_CONFIG!);
    final int? COLLISION_QUERY_AOffset = _COLLISION_QUERY_A == null ? null
        : fbBuilder.writeString(_COLLISION_QUERY_A!);
    final int? COLLISION_QUERY_BOffset = _COLLISION_QUERY_B == null ? null
        : fbBuilder.writeString(_COLLISION_QUERY_B!);
    final int? TRANSFORM_AOffset = _TRANSFORM_A == null ? null
        : fbBuilder.writeString(_TRANSFORM_A!);
    final int? TRANSFORM_BOffset = _TRANSFORM_B == null ? null
        : fbBuilder.writeString(_TRANSFORM_B!);
    final int? POSITION_AOffset = _POSITION_A == null ? null
        : fbBuilder.writeString(_POSITION_A!);
    final int? POSITION_BOffset = _POSITION_B == null ? null
        : fbBuilder.writeString(_POSITION_B!);
    final int? FLUIDOffset = _FLUID == null ? null
        : fbBuilder.writeString(_FLUID!);
    final int? AERO_QUERYOffset = _AERO_QUERY == null ? null
        : fbBuilder.writeString(_AERO_QUERY!);
    final int? DRAG_MODELOffset = _DRAG_MODEL == null ? null
        : fbBuilder.writeString(_DRAG_MODEL!);
    final int? THERMAL_STATEOffset = _THERMAL_STATE == null ? null
        : fbBuilder.writeString(_THERMAL_STATE!);
    fbBuilder.startTable(14);
    fbBuilder.addOffset(0, COMMANDOffset);
    fbBuilder.addOffset(1, SIMULATION_STEPOffset);
    fbBuilder.addOffset(2, RIGID_BODYOffset);
    fbBuilder.addOffset(3, INTEGRATION_CONFIGOffset);
    fbBuilder.addOffset(4, COLLISION_QUERY_AOffset);
    fbBuilder.addOffset(5, COLLISION_QUERY_BOffset);
    fbBuilder.addOffset(6, TRANSFORM_AOffset);
    fbBuilder.addOffset(7, TRANSFORM_BOffset);
    fbBuilder.addOffset(8, POSITION_AOffset);
    fbBuilder.addOffset(9, POSITION_BOffset);
    fbBuilder.addOffset(10, FLUIDOffset);
    fbBuilder.addOffset(11, AERO_QUERYOffset);
    fbBuilder.addOffset(12, DRAG_MODELOffset);
    fbBuilder.addOffset(13, THERMAL_STATEOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
