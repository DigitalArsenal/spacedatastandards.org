// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


///  Encryption Header for FlatBuffers field-level encryption
///  Key exchange algorithm used to derive the shared secret
class KeyExchange {
  final int value;
  const KeyExchange._(this.value);

  factory KeyExchange.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum KeyExchange');
    }
    return result;
  }

  static KeyExchange? _createOrNull(int? value) => 
      value == null ? null : KeyExchange.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const KeyExchange X25519 = KeyExchange._(0);
  static const KeyExchange Secp256k1 = KeyExchange._(1);
  static const KeyExchange P256 = KeyExchange._(2);
  static const Map<int, KeyExchange> values = {
    0: X25519,
    1: Secp256k1,
    2: P256};

  static const fb.Reader<KeyExchange> reader = _KeyExchangeReader();

  @override
  String toString() {
    return 'KeyExchange{value: $value}';
  }
}

class _KeyExchangeReader extends fb.Reader<KeyExchange> {
  const _KeyExchangeReader();

  @override
  int get size => 1;

  @override
  KeyExchange read(fb.BufferContext bc, int offset) =>
      KeyExchange.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Symmetric encryption algorithm
class SymmetricAlgo {
  final int value;
  const SymmetricAlgo._(this.value);

  factory SymmetricAlgo.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum SymmetricAlgo');
    }
    return result;
  }

  static SymmetricAlgo? _createOrNull(int? value) => 
      value == null ? null : SymmetricAlgo.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 0;
  static bool containsValue(int value) => values.containsKey(value);

  static const SymmetricAlgo AES_256_CTR = SymmetricAlgo._(0);
  static const Map<int, SymmetricAlgo> values = {
    0: AES_256_CTR};

  static const fb.Reader<SymmetricAlgo> reader = _SymmetricAlgoReader();

  @override
  String toString() {
    return 'SymmetricAlgo{value: $value}';
  }
}

class _SymmetricAlgoReader extends fb.Reader<SymmetricAlgo> {
  const _SymmetricAlgoReader();

  @override
  int get size => 1;

  @override
  SymmetricAlgo read(fb.BufferContext bc, int offset) =>
      SymmetricAlgo.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Key derivation function
class KDF {
  final int value;
  const KDF._(this.value);

  factory KDF.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum KDF');
    }
    return result;
  }

  static KDF? _createOrNull(int? value) => 
      value == null ? null : KDF.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 0;
  static bool containsValue(int value) => values.containsKey(value);

  static const KDF HKDF_SHA256 = KDF._(0);
  static const Map<int, KDF> values = {
    0: HKDF_SHA256};

  static const fb.Reader<KDF> reader = _KDFReader();

  @override
  String toString() {
    return 'KDF{value: $value}';
  }
}

class _KDFReader extends fb.Reader<KDF> {
  const _KDFReader();

  @override
  int get size => 1;

  @override
  KDF read(fb.BufferContext bc, int offset) =>
      KDF.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Encryption Header containing all parameters needed for decryption
class ENC {
  ENC._(this._bc, this._bcOffset);
  factory ENC(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<ENC> reader = _ENCReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  Schema version for forward compatibility
  int get VERSION => const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 1);
  ///  Key exchange algorithm used
  KeyExchange get KEY_EXCHANGE => KeyExchange.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 6, 0));
  ///  Symmetric encryption algorithm used
  SymmetricAlgo get SYMMETRIC => SymmetricAlgo.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 8, 0));
  ///  Key derivation function used
  KDF get KEY_DERIVATION => KDF.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 10, 0));
  ///  Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
  List<int>? get EPHEMERAL_PUBLIC_KEY => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 12);
  ///  Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  List<int>? get NONCE_START => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 14);
  ///  Optional identifier for the recipient's public key (up to 32 bytes)
  List<int>? get RECIPIENT_KEY_ID => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 16);
  ///  Optional domain separation context string
  String? get CONTEXT => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 18);
  ///  Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
  List<int>? get SCHEMA_HASH => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 20);
  ///  Optional root type name from the schema
  String? get ROOT_TYPE => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 22);
  ///  Optional Unix timestamp (milliseconds) when encryption was performed
  int get TIMESTAMP => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 24, 0);

  @override
  String toString() {
    return 'ENC{VERSION: ${VERSION}, KEY_EXCHANGE: ${KEY_EXCHANGE}, SYMMETRIC: ${SYMMETRIC}, KEY_DERIVATION: ${KEY_DERIVATION}, EPHEMERAL_PUBLIC_KEY: ${EPHEMERAL_PUBLIC_KEY}, NONCE_START: ${NONCE_START}, RECIPIENT_KEY_ID: ${RECIPIENT_KEY_ID}, CONTEXT: ${CONTEXT}, SCHEMA_HASH: ${SCHEMA_HASH}, ROOT_TYPE: ${ROOT_TYPE}, TIMESTAMP: ${TIMESTAMP}}';
  }
}

class _ENCReader extends fb.TableReader<ENC> {
  const _ENCReader();

  @override
  ENC createObject(fb.BufferContext bc, int offset) => 
    ENC._(bc, offset);
}

class ENCBuilder {
  ENCBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(11);
  }

  int addVersion(int? VERSION) {
    fbBuilder.addUint8(0, VERSION);
    return fbBuilder.offset;
  }
  int addKeyExchange(KeyExchange? KEY_EXCHANGE) {
    fbBuilder.addInt8(1, KEY_EXCHANGE?.value);
    return fbBuilder.offset;
  }
  int addSymmetric(SymmetricAlgo? SYMMETRIC) {
    fbBuilder.addInt8(2, SYMMETRIC?.value);
    return fbBuilder.offset;
  }
  int addKeyDerivation(KDF? KEY_DERIVATION) {
    fbBuilder.addInt8(3, KEY_DERIVATION?.value);
    return fbBuilder.offset;
  }
  int addEphemeralPublicKeyOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }
  int addNonceStartOffset(int? offset) {
    fbBuilder.addOffset(5, offset);
    return fbBuilder.offset;
  }
  int addRecipientKeyIdOffset(int? offset) {
    fbBuilder.addOffset(6, offset);
    return fbBuilder.offset;
  }
  int addContextOffset(int? offset) {
    fbBuilder.addOffset(7, offset);
    return fbBuilder.offset;
  }
  int addSchemaHashOffset(int? offset) {
    fbBuilder.addOffset(8, offset);
    return fbBuilder.offset;
  }
  int addRootTypeOffset(int? offset) {
    fbBuilder.addOffset(9, offset);
    return fbBuilder.offset;
  }
  int addTimestamp(int? TIMESTAMP) {
    fbBuilder.addUint64(10, TIMESTAMP);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class ENCObjectBuilder extends fb.ObjectBuilder {
  final int? _VERSION;
  final KeyExchange? _KEY_EXCHANGE;
  final SymmetricAlgo? _SYMMETRIC;
  final KDF? _KEY_DERIVATION;
  final List<int>? _EPHEMERAL_PUBLIC_KEY;
  final List<int>? _NONCE_START;
  final List<int>? _RECIPIENT_KEY_ID;
  final String? _CONTEXT;
  final List<int>? _SCHEMA_HASH;
  final String? _ROOT_TYPE;
  final int? _TIMESTAMP;

  ENCObjectBuilder({
    int? VERSION,
    KeyExchange? KEY_EXCHANGE,
    SymmetricAlgo? SYMMETRIC,
    KDF? KEY_DERIVATION,
    List<int>? EPHEMERAL_PUBLIC_KEY,
    List<int>? NONCE_START,
    List<int>? RECIPIENT_KEY_ID,
    String? CONTEXT,
    List<int>? SCHEMA_HASH,
    String? ROOT_TYPE,
    int? TIMESTAMP,
  })
      : _VERSION = VERSION,
        _KEY_EXCHANGE = KEY_EXCHANGE,
        _SYMMETRIC = SYMMETRIC,
        _KEY_DERIVATION = KEY_DERIVATION,
        _EPHEMERAL_PUBLIC_KEY = EPHEMERAL_PUBLIC_KEY,
        _NONCE_START = NONCE_START,
        _RECIPIENT_KEY_ID = RECIPIENT_KEY_ID,
        _CONTEXT = CONTEXT,
        _SCHEMA_HASH = SCHEMA_HASH,
        _ROOT_TYPE = ROOT_TYPE,
        _TIMESTAMP = TIMESTAMP;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? EPHEMERAL_PUBLIC_KEYOffset = _EPHEMERAL_PUBLIC_KEY == null ? null
        : fbBuilder.writeListUint8(_EPHEMERAL_PUBLIC_KEY!);
    final int? NONCE_STARTOffset = _NONCE_START == null ? null
        : fbBuilder.writeListUint8(_NONCE_START!);
    final int? RECIPIENT_KEY_IDOffset = _RECIPIENT_KEY_ID == null ? null
        : fbBuilder.writeListUint8(_RECIPIENT_KEY_ID!);
    final int? CONTEXTOffset = _CONTEXT == null ? null
        : fbBuilder.writeString(_CONTEXT!);
    final int? SCHEMA_HASHOffset = _SCHEMA_HASH == null ? null
        : fbBuilder.writeListUint8(_SCHEMA_HASH!);
    final int? ROOT_TYPEOffset = _ROOT_TYPE == null ? null
        : fbBuilder.writeString(_ROOT_TYPE!);
    fbBuilder.startTable(11);
    fbBuilder.addUint8(0, _VERSION);
    fbBuilder.addInt8(1, _KEY_EXCHANGE?.value);
    fbBuilder.addInt8(2, _SYMMETRIC?.value);
    fbBuilder.addInt8(3, _KEY_DERIVATION?.value);
    fbBuilder.addOffset(4, EPHEMERAL_PUBLIC_KEYOffset);
    fbBuilder.addOffset(5, NONCE_STARTOffset);
    fbBuilder.addOffset(6, RECIPIENT_KEY_IDOffset);
    fbBuilder.addOffset(7, CONTEXTOffset);
    fbBuilder.addOffset(8, SCHEMA_HASHOffset);
    fbBuilder.addOffset(9, ROOT_TYPEOffset);
    fbBuilder.addUint64(10, _TIMESTAMP);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
