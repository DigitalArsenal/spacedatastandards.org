// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

import 'dart:typed_data' show Uint8List;
import 'package:flat_buffers/flat_buffers.dart' as fb;


class TerrainDataSource {
  final int value;
  const TerrainDataSource._(this.value);

  factory TerrainDataSource.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TerrainDataSource');
    }
    return result;
  }

  static TerrainDataSource? _createOrNull(int? value) => 
      value == null ? null : TerrainDataSource.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 7;
  static bool containsValue(int value) => values.containsKey(value);

  static const TerrainDataSource SRTM = TerrainDataSource._(0);
  static const TerrainDataSource ASTER = TerrainDataSource._(1);
  static const TerrainDataSource DTED_0 = TerrainDataSource._(2);
  static const TerrainDataSource DTED_1 = TerrainDataSource._(3);
  static const TerrainDataSource DTED_2 = TerrainDataSource._(4);
  static const TerrainDataSource NED = TerrainDataSource._(5);
  static const TerrainDataSource LIDAR = TerrainDataSource._(6);
  static const TerrainDataSource CUSTOM = TerrainDataSource._(7);
  static const Map<int, TerrainDataSource> values = {
    0: SRTM,
    1: ASTER,
    2: DTED_0,
    3: DTED_1,
    4: DTED_2,
    5: NED,
    6: LIDAR,
    7: CUSTOM};

  static const fb.Reader<TerrainDataSource> reader = _TerrainDataSourceReader();

  @override
  String toString() {
    return 'TerrainDataSource{value: $value}';
  }
}

class _TerrainDataSourceReader extends fb.Reader<TerrainDataSource> {
  const _TerrainDataSourceReader();

  @override
  int get size => 1;

  @override
  TerrainDataSource read(fb.BufferContext bc, int offset) =>
      TerrainDataSource.fromValue(const fb.Int8Reader().read(bc, offset));
}

class LandCoverType {
  final int value;
  const LandCoverType._(this.value);

  factory LandCoverType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum LandCoverType');
    }
    return result;
  }

  static LandCoverType? _createOrNull(int? value) => 
      value == null ? null : LandCoverType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 16;
  static bool containsValue(int value) => values.containsKey(value);

  static const LandCoverType WATER = LandCoverType._(0);
  static const LandCoverType URBAN = LandCoverType._(1);
  static const LandCoverType SUBURBAN = LandCoverType._(2);
  static const LandCoverType FOREST_DECIDUOUS = LandCoverType._(3);
  static const LandCoverType FOREST_CONIFEROUS = LandCoverType._(4);
  static const LandCoverType FOREST_MIXED = LandCoverType._(5);
  static const LandCoverType GRASSLAND = LandCoverType._(6);
  static const LandCoverType SHRUBLAND = LandCoverType._(7);
  static const LandCoverType CROPLAND = LandCoverType._(8);
  static const LandCoverType BARREN = LandCoverType._(9);
  static const LandCoverType WETLAND = LandCoverType._(10);
  static const LandCoverType SNOW_ICE = LandCoverType._(11);
  static const LandCoverType DESERT = LandCoverType._(12);
  static const LandCoverType ROCK = LandCoverType._(13);
  static const LandCoverType ROAD = LandCoverType._(14);
  static const LandCoverType RUNWAY = LandCoverType._(15);
  static const LandCoverType BUILDING = LandCoverType._(16);
  static const Map<int, LandCoverType> values = {
    0: WATER,
    1: URBAN,
    2: SUBURBAN,
    3: FOREST_DECIDUOUS,
    4: FOREST_CONIFEROUS,
    5: FOREST_MIXED,
    6: GRASSLAND,
    7: SHRUBLAND,
    8: CROPLAND,
    9: BARREN,
    10: WETLAND,
    11: SNOW_ICE,
    12: DESERT,
    13: ROCK,
    14: ROAD,
    15: RUNWAY,
    16: BUILDING};

  static const fb.Reader<LandCoverType> reader = _LandCoverTypeReader();

  @override
  String toString() {
    return 'LandCoverType{value: $value}';
  }
}

class _LandCoverTypeReader extends fb.Reader<LandCoverType> {
  const _LandCoverTypeReader();

  @override
  int get size => 1;

  @override
  LandCoverType read(fb.BufferContext bc, int offset) =>
      LandCoverType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class TerrainInterpolation {
  final int value;
  const TerrainInterpolation._(this.value);

  factory TerrainInterpolation.fromValue(int value) {
    final result = values[value];
    if (result == null) {
        throw StateError('Invalid value $value for bit flag enum TerrainInterpolation');
    }
    return result;
  }

  static TerrainInterpolation? _createOrNull(int? value) => 
      value == null ? null : TerrainInterpolation.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const TerrainInterpolation NEAREST = TerrainInterpolation._(0);
  static const TerrainInterpolation BILINEAR = TerrainInterpolation._(1);
  static const TerrainInterpolation BICUBIC = TerrainInterpolation._(2);
  static const TerrainInterpolation KRIGING = TerrainInterpolation._(3);
  static const Map<int, TerrainInterpolation> values = {
    0: NEAREST,
    1: BILINEAR,
    2: BICUBIC,
    3: KRIGING};

  static const fb.Reader<TerrainInterpolation> reader = _TerrainInterpolationReader();

  @override
  String toString() {
    return 'TerrainInterpolation{value: $value}';
  }
}

class _TerrainInterpolationReader extends fb.Reader<TerrainInterpolation> {
  const _TerrainInterpolationReader();

  @override
  int get size => 1;

  @override
  TerrainInterpolation read(fb.BufferContext bc, int offset) =>
      TerrainInterpolation.fromValue(const fb.Int8Reader().read(bc, offset));
}

///  Terrain Models
class TRN {
  TRN._(this._bc, this._bcOffset);
  factory TRN(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<TRN> reader = _TRNReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<TerrainDataSource>? get SOURCES => const fb.ListReader<TerrainDataSource>(TerrainDataSource.reader).vTableGetNullable(_bc, _bcOffset, 4);
  TerrainInterpolation get INTERPOLATION => TerrainInterpolation.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 6, 1));
  bool get CACHE_ENABLED => const fb.BoolReader().vTableGet(_bc, _bcOffset, 8, true);
  int get MAX_CACHE_TILES => const fb.Uint16Reader().vTableGet(_bc, _bcOffset, 10, 100);
  double get VERTICAL_EXAGGERATION => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 12, 1.0);

  @override
  String toString() {
    return 'TRN{SOURCES: ${SOURCES}, INTERPOLATION: ${INTERPOLATION}, CACHE_ENABLED: ${CACHE_ENABLED}, MAX_CACHE_TILES: ${MAX_CACHE_TILES}, VERTICAL_EXAGGERATION: ${VERTICAL_EXAGGERATION}}';
  }
}

class _TRNReader extends fb.TableReader<TRN> {
  const _TRNReader();

  @override
  TRN createObject(fb.BufferContext bc, int offset) => 
    TRN._(bc, offset);
}

class TRNBuilder {
  TRNBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(5);
  }

  int addSourcesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }
  int addInterpolation(TerrainInterpolation? INTERPOLATION) {
    fbBuilder.addInt8(1, INTERPOLATION?.value);
    return fbBuilder.offset;
  }
  int addCacheEnabled(bool? CACHE_ENABLED) {
    fbBuilder.addBool(2, CACHE_ENABLED);
    return fbBuilder.offset;
  }
  int addMaxCacheTiles(int? MAX_CACHE_TILES) {
    fbBuilder.addUint16(3, MAX_CACHE_TILES);
    return fbBuilder.offset;
  }
  int addVerticalExaggeration(double? VERTICAL_EXAGGERATION) {
    fbBuilder.addFloat64(4, VERTICAL_EXAGGERATION);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TRNObjectBuilder extends fb.ObjectBuilder {
  final List<TerrainDataSource>? _SOURCES;
  final TerrainInterpolation? _INTERPOLATION;
  final bool? _CACHE_ENABLED;
  final int? _MAX_CACHE_TILES;
  final double? _VERTICAL_EXAGGERATION;

  TRNObjectBuilder({
    List<TerrainDataSource>? SOURCES,
    TerrainInterpolation? INTERPOLATION,
    bool? CACHE_ENABLED,
    int? MAX_CACHE_TILES,
    double? VERTICAL_EXAGGERATION,
  })
      : _SOURCES = SOURCES,
        _INTERPOLATION = INTERPOLATION,
        _CACHE_ENABLED = CACHE_ENABLED,
        _MAX_CACHE_TILES = MAX_CACHE_TILES,
        _VERTICAL_EXAGGERATION = VERTICAL_EXAGGERATION;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? SOURCESOffset = _SOURCES == null ? null
        : fbBuilder.writeListInt8(_SOURCES!.map((f) => f.value).toList());
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, SOURCESOffset);
    fbBuilder.addInt8(1, _INTERPOLATION?.value);
    fbBuilder.addBool(2, _CACHE_ENABLED);
    fbBuilder.addUint16(3, _MAX_CACHE_TILES);
    fbBuilder.addFloat64(4, _VERTICAL_EXAGGERATION);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
