// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Encryption Header containing all parameters needed for decryption
 */
@Suppress("unused")
class ENC : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ENC {
        __init(_i, _bb)
        return this
    }
    /**
     * Schema version for forward compatibility
     */
    val VERSION : UByte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 1u
        }
    /**
     * Key exchange algorithm used
     */
    val KEY_EXCHANGE : Byte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Symmetric encryption algorithm used
     */
    val SYMMETRIC : Byte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Key derivation function used
     */
    val KEY_DERIVATION : Byte
        get() {
            val o = __offset(10)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
     */
    fun EPHEMERAL_PUBLIC_KEY(j: Int) : UByte {
        val o = __offset(12)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            throw IndexOutOfBoundsException("Index out of range: $j, vector EPHEMERAL_PUBLIC_KEY is empty")
        }
    }
    val EPHEMERAL_PUBLIC_KEYLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    val EPHEMERAL_PUBLIC_KEYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun EPHEMERAL_PUBLIC_KEYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
     */
    fun NONCE_START(j: Int) : UByte {
        val o = __offset(14)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            throw IndexOutOfBoundsException("Index out of range: $j, vector NONCE_START is empty")
        }
    }
    val NONCE_STARTLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    val NONCE_STARTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun NONCE_STARTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Optional identifier for the recipient's public key (up to 32 bytes)
     */
    fun RECIPIENT_KEY_ID(j: Int) : UByte {
        val o = __offset(16)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val RECIPIENT_KEY_IDLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    val RECIPIENT_KEY_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun RECIPIENT_KEY_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Optional domain separation context string
     */
    val CONTEXT : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CONTEXTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun CONTEXTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
     */
    fun SCHEMA_HASH(j: Int) : UByte {
        val o = __offset(20)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val SCHEMA_HASHLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    val SCHEMA_HASHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun SCHEMA_HASHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Optional root type name from the schema
     */
    val ROOT_TYPE : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ROOT_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun ROOT_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Optional Unix timestamp (milliseconds) when encryption was performed
     */
    val TIMESTAMP : ULong
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsENC(_bb: ByteBuffer): ENC = getRootAsENC(_bb, ENC())
        fun getRootAsENC(_bb: ByteBuffer, obj: ENC): ENC {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun ENCBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$ENC")
        fun createENC(builder: FlatBufferBuilder, VERSION: UByte, KEY_EXCHANGE: Byte, SYMMETRIC: Byte, KEY_DERIVATION: Byte, EPHEMERAL_PUBLIC_KEYOffset: Int, NONCE_STARTOffset: Int, RECIPIENT_KEY_IDOffset: Int, CONTEXTOffset: Int, SCHEMA_HASHOffset: Int, ROOT_TYPEOffset: Int, TIMESTAMP: ULong) : Int {
            builder.startTable(11)
            addTIMESTAMP(builder, TIMESTAMP)
            addROOT_TYPE(builder, ROOT_TYPEOffset)
            addSCHEMA_HASH(builder, SCHEMA_HASHOffset)
            addCONTEXT(builder, CONTEXTOffset)
            addRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_IDOffset)
            addNONCE_START(builder, NONCE_STARTOffset)
            addEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEYOffset)
            addKEY_DERIVATION(builder, KEY_DERIVATION)
            addSYMMETRIC(builder, SYMMETRIC)
            addKEY_EXCHANGE(builder, KEY_EXCHANGE)
            addVERSION(builder, VERSION)
            return endENC(builder)
        }
        fun startENC(builder: FlatBufferBuilder) = builder.startTable(11)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: UByte) = builder.addByte(0, VERSION.toByte(), 1)
        fun addKEY_EXCHANGE(builder: FlatBufferBuilder, KEY_EXCHANGE: Byte) = builder.addByte(1, KEY_EXCHANGE, 0)
        fun addSYMMETRIC(builder: FlatBufferBuilder, SYMMETRIC: Byte) = builder.addByte(2, SYMMETRIC, 0)
        fun addKEY_DERIVATION(builder: FlatBufferBuilder, KEY_DERIVATION: Byte) = builder.addByte(3, KEY_DERIVATION, 0)
        fun addEPHEMERAL_PUBLIC_KEY(builder: FlatBufferBuilder, EPHEMERAL_PUBLIC_KEY: Int) = builder.addOffset(4, EPHEMERAL_PUBLIC_KEY, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createEphemeralPublicKeyVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startEphemeralPublicKeyVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addNONCE_START(builder: FlatBufferBuilder, NONCE_START: Int) = builder.addOffset(5, NONCE_START, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createNonceStartVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startNonceStartVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addRECIPIENT_KEY_ID(builder: FlatBufferBuilder, RECIPIENT_KEY_ID: Int) = builder.addOffset(6, RECIPIENT_KEY_ID, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createRecipientKeyIdVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startRecipientKeyIdVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addCONTEXT(builder: FlatBufferBuilder, CONTEXT: Int) = builder.addOffset(7, CONTEXT, 0)
        fun addSCHEMA_HASH(builder: FlatBufferBuilder, SCHEMA_HASH: Int) = builder.addOffset(8, SCHEMA_HASH, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createSchemaHashVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startSchemaHashVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addROOT_TYPE(builder: FlatBufferBuilder, ROOT_TYPE: Int) = builder.addOffset(9, ROOT_TYPE, 0)
        fun addTIMESTAMP(builder: FlatBufferBuilder, TIMESTAMP: ULong) = builder.addLong(10, TIMESTAMP.toLong(), 0)
        fun endENC(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 12)
                builder.required(o, 14)
            return o
        }
        fun finishENCBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$ENC")
        fun finishSizePrefixedENCBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$ENC")
    }
}
