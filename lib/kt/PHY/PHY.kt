// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Physics and Rigid Body Dynamics
 */
@Suppress("unused")
class PHY : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PHY {
        __init(_i, _bb)
        return this
    }
    val COMMAND : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COMMANDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun COMMANDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val SIMULATION_STEP : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SIMULATION_STEPAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun SIMULATION_STEPInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    val RIGID_BODY : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val RIGID_BODYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun RIGID_BODYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    val INTEGRATION_CONFIG : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val INTEGRATION_CONFIGAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun INTEGRATION_CONFIGInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    val COLLISION_QUERY_A : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COLLISION_QUERY_AAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun COLLISION_QUERY_AInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    val COLLISION_QUERY_B : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COLLISION_QUERY_BAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun COLLISION_QUERY_BInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    val TRANSFORM_A : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRANSFORM_AAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun TRANSFORM_AInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    val TRANSFORM_B : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRANSFORM_BAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun TRANSFORM_BInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    val POSITION_A : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val POSITION_AAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun POSITION_AInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    val POSITION_B : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val POSITION_BAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun POSITION_BInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    val FLUID : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val FLUIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun FLUIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    val AERO_QUERY : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val AERO_QUERYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun AERO_QUERYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    val DRAG_MODEL : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DRAG_MODELAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun DRAG_MODELInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    val THERMAL_STATE : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val THERMAL_STATEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun THERMAL_STATEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsPHY(_bb: ByteBuffer): PHY = getRootAsPHY(_bb, PHY())
        fun getRootAsPHY(_bb: ByteBuffer, obj: PHY): PHY {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PHYBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PHY")
        fun createPHY(builder: FlatBufferBuilder, COMMANDOffset: Int, SIMULATION_STEPOffset: Int, RIGID_BODYOffset: Int, INTEGRATION_CONFIGOffset: Int, COLLISION_QUERY_AOffset: Int, COLLISION_QUERY_BOffset: Int, TRANSFORM_AOffset: Int, TRANSFORM_BOffset: Int, POSITION_AOffset: Int, POSITION_BOffset: Int, FLUIDOffset: Int, AERO_QUERYOffset: Int, DRAG_MODELOffset: Int, THERMAL_STATEOffset: Int) : Int {
            builder.startTable(14)
            addTHERMAL_STATE(builder, THERMAL_STATEOffset)
            addDRAG_MODEL(builder, DRAG_MODELOffset)
            addAERO_QUERY(builder, AERO_QUERYOffset)
            addFLUID(builder, FLUIDOffset)
            addPOSITION_B(builder, POSITION_BOffset)
            addPOSITION_A(builder, POSITION_AOffset)
            addTRANSFORM_B(builder, TRANSFORM_BOffset)
            addTRANSFORM_A(builder, TRANSFORM_AOffset)
            addCOLLISION_QUERY_B(builder, COLLISION_QUERY_BOffset)
            addCOLLISION_QUERY_A(builder, COLLISION_QUERY_AOffset)
            addINTEGRATION_CONFIG(builder, INTEGRATION_CONFIGOffset)
            addRIGID_BODY(builder, RIGID_BODYOffset)
            addSIMULATION_STEP(builder, SIMULATION_STEPOffset)
            addCOMMAND(builder, COMMANDOffset)
            return endPHY(builder)
        }
        fun startPHY(builder: FlatBufferBuilder) = builder.startTable(14)
        fun addCOMMAND(builder: FlatBufferBuilder, COMMAND: Int) = builder.addOffset(0, COMMAND, 0)
        fun addSIMULATION_STEP(builder: FlatBufferBuilder, SIMULATION_STEP: Int) = builder.addOffset(1, SIMULATION_STEP, 0)
        fun addRIGID_BODY(builder: FlatBufferBuilder, RIGID_BODY: Int) = builder.addOffset(2, RIGID_BODY, 0)
        fun addINTEGRATION_CONFIG(builder: FlatBufferBuilder, INTEGRATION_CONFIG: Int) = builder.addOffset(3, INTEGRATION_CONFIG, 0)
        fun addCOLLISION_QUERY_A(builder: FlatBufferBuilder, COLLISION_QUERY_A: Int) = builder.addOffset(4, COLLISION_QUERY_A, 0)
        fun addCOLLISION_QUERY_B(builder: FlatBufferBuilder, COLLISION_QUERY_B: Int) = builder.addOffset(5, COLLISION_QUERY_B, 0)
        fun addTRANSFORM_A(builder: FlatBufferBuilder, TRANSFORM_A: Int) = builder.addOffset(6, TRANSFORM_A, 0)
        fun addTRANSFORM_B(builder: FlatBufferBuilder, TRANSFORM_B: Int) = builder.addOffset(7, TRANSFORM_B, 0)
        fun addPOSITION_A(builder: FlatBufferBuilder, POSITION_A: Int) = builder.addOffset(8, POSITION_A, 0)
        fun addPOSITION_B(builder: FlatBufferBuilder, POSITION_B: Int) = builder.addOffset(9, POSITION_B, 0)
        fun addFLUID(builder: FlatBufferBuilder, FLUID: Int) = builder.addOffset(10, FLUID, 0)
        fun addAERO_QUERY(builder: FlatBufferBuilder, AERO_QUERY: Int) = builder.addOffset(11, AERO_QUERY, 0)
        fun addDRAG_MODEL(builder: FlatBufferBuilder, DRAG_MODEL: Int) = builder.addOffset(12, DRAG_MODEL, 0)
        fun addTHERMAL_STATE(builder: FlatBufferBuilder, THERMAL_STATE: Int) = builder.addOffset(13, THERMAL_STATE, 0)
        fun endPHY(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishPHYBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PHY")
        fun finishSizePrefixedPHYBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PHY")
    }
}
