// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Propagator Configuration
 */
@Suppress("unused")
class PCF : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PCF {
        __init(_i, _bb)
        return this
    }
    val STEP_SIZE : Double
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val TOLERANCE : Double
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val MIN_STEP : Double
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val MAX_STEP : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val MAX_ITERATIONS : UInt
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val GRAVITY_DEGREE : UShort
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val GRAVITY_ORDER : UShort
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val INTEGRATOR : UByte
        get() {
            val o = __offset(18)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val OUTPUT_FRAME : UByte
        get() {
            val o = __offset(20)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val FORCE_FLAGS : UShort
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val DRAG_COEFFICIENT : Float
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val SRP_COEFFICIENT : Float
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val AREA_MASS_RATIO : Float
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    fun RESERVED(j: Int) : UByte {
        val o = __offset(30)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val RESERVEDLength : Int
        get() {
            val o = __offset(30); return if (o != 0) __vector_len(o) else 0
        }
    val RESERVEDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun RESERVEDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsPCF(_bb: ByteBuffer): PCF = getRootAsPCF(_bb, PCF())
        fun getRootAsPCF(_bb: ByteBuffer, obj: PCF): PCF {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PCFBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PCF")
        fun createPCF(builder: FlatBufferBuilder, STEP_SIZE: Double, TOLERANCE: Double, MIN_STEP: Double, MAX_STEP: Double, MAX_ITERATIONS: UInt, GRAVITY_DEGREE: UShort, GRAVITY_ORDER: UShort, INTEGRATOR: UByte, OUTPUT_FRAME: UByte, FORCE_FLAGS: UShort, DRAG_COEFFICIENT: Float, SRP_COEFFICIENT: Float, AREA_MASS_RATIO: Float, RESERVEDOffset: Int) : Int {
            builder.startTable(14)
            addMAX_STEP(builder, MAX_STEP)
            addMIN_STEP(builder, MIN_STEP)
            addTOLERANCE(builder, TOLERANCE)
            addSTEP_SIZE(builder, STEP_SIZE)
            addRESERVED(builder, RESERVEDOffset)
            addAREA_MASS_RATIO(builder, AREA_MASS_RATIO)
            addSRP_COEFFICIENT(builder, SRP_COEFFICIENT)
            addDRAG_COEFFICIENT(builder, DRAG_COEFFICIENT)
            addMAX_ITERATIONS(builder, MAX_ITERATIONS)
            addFORCE_FLAGS(builder, FORCE_FLAGS)
            addGRAVITY_ORDER(builder, GRAVITY_ORDER)
            addGRAVITY_DEGREE(builder, GRAVITY_DEGREE)
            addOUTPUT_FRAME(builder, OUTPUT_FRAME)
            addINTEGRATOR(builder, INTEGRATOR)
            return endPCF(builder)
        }
        fun startPCF(builder: FlatBufferBuilder) = builder.startTable(14)
        fun addSTEP_SIZE(builder: FlatBufferBuilder, STEP_SIZE: Double) = builder.addDouble(0, STEP_SIZE, 0.0)
        fun addTOLERANCE(builder: FlatBufferBuilder, TOLERANCE: Double) = builder.addDouble(1, TOLERANCE, 0.0)
        fun addMIN_STEP(builder: FlatBufferBuilder, MIN_STEP: Double) = builder.addDouble(2, MIN_STEP, 0.0)
        fun addMAX_STEP(builder: FlatBufferBuilder, MAX_STEP: Double) = builder.addDouble(3, MAX_STEP, 0.0)
        fun addMAX_ITERATIONS(builder: FlatBufferBuilder, MAX_ITERATIONS: UInt) = builder.addInt(4, MAX_ITERATIONS.toInt(), 0)
        fun addGRAVITY_DEGREE(builder: FlatBufferBuilder, GRAVITY_DEGREE: UShort) = builder.addShort(5, GRAVITY_DEGREE.toShort(), 0)
        fun addGRAVITY_ORDER(builder: FlatBufferBuilder, GRAVITY_ORDER: UShort) = builder.addShort(6, GRAVITY_ORDER.toShort(), 0)
        fun addINTEGRATOR(builder: FlatBufferBuilder, INTEGRATOR: UByte) = builder.addByte(7, INTEGRATOR.toByte(), 0)
        fun addOUTPUT_FRAME(builder: FlatBufferBuilder, OUTPUT_FRAME: UByte) = builder.addByte(8, OUTPUT_FRAME.toByte(), 0)
        fun addFORCE_FLAGS(builder: FlatBufferBuilder, FORCE_FLAGS: UShort) = builder.addShort(9, FORCE_FLAGS.toShort(), 0)
        fun addDRAG_COEFFICIENT(builder: FlatBufferBuilder, DRAG_COEFFICIENT: Float) = builder.addFloat(10, DRAG_COEFFICIENT, 0.0)
        fun addSRP_COEFFICIENT(builder: FlatBufferBuilder, SRP_COEFFICIENT: Float) = builder.addFloat(11, SRP_COEFFICIENT, 0.0)
        fun addAREA_MASS_RATIO(builder: FlatBufferBuilder, AREA_MASS_RATIO: Float) = builder.addFloat(12, AREA_MASS_RATIO, 0.0)
        fun addRESERVED(builder: FlatBufferBuilder, RESERVED: Int) = builder.addOffset(13, RESERVED, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createReservedVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startReservedVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endPCF(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishPCFBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PCF")
        fun finishSizePrefixedPCFBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PCF")
    }
}
