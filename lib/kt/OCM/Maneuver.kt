// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class Maneuver : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : Maneuver {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier for the maneuver.
     */
    val MAN_ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun MAN_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Basis of the maneuver plan (e.g., planned, predicted, estimated).
     */
    val MAN_BASIS : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_BASISAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun MAN_BASISInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Identifier of the maneuver device.
     */
    val MAN_DEVICE_ID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_DEVICE_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun MAN_DEVICE_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Identifier of the previous maneuver.
     */
    val MAN_PREV_ID : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_PREV_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun MAN_PREV_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Purpose of the maneuver.
     */
    val MAN_PURPOSE : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_PURPOSEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun MAN_PURPOSEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Reference frame for the maneuver data.
     */
    val MAN_REF_FRAME : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_REF_FRAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun MAN_REF_FRAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Epoch of the maneuver reference frame.
     */
    val MAN_FRAME_EPOCH : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_FRAME_EPOCHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun MAN_FRAME_EPOCHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Type of maneuver (e.g., IMPULSIVE, FINITE).
     */
    val MAN_TYPE : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun MAN_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Start epoch of the maneuver.
     */
    val MAN_EPOCH_START : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAN_EPOCH_STARTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun MAN_EPOCH_STARTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Duration of the maneuver.
     */
    val MAN_DURATION : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Units for the maneuver data values.
     */
    fun MAN_UNITS(j: Int) : String? {
        val o = __offset(24)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MAN_UNITSLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Data associated with the maneuver.
     */
    fun DATA(j: Int) : String? {
        val o = __offset(26)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val DATALength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Comments related to the maneuver.
     */
    fun MAN_COMMENT(j: Int) : String? {
        val o = __offset(28)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MAN_COMMENTLength : Int
        get() {
            val o = __offset(28); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsManeuver(_bb: ByteBuffer): Maneuver = getRootAsManeuver(_bb, Maneuver())
        fun getRootAsManeuver(_bb: ByteBuffer, obj: Maneuver): Maneuver {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createManeuver(builder: FlatBufferBuilder, MAN_IDOffset: Int, MAN_BASISOffset: Int, MAN_DEVICE_IDOffset: Int, MAN_PREV_IDOffset: Int, MAN_PURPOSEOffset: Int, MAN_REF_FRAMEOffset: Int, MAN_FRAME_EPOCHOffset: Int, MAN_TYPEOffset: Int, MAN_EPOCH_STARTOffset: Int, MAN_DURATION: Double, MAN_UNITSOffset: Int, DATAOffset: Int, MAN_COMMENTOffset: Int) : Int {
            builder.startTable(13)
            addMAN_DURATION(builder, MAN_DURATION)
            addMAN_COMMENT(builder, MAN_COMMENTOffset)
            addDATA(builder, DATAOffset)
            addMAN_UNITS(builder, MAN_UNITSOffset)
            addMAN_EPOCH_START(builder, MAN_EPOCH_STARTOffset)
            addMAN_TYPE(builder, MAN_TYPEOffset)
            addMAN_FRAME_EPOCH(builder, MAN_FRAME_EPOCHOffset)
            addMAN_REF_FRAME(builder, MAN_REF_FRAMEOffset)
            addMAN_PURPOSE(builder, MAN_PURPOSEOffset)
            addMAN_PREV_ID(builder, MAN_PREV_IDOffset)
            addMAN_DEVICE_ID(builder, MAN_DEVICE_IDOffset)
            addMAN_BASIS(builder, MAN_BASISOffset)
            addMAN_ID(builder, MAN_IDOffset)
            return endManeuver(builder)
        }
        fun startManeuver(builder: FlatBufferBuilder) = builder.startTable(13)
        fun addMAN_ID(builder: FlatBufferBuilder, MAN_ID: Int) = builder.addOffset(0, MAN_ID, 0)
        fun addMAN_BASIS(builder: FlatBufferBuilder, MAN_BASIS: Int) = builder.addOffset(1, MAN_BASIS, 0)
        fun addMAN_DEVICE_ID(builder: FlatBufferBuilder, MAN_DEVICE_ID: Int) = builder.addOffset(2, MAN_DEVICE_ID, 0)
        fun addMAN_PREV_ID(builder: FlatBufferBuilder, MAN_PREV_ID: Int) = builder.addOffset(3, MAN_PREV_ID, 0)
        fun addMAN_PURPOSE(builder: FlatBufferBuilder, MAN_PURPOSE: Int) = builder.addOffset(4, MAN_PURPOSE, 0)
        fun addMAN_REF_FRAME(builder: FlatBufferBuilder, MAN_REF_FRAME: Int) = builder.addOffset(5, MAN_REF_FRAME, 0)
        fun addMAN_FRAME_EPOCH(builder: FlatBufferBuilder, MAN_FRAME_EPOCH: Int) = builder.addOffset(6, MAN_FRAME_EPOCH, 0)
        fun addMAN_TYPE(builder: FlatBufferBuilder, MAN_TYPE: Int) = builder.addOffset(7, MAN_TYPE, 0)
        fun addMAN_EPOCH_START(builder: FlatBufferBuilder, MAN_EPOCH_START: Int) = builder.addOffset(8, MAN_EPOCH_START, 0)
        fun addMAN_DURATION(builder: FlatBufferBuilder, MAN_DURATION: Double) = builder.addDouble(9, MAN_DURATION, 0.0)
        fun addMAN_UNITS(builder: FlatBufferBuilder, MAN_UNITS: Int) = builder.addOffset(10, MAN_UNITS, 0)
        fun createManUnitsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startManUnitsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDATA(builder: FlatBufferBuilder, DATA: Int) = builder.addOffset(11, DATA, 0)
        fun createDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMAN_COMMENT(builder: FlatBufferBuilder, MAN_COMMENT: Int) = builder.addOffset(12, MAN_COMMENT, 0)
        fun createManCommentVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startManCommentVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endManeuver(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
