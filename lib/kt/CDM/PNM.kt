// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Publish Notification Message
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class PNM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PNM {
        __init(_i, _bb)
        return this
    }
    /**
     * Multiformat Address
     * https://multiformats.io/multiaddr/
     * A universal address format for representing multiple network protocols. Examples include:
     * - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
     * - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
     * - /dns4/example.com for a domain name resolvable only to IPv4 addresses
     * - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
     */
    val MULTIFORMAT_ADDRESS : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MULTIFORMAT_ADDRESSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun MULTIFORMAT_ADDRESSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Publish Time OF THE Publish Notification Message
     */
    val PUBLISH_TIMESTAMP : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PUBLISH_TIMESTAMPAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun PUBLISH_TIMESTAMPInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Concatenated Content Identifier (CID)
     * This field is a unique ID for distributed systems (CID).
     * The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
     */
    val CID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * File ID
     * This field is the file ID / Name
     */
    val FID : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val FIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun FIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Digital Signature of the CID
     * This is the digital signature of the CID, signed using the specified cryptographic method.
     */
    val SIGNATURE : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Timestamp Signature
     * Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
     */
    val TIMESTAMP_SIGNATURE : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TIMESTAMP_SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun TIMESTAMP_SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Type of Cryptographic Signature Used
     * Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
     */
    val SIGNATURE_TYPE : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SIGNATURE_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun SIGNATURE_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Type of Cryptographic Signature Used for Timestamp
     * Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
     */
    val TIMESTAMP_SIGNATURE_TYPE : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TIMESTAMP_SIGNATURE_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun TIMESTAMP_SIGNATURE_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsPNM(_bb: ByteBuffer): PNM = getRootAsPNM(_bb, PNM())
        fun getRootAsPNM(_bb: ByteBuffer, obj: PNM): PNM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PNMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PNM")
        fun createPNM(builder: FlatBufferBuilder, MULTIFORMAT_ADDRESSOffset: Int, PUBLISH_TIMESTAMPOffset: Int, CIDOffset: Int, FIDOffset: Int, SIGNATUREOffset: Int, TIMESTAMP_SIGNATUREOffset: Int, SIGNATURE_TYPEOffset: Int, TIMESTAMP_SIGNATURE_TYPEOffset: Int) : Int {
            builder.startTable(8)
            addTIMESTAMP_SIGNATURE_TYPE(builder, TIMESTAMP_SIGNATURE_TYPEOffset)
            addSIGNATURE_TYPE(builder, SIGNATURE_TYPEOffset)
            addTIMESTAMP_SIGNATURE(builder, TIMESTAMP_SIGNATUREOffset)
            addSIGNATURE(builder, SIGNATUREOffset)
            addFID(builder, FIDOffset)
            addCID(builder, CIDOffset)
            addPUBLISH_TIMESTAMP(builder, PUBLISH_TIMESTAMPOffset)
            addMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESSOffset)
            return endPNM(builder)
        }
        fun startPNM(builder: FlatBufferBuilder) = builder.startTable(8)
        fun addMULTIFORMAT_ADDRESS(builder: FlatBufferBuilder, MULTIFORMAT_ADDRESS: Int) = builder.addOffset(0, MULTIFORMAT_ADDRESS, 0)
        fun addPUBLISH_TIMESTAMP(builder: FlatBufferBuilder, PUBLISH_TIMESTAMP: Int) = builder.addOffset(1, PUBLISH_TIMESTAMP, 0)
        fun addCID(builder: FlatBufferBuilder, CID: Int) = builder.addOffset(2, CID, 0)
        fun addFID(builder: FlatBufferBuilder, FID: Int) = builder.addOffset(3, FID, 0)
        fun addSIGNATURE(builder: FlatBufferBuilder, SIGNATURE: Int) = builder.addOffset(4, SIGNATURE, 0)
        fun addTIMESTAMP_SIGNATURE(builder: FlatBufferBuilder, TIMESTAMP_SIGNATURE: Int) = builder.addOffset(5, TIMESTAMP_SIGNATURE, 0)
        fun addSIGNATURE_TYPE(builder: FlatBufferBuilder, SIGNATURE_TYPE: Int) = builder.addOffset(6, SIGNATURE_TYPE, 0)
        fun addTIMESTAMP_SIGNATURE_TYPE(builder: FlatBufferBuilder, TIMESTAMP_SIGNATURE_TYPE: Int) = builder.addOffset(7, TIMESTAMP_SIGNATURE_TYPE, 0)
        fun endPNM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishPNMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PNM")
        fun finishSizePrefixedPNMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PNM")
    }
}
