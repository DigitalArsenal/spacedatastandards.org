// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Attitude Data Point
 */
@Suppress("unused")
class ATD : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ATD {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Attitude set identifier (groups time-series points)
     */
    val AS_ID : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val AS_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun AS_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Satellite catalog number
     */
    val SAT_NO : UInt
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * International designator
     */
    val ORIG_OBJECT_ID : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun ORIG_OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Observation epoch (ISO 8601)
     */
    val EPOCH : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EPOCHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun EPOCHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Attitude representation used
     */
    val REPRESENTATION : Byte
        get() {
            val o = __offset(14)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Motion characterization
     */
    val MOTION_TYPE : Byte
        get() {
            val o = __offset(16)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Quaternion scalar component (q0 or qc)
     */
    val QC : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector component 1
     */
    val Q1 : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector component 2
     */
    val Q2 : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector component 3
     */
    val Q3 : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion scalar rate (rad/s)
     */
    val QC_DOT : Double
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector rate 1 (rad/s)
     */
    val Q1_DOT : Double
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector rate 2 (rad/s)
     */
    val Q2_DOT : Double
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Quaternion vector rate 3 (rad/s)
     */
    val Q3_DOT : Double
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Euler angle X (degrees)
     */
    val X_ANGLE : Double
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Euler angle Y (degrees)
     */
    val Y_ANGLE : Double
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Euler angle Z (degrees)
     */
    val Z_ANGLE : Double
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Angular rate about X (deg/s)
     */
    val X_RATE : Double
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Angular rate about Y (deg/s)
     */
    val Y_RATE : Double
        get() {
            val o = __offset(42)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Angular rate about Z (deg/s)
     */
    val Z_RATE : Double
        get() {
            val o = __offset(44)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Right ascension of spin axis (degrees)
     */
    val RA : Double
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Declination of spin axis (degrees)
     */
    val DECLINATION : Double
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Coning half-angle (degrees)
     */
    val CONING_ANGLE : Double
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Precession period (seconds)
     */
    val PREC_PERIOD : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Spin period (seconds)
     */
    val SPIN_PERIOD : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Attitude uncertainty (degrees, 1-sigma)
     */
    val ATTITUDE_UNC : Double
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Rate uncertainty (deg/s, 1-sigma)
     */
    val RATE_UNC : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Data quality (0-9, 9=best)
     */
    val QUALITY : UByte
        get() {
            val o = __offset(60)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Reference frame for attitude
     */
    val REF_FRAME : String?
        get() {
            val o = __offset(62)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val REF_FRAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(62, 1)
    fun REF_FRAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 62, 1)
    /**
     * Sensor identifier providing the observation
     */
    val SENSOR_ID : String?
        get() {
            val o = __offset(64)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SENSOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 1)
    fun SENSOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsATD(_bb: ByteBuffer): ATD = getRootAsATD(_bb, ATD())
        fun getRootAsATD(_bb: ByteBuffer, obj: ATD): ATD {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun ATDBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$ATD")
        fun createATD(builder: FlatBufferBuilder, IDOffset: Int, AS_IDOffset: Int, SAT_NO: UInt, ORIG_OBJECT_IDOffset: Int, EPOCHOffset: Int, REPRESENTATION: Byte, MOTION_TYPE: Byte, QC: Double, Q1: Double, Q2: Double, Q3: Double, QC_DOT: Double, Q1_DOT: Double, Q2_DOT: Double, Q3_DOT: Double, X_ANGLE: Double, Y_ANGLE: Double, Z_ANGLE: Double, X_RATE: Double, Y_RATE: Double, Z_RATE: Double, RA: Double, DECLINATION: Double, CONING_ANGLE: Double, PREC_PERIOD: Double, SPIN_PERIOD: Double, ATTITUDE_UNC: Double, RATE_UNC: Double, QUALITY: UByte, REF_FRAMEOffset: Int, SENSOR_IDOffset: Int) : Int {
            builder.startTable(31)
            addRATE_UNC(builder, RATE_UNC)
            addATTITUDE_UNC(builder, ATTITUDE_UNC)
            addSPIN_PERIOD(builder, SPIN_PERIOD)
            addPREC_PERIOD(builder, PREC_PERIOD)
            addCONING_ANGLE(builder, CONING_ANGLE)
            addDECLINATION(builder, DECLINATION)
            addRA(builder, RA)
            addZ_RATE(builder, Z_RATE)
            addY_RATE(builder, Y_RATE)
            addX_RATE(builder, X_RATE)
            addZ_ANGLE(builder, Z_ANGLE)
            addY_ANGLE(builder, Y_ANGLE)
            addX_ANGLE(builder, X_ANGLE)
            addQ3_DOT(builder, Q3_DOT)
            addQ2_DOT(builder, Q2_DOT)
            addQ1_DOT(builder, Q1_DOT)
            addQC_DOT(builder, QC_DOT)
            addQ3(builder, Q3)
            addQ2(builder, Q2)
            addQ1(builder, Q1)
            addQC(builder, QC)
            addSENSOR_ID(builder, SENSOR_IDOffset)
            addREF_FRAME(builder, REF_FRAMEOffset)
            addEPOCH(builder, EPOCHOffset)
            addORIG_OBJECT_ID(builder, ORIG_OBJECT_IDOffset)
            addSAT_NO(builder, SAT_NO)
            addAS_ID(builder, AS_IDOffset)
            addID(builder, IDOffset)
            addQUALITY(builder, QUALITY)
            addMOTION_TYPE(builder, MOTION_TYPE)
            addREPRESENTATION(builder, REPRESENTATION)
            return endATD(builder)
        }
        fun startATD(builder: FlatBufferBuilder) = builder.startTable(31)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addAS_ID(builder: FlatBufferBuilder, AS_ID: Int) = builder.addOffset(1, AS_ID, 0)
        fun addSAT_NO(builder: FlatBufferBuilder, SAT_NO: UInt) = builder.addInt(2, SAT_NO.toInt(), 0)
        fun addORIG_OBJECT_ID(builder: FlatBufferBuilder, ORIG_OBJECT_ID: Int) = builder.addOffset(3, ORIG_OBJECT_ID, 0)
        fun addEPOCH(builder: FlatBufferBuilder, EPOCH: Int) = builder.addOffset(4, EPOCH, 0)
        fun addREPRESENTATION(builder: FlatBufferBuilder, REPRESENTATION: Byte) = builder.addByte(5, REPRESENTATION, 0)
        fun addMOTION_TYPE(builder: FlatBufferBuilder, MOTION_TYPE: Byte) = builder.addByte(6, MOTION_TYPE, 0)
        fun addQC(builder: FlatBufferBuilder, QC: Double) = builder.addDouble(7, QC, 0.0)
        fun addQ1(builder: FlatBufferBuilder, Q1: Double) = builder.addDouble(8, Q1, 0.0)
        fun addQ2(builder: FlatBufferBuilder, Q2: Double) = builder.addDouble(9, Q2, 0.0)
        fun addQ3(builder: FlatBufferBuilder, Q3: Double) = builder.addDouble(10, Q3, 0.0)
        fun addQC_DOT(builder: FlatBufferBuilder, QC_DOT: Double) = builder.addDouble(11, QC_DOT, 0.0)
        fun addQ1_DOT(builder: FlatBufferBuilder, Q1_DOT: Double) = builder.addDouble(12, Q1_DOT, 0.0)
        fun addQ2_DOT(builder: FlatBufferBuilder, Q2_DOT: Double) = builder.addDouble(13, Q2_DOT, 0.0)
        fun addQ3_DOT(builder: FlatBufferBuilder, Q3_DOT: Double) = builder.addDouble(14, Q3_DOT, 0.0)
        fun addX_ANGLE(builder: FlatBufferBuilder, X_ANGLE: Double) = builder.addDouble(15, X_ANGLE, 0.0)
        fun addY_ANGLE(builder: FlatBufferBuilder, Y_ANGLE: Double) = builder.addDouble(16, Y_ANGLE, 0.0)
        fun addZ_ANGLE(builder: FlatBufferBuilder, Z_ANGLE: Double) = builder.addDouble(17, Z_ANGLE, 0.0)
        fun addX_RATE(builder: FlatBufferBuilder, X_RATE: Double) = builder.addDouble(18, X_RATE, 0.0)
        fun addY_RATE(builder: FlatBufferBuilder, Y_RATE: Double) = builder.addDouble(19, Y_RATE, 0.0)
        fun addZ_RATE(builder: FlatBufferBuilder, Z_RATE: Double) = builder.addDouble(20, Z_RATE, 0.0)
        fun addRA(builder: FlatBufferBuilder, RA: Double) = builder.addDouble(21, RA, 0.0)
        fun addDECLINATION(builder: FlatBufferBuilder, DECLINATION: Double) = builder.addDouble(22, DECLINATION, 0.0)
        fun addCONING_ANGLE(builder: FlatBufferBuilder, CONING_ANGLE: Double) = builder.addDouble(23, CONING_ANGLE, 0.0)
        fun addPREC_PERIOD(builder: FlatBufferBuilder, PREC_PERIOD: Double) = builder.addDouble(24, PREC_PERIOD, 0.0)
        fun addSPIN_PERIOD(builder: FlatBufferBuilder, SPIN_PERIOD: Double) = builder.addDouble(25, SPIN_PERIOD, 0.0)
        fun addATTITUDE_UNC(builder: FlatBufferBuilder, ATTITUDE_UNC: Double) = builder.addDouble(26, ATTITUDE_UNC, 0.0)
        fun addRATE_UNC(builder: FlatBufferBuilder, RATE_UNC: Double) = builder.addDouble(27, RATE_UNC, 0.0)
        fun addQUALITY(builder: FlatBufferBuilder, QUALITY: UByte) = builder.addByte(28, QUALITY.toByte(), 0)
        fun addREF_FRAME(builder: FlatBufferBuilder, REF_FRAME: Int) = builder.addOffset(29, REF_FRAME, 0)
        fun addSENSOR_ID(builder: FlatBufferBuilder, SENSOR_ID: Int) = builder.addOffset(30, SENSOR_ID, 0)
        fun endATD(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishATDBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$ATD")
        fun finishSizePrefixedATDBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$ATD")
    }
}
