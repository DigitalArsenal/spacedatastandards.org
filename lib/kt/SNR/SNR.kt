// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Sensor Systems
 */
@Suppress("unused")
class SNR : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : SNR {
        __init(_i, _bb)
        return this
    }
    val TYPE : UByte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val MODE : UByte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val RESERVED1 : UShort
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val MAX_RANGE : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val MIN_RANGE : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val FOV_AZIMUTH : Float
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val FOV_ELEVATION : Float
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ANGULAR_RESOLUTION : Float
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val RANGE_RESOLUTION : Float
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val UPDATE_RATE : Float
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val DETECTION_THRESHOLD : Float
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val AZIMUTH_SCAN_RATE : Float
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ELEVATION_SCAN_RATE : Float
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val POWER : Float
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val FREQUENCY : Float
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    fun RESERVED(j: Int) : UByte {
        val o = __offset(34)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val RESERVEDLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    val RESERVEDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun RESERVEDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsSNR(_bb: ByteBuffer): SNR = getRootAsSNR(_bb, SNR())
        fun getRootAsSNR(_bb: ByteBuffer, obj: SNR): SNR {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun SNRBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$SNR")
        fun createSNR(builder: FlatBufferBuilder, TYPE: UByte, MODE: UByte, RESERVED1: UShort, MAX_RANGE: Double, MIN_RANGE: Double, FOV_AZIMUTH: Float, FOV_ELEVATION: Float, ANGULAR_RESOLUTION: Float, RANGE_RESOLUTION: Float, UPDATE_RATE: Float, DETECTION_THRESHOLD: Float, AZIMUTH_SCAN_RATE: Float, ELEVATION_SCAN_RATE: Float, POWER: Float, FREQUENCY: Float, RESERVEDOffset: Int) : Int {
            builder.startTable(16)
            addMIN_RANGE(builder, MIN_RANGE)
            addMAX_RANGE(builder, MAX_RANGE)
            addRESERVED(builder, RESERVEDOffset)
            addFREQUENCY(builder, FREQUENCY)
            addPOWER(builder, POWER)
            addELEVATION_SCAN_RATE(builder, ELEVATION_SCAN_RATE)
            addAZIMUTH_SCAN_RATE(builder, AZIMUTH_SCAN_RATE)
            addDETECTION_THRESHOLD(builder, DETECTION_THRESHOLD)
            addUPDATE_RATE(builder, UPDATE_RATE)
            addRANGE_RESOLUTION(builder, RANGE_RESOLUTION)
            addANGULAR_RESOLUTION(builder, ANGULAR_RESOLUTION)
            addFOV_ELEVATION(builder, FOV_ELEVATION)
            addFOV_AZIMUTH(builder, FOV_AZIMUTH)
            addRESERVED1(builder, RESERVED1)
            addMODE(builder, MODE)
            addTYPE(builder, TYPE)
            return endSNR(builder)
        }
        fun startSNR(builder: FlatBufferBuilder) = builder.startTable(16)
        fun addTYPE(builder: FlatBufferBuilder, TYPE: UByte) = builder.addByte(0, TYPE.toByte(), 0)
        fun addMODE(builder: FlatBufferBuilder, MODE: UByte) = builder.addByte(1, MODE.toByte(), 0)
        fun addRESERVED1(builder: FlatBufferBuilder, RESERVED1: UShort) = builder.addShort(2, RESERVED1.toShort(), 0)
        fun addMAX_RANGE(builder: FlatBufferBuilder, MAX_RANGE: Double) = builder.addDouble(3, MAX_RANGE, 0.0)
        fun addMIN_RANGE(builder: FlatBufferBuilder, MIN_RANGE: Double) = builder.addDouble(4, MIN_RANGE, 0.0)
        fun addFOV_AZIMUTH(builder: FlatBufferBuilder, FOV_AZIMUTH: Float) = builder.addFloat(5, FOV_AZIMUTH, 0.0)
        fun addFOV_ELEVATION(builder: FlatBufferBuilder, FOV_ELEVATION: Float) = builder.addFloat(6, FOV_ELEVATION, 0.0)
        fun addANGULAR_RESOLUTION(builder: FlatBufferBuilder, ANGULAR_RESOLUTION: Float) = builder.addFloat(7, ANGULAR_RESOLUTION, 0.0)
        fun addRANGE_RESOLUTION(builder: FlatBufferBuilder, RANGE_RESOLUTION: Float) = builder.addFloat(8, RANGE_RESOLUTION, 0.0)
        fun addUPDATE_RATE(builder: FlatBufferBuilder, UPDATE_RATE: Float) = builder.addFloat(9, UPDATE_RATE, 0.0)
        fun addDETECTION_THRESHOLD(builder: FlatBufferBuilder, DETECTION_THRESHOLD: Float) = builder.addFloat(10, DETECTION_THRESHOLD, 0.0)
        fun addAZIMUTH_SCAN_RATE(builder: FlatBufferBuilder, AZIMUTH_SCAN_RATE: Float) = builder.addFloat(11, AZIMUTH_SCAN_RATE, 0.0)
        fun addELEVATION_SCAN_RATE(builder: FlatBufferBuilder, ELEVATION_SCAN_RATE: Float) = builder.addFloat(12, ELEVATION_SCAN_RATE, 0.0)
        fun addPOWER(builder: FlatBufferBuilder, POWER: Float) = builder.addFloat(13, POWER, 0.0)
        fun addFREQUENCY(builder: FlatBufferBuilder, FREQUENCY: Float) = builder.addFloat(14, FREQUENCY, 0.0)
        fun addRESERVED(builder: FlatBufferBuilder, RESERVED: Int) = builder.addOffset(15, RESERVED, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createReservedVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startReservedVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endSNR(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishSNRBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$SNR")
        fun finishSizePrefixedSNRBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$SNR")
    }
}
