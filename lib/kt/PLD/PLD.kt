// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Payload Information
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class PLD : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PLD {
        __init(_i, _bb)
        return this
    }
    val PAYLOAD_DURATION : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYLOAD_DURATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun PAYLOAD_DURATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val MASS_AT_LAUNCH : Float
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val DIMENSIONS : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DIMENSIONSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun DIMENSIONSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    val SOLAR_ARRAY_AREA : Float
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val SOLAR_ARRAY_DIMENSIONS : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOLAR_ARRAY_DIMENSIONSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun SOLAR_ARRAY_DIMENSIONSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    val NOMINAL_OPERATIONAL_LIFETIME : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NOMINAL_OPERATIONAL_LIFETIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun NOMINAL_OPERATIONAL_LIFETIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    fun INSTRUMENTS(j: Int) : IDM? = INSTRUMENTS(IDM(), j)
    fun INSTRUMENTS(obj: IDM, j: Int) : IDM? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val INSTRUMENTSLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsPLD(_bb: ByteBuffer): PLD = getRootAsPLD(_bb, PLD())
        fun getRootAsPLD(_bb: ByteBuffer, obj: PLD): PLD {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createPLD(builder: FlatBufferBuilder, PAYLOAD_DURATIONOffset: Int, MASS_AT_LAUNCH: Float, DIMENSIONSOffset: Int, SOLAR_ARRAY_AREA: Float, SOLAR_ARRAY_DIMENSIONSOffset: Int, NOMINAL_OPERATIONAL_LIFETIMEOffset: Int, INSTRUMENTSOffset: Int) : Int {
            builder.startTable(7)
            addINSTRUMENTS(builder, INSTRUMENTSOffset)
            addNOMINAL_OPERATIONAL_LIFETIME(builder, NOMINAL_OPERATIONAL_LIFETIMEOffset)
            addSOLAR_ARRAY_DIMENSIONS(builder, SOLAR_ARRAY_DIMENSIONSOffset)
            addSOLAR_ARRAY_AREA(builder, SOLAR_ARRAY_AREA)
            addDIMENSIONS(builder, DIMENSIONSOffset)
            addMASS_AT_LAUNCH(builder, MASS_AT_LAUNCH)
            addPAYLOAD_DURATION(builder, PAYLOAD_DURATIONOffset)
            return endPLD(builder)
        }
        fun startPLD(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addPAYLOAD_DURATION(builder: FlatBufferBuilder, PAYLOAD_DURATION: Int) = builder.addOffset(0, PAYLOAD_DURATION, 0)
        fun addMASS_AT_LAUNCH(builder: FlatBufferBuilder, MASS_AT_LAUNCH: Float) = builder.addFloat(1, MASS_AT_LAUNCH, 0.0)
        fun addDIMENSIONS(builder: FlatBufferBuilder, DIMENSIONS: Int) = builder.addOffset(2, DIMENSIONS, 0)
        fun addSOLAR_ARRAY_AREA(builder: FlatBufferBuilder, SOLAR_ARRAY_AREA: Float) = builder.addFloat(3, SOLAR_ARRAY_AREA, 0.0)
        fun addSOLAR_ARRAY_DIMENSIONS(builder: FlatBufferBuilder, SOLAR_ARRAY_DIMENSIONS: Int) = builder.addOffset(4, SOLAR_ARRAY_DIMENSIONS, 0)
        fun addNOMINAL_OPERATIONAL_LIFETIME(builder: FlatBufferBuilder, NOMINAL_OPERATIONAL_LIFETIME: Int) = builder.addOffset(5, NOMINAL_OPERATIONAL_LIFETIME, 0)
        fun addINSTRUMENTS(builder: FlatBufferBuilder, INSTRUMENTS: Int) = builder.addOffset(6, INSTRUMENTS, 0)
        fun createInstrumentsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startInstrumentsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endPLD(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
