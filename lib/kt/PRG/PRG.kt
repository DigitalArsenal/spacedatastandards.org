// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Program Description Message
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class PRG : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PRG {
        __init(_i, _bb)
        return this
    }
    /**
     * The name of the program
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Hierarchical Deterministic (HD) derivation path for the program's key, used in cryptocurrency wallets
     */
    val HD_KEY_PATH : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val HD_KEY_PATHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun HD_KEY_PATHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Vector of standard message types used by the program
     */
    fun MESSAGE_TYPES(j: Int) : String? {
        val o = __offset(8)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MESSAGE_TYPESLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Vector of users associated with the program, each user can have assigned message types
     */
    fun USERS(j: Int) : USR? = USERS(USR(), j)
    fun USERS(obj: USR, j: Int) : USR? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val USERSLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsPRG(_bb: ByteBuffer): PRG = getRootAsPRG(_bb, PRG())
        fun getRootAsPRG(_bb: ByteBuffer, obj: PRG): PRG {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PRGBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PRG")
        fun createPRG(builder: FlatBufferBuilder, NAMEOffset: Int, HD_KEY_PATHOffset: Int, MESSAGE_TYPESOffset: Int, USERSOffset: Int) : Int {
            builder.startTable(4)
            addUSERS(builder, USERSOffset)
            addMESSAGE_TYPES(builder, MESSAGE_TYPESOffset)
            addHD_KEY_PATH(builder, HD_KEY_PATHOffset)
            addNAME(builder, NAMEOffset)
            return endPRG(builder)
        }
        fun startPRG(builder: FlatBufferBuilder) = builder.startTable(4)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addHD_KEY_PATH(builder: FlatBufferBuilder, HD_KEY_PATH: Int) = builder.addOffset(1, HD_KEY_PATH, 0)
        fun addMESSAGE_TYPES(builder: FlatBufferBuilder, MESSAGE_TYPES: Int) = builder.addOffset(2, MESSAGE_TYPES, 0)
        fun createMessageTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMessageTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addUSERS(builder: FlatBufferBuilder, USERS: Int) = builder.addOffset(3, USERS, 0)
        fun createUsersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startUsersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endPRG(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishPRGBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PRG")
        fun finishSizePrefixedPRGBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PRG")
    }
}
