// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * MultiGeometry
 */
@Suppress("unused")
class KMLMultiGeometry : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : KMLMultiGeometry {
        __init(_i, _bb)
        return this
    }
    /**
     * Child points
     */
    fun POINTS(j: Int) : KMLPoint? = POINTS(KMLPoint(), j)
    fun POINTS(obj: KMLPoint, j: Int) : KMLPoint? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val POINTSLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child line strings
     */
    fun LINE_STRINGS(j: Int) : KMLLineString? = LINE_STRINGS(KMLLineString(), j)
    fun LINE_STRINGS(obj: KMLLineString, j: Int) : KMLLineString? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val LINE_STRINGSLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child polygons
     */
    fun POLYGONS(j: Int) : KMLPolygon? = POLYGONS(KMLPolygon(), j)
    fun POLYGONS(obj: KMLPolygon, j: Int) : KMLPolygon? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val POLYGONSLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Nested multi-geometries
     */
    fun MULTI_GEOMETRIES(j: Int) : KMLMultiGeometry? = MULTI_GEOMETRIES(KMLMultiGeometry(), j)
    fun MULTI_GEOMETRIES(obj: KMLMultiGeometry, j: Int) : KMLMultiGeometry? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val MULTI_GEOMETRIESLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsKMLMultiGeometry(_bb: ByteBuffer): KMLMultiGeometry = getRootAsKMLMultiGeometry(_bb, KMLMultiGeometry())
        fun getRootAsKMLMultiGeometry(_bb: ByteBuffer, obj: KMLMultiGeometry): KMLMultiGeometry {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createKMLMultiGeometry(builder: FlatBufferBuilder, POINTSOffset: Int, LINE_STRINGSOffset: Int, POLYGONSOffset: Int, MULTI_GEOMETRIESOffset: Int) : Int {
            builder.startTable(4)
            addMULTI_GEOMETRIES(builder, MULTI_GEOMETRIESOffset)
            addPOLYGONS(builder, POLYGONSOffset)
            addLINE_STRINGS(builder, LINE_STRINGSOffset)
            addPOINTS(builder, POINTSOffset)
            return endKMLMultiGeometry(builder)
        }
        fun startKMLMultiGeometry(builder: FlatBufferBuilder) = builder.startTable(4)
        fun addPOINTS(builder: FlatBufferBuilder, POINTS: Int) = builder.addOffset(0, POINTS, 0)
        fun createPointsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPointsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLINE_STRINGS(builder: FlatBufferBuilder, LINE_STRINGS: Int) = builder.addOffset(1, LINE_STRINGS, 0)
        fun createLineStringsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLineStringsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPOLYGONS(builder: FlatBufferBuilder, POLYGONS: Int) = builder.addOffset(2, POLYGONS, 0)
        fun createPolygonsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPolygonsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMULTI_GEOMETRIES(builder: FlatBufferBuilder, MULTI_GEOMETRIES: Int) = builder.addOffset(3, MULTI_GEOMETRIES, 0)
        fun createMultiGeometriesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMultiGeometriesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endKMLMultiGeometry(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
