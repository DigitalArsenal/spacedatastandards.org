// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * 3D Model geometry
 */
@Suppress("unused")
class KMLModel : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : KMLModel {
        __init(_i, _bb)
        return this
    }
    /**
     * Altitude mode
     */
    val ALTITUDE_MODE : Byte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Location longitude
     */
    val LOCATION_LON : Double
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Location latitude
     */
    val LOCATION_LAT : Double
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Location altitude
     */
    val LOCATION_ALT : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Orientation heading
     */
    val ORIENTATION_HEADING : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Orientation tilt
     */
    val ORIENTATION_TILT : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Orientation roll
     */
    val ORIENTATION_ROLL : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Scale X
     */
    val SCALE_X : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Scale Y
     */
    val SCALE_Y : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Scale Z
     */
    val SCALE_Z : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Link to 3D model file
     */
    val LINK_HREF : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LINK_HREFAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun LINK_HREFInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Resource map aliases
     */
    fun RESOURCE_MAP(j: Int) : KMLResourceMapAlias? = RESOURCE_MAP(KMLResourceMapAlias(), j)
    fun RESOURCE_MAP(obj: KMLResourceMapAlias, j: Int) : KMLResourceMapAlias? {
        val o = __offset(26)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val RESOURCE_MAPLength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsKMLModel(_bb: ByteBuffer): KMLModel = getRootAsKMLModel(_bb, KMLModel())
        fun getRootAsKMLModel(_bb: ByteBuffer, obj: KMLModel): KMLModel {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createKMLModel(builder: FlatBufferBuilder, ALTITUDE_MODE: Byte, LOCATION_LON: Double, LOCATION_LAT: Double, LOCATION_ALT: Double, ORIENTATION_HEADING: Double, ORIENTATION_TILT: Double, ORIENTATION_ROLL: Double, SCALE_X: Double, SCALE_Y: Double, SCALE_Z: Double, LINK_HREFOffset: Int, RESOURCE_MAPOffset: Int) : Int {
            builder.startTable(12)
            addSCALE_Z(builder, SCALE_Z)
            addSCALE_Y(builder, SCALE_Y)
            addSCALE_X(builder, SCALE_X)
            addORIENTATION_ROLL(builder, ORIENTATION_ROLL)
            addORIENTATION_TILT(builder, ORIENTATION_TILT)
            addORIENTATION_HEADING(builder, ORIENTATION_HEADING)
            addLOCATION_ALT(builder, LOCATION_ALT)
            addLOCATION_LAT(builder, LOCATION_LAT)
            addLOCATION_LON(builder, LOCATION_LON)
            addRESOURCE_MAP(builder, RESOURCE_MAPOffset)
            addLINK_HREF(builder, LINK_HREFOffset)
            addALTITUDE_MODE(builder, ALTITUDE_MODE)
            return endKMLModel(builder)
        }
        fun startKMLModel(builder: FlatBufferBuilder) = builder.startTable(12)
        fun addALTITUDE_MODE(builder: FlatBufferBuilder, ALTITUDE_MODE: Byte) = builder.addByte(0, ALTITUDE_MODE, 0)
        fun addLOCATION_LON(builder: FlatBufferBuilder, LOCATION_LON: Double) = builder.addDouble(1, LOCATION_LON, 0.0)
        fun addLOCATION_LAT(builder: FlatBufferBuilder, LOCATION_LAT: Double) = builder.addDouble(2, LOCATION_LAT, 0.0)
        fun addLOCATION_ALT(builder: FlatBufferBuilder, LOCATION_ALT: Double) = builder.addDouble(3, LOCATION_ALT, 0.0)
        fun addORIENTATION_HEADING(builder: FlatBufferBuilder, ORIENTATION_HEADING: Double) = builder.addDouble(4, ORIENTATION_HEADING, 0.0)
        fun addORIENTATION_TILT(builder: FlatBufferBuilder, ORIENTATION_TILT: Double) = builder.addDouble(5, ORIENTATION_TILT, 0.0)
        fun addORIENTATION_ROLL(builder: FlatBufferBuilder, ORIENTATION_ROLL: Double) = builder.addDouble(6, ORIENTATION_ROLL, 0.0)
        fun addSCALE_X(builder: FlatBufferBuilder, SCALE_X: Double) = builder.addDouble(7, SCALE_X, 0.0)
        fun addSCALE_Y(builder: FlatBufferBuilder, SCALE_Y: Double) = builder.addDouble(8, SCALE_Y, 0.0)
        fun addSCALE_Z(builder: FlatBufferBuilder, SCALE_Z: Double) = builder.addDouble(9, SCALE_Z, 0.0)
        fun addLINK_HREF(builder: FlatBufferBuilder, LINK_HREF: Int) = builder.addOffset(10, LINK_HREF, 0)
        fun addRESOURCE_MAP(builder: FlatBufferBuilder, RESOURCE_MAP: Int) = builder.addOffset(11, RESOURCE_MAP, 0)
        fun createResourceMapVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startResourceMapVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endKMLModel(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
