// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Plugin dependency on another plugin
 */
@Suppress("unused")
class PluginDependency : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PluginDependency {
        __init(_i, _bb)
        return this
    }
    /**
     * Plugin ID of the dependency
     */
    val PLUGIN_ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PLUGIN_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun PLUGIN_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Minimum version required (semver)
     */
    val MIN_VERSION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MIN_VERSIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun MIN_VERSIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Maximum version allowed (optional)
     */
    val MAX_VERSION : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MAX_VERSIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun MAX_VERSIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsPluginDependency(_bb: ByteBuffer): PluginDependency = getRootAsPluginDependency(_bb, PluginDependency())
        fun getRootAsPluginDependency(_bb: ByteBuffer, obj: PluginDependency): PluginDependency {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createPluginDependency(builder: FlatBufferBuilder, PLUGIN_IDOffset: Int, MIN_VERSIONOffset: Int, MAX_VERSIONOffset: Int) : Int {
            builder.startTable(3)
            addMAX_VERSION(builder, MAX_VERSIONOffset)
            addMIN_VERSION(builder, MIN_VERSIONOffset)
            addPLUGIN_ID(builder, PLUGIN_IDOffset)
            return endPluginDependency(builder)
        }
        fun startPluginDependency(builder: FlatBufferBuilder) = builder.startTable(3)
        fun addPLUGIN_ID(builder: FlatBufferBuilder, PLUGIN_ID: Int) = builder.addOffset(0, PLUGIN_ID, 0)
        fun addMIN_VERSION(builder: FlatBufferBuilder, MIN_VERSION: Int) = builder.addOffset(1, MIN_VERSION, 0)
        fun addMAX_VERSION(builder: FlatBufferBuilder, MAX_VERSION: Int) = builder.addOffset(2, MAX_VERSION, 0)
        fun endPluginDependency(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
