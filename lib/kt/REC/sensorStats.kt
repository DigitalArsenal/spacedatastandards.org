// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Sensor Operational Statistics
 */
@Suppress("unused")
class sensorStats : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : sensorStats {
        __init(_i, _bb)
        return this
    }
    /**
     * Statistics period start (ISO 8601)
     */
    val PERIOD_START : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PERIOD_STARTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun PERIOD_STARTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Statistics period end (ISO 8601)
     */
    val PERIOD_END : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PERIOD_ENDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun PERIOD_ENDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Total observation attempts
     */
    val OBS_ATTEMPTED : UInt
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Successful observations
     */
    val OBS_SUCCESSFUL : UInt
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Failed observations
     */
    val OBS_FAILED : UInt
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Uptime fraction (0.0-1.0)
     */
    val UPTIME : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Average tracking accuracy in arcseconds
     */
    val AVG_ACCURACY : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Detected objects count
     */
    val DETECTIONS : UInt
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Uncorrelated tracks count
     */
    val UCT_COUNT : UInt
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAssensorStats(_bb: ByteBuffer): sensorStats = getRootAssensorStats(_bb, sensorStats())
        fun getRootAssensorStats(_bb: ByteBuffer, obj: sensorStats): sensorStats {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createsensorStats(builder: FlatBufferBuilder, PERIOD_STARTOffset: Int, PERIOD_ENDOffset: Int, OBS_ATTEMPTED: UInt, OBS_SUCCESSFUL: UInt, OBS_FAILED: UInt, UPTIME: Double, AVG_ACCURACY: Double, DETECTIONS: UInt, UCT_COUNT: UInt) : Int {
            builder.startTable(9)
            addAVG_ACCURACY(builder, AVG_ACCURACY)
            addUPTIME(builder, UPTIME)
            addUCT_COUNT(builder, UCT_COUNT)
            addDETECTIONS(builder, DETECTIONS)
            addOBS_FAILED(builder, OBS_FAILED)
            addOBS_SUCCESSFUL(builder, OBS_SUCCESSFUL)
            addOBS_ATTEMPTED(builder, OBS_ATTEMPTED)
            addPERIOD_END(builder, PERIOD_ENDOffset)
            addPERIOD_START(builder, PERIOD_STARTOffset)
            return endsensorStats(builder)
        }
        fun startsensorStats(builder: FlatBufferBuilder) = builder.startTable(9)
        fun addPERIOD_START(builder: FlatBufferBuilder, PERIOD_START: Int) = builder.addOffset(0, PERIOD_START, 0)
        fun addPERIOD_END(builder: FlatBufferBuilder, PERIOD_END: Int) = builder.addOffset(1, PERIOD_END, 0)
        fun addOBS_ATTEMPTED(builder: FlatBufferBuilder, OBS_ATTEMPTED: UInt) = builder.addInt(2, OBS_ATTEMPTED.toInt(), 0)
        fun addOBS_SUCCESSFUL(builder: FlatBufferBuilder, OBS_SUCCESSFUL: UInt) = builder.addInt(3, OBS_SUCCESSFUL.toInt(), 0)
        fun addOBS_FAILED(builder: FlatBufferBuilder, OBS_FAILED: UInt) = builder.addInt(4, OBS_FAILED.toInt(), 0)
        fun addUPTIME(builder: FlatBufferBuilder, UPTIME: Double) = builder.addDouble(5, UPTIME, 0.0)
        fun addAVG_ACCURACY(builder: FlatBufferBuilder, AVG_ACCURACY: Double) = builder.addDouble(6, AVG_ACCURACY, 0.0)
        fun addDETECTIONS(builder: FlatBufferBuilder, DETECTIONS: UInt) = builder.addInt(7, DETECTIONS.toInt(), 0)
        fun addUCT_COUNT(builder: FlatBufferBuilder, UCT_COUNT: UInt) = builder.addInt(8, UCT_COUNT.toInt(), 0)
        fun endsensorStats(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
