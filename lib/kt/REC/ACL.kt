// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Access Control Grant - Permission to access purchased data
 */
@Suppress("unused")
class ACL : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ACL {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier for this grant
     */
    val GRANT_ID : String
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field GRANT_ID")
            }
        }
    val GRANT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun GRANT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * ID of the listing this grant applies to
     */
    val LISTING_ID : String
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field LISTING_ID")
            }
        }
    val LISTING_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun LISTING_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Peer ID of the buyer/grantee
     */
    val BUYER_PEER_ID : String
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field BUYER_PEER_ID")
            }
        }
    val BUYER_PEER_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun BUYER_PEER_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Buyer's encryption public key for encrypted delivery
     */
    fun BUYER_ENCRYPTION_PUBKEY(j: Int) : UByte {
        val o = __offset(10)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val BUYER_ENCRYPTION_PUBKEYLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    val BUYER_ENCRYPTION_PUBKEYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun BUYER_ENCRYPTION_PUBKEYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Type of access granted
     */
    val ACCESS_TYPE : Byte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Name of the pricing tier purchased
     */
    val TIER_NAME : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TIER_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun TIER_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Unix timestamp when access was granted
     */
    val GRANTED_AT : ULong
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Unix timestamp when access expires (0 = never expires)
     */
    val EXPIRES_AT : ULong
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Transaction hash or reference proving payment
     */
    val PAYMENT_TX_HASH : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYMENT_TX_HASHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun PAYMENT_TX_HASHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Payment method used
     */
    val PAYMENT_METHOD : Byte
        get() {
            val o = __offset(22)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Ed25519 signature from provider
     */
    fun PROVIDER_SIGNATURE(j: Int) : UByte {
        val o = __offset(24)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val PROVIDER_SIGNATURELength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    val PROVIDER_SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun PROVIDER_SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsACL(_bb: ByteBuffer): ACL = getRootAsACL(_bb, ACL())
        fun getRootAsACL(_bb: ByteBuffer, obj: ACL): ACL {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun ACLBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$ACL")
        fun createACL(builder: FlatBufferBuilder, GRANT_IDOffset: Int, LISTING_IDOffset: Int, BUYER_PEER_IDOffset: Int, BUYER_ENCRYPTION_PUBKEYOffset: Int, ACCESS_TYPE: Byte, TIER_NAMEOffset: Int, GRANTED_AT: ULong, EXPIRES_AT: ULong, PAYMENT_TX_HASHOffset: Int, PAYMENT_METHOD: Byte, PROVIDER_SIGNATUREOffset: Int) : Int {
            builder.startTable(11)
            addEXPIRES_AT(builder, EXPIRES_AT)
            addGRANTED_AT(builder, GRANTED_AT)
            addPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATUREOffset)
            addPAYMENT_TX_HASH(builder, PAYMENT_TX_HASHOffset)
            addTIER_NAME(builder, TIER_NAMEOffset)
            addBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEYOffset)
            addBUYER_PEER_ID(builder, BUYER_PEER_IDOffset)
            addLISTING_ID(builder, LISTING_IDOffset)
            addGRANT_ID(builder, GRANT_IDOffset)
            addPAYMENT_METHOD(builder, PAYMENT_METHOD)
            addACCESS_TYPE(builder, ACCESS_TYPE)
            return endACL(builder)
        }
        fun startACL(builder: FlatBufferBuilder) = builder.startTable(11)
        fun addGRANT_ID(builder: FlatBufferBuilder, GRANT_ID: Int) = builder.addOffset(0, GRANT_ID, 0)
        fun addLISTING_ID(builder: FlatBufferBuilder, LISTING_ID: Int) = builder.addOffset(1, LISTING_ID, 0)
        fun addBUYER_PEER_ID(builder: FlatBufferBuilder, BUYER_PEER_ID: Int) = builder.addOffset(2, BUYER_PEER_ID, 0)
        fun addBUYER_ENCRYPTION_PUBKEY(builder: FlatBufferBuilder, BUYER_ENCRYPTION_PUBKEY: Int) = builder.addOffset(3, BUYER_ENCRYPTION_PUBKEY, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createBuyerEncryptionPubkeyVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startBuyerEncryptionPubkeyVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addACCESS_TYPE(builder: FlatBufferBuilder, ACCESS_TYPE: Byte) = builder.addByte(4, ACCESS_TYPE, 0)
        fun addTIER_NAME(builder: FlatBufferBuilder, TIER_NAME: Int) = builder.addOffset(5, TIER_NAME, 0)
        fun addGRANTED_AT(builder: FlatBufferBuilder, GRANTED_AT: ULong) = builder.addLong(6, GRANTED_AT.toLong(), 0)
        fun addEXPIRES_AT(builder: FlatBufferBuilder, EXPIRES_AT: ULong) = builder.addLong(7, EXPIRES_AT.toLong(), 0)
        fun addPAYMENT_TX_HASH(builder: FlatBufferBuilder, PAYMENT_TX_HASH: Int) = builder.addOffset(8, PAYMENT_TX_HASH, 0)
        fun addPAYMENT_METHOD(builder: FlatBufferBuilder, PAYMENT_METHOD: Byte) = builder.addByte(9, PAYMENT_METHOD, 0)
        fun addPROVIDER_SIGNATURE(builder: FlatBufferBuilder, PROVIDER_SIGNATURE: Int) = builder.addOffset(10, PROVIDER_SIGNATURE, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createProviderSignatureVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startProviderSignatureVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endACL(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 4)
                builder.required(o, 6)
                builder.required(o, 8)
            return o
        }
        fun finishACLBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$ACL")
        fun finishSizePrefixedACLBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$ACL")
    }
}
