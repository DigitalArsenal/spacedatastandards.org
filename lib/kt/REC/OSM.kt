// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Observation Stability Message
 */
@Suppress("unused")
class OSM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : OSM {
        __init(_i, _bb)
        return this
    }
    /**
     * Indicates whether the observation is stable or not
     */
    val IS_STABLE : Boolean
        get() {
            val o = __offset(4)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The number of observations
     */
    val NUM_OBS : Int
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Unique identifier for the object being observed
     */
    val OBJECT_ID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Identifier of the sensor
     */
    val ID_SENSOR : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_SENSORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun ID_SENSORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Timestamp of data creation
     */
    val PASS_START : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PASS_STARTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun PASS_STARTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Duration of the observation pass in seconds
     */
    val PASS_DURATION : Int
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsOSM(_bb: ByteBuffer): OSM = getRootAsOSM(_bb, OSM())
        fun getRootAsOSM(_bb: ByteBuffer, obj: OSM): OSM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun OSMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$OSM")
        fun createOSM(builder: FlatBufferBuilder, IS_STABLE: Boolean, NUM_OBS: Int, OBJECT_IDOffset: Int, ID_SENSOROffset: Int, PASS_STARTOffset: Int, PASS_DURATION: Int) : Int {
            builder.startTable(6)
            addPASS_DURATION(builder, PASS_DURATION)
            addPASS_START(builder, PASS_STARTOffset)
            addID_SENSOR(builder, ID_SENSOROffset)
            addOBJECT_ID(builder, OBJECT_IDOffset)
            addNUM_OBS(builder, NUM_OBS)
            addIS_STABLE(builder, IS_STABLE)
            return endOSM(builder)
        }
        fun startOSM(builder: FlatBufferBuilder) = builder.startTable(6)
        fun addIS_STABLE(builder: FlatBufferBuilder, IS_STABLE: Boolean) = builder.addBoolean(0, IS_STABLE, false)
        fun addNUM_OBS(builder: FlatBufferBuilder, NUM_OBS: Int) = builder.addInt(1, NUM_OBS, 0)
        fun addOBJECT_ID(builder: FlatBufferBuilder, OBJECT_ID: Int) = builder.addOffset(2, OBJECT_ID, 0)
        fun addID_SENSOR(builder: FlatBufferBuilder, ID_SENSOR: Int) = builder.addOffset(3, ID_SENSOR, 0)
        fun addPASS_START(builder: FlatBufferBuilder, PASS_START: Int) = builder.addOffset(4, PASS_START, 0)
        fun addPASS_DURATION(builder: FlatBufferBuilder, PASS_DURATION: Int) = builder.addInt(5, PASS_DURATION, 0)
        fun endOSM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishOSMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$OSM")
        fun finishSizePrefixedOSMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$OSM")
    }
}
