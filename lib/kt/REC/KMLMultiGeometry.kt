// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * MultiGeometry
 */
@Suppress("unused")
class KMLMultiGeometry : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : KMLMultiGeometry {
        __init(_i, _bb)
        return this
    }
    /**
     * Child points
     */
    fun POINTS(j: Int) : KMLPoint? = POINTS(KMLPoint(), j)
    fun POINTS(obj: KMLPoint, j: Int) : KMLPoint? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val POINTSLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child line strings
     */
    fun LINE_STRINGS(j: Int) : KMLLineString? = LINE_STRINGS(KMLLineString(), j)
    fun LINE_STRINGS(obj: KMLLineString, j: Int) : KMLLineString? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val LINE_STRINGSLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child polygons
     */
    fun POLYGONS(j: Int) : KMLPolygon? = POLYGONS(KMLPolygon(), j)
    fun POLYGONS(obj: KMLPolygon, j: Int) : KMLPolygon? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val POLYGONSLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Nested multi-geometries
     */
    fun MULTI_GEOMETRIES(j: Int) : KMLMultiGeometry? = MULTI_GEOMETRIES(KMLMultiGeometry(), j)
    fun MULTI_GEOMETRIES(obj: KMLMultiGeometry, j: Int) : KMLMultiGeometry? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val MULTI_GEOMETRIESLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child linear rings (standalone)
     */
    fun LINEAR_RINGS(j: Int) : KMLLinearRing? = LINEAR_RINGS(KMLLinearRing(), j)
    fun LINEAR_RINGS(obj: KMLLinearRing, j: Int) : KMLLinearRing? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val LINEAR_RINGSLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child 3D models
     */
    fun MODELS(j: Int) : KMLModel? = MODELS(KMLModel(), j)
    fun MODELS(obj: KMLModel, j: Int) : KMLModel? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val MODELSLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child tracks
     */
    fun TRACKS(j: Int) : KMLTrack? = TRACKS(KMLTrack(), j)
    fun TRACKS(obj: KMLTrack, j: Int) : KMLTrack? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val TRACKSLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Child multi-tracks
     */
    fun MULTI_TRACKS(j: Int) : KMLMultiTrack? = MULTI_TRACKS(KMLMultiTrack(), j)
    fun MULTI_TRACKS(obj: KMLMultiTrack, j: Int) : KMLMultiTrack? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val MULTI_TRACKSLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsKMLMultiGeometry(_bb: ByteBuffer): KMLMultiGeometry = getRootAsKMLMultiGeometry(_bb, KMLMultiGeometry())
        fun getRootAsKMLMultiGeometry(_bb: ByteBuffer, obj: KMLMultiGeometry): KMLMultiGeometry {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createKMLMultiGeometry(builder: FlatBufferBuilder, POINTSOffset: Int, LINE_STRINGSOffset: Int, POLYGONSOffset: Int, MULTI_GEOMETRIESOffset: Int, LINEAR_RINGSOffset: Int, MODELSOffset: Int, TRACKSOffset: Int, MULTI_TRACKSOffset: Int) : Int {
            builder.startTable(8)
            addMULTI_TRACKS(builder, MULTI_TRACKSOffset)
            addTRACKS(builder, TRACKSOffset)
            addMODELS(builder, MODELSOffset)
            addLINEAR_RINGS(builder, LINEAR_RINGSOffset)
            addMULTI_GEOMETRIES(builder, MULTI_GEOMETRIESOffset)
            addPOLYGONS(builder, POLYGONSOffset)
            addLINE_STRINGS(builder, LINE_STRINGSOffset)
            addPOINTS(builder, POINTSOffset)
            return endKMLMultiGeometry(builder)
        }
        fun startKMLMultiGeometry(builder: FlatBufferBuilder) = builder.startTable(8)
        fun addPOINTS(builder: FlatBufferBuilder, POINTS: Int) = builder.addOffset(0, POINTS, 0)
        fun createPointsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPointsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLINE_STRINGS(builder: FlatBufferBuilder, LINE_STRINGS: Int) = builder.addOffset(1, LINE_STRINGS, 0)
        fun createLineStringsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLineStringsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPOLYGONS(builder: FlatBufferBuilder, POLYGONS: Int) = builder.addOffset(2, POLYGONS, 0)
        fun createPolygonsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPolygonsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMULTI_GEOMETRIES(builder: FlatBufferBuilder, MULTI_GEOMETRIES: Int) = builder.addOffset(3, MULTI_GEOMETRIES, 0)
        fun createMultiGeometriesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMultiGeometriesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLINEAR_RINGS(builder: FlatBufferBuilder, LINEAR_RINGS: Int) = builder.addOffset(4, LINEAR_RINGS, 0)
        fun createLinearRingsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLinearRingsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMODELS(builder: FlatBufferBuilder, MODELS: Int) = builder.addOffset(5, MODELS, 0)
        fun createModelsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startModelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTRACKS(builder: FlatBufferBuilder, TRACKS: Int) = builder.addOffset(6, TRACKS, 0)
        fun createTracksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTracksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMULTI_TRACKS(builder: FlatBufferBuilder, MULTI_TRACKS: Int) = builder.addOffset(7, MULTI_TRACKS, 0)
        fun createMultiTracksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMultiTracksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endKMLMultiGeometry(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
