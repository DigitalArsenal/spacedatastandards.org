// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Spacecraft Maneuver
 */
@Suppress("unused")
class MNV : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : MNV {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Satellite catalog number
     */
    val SAT_NO : UInt
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * International designator
     */
    val ORIG_OBJECT_ID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ORIG_OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * On-orbit reference
     */
    val ON_ORBIT : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ON_ORBITAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun ON_ORBITInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Maneuver status
     */
    val STATUS : Byte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Maneuver characterization
     */
    val CHARACTERIZATION : Byte
        get() {
            val o = __offset(14)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Characterization uncertainty (0-1)
     */
    val CHARACTERIZATION_UNC : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Detection report time (ISO 8601)
     */
    val REPORT_TIME : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val REPORT_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun REPORT_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Maneuver start time (ISO 8601)
     */
    val EVENT_START_TIME : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EVENT_START_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun EVENT_START_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Maneuver end time (ISO 8601)
     */
    val EVENT_END_TIME : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EVENT_END_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun EVENT_END_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Total burn time (seconds)
     */
    val TOTAL_BURN_TIME : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * OD fit end time (ISO 8601)
     */
    val OD_FIT_END_TIME : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OD_FIT_END_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun OD_FIT_END_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Detecting sensor identifier
     */
    val ID_SENSOR : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_SENSORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun ID_SENSORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Original sensor identifier
     */
    val ORIG_SENSOR_ID : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_SENSOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun ORIG_SENSOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Maneuver event identifier
     */
    val EVENT_ID : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EVENT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun EVENT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * True if object is uncorrelated
     */
    val UCT : Boolean
        get() {
            val o = __offset(34)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Maneuver detection uncertainty (km)
     */
    val MANEUVER_UNC : Double
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Total delta-V magnitude (km/s)
     */
    val DELTA_VEL : Double
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta-V along-track/U component (km/s)
     */
    val DELTA_VEL_U : Double
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta-V cross-track/V component (km/s)
     */
    val DELTA_VEL_V : Double
        get() {
            val o = __offset(42)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta-V radial/W component (km/s)
     */
    val DELTA_VEL_W : Double
        get() {
            val o = __offset(44)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Total delta position (km)
     */
    val DELTA_POS : Double
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta position U component (km)
     */
    val DELTA_POS_U : Double
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta position V component (km)
     */
    val DELTA_POS_V : Double
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Delta position W component (km)
     */
    val DELTA_POS_W : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Propellant mass consumed (kg)
     */
    val DELTA_MASS : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Pre-maneuver orbital state
     */
    val PRE_EVENT : mnvOrbitalState? get() = PRE_EVENT(mnvOrbitalState())
    fun PRE_EVENT(obj: mnvOrbitalState) : mnvOrbitalState? {
        val o = __offset(56)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Post-maneuver orbital state
     */
    val POST_EVENT : mnvOrbitalState? get() = POST_EVENT(mnvOrbitalState())
    fun POST_EVENT(obj: mnvOrbitalState) : mnvOrbitalState? {
        val o = __offset(58)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Post-maneuver mass (kg)
     */
    val POST_MASS : Double
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Post-maneuver cross-sectional area (m^2)
     */
    val POST_AREA : Double
        get() {
            val o = __offset(62)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * 6x6 covariance matrix (upper triangle, row-major)
     */
    fun COV(j: Int) : Double {
        val o = __offset(64)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val COVLength : Int
        get() {
            val o = __offset(64); return if (o != 0) __vector_len(o) else 0
        }
    val COVAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(64, 8)
    fun COVInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 64, 8)
    /**
     * Number of observations used
     */
    val NUM_OBS : UInt
        get() {
            val o = __offset(66)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * State model used
     */
    val STATE_MODEL : String?
        get() {
            val o = __offset(68)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val STATE_MODELAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(68, 1)
    fun STATE_MODELInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 68, 1)
    /**
     * State model version
     */
    val STATE_MODEL_VERSION : Double
        get() {
            val o = __offset(70)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of acceleration profile points
     */
    val NUM_ACCEL_POINTS : UShort
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    /**
     * Acceleration profile times (ISO 8601)
     */
    fun MNVR_ACCEL_TIMES(j: Int) : String? {
        val o = __offset(74)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MNVR_ACCEL_TIMESLength : Int
        get() {
            val o = __offset(74); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Acceleration values (km/s^2, 3 components per point)
     */
    fun MNVR_ACCELS(j: Int) : Double {
        val o = __offset(76)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val MNVR_ACCELSLength : Int
        get() {
            val o = __offset(76); return if (o != 0) __vector_len(o) else 0
        }
    val MNVR_ACCELSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(76, 8)
    fun MNVR_ACCELSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 76, 8)
    /**
     * Acceleration uncertainties (km/s^2)
     */
    fun MNVR_ACCEL_UNCS(j: Int) : Double {
        val o = __offset(78)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val MNVR_ACCEL_UNCSLength : Int
        get() {
            val o = __offset(78); return if (o != 0) __vector_len(o) else 0
        }
    val MNVR_ACCEL_UNCSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(78, 8)
    fun MNVR_ACCEL_UNCSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 78, 8)
    /**
     * Description
     */
    val DESCRIPTION : String?
        get() {
            val o = __offset(80)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(80, 1)
    fun DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 80, 1)
    /**
     * Event descriptor
     */
    val DESCRIPTOR : String?
        get() {
            val o = __offset(82)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(82, 1)
    fun DESCRIPTORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 82, 1)
    /**
     * Algorithm used for detection
     */
    val ALGORITHM : String?
        get() {
            val o = __offset(84)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ALGORITHMAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(84, 1)
    fun ALGORITHMInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 84, 1)
    /**
     * Associated tags
     */
    fun TAGS(j: Int) : String? {
        val o = __offset(86)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val TAGSLength : Int
        get() {
            val o = __offset(86); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Sourced data references
     */
    fun SOURCED_DATA(j: Int) : String? {
        val o = __offset(88)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val SOURCED_DATALength : Int
        get() {
            val o = __offset(88); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Sourced data types
     */
    val SOURCED_DATA_TYPES : String?
        get() {
            val o = __offset(90)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOURCED_DATA_TYPESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(90, 1)
    fun SOURCED_DATA_TYPESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 90, 1)
    /**
     * Transaction identifier
     */
    val TRANSACTION_ID : String?
        get() {
            val o = __offset(92)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRANSACTION_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(92, 1)
    fun TRANSACTION_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 92, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsMNV(_bb: ByteBuffer): MNV = getRootAsMNV(_bb, MNV())
        fun getRootAsMNV(_bb: ByteBuffer, obj: MNV): MNV {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun MNVBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$MNV")
        fun createMNV(builder: FlatBufferBuilder, IDOffset: Int, SAT_NO: UInt, ORIG_OBJECT_IDOffset: Int, ON_ORBITOffset: Int, STATUS: Byte, CHARACTERIZATION: Byte, CHARACTERIZATION_UNC: Double, REPORT_TIMEOffset: Int, EVENT_START_TIMEOffset: Int, EVENT_END_TIMEOffset: Int, TOTAL_BURN_TIME: Double, OD_FIT_END_TIMEOffset: Int, ID_SENSOROffset: Int, ORIG_SENSOR_IDOffset: Int, EVENT_IDOffset: Int, UCT: Boolean, MANEUVER_UNC: Double, DELTA_VEL: Double, DELTA_VEL_U: Double, DELTA_VEL_V: Double, DELTA_VEL_W: Double, DELTA_POS: Double, DELTA_POS_U: Double, DELTA_POS_V: Double, DELTA_POS_W: Double, DELTA_MASS: Double, PRE_EVENTOffset: Int, POST_EVENTOffset: Int, POST_MASS: Double, POST_AREA: Double, COVOffset: Int, NUM_OBS: UInt, STATE_MODELOffset: Int, STATE_MODEL_VERSION: Double, NUM_ACCEL_POINTS: UShort, MNVR_ACCEL_TIMESOffset: Int, MNVR_ACCELSOffset: Int, MNVR_ACCEL_UNCSOffset: Int, DESCRIPTIONOffset: Int, DESCRIPTOROffset: Int, ALGORITHMOffset: Int, TAGSOffset: Int, SOURCED_DATAOffset: Int, SOURCED_DATA_TYPESOffset: Int, TRANSACTION_IDOffset: Int) : Int {
            builder.startTable(45)
            addSTATE_MODEL_VERSION(builder, STATE_MODEL_VERSION)
            addPOST_AREA(builder, POST_AREA)
            addPOST_MASS(builder, POST_MASS)
            addDELTA_MASS(builder, DELTA_MASS)
            addDELTA_POS_W(builder, DELTA_POS_W)
            addDELTA_POS_V(builder, DELTA_POS_V)
            addDELTA_POS_U(builder, DELTA_POS_U)
            addDELTA_POS(builder, DELTA_POS)
            addDELTA_VEL_W(builder, DELTA_VEL_W)
            addDELTA_VEL_V(builder, DELTA_VEL_V)
            addDELTA_VEL_U(builder, DELTA_VEL_U)
            addDELTA_VEL(builder, DELTA_VEL)
            addMANEUVER_UNC(builder, MANEUVER_UNC)
            addTOTAL_BURN_TIME(builder, TOTAL_BURN_TIME)
            addCHARACTERIZATION_UNC(builder, CHARACTERIZATION_UNC)
            addTRANSACTION_ID(builder, TRANSACTION_IDOffset)
            addSOURCED_DATA_TYPES(builder, SOURCED_DATA_TYPESOffset)
            addSOURCED_DATA(builder, SOURCED_DATAOffset)
            addTAGS(builder, TAGSOffset)
            addALGORITHM(builder, ALGORITHMOffset)
            addDESCRIPTOR(builder, DESCRIPTOROffset)
            addDESCRIPTION(builder, DESCRIPTIONOffset)
            addMNVR_ACCEL_UNCS(builder, MNVR_ACCEL_UNCSOffset)
            addMNVR_ACCELS(builder, MNVR_ACCELSOffset)
            addMNVR_ACCEL_TIMES(builder, MNVR_ACCEL_TIMESOffset)
            addSTATE_MODEL(builder, STATE_MODELOffset)
            addNUM_OBS(builder, NUM_OBS)
            addCOV(builder, COVOffset)
            addPOST_EVENT(builder, POST_EVENTOffset)
            addPRE_EVENT(builder, PRE_EVENTOffset)
            addEVENT_ID(builder, EVENT_IDOffset)
            addORIG_SENSOR_ID(builder, ORIG_SENSOR_IDOffset)
            addID_SENSOR(builder, ID_SENSOROffset)
            addOD_FIT_END_TIME(builder, OD_FIT_END_TIMEOffset)
            addEVENT_END_TIME(builder, EVENT_END_TIMEOffset)
            addEVENT_START_TIME(builder, EVENT_START_TIMEOffset)
            addREPORT_TIME(builder, REPORT_TIMEOffset)
            addON_ORBIT(builder, ON_ORBITOffset)
            addORIG_OBJECT_ID(builder, ORIG_OBJECT_IDOffset)
            addSAT_NO(builder, SAT_NO)
            addID(builder, IDOffset)
            addNUM_ACCEL_POINTS(builder, NUM_ACCEL_POINTS)
            addUCT(builder, UCT)
            addCHARACTERIZATION(builder, CHARACTERIZATION)
            addSTATUS(builder, STATUS)
            return endMNV(builder)
        }
        fun startMNV(builder: FlatBufferBuilder) = builder.startTable(45)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addSAT_NO(builder: FlatBufferBuilder, SAT_NO: UInt) = builder.addInt(1, SAT_NO.toInt(), 0)
        fun addORIG_OBJECT_ID(builder: FlatBufferBuilder, ORIG_OBJECT_ID: Int) = builder.addOffset(2, ORIG_OBJECT_ID, 0)
        fun addON_ORBIT(builder: FlatBufferBuilder, ON_ORBIT: Int) = builder.addOffset(3, ON_ORBIT, 0)
        fun addSTATUS(builder: FlatBufferBuilder, STATUS: Byte) = builder.addByte(4, STATUS, 0)
        fun addCHARACTERIZATION(builder: FlatBufferBuilder, CHARACTERIZATION: Byte) = builder.addByte(5, CHARACTERIZATION, 0)
        fun addCHARACTERIZATION_UNC(builder: FlatBufferBuilder, CHARACTERIZATION_UNC: Double) = builder.addDouble(6, CHARACTERIZATION_UNC, 0.0)
        fun addREPORT_TIME(builder: FlatBufferBuilder, REPORT_TIME: Int) = builder.addOffset(7, REPORT_TIME, 0)
        fun addEVENT_START_TIME(builder: FlatBufferBuilder, EVENT_START_TIME: Int) = builder.addOffset(8, EVENT_START_TIME, 0)
        fun addEVENT_END_TIME(builder: FlatBufferBuilder, EVENT_END_TIME: Int) = builder.addOffset(9, EVENT_END_TIME, 0)
        fun addTOTAL_BURN_TIME(builder: FlatBufferBuilder, TOTAL_BURN_TIME: Double) = builder.addDouble(10, TOTAL_BURN_TIME, 0.0)
        fun addOD_FIT_END_TIME(builder: FlatBufferBuilder, OD_FIT_END_TIME: Int) = builder.addOffset(11, OD_FIT_END_TIME, 0)
        fun addID_SENSOR(builder: FlatBufferBuilder, ID_SENSOR: Int) = builder.addOffset(12, ID_SENSOR, 0)
        fun addORIG_SENSOR_ID(builder: FlatBufferBuilder, ORIG_SENSOR_ID: Int) = builder.addOffset(13, ORIG_SENSOR_ID, 0)
        fun addEVENT_ID(builder: FlatBufferBuilder, EVENT_ID: Int) = builder.addOffset(14, EVENT_ID, 0)
        fun addUCT(builder: FlatBufferBuilder, UCT: Boolean) = builder.addBoolean(15, UCT, false)
        fun addMANEUVER_UNC(builder: FlatBufferBuilder, MANEUVER_UNC: Double) = builder.addDouble(16, MANEUVER_UNC, 0.0)
        fun addDELTA_VEL(builder: FlatBufferBuilder, DELTA_VEL: Double) = builder.addDouble(17, DELTA_VEL, 0.0)
        fun addDELTA_VEL_U(builder: FlatBufferBuilder, DELTA_VEL_U: Double) = builder.addDouble(18, DELTA_VEL_U, 0.0)
        fun addDELTA_VEL_V(builder: FlatBufferBuilder, DELTA_VEL_V: Double) = builder.addDouble(19, DELTA_VEL_V, 0.0)
        fun addDELTA_VEL_W(builder: FlatBufferBuilder, DELTA_VEL_W: Double) = builder.addDouble(20, DELTA_VEL_W, 0.0)
        fun addDELTA_POS(builder: FlatBufferBuilder, DELTA_POS: Double) = builder.addDouble(21, DELTA_POS, 0.0)
        fun addDELTA_POS_U(builder: FlatBufferBuilder, DELTA_POS_U: Double) = builder.addDouble(22, DELTA_POS_U, 0.0)
        fun addDELTA_POS_V(builder: FlatBufferBuilder, DELTA_POS_V: Double) = builder.addDouble(23, DELTA_POS_V, 0.0)
        fun addDELTA_POS_W(builder: FlatBufferBuilder, DELTA_POS_W: Double) = builder.addDouble(24, DELTA_POS_W, 0.0)
        fun addDELTA_MASS(builder: FlatBufferBuilder, DELTA_MASS: Double) = builder.addDouble(25, DELTA_MASS, 0.0)
        fun addPRE_EVENT(builder: FlatBufferBuilder, PRE_EVENT: Int) = builder.addOffset(26, PRE_EVENT, 0)
        fun addPOST_EVENT(builder: FlatBufferBuilder, POST_EVENT: Int) = builder.addOffset(27, POST_EVENT, 0)
        fun addPOST_MASS(builder: FlatBufferBuilder, POST_MASS: Double) = builder.addDouble(28, POST_MASS, 0.0)
        fun addPOST_AREA(builder: FlatBufferBuilder, POST_AREA: Double) = builder.addDouble(29, POST_AREA, 0.0)
        fun addCOV(builder: FlatBufferBuilder, COV: Int) = builder.addOffset(30, COV, 0)
        fun createCovVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startCovVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun addNUM_OBS(builder: FlatBufferBuilder, NUM_OBS: UInt) = builder.addInt(31, NUM_OBS.toInt(), 0)
        fun addSTATE_MODEL(builder: FlatBufferBuilder, STATE_MODEL: Int) = builder.addOffset(32, STATE_MODEL, 0)
        fun addSTATE_MODEL_VERSION(builder: FlatBufferBuilder, STATE_MODEL_VERSION: Double) = builder.addDouble(33, STATE_MODEL_VERSION, 0.0)
        fun addNUM_ACCEL_POINTS(builder: FlatBufferBuilder, NUM_ACCEL_POINTS: UShort) = builder.addShort(34, NUM_ACCEL_POINTS.toShort(), 0)
        fun addMNVR_ACCEL_TIMES(builder: FlatBufferBuilder, MNVR_ACCEL_TIMES: Int) = builder.addOffset(35, MNVR_ACCEL_TIMES, 0)
        fun createMnvrAccelTimesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMnvrAccelTimesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMNVR_ACCELS(builder: FlatBufferBuilder, MNVR_ACCELS: Int) = builder.addOffset(36, MNVR_ACCELS, 0)
        fun createMnvrAccelsVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startMnvrAccelsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun addMNVR_ACCEL_UNCS(builder: FlatBufferBuilder, MNVR_ACCEL_UNCS: Int) = builder.addOffset(37, MNVR_ACCEL_UNCS, 0)
        fun createMnvrAccelUncsVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startMnvrAccelUncsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun addDESCRIPTION(builder: FlatBufferBuilder, DESCRIPTION: Int) = builder.addOffset(38, DESCRIPTION, 0)
        fun addDESCRIPTOR(builder: FlatBufferBuilder, DESCRIPTOR: Int) = builder.addOffset(39, DESCRIPTOR, 0)
        fun addALGORITHM(builder: FlatBufferBuilder, ALGORITHM: Int) = builder.addOffset(40, ALGORITHM, 0)
        fun addTAGS(builder: FlatBufferBuilder, TAGS: Int) = builder.addOffset(41, TAGS, 0)
        fun createTagsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTagsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSOURCED_DATA(builder: FlatBufferBuilder, SOURCED_DATA: Int) = builder.addOffset(42, SOURCED_DATA, 0)
        fun createSourcedDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSourcedDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSOURCED_DATA_TYPES(builder: FlatBufferBuilder, SOURCED_DATA_TYPES: Int) = builder.addOffset(43, SOURCED_DATA_TYPES, 0)
        fun addTRANSACTION_ID(builder: FlatBufferBuilder, TRANSACTION_ID: Int) = builder.addOffset(44, TRANSACTION_ID, 0)
        fun endMNV(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishMNVBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$MNV")
        fun finishSizePrefixedMNVBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$MNV")
    }
}
