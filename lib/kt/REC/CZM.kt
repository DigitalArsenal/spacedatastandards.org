// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * CZML Document
 */
@Suppress("unused")
class CZM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CZM {
        __init(_i, _bb)
        return this
    }
    /**
     * Document-level name
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Document-level version
     */
    val VERSION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val VERSIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun VERSIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Clock settings - current time (ISO 8601)
     */
    val CLOCK_CURRENT_TIME : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLOCK_CURRENT_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun CLOCK_CURRENT_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Clock settings - interval (ISO 8601 interval)
     */
    val CLOCK_INTERVAL : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLOCK_INTERVALAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun CLOCK_INTERVALInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Clock settings - multiplier
     */
    val CLOCK_MULTIPLIER : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Clock range
     */
    val CLOCK_RANGE : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLOCK_RANGEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun CLOCK_RANGEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Clock step
     */
    val CLOCK_STEP : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLOCK_STEPAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun CLOCK_STEPInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * All packets in the document
     */
    fun PACKETS(j: Int) : CZMPacket? = PACKETS(CZMPacket(), j)
    fun PACKETS(obj: CZMPacket, j: Int) : CZMPacket? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val PACKETSLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCZM(_bb: ByteBuffer): CZM = getRootAsCZM(_bb, CZM())
        fun getRootAsCZM(_bb: ByteBuffer, obj: CZM): CZM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun CZMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$CZM")
        fun createCZM(builder: FlatBufferBuilder, NAMEOffset: Int, VERSIONOffset: Int, CLOCK_CURRENT_TIMEOffset: Int, CLOCK_INTERVALOffset: Int, CLOCK_MULTIPLIER: Double, CLOCK_RANGEOffset: Int, CLOCK_STEPOffset: Int, PACKETSOffset: Int) : Int {
            builder.startTable(8)
            addCLOCK_MULTIPLIER(builder, CLOCK_MULTIPLIER)
            addPACKETS(builder, PACKETSOffset)
            addCLOCK_STEP(builder, CLOCK_STEPOffset)
            addCLOCK_RANGE(builder, CLOCK_RANGEOffset)
            addCLOCK_INTERVAL(builder, CLOCK_INTERVALOffset)
            addCLOCK_CURRENT_TIME(builder, CLOCK_CURRENT_TIMEOffset)
            addVERSION(builder, VERSIONOffset)
            addNAME(builder, NAMEOffset)
            return endCZM(builder)
        }
        fun startCZM(builder: FlatBufferBuilder) = builder.startTable(8)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: Int) = builder.addOffset(1, VERSION, 0)
        fun addCLOCK_CURRENT_TIME(builder: FlatBufferBuilder, CLOCK_CURRENT_TIME: Int) = builder.addOffset(2, CLOCK_CURRENT_TIME, 0)
        fun addCLOCK_INTERVAL(builder: FlatBufferBuilder, CLOCK_INTERVAL: Int) = builder.addOffset(3, CLOCK_INTERVAL, 0)
        fun addCLOCK_MULTIPLIER(builder: FlatBufferBuilder, CLOCK_MULTIPLIER: Double) = builder.addDouble(4, CLOCK_MULTIPLIER, 0.0)
        fun addCLOCK_RANGE(builder: FlatBufferBuilder, CLOCK_RANGE: Int) = builder.addOffset(5, CLOCK_RANGE, 0)
        fun addCLOCK_STEP(builder: FlatBufferBuilder, CLOCK_STEP: Int) = builder.addOffset(6, CLOCK_STEP, 0)
        fun addPACKETS(builder: FlatBufferBuilder, PACKETS: Int) = builder.addOffset(7, PACKETS, 0)
        fun createPacketsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPacketsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endCZM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishCZMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$CZM")
        fun finishSizePrefixedCZMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$CZM")
    }
}
