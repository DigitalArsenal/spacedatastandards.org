// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Math algorithm (inline calculation)
 */
@Suppress("unused")
class MathAlgorithm : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : MathAlgorithm {
        __init(_i, _bb)
        return this
    }
    /**
     * Algorithm name
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Short description
     */
    val SHORT_DESCRIPTION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SHORT_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun SHORT_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Math operation in RPN
     */
    val MATH_OPERATION : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MATH_OPERATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun MATH_OPERATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Output parameter reference
     */
    val OUTPUT_PARAMETER_REF : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OUTPUT_PARAMETER_REFAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun OUTPUT_PARAMETER_REFInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Trigger conditions
     */
    fun TRIGGERS(j: Int) : AlgorithmTrigger? = TRIGGERS(AlgorithmTrigger(), j)
    fun TRIGGERS(obj: AlgorithmTrigger, j: Int) : AlgorithmTrigger? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val TRIGGERSLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsMathAlgorithm(_bb: ByteBuffer): MathAlgorithm = getRootAsMathAlgorithm(_bb, MathAlgorithm())
        fun getRootAsMathAlgorithm(_bb: ByteBuffer, obj: MathAlgorithm): MathAlgorithm {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createMathAlgorithm(builder: FlatBufferBuilder, NAMEOffset: Int, SHORT_DESCRIPTIONOffset: Int, MATH_OPERATIONOffset: Int, OUTPUT_PARAMETER_REFOffset: Int, TRIGGERSOffset: Int) : Int {
            builder.startTable(5)
            addTRIGGERS(builder, TRIGGERSOffset)
            addOUTPUT_PARAMETER_REF(builder, OUTPUT_PARAMETER_REFOffset)
            addMATH_OPERATION(builder, MATH_OPERATIONOffset)
            addSHORT_DESCRIPTION(builder, SHORT_DESCRIPTIONOffset)
            addNAME(builder, NAMEOffset)
            return endMathAlgorithm(builder)
        }
        fun startMathAlgorithm(builder: FlatBufferBuilder) = builder.startTable(5)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addSHORT_DESCRIPTION(builder: FlatBufferBuilder, SHORT_DESCRIPTION: Int) = builder.addOffset(1, SHORT_DESCRIPTION, 0)
        fun addMATH_OPERATION(builder: FlatBufferBuilder, MATH_OPERATION: Int) = builder.addOffset(2, MATH_OPERATION, 0)
        fun addOUTPUT_PARAMETER_REF(builder: FlatBufferBuilder, OUTPUT_PARAMETER_REF: Int) = builder.addOffset(3, OUTPUT_PARAMETER_REF, 0)
        fun addTRIGGERS(builder: FlatBufferBuilder, TRIGGERS: Int) = builder.addOffset(4, TRIGGERS, 0)
        fun createTriggersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTriggersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endMathAlgorithm(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
