// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Space Packet Protocol (CCSDS 133.0-B-1)
 */
@Suppress("unused")
class SPP : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : SPP {
        __init(_i, _bb)
        return this
    }
    /**
     * Packet version number
     */
    val VERSION : UByte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Packet type (TM or TC)
     */
    val PACKET_TYPE : Byte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Secondary header flag
     */
    val SEC_HDR_FLAG : Boolean
        get() {
            val o = __offset(8)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Application Process Identifier
     */
    val APID : UShort
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    /**
     * Sequence flags (00=continuation, 01=first, 10=last, 11=standalone)
     */
    val SEQUENCE_FLAGS : UByte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Sequence count
     */
    val SEQUENCE_COUNT : UShort
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    /**
     * Data length minus 1
     */
    val DATA_LENGTH : UShort
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    /**
     * Packet data zone
     */
    fun DATA(j: Int) : UByte {
        val o = __offset(18)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val DATALength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    val DATAAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun DATAInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsSPP(_bb: ByteBuffer): SPP = getRootAsSPP(_bb, SPP())
        fun getRootAsSPP(_bb: ByteBuffer, obj: SPP): SPP {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun SPPBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$SPP")
        fun createSPP(builder: FlatBufferBuilder, VERSION: UByte, PACKET_TYPE: Byte, SEC_HDR_FLAG: Boolean, APID: UShort, SEQUENCE_FLAGS: UByte, SEQUENCE_COUNT: UShort, DATA_LENGTH: UShort, DATAOffset: Int) : Int {
            builder.startTable(8)
            addDATA(builder, DATAOffset)
            addDATA_LENGTH(builder, DATA_LENGTH)
            addSEQUENCE_COUNT(builder, SEQUENCE_COUNT)
            addAPID(builder, APID)
            addSEQUENCE_FLAGS(builder, SEQUENCE_FLAGS)
            addSEC_HDR_FLAG(builder, SEC_HDR_FLAG)
            addPACKET_TYPE(builder, PACKET_TYPE)
            addVERSION(builder, VERSION)
            return endSPP(builder)
        }
        fun startSPP(builder: FlatBufferBuilder) = builder.startTable(8)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: UByte) = builder.addByte(0, VERSION.toByte(), 0)
        fun addPACKET_TYPE(builder: FlatBufferBuilder, PACKET_TYPE: Byte) = builder.addByte(1, PACKET_TYPE, 0)
        fun addSEC_HDR_FLAG(builder: FlatBufferBuilder, SEC_HDR_FLAG: Boolean) = builder.addBoolean(2, SEC_HDR_FLAG, false)
        fun addAPID(builder: FlatBufferBuilder, APID: UShort) = builder.addShort(3, APID.toShort(), 0)
        fun addSEQUENCE_FLAGS(builder: FlatBufferBuilder, SEQUENCE_FLAGS: UByte) = builder.addByte(4, SEQUENCE_FLAGS.toByte(), 0)
        fun addSEQUENCE_COUNT(builder: FlatBufferBuilder, SEQUENCE_COUNT: UShort) = builder.addShort(5, SEQUENCE_COUNT.toShort(), 0)
        fun addDATA_LENGTH(builder: FlatBufferBuilder, DATA_LENGTH: UShort) = builder.addShort(6, DATA_LENGTH.toShort(), 0)
        fun addDATA(builder: FlatBufferBuilder, DATA: Int) = builder.addOffset(7, DATA, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createDataVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endSPP(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishSPPBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$SPP")
        fun finishSizePrefixedSPPBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$SPP")
    }
}
