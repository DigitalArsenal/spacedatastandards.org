// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Minimum Propagatable Element Set
 */
@Suppress("unused")
class MPE : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : MPE {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique ID as a String [no units]
     */
    val ENTITY_ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ENTITY_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun ENTITY_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Epoch of Mean Keplerian elements (UNIX timestamp) [numeric seconds since 1970-01-01T00:00:00 UTC]
     */
    val EPOCH : Double
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Mean motion in rev/day [M if chosen to represent orbit size for SGP/SGP4 elements]
     */
    val MEAN_MOTION : Double
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Eccentricity (unitless)
     */
    val ECCENTRICITY : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Inclination in degrees
     */
    val INCLINATION : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Right ascension of ascending node in degrees
     */
    val RA_OF_ASC_NODE : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Argument of pericenter in degrees
     */
    val ARG_OF_PERICENTER : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Mean anomaly in degrees
     */
    val MEAN_ANOMALY : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * SGP/SGP4 drag-like coefficient (BSTAR) in units of 1/[Earth radii]
     */
    val BSTAR : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Description of the Mean Element Theory (SGP4, DSST, USM)
     */
    val MEAN_ELEMENT_THEORY : Byte
        get() {
            val o = __offset(22)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsMPE(_bb: ByteBuffer): MPE = getRootAsMPE(_bb, MPE())
        fun getRootAsMPE(_bb: ByteBuffer, obj: MPE): MPE {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun MPEBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$MPE")
        fun createMPE(builder: FlatBufferBuilder, ENTITY_IDOffset: Int, EPOCH: Double, MEAN_MOTION: Double, ECCENTRICITY: Double, INCLINATION: Double, RA_OF_ASC_NODE: Double, ARG_OF_PERICENTER: Double, MEAN_ANOMALY: Double, BSTAR: Double, MEAN_ELEMENT_THEORY: Byte) : Int {
            builder.startTable(10)
            addBSTAR(builder, BSTAR)
            addMEAN_ANOMALY(builder, MEAN_ANOMALY)
            addARG_OF_PERICENTER(builder, ARG_OF_PERICENTER)
            addRA_OF_ASC_NODE(builder, RA_OF_ASC_NODE)
            addINCLINATION(builder, INCLINATION)
            addECCENTRICITY(builder, ECCENTRICITY)
            addMEAN_MOTION(builder, MEAN_MOTION)
            addEPOCH(builder, EPOCH)
            addENTITY_ID(builder, ENTITY_IDOffset)
            addMEAN_ELEMENT_THEORY(builder, MEAN_ELEMENT_THEORY)
            return endMPE(builder)
        }
        fun startMPE(builder: FlatBufferBuilder) = builder.startTable(10)
        fun addENTITY_ID(builder: FlatBufferBuilder, ENTITY_ID: Int) = builder.addOffset(0, ENTITY_ID, 0)
        fun addEPOCH(builder: FlatBufferBuilder, EPOCH: Double) = builder.addDouble(1, EPOCH, 0.0)
        fun addMEAN_MOTION(builder: FlatBufferBuilder, MEAN_MOTION: Double) = builder.addDouble(2, MEAN_MOTION, 0.0)
        fun addECCENTRICITY(builder: FlatBufferBuilder, ECCENTRICITY: Double) = builder.addDouble(3, ECCENTRICITY, 0.0)
        fun addINCLINATION(builder: FlatBufferBuilder, INCLINATION: Double) = builder.addDouble(4, INCLINATION, 0.0)
        fun addRA_OF_ASC_NODE(builder: FlatBufferBuilder, RA_OF_ASC_NODE: Double) = builder.addDouble(5, RA_OF_ASC_NODE, 0.0)
        fun addARG_OF_PERICENTER(builder: FlatBufferBuilder, ARG_OF_PERICENTER: Double) = builder.addDouble(6, ARG_OF_PERICENTER, 0.0)
        fun addMEAN_ANOMALY(builder: FlatBufferBuilder, MEAN_ANOMALY: Double) = builder.addDouble(7, MEAN_ANOMALY, 0.0)
        fun addBSTAR(builder: FlatBufferBuilder, BSTAR: Double) = builder.addDouble(8, BSTAR, 0.0)
        fun addMEAN_ELEMENT_THEORY(builder: FlatBufferBuilder, MEAN_ELEMENT_THEORY: Byte) = builder.addByte(9, MEAN_ELEMENT_THEORY, 0)
        fun endMPE(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishMPEBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$MPE")
        fun finishSizePrefixedMPEBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$MPE")
    }
}
