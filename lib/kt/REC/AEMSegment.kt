// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class AEMSegment : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AEMSegment {
        __init(_i, _bb)
        return this
    }
    val OBJECT_NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OBJECT_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun OBJECT_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val OBJECT_ID : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    val REF_FRAME_A : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val REF_FRAME_AAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun REF_FRAME_AInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    val REF_FRAME_B : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val REF_FRAME_BAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun REF_FRAME_BInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    val ATTITUDE_DIR : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ATTITUDE_DIRAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun ATTITUDE_DIRInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    val TIME_SYSTEM : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TIME_SYSTEMAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun TIME_SYSTEMInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    val ATTITUDE_TYPE : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ATTITUDE_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun ATTITUDE_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    val START_TIME : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val START_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun START_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    val STOP_TIME : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val STOP_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun STOP_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Time interval between attitude states in seconds (required).
     */
    val STEP_SIZE : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of components per attitude state.
     * 7 = quaternion + angular rates (Q1, Q2, Q3, QC, RATE_X, RATE_Y, RATE_Z)
     * 4 = quaternion only (Q1, Q2, Q3, QC)
     */
    val ATTITUDE_COMPONENTS : UByte
        get() {
            val o = __offset(24)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 7u
        }
    /**
     * Attitude data as row-major array of doubles.
     * Layout: [Q1_0, Q2_0, Q3_0, QC_0, RATE_X_0, RATE_Y_0, RATE_Z_0, Q1_1, ...]
     * Time reconstruction: epoch[i] = START_TIME + (i * STEP_SIZE)
     * Length must be divisible by ATTITUDE_COMPONENTS.
     */
    fun ATTITUDE_DATA(j: Int) : Double {
        val o = __offset(26)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val ATTITUDE_DATALength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    val ATTITUDE_DATAAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 8)
    fun ATTITUDE_DATAInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 8)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAEMSegment(_bb: ByteBuffer): AEMSegment = getRootAsAEMSegment(_bb, AEMSegment())
        fun getRootAsAEMSegment(_bb: ByteBuffer, obj: AEMSegment): AEMSegment {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createAEMSegment(builder: FlatBufferBuilder, OBJECT_NAMEOffset: Int, OBJECT_IDOffset: Int, REF_FRAME_AOffset: Int, REF_FRAME_BOffset: Int, ATTITUDE_DIROffset: Int, TIME_SYSTEMOffset: Int, ATTITUDE_TYPEOffset: Int, START_TIMEOffset: Int, STOP_TIMEOffset: Int, STEP_SIZE: Double, ATTITUDE_COMPONENTS: UByte, ATTITUDE_DATAOffset: Int) : Int {
            builder.startTable(12)
            addSTEP_SIZE(builder, STEP_SIZE)
            addATTITUDE_DATA(builder, ATTITUDE_DATAOffset)
            addSTOP_TIME(builder, STOP_TIMEOffset)
            addSTART_TIME(builder, START_TIMEOffset)
            addATTITUDE_TYPE(builder, ATTITUDE_TYPEOffset)
            addTIME_SYSTEM(builder, TIME_SYSTEMOffset)
            addATTITUDE_DIR(builder, ATTITUDE_DIROffset)
            addREF_FRAME_B(builder, REF_FRAME_BOffset)
            addREF_FRAME_A(builder, REF_FRAME_AOffset)
            addOBJECT_ID(builder, OBJECT_IDOffset)
            addOBJECT_NAME(builder, OBJECT_NAMEOffset)
            addATTITUDE_COMPONENTS(builder, ATTITUDE_COMPONENTS)
            return endAEMSegment(builder)
        }
        fun startAEMSegment(builder: FlatBufferBuilder) = builder.startTable(12)
        fun addOBJECT_NAME(builder: FlatBufferBuilder, OBJECT_NAME: Int) = builder.addOffset(0, OBJECT_NAME, 0)
        fun addOBJECT_ID(builder: FlatBufferBuilder, OBJECT_ID: Int) = builder.addOffset(1, OBJECT_ID, 0)
        fun addREF_FRAME_A(builder: FlatBufferBuilder, REF_FRAME_A: Int) = builder.addOffset(2, REF_FRAME_A, 0)
        fun addREF_FRAME_B(builder: FlatBufferBuilder, REF_FRAME_B: Int) = builder.addOffset(3, REF_FRAME_B, 0)
        fun addATTITUDE_DIR(builder: FlatBufferBuilder, ATTITUDE_DIR: Int) = builder.addOffset(4, ATTITUDE_DIR, 0)
        fun addTIME_SYSTEM(builder: FlatBufferBuilder, TIME_SYSTEM: Int) = builder.addOffset(5, TIME_SYSTEM, 0)
        fun addATTITUDE_TYPE(builder: FlatBufferBuilder, ATTITUDE_TYPE: Int) = builder.addOffset(6, ATTITUDE_TYPE, 0)
        fun addSTART_TIME(builder: FlatBufferBuilder, START_TIME: Int) = builder.addOffset(7, START_TIME, 0)
        fun addSTOP_TIME(builder: FlatBufferBuilder, STOP_TIME: Int) = builder.addOffset(8, STOP_TIME, 0)
        fun addSTEP_SIZE(builder: FlatBufferBuilder, STEP_SIZE: Double) = builder.addDouble(9, STEP_SIZE, 0.0)
        fun addATTITUDE_COMPONENTS(builder: FlatBufferBuilder, ATTITUDE_COMPONENTS: UByte) = builder.addByte(10, ATTITUDE_COMPONENTS.toByte(), 7)
        fun addATTITUDE_DATA(builder: FlatBufferBuilder, ATTITUDE_DATA: Int) = builder.addOffset(11, ATTITUDE_DATA, 0)
        fun createAttitudeDataVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startAttitudeDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun endAEMSegment(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
