// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Orbit Comprehensive Message
 */
@Suppress("unused")
class OCM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : OCM {
        __init(_i, _bb)
        return this
    }
    /**
     * Header section of the OCM.
     */
    val HEADER : Header? get() = HEADER(Header())
    fun HEADER(obj: Header) : Header? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Metadata section of the OCM.
     */
    val METADATA : Metadata? get() = METADATA(Metadata())
    fun METADATA(obj: Metadata) : Metadata? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Trajectory type (e.g., PROPAGATED, ESTIMATED).
     */
    val TRAJ_TYPE : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRAJ_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun TRAJ_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * State vector data.
     */
    fun STATE_DATA(j: Int) : StateVector? = STATE_DATA(StateVector(), j)
    fun STATE_DATA(obj: StateVector, j: Int) : StateVector? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val STATE_DATALength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Physical properties of the space object.
     */
    val PHYSICAL_PROPERTIES : PhysicalProperties? get() = PHYSICAL_PROPERTIES(PhysicalProperties())
    fun PHYSICAL_PROPERTIES(obj: PhysicalProperties) : PhysicalProperties? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Covariance data associated with the state vectors.
     */
    fun COVARIANCE_DATA(j: Int) : StateVector? = COVARIANCE_DATA(StateVector(), j)
    fun COVARIANCE_DATA(obj: StateVector, j: Int) : StateVector? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val COVARIANCE_DATALength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Maneuver data.
     */
    fun MANEUVER_DATA(j: Int) : Maneuver? = MANEUVER_DATA(Maneuver(), j)
    fun MANEUVER_DATA(obj: Maneuver, j: Int) : Maneuver? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val MANEUVER_DATALength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Perturbations parameters used.
     */
    val PERTURBATIONS : Perturbations? get() = PERTURBATIONS(Perturbations())
    fun PERTURBATIONS(obj: Perturbations) : Perturbations? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Orbit determination data.
     */
    val ORBIT_DETERMINATION : OrbitDetermination? get() = ORBIT_DETERMINATION(OrbitDetermination())
    fun ORBIT_DETERMINATION(obj: OrbitDetermination) : OrbitDetermination? {
        val o = __offset(20)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * User-defined parameters and supplemental comments.
     */
    fun USER_DEFINED_PARAMETERS(j: Int) : UserDefinedParameters? = USER_DEFINED_PARAMETERS(UserDefinedParameters(), j)
    fun USER_DEFINED_PARAMETERS(obj: UserDefinedParameters, j: Int) : UserDefinedParameters? {
        val o = __offset(22)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val USER_DEFINED_PARAMETERSLength : Int
        get() {
            val o = __offset(22); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsOCM(_bb: ByteBuffer): OCM = getRootAsOCM(_bb, OCM())
        fun getRootAsOCM(_bb: ByteBuffer, obj: OCM): OCM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun OCMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$OCM")
        fun createOCM(builder: FlatBufferBuilder, HEADEROffset: Int, METADATAOffset: Int, TRAJ_TYPEOffset: Int, STATE_DATAOffset: Int, PHYSICAL_PROPERTIESOffset: Int, COVARIANCE_DATAOffset: Int, MANEUVER_DATAOffset: Int, PERTURBATIONSOffset: Int, ORBIT_DETERMINATIONOffset: Int, USER_DEFINED_PARAMETERSOffset: Int) : Int {
            builder.startTable(10)
            addUSER_DEFINED_PARAMETERS(builder, USER_DEFINED_PARAMETERSOffset)
            addORBIT_DETERMINATION(builder, ORBIT_DETERMINATIONOffset)
            addPERTURBATIONS(builder, PERTURBATIONSOffset)
            addMANEUVER_DATA(builder, MANEUVER_DATAOffset)
            addCOVARIANCE_DATA(builder, COVARIANCE_DATAOffset)
            addPHYSICAL_PROPERTIES(builder, PHYSICAL_PROPERTIESOffset)
            addSTATE_DATA(builder, STATE_DATAOffset)
            addTRAJ_TYPE(builder, TRAJ_TYPEOffset)
            addMETADATA(builder, METADATAOffset)
            addHEADER(builder, HEADEROffset)
            return endOCM(builder)
        }
        fun startOCM(builder: FlatBufferBuilder) = builder.startTable(10)
        fun addHEADER(builder: FlatBufferBuilder, HEADER: Int) = builder.addOffset(0, HEADER, 0)
        fun addMETADATA(builder: FlatBufferBuilder, METADATA: Int) = builder.addOffset(1, METADATA, 0)
        fun addTRAJ_TYPE(builder: FlatBufferBuilder, TRAJ_TYPE: Int) = builder.addOffset(2, TRAJ_TYPE, 0)
        fun addSTATE_DATA(builder: FlatBufferBuilder, STATE_DATA: Int) = builder.addOffset(3, STATE_DATA, 0)
        fun createStateDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startStateDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPHYSICAL_PROPERTIES(builder: FlatBufferBuilder, PHYSICAL_PROPERTIES: Int) = builder.addOffset(4, PHYSICAL_PROPERTIES, 0)
        fun addCOVARIANCE_DATA(builder: FlatBufferBuilder, COVARIANCE_DATA: Int) = builder.addOffset(5, COVARIANCE_DATA, 0)
        fun createCovarianceDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCovarianceDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addMANEUVER_DATA(builder: FlatBufferBuilder, MANEUVER_DATA: Int) = builder.addOffset(6, MANEUVER_DATA, 0)
        fun createManeuverDataVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startManeuverDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPERTURBATIONS(builder: FlatBufferBuilder, PERTURBATIONS: Int) = builder.addOffset(7, PERTURBATIONS, 0)
        fun addORBIT_DETERMINATION(builder: FlatBufferBuilder, ORBIT_DETERMINATION: Int) = builder.addOffset(8, ORBIT_DETERMINATION, 0)
        fun addUSER_DEFINED_PARAMETERS(builder: FlatBufferBuilder, USER_DEFINED_PARAMETERS: Int) = builder.addOffset(9, USER_DEFINED_PARAMETERS, 0)
        fun createUserDefinedParametersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startUserDefinedParametersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endOCM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishOCMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$OCM")
        fun finishSizePrefixedOCMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$OCM")
    }
}
