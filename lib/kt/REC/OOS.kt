// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * On-Orbit Solar Array
 */
@Suppress("unused")
class OOS : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : OOS {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Reference to parent on-orbit object
     */
    val ID_ON_ORBIT : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_ON_ORBITAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun ID_ON_ORBITInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Reference to solar array specification
     */
    val ID_SOLAR_ARRAY : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_SOLAR_ARRAYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ID_SOLAR_ARRAYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Solar array name or designation
     */
    val NAME : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Solar cell type (e.g., SILICON, GAAS, MULTI_JUNCTION, THIN_FILM, PEROVSKITE)
     */
    val CELL_TYPE : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CELL_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun CELL_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Number of solar arrays of this type
     */
    val QUANTITY : UInt
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Total array area in square meters
     */
    val AREA : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beginning of life power output in Watts
     */
    val POWER_BOL : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * End of life power output in Watts
     */
    val POWER_EOL : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Conversion efficiency as fraction (0.0-1.0)
     */
    val EFFICIENCY : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Degradation rate per year as fraction
     */
    val DEGRADATION_RATE : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Number of panels per array
     */
    val NUM_PANELS : UInt
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Whether the array is deployable
     */
    val DEPLOYABLE : Boolean
        get() {
            val o = __offset(28)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Whether the array is articulable/tracking
     */
    val TRACKING : Boolean
        get() {
            val o = __offset(30)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Array mass in kg
     */
    val MASS : Double
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Additional notes
     */
    val NOTES : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NOTESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun NOTESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsOOS(_bb: ByteBuffer): OOS = getRootAsOOS(_bb, OOS())
        fun getRootAsOOS(_bb: ByteBuffer, obj: OOS): OOS {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun OOSBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$OOS")
        fun createOOS(builder: FlatBufferBuilder, IDOffset: Int, ID_ON_ORBITOffset: Int, ID_SOLAR_ARRAYOffset: Int, NAMEOffset: Int, CELL_TYPEOffset: Int, QUANTITY: UInt, AREA: Double, POWER_BOL: Double, POWER_EOL: Double, EFFICIENCY: Double, DEGRADATION_RATE: Double, NUM_PANELS: UInt, DEPLOYABLE: Boolean, TRACKING: Boolean, MASS: Double, NOTESOffset: Int) : Int {
            builder.startTable(16)
            addMASS(builder, MASS)
            addDEGRADATION_RATE(builder, DEGRADATION_RATE)
            addEFFICIENCY(builder, EFFICIENCY)
            addPOWER_EOL(builder, POWER_EOL)
            addPOWER_BOL(builder, POWER_BOL)
            addAREA(builder, AREA)
            addNOTES(builder, NOTESOffset)
            addNUM_PANELS(builder, NUM_PANELS)
            addQUANTITY(builder, QUANTITY)
            addCELL_TYPE(builder, CELL_TYPEOffset)
            addNAME(builder, NAMEOffset)
            addID_SOLAR_ARRAY(builder, ID_SOLAR_ARRAYOffset)
            addID_ON_ORBIT(builder, ID_ON_ORBITOffset)
            addID(builder, IDOffset)
            addTRACKING(builder, TRACKING)
            addDEPLOYABLE(builder, DEPLOYABLE)
            return endOOS(builder)
        }
        fun startOOS(builder: FlatBufferBuilder) = builder.startTable(16)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addID_ON_ORBIT(builder: FlatBufferBuilder, ID_ON_ORBIT: Int) = builder.addOffset(1, ID_ON_ORBIT, 0)
        fun addID_SOLAR_ARRAY(builder: FlatBufferBuilder, ID_SOLAR_ARRAY: Int) = builder.addOffset(2, ID_SOLAR_ARRAY, 0)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(3, NAME, 0)
        fun addCELL_TYPE(builder: FlatBufferBuilder, CELL_TYPE: Int) = builder.addOffset(4, CELL_TYPE, 0)
        fun addQUANTITY(builder: FlatBufferBuilder, QUANTITY: UInt) = builder.addInt(5, QUANTITY.toInt(), 0)
        fun addAREA(builder: FlatBufferBuilder, AREA: Double) = builder.addDouble(6, AREA, 0.0)
        fun addPOWER_BOL(builder: FlatBufferBuilder, POWER_BOL: Double) = builder.addDouble(7, POWER_BOL, 0.0)
        fun addPOWER_EOL(builder: FlatBufferBuilder, POWER_EOL: Double) = builder.addDouble(8, POWER_EOL, 0.0)
        fun addEFFICIENCY(builder: FlatBufferBuilder, EFFICIENCY: Double) = builder.addDouble(9, EFFICIENCY, 0.0)
        fun addDEGRADATION_RATE(builder: FlatBufferBuilder, DEGRADATION_RATE: Double) = builder.addDouble(10, DEGRADATION_RATE, 0.0)
        fun addNUM_PANELS(builder: FlatBufferBuilder, NUM_PANELS: UInt) = builder.addInt(11, NUM_PANELS.toInt(), 0)
        fun addDEPLOYABLE(builder: FlatBufferBuilder, DEPLOYABLE: Boolean) = builder.addBoolean(12, DEPLOYABLE, false)
        fun addTRACKING(builder: FlatBufferBuilder, TRACKING: Boolean) = builder.addBoolean(13, TRACKING, false)
        fun addMASS(builder: FlatBufferBuilder, MASS: Double) = builder.addDouble(14, MASS, 0.0)
        fun addNOTES(builder: FlatBufferBuilder, NOTES: Int) = builder.addOffset(15, NOTES, 0)
        fun endOOS(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishOOSBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$OOS")
        fun finishSizePrefixedOOSBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$OOS")
    }
}
