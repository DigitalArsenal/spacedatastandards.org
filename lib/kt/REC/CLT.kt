// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Command Link Transmission Unit Service (CCSDS 912.3-B-2)
 */
@Suppress("unused")
class CLT : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CLT {
        __init(_i, _bb)
        return this
    }
    /**
     * PDU type
     */
    val PDU_TYPE : Byte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Initiator identifier
     */
    val INITIATOR_ID : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val INITIATOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun INITIATOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Responder port identifier
     */
    val RESPONDER_PORT_ID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val RESPONDER_PORT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun RESPONDER_PORT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Service type
     */
    val SERVICE_TYPE : UByte
        get() {
            val o = __offset(10)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Version number
     */
    val VERSION : UShort
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    /**
     * Invoke ID
     */
    val INVOKE_ID : UInt
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * CLTU data
     */
    fun DATA(j: Int) : UByte {
        val o = __offset(16)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val DATALength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    val DATAAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun DATAInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCLT(_bb: ByteBuffer): CLT = getRootAsCLT(_bb, CLT())
        fun getRootAsCLT(_bb: ByteBuffer, obj: CLT): CLT {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun CLTBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$CLT")
        fun createCLT(builder: FlatBufferBuilder, PDU_TYPE: Byte, INITIATOR_IDOffset: Int, RESPONDER_PORT_IDOffset: Int, SERVICE_TYPE: UByte, VERSION: UShort, INVOKE_ID: UInt, DATAOffset: Int) : Int {
            builder.startTable(7)
            addDATA(builder, DATAOffset)
            addINVOKE_ID(builder, INVOKE_ID)
            addRESPONDER_PORT_ID(builder, RESPONDER_PORT_IDOffset)
            addINITIATOR_ID(builder, INITIATOR_IDOffset)
            addVERSION(builder, VERSION)
            addSERVICE_TYPE(builder, SERVICE_TYPE)
            addPDU_TYPE(builder, PDU_TYPE)
            return endCLT(builder)
        }
        fun startCLT(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addPDU_TYPE(builder: FlatBufferBuilder, PDU_TYPE: Byte) = builder.addByte(0, PDU_TYPE, 0)
        fun addINITIATOR_ID(builder: FlatBufferBuilder, INITIATOR_ID: Int) = builder.addOffset(1, INITIATOR_ID, 0)
        fun addRESPONDER_PORT_ID(builder: FlatBufferBuilder, RESPONDER_PORT_ID: Int) = builder.addOffset(2, RESPONDER_PORT_ID, 0)
        fun addSERVICE_TYPE(builder: FlatBufferBuilder, SERVICE_TYPE: UByte) = builder.addByte(3, SERVICE_TYPE.toByte(), 0)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: UShort) = builder.addShort(4, VERSION.toShort(), 0)
        fun addINVOKE_ID(builder: FlatBufferBuilder, INVOKE_ID: UInt) = builder.addInt(5, INVOKE_ID.toInt(), 0)
        fun addDATA(builder: FlatBufferBuilder, DATA: Int) = builder.addOffset(6, DATA, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createDataVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startDataVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endCLT(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishCLTBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$CLT")
        fun finishSizePrefixedCLTBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$CLT")
    }
}
