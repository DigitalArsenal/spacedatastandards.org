// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * MetaCommand definition
 */
@Suppress("unused")
class MetaCommand : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : MetaCommand {
        __init(_i, _bb)
        return this
    }
    /**
     * Command name
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Short description
     */
    val SHORT_DESCRIPTION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SHORT_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun SHORT_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Long description
     */
    val LONG_DESCRIPTION : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LONG_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun LONG_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Abstract command (base only)
     */
    val ABSTRACT : Boolean
        get() {
            val o = __offset(10)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Argument list
     */
    fun ARGUMENTS(j: Int) : Argument? = ARGUMENTS(Argument(), j)
    fun ARGUMENTS(obj: Argument, j: Int) : Argument? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val ARGUMENTSLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Command container
     */
    val COMMAND_CONTAINER : CommandContainer? get() = COMMAND_CONTAINER(CommandContainer())
    fun COMMAND_CONTAINER(obj: CommandContainer) : CommandContainer? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Base metacommand (inheritance)
     */
    val BASE_META_COMMAND : BaseMetaCommand? get() = BASE_META_COMMAND(BaseMetaCommand())
    fun BASE_META_COMMAND(obj: BaseMetaCommand) : BaseMetaCommand? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Command verifiers
     */
    fun VERIFIERS(j: Int) : CommandVerifier? = VERIFIERS(CommandVerifier(), j)
    fun VERIFIERS(obj: CommandVerifier, j: Int) : CommandVerifier? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val VERIFIERSLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Command significance
     */
    val SIGNIFICANCE : CommandSignificance? get() = SIGNIFICANCE(CommandSignificance())
    fun SIGNIFICANCE(obj: CommandSignificance) : CommandSignificance? {
        val o = __offset(20)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Interlock constraints
     */
    fun INTERLOCKS(j: Int) : Interlock? = INTERLOCKS(Interlock(), j)
    fun INTERLOCKS(obj: Interlock, j: Int) : Interlock? {
        val o = __offset(22)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val INTERLOCKSLength : Int
        get() {
            val o = __offset(22); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Default significance
     */
    val DEFAULT_SIGNIFICANCE : CommandSignificance? get() = DEFAULT_SIGNIFICANCE(CommandSignificance())
    fun DEFAULT_SIGNIFICANCE(obj: CommandSignificance) : CommandSignificance? {
        val o = __offset(24)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsMetaCommand(_bb: ByteBuffer): MetaCommand = getRootAsMetaCommand(_bb, MetaCommand())
        fun getRootAsMetaCommand(_bb: ByteBuffer, obj: MetaCommand): MetaCommand {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createMetaCommand(builder: FlatBufferBuilder, NAMEOffset: Int, SHORT_DESCRIPTIONOffset: Int, LONG_DESCRIPTIONOffset: Int, ABSTRACT: Boolean, ARGUMENTSOffset: Int, COMMAND_CONTAINEROffset: Int, BASE_META_COMMANDOffset: Int, VERIFIERSOffset: Int, SIGNIFICANCEOffset: Int, INTERLOCKSOffset: Int, DEFAULT_SIGNIFICANCEOffset: Int) : Int {
            builder.startTable(11)
            addDEFAULT_SIGNIFICANCE(builder, DEFAULT_SIGNIFICANCEOffset)
            addINTERLOCKS(builder, INTERLOCKSOffset)
            addSIGNIFICANCE(builder, SIGNIFICANCEOffset)
            addVERIFIERS(builder, VERIFIERSOffset)
            addBASE_META_COMMAND(builder, BASE_META_COMMANDOffset)
            addCOMMAND_CONTAINER(builder, COMMAND_CONTAINEROffset)
            addARGUMENTS(builder, ARGUMENTSOffset)
            addLONG_DESCRIPTION(builder, LONG_DESCRIPTIONOffset)
            addSHORT_DESCRIPTION(builder, SHORT_DESCRIPTIONOffset)
            addNAME(builder, NAMEOffset)
            addABSTRACT(builder, ABSTRACT)
            return endMetaCommand(builder)
        }
        fun startMetaCommand(builder: FlatBufferBuilder) = builder.startTable(11)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addSHORT_DESCRIPTION(builder: FlatBufferBuilder, SHORT_DESCRIPTION: Int) = builder.addOffset(1, SHORT_DESCRIPTION, 0)
        fun addLONG_DESCRIPTION(builder: FlatBufferBuilder, LONG_DESCRIPTION: Int) = builder.addOffset(2, LONG_DESCRIPTION, 0)
        fun addABSTRACT(builder: FlatBufferBuilder, ABSTRACT: Boolean) = builder.addBoolean(3, ABSTRACT, false)
        fun addARGUMENTS(builder: FlatBufferBuilder, ARGUMENTS: Int) = builder.addOffset(4, ARGUMENTS, 0)
        fun createArgumentsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startArgumentsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCOMMAND_CONTAINER(builder: FlatBufferBuilder, COMMAND_CONTAINER: Int) = builder.addOffset(5, COMMAND_CONTAINER, 0)
        fun addBASE_META_COMMAND(builder: FlatBufferBuilder, BASE_META_COMMAND: Int) = builder.addOffset(6, BASE_META_COMMAND, 0)
        fun addVERIFIERS(builder: FlatBufferBuilder, VERIFIERS: Int) = builder.addOffset(7, VERIFIERS, 0)
        fun createVerifiersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startVerifiersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSIGNIFICANCE(builder: FlatBufferBuilder, SIGNIFICANCE: Int) = builder.addOffset(8, SIGNIFICANCE, 0)
        fun addINTERLOCKS(builder: FlatBufferBuilder, INTERLOCKS: Int) = builder.addOffset(9, INTERLOCKS, 0)
        fun createInterlocksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startInterlocksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDEFAULT_SIGNIFICANCE(builder: FlatBufferBuilder, DEFAULT_SIGNIFICANCE: Int) = builder.addOffset(10, DEFAULT_SIGNIFICANCE, 0)
        fun endMetaCommand(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
