// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * A single interval in a time-varying property
 */
@Suppress("unused")
class CZMDynInterval : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CZMDynInterval {
        __init(_i, _bb)
        return this
    }
    /**
     * ISO 8601 interval string
     */
    val INTERVAL : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val INTERVALAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun INTERVALInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Value type
     */
    val VALUE_TYPE : Byte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Numeric value (when VALUE_TYPE is NUMBER)
     */
    val NUMBER_VALUE : Double
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Boolean value (when VALUE_TYPE is BOOLEAN)
     */
    val BOOLEAN_VALUE : Boolean
        get() {
            val o = __offset(10)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * String value (when VALUE_TYPE is STRING)
     */
    val STRING_VALUE : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val STRING_VALUEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun STRING_VALUEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Color value (when VALUE_TYPE is COLOR)
     */
    val COLOR_VALUE : CZMColor? get() = COLOR_VALUE(CZMColor())
    fun COLOR_VALUE(obj: CZMColor) : CZMColor? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Array value for cartesian/nearFarScalar types
     */
    fun ARRAY_VALUE(j: Int) : Double {
        val o = __offset(16)
        return if (o != 0) {
            bb.getDouble(__vector(o) + j * 8)
        } else {
            0.0
        }
    }
    val ARRAY_VALUELength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    val ARRAY_VALUEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 8)
    fun ARRAY_VALUEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 8)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCZMDynInterval(_bb: ByteBuffer): CZMDynInterval = getRootAsCZMDynInterval(_bb, CZMDynInterval())
        fun getRootAsCZMDynInterval(_bb: ByteBuffer, obj: CZMDynInterval): CZMDynInterval {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createCZMDynInterval(builder: FlatBufferBuilder, INTERVALOffset: Int, VALUE_TYPE: Byte, NUMBER_VALUE: Double, BOOLEAN_VALUE: Boolean, STRING_VALUEOffset: Int, COLOR_VALUEOffset: Int, ARRAY_VALUEOffset: Int) : Int {
            builder.startTable(7)
            addNUMBER_VALUE(builder, NUMBER_VALUE)
            addARRAY_VALUE(builder, ARRAY_VALUEOffset)
            addCOLOR_VALUE(builder, COLOR_VALUEOffset)
            addSTRING_VALUE(builder, STRING_VALUEOffset)
            addINTERVAL(builder, INTERVALOffset)
            addBOOLEAN_VALUE(builder, BOOLEAN_VALUE)
            addVALUE_TYPE(builder, VALUE_TYPE)
            return endCZMDynInterval(builder)
        }
        fun startCZMDynInterval(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addINTERVAL(builder: FlatBufferBuilder, INTERVAL: Int) = builder.addOffset(0, INTERVAL, 0)
        fun addVALUE_TYPE(builder: FlatBufferBuilder, VALUE_TYPE: Byte) = builder.addByte(1, VALUE_TYPE, 0)
        fun addNUMBER_VALUE(builder: FlatBufferBuilder, NUMBER_VALUE: Double) = builder.addDouble(2, NUMBER_VALUE, 0.0)
        fun addBOOLEAN_VALUE(builder: FlatBufferBuilder, BOOLEAN_VALUE: Boolean) = builder.addBoolean(3, BOOLEAN_VALUE, false)
        fun addSTRING_VALUE(builder: FlatBufferBuilder, STRING_VALUE: Int) = builder.addOffset(4, STRING_VALUE, 0)
        fun addCOLOR_VALUE(builder: FlatBufferBuilder, COLOR_VALUE: Int) = builder.addOffset(5, COLOR_VALUE, 0)
        fun addARRAY_VALUE(builder: FlatBufferBuilder, ARRAY_VALUE: Int) = builder.addOffset(6, ARRAY_VALUE, 0)
        fun createArrayValueVector(builder: FlatBufferBuilder, data: DoubleArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addDouble(data[i])
            }
            return builder.endVector()
        }
        fun startArrayValueVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun endCZMDynInterval(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
