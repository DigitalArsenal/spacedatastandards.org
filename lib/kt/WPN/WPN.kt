// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Weapons and Munitions
 */
@Suppress("unused")
class WPN : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : WPN {
        __init(_i, _bb)
        return this
    }
    val CALIBER : Float
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val MUZZLE_VELOCITY : Float
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val RATE_OF_FIRE : Float
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val DISPERSION : Float
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val AMMO_CAPACITY : UShort
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val BURST_LENGTH : UShort
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val RELOAD_TIME : Float
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val OVERHEAT_ROUNDS : UShort
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val COOLDOWN_RATE : Float
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ELEVATION_MIN : Float
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val ELEVATION_MAX : Float
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val TRAVERSE_MIN : Float
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val TRAVERSE_MAX : Float
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val SLEW_RATE : Float
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    val WEAPON_TYPE : UByte
        get() {
            val o = __offset(32)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val FUZE_TYPE : UByte
        get() {
            val o = __offset(34)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    fun RESERVED(j: Int) : UByte {
        val o = __offset(36)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val RESERVEDLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    val RESERVEDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun RESERVEDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsWPN(_bb: ByteBuffer): WPN = getRootAsWPN(_bb, WPN())
        fun getRootAsWPN(_bb: ByteBuffer, obj: WPN): WPN {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun WPNBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$WPN")
        fun createWPN(builder: FlatBufferBuilder, CALIBER: Float, MUZZLE_VELOCITY: Float, RATE_OF_FIRE: Float, DISPERSION: Float, AMMO_CAPACITY: UShort, BURST_LENGTH: UShort, RELOAD_TIME: Float, OVERHEAT_ROUNDS: UShort, COOLDOWN_RATE: Float, ELEVATION_MIN: Float, ELEVATION_MAX: Float, TRAVERSE_MIN: Float, TRAVERSE_MAX: Float, SLEW_RATE: Float, WEAPON_TYPE: UByte, FUZE_TYPE: UByte, RESERVEDOffset: Int) : Int {
            builder.startTable(17)
            addRESERVED(builder, RESERVEDOffset)
            addSLEW_RATE(builder, SLEW_RATE)
            addTRAVERSE_MAX(builder, TRAVERSE_MAX)
            addTRAVERSE_MIN(builder, TRAVERSE_MIN)
            addELEVATION_MAX(builder, ELEVATION_MAX)
            addELEVATION_MIN(builder, ELEVATION_MIN)
            addCOOLDOWN_RATE(builder, COOLDOWN_RATE)
            addRELOAD_TIME(builder, RELOAD_TIME)
            addDISPERSION(builder, DISPERSION)
            addRATE_OF_FIRE(builder, RATE_OF_FIRE)
            addMUZZLE_VELOCITY(builder, MUZZLE_VELOCITY)
            addCALIBER(builder, CALIBER)
            addOVERHEAT_ROUNDS(builder, OVERHEAT_ROUNDS)
            addBURST_LENGTH(builder, BURST_LENGTH)
            addAMMO_CAPACITY(builder, AMMO_CAPACITY)
            addFUZE_TYPE(builder, FUZE_TYPE)
            addWEAPON_TYPE(builder, WEAPON_TYPE)
            return endWPN(builder)
        }
        fun startWPN(builder: FlatBufferBuilder) = builder.startTable(17)
        fun addCALIBER(builder: FlatBufferBuilder, CALIBER: Float) = builder.addFloat(0, CALIBER, 0.0)
        fun addMUZZLE_VELOCITY(builder: FlatBufferBuilder, MUZZLE_VELOCITY: Float) = builder.addFloat(1, MUZZLE_VELOCITY, 0.0)
        fun addRATE_OF_FIRE(builder: FlatBufferBuilder, RATE_OF_FIRE: Float) = builder.addFloat(2, RATE_OF_FIRE, 0.0)
        fun addDISPERSION(builder: FlatBufferBuilder, DISPERSION: Float) = builder.addFloat(3, DISPERSION, 0.0)
        fun addAMMO_CAPACITY(builder: FlatBufferBuilder, AMMO_CAPACITY: UShort) = builder.addShort(4, AMMO_CAPACITY.toShort(), 0)
        fun addBURST_LENGTH(builder: FlatBufferBuilder, BURST_LENGTH: UShort) = builder.addShort(5, BURST_LENGTH.toShort(), 0)
        fun addRELOAD_TIME(builder: FlatBufferBuilder, RELOAD_TIME: Float) = builder.addFloat(6, RELOAD_TIME, 0.0)
        fun addOVERHEAT_ROUNDS(builder: FlatBufferBuilder, OVERHEAT_ROUNDS: UShort) = builder.addShort(7, OVERHEAT_ROUNDS.toShort(), 0)
        fun addCOOLDOWN_RATE(builder: FlatBufferBuilder, COOLDOWN_RATE: Float) = builder.addFloat(8, COOLDOWN_RATE, 0.0)
        fun addELEVATION_MIN(builder: FlatBufferBuilder, ELEVATION_MIN: Float) = builder.addFloat(9, ELEVATION_MIN, 0.0)
        fun addELEVATION_MAX(builder: FlatBufferBuilder, ELEVATION_MAX: Float) = builder.addFloat(10, ELEVATION_MAX, 0.0)
        fun addTRAVERSE_MIN(builder: FlatBufferBuilder, TRAVERSE_MIN: Float) = builder.addFloat(11, TRAVERSE_MIN, 0.0)
        fun addTRAVERSE_MAX(builder: FlatBufferBuilder, TRAVERSE_MAX: Float) = builder.addFloat(12, TRAVERSE_MAX, 0.0)
        fun addSLEW_RATE(builder: FlatBufferBuilder, SLEW_RATE: Float) = builder.addFloat(13, SLEW_RATE, 0.0)
        fun addWEAPON_TYPE(builder: FlatBufferBuilder, WEAPON_TYPE: UByte) = builder.addByte(14, WEAPON_TYPE.toByte(), 0)
        fun addFUZE_TYPE(builder: FlatBufferBuilder, FUZE_TYPE: UByte) = builder.addByte(15, FUZE_TYPE.toByte(), 0)
        fun addRESERVED(builder: FlatBufferBuilder, RESERVED: Int) = builder.addOffset(16, RESERVED, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createReservedVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startReservedVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endWPN(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishWPNBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$WPN")
        fun finishSizePrefixedWPNBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$WPN")
    }
}
