// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Antenna Beam
 */
@Suppress("unused")
class BEM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : BEM {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique beam identifier
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Beam name or designation
     */
    val BEAM_NAME : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val BEAM_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun BEAM_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Reference to parent entity (satellite/transponder)
     */
    val ID_ENTITY : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_ENTITYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ID_ENTITYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Reference to parent antenna
     */
    val ID_ANTENNA : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_ANTENNAAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun ID_ANTENNAInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Beam type
     */
    val TYPE : Byte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Beam polarization
     */
    val POLARIZATION : Byte
        get() {
            val o = __offset(14)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Peak gain in dBi
     */
    val PEAK_GAIN : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Edge-of-coverage gain in dBi
     */
    val EOC_GAIN : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beam center latitude in degrees
     */
    val CENTER_LATITUDE : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beam center longitude in degrees
     */
    val CENTER_LONGITUDE : Double
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beamwidth (3dB) in degrees
     */
    val BEAMWIDTH : Double
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Operating frequency in MHz
     */
    val FREQUENCY : Double
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * EIRP at beam center in dBW
     */
    val EIRP : Double
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * G/T at beam center in dB/K
     */
    val G_OVER_T : Double
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beam footprint area in km^2
     */
    val FOOTPRINT_AREA : Double
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Beam contour definitions
     */
    fun BEAM_CONTOURS(j: Int) : beamContour? = BEAM_CONTOURS(beamContour(), j)
    fun BEAM_CONTOURS(obj: beamContour, j: Int) : beamContour? {
        val o = __offset(34)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val BEAM_CONTOURSLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Additional notes
     */
    val NOTES : String?
        get() {
            val o = __offset(36)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NOTESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun NOTESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsBEM(_bb: ByteBuffer): BEM = getRootAsBEM(_bb, BEM())
        fun getRootAsBEM(_bb: ByteBuffer, obj: BEM): BEM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun BEMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$BEM")
        fun createBEM(builder: FlatBufferBuilder, IDOffset: Int, BEAM_NAMEOffset: Int, ID_ENTITYOffset: Int, ID_ANTENNAOffset: Int, TYPE: Byte, POLARIZATION: Byte, PEAK_GAIN: Double, EOC_GAIN: Double, CENTER_LATITUDE: Double, CENTER_LONGITUDE: Double, BEAMWIDTH: Double, FREQUENCY: Double, EIRP: Double, G_OVER_T: Double, FOOTPRINT_AREA: Double, BEAM_CONTOURSOffset: Int, NOTESOffset: Int) : Int {
            builder.startTable(17)
            addFOOTPRINT_AREA(builder, FOOTPRINT_AREA)
            addG_OVER_T(builder, G_OVER_T)
            addEIRP(builder, EIRP)
            addFREQUENCY(builder, FREQUENCY)
            addBEAMWIDTH(builder, BEAMWIDTH)
            addCENTER_LONGITUDE(builder, CENTER_LONGITUDE)
            addCENTER_LATITUDE(builder, CENTER_LATITUDE)
            addEOC_GAIN(builder, EOC_GAIN)
            addPEAK_GAIN(builder, PEAK_GAIN)
            addNOTES(builder, NOTESOffset)
            addBEAM_CONTOURS(builder, BEAM_CONTOURSOffset)
            addID_ANTENNA(builder, ID_ANTENNAOffset)
            addID_ENTITY(builder, ID_ENTITYOffset)
            addBEAM_NAME(builder, BEAM_NAMEOffset)
            addID(builder, IDOffset)
            addPOLARIZATION(builder, POLARIZATION)
            addTYPE(builder, TYPE)
            return endBEM(builder)
        }
        fun startBEM(builder: FlatBufferBuilder) = builder.startTable(17)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addBEAM_NAME(builder: FlatBufferBuilder, BEAM_NAME: Int) = builder.addOffset(1, BEAM_NAME, 0)
        fun addID_ENTITY(builder: FlatBufferBuilder, ID_ENTITY: Int) = builder.addOffset(2, ID_ENTITY, 0)
        fun addID_ANTENNA(builder: FlatBufferBuilder, ID_ANTENNA: Int) = builder.addOffset(3, ID_ANTENNA, 0)
        fun addTYPE(builder: FlatBufferBuilder, TYPE: Byte) = builder.addByte(4, TYPE, 0)
        fun addPOLARIZATION(builder: FlatBufferBuilder, POLARIZATION: Byte) = builder.addByte(5, POLARIZATION, 0)
        fun addPEAK_GAIN(builder: FlatBufferBuilder, PEAK_GAIN: Double) = builder.addDouble(6, PEAK_GAIN, 0.0)
        fun addEOC_GAIN(builder: FlatBufferBuilder, EOC_GAIN: Double) = builder.addDouble(7, EOC_GAIN, 0.0)
        fun addCENTER_LATITUDE(builder: FlatBufferBuilder, CENTER_LATITUDE: Double) = builder.addDouble(8, CENTER_LATITUDE, 0.0)
        fun addCENTER_LONGITUDE(builder: FlatBufferBuilder, CENTER_LONGITUDE: Double) = builder.addDouble(9, CENTER_LONGITUDE, 0.0)
        fun addBEAMWIDTH(builder: FlatBufferBuilder, BEAMWIDTH: Double) = builder.addDouble(10, BEAMWIDTH, 0.0)
        fun addFREQUENCY(builder: FlatBufferBuilder, FREQUENCY: Double) = builder.addDouble(11, FREQUENCY, 0.0)
        fun addEIRP(builder: FlatBufferBuilder, EIRP: Double) = builder.addDouble(12, EIRP, 0.0)
        fun addG_OVER_T(builder: FlatBufferBuilder, G_OVER_T: Double) = builder.addDouble(13, G_OVER_T, 0.0)
        fun addFOOTPRINT_AREA(builder: FlatBufferBuilder, FOOTPRINT_AREA: Double) = builder.addDouble(14, FOOTPRINT_AREA, 0.0)
        fun addBEAM_CONTOURS(builder: FlatBufferBuilder, BEAM_CONTOURS: Int) = builder.addOffset(15, BEAM_CONTOURS, 0)
        fun createBeamContoursVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startBeamContoursVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addNOTES(builder: FlatBufferBuilder, NOTES: Int) = builder.addOffset(16, NOTES, 0)
        fun endBEM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishBEMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$BEM")
        fun finishSizePrefixedBEMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$BEM")
    }
}
