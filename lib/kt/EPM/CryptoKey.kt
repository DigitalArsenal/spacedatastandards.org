// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Represents cryptographic key information
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class CryptoKey : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CryptoKey {
        __init(_i, _bb)
        return this
    }
    /**
     * Public part of the cryptographic key
     */
    val PUBLIC_KEY : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PUBLIC_KEYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun PUBLIC_KEYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Extended public key
     */
    val XPUB : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val XPUBAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun XPUBInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Private part of the cryptographic key, should be kept secret
     */
    val PRIVATE_KEY : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PRIVATE_KEYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun PRIVATE_KEYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Extended private key
     */
    val XPRIV : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val XPRIVAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun XPRIVInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Address generated from the cryptographic key
     */
    val KEY_ADDRESS : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val KEY_ADDRESSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun KEY_ADDRESSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Type of the address generated from the cryptographic key
     */
    val ADDRESS_TYPE : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ADDRESS_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun ADDRESS_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Type of the cryptographic key (signing or encryption)
     */
    val KEY_TYPE : Byte
        get() {
            val o = __offset(16)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsCryptoKey(_bb: ByteBuffer): CryptoKey = getRootAsCryptoKey(_bb, CryptoKey())
        fun getRootAsCryptoKey(_bb: ByteBuffer, obj: CryptoKey): CryptoKey {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createCryptoKey(builder: FlatBufferBuilder, PUBLIC_KEYOffset: Int, XPUBOffset: Int, PRIVATE_KEYOffset: Int, XPRIVOffset: Int, KEY_ADDRESSOffset: Int, ADDRESS_TYPEOffset: Int, KEY_TYPE: Byte) : Int {
            builder.startTable(7)
            addADDRESS_TYPE(builder, ADDRESS_TYPEOffset)
            addKEY_ADDRESS(builder, KEY_ADDRESSOffset)
            addXPRIV(builder, XPRIVOffset)
            addPRIVATE_KEY(builder, PRIVATE_KEYOffset)
            addXPUB(builder, XPUBOffset)
            addPUBLIC_KEY(builder, PUBLIC_KEYOffset)
            addKEY_TYPE(builder, KEY_TYPE)
            return endCryptoKey(builder)
        }
        fun startCryptoKey(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addPUBLIC_KEY(builder: FlatBufferBuilder, PUBLIC_KEY: Int) = builder.addOffset(0, PUBLIC_KEY, 0)
        fun addXPUB(builder: FlatBufferBuilder, XPUB: Int) = builder.addOffset(1, XPUB, 0)
        fun addPRIVATE_KEY(builder: FlatBufferBuilder, PRIVATE_KEY: Int) = builder.addOffset(2, PRIVATE_KEY, 0)
        fun addXPRIV(builder: FlatBufferBuilder, XPRIV: Int) = builder.addOffset(3, XPRIV, 0)
        fun addKEY_ADDRESS(builder: FlatBufferBuilder, KEY_ADDRESS: Int) = builder.addOffset(4, KEY_ADDRESS, 0)
        fun addADDRESS_TYPE(builder: FlatBufferBuilder, ADDRESS_TYPE: Int) = builder.addOffset(5, ADDRESS_TYPE, 0)
        fun addKEY_TYPE(builder: FlatBufferBuilder, KEY_TYPE: Byte) = builder.addByte(6, KEY_TYPE, 0)
        fun endCryptoKey(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
