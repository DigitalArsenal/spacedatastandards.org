// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * GPX Document
 */
@Suppress("unused")
class GPX : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : GPX {
        __init(_i, _bb)
        return this
    }
    /**
     * GPX schema version
     */
    val VERSION : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val VERSIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun VERSIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Creator software/organization
     */
    val CREATOR : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CREATORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun CREATORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * File name
     */
    val NAME : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * File description
     */
    val DESCRIPTION : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Person or organization who created the file
     */
    val AUTHOR_NAME : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val AUTHOR_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun AUTHOR_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Author email
     */
    val AUTHOR_EMAIL : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val AUTHOR_EMAILAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun AUTHOR_EMAILInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Author link
     */
    val AUTHOR_LINK : GPXLink? get() = AUTHOR_LINK(GPXLink())
    fun AUTHOR_LINK(obj: GPXLink) : GPXLink? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Copyright holder
     */
    val COPYRIGHT_AUTHOR : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COPYRIGHT_AUTHORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun COPYRIGHT_AUTHORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Copyright year
     */
    val COPYRIGHT_YEAR : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COPYRIGHT_YEARAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun COPYRIGHT_YEARInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Copyright license URL
     */
    val COPYRIGHT_LICENSE : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COPYRIGHT_LICENSEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun COPYRIGHT_LICENSEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Links to additional information
     */
    fun LINKS(j: Int) : GPXLink? = LINKS(GPXLink(), j)
    fun LINKS(obj: GPXLink, j: Int) : GPXLink? {
        val o = __offset(24)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val LINKSLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Creation timestamp (ISO 8601)
     */
    val TIME : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Keywords
     */
    val KEYWORDS : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val KEYWORDSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun KEYWORDSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Minimum latitude of bounding box
     */
    val BOUNDS_MIN_LAT : Double
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Minimum longitude of bounding box
     */
    val BOUNDS_MIN_LON : Double
        get() {
            val o = __offset(32)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum latitude of bounding box
     */
    val BOUNDS_MAX_LAT : Double
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum longitude of bounding box
     */
    val BOUNDS_MAX_LON : Double
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Waypoints
     */
    fun WAYPOINTS(j: Int) : GPXWaypoint? = WAYPOINTS(GPXWaypoint(), j)
    fun WAYPOINTS(obj: GPXWaypoint, j: Int) : GPXWaypoint? {
        val o = __offset(38)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val WAYPOINTSLength : Int
        get() {
            val o = __offset(38); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Routes
     */
    fun ROUTES(j: Int) : GPXRoute? = ROUTES(GPXRoute(), j)
    fun ROUTES(obj: GPXRoute, j: Int) : GPXRoute? {
        val o = __offset(40)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val ROUTESLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Tracks
     */
    fun TRACKS(j: Int) : GPXTrack? = TRACKS(GPXTrack(), j)
    fun TRACKS(obj: GPXTrack, j: Int) : GPXTrack? {
        val o = __offset(42)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val TRACKSLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsGPX(_bb: ByteBuffer): GPX = getRootAsGPX(_bb, GPX())
        fun getRootAsGPX(_bb: ByteBuffer, obj: GPX): GPX {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun GPXBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$GPX")
        fun createGPX(builder: FlatBufferBuilder, VERSIONOffset: Int, CREATOROffset: Int, NAMEOffset: Int, DESCRIPTIONOffset: Int, AUTHOR_NAMEOffset: Int, AUTHOR_EMAILOffset: Int, AUTHOR_LINKOffset: Int, COPYRIGHT_AUTHOROffset: Int, COPYRIGHT_YEAROffset: Int, COPYRIGHT_LICENSEOffset: Int, LINKSOffset: Int, TIMEOffset: Int, KEYWORDSOffset: Int, BOUNDS_MIN_LAT: Double, BOUNDS_MIN_LON: Double, BOUNDS_MAX_LAT: Double, BOUNDS_MAX_LON: Double, WAYPOINTSOffset: Int, ROUTESOffset: Int, TRACKSOffset: Int) : Int {
            builder.startTable(20)
            addBOUNDS_MAX_LON(builder, BOUNDS_MAX_LON)
            addBOUNDS_MAX_LAT(builder, BOUNDS_MAX_LAT)
            addBOUNDS_MIN_LON(builder, BOUNDS_MIN_LON)
            addBOUNDS_MIN_LAT(builder, BOUNDS_MIN_LAT)
            addTRACKS(builder, TRACKSOffset)
            addROUTES(builder, ROUTESOffset)
            addWAYPOINTS(builder, WAYPOINTSOffset)
            addKEYWORDS(builder, KEYWORDSOffset)
            addTIME(builder, TIMEOffset)
            addLINKS(builder, LINKSOffset)
            addCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSEOffset)
            addCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAROffset)
            addCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOROffset)
            addAUTHOR_LINK(builder, AUTHOR_LINKOffset)
            addAUTHOR_EMAIL(builder, AUTHOR_EMAILOffset)
            addAUTHOR_NAME(builder, AUTHOR_NAMEOffset)
            addDESCRIPTION(builder, DESCRIPTIONOffset)
            addNAME(builder, NAMEOffset)
            addCREATOR(builder, CREATOROffset)
            addVERSION(builder, VERSIONOffset)
            return endGPX(builder)
        }
        fun startGPX(builder: FlatBufferBuilder) = builder.startTable(20)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: Int) = builder.addOffset(0, VERSION, 0)
        fun addCREATOR(builder: FlatBufferBuilder, CREATOR: Int) = builder.addOffset(1, CREATOR, 0)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(2, NAME, 0)
        fun addDESCRIPTION(builder: FlatBufferBuilder, DESCRIPTION: Int) = builder.addOffset(3, DESCRIPTION, 0)
        fun addAUTHOR_NAME(builder: FlatBufferBuilder, AUTHOR_NAME: Int) = builder.addOffset(4, AUTHOR_NAME, 0)
        fun addAUTHOR_EMAIL(builder: FlatBufferBuilder, AUTHOR_EMAIL: Int) = builder.addOffset(5, AUTHOR_EMAIL, 0)
        fun addAUTHOR_LINK(builder: FlatBufferBuilder, AUTHOR_LINK: Int) = builder.addOffset(6, AUTHOR_LINK, 0)
        fun addCOPYRIGHT_AUTHOR(builder: FlatBufferBuilder, COPYRIGHT_AUTHOR: Int) = builder.addOffset(7, COPYRIGHT_AUTHOR, 0)
        fun addCOPYRIGHT_YEAR(builder: FlatBufferBuilder, COPYRIGHT_YEAR: Int) = builder.addOffset(8, COPYRIGHT_YEAR, 0)
        fun addCOPYRIGHT_LICENSE(builder: FlatBufferBuilder, COPYRIGHT_LICENSE: Int) = builder.addOffset(9, COPYRIGHT_LICENSE, 0)
        fun addLINKS(builder: FlatBufferBuilder, LINKS: Int) = builder.addOffset(10, LINKS, 0)
        fun createLinksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLinksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTIME(builder: FlatBufferBuilder, TIME: Int) = builder.addOffset(11, TIME, 0)
        fun addKEYWORDS(builder: FlatBufferBuilder, KEYWORDS: Int) = builder.addOffset(12, KEYWORDS, 0)
        fun addBOUNDS_MIN_LAT(builder: FlatBufferBuilder, BOUNDS_MIN_LAT: Double) = builder.addDouble(13, BOUNDS_MIN_LAT, 0.0)
        fun addBOUNDS_MIN_LON(builder: FlatBufferBuilder, BOUNDS_MIN_LON: Double) = builder.addDouble(14, BOUNDS_MIN_LON, 0.0)
        fun addBOUNDS_MAX_LAT(builder: FlatBufferBuilder, BOUNDS_MAX_LAT: Double) = builder.addDouble(15, BOUNDS_MAX_LAT, 0.0)
        fun addBOUNDS_MAX_LON(builder: FlatBufferBuilder, BOUNDS_MAX_LON: Double) = builder.addDouble(16, BOUNDS_MAX_LON, 0.0)
        fun addWAYPOINTS(builder: FlatBufferBuilder, WAYPOINTS: Int) = builder.addOffset(17, WAYPOINTS, 0)
        fun createWaypointsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startWaypointsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addROUTES(builder: FlatBufferBuilder, ROUTES: Int) = builder.addOffset(18, ROUTES, 0)
        fun createRoutesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRoutesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTRACKS(builder: FlatBufferBuilder, TRACKS: Int) = builder.addOffset(19, TRACKS, 0)
        fun createTracksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTracksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endGPX(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishGPXBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$GPX")
        fun finishSizePrefixedGPXBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$GPX")
    }
}
