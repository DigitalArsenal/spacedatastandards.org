// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Storefront Listing - Data marketplace listing
 */
@Suppress("unused")
class STF : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : STF {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier for the listing
     */
    val LISTING_ID : String
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field LISTING_ID")
            }
        }
    val LISTING_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun LISTING_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Peer ID of the data provider
     */
    val PROVIDER_PEER_ID : String
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field PROVIDER_PEER_ID")
            }
        }
    val PROVIDER_PEER_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun PROVIDER_PEER_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * IPFS CID of provider's EPM (Entity Profile Message)
     */
    val PROVIDER_EPM_CID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PROVIDER_EPM_CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun PROVIDER_EPM_CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Title of the data listing
     */
    val TITLE : String
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field TITLE")
            }
        }
    val TITLEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun TITLEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Detailed description of the data offering
     */
    val DESCRIPTION : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
     */
    fun DATA_TYPES(j: Int) : String? {
        val o = __offset(14)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val DATA_TYPESLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Coverage information (spatial and temporal)
     */
    val COVERAGE : DataCoverage? get() = COVERAGE(DataCoverage())
    fun COVERAGE(obj: DataCoverage) : DataCoverage? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * IPFS CID of sample data
     */
    val SAMPLE_CID : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SAMPLE_CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun SAMPLE_CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Type of access offered
     */
    val ACCESS_TYPE : Byte
        get() {
            val o = __offset(20)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Whether encryption is required for data delivery
     */
    val ENCRYPTION_REQUIRED : Boolean
        get() {
            val o = __offset(22)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Available pricing tiers
     */
    fun PRICING(j: Int) : PricingTier? = PRICING(PricingTier(), j)
    fun PRICING(obj: PricingTier, j: Int) : PricingTier? {
        val o = __offset(24)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val PRICINGLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Payment methods accepted
     */
    fun ACCEPTED_PAYMENTS(j: Int) : Byte {
        val o = __offset(26)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1)
        } else {
            0
        }
    }
    val ACCEPTED_PAYMENTSLength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    val ACCEPTED_PAYMENTSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun ACCEPTED_PAYMENTSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Unix timestamp when listing was created
     */
    val CREATED_AT : ULong
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Unix timestamp when listing was last updated
     */
    val UPDATED_AT : ULong
        get() {
            val o = __offset(30)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Whether the listing is currently active
     */
    val ACTIVE : Boolean
        get() {
            val o = __offset(32)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Ed25519 signature from provider
     */
    fun SIGNATURE(j: Int) : UByte {
        val o = __offset(34)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val SIGNATURELength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    val SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsSTF(_bb: ByteBuffer): STF = getRootAsSTF(_bb, STF())
        fun getRootAsSTF(_bb: ByteBuffer, obj: STF): STF {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun STFBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$STF")
        fun createSTF(builder: FlatBufferBuilder, LISTING_IDOffset: Int, PROVIDER_PEER_IDOffset: Int, PROVIDER_EPM_CIDOffset: Int, TITLEOffset: Int, DESCRIPTIONOffset: Int, DATA_TYPESOffset: Int, COVERAGEOffset: Int, SAMPLE_CIDOffset: Int, ACCESS_TYPE: Byte, ENCRYPTION_REQUIRED: Boolean, PRICINGOffset: Int, ACCEPTED_PAYMENTSOffset: Int, CREATED_AT: ULong, UPDATED_AT: ULong, ACTIVE: Boolean, SIGNATUREOffset: Int) : Int {
            builder.startTable(16)
            addUPDATED_AT(builder, UPDATED_AT)
            addCREATED_AT(builder, CREATED_AT)
            addSIGNATURE(builder, SIGNATUREOffset)
            addACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTSOffset)
            addPRICING(builder, PRICINGOffset)
            addSAMPLE_CID(builder, SAMPLE_CIDOffset)
            addCOVERAGE(builder, COVERAGEOffset)
            addDATA_TYPES(builder, DATA_TYPESOffset)
            addDESCRIPTION(builder, DESCRIPTIONOffset)
            addTITLE(builder, TITLEOffset)
            addPROVIDER_EPM_CID(builder, PROVIDER_EPM_CIDOffset)
            addPROVIDER_PEER_ID(builder, PROVIDER_PEER_IDOffset)
            addLISTING_ID(builder, LISTING_IDOffset)
            addACTIVE(builder, ACTIVE)
            addENCRYPTION_REQUIRED(builder, ENCRYPTION_REQUIRED)
            addACCESS_TYPE(builder, ACCESS_TYPE)
            return endSTF(builder)
        }
        fun startSTF(builder: FlatBufferBuilder) = builder.startTable(16)
        fun addLISTING_ID(builder: FlatBufferBuilder, LISTING_ID: Int) = builder.addOffset(0, LISTING_ID, 0)
        fun addPROVIDER_PEER_ID(builder: FlatBufferBuilder, PROVIDER_PEER_ID: Int) = builder.addOffset(1, PROVIDER_PEER_ID, 0)
        fun addPROVIDER_EPM_CID(builder: FlatBufferBuilder, PROVIDER_EPM_CID: Int) = builder.addOffset(2, PROVIDER_EPM_CID, 0)
        fun addTITLE(builder: FlatBufferBuilder, TITLE: Int) = builder.addOffset(3, TITLE, 0)
        fun addDESCRIPTION(builder: FlatBufferBuilder, DESCRIPTION: Int) = builder.addOffset(4, DESCRIPTION, 0)
        fun addDATA_TYPES(builder: FlatBufferBuilder, DATA_TYPES: Int) = builder.addOffset(5, DATA_TYPES, 0)
        fun createDataTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDataTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCOVERAGE(builder: FlatBufferBuilder, COVERAGE: Int) = builder.addOffset(6, COVERAGE, 0)
        fun addSAMPLE_CID(builder: FlatBufferBuilder, SAMPLE_CID: Int) = builder.addOffset(7, SAMPLE_CID, 0)
        fun addACCESS_TYPE(builder: FlatBufferBuilder, ACCESS_TYPE: Byte) = builder.addByte(8, ACCESS_TYPE, 0)
        fun addENCRYPTION_REQUIRED(builder: FlatBufferBuilder, ENCRYPTION_REQUIRED: Boolean) = builder.addBoolean(9, ENCRYPTION_REQUIRED, false)
        fun addPRICING(builder: FlatBufferBuilder, PRICING: Int) = builder.addOffset(10, PRICING, 0)
        fun createPricingVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPricingVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addACCEPTED_PAYMENTS(builder: FlatBufferBuilder, ACCEPTED_PAYMENTS: Int) = builder.addOffset(11, ACCEPTED_PAYMENTS, 0)
        fun createAcceptedPaymentsVector(builder: FlatBufferBuilder, data: ByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i])
            }
            return builder.endVector()
        }
        fun startAcceptedPaymentsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addCREATED_AT(builder: FlatBufferBuilder, CREATED_AT: ULong) = builder.addLong(12, CREATED_AT.toLong(), 0)
        fun addUPDATED_AT(builder: FlatBufferBuilder, UPDATED_AT: ULong) = builder.addLong(13, UPDATED_AT.toLong(), 0)
        fun addACTIVE(builder: FlatBufferBuilder, ACTIVE: Boolean) = builder.addBoolean(14, ACTIVE, false)
        fun addSIGNATURE(builder: FlatBufferBuilder, SIGNATURE: Int) = builder.addOffset(15, SIGNATURE, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createSignatureVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startSignatureVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endSTF(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 4)
                builder.required(o, 6)
                builder.required(o, 10)
            return o
        }
        fun finishSTFBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$STF")
        fun finishSizePrefixedSTFBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$STF")
    }
}
