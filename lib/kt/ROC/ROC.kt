// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Rocket Configuration
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class ROC : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ROC {
        __init(_i, _bb)
        return this
    }
    /**
     * Rocket Name
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Rocket Family
     */
    val FAMILY : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val FAMILYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun FAMILYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Rocket Variant
     */
    val VARIANT : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val VARIANTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun VARIANTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Stages in the Rocket
     */
    fun STAGES(j: Int) : STAGE? = STAGES(STAGE(), j)
    fun STAGES(obj: STAGE, j: Int) : STAGE? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val STAGESLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Sustainers in the Rocket
     */
    fun SUSTAINERS(j: Int) : SUSTAINER? = SUSTAINERS(SUSTAINER(), j)
    fun SUSTAINERS(obj: SUSTAINER, j: Int) : SUSTAINER? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val SUSTAINERSLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsROC(_bb: ByteBuffer): ROC = getRootAsROC(_bb, ROC())
        fun getRootAsROC(_bb: ByteBuffer, obj: ROC): ROC {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun ROCBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$ROC")
        fun createROC(builder: FlatBufferBuilder, NAMEOffset: Int, FAMILYOffset: Int, VARIANTOffset: Int, STAGESOffset: Int, SUSTAINERSOffset: Int) : Int {
            builder.startTable(5)
            addSUSTAINERS(builder, SUSTAINERSOffset)
            addSTAGES(builder, STAGESOffset)
            addVARIANT(builder, VARIANTOffset)
            addFAMILY(builder, FAMILYOffset)
            addNAME(builder, NAMEOffset)
            return endROC(builder)
        }
        fun startROC(builder: FlatBufferBuilder) = builder.startTable(5)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addFAMILY(builder: FlatBufferBuilder, FAMILY: Int) = builder.addOffset(1, FAMILY, 0)
        fun addVARIANT(builder: FlatBufferBuilder, VARIANT: Int) = builder.addOffset(2, VARIANT, 0)
        fun addSTAGES(builder: FlatBufferBuilder, STAGES: Int) = builder.addOffset(3, STAGES, 0)
        fun createStagesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startStagesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSUSTAINERS(builder: FlatBufferBuilder, SUSTAINERS: Int) = builder.addOffset(4, SUSTAINERS, 0)
        fun createSustainersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSustainersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endROC(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishROCBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$ROC")
        fun finishSizePrefixedROCBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$ROC")
    }
}
