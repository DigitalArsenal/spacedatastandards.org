// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Publish Notification Message
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class PNM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PNM {
        __init(_i, _bb)
        return this
    }
    /**
     * IPFS Content Identifier (CID)
     * The hash of a file stored on the InterPlanetary File System (IPFS).
     * Refer to the section on IPFS integration for details.
     */
    val IPFS_CID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IPFS_CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IPFS_CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Unique identifier generated from the data provider's public key
     */
    val KEY_ADDRESS : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val KEY_ADDRESSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun KEY_ADDRESSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * SpaceDataStandards 4 Character File Identifier
     */
    val FILE_IDENTIFIER : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val FILE_IDENTIFIERAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun FILE_IDENTIFIERInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsPNM(_bb: ByteBuffer): PNM = getRootAsPNM(_bb, PNM())
        fun getRootAsPNM(_bb: ByteBuffer, obj: PNM): PNM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PNMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PNM")
        fun createPNM(builder: FlatBufferBuilder, IPFS_CIDOffset: Int, KEY_ADDRESSOffset: Int, FILE_IDENTIFIEROffset: Int) : Int {
            builder.startTable(3)
            addFILE_IDENTIFIER(builder, FILE_IDENTIFIEROffset)
            addKEY_ADDRESS(builder, KEY_ADDRESSOffset)
            addIPFS_CID(builder, IPFS_CIDOffset)
            return endPNM(builder)
        }
        fun startPNM(builder: FlatBufferBuilder) = builder.startTable(3)
        fun addIPFS_CID(builder: FlatBufferBuilder, IPFS_CID: Int) = builder.addOffset(0, IPFS_CID, 0)
        fun addKEY_ADDRESS(builder: FlatBufferBuilder, KEY_ADDRESS: Int) = builder.addOffset(1, KEY_ADDRESS, 0)
        fun addFILE_IDENTIFIER(builder: FlatBufferBuilder, FILE_IDENTIFIER: Int) = builder.addOffset(2, FILE_IDENTIFIER, 0)
        fun endPNM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishPNMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PNM")
        fun finishSizePrefixedPNMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PNM")
    }
}
