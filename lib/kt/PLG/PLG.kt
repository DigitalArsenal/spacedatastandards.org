// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Plugin Manifest - WASM plugin distribution
 */
@Suppress("unused")
class PLG : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PLG {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier for the plugin
     */
    val PLUGIN_ID : String
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field PLUGIN_ID")
            }
        }
    val PLUGIN_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun PLUGIN_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Human-readable plugin name
     */
    val NAME : String
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field NAME")
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Plugin version (semver format)
     */
    val VERSION : String
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field VERSION")
            }
        }
    val VERSIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun VERSIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Detailed description of plugin functionality
     */
    val DESCRIPTION : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Type/category of the plugin
     */
    val PLUGIN_TYPE : Byte
        get() {
            val o = __offset(12)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * ABI version for compatibility checking
     */
    val ABI_VERSION : UInt
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 1u
        }
    /**
     * SHA256 hash of the decrypted WASM binary
     */
    fun WASM_HASH(j: Int) : UByte {
        val o = __offset(16)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val WASM_HASHLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    val WASM_HASHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun WASM_HASHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Size of WASM binary in bytes
     */
    val WASM_SIZE : ULong
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * IPFS CID of the encrypted WASM binary
     */
    val WASM_CID : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val WASM_CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun WASM_CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Entry point functions exported by the plugin
     */
    fun ENTRY_FUNCTIONS(j: Int) : EntryFunction? = ENTRY_FUNCTIONS(EntryFunction(), j)
    fun ENTRY_FUNCTIONS(obj: EntryFunction, j: Int) : EntryFunction? {
        val o = __offset(22)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val ENTRY_FUNCTIONSLength : Int
        get() {
            val o = __offset(22); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * FlatBuffer schemas required by this plugin
     */
    fun REQUIRED_SCHEMAS(j: Int) : String? {
        val o = __offset(24)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val REQUIRED_SCHEMASLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Other plugins this depends on
     */
    fun DEPENDENCIES(j: Int) : PluginDependency? = DEPENDENCIES(PluginDependency(), j)
    fun DEPENDENCIES(obj: PluginDependency, j: Int) : PluginDependency? {
        val o = __offset(26)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val DEPENDENCIESLength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Capabilities provided by this plugin
     */
    fun CAPABILITIES(j: Int) : PluginCapability? = CAPABILITIES(PluginCapability(), j)
    fun CAPABILITIES(obj: PluginCapability, j: Int) : PluginCapability? {
        val o = __offset(28)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val CAPABILITIESLength : Int
        get() {
            val o = __offset(28); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Peer ID of the plugin provider
     */
    val PROVIDER_PEER_ID : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PROVIDER_PEER_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun PROVIDER_PEER_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * IPFS CID of provider's EPM (Entity Profile Message)
     */
    val PROVIDER_EPM_CID : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PROVIDER_EPM_CIDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun PROVIDER_EPM_CIDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * Whether the WASM binary is encrypted
     */
    val ENCRYPTED : Boolean
        get() {
            val o = __offset(34)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else true
        }
    /**
     * Minimum permissions required to run
     */
    fun MIN_PERMISSIONS(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MIN_PERMISSIONSLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Unix timestamp when plugin was created
     */
    val CREATED_AT : ULong
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Unix timestamp when plugin was last updated
     */
    val UPDATED_AT : ULong
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * URL to plugin documentation
     */
    val DOCUMENTATION_URL : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DOCUMENTATION_URLAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun DOCUMENTATION_URLInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * URL to plugin icon/logo
     */
    val ICON_URL : String?
        get() {
            val o = __offset(44)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ICON_URLAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(44, 1)
    fun ICON_URLInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 44, 1)
    /**
     * License identifier (SPDX format)
     */
    val LICENSE : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LICENSEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun LICENSEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Ed25519 signature from provider over manifest
     */
    fun SIGNATURE(j: Int) : UByte {
        val o = __offset(48)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val SIGNATURELength : Int
        get() {
            val o = __offset(48); return if (o != 0) __vector_len(o) else 0
        }
    val SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsPLG(_bb: ByteBuffer): PLG = getRootAsPLG(_bb, PLG())
        fun getRootAsPLG(_bb: ByteBuffer, obj: PLG): PLG {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PLGBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PLG")
        fun createPLG(builder: FlatBufferBuilder, PLUGIN_IDOffset: Int, NAMEOffset: Int, VERSIONOffset: Int, DESCRIPTIONOffset: Int, PLUGIN_TYPE: Byte, ABI_VERSION: UInt, WASM_HASHOffset: Int, WASM_SIZE: ULong, WASM_CIDOffset: Int, ENTRY_FUNCTIONSOffset: Int, REQUIRED_SCHEMASOffset: Int, DEPENDENCIESOffset: Int, CAPABILITIESOffset: Int, PROVIDER_PEER_IDOffset: Int, PROVIDER_EPM_CIDOffset: Int, ENCRYPTED: Boolean, MIN_PERMISSIONSOffset: Int, CREATED_AT: ULong, UPDATED_AT: ULong, DOCUMENTATION_URLOffset: Int, ICON_URLOffset: Int, LICENSEOffset: Int, SIGNATUREOffset: Int) : Int {
            builder.startTable(23)
            addUPDATED_AT(builder, UPDATED_AT)
            addCREATED_AT(builder, CREATED_AT)
            addWASM_SIZE(builder, WASM_SIZE)
            addSIGNATURE(builder, SIGNATUREOffset)
            addLICENSE(builder, LICENSEOffset)
            addICON_URL(builder, ICON_URLOffset)
            addDOCUMENTATION_URL(builder, DOCUMENTATION_URLOffset)
            addMIN_PERMISSIONS(builder, MIN_PERMISSIONSOffset)
            addPROVIDER_EPM_CID(builder, PROVIDER_EPM_CIDOffset)
            addPROVIDER_PEER_ID(builder, PROVIDER_PEER_IDOffset)
            addCAPABILITIES(builder, CAPABILITIESOffset)
            addDEPENDENCIES(builder, DEPENDENCIESOffset)
            addREQUIRED_SCHEMAS(builder, REQUIRED_SCHEMASOffset)
            addENTRY_FUNCTIONS(builder, ENTRY_FUNCTIONSOffset)
            addWASM_CID(builder, WASM_CIDOffset)
            addWASM_HASH(builder, WASM_HASHOffset)
            addABI_VERSION(builder, ABI_VERSION)
            addDESCRIPTION(builder, DESCRIPTIONOffset)
            addVERSION(builder, VERSIONOffset)
            addNAME(builder, NAMEOffset)
            addPLUGIN_ID(builder, PLUGIN_IDOffset)
            addENCRYPTED(builder, ENCRYPTED)
            addPLUGIN_TYPE(builder, PLUGIN_TYPE)
            return endPLG(builder)
        }
        fun startPLG(builder: FlatBufferBuilder) = builder.startTable(23)
        fun addPLUGIN_ID(builder: FlatBufferBuilder, PLUGIN_ID: Int) = builder.addOffset(0, PLUGIN_ID, 0)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(1, NAME, 0)
        fun addVERSION(builder: FlatBufferBuilder, VERSION: Int) = builder.addOffset(2, VERSION, 0)
        fun addDESCRIPTION(builder: FlatBufferBuilder, DESCRIPTION: Int) = builder.addOffset(3, DESCRIPTION, 0)
        fun addPLUGIN_TYPE(builder: FlatBufferBuilder, PLUGIN_TYPE: Byte) = builder.addByte(4, PLUGIN_TYPE, 0)
        fun addABI_VERSION(builder: FlatBufferBuilder, ABI_VERSION: UInt) = builder.addInt(5, ABI_VERSION.toInt(), 1)
        fun addWASM_HASH(builder: FlatBufferBuilder, WASM_HASH: Int) = builder.addOffset(6, WASM_HASH, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createWasmHashVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startWasmHashVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addWASM_SIZE(builder: FlatBufferBuilder, WASM_SIZE: ULong) = builder.addLong(7, WASM_SIZE.toLong(), 0)
        fun addWASM_CID(builder: FlatBufferBuilder, WASM_CID: Int) = builder.addOffset(8, WASM_CID, 0)
        fun addENTRY_FUNCTIONS(builder: FlatBufferBuilder, ENTRY_FUNCTIONS: Int) = builder.addOffset(9, ENTRY_FUNCTIONS, 0)
        fun createEntryFunctionsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEntryFunctionsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addREQUIRED_SCHEMAS(builder: FlatBufferBuilder, REQUIRED_SCHEMAS: Int) = builder.addOffset(10, REQUIRED_SCHEMAS, 0)
        fun createRequiredSchemasVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startRequiredSchemasVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addDEPENDENCIES(builder: FlatBufferBuilder, DEPENDENCIES: Int) = builder.addOffset(11, DEPENDENCIES, 0)
        fun createDependenciesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startDependenciesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCAPABILITIES(builder: FlatBufferBuilder, CAPABILITIES: Int) = builder.addOffset(12, CAPABILITIES, 0)
        fun createCapabilitiesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startCapabilitiesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addPROVIDER_PEER_ID(builder: FlatBufferBuilder, PROVIDER_PEER_ID: Int) = builder.addOffset(13, PROVIDER_PEER_ID, 0)
        fun addPROVIDER_EPM_CID(builder: FlatBufferBuilder, PROVIDER_EPM_CID: Int) = builder.addOffset(14, PROVIDER_EPM_CID, 0)
        fun addENCRYPTED(builder: FlatBufferBuilder, ENCRYPTED: Boolean) = builder.addBoolean(15, ENCRYPTED, true)
        fun addMIN_PERMISSIONS(builder: FlatBufferBuilder, MIN_PERMISSIONS: Int) = builder.addOffset(16, MIN_PERMISSIONS, 0)
        fun createMinPermissionsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMinPermissionsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCREATED_AT(builder: FlatBufferBuilder, CREATED_AT: ULong) = builder.addLong(17, CREATED_AT.toLong(), 0)
        fun addUPDATED_AT(builder: FlatBufferBuilder, UPDATED_AT: ULong) = builder.addLong(18, UPDATED_AT.toLong(), 0)
        fun addDOCUMENTATION_URL(builder: FlatBufferBuilder, DOCUMENTATION_URL: Int) = builder.addOffset(19, DOCUMENTATION_URL, 0)
        fun addICON_URL(builder: FlatBufferBuilder, ICON_URL: Int) = builder.addOffset(20, ICON_URL, 0)
        fun addLICENSE(builder: FlatBufferBuilder, LICENSE: Int) = builder.addOffset(21, LICENSE, 0)
        fun addSIGNATURE(builder: FlatBufferBuilder, SIGNATURE: Int) = builder.addOffset(22, SIGNATURE, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createSignatureVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startSignatureVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endPLG(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 4)
                builder.required(o, 6)
                builder.required(o, 8)
            return o
        }
        fun finishPLGBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PLG")
        fun finishSizePrefixedPLGBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PLG")
    }
}
