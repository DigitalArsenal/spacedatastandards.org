// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Sensor Tasking Plan
 */
@Suppress("unused")
class sensorPlan : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : sensorPlan {
        __init(_i, _bb)
        return this
    }
    /**
     * Plan start time (ISO 8601)
     */
    val START_TIME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val START_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun START_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Plan end time (ISO 8601)
     */
    val END_TIME : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val END_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun END_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Target satellite number or designator
     */
    val TARGET_ID : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TARGET_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun TARGET_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Priority level (1=highest)
     */
    val PRIORITY : UByte
        get() {
            val o = __offset(10)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    /**
     * Requested observation mode
     */
    val MODE : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MODEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun MODEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Minimum elevation in degrees
     */
    val MIN_ELEVATION : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum range in km
     */
    val MAX_RANGE : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAssensorPlan(_bb: ByteBuffer): sensorPlan = getRootAssensorPlan(_bb, sensorPlan())
        fun getRootAssensorPlan(_bb: ByteBuffer, obj: sensorPlan): sensorPlan {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createsensorPlan(builder: FlatBufferBuilder, START_TIMEOffset: Int, END_TIMEOffset: Int, TARGET_IDOffset: Int, PRIORITY: UByte, MODEOffset: Int, MIN_ELEVATION: Double, MAX_RANGE: Double) : Int {
            builder.startTable(7)
            addMAX_RANGE(builder, MAX_RANGE)
            addMIN_ELEVATION(builder, MIN_ELEVATION)
            addMODE(builder, MODEOffset)
            addTARGET_ID(builder, TARGET_IDOffset)
            addEND_TIME(builder, END_TIMEOffset)
            addSTART_TIME(builder, START_TIMEOffset)
            addPRIORITY(builder, PRIORITY)
            return endsensorPlan(builder)
        }
        fun startsensorPlan(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addSTART_TIME(builder: FlatBufferBuilder, START_TIME: Int) = builder.addOffset(0, START_TIME, 0)
        fun addEND_TIME(builder: FlatBufferBuilder, END_TIME: Int) = builder.addOffset(1, END_TIME, 0)
        fun addTARGET_ID(builder: FlatBufferBuilder, TARGET_ID: Int) = builder.addOffset(2, TARGET_ID, 0)
        fun addPRIORITY(builder: FlatBufferBuilder, PRIORITY: UByte) = builder.addByte(3, PRIORITY.toByte(), 0)
        fun addMODE(builder: FlatBufferBuilder, MODE: Int) = builder.addOffset(4, MODE, 0)
        fun addMIN_ELEVATION(builder: FlatBufferBuilder, MIN_ELEVATION: Double) = builder.addDouble(5, MIN_ELEVATION, 0.0)
        fun addMAX_RANGE(builder: FlatBufferBuilder, MAX_RANGE: Double) = builder.addDouble(6, MAX_RANGE, 0.0)
        fun endsensorPlan(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
