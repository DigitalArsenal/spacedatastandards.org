// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Electro-Optical Observation
 */
@Suppress("unused")
class EOO : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : EOO {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record.
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     */
    val CLASSIFICATION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLASSIFICATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun CLASSIFICATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
     */
    val OB_TIME : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OB_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun OB_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Correlation score of the observation when compared to a known orbit state.
     */
    val CORR_QUALITY : Float
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Server will auto-populate with SAT_NO if available.
     */
    val ID_ON_ORBIT : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_ON_ORBITAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun ID_ON_ORBITInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Unique ID of the sensor. Must have a corresponding sensor record on the server.
     */
    val SENSOR_ID : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SENSOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun SENSOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Accepted Collection Method
     */
    val COLLECT_METHOD : Byte
        get() {
            val o = __offset(16)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
     */
    val NORAD_CAT_ID : Int
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Identifier for the collectRequest message if the collection was in response to tasking.
     */
    val TASK_ID : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TASK_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun TASK_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Optional identifier to track a transaction.
     */
    val TRANSACTION_ID : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRANSACTION_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun TRANSACTION_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Identifier of the track to which this observation belongs, if applicable.
     */
    val TRACK_ID : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TRACK_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun TRACK_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
     */
    val OB_POSITION : Byte
        get() {
            val o = __offset(26)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Provider maintained ID. May not be consistent with 18SDS SAT_NO.
     */
    val ORIG_OBJECT_ID : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun ORIG_OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Sensor ID.
     */
    val ORIG_SENSOR_ID : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_SENSOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun ORIG_SENSOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Required if correlation is attempted. Indicates whether correlation succeeded.
     */
    val UCT : Boolean
        get() {
            val o = __offset(32)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Line of sight azimuth angle in degrees and topocentric frame.
     */
    val AZIMUTH : Float
        get() {
            val o = __offset(34)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight azimuth angle, in degrees.
     */
    val AZIMUTH_UNC : Float
        get() {
            val o = __offset(36)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor line of sight azimuth angle bias in degrees.
     */
    val AZIMUTH_BIAS : Float
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Rate of change of the line of sight azimuth in degrees per second.
     */
    val AZIMUTH_RATE : Float
        get() {
            val o = __offset(40)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Line of sight elevation in degrees and topocentric frame.
     */
    val ELEVATION : Float
        get() {
            val o = __offset(42)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight elevation angle, in degrees.
     */
    val ELEVATION_UNC : Float
        get() {
            val o = __offset(44)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor line of sight elevation bias in degrees.
     */
    val ELEVATION_BIAS : Float
        get() {
            val o = __offset(46)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Rate of change of the line of sight elevation in degrees per second.
     */
    val ELEVATION_RATE : Float
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Line of sight range in km. Reported value should include all applicable corrections.
     */
    val RANGE : Float
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight range, in km.
     */
    val RANGE_UNC : Float
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor line of sight range bias in km.
     */
    val RANGE_BIAS : Float
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Range rate in km/s. Reported value should include all applicable corrections.
     */
    val RANGE_RATE : Float
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight range rate, in km/sec.
     */
    val RANGE_RATE_UNC : Float
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Right ascension in degrees. Required metric reporting field for EO observations.
     */
    val RA : Float
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Line of sight right ascension rate of change, in degrees/sec.
     */
    val RA_RATE : Float
        get() {
            val o = __offset(62)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight right ascension angle, in degrees.
     */
    val RA_UNC : Float
        get() {
            val o = __offset(64)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor line of sight right ascension bias in degrees.
     */
    val RA_BIAS : Float
        get() {
            val o = __offset(66)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Declination in degrees. Required metric reporting field for EO observations.
     */
    val DECLINATION : Float
        get() {
            val o = __offset(68)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Line of sight declination rate of change, in degrees/sec.
     */
    val DECLINATION_RATE : Float
        get() {
            val o = __offset(70)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line of sight declination angle, in degrees.
     */
    val DECLINATION_UNC : Float
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor line of sight declination angle bias in degrees.
     */
    val DECLINATION_BIAS : Float
        get() {
            val o = __offset(74)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    val LOSX : Float
        get() {
            val o = __offset(76)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    val LOSY : Float
        get() {
            val o = __offset(78)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    val LOSZ : Float
        get() {
            val o = __offset(80)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * One sigma uncertainty in the line-of-sight direction vector components.
     */
    val LOS_UNC : Float
        get() {
            val o = __offset(82)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * X-component of the velocity vector along the line of sight, in km/s.
     */
    val LOSXVEL : Float
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Y-component of the velocity vector along the line of sight, in km/s.
     */
    val LOSYVEL : Float
        get() {
            val o = __offset(86)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Z-component of the velocity vector along the line of sight, in km/s.
     */
    val LOSZVEL : Float
        get() {
            val o = __offset(88)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * WGS-84 latitude in decimal degrees at the time of the observation.
     */
    val SENLAT : Float
        get() {
            val o = __offset(90)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * WGS-84 longitude in decimal degrees at the time of the observation.
     */
    val SENLON : Float
        get() {
            val o = __offset(92)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
     */
    val SENALT : Float
        get() {
            val o = __offset(94)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Cartesian X position in km at the time of the observation.
     */
    val SENX : Float
        get() {
            val o = __offset(96)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Cartesian Y position in km at the time of the observation.
     */
    val SENY : Float
        get() {
            val o = __offset(98)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Cartesian Z position in km at the time of the observation.
     */
    val SENZ : Float
        get() {
            val o = __offset(100)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Total number of satellites in the field of view.
     */
    val FOV_COUNT : Int
        get() {
            val o = __offset(102)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Number of uncorrelated satellites in the field of view (JCO).
     */
    val FOV_COUNT_UCTS : Int
        get() {
            val o = __offset(104)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
     * the exposure duration should be the total integration time. This field is highly recommended / required if the 
     * observations are going to be used for photometric processing.
     */
    val EXP_DURATION : Float
        get() {
            val o = __offset(106)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
     */
    val ZEROPTD : Float
        get() {
            val o = __offset(108)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Net object signature = counts / EXP_DURATION.
     */
    val NET_OBJ_SIG : Float
        get() {
            val o = __offset(110)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
     */
    val NET_OBJ_SIG_UNC : Float
        get() {
            val o = __offset(112)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Measure of observed brightness calibrated against the Gaia G-band.
     */
    val MAG : Float
        get() {
            val o = __offset(114)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Uncertainty of the observed brightness.
     */
    val MAG_UNC : Float
        get() {
            val o = __offset(116)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * [Definition needed].
     */
    val MAG_NORM_RANGE : Float
        get() {
            val o = __offset(118)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
     * and corresponding viewing geometry. It must NOT be computed from the orbit state.
     */
    val GEOLAT : Float
        get() {
            val o = __offset(120)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
     * and viewing geometry. It must NOT be computed from the orbit state.
     */
    val GEOLON : Float
        get() {
            val o = __offset(122)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
     */
    val GEOALT : Float
        get() {
            val o = __offset(124)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
     */
    val GEORANGE : Float
        get() {
            val o = __offset(126)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
     * empty part of the night sky.
     */
    val SKY_BKGRND : Float
        get() {
            val o = __offset(128)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
     * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
     * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
     * object and the observer.
     */
    val PRIMARY_EXTINCTION : Float
        get() {
            val o = __offset(130)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Primary Extinction Coefficient Uncertainty, in Magnitudes.
     */
    val PRIMARY_EXTINCTION_UNC : Float
        get() {
            val o = __offset(132)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
     * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
     */
    val SOLAR_PHASE_ANGLE : Float
        get() {
            val o = __offset(134)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
     * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
     * and positive when opening (after the opposition).
     */
    val SOLAR_EQ_PHASE_ANGLE : Float
        get() {
            val o = __offset(136)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Angle from the sun to the equatorial plane.
     */
    val SOLAR_DEC_ANGLE : Float
        get() {
            val o = __offset(138)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Shutter delay in seconds.
     */
    val SHUTTER_DELAY : Float
        get() {
            val o = __offset(140)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Sensor timing bias in seconds.
     */
    val TIMING_BIAS : Float
        get() {
            val o = __offset(142)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
     */
    val RAW_FILE_URI : String?
        get() {
            val o = __offset(144)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val RAW_FILE_URIAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(144, 1)
    fun RAW_FILE_URIInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 144, 1)
    /**
     * Intensity of the target for IR observations, in kw/sr/em.
     */
    val INTENSITY : Float
        get() {
            val o = __offset(146)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Background intensity for IR observations, in kw/sr/um.
     */
    val BG_INTENSITY : Float
        get() {
            val o = __offset(148)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * Optional source-provided and searchable metadata or descriptor of the data.
     */
    val DESCRIPTOR : String?
        get() {
            val o = __offset(150)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DESCRIPTORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(150, 1)
    fun DESCRIPTORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 150, 1)
    /**
     * Source of the data.
     */
    val SOURCE : String?
        get() {
            val o = __offset(152)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOURCEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(152, 1)
    fun SOURCEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 152, 1)
    /**
     * Originating system or organization which produced the data, if different from the source.
     * The origin may be different than the source if the source was a mediating system which forwarded 
     * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
     */
    val ORIGIN : String?
        get() {
            val o = __offset(154)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIGINAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(154, 1)
    fun ORIGINInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 154, 1)
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
     */
    val DATA_MODE : Byte
        get() {
            val o = __offset(156)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Time the row was created in the database, auto-populated by the system.
     */
    val CREATED_AT : String?
        get() {
            val o = __offset(158)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CREATED_ATAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(158, 1)
    fun CREATED_ATInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 158, 1)
    /**
     * Application user who created the row in the database, auto-populated by the system.
     */
    val CREATED_BY : String?
        get() {
            val o = __offset(160)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CREATED_BYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(160, 1)
    fun CREATED_BYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 160, 1)
    /**
     * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
     */
    val REFERENCE_FRAME : Byte
        get() {
            val o = __offset(162)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
     * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
     * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
     */
    val SEN_REFERENCE_FRAME : Byte
        get() {
            val o = __offset(164)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
     */
    val UMBRA : Boolean
        get() {
            val o = __offset(166)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
     * This field is highly recommended if the observations will be used for photometric processing.
     */
    val PENUMBRA : Boolean
        get() {
            val o = __offset(168)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The originating source network on which this record was created, auto-populated by the system.
     */
    val ORIG_NETWORK : String?
        get() {
            val o = __offset(170)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_NETWORKAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(170, 1)
    fun ORIG_NETWORKInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 170, 1)
    /**
     * The source from which this record was received.
     */
    val SOURCE_DL : String?
        get() {
            val o = __offset(172)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOURCE_DLAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(172, 1)
    fun SOURCE_DLInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 172, 1)
    /**
     * Device Type
     */
    val TYPE : Byte
        get() {
            val o = __offset(174)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * True if measured, false if computed. Required if azimuth is reported.
     */
    val AZIMUTH_MEASURED : Boolean
        get() {
            val o = __offset(176)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * True if measured, false if computed. Required if elevation is reported.
     */
    val ELEVATION_MEASURED : Boolean
        get() {
            val o = __offset(178)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * True if measured, false if computed. Required if range is reported.
     */
    val RANGE_MEASURED : Boolean
        get() {
            val o = __offset(180)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * True if measured, false if computed. Required if range-rate is reported.
     */
    val RANGERATE_MEASURED : Boolean
        get() {
            val o = __offset(182)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * True if measured, false if computed. Required if right ascension is reported.
     */
    val RA_MEASURED : Boolean
        get() {
            val o = __offset(184)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * True if measured, false if computed. Required if declination is reported.
     */
    val DECLINATION_MEASURED : Boolean
        get() {
            val o = __offset(186)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsEOO(_bb: ByteBuffer): EOO = getRootAsEOO(_bb, EOO())
        fun getRootAsEOO(_bb: ByteBuffer, obj: EOO): EOO {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun EOOBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$EOO")
        fun createEOO(builder: FlatBufferBuilder, IDOffset: Int, CLASSIFICATIONOffset: Int, OB_TIMEOffset: Int, CORR_QUALITY: Float, ID_ON_ORBITOffset: Int, SENSOR_IDOffset: Int, COLLECT_METHOD: Byte, NORAD_CAT_ID: Int, TASK_IDOffset: Int, TRANSACTION_IDOffset: Int, TRACK_IDOffset: Int, OB_POSITION: Byte, ORIG_OBJECT_IDOffset: Int, ORIG_SENSOR_IDOffset: Int, UCT: Boolean, AZIMUTH: Float, AZIMUTH_UNC: Float, AZIMUTH_BIAS: Float, AZIMUTH_RATE: Float, ELEVATION: Float, ELEVATION_UNC: Float, ELEVATION_BIAS: Float, ELEVATION_RATE: Float, RANGE: Float, RANGE_UNC: Float, RANGE_BIAS: Float, RANGE_RATE: Float, RANGE_RATE_UNC: Float, RA: Float, RA_RATE: Float, RA_UNC: Float, RA_BIAS: Float, DECLINATION: Float, DECLINATION_RATE: Float, DECLINATION_UNC: Float, DECLINATION_BIAS: Float, LOSX: Float, LOSY: Float, LOSZ: Float, LOS_UNC: Float, LOSXVEL: Float, LOSYVEL: Float, LOSZVEL: Float, SENLAT: Float, SENLON: Float, SENALT: Float, SENX: Float, SENY: Float, SENZ: Float, FOV_COUNT: Int, FOV_COUNT_UCTS: Int, EXP_DURATION: Float, ZEROPTD: Float, NET_OBJ_SIG: Float, NET_OBJ_SIG_UNC: Float, MAG: Float, MAG_UNC: Float, MAG_NORM_RANGE: Float, GEOLAT: Float, GEOLON: Float, GEOALT: Float, GEORANGE: Float, SKY_BKGRND: Float, PRIMARY_EXTINCTION: Float, PRIMARY_EXTINCTION_UNC: Float, SOLAR_PHASE_ANGLE: Float, SOLAR_EQ_PHASE_ANGLE: Float, SOLAR_DEC_ANGLE: Float, SHUTTER_DELAY: Float, TIMING_BIAS: Float, RAW_FILE_URIOffset: Int, INTENSITY: Float, BG_INTENSITY: Float, DESCRIPTOROffset: Int, SOURCEOffset: Int, ORIGINOffset: Int, DATA_MODE: Byte, CREATED_ATOffset: Int, CREATED_BYOffset: Int, REFERENCE_FRAME: Byte, SEN_REFERENCE_FRAME: Byte, UMBRA: Boolean, PENUMBRA: Boolean, ORIG_NETWORKOffset: Int, SOURCE_DLOffset: Int, TYPE: Byte, AZIMUTH_MEASURED: Boolean, ELEVATION_MEASURED: Boolean, RANGE_MEASURED: Boolean, RANGERATE_MEASURED: Boolean, RA_MEASURED: Boolean, DECLINATION_MEASURED: Boolean) : Int {
            builder.startTable(92)
            addSOURCE_DL(builder, SOURCE_DLOffset)
            addORIG_NETWORK(builder, ORIG_NETWORKOffset)
            addCREATED_BY(builder, CREATED_BYOffset)
            addCREATED_AT(builder, CREATED_ATOffset)
            addORIGIN(builder, ORIGINOffset)
            addSOURCE(builder, SOURCEOffset)
            addDESCRIPTOR(builder, DESCRIPTOROffset)
            addBG_INTENSITY(builder, BG_INTENSITY)
            addINTENSITY(builder, INTENSITY)
            addRAW_FILE_URI(builder, RAW_FILE_URIOffset)
            addTIMING_BIAS(builder, TIMING_BIAS)
            addSHUTTER_DELAY(builder, SHUTTER_DELAY)
            addSOLAR_DEC_ANGLE(builder, SOLAR_DEC_ANGLE)
            addSOLAR_EQ_PHASE_ANGLE(builder, SOLAR_EQ_PHASE_ANGLE)
            addSOLAR_PHASE_ANGLE(builder, SOLAR_PHASE_ANGLE)
            addPRIMARY_EXTINCTION_UNC(builder, PRIMARY_EXTINCTION_UNC)
            addPRIMARY_EXTINCTION(builder, PRIMARY_EXTINCTION)
            addSKY_BKGRND(builder, SKY_BKGRND)
            addGEORANGE(builder, GEORANGE)
            addGEOALT(builder, GEOALT)
            addGEOLON(builder, GEOLON)
            addGEOLAT(builder, GEOLAT)
            addMAG_NORM_RANGE(builder, MAG_NORM_RANGE)
            addMAG_UNC(builder, MAG_UNC)
            addMAG(builder, MAG)
            addNET_OBJ_SIG_UNC(builder, NET_OBJ_SIG_UNC)
            addNET_OBJ_SIG(builder, NET_OBJ_SIG)
            addZEROPTD(builder, ZEROPTD)
            addEXP_DURATION(builder, EXP_DURATION)
            addFOV_COUNT_UCTS(builder, FOV_COUNT_UCTS)
            addFOV_COUNT(builder, FOV_COUNT)
            addSENZ(builder, SENZ)
            addSENY(builder, SENY)
            addSENX(builder, SENX)
            addSENALT(builder, SENALT)
            addSENLON(builder, SENLON)
            addSENLAT(builder, SENLAT)
            addLOSZVEL(builder, LOSZVEL)
            addLOSYVEL(builder, LOSYVEL)
            addLOSXVEL(builder, LOSXVEL)
            addLOS_UNC(builder, LOS_UNC)
            addLOSZ(builder, LOSZ)
            addLOSY(builder, LOSY)
            addLOSX(builder, LOSX)
            addDECLINATION_BIAS(builder, DECLINATION_BIAS)
            addDECLINATION_UNC(builder, DECLINATION_UNC)
            addDECLINATION_RATE(builder, DECLINATION_RATE)
            addDECLINATION(builder, DECLINATION)
            addRA_BIAS(builder, RA_BIAS)
            addRA_UNC(builder, RA_UNC)
            addRA_RATE(builder, RA_RATE)
            addRA(builder, RA)
            addRANGE_RATE_UNC(builder, RANGE_RATE_UNC)
            addRANGE_RATE(builder, RANGE_RATE)
            addRANGE_BIAS(builder, RANGE_BIAS)
            addRANGE_UNC(builder, RANGE_UNC)
            addRANGE(builder, RANGE)
            addELEVATION_RATE(builder, ELEVATION_RATE)
            addELEVATION_BIAS(builder, ELEVATION_BIAS)
            addELEVATION_UNC(builder, ELEVATION_UNC)
            addELEVATION(builder, ELEVATION)
            addAZIMUTH_RATE(builder, AZIMUTH_RATE)
            addAZIMUTH_BIAS(builder, AZIMUTH_BIAS)
            addAZIMUTH_UNC(builder, AZIMUTH_UNC)
            addAZIMUTH(builder, AZIMUTH)
            addORIG_SENSOR_ID(builder, ORIG_SENSOR_IDOffset)
            addORIG_OBJECT_ID(builder, ORIG_OBJECT_IDOffset)
            addTRACK_ID(builder, TRACK_IDOffset)
            addTRANSACTION_ID(builder, TRANSACTION_IDOffset)
            addTASK_ID(builder, TASK_IDOffset)
            addNORAD_CAT_ID(builder, NORAD_CAT_ID)
            addSENSOR_ID(builder, SENSOR_IDOffset)
            addID_ON_ORBIT(builder, ID_ON_ORBITOffset)
            addCORR_QUALITY(builder, CORR_QUALITY)
            addOB_TIME(builder, OB_TIMEOffset)
            addCLASSIFICATION(builder, CLASSIFICATIONOffset)
            addID(builder, IDOffset)
            addDECLINATION_MEASURED(builder, DECLINATION_MEASURED)
            addRA_MEASURED(builder, RA_MEASURED)
            addRANGERATE_MEASURED(builder, RANGERATE_MEASURED)
            addRANGE_MEASURED(builder, RANGE_MEASURED)
            addELEVATION_MEASURED(builder, ELEVATION_MEASURED)
            addAZIMUTH_MEASURED(builder, AZIMUTH_MEASURED)
            addTYPE(builder, TYPE)
            addPENUMBRA(builder, PENUMBRA)
            addUMBRA(builder, UMBRA)
            addSEN_REFERENCE_FRAME(builder, SEN_REFERENCE_FRAME)
            addREFERENCE_FRAME(builder, REFERENCE_FRAME)
            addDATA_MODE(builder, DATA_MODE)
            addUCT(builder, UCT)
            addOB_POSITION(builder, OB_POSITION)
            addCOLLECT_METHOD(builder, COLLECT_METHOD)
            return endEOO(builder)
        }
        fun startEOO(builder: FlatBufferBuilder) = builder.startTable(92)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addCLASSIFICATION(builder: FlatBufferBuilder, CLASSIFICATION: Int) = builder.addOffset(1, CLASSIFICATION, 0)
        fun addOB_TIME(builder: FlatBufferBuilder, OB_TIME: Int) = builder.addOffset(2, OB_TIME, 0)
        fun addCORR_QUALITY(builder: FlatBufferBuilder, CORR_QUALITY: Float) = builder.addFloat(3, CORR_QUALITY, 0.0)
        fun addID_ON_ORBIT(builder: FlatBufferBuilder, ID_ON_ORBIT: Int) = builder.addOffset(4, ID_ON_ORBIT, 0)
        fun addSENSOR_ID(builder: FlatBufferBuilder, SENSOR_ID: Int) = builder.addOffset(5, SENSOR_ID, 0)
        fun addCOLLECT_METHOD(builder: FlatBufferBuilder, COLLECT_METHOD: Byte) = builder.addByte(6, COLLECT_METHOD, 0)
        fun addNORAD_CAT_ID(builder: FlatBufferBuilder, NORAD_CAT_ID: Int) = builder.addInt(7, NORAD_CAT_ID, 0)
        fun addTASK_ID(builder: FlatBufferBuilder, TASK_ID: Int) = builder.addOffset(8, TASK_ID, 0)
        fun addTRANSACTION_ID(builder: FlatBufferBuilder, TRANSACTION_ID: Int) = builder.addOffset(9, TRANSACTION_ID, 0)
        fun addTRACK_ID(builder: FlatBufferBuilder, TRACK_ID: Int) = builder.addOffset(10, TRACK_ID, 0)
        fun addOB_POSITION(builder: FlatBufferBuilder, OB_POSITION: Byte) = builder.addByte(11, OB_POSITION, 0)
        fun addORIG_OBJECT_ID(builder: FlatBufferBuilder, ORIG_OBJECT_ID: Int) = builder.addOffset(12, ORIG_OBJECT_ID, 0)
        fun addORIG_SENSOR_ID(builder: FlatBufferBuilder, ORIG_SENSOR_ID: Int) = builder.addOffset(13, ORIG_SENSOR_ID, 0)
        fun addUCT(builder: FlatBufferBuilder, UCT: Boolean) = builder.addBoolean(14, UCT, false)
        fun addAZIMUTH(builder: FlatBufferBuilder, AZIMUTH: Float) = builder.addFloat(15, AZIMUTH, 0.0)
        fun addAZIMUTH_UNC(builder: FlatBufferBuilder, AZIMUTH_UNC: Float) = builder.addFloat(16, AZIMUTH_UNC, 0.0)
        fun addAZIMUTH_BIAS(builder: FlatBufferBuilder, AZIMUTH_BIAS: Float) = builder.addFloat(17, AZIMUTH_BIAS, 0.0)
        fun addAZIMUTH_RATE(builder: FlatBufferBuilder, AZIMUTH_RATE: Float) = builder.addFloat(18, AZIMUTH_RATE, 0.0)
        fun addELEVATION(builder: FlatBufferBuilder, ELEVATION: Float) = builder.addFloat(19, ELEVATION, 0.0)
        fun addELEVATION_UNC(builder: FlatBufferBuilder, ELEVATION_UNC: Float) = builder.addFloat(20, ELEVATION_UNC, 0.0)
        fun addELEVATION_BIAS(builder: FlatBufferBuilder, ELEVATION_BIAS: Float) = builder.addFloat(21, ELEVATION_BIAS, 0.0)
        fun addELEVATION_RATE(builder: FlatBufferBuilder, ELEVATION_RATE: Float) = builder.addFloat(22, ELEVATION_RATE, 0.0)
        fun addRANGE(builder: FlatBufferBuilder, RANGE: Float) = builder.addFloat(23, RANGE, 0.0)
        fun addRANGE_UNC(builder: FlatBufferBuilder, RANGE_UNC: Float) = builder.addFloat(24, RANGE_UNC, 0.0)
        fun addRANGE_BIAS(builder: FlatBufferBuilder, RANGE_BIAS: Float) = builder.addFloat(25, RANGE_BIAS, 0.0)
        fun addRANGE_RATE(builder: FlatBufferBuilder, RANGE_RATE: Float) = builder.addFloat(26, RANGE_RATE, 0.0)
        fun addRANGE_RATE_UNC(builder: FlatBufferBuilder, RANGE_RATE_UNC: Float) = builder.addFloat(27, RANGE_RATE_UNC, 0.0)
        fun addRA(builder: FlatBufferBuilder, RA: Float) = builder.addFloat(28, RA, 0.0)
        fun addRA_RATE(builder: FlatBufferBuilder, RA_RATE: Float) = builder.addFloat(29, RA_RATE, 0.0)
        fun addRA_UNC(builder: FlatBufferBuilder, RA_UNC: Float) = builder.addFloat(30, RA_UNC, 0.0)
        fun addRA_BIAS(builder: FlatBufferBuilder, RA_BIAS: Float) = builder.addFloat(31, RA_BIAS, 0.0)
        fun addDECLINATION(builder: FlatBufferBuilder, DECLINATION: Float) = builder.addFloat(32, DECLINATION, 0.0)
        fun addDECLINATION_RATE(builder: FlatBufferBuilder, DECLINATION_RATE: Float) = builder.addFloat(33, DECLINATION_RATE, 0.0)
        fun addDECLINATION_UNC(builder: FlatBufferBuilder, DECLINATION_UNC: Float) = builder.addFloat(34, DECLINATION_UNC, 0.0)
        fun addDECLINATION_BIAS(builder: FlatBufferBuilder, DECLINATION_BIAS: Float) = builder.addFloat(35, DECLINATION_BIAS, 0.0)
        fun addLOSX(builder: FlatBufferBuilder, LOSX: Float) = builder.addFloat(36, LOSX, 0.0)
        fun addLOSY(builder: FlatBufferBuilder, LOSY: Float) = builder.addFloat(37, LOSY, 0.0)
        fun addLOSZ(builder: FlatBufferBuilder, LOSZ: Float) = builder.addFloat(38, LOSZ, 0.0)
        fun addLOS_UNC(builder: FlatBufferBuilder, LOS_UNC: Float) = builder.addFloat(39, LOS_UNC, 0.0)
        fun addLOSXVEL(builder: FlatBufferBuilder, LOSXVEL: Float) = builder.addFloat(40, LOSXVEL, 0.0)
        fun addLOSYVEL(builder: FlatBufferBuilder, LOSYVEL: Float) = builder.addFloat(41, LOSYVEL, 0.0)
        fun addLOSZVEL(builder: FlatBufferBuilder, LOSZVEL: Float) = builder.addFloat(42, LOSZVEL, 0.0)
        fun addSENLAT(builder: FlatBufferBuilder, SENLAT: Float) = builder.addFloat(43, SENLAT, 0.0)
        fun addSENLON(builder: FlatBufferBuilder, SENLON: Float) = builder.addFloat(44, SENLON, 0.0)
        fun addSENALT(builder: FlatBufferBuilder, SENALT: Float) = builder.addFloat(45, SENALT, 0.0)
        fun addSENX(builder: FlatBufferBuilder, SENX: Float) = builder.addFloat(46, SENX, 0.0)
        fun addSENY(builder: FlatBufferBuilder, SENY: Float) = builder.addFloat(47, SENY, 0.0)
        fun addSENZ(builder: FlatBufferBuilder, SENZ: Float) = builder.addFloat(48, SENZ, 0.0)
        fun addFOV_COUNT(builder: FlatBufferBuilder, FOV_COUNT: Int) = builder.addInt(49, FOV_COUNT, 0)
        fun addFOV_COUNT_UCTS(builder: FlatBufferBuilder, FOV_COUNT_UCTS: Int) = builder.addInt(50, FOV_COUNT_UCTS, 0)
        fun addEXP_DURATION(builder: FlatBufferBuilder, EXP_DURATION: Float) = builder.addFloat(51, EXP_DURATION, 0.0)
        fun addZEROPTD(builder: FlatBufferBuilder, ZEROPTD: Float) = builder.addFloat(52, ZEROPTD, 0.0)
        fun addNET_OBJ_SIG(builder: FlatBufferBuilder, NET_OBJ_SIG: Float) = builder.addFloat(53, NET_OBJ_SIG, 0.0)
        fun addNET_OBJ_SIG_UNC(builder: FlatBufferBuilder, NET_OBJ_SIG_UNC: Float) = builder.addFloat(54, NET_OBJ_SIG_UNC, 0.0)
        fun addMAG(builder: FlatBufferBuilder, MAG: Float) = builder.addFloat(55, MAG, 0.0)
        fun addMAG_UNC(builder: FlatBufferBuilder, MAG_UNC: Float) = builder.addFloat(56, MAG_UNC, 0.0)
        fun addMAG_NORM_RANGE(builder: FlatBufferBuilder, MAG_NORM_RANGE: Float) = builder.addFloat(57, MAG_NORM_RANGE, 0.0)
        fun addGEOLAT(builder: FlatBufferBuilder, GEOLAT: Float) = builder.addFloat(58, GEOLAT, 0.0)
        fun addGEOLON(builder: FlatBufferBuilder, GEOLON: Float) = builder.addFloat(59, GEOLON, 0.0)
        fun addGEOALT(builder: FlatBufferBuilder, GEOALT: Float) = builder.addFloat(60, GEOALT, 0.0)
        fun addGEORANGE(builder: FlatBufferBuilder, GEORANGE: Float) = builder.addFloat(61, GEORANGE, 0.0)
        fun addSKY_BKGRND(builder: FlatBufferBuilder, SKY_BKGRND: Float) = builder.addFloat(62, SKY_BKGRND, 0.0)
        fun addPRIMARY_EXTINCTION(builder: FlatBufferBuilder, PRIMARY_EXTINCTION: Float) = builder.addFloat(63, PRIMARY_EXTINCTION, 0.0)
        fun addPRIMARY_EXTINCTION_UNC(builder: FlatBufferBuilder, PRIMARY_EXTINCTION_UNC: Float) = builder.addFloat(64, PRIMARY_EXTINCTION_UNC, 0.0)
        fun addSOLAR_PHASE_ANGLE(builder: FlatBufferBuilder, SOLAR_PHASE_ANGLE: Float) = builder.addFloat(65, SOLAR_PHASE_ANGLE, 0.0)
        fun addSOLAR_EQ_PHASE_ANGLE(builder: FlatBufferBuilder, SOLAR_EQ_PHASE_ANGLE: Float) = builder.addFloat(66, SOLAR_EQ_PHASE_ANGLE, 0.0)
        fun addSOLAR_DEC_ANGLE(builder: FlatBufferBuilder, SOLAR_DEC_ANGLE: Float) = builder.addFloat(67, SOLAR_DEC_ANGLE, 0.0)
        fun addSHUTTER_DELAY(builder: FlatBufferBuilder, SHUTTER_DELAY: Float) = builder.addFloat(68, SHUTTER_DELAY, 0.0)
        fun addTIMING_BIAS(builder: FlatBufferBuilder, TIMING_BIAS: Float) = builder.addFloat(69, TIMING_BIAS, 0.0)
        fun addRAW_FILE_URI(builder: FlatBufferBuilder, RAW_FILE_URI: Int) = builder.addOffset(70, RAW_FILE_URI, 0)
        fun addINTENSITY(builder: FlatBufferBuilder, INTENSITY: Float) = builder.addFloat(71, INTENSITY, 0.0)
        fun addBG_INTENSITY(builder: FlatBufferBuilder, BG_INTENSITY: Float) = builder.addFloat(72, BG_INTENSITY, 0.0)
        fun addDESCRIPTOR(builder: FlatBufferBuilder, DESCRIPTOR: Int) = builder.addOffset(73, DESCRIPTOR, 0)
        fun addSOURCE(builder: FlatBufferBuilder, SOURCE: Int) = builder.addOffset(74, SOURCE, 0)
        fun addORIGIN(builder: FlatBufferBuilder, ORIGIN: Int) = builder.addOffset(75, ORIGIN, 0)
        fun addDATA_MODE(builder: FlatBufferBuilder, DATA_MODE: Byte) = builder.addByte(76, DATA_MODE, 0)
        fun addCREATED_AT(builder: FlatBufferBuilder, CREATED_AT: Int) = builder.addOffset(77, CREATED_AT, 0)
        fun addCREATED_BY(builder: FlatBufferBuilder, CREATED_BY: Int) = builder.addOffset(78, CREATED_BY, 0)
        fun addREFERENCE_FRAME(builder: FlatBufferBuilder, REFERENCE_FRAME: Byte) = builder.addByte(79, REFERENCE_FRAME, 0)
        fun addSEN_REFERENCE_FRAME(builder: FlatBufferBuilder, SEN_REFERENCE_FRAME: Byte) = builder.addByte(80, SEN_REFERENCE_FRAME, 0)
        fun addUMBRA(builder: FlatBufferBuilder, UMBRA: Boolean) = builder.addBoolean(81, UMBRA, false)
        fun addPENUMBRA(builder: FlatBufferBuilder, PENUMBRA: Boolean) = builder.addBoolean(82, PENUMBRA, false)
        fun addORIG_NETWORK(builder: FlatBufferBuilder, ORIG_NETWORK: Int) = builder.addOffset(83, ORIG_NETWORK, 0)
        fun addSOURCE_DL(builder: FlatBufferBuilder, SOURCE_DL: Int) = builder.addOffset(84, SOURCE_DL, 0)
        fun addTYPE(builder: FlatBufferBuilder, TYPE: Byte) = builder.addByte(85, TYPE, 0)
        fun addAZIMUTH_MEASURED(builder: FlatBufferBuilder, AZIMUTH_MEASURED: Boolean) = builder.addBoolean(86, AZIMUTH_MEASURED, false)
        fun addELEVATION_MEASURED(builder: FlatBufferBuilder, ELEVATION_MEASURED: Boolean) = builder.addBoolean(87, ELEVATION_MEASURED, false)
        fun addRANGE_MEASURED(builder: FlatBufferBuilder, RANGE_MEASURED: Boolean) = builder.addBoolean(88, RANGE_MEASURED, false)
        fun addRANGERATE_MEASURED(builder: FlatBufferBuilder, RANGERATE_MEASURED: Boolean) = builder.addBoolean(89, RANGERATE_MEASURED, false)
        fun addRA_MEASURED(builder: FlatBufferBuilder, RA_MEASURED: Boolean) = builder.addBoolean(90, RA_MEASURED, false)
        fun addDECLINATION_MEASURED(builder: FlatBufferBuilder, DECLINATION_MEASURED: Boolean) = builder.addBoolean(91, DECLINATION_MEASURED, false)
        fun endEOO(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishEOOBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$EOO")
        fun finishSizePrefixedEOOBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$EOO")
    }
}
