// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Custom algorithm definition
 */
@Suppress("unused")
class CustomAlgorithm : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CustomAlgorithm {
        __init(_i, _bb)
        return this
    }
    /**
     * Algorithm name
     */
    val NAME : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Short description
     */
    val SHORT_DESCRIPTION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SHORT_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun SHORT_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Long description
     */
    val LONG_DESCRIPTION : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LONG_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun LONG_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Programming language
     */
    val LANGUAGE : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LANGUAGEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun LANGUAGEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Algorithm text/code
     */
    val ALGORITHM_TEXT : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ALGORITHM_TEXTAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun ALGORITHM_TEXTInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * External algorithm reference
     */
    val EXTERNAL_ALGORITHM_REF : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EXTERNAL_ALGORITHM_REFAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun EXTERNAL_ALGORITHM_REFInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * Input bindings
     */
    fun INPUTS(j: Int) : AlgorithmInput? = INPUTS(AlgorithmInput(), j)
    fun INPUTS(obj: AlgorithmInput, j: Int) : AlgorithmInput? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val INPUTSLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Output bindings
     */
    fun OUTPUTS(j: Int) : AlgorithmOutput? = OUTPUTS(AlgorithmOutput(), j)
    fun OUTPUTS(obj: AlgorithmOutput, j: Int) : AlgorithmOutput? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val OUTPUTSLength : Int
        get() {
            val o = __offset(18); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Trigger conditions
     */
    fun TRIGGERS(j: Int) : AlgorithmTrigger? = TRIGGERS(AlgorithmTrigger(), j)
    fun TRIGGERS(obj: AlgorithmTrigger, j: Int) : AlgorithmTrigger? {
        val o = __offset(20)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val TRIGGERSLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCustomAlgorithm(_bb: ByteBuffer): CustomAlgorithm = getRootAsCustomAlgorithm(_bb, CustomAlgorithm())
        fun getRootAsCustomAlgorithm(_bb: ByteBuffer, obj: CustomAlgorithm): CustomAlgorithm {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createCustomAlgorithm(builder: FlatBufferBuilder, NAMEOffset: Int, SHORT_DESCRIPTIONOffset: Int, LONG_DESCRIPTIONOffset: Int, LANGUAGEOffset: Int, ALGORITHM_TEXTOffset: Int, EXTERNAL_ALGORITHM_REFOffset: Int, INPUTSOffset: Int, OUTPUTSOffset: Int, TRIGGERSOffset: Int) : Int {
            builder.startTable(9)
            addTRIGGERS(builder, TRIGGERSOffset)
            addOUTPUTS(builder, OUTPUTSOffset)
            addINPUTS(builder, INPUTSOffset)
            addEXTERNAL_ALGORITHM_REF(builder, EXTERNAL_ALGORITHM_REFOffset)
            addALGORITHM_TEXT(builder, ALGORITHM_TEXTOffset)
            addLANGUAGE(builder, LANGUAGEOffset)
            addLONG_DESCRIPTION(builder, LONG_DESCRIPTIONOffset)
            addSHORT_DESCRIPTION(builder, SHORT_DESCRIPTIONOffset)
            addNAME(builder, NAMEOffset)
            return endCustomAlgorithm(builder)
        }
        fun startCustomAlgorithm(builder: FlatBufferBuilder) = builder.startTable(9)
        fun addNAME(builder: FlatBufferBuilder, NAME: Int) = builder.addOffset(0, NAME, 0)
        fun addSHORT_DESCRIPTION(builder: FlatBufferBuilder, SHORT_DESCRIPTION: Int) = builder.addOffset(1, SHORT_DESCRIPTION, 0)
        fun addLONG_DESCRIPTION(builder: FlatBufferBuilder, LONG_DESCRIPTION: Int) = builder.addOffset(2, LONG_DESCRIPTION, 0)
        fun addLANGUAGE(builder: FlatBufferBuilder, LANGUAGE: Int) = builder.addOffset(3, LANGUAGE, 0)
        fun addALGORITHM_TEXT(builder: FlatBufferBuilder, ALGORITHM_TEXT: Int) = builder.addOffset(4, ALGORITHM_TEXT, 0)
        fun addEXTERNAL_ALGORITHM_REF(builder: FlatBufferBuilder, EXTERNAL_ALGORITHM_REF: Int) = builder.addOffset(5, EXTERNAL_ALGORITHM_REF, 0)
        fun addINPUTS(builder: FlatBufferBuilder, INPUTS: Int) = builder.addOffset(6, INPUTS, 0)
        fun createInputsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startInputsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOUTPUTS(builder: FlatBufferBuilder, OUTPUTS: Int) = builder.addOffset(7, OUTPUTS, 0)
        fun createOutputsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startOutputsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTRIGGERS(builder: FlatBufferBuilder, TRIGGERS: Int) = builder.addOffset(8, TRIGGERS, 0)
        fun createTriggersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTriggersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endCustomAlgorithm(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
