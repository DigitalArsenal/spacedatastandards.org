// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Collection of argument types
 */
@Suppress("unused")
class ArgumentTypeSet : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : ArgumentTypeSet {
        __init(_i, _bb)
        return this
    }
    /**
     * Integer argument types
     */
    fun INTEGER_TYPES(j: Int) : IntegerArgumentType? = INTEGER_TYPES(IntegerArgumentType(), j)
    fun INTEGER_TYPES(obj: IntegerArgumentType, j: Int) : IntegerArgumentType? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val INTEGER_TYPESLength : Int
        get() {
            val o = __offset(4); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Float argument types
     */
    fun FLOAT_TYPES(j: Int) : FloatArgumentType? = FLOAT_TYPES(FloatArgumentType(), j)
    fun FLOAT_TYPES(obj: FloatArgumentType, j: Int) : FloatArgumentType? {
        val o = __offset(6)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val FLOAT_TYPESLength : Int
        get() {
            val o = __offset(6); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * String argument types
     */
    fun STRING_TYPES(j: Int) : StringArgumentType? = STRING_TYPES(StringArgumentType(), j)
    fun STRING_TYPES(obj: StringArgumentType, j: Int) : StringArgumentType? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val STRING_TYPESLength : Int
        get() {
            val o = __offset(8); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Boolean argument types
     */
    fun BOOLEAN_TYPES(j: Int) : BooleanArgumentType? = BOOLEAN_TYPES(BooleanArgumentType(), j)
    fun BOOLEAN_TYPES(obj: BooleanArgumentType, j: Int) : BooleanArgumentType? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val BOOLEAN_TYPESLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Enumerated argument types
     */
    fun ENUMERATED_TYPES(j: Int) : EnumeratedArgumentType? = ENUMERATED_TYPES(EnumeratedArgumentType(), j)
    fun ENUMERATED_TYPES(obj: EnumeratedArgumentType, j: Int) : EnumeratedArgumentType? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val ENUMERATED_TYPESLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Binary argument types
     */
    fun BINARY_TYPES(j: Int) : BinaryArgumentType? = BINARY_TYPES(BinaryArgumentType(), j)
    fun BINARY_TYPES(obj: BinaryArgumentType, j: Int) : BinaryArgumentType? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val BINARY_TYPESLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Aggregate argument types
     */
    fun AGGREGATE_TYPES(j: Int) : AggregateArgumentType? = AGGREGATE_TYPES(AggregateArgumentType(), j)
    fun AGGREGATE_TYPES(obj: AggregateArgumentType, j: Int) : AggregateArgumentType? {
        val o = __offset(16)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val AGGREGATE_TYPESLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsArgumentTypeSet(_bb: ByteBuffer): ArgumentTypeSet = getRootAsArgumentTypeSet(_bb, ArgumentTypeSet())
        fun getRootAsArgumentTypeSet(_bb: ByteBuffer, obj: ArgumentTypeSet): ArgumentTypeSet {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createArgumentTypeSet(builder: FlatBufferBuilder, INTEGER_TYPESOffset: Int, FLOAT_TYPESOffset: Int, STRING_TYPESOffset: Int, BOOLEAN_TYPESOffset: Int, ENUMERATED_TYPESOffset: Int, BINARY_TYPESOffset: Int, AGGREGATE_TYPESOffset: Int) : Int {
            builder.startTable(7)
            addAGGREGATE_TYPES(builder, AGGREGATE_TYPESOffset)
            addBINARY_TYPES(builder, BINARY_TYPESOffset)
            addENUMERATED_TYPES(builder, ENUMERATED_TYPESOffset)
            addBOOLEAN_TYPES(builder, BOOLEAN_TYPESOffset)
            addSTRING_TYPES(builder, STRING_TYPESOffset)
            addFLOAT_TYPES(builder, FLOAT_TYPESOffset)
            addINTEGER_TYPES(builder, INTEGER_TYPESOffset)
            return endArgumentTypeSet(builder)
        }
        fun startArgumentTypeSet(builder: FlatBufferBuilder) = builder.startTable(7)
        fun addINTEGER_TYPES(builder: FlatBufferBuilder, INTEGER_TYPES: Int) = builder.addOffset(0, INTEGER_TYPES, 0)
        fun createIntegerTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startIntegerTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addFLOAT_TYPES(builder: FlatBufferBuilder, FLOAT_TYPES: Int) = builder.addOffset(1, FLOAT_TYPES, 0)
        fun createFloatTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startFloatTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addSTRING_TYPES(builder: FlatBufferBuilder, STRING_TYPES: Int) = builder.addOffset(2, STRING_TYPES, 0)
        fun createStringTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startStringTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addBOOLEAN_TYPES(builder: FlatBufferBuilder, BOOLEAN_TYPES: Int) = builder.addOffset(3, BOOLEAN_TYPES, 0)
        fun createBooleanTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startBooleanTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addENUMERATED_TYPES(builder: FlatBufferBuilder, ENUMERATED_TYPES: Int) = builder.addOffset(4, ENUMERATED_TYPES, 0)
        fun createEnumeratedTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEnumeratedTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addBINARY_TYPES(builder: FlatBufferBuilder, BINARY_TYPES: Int) = builder.addOffset(5, BINARY_TYPES, 0)
        fun createBinaryTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startBinaryTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addAGGREGATE_TYPES(builder: FlatBufferBuilder, AGGREGATE_TYPES: Int) = builder.addOffset(6, AGGREGATE_TYPES, 0)
        fun createAggregateTypesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startAggregateTypesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endArgumentTypeSet(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
