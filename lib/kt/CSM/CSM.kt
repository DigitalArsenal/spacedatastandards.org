// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Conjunction Summary Message
 */
@Suppress("unused")
class CSM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CSM {
        __init(_i, _bb)
        return this
    }
    /**
     * Satellite name for the first object
     */
    val OBJECT_1 : CAT? get() = OBJECT_1(CAT())
    fun OBJECT_1(obj: CAT) : CAT? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Days since epoch for the first object
     */
    val DSE_1 : Double
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Satellite name for the second object
     */
    val OBJECT_2 : CAT? get() = OBJECT_2(CAT())
    fun OBJECT_2(obj: CAT) : CAT? {
        val o = __offset(8)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Days since epoch for the second object
     */
    val DSE_2 : Double
        get() {
            val o = __offset(10)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Time of closest approach as a Unix timestamp
     */
    val TCA : Double
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The distance or range between the two objects at TCA
     */
    val TCA_RANGE : Double
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The magnitude of the relative velocity at TCA
     */
    val TCA_RELATIVE_SPEED : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Maximum probability
     */
    val MAX_PROB : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Standard deviation that produces the maximum probability
     */
    val DILUTION : Double
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsCSM(_bb: ByteBuffer): CSM = getRootAsCSM(_bb, CSM())
        fun getRootAsCSM(_bb: ByteBuffer, obj: CSM): CSM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun CSMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$CSM")
        fun createCSM(builder: FlatBufferBuilder, OBJECT_1Offset: Int, DSE_1: Double, OBJECT_2Offset: Int, DSE_2: Double, TCA: Double, TCA_RANGE: Double, TCA_RELATIVE_SPEED: Double, MAX_PROB: Double, DILUTION: Double) : Int {
            builder.startTable(9)
            addDILUTION(builder, DILUTION)
            addMAX_PROB(builder, MAX_PROB)
            addTCA_RELATIVE_SPEED(builder, TCA_RELATIVE_SPEED)
            addTCA_RANGE(builder, TCA_RANGE)
            addTCA(builder, TCA)
            addDSE_2(builder, DSE_2)
            addDSE_1(builder, DSE_1)
            addOBJECT_2(builder, OBJECT_2Offset)
            addOBJECT_1(builder, OBJECT_1Offset)
            return endCSM(builder)
        }
        fun startCSM(builder: FlatBufferBuilder) = builder.startTable(9)
        fun addOBJECT_1(builder: FlatBufferBuilder, OBJECT_1: Int) = builder.addOffset(0, OBJECT_1, 0)
        fun addDSE_1(builder: FlatBufferBuilder, DSE_1: Double) = builder.addDouble(1, DSE_1, 0.0)
        fun addOBJECT_2(builder: FlatBufferBuilder, OBJECT_2: Int) = builder.addOffset(2, OBJECT_2, 0)
        fun addDSE_2(builder: FlatBufferBuilder, DSE_2: Double) = builder.addDouble(3, DSE_2, 0.0)
        fun addTCA(builder: FlatBufferBuilder, TCA: Double) = builder.addDouble(4, TCA, 0.0)
        fun addTCA_RANGE(builder: FlatBufferBuilder, TCA_RANGE: Double) = builder.addDouble(5, TCA_RANGE, 0.0)
        fun addTCA_RELATIVE_SPEED(builder: FlatBufferBuilder, TCA_RELATIVE_SPEED: Double) = builder.addDouble(6, TCA_RELATIVE_SPEED, 0.0)
        fun addMAX_PROB(builder: FlatBufferBuilder, MAX_PROB: Double) = builder.addDouble(7, MAX_PROB, 0.0)
        fun addDILUTION(builder: FlatBufferBuilder, DILUTION: Double) = builder.addDouble(8, DILUTION, 0.0)
        fun endCSM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishCSMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$CSM")
        fun finishSizePrefixedCSMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$CSM")
    }
}
