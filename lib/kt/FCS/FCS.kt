// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Fire Control Systems
 */
@Suppress("unused")
class FCS : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : FCS {
        __init(_i, _bb)
        return this
    }
    val MODE : UByte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val LEAD_METHOD : UByte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val RANGEFINDER_TYPE : UByte
        get() {
            val o = __offset(8)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val AMMO_SELECTED : UByte
        get() {
            val o = __offset(10)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val TARGET : String?
        get() {
            val o = __offset(12)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TARGETAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun TARGETInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    val SOLUTION : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOLUTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun SOLUTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    val LAST_RANGE : Double
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val RANGE_RATE : Double
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    val ROUNDS_REMAINING : UShort
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getShort(o + bb_pos).toUShort() else 0u
        }
    val TEMPERATURE : Float
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    fun RESERVED(j: Int) : UByte {
        val o = __offset(24)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val RESERVEDLength : Int
        get() {
            val o = __offset(24); return if (o != 0) __vector_len(o) else 0
        }
    val RESERVEDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun RESERVEDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsFCS(_bb: ByteBuffer): FCS = getRootAsFCS(_bb, FCS())
        fun getRootAsFCS(_bb: ByteBuffer, obj: FCS): FCS {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun FCSBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$FCS")
        fun createFCS(builder: FlatBufferBuilder, MODE: UByte, LEAD_METHOD: UByte, RANGEFINDER_TYPE: UByte, AMMO_SELECTED: UByte, TARGETOffset: Int, SOLUTIONOffset: Int, LAST_RANGE: Double, RANGE_RATE: Double, ROUNDS_REMAINING: UShort, TEMPERATURE: Float, RESERVEDOffset: Int) : Int {
            builder.startTable(11)
            addRANGE_RATE(builder, RANGE_RATE)
            addLAST_RANGE(builder, LAST_RANGE)
            addRESERVED(builder, RESERVEDOffset)
            addTEMPERATURE(builder, TEMPERATURE)
            addSOLUTION(builder, SOLUTIONOffset)
            addTARGET(builder, TARGETOffset)
            addROUNDS_REMAINING(builder, ROUNDS_REMAINING)
            addAMMO_SELECTED(builder, AMMO_SELECTED)
            addRANGEFINDER_TYPE(builder, RANGEFINDER_TYPE)
            addLEAD_METHOD(builder, LEAD_METHOD)
            addMODE(builder, MODE)
            return endFCS(builder)
        }
        fun startFCS(builder: FlatBufferBuilder) = builder.startTable(11)
        fun addMODE(builder: FlatBufferBuilder, MODE: UByte) = builder.addByte(0, MODE.toByte(), 0)
        fun addLEAD_METHOD(builder: FlatBufferBuilder, LEAD_METHOD: UByte) = builder.addByte(1, LEAD_METHOD.toByte(), 0)
        fun addRANGEFINDER_TYPE(builder: FlatBufferBuilder, RANGEFINDER_TYPE: UByte) = builder.addByte(2, RANGEFINDER_TYPE.toByte(), 0)
        fun addAMMO_SELECTED(builder: FlatBufferBuilder, AMMO_SELECTED: UByte) = builder.addByte(3, AMMO_SELECTED.toByte(), 0)
        fun addTARGET(builder: FlatBufferBuilder, TARGET: Int) = builder.addOffset(4, TARGET, 0)
        fun addSOLUTION(builder: FlatBufferBuilder, SOLUTION: Int) = builder.addOffset(5, SOLUTION, 0)
        fun addLAST_RANGE(builder: FlatBufferBuilder, LAST_RANGE: Double) = builder.addDouble(6, LAST_RANGE, 0.0)
        fun addRANGE_RATE(builder: FlatBufferBuilder, RANGE_RATE: Double) = builder.addDouble(7, RANGE_RATE, 0.0)
        fun addROUNDS_REMAINING(builder: FlatBufferBuilder, ROUNDS_REMAINING: UShort) = builder.addShort(8, ROUNDS_REMAINING.toShort(), 0)
        fun addTEMPERATURE(builder: FlatBufferBuilder, TEMPERATURE: Float) = builder.addFloat(9, TEMPERATURE, 0.0)
        fun addRESERVED(builder: FlatBufferBuilder, RESERVED: Int) = builder.addOffset(10, RESERVED, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createReservedVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startReservedVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun endFCS(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishFCSBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$FCS")
        fun finishSizePrefixedFCSBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$FCS")
    }
}
