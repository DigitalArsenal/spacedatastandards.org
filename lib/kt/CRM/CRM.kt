// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Collection Request Message
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class CRM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : CRM {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier of the record, auto-generated by the system.
     */
    val ID : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * Classification marking of the data in IC/CAPCO Portion-marked format.
     */
    val CLASSIFICATION : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CLASSIFICATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun CLASSIFICATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * The type of this collect or contact request.
     */
    val TYPE : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Unique identifier of the parent plan or schedule associated with this request.
     */
    val ID_PLAN : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_PLANAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun ID_PLANInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Index number for records within a collection plan or schedule.
     */
    val PLAN_INDEX : Int
        get() {
            val o = __offset(12)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * Task ID associated with this request.
     */
    val TASK_ID : String?
        get() {
            val o = __offset(14)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TASK_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(14, 1)
    fun TASK_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 14, 1)
    /**
     * The dwell ID associated with this request.
     */
    val DWELL_ID : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DWELL_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun DWELL_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Optional ID from external systems.
     */
    val EXTERNAL_ID : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EXTERNAL_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun EXTERNAL_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Unique identifier of the requested/scheduled/planned sensor associated with this request.
     */
    val ID_SENSOR : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_SENSORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun ID_SENSORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
     */
    val ORIG_SENSOR_ID : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_SENSOR_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun ORIG_SENSOR_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Optional type of observation requested.
     */
    val OB_TYPE : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val OB_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun OB_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * The priority of the collect request.
     */
    val PRIORITY : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PRIORITYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun PRIORITYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * The tasking category associated with this request.
     */
    val TASK_CATEGORY : Int
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The tasking suffix associated with this request.
     */
    val SUFFIX : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SUFFIXAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun SUFFIXInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Boolean indicating that this collect request is UCT follow-up.
     */
    val UCT_FOLLOW_UP : Boolean
        get() {
            val o = __offset(32)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    /**
     * The start time of the collect or contact request window, in ISO 8601 UTC format.
     */
    val START_TIME : String?
        get() {
            val o = __offset(34)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val START_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(34, 1)
    fun START_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 34, 1)
    /**
     * The end time of the collect or contact request window, in ISO 8601 UTC format.
     */
    val END_TIME : String?
        get() {
            val o = __offset(36)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val END_TIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(36, 1)
    fun END_TIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 36, 1)
    /**
     * Satellite/catalog number of the target on-orbit object for this request.
     */
    val NORAD_CAT_ID : UInt
        get() {
            val o = __offset(38)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    /**
     * Optional identifier provided by the data source to indicate the target object of this request.
     */
    val ORIG_OBJECT_ID : String?
        get() {
            val o = __offset(40)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIG_OBJECT_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(40, 1)
    fun ORIG_OBJECT_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 40, 1)
    /**
     * The tasking group to which the target object is assigned.
     */
    val TASK_GROUP : String?
        get() {
            val o = __offset(42)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val TASK_GROUPAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(42, 1)
    fun TASK_GROUPInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 42, 1)
    /**
     * Inter-Range Operations Number.
     */
    val IRON : Int
        get() {
            val o = __offset(44)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The orbit regime of the target.
     */
    val ORBIT_REGIME : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORBIT_REGIMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun ORBIT_REGIMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * The minimum object (diameter) size, in meters, to be reported.
     */
    val TARGET_SIZE : Double
        get() {
            val o = __offset(48)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The minimum Radar Cross-Section of the target, in m^2.
     */
    val RCS_MIN : Double
        get() {
            val o = __offset(50)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The Radar Cross-Section of the target, in m^2.
     */
    val RCS : Double
        get() {
            val o = __offset(52)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum Radar Cross-Section of the target, in m^2.
     */
    val RCS_MAX : Double
        get() {
            val o = __offset(54)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The minimum frequency of interest, in MHz.
     */
    val FREQ_MIN : Double
        get() {
            val o = __offset(56)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The estimated or expected emission frequency of the target, in MHz.
     */
    val FREQ : Double
        get() {
            val o = __offset(58)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum frequency of interest, in MHz.
     */
    val FREQ_MAX : Double
        get() {
            val o = __offset(60)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The RF polarization.
     */
    val POLARIZATION : String?
        get() {
            val o = __offset(62)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val POLARIZATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(62, 1)
    fun POLARIZATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 62, 1)
    /**
     * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    val VIS_MAG_MIN : Double
        get() {
            val o = __offset(64)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    val VIS_MAG : Double
        get() {
            val o = __offset(66)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    val VIS_MAG_MAX : Double
        get() {
            val o = __offset(68)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The spectral model used for the irradiance calculation.
     */
    val SPECTRAL_MODEL : String?
        get() {
            val o = __offset(70)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SPECTRAL_MODELAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(70, 1)
    fun SPECTRAL_MODELInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 70, 1)
    /**
     * The fraction of solar energy reflected from target.
     */
    val REFLECTANCE : Double
        get() {
            val o = __offset(72)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The target object irradiance value.
     */
    val IRRADIANCE : Double
        get() {
            val o = __offset(74)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * For optical sensors, the requested number of frames to capture at each sensor step.
     */
    val NUM_FRAMES : Int
        get() {
            val o = __offset(76)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * For optical sensors, the frame rate of the camera, in Hz.
     */
    val FRAME_RATE : Double
        get() {
            val o = __offset(78)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * For optical sensors, the integration time per camera frame, in milliseconds.
     */
    val INTEGRATION_TIME : Double
        get() {
            val o = __offset(80)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The number of requested tracks on the target.
     */
    val NUM_TRACKS : Int
        get() {
            val o = __offset(82)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The number of requested observations on the target.
     */
    val NUM_OBS : Int
        get() {
            val o = __offset(84)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The duration of the collect request, in seconds.
     */
    val DURATION : Int
        get() {
            val o = __offset(86)
            return if(o != 0) bb.getInt(o + bb_pos) else 0
        }
    /**
     * The search pattern to be executed for this request.
     */
    val SRCH_PATTERN : String?
        get() {
            val o = __offset(88)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SRCH_PATTERNAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(88, 1)
    fun SRCH_PATTERNInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 88, 1)
    /**
     * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
     */
    val SCENARIO : String?
        get() {
            val o = __offset(90)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SCENARIOAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(90, 1)
    fun SCENARIOInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 90, 1)
    /**
     * ID of the Elset of the object associated with this request.
     */
    val ID_ELSET : String?
        get() {
            val o = __offset(92)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_ELSETAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(92, 1)
    fun ID_ELSETInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 92, 1)
    /**
     * ID of the Manifold Elset of the object associated with this request.
     */
    val ID_MANIFOLD : String?
        get() {
            val o = __offset(94)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_MANIFOLDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(94, 1)
    fun ID_MANIFOLDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 94, 1)
    /**
     * ID of the State Vector of the object or central vector associated with this request.
     */
    val ID_STATE_VECTOR : String?
        get() {
            val o = __offset(96)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ID_STATE_VECTORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(96, 1)
    fun ID_STATE_VECTORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 96, 1)
    /**
     * ID of the Ephemeris Set of the object associated with this request.
     */
    val ES_ID : String?
        get() {
            val o = __offset(98)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ES_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(98, 1)
    fun ES_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 98, 1)
    /**
     * Epoch time, in ISO 8601 UTC format, of the orbital elements.
     */
    val EPOCH : String?
        get() {
            val o = __offset(100)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val EPOCHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(100, 1)
    fun EPOCHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 100, 1)
    /**
     * The average of the periapsis and apoapsis distances, in kilometers.
     */
    val SEMI_MAJOR_AXIS : Double
        get() {
            val o = __offset(102)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The orbital eccentricity of an astronomical object.
     */
    val ECCENTRICITY : Double
        get() {
            val o = __offset(104)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angle, in degrees, between the equator and the orbit plane.
     */
    val INCLINATION : Double
        get() {
            val o = __offset(106)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Right ascension of the ascending node, in degrees.
     */
    val RAAN : Double
        get() {
            val o = __offset(108)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The argument of perigee, in degrees.
     */
    val ARG_OF_PERIGEE : Double
        get() {
            val o = __offset(110)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
     */
    val MEAN_ANOMALY : Double
        get() {
            val o = __offset(112)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed right ascension angle, in degrees.
     */
    val RA : Double
        get() {
            val o = __offset(114)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed declination angle, in degrees.
     */
    val DEC : Double
        get() {
            val o = __offset(116)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed azimuth angle, in degrees.
     */
    val AZ : Double
        get() {
            val o = __offset(118)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected or directed elevation angle, in degrees.
     */
    val EL : Double
        get() {
            val o = __offset(120)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The expected acquisition range or defined center range, in km.
     */
    val RANGE : Double
        get() {
            val o = __offset(122)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the azimuth angle, in degrees, from center azimuth.
     */
    val EXTENT_AZ : Double
        get() {
            val o = __offset(124)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the elevation angle, in degrees, from center elevation.
     */
    val EXTENT_EL : Double
        get() {
            val o = __offset(126)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The extent of the range, in km, from center range.
     */
    val EXTENT_RANGE : Double
        get() {
            val o = __offset(128)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 latitude, in degrees.
     */
    val LAT : Double
        get() {
            val o = __offset(130)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * WGS-84 longitude, in degrees.
     */
    val LON : Double
        get() {
            val o = __offset(132)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * Height above WGS-84 ellipsoid (HAE), in kilometers.
     */
    val ALT : Double
        get() {
            val o = __offset(134)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping WGS-84 latitude of a volume definition, in degrees.
     */
    val STOP_LAT : Double
        get() {
            val o = __offset(136)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping WGS-84 longitude of a volume definition, in degrees.
     */
    val STOP_LON : Double
        get() {
            val o = __offset(138)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
     */
    val STOP_ALT : Double
        get() {
            val o = __offset(140)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The maximum inclination, in degrees, to be used in search operations.
     */
    val SRCH_INC : Double
        get() {
            val o = __offset(142)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angular distance, in degrees, in the sensor-x direction from scan center.
     */
    val X_ANGLE : Double
        get() {
            val o = __offset(144)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The angular distance, in degrees, in the sensor-y direction from scan center.
     */
    val Y_ANGLE : Double
        get() {
            val o = __offset(146)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
     */
    val ORIENT_ANGLE : Double
        get() {
            val o = __offset(148)
            return if(o != 0) bb.getDouble(o + bb_pos) else 0.0
        }
    /**
     * The customer for this request.
     */
    val CUSTOMER : String?
        get() {
            val o = __offset(150)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CUSTOMERAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(150, 1)
    fun CUSTOMERInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 150, 1)
    /**
     * Notes or comments associated with this request.
     */
    val NOTES : String?
        get() {
            val o = __offset(152)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NOTESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(152, 1)
    fun NOTESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 152, 1)
    /**
     *  Source of the data.
     */
    val SOURCE : String?
        get() {
            val o = __offset(154)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val SOURCEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(154, 1)
    fun SOURCEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 154, 1)
    /**
     *  Originating system or organization which produced the data, if different from the source.
     */
    val ORIGIN : String?
        get() {
            val o = __offset(156)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIGINAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(156, 1)
    fun ORIGINInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 156, 1)
    /**
     *  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
     */
    val DATA_MODE : String?
        get() {
            val o = __offset(158)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val DATA_MODEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(158, 1)
    fun DATA_MODEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 158, 1)
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsCRM(_bb: ByteBuffer): CRM = getRootAsCRM(_bb, CRM())
        fun getRootAsCRM(_bb: ByteBuffer, obj: CRM): CRM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun CRMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$CRM")
        fun createCRM(builder: FlatBufferBuilder, IDOffset: Int, CLASSIFICATIONOffset: Int, TYPEOffset: Int, ID_PLANOffset: Int, PLAN_INDEX: Int, TASK_IDOffset: Int, DWELL_IDOffset: Int, EXTERNAL_IDOffset: Int, ID_SENSOROffset: Int, ORIG_SENSOR_IDOffset: Int, OB_TYPEOffset: Int, PRIORITYOffset: Int, TASK_CATEGORY: Int, SUFFIXOffset: Int, UCT_FOLLOW_UP: Boolean, START_TIMEOffset: Int, END_TIMEOffset: Int, NORAD_CAT_ID: UInt, ORIG_OBJECT_IDOffset: Int, TASK_GROUPOffset: Int, IRON: Int, ORBIT_REGIMEOffset: Int, TARGET_SIZE: Double, RCS_MIN: Double, RCS: Double, RCS_MAX: Double, FREQ_MIN: Double, FREQ: Double, FREQ_MAX: Double, POLARIZATIONOffset: Int, VIS_MAG_MIN: Double, VIS_MAG: Double, VIS_MAG_MAX: Double, SPECTRAL_MODELOffset: Int, REFLECTANCE: Double, IRRADIANCE: Double, NUM_FRAMES: Int, FRAME_RATE: Double, INTEGRATION_TIME: Double, NUM_TRACKS: Int, NUM_OBS: Int, DURATION: Int, SRCH_PATTERNOffset: Int, SCENARIOOffset: Int, ID_ELSETOffset: Int, ID_MANIFOLDOffset: Int, ID_STATE_VECTOROffset: Int, ES_IDOffset: Int, EPOCHOffset: Int, SEMI_MAJOR_AXIS: Double, ECCENTRICITY: Double, INCLINATION: Double, RAAN: Double, ARG_OF_PERIGEE: Double, MEAN_ANOMALY: Double, RA: Double, DEC: Double, AZ: Double, EL: Double, RANGE: Double, EXTENT_AZ: Double, EXTENT_EL: Double, EXTENT_RANGE: Double, LAT: Double, LON: Double, ALT: Double, STOP_LAT: Double, STOP_LON: Double, STOP_ALT: Double, SRCH_INC: Double, X_ANGLE: Double, Y_ANGLE: Double, ORIENT_ANGLE: Double, CUSTOMEROffset: Int, NOTESOffset: Int, SOURCEOffset: Int, ORIGINOffset: Int, DATA_MODEOffset: Int) : Int {
            builder.startTable(78)
            addORIENT_ANGLE(builder, ORIENT_ANGLE)
            addY_ANGLE(builder, Y_ANGLE)
            addX_ANGLE(builder, X_ANGLE)
            addSRCH_INC(builder, SRCH_INC)
            addSTOP_ALT(builder, STOP_ALT)
            addSTOP_LON(builder, STOP_LON)
            addSTOP_LAT(builder, STOP_LAT)
            addALT(builder, ALT)
            addLON(builder, LON)
            addLAT(builder, LAT)
            addEXTENT_RANGE(builder, EXTENT_RANGE)
            addEXTENT_EL(builder, EXTENT_EL)
            addEXTENT_AZ(builder, EXTENT_AZ)
            addRANGE(builder, RANGE)
            addEL(builder, EL)
            addAZ(builder, AZ)
            addDEC(builder, DEC)
            addRA(builder, RA)
            addMEAN_ANOMALY(builder, MEAN_ANOMALY)
            addARG_OF_PERIGEE(builder, ARG_OF_PERIGEE)
            addRAAN(builder, RAAN)
            addINCLINATION(builder, INCLINATION)
            addECCENTRICITY(builder, ECCENTRICITY)
            addSEMI_MAJOR_AXIS(builder, SEMI_MAJOR_AXIS)
            addINTEGRATION_TIME(builder, INTEGRATION_TIME)
            addFRAME_RATE(builder, FRAME_RATE)
            addIRRADIANCE(builder, IRRADIANCE)
            addREFLECTANCE(builder, REFLECTANCE)
            addVIS_MAG_MAX(builder, VIS_MAG_MAX)
            addVIS_MAG(builder, VIS_MAG)
            addVIS_MAG_MIN(builder, VIS_MAG_MIN)
            addFREQ_MAX(builder, FREQ_MAX)
            addFREQ(builder, FREQ)
            addFREQ_MIN(builder, FREQ_MIN)
            addRCS_MAX(builder, RCS_MAX)
            addRCS(builder, RCS)
            addRCS_MIN(builder, RCS_MIN)
            addTARGET_SIZE(builder, TARGET_SIZE)
            addDATA_MODE(builder, DATA_MODEOffset)
            addORIGIN(builder, ORIGINOffset)
            addSOURCE(builder, SOURCEOffset)
            addNOTES(builder, NOTESOffset)
            addCUSTOMER(builder, CUSTOMEROffset)
            addEPOCH(builder, EPOCHOffset)
            addES_ID(builder, ES_IDOffset)
            addID_STATE_VECTOR(builder, ID_STATE_VECTOROffset)
            addID_MANIFOLD(builder, ID_MANIFOLDOffset)
            addID_ELSET(builder, ID_ELSETOffset)
            addSCENARIO(builder, SCENARIOOffset)
            addSRCH_PATTERN(builder, SRCH_PATTERNOffset)
            addDURATION(builder, DURATION)
            addNUM_OBS(builder, NUM_OBS)
            addNUM_TRACKS(builder, NUM_TRACKS)
            addNUM_FRAMES(builder, NUM_FRAMES)
            addSPECTRAL_MODEL(builder, SPECTRAL_MODELOffset)
            addPOLARIZATION(builder, POLARIZATIONOffset)
            addORBIT_REGIME(builder, ORBIT_REGIMEOffset)
            addIRON(builder, IRON)
            addTASK_GROUP(builder, TASK_GROUPOffset)
            addORIG_OBJECT_ID(builder, ORIG_OBJECT_IDOffset)
            addNORAD_CAT_ID(builder, NORAD_CAT_ID)
            addEND_TIME(builder, END_TIMEOffset)
            addSTART_TIME(builder, START_TIMEOffset)
            addSUFFIX(builder, SUFFIXOffset)
            addTASK_CATEGORY(builder, TASK_CATEGORY)
            addPRIORITY(builder, PRIORITYOffset)
            addOB_TYPE(builder, OB_TYPEOffset)
            addORIG_SENSOR_ID(builder, ORIG_SENSOR_IDOffset)
            addID_SENSOR(builder, ID_SENSOROffset)
            addEXTERNAL_ID(builder, EXTERNAL_IDOffset)
            addDWELL_ID(builder, DWELL_IDOffset)
            addTASK_ID(builder, TASK_IDOffset)
            addPLAN_INDEX(builder, PLAN_INDEX)
            addID_PLAN(builder, ID_PLANOffset)
            addTYPE(builder, TYPEOffset)
            addCLASSIFICATION(builder, CLASSIFICATIONOffset)
            addID(builder, IDOffset)
            addUCT_FOLLOW_UP(builder, UCT_FOLLOW_UP)
            return endCRM(builder)
        }
        fun startCRM(builder: FlatBufferBuilder) = builder.startTable(78)
        fun addID(builder: FlatBufferBuilder, ID: Int) = builder.addOffset(0, ID, 0)
        fun addCLASSIFICATION(builder: FlatBufferBuilder, CLASSIFICATION: Int) = builder.addOffset(1, CLASSIFICATION, 0)
        fun addTYPE(builder: FlatBufferBuilder, TYPE: Int) = builder.addOffset(2, TYPE, 0)
        fun addID_PLAN(builder: FlatBufferBuilder, ID_PLAN: Int) = builder.addOffset(3, ID_PLAN, 0)
        fun addPLAN_INDEX(builder: FlatBufferBuilder, PLAN_INDEX: Int) = builder.addInt(4, PLAN_INDEX, 0)
        fun addTASK_ID(builder: FlatBufferBuilder, TASK_ID: Int) = builder.addOffset(5, TASK_ID, 0)
        fun addDWELL_ID(builder: FlatBufferBuilder, DWELL_ID: Int) = builder.addOffset(6, DWELL_ID, 0)
        fun addEXTERNAL_ID(builder: FlatBufferBuilder, EXTERNAL_ID: Int) = builder.addOffset(7, EXTERNAL_ID, 0)
        fun addID_SENSOR(builder: FlatBufferBuilder, ID_SENSOR: Int) = builder.addOffset(8, ID_SENSOR, 0)
        fun addORIG_SENSOR_ID(builder: FlatBufferBuilder, ORIG_SENSOR_ID: Int) = builder.addOffset(9, ORIG_SENSOR_ID, 0)
        fun addOB_TYPE(builder: FlatBufferBuilder, OB_TYPE: Int) = builder.addOffset(10, OB_TYPE, 0)
        fun addPRIORITY(builder: FlatBufferBuilder, PRIORITY: Int) = builder.addOffset(11, PRIORITY, 0)
        fun addTASK_CATEGORY(builder: FlatBufferBuilder, TASK_CATEGORY: Int) = builder.addInt(12, TASK_CATEGORY, 0)
        fun addSUFFIX(builder: FlatBufferBuilder, SUFFIX: Int) = builder.addOffset(13, SUFFIX, 0)
        fun addUCT_FOLLOW_UP(builder: FlatBufferBuilder, UCT_FOLLOW_UP: Boolean) = builder.addBoolean(14, UCT_FOLLOW_UP, false)
        fun addSTART_TIME(builder: FlatBufferBuilder, START_TIME: Int) = builder.addOffset(15, START_TIME, 0)
        fun addEND_TIME(builder: FlatBufferBuilder, END_TIME: Int) = builder.addOffset(16, END_TIME, 0)
        fun addNORAD_CAT_ID(builder: FlatBufferBuilder, NORAD_CAT_ID: UInt) = builder.addInt(17, NORAD_CAT_ID.toInt(), 0)
        fun addORIG_OBJECT_ID(builder: FlatBufferBuilder, ORIG_OBJECT_ID: Int) = builder.addOffset(18, ORIG_OBJECT_ID, 0)
        fun addTASK_GROUP(builder: FlatBufferBuilder, TASK_GROUP: Int) = builder.addOffset(19, TASK_GROUP, 0)
        fun addIRON(builder: FlatBufferBuilder, IRON: Int) = builder.addInt(20, IRON, 0)
        fun addORBIT_REGIME(builder: FlatBufferBuilder, ORBIT_REGIME: Int) = builder.addOffset(21, ORBIT_REGIME, 0)
        fun addTARGET_SIZE(builder: FlatBufferBuilder, TARGET_SIZE: Double) = builder.addDouble(22, TARGET_SIZE, 0.0)
        fun addRCS_MIN(builder: FlatBufferBuilder, RCS_MIN: Double) = builder.addDouble(23, RCS_MIN, 0.0)
        fun addRCS(builder: FlatBufferBuilder, RCS: Double) = builder.addDouble(24, RCS, 0.0)
        fun addRCS_MAX(builder: FlatBufferBuilder, RCS_MAX: Double) = builder.addDouble(25, RCS_MAX, 0.0)
        fun addFREQ_MIN(builder: FlatBufferBuilder, FREQ_MIN: Double) = builder.addDouble(26, FREQ_MIN, 0.0)
        fun addFREQ(builder: FlatBufferBuilder, FREQ: Double) = builder.addDouble(27, FREQ, 0.0)
        fun addFREQ_MAX(builder: FlatBufferBuilder, FREQ_MAX: Double) = builder.addDouble(28, FREQ_MAX, 0.0)
        fun addPOLARIZATION(builder: FlatBufferBuilder, POLARIZATION: Int) = builder.addOffset(29, POLARIZATION, 0)
        fun addVIS_MAG_MIN(builder: FlatBufferBuilder, VIS_MAG_MIN: Double) = builder.addDouble(30, VIS_MAG_MIN, 0.0)
        fun addVIS_MAG(builder: FlatBufferBuilder, VIS_MAG: Double) = builder.addDouble(31, VIS_MAG, 0.0)
        fun addVIS_MAG_MAX(builder: FlatBufferBuilder, VIS_MAG_MAX: Double) = builder.addDouble(32, VIS_MAG_MAX, 0.0)
        fun addSPECTRAL_MODEL(builder: FlatBufferBuilder, SPECTRAL_MODEL: Int) = builder.addOffset(33, SPECTRAL_MODEL, 0)
        fun addREFLECTANCE(builder: FlatBufferBuilder, REFLECTANCE: Double) = builder.addDouble(34, REFLECTANCE, 0.0)
        fun addIRRADIANCE(builder: FlatBufferBuilder, IRRADIANCE: Double) = builder.addDouble(35, IRRADIANCE, 0.0)
        fun addNUM_FRAMES(builder: FlatBufferBuilder, NUM_FRAMES: Int) = builder.addInt(36, NUM_FRAMES, 0)
        fun addFRAME_RATE(builder: FlatBufferBuilder, FRAME_RATE: Double) = builder.addDouble(37, FRAME_RATE, 0.0)
        fun addINTEGRATION_TIME(builder: FlatBufferBuilder, INTEGRATION_TIME: Double) = builder.addDouble(38, INTEGRATION_TIME, 0.0)
        fun addNUM_TRACKS(builder: FlatBufferBuilder, NUM_TRACKS: Int) = builder.addInt(39, NUM_TRACKS, 0)
        fun addNUM_OBS(builder: FlatBufferBuilder, NUM_OBS: Int) = builder.addInt(40, NUM_OBS, 0)
        fun addDURATION(builder: FlatBufferBuilder, DURATION: Int) = builder.addInt(41, DURATION, 0)
        fun addSRCH_PATTERN(builder: FlatBufferBuilder, SRCH_PATTERN: Int) = builder.addOffset(42, SRCH_PATTERN, 0)
        fun addSCENARIO(builder: FlatBufferBuilder, SCENARIO: Int) = builder.addOffset(43, SCENARIO, 0)
        fun addID_ELSET(builder: FlatBufferBuilder, ID_ELSET: Int) = builder.addOffset(44, ID_ELSET, 0)
        fun addID_MANIFOLD(builder: FlatBufferBuilder, ID_MANIFOLD: Int) = builder.addOffset(45, ID_MANIFOLD, 0)
        fun addID_STATE_VECTOR(builder: FlatBufferBuilder, ID_STATE_VECTOR: Int) = builder.addOffset(46, ID_STATE_VECTOR, 0)
        fun addES_ID(builder: FlatBufferBuilder, ES_ID: Int) = builder.addOffset(47, ES_ID, 0)
        fun addEPOCH(builder: FlatBufferBuilder, EPOCH: Int) = builder.addOffset(48, EPOCH, 0)
        fun addSEMI_MAJOR_AXIS(builder: FlatBufferBuilder, SEMI_MAJOR_AXIS: Double) = builder.addDouble(49, SEMI_MAJOR_AXIS, 0.0)
        fun addECCENTRICITY(builder: FlatBufferBuilder, ECCENTRICITY: Double) = builder.addDouble(50, ECCENTRICITY, 0.0)
        fun addINCLINATION(builder: FlatBufferBuilder, INCLINATION: Double) = builder.addDouble(51, INCLINATION, 0.0)
        fun addRAAN(builder: FlatBufferBuilder, RAAN: Double) = builder.addDouble(52, RAAN, 0.0)
        fun addARG_OF_PERIGEE(builder: FlatBufferBuilder, ARG_OF_PERIGEE: Double) = builder.addDouble(53, ARG_OF_PERIGEE, 0.0)
        fun addMEAN_ANOMALY(builder: FlatBufferBuilder, MEAN_ANOMALY: Double) = builder.addDouble(54, MEAN_ANOMALY, 0.0)
        fun addRA(builder: FlatBufferBuilder, RA: Double) = builder.addDouble(55, RA, 0.0)
        fun addDEC(builder: FlatBufferBuilder, DEC: Double) = builder.addDouble(56, DEC, 0.0)
        fun addAZ(builder: FlatBufferBuilder, AZ: Double) = builder.addDouble(57, AZ, 0.0)
        fun addEL(builder: FlatBufferBuilder, EL: Double) = builder.addDouble(58, EL, 0.0)
        fun addRANGE(builder: FlatBufferBuilder, RANGE: Double) = builder.addDouble(59, RANGE, 0.0)
        fun addEXTENT_AZ(builder: FlatBufferBuilder, EXTENT_AZ: Double) = builder.addDouble(60, EXTENT_AZ, 0.0)
        fun addEXTENT_EL(builder: FlatBufferBuilder, EXTENT_EL: Double) = builder.addDouble(61, EXTENT_EL, 0.0)
        fun addEXTENT_RANGE(builder: FlatBufferBuilder, EXTENT_RANGE: Double) = builder.addDouble(62, EXTENT_RANGE, 0.0)
        fun addLAT(builder: FlatBufferBuilder, LAT: Double) = builder.addDouble(63, LAT, 0.0)
        fun addLON(builder: FlatBufferBuilder, LON: Double) = builder.addDouble(64, LON, 0.0)
        fun addALT(builder: FlatBufferBuilder, ALT: Double) = builder.addDouble(65, ALT, 0.0)
        fun addSTOP_LAT(builder: FlatBufferBuilder, STOP_LAT: Double) = builder.addDouble(66, STOP_LAT, 0.0)
        fun addSTOP_LON(builder: FlatBufferBuilder, STOP_LON: Double) = builder.addDouble(67, STOP_LON, 0.0)
        fun addSTOP_ALT(builder: FlatBufferBuilder, STOP_ALT: Double) = builder.addDouble(68, STOP_ALT, 0.0)
        fun addSRCH_INC(builder: FlatBufferBuilder, SRCH_INC: Double) = builder.addDouble(69, SRCH_INC, 0.0)
        fun addX_ANGLE(builder: FlatBufferBuilder, X_ANGLE: Double) = builder.addDouble(70, X_ANGLE, 0.0)
        fun addY_ANGLE(builder: FlatBufferBuilder, Y_ANGLE: Double) = builder.addDouble(71, Y_ANGLE, 0.0)
        fun addORIENT_ANGLE(builder: FlatBufferBuilder, ORIENT_ANGLE: Double) = builder.addDouble(72, ORIENT_ANGLE, 0.0)
        fun addCUSTOMER(builder: FlatBufferBuilder, CUSTOMER: Int) = builder.addOffset(73, CUSTOMER, 0)
        fun addNOTES(builder: FlatBufferBuilder, NOTES: Int) = builder.addOffset(74, NOTES, 0)
        fun addSOURCE(builder: FlatBufferBuilder, SOURCE: Int) = builder.addOffset(75, SOURCE, 0)
        fun addORIGIN(builder: FlatBufferBuilder, ORIGIN: Int) = builder.addOffset(76, ORIGIN, 0)
        fun addDATA_MODE(builder: FlatBufferBuilder, DATA_MODE: Int) = builder.addOffset(77, DATA_MODE, 0)
        fun endCRM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishCRMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$CRM")
        fun finishSizePrefixedCRMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$CRM")
    }
}
