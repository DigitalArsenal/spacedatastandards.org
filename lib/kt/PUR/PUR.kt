// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Purchase Request - Request to purchase data from a storefront listing
 */
@Suppress("unused")
class PUR : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : PUR {
        __init(_i, _bb)
        return this
    }
    /**
     * Unique identifier for this purchase request
     */
    val REQUEST_ID : String
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field REQUEST_ID")
            }
        }
    val REQUEST_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun REQUEST_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    /**
     * ID of the listing being purchased
     */
    val LISTING_ID : String
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field LISTING_ID")
            }
        }
    val LISTING_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun LISTING_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    /**
     * Name of the pricing tier selected
     */
    val TIER_NAME : String
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field TIER_NAME")
            }
        }
    val TIER_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun TIER_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Peer ID of the buyer
     */
    val BUYER_PEER_ID : String
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                throw AssertionError("No value for (required) field BUYER_PEER_ID")
            }
        }
    val BUYER_PEER_IDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun BUYER_PEER_IDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Buyer's encryption public key for encrypted delivery
     */
    fun BUYER_ENCRYPTION_PUBKEY(j: Int) : UByte {
        val o = __offset(12)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val BUYER_ENCRYPTION_PUBKEYLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    val BUYER_ENCRYPTION_PUBKEYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 1)
    fun BUYER_ENCRYPTION_PUBKEYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 1)
    /**
     * Payment method used
     */
    val PAYMENT_METHOD : Byte
        get() {
            val o = __offset(14)
            return if(o != 0) bb.get(o + bb_pos) else 0
        }
    /**
     * Payment amount in smallest unit
     */
    val PAYMENT_AMOUNT : ULong
        get() {
            val o = __offset(16)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    /**
     * Currency of payment
     */
    val PAYMENT_CURRENCY : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYMENT_CURRENCYAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun PAYMENT_CURRENCYInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    /**
     * Transaction hash for cryptocurrency payments
     */
    val PAYMENT_TX_HASH : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYMENT_TX_HASHAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun PAYMENT_TX_HASHInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Blockchain network: "ethereum", "solana", "bitcoin"
     */
    val PAYMENT_CHAIN : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYMENT_CHAINAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun PAYMENT_CHAINInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Reference ID for credit/fiat payments
     */
    val PAYMENT_REFERENCE : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PAYMENT_REFERENCEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun PAYMENT_REFERENCEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Ed25519 signature from buyer
     */
    fun BUYER_SIGNATURE(j: Int) : UByte {
        val o = __offset(26)
        return if (o != 0) {
            bb.get(__vector(o) + j * 1).toUByte()
        } else {
            0u
        }
    }
    val BUYER_SIGNATURELength : Int
        get() {
            val o = __offset(26); return if (o != 0) __vector_len(o) else 0
        }
    val BUYER_SIGNATUREAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun BUYER_SIGNATUREInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Unix timestamp of the request
     */
    val TIMESTAMP : ULong
        get() {
            val o = __offset(28)
            return if(o != 0) bb.getLong(o + bb_pos).toULong() else 0UL
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsPUR(_bb: ByteBuffer): PUR = getRootAsPUR(_bb, PUR())
        fun getRootAsPUR(_bb: ByteBuffer, obj: PUR): PUR {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun PURBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$PUR")
        fun createPUR(builder: FlatBufferBuilder, REQUEST_IDOffset: Int, LISTING_IDOffset: Int, TIER_NAMEOffset: Int, BUYER_PEER_IDOffset: Int, BUYER_ENCRYPTION_PUBKEYOffset: Int, PAYMENT_METHOD: Byte, PAYMENT_AMOUNT: ULong, PAYMENT_CURRENCYOffset: Int, PAYMENT_TX_HASHOffset: Int, PAYMENT_CHAINOffset: Int, PAYMENT_REFERENCEOffset: Int, BUYER_SIGNATUREOffset: Int, TIMESTAMP: ULong) : Int {
            builder.startTable(13)
            addTIMESTAMP(builder, TIMESTAMP)
            addPAYMENT_AMOUNT(builder, PAYMENT_AMOUNT)
            addBUYER_SIGNATURE(builder, BUYER_SIGNATUREOffset)
            addPAYMENT_REFERENCE(builder, PAYMENT_REFERENCEOffset)
            addPAYMENT_CHAIN(builder, PAYMENT_CHAINOffset)
            addPAYMENT_TX_HASH(builder, PAYMENT_TX_HASHOffset)
            addPAYMENT_CURRENCY(builder, PAYMENT_CURRENCYOffset)
            addBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEYOffset)
            addBUYER_PEER_ID(builder, BUYER_PEER_IDOffset)
            addTIER_NAME(builder, TIER_NAMEOffset)
            addLISTING_ID(builder, LISTING_IDOffset)
            addREQUEST_ID(builder, REQUEST_IDOffset)
            addPAYMENT_METHOD(builder, PAYMENT_METHOD)
            return endPUR(builder)
        }
        fun startPUR(builder: FlatBufferBuilder) = builder.startTable(13)
        fun addREQUEST_ID(builder: FlatBufferBuilder, REQUEST_ID: Int) = builder.addOffset(0, REQUEST_ID, 0)
        fun addLISTING_ID(builder: FlatBufferBuilder, LISTING_ID: Int) = builder.addOffset(1, LISTING_ID, 0)
        fun addTIER_NAME(builder: FlatBufferBuilder, TIER_NAME: Int) = builder.addOffset(2, TIER_NAME, 0)
        fun addBUYER_PEER_ID(builder: FlatBufferBuilder, BUYER_PEER_ID: Int) = builder.addOffset(3, BUYER_PEER_ID, 0)
        fun addBUYER_ENCRYPTION_PUBKEY(builder: FlatBufferBuilder, BUYER_ENCRYPTION_PUBKEY: Int) = builder.addOffset(4, BUYER_ENCRYPTION_PUBKEY, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createBuyerEncryptionPubkeyVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startBuyerEncryptionPubkeyVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addPAYMENT_METHOD(builder: FlatBufferBuilder, PAYMENT_METHOD: Byte) = builder.addByte(5, PAYMENT_METHOD, 0)
        fun addPAYMENT_AMOUNT(builder: FlatBufferBuilder, PAYMENT_AMOUNT: ULong) = builder.addLong(6, PAYMENT_AMOUNT.toLong(), 0)
        fun addPAYMENT_CURRENCY(builder: FlatBufferBuilder, PAYMENT_CURRENCY: Int) = builder.addOffset(7, PAYMENT_CURRENCY, 0)
        fun addPAYMENT_TX_HASH(builder: FlatBufferBuilder, PAYMENT_TX_HASH: Int) = builder.addOffset(8, PAYMENT_TX_HASH, 0)
        fun addPAYMENT_CHAIN(builder: FlatBufferBuilder, PAYMENT_CHAIN: Int) = builder.addOffset(9, PAYMENT_CHAIN, 0)
        fun addPAYMENT_REFERENCE(builder: FlatBufferBuilder, PAYMENT_REFERENCE: Int) = builder.addOffset(10, PAYMENT_REFERENCE, 0)
        fun addBUYER_SIGNATURE(builder: FlatBufferBuilder, BUYER_SIGNATURE: Int) = builder.addOffset(11, BUYER_SIGNATURE, 0)
        @kotlin.ExperimentalUnsignedTypes
        fun createBuyerSignatureVector(builder: FlatBufferBuilder, data: UByteArray) : Int {
            builder.startVector(1, data.size, 1)
            for (i in data.size - 1 downTo 0) {
                builder.addByte(data[i].toByte())
            }
            return builder.endVector()
        }
        fun startBuyerSignatureVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(1, numElems, 1)
        fun addTIMESTAMP(builder: FlatBufferBuilder, TIMESTAMP: ULong) = builder.addLong(12, TIMESTAMP.toLong(), 0)
        fun endPUR(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
                builder.required(o, 4)
                builder.required(o, 6)
                builder.required(o, 8)
                builder.required(o, 10)
            return o
        }
        fun finishPURBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$PUR")
        fun finishSizePrefixedPURBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$PUR")
    }
}
