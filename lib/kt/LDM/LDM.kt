// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Launch Data Message
 */
@Suppress("unused")
@kotlin.ExperimentalUnsignedTypes
class LDM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : LDM {
        __init(_i, _bb)
        return this
    }
    /**
     * Launch Site Information
     */
    val SITE : SIT? get() = SITE(SIT())
    fun SITE(obj: SIT) : SIT? {
        val o = __offset(4)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Azimuth at Launch (in Degrees)
     */
    val AZIMUTH : Float
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    /**
     * References for Launch Data
     */
    val REFERENCES : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val REFERENCESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun REFERENCESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    /**
     * Launching Agency Name
     */
    val AGENCY_NAME : String?
        get() {
            val o = __offset(10)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val AGENCY_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 1)
    fun AGENCY_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 1)
    /**
     * Points of Contact for Launch
     */
    fun POINTS_OF_CONTACT(j: Int) : EPM? = POINTS_OF_CONTACT(EPM(), j)
    fun POINTS_OF_CONTACT(obj: EPM, j: Int) : EPM? {
        val o = __offset(12)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val POINTS_OF_CONTACTLength : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Operations Points of Contact for Launch
     */
    fun OPERATIONS_POINTS_OF_CONTACT(j: Int) : EPM? = OPERATIONS_POINTS_OF_CONTACT(EPM(), j)
    fun OPERATIONS_POINTS_OF_CONTACT(obj: EPM, j: Int) : EPM? {
        val o = __offset(14)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val OPERATIONS_POINTS_OF_CONTACTLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Net Launch Time (UTC Format)
     */
    val NET : String?
        get() {
            val o = __offset(16)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val NETAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(16, 1)
    fun NETInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 16, 1)
    /**
     * Rocket Configuration Details
     */
    val ROCKET_CONFIGURATION : ROC? get() = ROCKET_CONFIGURATION(ROC())
    fun ROCKET_CONFIGURATION(obj: ROC) : ROC? {
        val o = __offset(18)
        return if (o != 0) {
            obj.__assign(__indirect(o + bb_pos), bb)
        } else {
            null
        }
    }
    /**
     * Mission Name
     */
    val MISSION_NAME : String?
        get() {
            val o = __offset(20)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MISSION_NAMEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(20, 1)
    fun MISSION_NAMEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 20, 1)
    /**
     * Description of the Mission
     */
    val MISSION_DESCRIPTION : String?
        get() {
            val o = __offset(22)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MISSION_DESCRIPTIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(22, 1)
    fun MISSION_DESCRIPTIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 22, 1)
    /**
     * Type of the Mission (e.g., Test Flight, Satellite Deployment)
     */
    val MISSION_TYPE : String?
        get() {
            val o = __offset(24)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val MISSION_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(24, 1)
    fun MISSION_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 24, 1)
    /**
     * Target Orbit Type (e.g., LEO, GEO)
     */
    val ORBIT_TYPE : String?
        get() {
            val o = __offset(26)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORBIT_TYPEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(26, 1)
    fun ORBIT_TYPEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 26, 1)
    /**
     * Weather and Environmental Conditions at Launch
     */
    val WEATHER_CONDITIONS : String?
        get() {
            val o = __offset(28)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val WEATHER_CONDITIONSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(28, 1)
    fun WEATHER_CONDITIONSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 28, 1)
    /**
     * Launch Outcome and Status (e.g., Successful, Failed)
     */
    val LAUNCH_STATUS : String?
        get() {
            val o = __offset(30)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val LAUNCH_STATUSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(30, 1)
    fun LAUNCH_STATUSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 30, 1)
    /**
     * Webcast URL for the Launch
     */
    val WEBCAST_URL : String?
        get() {
            val o = __offset(32)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val WEBCAST_URLAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(32, 1)
    fun WEBCAST_URLInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 32, 1)
    /**
     * Media Links Related to the Launch
     */
    fun MEDIA_LINKS(j: Int) : String? {
        val o = __offset(34)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val MEDIA_LINKSLength : Int
        get() {
            val o = __offset(34); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Earliest Possible Launch Times
     */
    fun EARLIEST_LAUNCH_TIMES(j: Int) : String? {
        val o = __offset(36)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val EARLIEST_LAUNCH_TIMESLength : Int
        get() {
            val o = __offset(36); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Latest Possible Launch Times
     */
    fun LATEST_LAUNCH_TIMES(j: Int) : String? {
        val o = __offset(38)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val LATEST_LAUNCH_TIMESLength : Int
        get() {
            val o = __offset(38); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Launch Collision Avoidance Information
     */
    fun LCOLA_WINDOW_CLOSURES(j: Int) : String? {
        val o = __offset(40)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val LCOLA_WINDOW_CLOSURESLength : Int
        get() {
            val o = __offset(40); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Payload Information (Catalog Entities)
     */
    fun OBJECTS(j: Int) : CAT? = OBJECTS(CAT(), j)
    fun OBJECTS(obj: CAT, j: Int) : CAT? {
        val o = __offset(42)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val OBJECTSLength : Int
        get() {
            val o = __offset(42); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Tracking and Collision Avoidance Requirements
     */
    fun TRACKING_REQUIREMENTS(j: Int) : String? {
        val o = __offset(44)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val TRACKING_REQUIREMENTSLength : Int
        get() {
            val o = __offset(44); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Duration of Collision Avoidance Screen (in Seconds)
     */
    val COLA_SCREEN_DURATION : String?
        get() {
            val o = __offset(46)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COLA_SCREEN_DURATIONAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(46, 1)
    fun COLA_SCREEN_DURATIONInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 46, 1)
    /**
     * Probability of Collision Threshold (Percentage)
     */
    val PROBABILITY_OF_COLLISION_THRESHOLD : String?
        get() {
            val o = __offset(48)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val PROBABILITY_OF_COLLISION_THRESHOLDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(48, 1)
    fun PROBABILITY_OF_COLLISION_THRESHOLDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 48, 1)
    /**
     * Number of Required Collision Avoidance Runs
     */
    val COLA_RUNS_REQUIRED : String?
        get() {
            val o = __offset(50)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COLA_RUNS_REQUIREDAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(50, 1)
    fun COLA_RUNS_REQUIREDInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 50, 1)
    /**
     * Points of Contact for Collision Avoidance
     */
    fun COLA_POINTS_OF_CONTACT(j: Int) : EPM? = COLA_POINTS_OF_CONTACT(EPM(), j)
    fun COLA_POINTS_OF_CONTACT(obj: EPM, j: Int) : EPM? {
        val o = __offset(52)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val COLA_POINTS_OF_CONTACTLength : Int
        get() {
            val o = __offset(52); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Orbital Parameters of the Launch
     */
    fun ORBITAL_PARAMETERS(j: Int) : String? {
        val o = __offset(54)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ORBITAL_PARAMETERSLength : Int
        get() {
            val o = __offset(54); return if (o != 0) __vector_len(o) else 0
        }
    /**
     * Burn Out Vectors for the Launch
     */
    fun BURN_OUT_VECTORS(j: Int) : BOV? = BURN_OUT_VECTORS(BOV(), j)
    fun BURN_OUT_VECTORS(obj: BOV, j: Int) : BOV? {
        val o = __offset(56)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val BURN_OUT_VECTORSLength : Int
        get() {
            val o = __offset(56); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_23_3_3()
        fun getRootAsLDM(_bb: ByteBuffer): LDM = getRootAsLDM(_bb, LDM())
        fun getRootAsLDM(_bb: ByteBuffer, obj: LDM): LDM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun LDMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$LDM")
        fun createLDM(builder: FlatBufferBuilder, SITEOffset: Int, AZIMUTH: Float, REFERENCESOffset: Int, AGENCY_NAMEOffset: Int, POINTS_OF_CONTACTOffset: Int, OPERATIONS_POINTS_OF_CONTACTOffset: Int, NETOffset: Int, ROCKET_CONFIGURATIONOffset: Int, MISSION_NAMEOffset: Int, MISSION_DESCRIPTIONOffset: Int, MISSION_TYPEOffset: Int, ORBIT_TYPEOffset: Int, WEATHER_CONDITIONSOffset: Int, LAUNCH_STATUSOffset: Int, WEBCAST_URLOffset: Int, MEDIA_LINKSOffset: Int, EARLIEST_LAUNCH_TIMESOffset: Int, LATEST_LAUNCH_TIMESOffset: Int, LCOLA_WINDOW_CLOSURESOffset: Int, OBJECTSOffset: Int, TRACKING_REQUIREMENTSOffset: Int, COLA_SCREEN_DURATIONOffset: Int, PROBABILITY_OF_COLLISION_THRESHOLDOffset: Int, COLA_RUNS_REQUIREDOffset: Int, COLA_POINTS_OF_CONTACTOffset: Int, ORBITAL_PARAMETERSOffset: Int, BURN_OUT_VECTORSOffset: Int) : Int {
            builder.startTable(27)
            addBURN_OUT_VECTORS(builder, BURN_OUT_VECTORSOffset)
            addORBITAL_PARAMETERS(builder, ORBITAL_PARAMETERSOffset)
            addCOLA_POINTS_OF_CONTACT(builder, COLA_POINTS_OF_CONTACTOffset)
            addCOLA_RUNS_REQUIRED(builder, COLA_RUNS_REQUIREDOffset)
            addPROBABILITY_OF_COLLISION_THRESHOLD(builder, PROBABILITY_OF_COLLISION_THRESHOLDOffset)
            addCOLA_SCREEN_DURATION(builder, COLA_SCREEN_DURATIONOffset)
            addTRACKING_REQUIREMENTS(builder, TRACKING_REQUIREMENTSOffset)
            addOBJECTS(builder, OBJECTSOffset)
            addLCOLA_WINDOW_CLOSURES(builder, LCOLA_WINDOW_CLOSURESOffset)
            addLATEST_LAUNCH_TIMES(builder, LATEST_LAUNCH_TIMESOffset)
            addEARLIEST_LAUNCH_TIMES(builder, EARLIEST_LAUNCH_TIMESOffset)
            addMEDIA_LINKS(builder, MEDIA_LINKSOffset)
            addWEBCAST_URL(builder, WEBCAST_URLOffset)
            addLAUNCH_STATUS(builder, LAUNCH_STATUSOffset)
            addWEATHER_CONDITIONS(builder, WEATHER_CONDITIONSOffset)
            addORBIT_TYPE(builder, ORBIT_TYPEOffset)
            addMISSION_TYPE(builder, MISSION_TYPEOffset)
            addMISSION_DESCRIPTION(builder, MISSION_DESCRIPTIONOffset)
            addMISSION_NAME(builder, MISSION_NAMEOffset)
            addROCKET_CONFIGURATION(builder, ROCKET_CONFIGURATIONOffset)
            addNET(builder, NETOffset)
            addOPERATIONS_POINTS_OF_CONTACT(builder, OPERATIONS_POINTS_OF_CONTACTOffset)
            addPOINTS_OF_CONTACT(builder, POINTS_OF_CONTACTOffset)
            addAGENCY_NAME(builder, AGENCY_NAMEOffset)
            addREFERENCES(builder, REFERENCESOffset)
            addAZIMUTH(builder, AZIMUTH)
            addSITE(builder, SITEOffset)
            return endLDM(builder)
        }
        fun startLDM(builder: FlatBufferBuilder) = builder.startTable(27)
        fun addSITE(builder: FlatBufferBuilder, SITE: Int) = builder.addOffset(0, SITE, 0)
        fun addAZIMUTH(builder: FlatBufferBuilder, AZIMUTH: Float) = builder.addFloat(1, AZIMUTH, 0.0)
        fun addREFERENCES(builder: FlatBufferBuilder, REFERENCES: Int) = builder.addOffset(2, REFERENCES, 0)
        fun addAGENCY_NAME(builder: FlatBufferBuilder, AGENCY_NAME: Int) = builder.addOffset(3, AGENCY_NAME, 0)
        fun addPOINTS_OF_CONTACT(builder: FlatBufferBuilder, POINTS_OF_CONTACT: Int) = builder.addOffset(4, POINTS_OF_CONTACT, 0)
        fun createPointsOfContactVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startPointsOfContactVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOPERATIONS_POINTS_OF_CONTACT(builder: FlatBufferBuilder, OPERATIONS_POINTS_OF_CONTACT: Int) = builder.addOffset(5, OPERATIONS_POINTS_OF_CONTACT, 0)
        fun createOperationsPointsOfContactVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startOperationsPointsOfContactVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addNET(builder: FlatBufferBuilder, NET: Int) = builder.addOffset(6, NET, 0)
        fun addROCKET_CONFIGURATION(builder: FlatBufferBuilder, ROCKET_CONFIGURATION: Int) = builder.addOffset(7, ROCKET_CONFIGURATION, 0)
        fun addMISSION_NAME(builder: FlatBufferBuilder, MISSION_NAME: Int) = builder.addOffset(8, MISSION_NAME, 0)
        fun addMISSION_DESCRIPTION(builder: FlatBufferBuilder, MISSION_DESCRIPTION: Int) = builder.addOffset(9, MISSION_DESCRIPTION, 0)
        fun addMISSION_TYPE(builder: FlatBufferBuilder, MISSION_TYPE: Int) = builder.addOffset(10, MISSION_TYPE, 0)
        fun addORBIT_TYPE(builder: FlatBufferBuilder, ORBIT_TYPE: Int) = builder.addOffset(11, ORBIT_TYPE, 0)
        fun addWEATHER_CONDITIONS(builder: FlatBufferBuilder, WEATHER_CONDITIONS: Int) = builder.addOffset(12, WEATHER_CONDITIONS, 0)
        fun addLAUNCH_STATUS(builder: FlatBufferBuilder, LAUNCH_STATUS: Int) = builder.addOffset(13, LAUNCH_STATUS, 0)
        fun addWEBCAST_URL(builder: FlatBufferBuilder, WEBCAST_URL: Int) = builder.addOffset(14, WEBCAST_URL, 0)
        fun addMEDIA_LINKS(builder: FlatBufferBuilder, MEDIA_LINKS: Int) = builder.addOffset(15, MEDIA_LINKS, 0)
        fun createMediaLinksVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startMediaLinksVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEARLIEST_LAUNCH_TIMES(builder: FlatBufferBuilder, EARLIEST_LAUNCH_TIMES: Int) = builder.addOffset(16, EARLIEST_LAUNCH_TIMES, 0)
        fun createEarliestLaunchTimesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEarliestLaunchTimesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLATEST_LAUNCH_TIMES(builder: FlatBufferBuilder, LATEST_LAUNCH_TIMES: Int) = builder.addOffset(17, LATEST_LAUNCH_TIMES, 0)
        fun createLatestLaunchTimesVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLatestLaunchTimesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addLCOLA_WINDOW_CLOSURES(builder: FlatBufferBuilder, LCOLA_WINDOW_CLOSURES: Int) = builder.addOffset(18, LCOLA_WINDOW_CLOSURES, 0)
        fun createLcolaWindowClosuresVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startLcolaWindowClosuresVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addOBJECTS(builder: FlatBufferBuilder, OBJECTS: Int) = builder.addOffset(19, OBJECTS, 0)
        fun createObjectsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startObjectsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addTRACKING_REQUIREMENTS(builder: FlatBufferBuilder, TRACKING_REQUIREMENTS: Int) = builder.addOffset(20, TRACKING_REQUIREMENTS, 0)
        fun createTrackingRequirementsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startTrackingRequirementsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCOLA_SCREEN_DURATION(builder: FlatBufferBuilder, COLA_SCREEN_DURATION: Int) = builder.addOffset(21, COLA_SCREEN_DURATION, 0)
        fun addPROBABILITY_OF_COLLISION_THRESHOLD(builder: FlatBufferBuilder, PROBABILITY_OF_COLLISION_THRESHOLD: Int) = builder.addOffset(22, PROBABILITY_OF_COLLISION_THRESHOLD, 0)
        fun addCOLA_RUNS_REQUIRED(builder: FlatBufferBuilder, COLA_RUNS_REQUIRED: Int) = builder.addOffset(23, COLA_RUNS_REQUIRED, 0)
        fun addCOLA_POINTS_OF_CONTACT(builder: FlatBufferBuilder, COLA_POINTS_OF_CONTACT: Int) = builder.addOffset(24, COLA_POINTS_OF_CONTACT, 0)
        fun createColaPointsOfContactVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startColaPointsOfContactVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addORBITAL_PARAMETERS(builder: FlatBufferBuilder, ORBITAL_PARAMETERS: Int) = builder.addOffset(25, ORBITAL_PARAMETERS, 0)
        fun createOrbitalParametersVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startOrbitalParametersVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addBURN_OUT_VECTORS(builder: FlatBufferBuilder, BURN_OUT_VECTORS: Int) = builder.addOffset(26, BURN_OUT_VECTORS, 0)
        fun createBurnOutVectorsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startBurnOutVectorsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endLDM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishLDMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$LDM")
        fun finishSizePrefixedLDMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$LDM")
    }
}
