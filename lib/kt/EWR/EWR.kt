// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Electronic Warfare
 */
@Suppress("unused")
class EWR : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : EWR {
        __init(_i, _bb)
        return this
    }
    val SYSTEM_ID : UInt
        get() {
            val o = __offset(4)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val ENTITY_ID : UInt
        get() {
            val o = __offset(6)
            return if(o != 0) bb.getInt(o + bb_pos).toUInt() else 0u
        }
    val ESM_ACTIVE : Boolean
        get() {
            val o = __offset(8)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val ECM_ACTIVE : Boolean
        get() {
            val o = __offset(10)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    val RWR_ACTIVE : Boolean
        get() {
            val o = __offset(12)
            return if(o != 0) 0.toByte() != bb.get(o + bb_pos) else false
        }
    fun ESM_CONTACTS(j: Int) : String? {
        val o = __offset(14)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ESM_CONTACTSLength : Int
        get() {
            val o = __offset(14); return if (o != 0) __vector_len(o) else 0
        }
    fun ACTIVE_JAMMING(j: Int) : String? {
        val o = __offset(16)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val ACTIVE_JAMMINGLength : Int
        get() {
            val o = __offset(16); return if (o != 0) __vector_len(o) else 0
        }
    val COUNTERMEASURES : String?
        get() {
            val o = __offset(18)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val COUNTERMEASURESAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(18, 1)
    fun COUNTERMEASURESInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 18, 1)
    fun THREAT_WARNINGS(j: Int) : String? {
        val o = __offset(20)
        return if (o != 0) {
            __string(__vector(o) + j * 4)
        } else {
            null
        }
    }
    val THREAT_WARNINGSLength : Int
        get() {
            val o = __offset(20); return if (o != 0) __vector_len(o) else 0
        }
    val EMCON_LEVEL : UByte
        get() {
            val o = __offset(22)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val LAST_UPDATE_MS : Long
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getLong(o + bb_pos) else 0L
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsEWR(_bb: ByteBuffer): EWR = getRootAsEWR(_bb, EWR())
        fun getRootAsEWR(_bb: ByteBuffer, obj: EWR): EWR {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun EWRBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$EWR")
        fun createEWR(builder: FlatBufferBuilder, SYSTEM_ID: UInt, ENTITY_ID: UInt, ESM_ACTIVE: Boolean, ECM_ACTIVE: Boolean, RWR_ACTIVE: Boolean, ESM_CONTACTSOffset: Int, ACTIVE_JAMMINGOffset: Int, COUNTERMEASURESOffset: Int, THREAT_WARNINGSOffset: Int, EMCON_LEVEL: UByte, LAST_UPDATE_MS: Long) : Int {
            builder.startTable(11)
            addLAST_UPDATE_MS(builder, LAST_UPDATE_MS)
            addTHREAT_WARNINGS(builder, THREAT_WARNINGSOffset)
            addCOUNTERMEASURES(builder, COUNTERMEASURESOffset)
            addACTIVE_JAMMING(builder, ACTIVE_JAMMINGOffset)
            addESM_CONTACTS(builder, ESM_CONTACTSOffset)
            addENTITY_ID(builder, ENTITY_ID)
            addSYSTEM_ID(builder, SYSTEM_ID)
            addEMCON_LEVEL(builder, EMCON_LEVEL)
            addRWR_ACTIVE(builder, RWR_ACTIVE)
            addECM_ACTIVE(builder, ECM_ACTIVE)
            addESM_ACTIVE(builder, ESM_ACTIVE)
            return endEWR(builder)
        }
        fun startEWR(builder: FlatBufferBuilder) = builder.startTable(11)
        fun addSYSTEM_ID(builder: FlatBufferBuilder, SYSTEM_ID: UInt) = builder.addInt(0, SYSTEM_ID.toInt(), 0)
        fun addENTITY_ID(builder: FlatBufferBuilder, ENTITY_ID: UInt) = builder.addInt(1, ENTITY_ID.toInt(), 0)
        fun addESM_ACTIVE(builder: FlatBufferBuilder, ESM_ACTIVE: Boolean) = builder.addBoolean(2, ESM_ACTIVE, false)
        fun addECM_ACTIVE(builder: FlatBufferBuilder, ECM_ACTIVE: Boolean) = builder.addBoolean(3, ECM_ACTIVE, false)
        fun addRWR_ACTIVE(builder: FlatBufferBuilder, RWR_ACTIVE: Boolean) = builder.addBoolean(4, RWR_ACTIVE, false)
        fun addESM_CONTACTS(builder: FlatBufferBuilder, ESM_CONTACTS: Int) = builder.addOffset(5, ESM_CONTACTS, 0)
        fun createEsmContactsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startEsmContactsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addACTIVE_JAMMING(builder: FlatBufferBuilder, ACTIVE_JAMMING: Int) = builder.addOffset(6, ACTIVE_JAMMING, 0)
        fun createActiveJammingVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startActiveJammingVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addCOUNTERMEASURES(builder: FlatBufferBuilder, COUNTERMEASURES: Int) = builder.addOffset(7, COUNTERMEASURES, 0)
        fun addTHREAT_WARNINGS(builder: FlatBufferBuilder, THREAT_WARNINGS: Int) = builder.addOffset(8, THREAT_WARNINGS, 0)
        fun createThreatWarningsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startThreatWarningsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addEMCON_LEVEL(builder: FlatBufferBuilder, EMCON_LEVEL: UByte) = builder.addByte(9, EMCON_LEVEL.toByte(), 0)
        fun addLAST_UPDATE_MS(builder: FlatBufferBuilder, LAST_UPDATE_MS: Long) = builder.addLong(10, LAST_UPDATE_MS, 0L)
        fun endEWR(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishEWRBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$EWR")
        fun finishSizePrefixedEWRBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$EWR")
    }
}
