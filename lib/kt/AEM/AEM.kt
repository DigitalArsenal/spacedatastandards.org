// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

/**
 * Attitude Ephemeris Message
 */
@Suppress("unused")
class AEM : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : AEM {
        __init(_i, _bb)
        return this
    }
    val CCSDS_AEM_VERS : String?
        get() {
            val o = __offset(4)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CCSDS_AEM_VERSAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(4, 1)
    fun CCSDS_AEM_VERSInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 4, 1)
    val CREATION_DATE : String?
        get() {
            val o = __offset(6)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val CREATION_DATEAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(6, 1)
    fun CREATION_DATEInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 6, 1)
    val ORIGINATOR : String?
        get() {
            val o = __offset(8)
            return if (o != 0) {
                __string(o + bb_pos)
            } else {
                null
            }
        }
    val ORIGINATORAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(8, 1)
    fun ORIGINATORInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 8, 1)
    fun SEGMENTS(j: Int) : AEMSegment? = SEGMENTS(AEMSegment(), j)
    fun SEGMENTS(obj: AEMSegment, j: Int) : AEMSegment? {
        val o = __offset(10)
        return if (o != 0) {
            obj.__assign(__indirect(__vector(o) + j * 4), bb)
        } else {
            null
        }
    }
    val SEGMENTSLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_24_3_25()
        fun getRootAsAEM(_bb: ByteBuffer): AEM = getRootAsAEM(_bb, AEM())
        fun getRootAsAEM(_bb: ByteBuffer, obj: AEM): AEM {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun AEMBufferHasIdentifier(_bb: ByteBuffer) : Boolean = __has_identifier(_bb, "$AEM")
        fun createAEM(builder: FlatBufferBuilder, CCSDS_AEM_VERSOffset: Int, CREATION_DATEOffset: Int, ORIGINATOROffset: Int, SEGMENTSOffset: Int) : Int {
            builder.startTable(4)
            addSEGMENTS(builder, SEGMENTSOffset)
            addORIGINATOR(builder, ORIGINATOROffset)
            addCREATION_DATE(builder, CREATION_DATEOffset)
            addCCSDS_AEM_VERS(builder, CCSDS_AEM_VERSOffset)
            return endAEM(builder)
        }
        fun startAEM(builder: FlatBufferBuilder) = builder.startTable(4)
        fun addCCSDS_AEM_VERS(builder: FlatBufferBuilder, CCSDS_AEM_VERS: Int) = builder.addOffset(0, CCSDS_AEM_VERS, 0)
        fun addCREATION_DATE(builder: FlatBufferBuilder, CREATION_DATE: Int) = builder.addOffset(1, CREATION_DATE, 0)
        fun addORIGINATOR(builder: FlatBufferBuilder, ORIGINATOR: Int) = builder.addOffset(2, ORIGINATOR, 0)
        fun addSEGMENTS(builder: FlatBufferBuilder, SEGMENTS: Int) = builder.addOffset(3, SEGMENTS, 0)
        fun createSegmentsVector(builder: FlatBufferBuilder, data: IntArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addOffset(data[i])
            }
            return builder.endVector()
        }
        fun startSegmentsVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun endAEM(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
        fun finishAEMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finish(offset, "$AEM")
        fun finishSizePrefixedAEMBuffer(builder: FlatBufferBuilder, offset: Int) = builder.finishSizePrefixed(offset, "$AEM")
    }
}
