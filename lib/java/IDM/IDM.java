// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Integrated Device Message
 */
@SuppressWarnings("unused")
public final class IDM extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_3_3(); }
  public static IDM getRootAsIDM(ByteBuffer _bb) { return getRootAsIDM(_bb, new IDM()); }
  public static IDM getRootAsIDM(ByteBuffer _bb, IDM obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean IDMBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$IDM"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public IDM __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier for the EMT
   */
  public String ID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Name of the EMT
   */
  public String NAME() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NAMEAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer NAMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Mode of the data (real, simulated, synthetic)
   */
  public byte DATA_MODE() { int o = __offset(8); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Uplink frequency range
   */
  public FrequencyRange UPLINK() { return UPLINK(new FrequencyRange()); }
  public FrequencyRange UPLINK(FrequencyRange obj) { int o = __offset(10); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * Downlink frequency range
   */
  public FrequencyRange DOWNLINK() { return DOWNLINK(new FrequencyRange()); }
  public FrequencyRange DOWNLINK(FrequencyRange obj) { int o = __offset(12); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * Beacon frequency range
   */
  public FrequencyRange BEACON() { return BEACON(new FrequencyRange()); }
  public FrequencyRange BEACON(FrequencyRange obj) { int o = __offset(14); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * Bands associated with the EMT
   */
  public Band BAND(int j) { return BAND(new Band(), j); }
  public Band BAND(Band obj, int j) { int o = __offset(16); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int BANDLength() { int o = __offset(16); return o != 0 ? __vector_len(o) : 0; }
  public Band.Vector bandVector() { return bandVector(new Band.Vector()); }
  public Band.Vector bandVector(Band.Vector obj) { int o = __offset(16); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Type of polarization used
   */
  public byte POLARIZATION_TYPE() { int o = __offset(18); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Simple polarization configuration
   */
  public byte SIMPLE_POLARIZATION() { int o = __offset(20); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Stokes parameters for polarization characterization
   */
  public StokesParameters STOKES_PARAMETERS() { return STOKES_PARAMETERS(new StokesParameters()); }
  public StokesParameters STOKES_PARAMETERS(StokesParameters obj) { int o = __offset(22); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * Power required in Watts
   */
  public double POWER_REQUIRED() { int o = __offset(24); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Type of power (eg. AC or DC)
   */
  public String POWER_TYPE() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer POWER_TYPEAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer POWER_TYPEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * Indicates if the EMT can transmit
   */
  public boolean TRANSMIT() { int o = __offset(28); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Indicates if the EMT can receive
   */
  public boolean RECEIVE() { int o = __offset(30); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Type of the sensor
   */
  public byte SENSOR_TYPE() { int o = __offset(32); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Source of the data
   */
  public String SOURCE() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SOURCEAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer SOURCEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Timestamp of the last observation
   */
  public String LAST_OB_TIME() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer LAST_OB_TIMEAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer LAST_OB_TIMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Lower left elevation limit
   */
  public double LOWER_LEFT_ELEVATION_LIMIT() { int o = __offset(38); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Upper left azimuth limit
   */
  public double UPPER_LEFT_AZIMUTH_LIMIT() { int o = __offset(40); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Lower right elevation limit
   */
  public double LOWER_RIGHT_ELEVATION_LIMIT() { int o = __offset(42); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Lower left azimuth limit
   */
  public double LOWER_LEFT_AZIMUTH_LIMIT() { int o = __offset(44); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Upper right elevation limit
   */
  public double UPPER_RIGHT_ELEVATION_LIMIT() { int o = __offset(46); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Upper right azimuth limit
   */
  public double UPPER_RIGHT_AZIMUTH_LIMIT() { int o = __offset(48); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Lower right azimuth limit
   */
  public double LOWER_RIGHT_AZIMUTH_LIMIT() { int o = __offset(50); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Upper left elevation limit
   */
  public double UPPER_LEFT_ELEVATION_LIMIT() { int o = __offset(52); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Right geostationary belt limit
   */
  public double RIGHT_GEO_BELT_LIMIT() { int o = __offset(54); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Left geostationary belt limit
   */
  public double LEFT_GEO_BELT_LIMIT() { int o = __offset(56); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Magnitude limit of the sensor
   */
  public double MAGNITUDE_LIMIT() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Indicates if the site is taskable
   */
  public boolean TASKABLE() { int o = __offset(60); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }

  public static int createIDM(FlatBufferBuilder builder,
      int IDOffset,
      int NAMEOffset,
      byte DATA_MODE,
      int UPLINKOffset,
      int DOWNLINKOffset,
      int BEACONOffset,
      int BANDOffset,
      byte POLARIZATION_TYPE,
      byte SIMPLE_POLARIZATION,
      int STOKES_PARAMETERSOffset,
      double POWER_REQUIRED,
      int POWER_TYPEOffset,
      boolean TRANSMIT,
      boolean RECEIVE,
      byte SENSOR_TYPE,
      int SOURCEOffset,
      int LAST_OB_TIMEOffset,
      double LOWER_LEFT_ELEVATION_LIMIT,
      double UPPER_LEFT_AZIMUTH_LIMIT,
      double LOWER_RIGHT_ELEVATION_LIMIT,
      double LOWER_LEFT_AZIMUTH_LIMIT,
      double UPPER_RIGHT_ELEVATION_LIMIT,
      double UPPER_RIGHT_AZIMUTH_LIMIT,
      double LOWER_RIGHT_AZIMUTH_LIMIT,
      double UPPER_LEFT_ELEVATION_LIMIT,
      double RIGHT_GEO_BELT_LIMIT,
      double LEFT_GEO_BELT_LIMIT,
      double MAGNITUDE_LIMIT,
      boolean TASKABLE) {
    builder.startTable(29);
    IDM.addMagnitudeLimit(builder, MAGNITUDE_LIMIT);
    IDM.addLeftGeoBeltLimit(builder, LEFT_GEO_BELT_LIMIT);
    IDM.addRightGeoBeltLimit(builder, RIGHT_GEO_BELT_LIMIT);
    IDM.addUpperLeftElevationLimit(builder, UPPER_LEFT_ELEVATION_LIMIT);
    IDM.addLowerRightAzimuthLimit(builder, LOWER_RIGHT_AZIMUTH_LIMIT);
    IDM.addUpperRightAzimuthLimit(builder, UPPER_RIGHT_AZIMUTH_LIMIT);
    IDM.addUpperRightElevationLimit(builder, UPPER_RIGHT_ELEVATION_LIMIT);
    IDM.addLowerLeftAzimuthLimit(builder, LOWER_LEFT_AZIMUTH_LIMIT);
    IDM.addLowerRightElevationLimit(builder, LOWER_RIGHT_ELEVATION_LIMIT);
    IDM.addUpperLeftAzimuthLimit(builder, UPPER_LEFT_AZIMUTH_LIMIT);
    IDM.addLowerLeftElevationLimit(builder, LOWER_LEFT_ELEVATION_LIMIT);
    IDM.addPowerRequired(builder, POWER_REQUIRED);
    IDM.addLastObTime(builder, LAST_OB_TIMEOffset);
    IDM.addSource(builder, SOURCEOffset);
    IDM.addPowerType(builder, POWER_TYPEOffset);
    IDM.addStokesParameters(builder, STOKES_PARAMETERSOffset);
    IDM.addBand(builder, BANDOffset);
    IDM.addBeacon(builder, BEACONOffset);
    IDM.addDownlink(builder, DOWNLINKOffset);
    IDM.addUplink(builder, UPLINKOffset);
    IDM.addName(builder, NAMEOffset);
    IDM.addId(builder, IDOffset);
    IDM.addTaskable(builder, TASKABLE);
    IDM.addSensorType(builder, SENSOR_TYPE);
    IDM.addReceive(builder, RECEIVE);
    IDM.addTransmit(builder, TRANSMIT);
    IDM.addSimplePolarization(builder, SIMPLE_POLARIZATION);
    IDM.addPolarizationType(builder, POLARIZATION_TYPE);
    IDM.addDataMode(builder, DATA_MODE);
    return IDM.endIDM(builder);
  }

  public static void startIDM(FlatBufferBuilder builder) { builder.startTable(29); }
  public static void addId(FlatBufferBuilder builder, int IDOffset) { builder.addOffset(0, IDOffset, 0); }
  public static void addName(FlatBufferBuilder builder, int NAMEOffset) { builder.addOffset(1, NAMEOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte DATA_MODE) { builder.addByte(2, DATA_MODE, 0); }
  public static void addUplink(FlatBufferBuilder builder, int UPLINKOffset) { builder.addOffset(3, UPLINKOffset, 0); }
  public static void addDownlink(FlatBufferBuilder builder, int DOWNLINKOffset) { builder.addOffset(4, DOWNLINKOffset, 0); }
  public static void addBeacon(FlatBufferBuilder builder, int BEACONOffset) { builder.addOffset(5, BEACONOffset, 0); }
  public static void addBand(FlatBufferBuilder builder, int BANDOffset) { builder.addOffset(6, BANDOffset, 0); }
  public static int createBandVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startBandVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addPolarizationType(FlatBufferBuilder builder, byte POLARIZATION_TYPE) { builder.addByte(7, POLARIZATION_TYPE, 0); }
  public static void addSimplePolarization(FlatBufferBuilder builder, byte SIMPLE_POLARIZATION) { builder.addByte(8, SIMPLE_POLARIZATION, 0); }
  public static void addStokesParameters(FlatBufferBuilder builder, int STOKES_PARAMETERSOffset) { builder.addOffset(9, STOKES_PARAMETERSOffset, 0); }
  public static void addPowerRequired(FlatBufferBuilder builder, double POWER_REQUIRED) { builder.addDouble(10, POWER_REQUIRED, 0.0); }
  public static void addPowerType(FlatBufferBuilder builder, int POWER_TYPEOffset) { builder.addOffset(11, POWER_TYPEOffset, 0); }
  public static void addTransmit(FlatBufferBuilder builder, boolean TRANSMIT) { builder.addBoolean(12, TRANSMIT, false); }
  public static void addReceive(FlatBufferBuilder builder, boolean RECEIVE) { builder.addBoolean(13, RECEIVE, false); }
  public static void addSensorType(FlatBufferBuilder builder, byte SENSOR_TYPE) { builder.addByte(14, SENSOR_TYPE, 0); }
  public static void addSource(FlatBufferBuilder builder, int SOURCEOffset) { builder.addOffset(15, SOURCEOffset, 0); }
  public static void addLastObTime(FlatBufferBuilder builder, int LAST_OB_TIMEOffset) { builder.addOffset(16, LAST_OB_TIMEOffset, 0); }
  public static void addLowerLeftElevationLimit(FlatBufferBuilder builder, double LOWER_LEFT_ELEVATION_LIMIT) { builder.addDouble(17, LOWER_LEFT_ELEVATION_LIMIT, 0.0); }
  public static void addUpperLeftAzimuthLimit(FlatBufferBuilder builder, double UPPER_LEFT_AZIMUTH_LIMIT) { builder.addDouble(18, UPPER_LEFT_AZIMUTH_LIMIT, 0.0); }
  public static void addLowerRightElevationLimit(FlatBufferBuilder builder, double LOWER_RIGHT_ELEVATION_LIMIT) { builder.addDouble(19, LOWER_RIGHT_ELEVATION_LIMIT, 0.0); }
  public static void addLowerLeftAzimuthLimit(FlatBufferBuilder builder, double LOWER_LEFT_AZIMUTH_LIMIT) { builder.addDouble(20, LOWER_LEFT_AZIMUTH_LIMIT, 0.0); }
  public static void addUpperRightElevationLimit(FlatBufferBuilder builder, double UPPER_RIGHT_ELEVATION_LIMIT) { builder.addDouble(21, UPPER_RIGHT_ELEVATION_LIMIT, 0.0); }
  public static void addUpperRightAzimuthLimit(FlatBufferBuilder builder, double UPPER_RIGHT_AZIMUTH_LIMIT) { builder.addDouble(22, UPPER_RIGHT_AZIMUTH_LIMIT, 0.0); }
  public static void addLowerRightAzimuthLimit(FlatBufferBuilder builder, double LOWER_RIGHT_AZIMUTH_LIMIT) { builder.addDouble(23, LOWER_RIGHT_AZIMUTH_LIMIT, 0.0); }
  public static void addUpperLeftElevationLimit(FlatBufferBuilder builder, double UPPER_LEFT_ELEVATION_LIMIT) { builder.addDouble(24, UPPER_LEFT_ELEVATION_LIMIT, 0.0); }
  public static void addRightGeoBeltLimit(FlatBufferBuilder builder, double RIGHT_GEO_BELT_LIMIT) { builder.addDouble(25, RIGHT_GEO_BELT_LIMIT, 0.0); }
  public static void addLeftGeoBeltLimit(FlatBufferBuilder builder, double LEFT_GEO_BELT_LIMIT) { builder.addDouble(26, LEFT_GEO_BELT_LIMIT, 0.0); }
  public static void addMagnitudeLimit(FlatBufferBuilder builder, double MAGNITUDE_LIMIT) { builder.addDouble(27, MAGNITUDE_LIMIT, 0.0); }
  public static void addTaskable(FlatBufferBuilder builder, boolean TASKABLE) { builder.addBoolean(28, TASKABLE, false); }
  public static int endIDM(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishIDMBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$IDM"); }
  public static void finishSizePrefixedIDMBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$IDM"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public IDM get(int j) { return get(new IDM(), j); }
    public IDM get(IDM obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

