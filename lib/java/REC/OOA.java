// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * On-Orbit Antenna
 */
@SuppressWarnings("unused")
public final class OOA extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static OOA getRootAsOOA(ByteBuffer _bb) { return getRootAsOOA(_bb, new OOA()); }
  public static OOA getRootAsOOA(ByteBuffer _bb, OOA obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean OOABufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$OOA"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public OOA __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier
   */
  public String ID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Reference to parent on-orbit object
   */
  public String ID_ON_ORBIT() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_ON_ORBITAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer ID_ON_ORBITInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Reference to antenna specification
   */
  public String ID_ANTENNA() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_ANTENNAAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer ID_ANTENNAInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Antenna name or designation
   */
  public String NAME() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NAMEAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer NAMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Antenna type (e.g., PARABOLIC, PHASED_ARRAY, HORN, HELICAL, DIPOLE, PATCH, YAGI)
   */
  public String ANTENNA_TYPE() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ANTENNA_TYPEAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer ANTENNA_TYPEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Number of antennas of this type
   */
  public long QUANTITY() { int o = __offset(14); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * Operating frequency band (e.g., UHF, L, S, C, X, Ku, Ka, V, W)
   */
  public String BAND() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BANDAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer BANDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Minimum operating frequency in MHz
   */
  public double FREQ_MIN() { int o = __offset(18); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Maximum operating frequency in MHz
   */
  public double FREQ_MAX() { int o = __offset(20); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Antenna gain in dBi
   */
  public double GAIN() { int o = __offset(22); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Antenna diameter or aperture in meters
   */
  public double APERTURE() { int o = __offset(24); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Beamwidth in degrees
   */
  public double BEAMWIDTH() { int o = __offset(26); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Polarization type (e.g., LINEAR, CIRCULAR, DUAL, RHCP, LHCP)
   */
  public String POLARIZATION() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer POLARIZATIONAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer POLARIZATIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Whether the antenna is steerable
   */
  public boolean STEERABLE() { int o = __offset(30); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Maximum slew rate in degrees per second
   */
  public double SLEW_RATE() { int o = __offset(32); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Purpose or function (e.g., TT_C, PAYLOAD, CROSSLINK, GPS)
   */
  public String PURPOSE() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PURPOSEAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer PURPOSEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Additional notes
   */
  public String NOTES() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NOTESAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer NOTESInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }

  public static int createOOA(FlatBufferBuilder builder,
      int IDOffset,
      int ID_ON_ORBITOffset,
      int ID_ANTENNAOffset,
      int NAMEOffset,
      int ANTENNA_TYPEOffset,
      long QUANTITY,
      int BANDOffset,
      double FREQ_MIN,
      double FREQ_MAX,
      double GAIN,
      double APERTURE,
      double BEAMWIDTH,
      int POLARIZATIONOffset,
      boolean STEERABLE,
      double SLEW_RATE,
      int PURPOSEOffset,
      int NOTESOffset) {
    builder.startTable(17);
    OOA.addSlewRate(builder, SLEW_RATE);
    OOA.addBeamwidth(builder, BEAMWIDTH);
    OOA.addAperture(builder, APERTURE);
    OOA.addGain(builder, GAIN);
    OOA.addFreqMax(builder, FREQ_MAX);
    OOA.addFreqMin(builder, FREQ_MIN);
    OOA.addNotes(builder, NOTESOffset);
    OOA.addPurpose(builder, PURPOSEOffset);
    OOA.addPolarization(builder, POLARIZATIONOffset);
    OOA.addBand(builder, BANDOffset);
    OOA.addQuantity(builder, QUANTITY);
    OOA.addAntennaType(builder, ANTENNA_TYPEOffset);
    OOA.addName(builder, NAMEOffset);
    OOA.addIdAntenna(builder, ID_ANTENNAOffset);
    OOA.addIdOnOrbit(builder, ID_ON_ORBITOffset);
    OOA.addId(builder, IDOffset);
    OOA.addSteerable(builder, STEERABLE);
    return OOA.endOOA(builder);
  }

  public static void startOOA(FlatBufferBuilder builder) { builder.startTable(17); }
  public static void addId(FlatBufferBuilder builder, int IDOffset) { builder.addOffset(0, IDOffset, 0); }
  public static void addIdOnOrbit(FlatBufferBuilder builder, int ID_ON_ORBITOffset) { builder.addOffset(1, ID_ON_ORBITOffset, 0); }
  public static void addIdAntenna(FlatBufferBuilder builder, int ID_ANTENNAOffset) { builder.addOffset(2, ID_ANTENNAOffset, 0); }
  public static void addName(FlatBufferBuilder builder, int NAMEOffset) { builder.addOffset(3, NAMEOffset, 0); }
  public static void addAntennaType(FlatBufferBuilder builder, int ANTENNA_TYPEOffset) { builder.addOffset(4, ANTENNA_TYPEOffset, 0); }
  public static void addQuantity(FlatBufferBuilder builder, long QUANTITY) { builder.addInt(5, (int) QUANTITY, (int) 0L); }
  public static void addBand(FlatBufferBuilder builder, int BANDOffset) { builder.addOffset(6, BANDOffset, 0); }
  public static void addFreqMin(FlatBufferBuilder builder, double FREQ_MIN) { builder.addDouble(7, FREQ_MIN, 0.0); }
  public static void addFreqMax(FlatBufferBuilder builder, double FREQ_MAX) { builder.addDouble(8, FREQ_MAX, 0.0); }
  public static void addGain(FlatBufferBuilder builder, double GAIN) { builder.addDouble(9, GAIN, 0.0); }
  public static void addAperture(FlatBufferBuilder builder, double APERTURE) { builder.addDouble(10, APERTURE, 0.0); }
  public static void addBeamwidth(FlatBufferBuilder builder, double BEAMWIDTH) { builder.addDouble(11, BEAMWIDTH, 0.0); }
  public static void addPolarization(FlatBufferBuilder builder, int POLARIZATIONOffset) { builder.addOffset(12, POLARIZATIONOffset, 0); }
  public static void addSteerable(FlatBufferBuilder builder, boolean STEERABLE) { builder.addBoolean(13, STEERABLE, false); }
  public static void addSlewRate(FlatBufferBuilder builder, double SLEW_RATE) { builder.addDouble(14, SLEW_RATE, 0.0); }
  public static void addPurpose(FlatBufferBuilder builder, int PURPOSEOffset) { builder.addOffset(15, PURPOSEOffset, 0); }
  public static void addNotes(FlatBufferBuilder builder, int NOTESOffset) { builder.addOffset(16, NOTESOffset, 0); }
  public static int endOOA(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishOOABuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$OOA"); }
  public static void finishSizePrefixedOOABuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$OOA"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public OOA get(int j) { return get(new OOA(), j); }
    public OOA get(OOA obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

