// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Collection Request Message
 */
@SuppressWarnings("unused")
public final class CRM extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static CRM getRootAsCRM(ByteBuffer _bb) { return getRootAsCRM(_bb, new CRM()); }
  public static CRM getRootAsCRM(ByteBuffer _bb, CRM obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean CRMBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$CRM"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public CRM __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   */
  public String ID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   */
  public String CLASSIFICATION() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CLASSIFICATIONAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer CLASSIFICATIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The type of this collect or contact request.
   */
  public String TYPE() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TYPEAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer TYPEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Unique identifier of the parent plan or schedule associated with this request.
   */
  public String ID_PLAN() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_PLANAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer ID_PLANInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Index number for records within a collection plan or schedule.
   */
  public int PLAN_INDEX() { int o = __offset(12); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Task ID associated with this request.
   */
  public String TASK_ID() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TASK_IDAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer TASK_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * The dwell ID associated with this request.
   */
  public String DWELL_ID() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DWELL_IDAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer DWELL_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Optional ID from external systems.
   */
  public String EXTERNAL_ID() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer EXTERNAL_IDAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer EXTERNAL_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * Unique identifier of the requested/scheduled/planned sensor associated with this request.
   */
  public String ID_SENSOR() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_SENSORAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer ID_SENSORInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
   */
  public String ORIG_SENSOR_ID() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIG_SENSOR_IDAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer ORIG_SENSOR_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * Optional type of observation requested.
   */
  public String OB_TYPE() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer OB_TYPEAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer OB_TYPEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * The priority of the collect request.
   */
  public String PRIORITY() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PRIORITYAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer PRIORITYInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * The tasking category associated with this request.
   */
  public int TASK_CATEGORY() { int o = __offset(28); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The tasking suffix associated with this request.
   */
  public String SUFFIX() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SUFFIXAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer SUFFIXInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * Boolean indicating that this collect request is UCT follow-up.
   */
  public boolean UCT_FOLLOW_UP() { int o = __offset(32); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The start time of the collect or contact request window, in ISO 8601 UTC format.
   */
  public String START_TIME() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer START_TIMEAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer START_TIMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * The end time of the collect or contact request window, in ISO 8601 UTC format.
   */
  public String END_TIME() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer END_TIMEAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer END_TIMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Satellite/catalog number of the target on-orbit object for this request.
   */
  public long NORAD_CAT_ID() { int o = __offset(38); return o != 0 ? (long)bb.getInt(o + bb_pos) & 0xFFFFFFFFL : 0L; }
  /**
   * Optional identifier provided by the data source to indicate the target object of this request.
   */
  public String ORIG_OBJECT_ID() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIG_OBJECT_IDAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer ORIG_OBJECT_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * The tasking group to which the target object is assigned.
   */
  public String TASK_GROUP() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TASK_GROUPAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer TASK_GROUPInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * Inter-Range Operations Number.
   */
  public int IRON() { int o = __offset(44); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The orbit regime of the target.
   */
  public String ORBIT_REGIME() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORBIT_REGIMEAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer ORBIT_REGIMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * The minimum object (diameter) size, in meters, to be reported.
   */
  public double TARGET_SIZE() { int o = __offset(48); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The minimum Radar Cross-Section of the target, in m^2.
   */
  public double RCS_MIN() { int o = __offset(50); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Radar Cross-Section of the target, in m^2.
   */
  public double RCS() { int o = __offset(52); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum Radar Cross-Section of the target, in m^2.
   */
  public double RCS_MAX() { int o = __offset(54); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The minimum frequency of interest, in MHz.
   */
  public double FREQ_MIN() { int o = __offset(56); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The estimated or expected emission frequency of the target, in MHz.
   */
  public double FREQ() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum frequency of interest, in MHz.
   */
  public double FREQ_MAX() { int o = __offset(60); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The RF polarization.
   */
  public String POLARIZATION() { int o = __offset(62); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer POLARIZATIONAsByteBuffer() { return __vector_as_bytebuffer(62, 1); }
  public ByteBuffer POLARIZATIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 62, 1); }
  /**
   * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
   */
  public double VIS_MAG_MIN() { int o = __offset(64); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The estimated or expected visual magnitude of the target, in Magnitudes (M).
   */
  public double VIS_MAG() { int o = __offset(66); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
   */
  public double VIS_MAG_MAX() { int o = __offset(68); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The spectral model used for the irradiance calculation.
   */
  public String SPECTRAL_MODEL() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SPECTRAL_MODELAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer SPECTRAL_MODELInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * The fraction of solar energy reflected from target.
   */
  public double REFLECTANCE() { int o = __offset(72); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The target object irradiance value.
   */
  public double IRRADIANCE() { int o = __offset(74); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * For optical sensors, the requested number of frames to capture at each sensor step.
   */
  public int NUM_FRAMES() { int o = __offset(76); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * For optical sensors, the frame rate of the camera, in Hz.
   */
  public double FRAME_RATE() { int o = __offset(78); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * For optical sensors, the integration time per camera frame, in milliseconds.
   */
  public double INTEGRATION_TIME() { int o = __offset(80); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The number of requested tracks on the target.
   */
  public int NUM_TRACKS() { int o = __offset(82); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of requested observations on the target.
   */
  public int NUM_OBS() { int o = __offset(84); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The duration of the collect request, in seconds.
   */
  public int DURATION() { int o = __offset(86); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The search pattern to be executed for this request.
   */
  public String SRCH_PATTERN() { int o = __offset(88); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SRCH_PATTERNAsByteBuffer() { return __vector_as_bytebuffer(88, 1); }
  public ByteBuffer SRCH_PATTERNInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 88, 1); }
  /**
   * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
   */
  public String SCENARIO() { int o = __offset(90); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SCENARIOAsByteBuffer() { return __vector_as_bytebuffer(90, 1); }
  public ByteBuffer SCENARIOInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 90, 1); }
  /**
   * ID of the Elset of the object associated with this request.
   */
  public String ID_ELSET() { int o = __offset(92); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_ELSETAsByteBuffer() { return __vector_as_bytebuffer(92, 1); }
  public ByteBuffer ID_ELSETInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 92, 1); }
  /**
   * ID of the Manifold Elset of the object associated with this request.
   */
  public String ID_MANIFOLD() { int o = __offset(94); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_MANIFOLDAsByteBuffer() { return __vector_as_bytebuffer(94, 1); }
  public ByteBuffer ID_MANIFOLDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 94, 1); }
  /**
   * ID of the State Vector of the object or central vector associated with this request.
   */
  public String ID_STATE_VECTOR() { int o = __offset(96); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_STATE_VECTORAsByteBuffer() { return __vector_as_bytebuffer(96, 1); }
  public ByteBuffer ID_STATE_VECTORInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 96, 1); }
  /**
   * ID of the Ephemeris Set of the object associated with this request.
   */
  public String ES_ID() { int o = __offset(98); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ES_IDAsByteBuffer() { return __vector_as_bytebuffer(98, 1); }
  public ByteBuffer ES_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 98, 1); }
  /**
   * Epoch time, in ISO 8601 UTC format, of the orbital elements.
   */
  public String EPOCH() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer EPOCHAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer EPOCHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * The average of the periapsis and apoapsis distances, in kilometers.
   */
  public double SEMI_MAJOR_AXIS() { int o = __offset(102); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The orbital eccentricity of an astronomical object.
   */
  public double ECCENTRICITY() { int o = __offset(104); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angle, in degrees, between the equator and the orbit plane.
   */
  public double INCLINATION() { int o = __offset(106); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Right ascension of the ascending node, in degrees.
   */
  public double RAAN() { int o = __offset(108); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The argument of perigee, in degrees.
   */
  public double ARG_OF_PERIGEE() { int o = __offset(110); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
   */
  public double MEAN_ANOMALY() { int o = __offset(112); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed right ascension angle, in degrees.
   */
  public double RA() { int o = __offset(114); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed declination angle, in degrees.
   */
  public double DEC() { int o = __offset(116); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed azimuth angle, in degrees.
   */
  public double AZ() { int o = __offset(118); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed elevation angle, in degrees.
   */
  public double EL() { int o = __offset(120); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected acquisition range or defined center range, in km.
   */
  public double RANGE() { int o = __offset(122); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the azimuth angle, in degrees, from center azimuth.
   */
  public double EXTENT_AZ() { int o = __offset(124); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the elevation angle, in degrees, from center elevation.
   */
  public double EXTENT_EL() { int o = __offset(126); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the range, in km, from center range.
   */
  public double EXTENT_RANGE() { int o = __offset(128); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 latitude, in degrees.
   */
  public double LAT() { int o = __offset(130); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude, in degrees.
   */
  public double LON() { int o = __offset(132); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Height above WGS-84 ellipsoid (HAE), in kilometers.
   */
  public double ALT() { int o = __offset(134); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping WGS-84 latitude of a volume definition, in degrees.
   */
  public double STOP_LAT() { int o = __offset(136); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping WGS-84 longitude of a volume definition, in degrees.
   */
  public double STOP_LON() { int o = __offset(138); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
   */
  public double STOP_ALT() { int o = __offset(140); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum inclination, in degrees, to be used in search operations.
   */
  public double SRCH_INC() { int o = __offset(142); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angular distance, in degrees, in the sensor-x direction from scan center.
   */
  public double X_ANGLE() { int o = __offset(144); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angular distance, in degrees, in the sensor-y direction from scan center.
   */
  public double Y_ANGLE() { int o = __offset(146); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
   */
  public double ORIENT_ANGLE() { int o = __offset(148); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The customer for this request.
   */
  public String CUSTOMER() { int o = __offset(150); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CUSTOMERAsByteBuffer() { return __vector_as_bytebuffer(150, 1); }
  public ByteBuffer CUSTOMERInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 150, 1); }
  /**
   * Notes or comments associated with this request.
   */
  public String NOTES() { int o = __offset(152); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NOTESAsByteBuffer() { return __vector_as_bytebuffer(152, 1); }
  public ByteBuffer NOTESInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 152, 1); }
  /**
   *  Source of the data.
   */
  public String SOURCE() { int o = __offset(154); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SOURCEAsByteBuffer() { return __vector_as_bytebuffer(154, 1); }
  public ByteBuffer SOURCEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 154, 1); }
  /**
   *  Originating system or organization which produced the data, if different from the source.
   */
  public String ORIGIN() { int o = __offset(156); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIGINAsByteBuffer() { return __vector_as_bytebuffer(156, 1); }
  public ByteBuffer ORIGINInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 156, 1); }
  /**
   *  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
   */
  public String DATA_MODE() { int o = __offset(158); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DATA_MODEAsByteBuffer() { return __vector_as_bytebuffer(158, 1); }
  public ByteBuffer DATA_MODEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 158, 1); }

  public static int createCRM(FlatBufferBuilder builder,
      int IDOffset,
      int CLASSIFICATIONOffset,
      int TYPEOffset,
      int ID_PLANOffset,
      int PLAN_INDEX,
      int TASK_IDOffset,
      int DWELL_IDOffset,
      int EXTERNAL_IDOffset,
      int ID_SENSOROffset,
      int ORIG_SENSOR_IDOffset,
      int OB_TYPEOffset,
      int PRIORITYOffset,
      int TASK_CATEGORY,
      int SUFFIXOffset,
      boolean UCT_FOLLOW_UP,
      int START_TIMEOffset,
      int END_TIMEOffset,
      long NORAD_CAT_ID,
      int ORIG_OBJECT_IDOffset,
      int TASK_GROUPOffset,
      int IRON,
      int ORBIT_REGIMEOffset,
      double TARGET_SIZE,
      double RCS_MIN,
      double RCS,
      double RCS_MAX,
      double FREQ_MIN,
      double FREQ,
      double FREQ_MAX,
      int POLARIZATIONOffset,
      double VIS_MAG_MIN,
      double VIS_MAG,
      double VIS_MAG_MAX,
      int SPECTRAL_MODELOffset,
      double REFLECTANCE,
      double IRRADIANCE,
      int NUM_FRAMES,
      double FRAME_RATE,
      double INTEGRATION_TIME,
      int NUM_TRACKS,
      int NUM_OBS,
      int DURATION,
      int SRCH_PATTERNOffset,
      int SCENARIOOffset,
      int ID_ELSETOffset,
      int ID_MANIFOLDOffset,
      int ID_STATE_VECTOROffset,
      int ES_IDOffset,
      int EPOCHOffset,
      double SEMI_MAJOR_AXIS,
      double ECCENTRICITY,
      double INCLINATION,
      double RAAN,
      double ARG_OF_PERIGEE,
      double MEAN_ANOMALY,
      double RA,
      double DEC,
      double AZ,
      double EL,
      double RANGE,
      double EXTENT_AZ,
      double EXTENT_EL,
      double EXTENT_RANGE,
      double LAT,
      double LON,
      double ALT,
      double STOP_LAT,
      double STOP_LON,
      double STOP_ALT,
      double SRCH_INC,
      double X_ANGLE,
      double Y_ANGLE,
      double ORIENT_ANGLE,
      int CUSTOMEROffset,
      int NOTESOffset,
      int SOURCEOffset,
      int ORIGINOffset,
      int DATA_MODEOffset) {
    builder.startTable(78);
    CRM.addOrientAngle(builder, ORIENT_ANGLE);
    CRM.addYAngle(builder, Y_ANGLE);
    CRM.addXAngle(builder, X_ANGLE);
    CRM.addSrchInc(builder, SRCH_INC);
    CRM.addStopAlt(builder, STOP_ALT);
    CRM.addStopLon(builder, STOP_LON);
    CRM.addStopLat(builder, STOP_LAT);
    CRM.addAlt(builder, ALT);
    CRM.addLon(builder, LON);
    CRM.addLat(builder, LAT);
    CRM.addExtentRange(builder, EXTENT_RANGE);
    CRM.addExtentEl(builder, EXTENT_EL);
    CRM.addExtentAz(builder, EXTENT_AZ);
    CRM.addRange(builder, RANGE);
    CRM.addEl(builder, EL);
    CRM.addAz(builder, AZ);
    CRM.addDec(builder, DEC);
    CRM.addRa(builder, RA);
    CRM.addMeanAnomaly(builder, MEAN_ANOMALY);
    CRM.addArgOfPerigee(builder, ARG_OF_PERIGEE);
    CRM.addRaan(builder, RAAN);
    CRM.addInclination(builder, INCLINATION);
    CRM.addEccentricity(builder, ECCENTRICITY);
    CRM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
    CRM.addIntegrationTime(builder, INTEGRATION_TIME);
    CRM.addFrameRate(builder, FRAME_RATE);
    CRM.addIrradiance(builder, IRRADIANCE);
    CRM.addReflectance(builder, REFLECTANCE);
    CRM.addVisMagMax(builder, VIS_MAG_MAX);
    CRM.addVisMag(builder, VIS_MAG);
    CRM.addVisMagMin(builder, VIS_MAG_MIN);
    CRM.addFreqMax(builder, FREQ_MAX);
    CRM.addFreq(builder, FREQ);
    CRM.addFreqMin(builder, FREQ_MIN);
    CRM.addRcsMax(builder, RCS_MAX);
    CRM.addRcs(builder, RCS);
    CRM.addRcsMin(builder, RCS_MIN);
    CRM.addTargetSize(builder, TARGET_SIZE);
    CRM.addDataMode(builder, DATA_MODEOffset);
    CRM.addOrigin(builder, ORIGINOffset);
    CRM.addSource(builder, SOURCEOffset);
    CRM.addNotes(builder, NOTESOffset);
    CRM.addCustomer(builder, CUSTOMEROffset);
    CRM.addEpoch(builder, EPOCHOffset);
    CRM.addEsId(builder, ES_IDOffset);
    CRM.addIdStateVector(builder, ID_STATE_VECTOROffset);
    CRM.addIdManifold(builder, ID_MANIFOLDOffset);
    CRM.addIdElset(builder, ID_ELSETOffset);
    CRM.addScenario(builder, SCENARIOOffset);
    CRM.addSrchPattern(builder, SRCH_PATTERNOffset);
    CRM.addDuration(builder, DURATION);
    CRM.addNumObs(builder, NUM_OBS);
    CRM.addNumTracks(builder, NUM_TRACKS);
    CRM.addNumFrames(builder, NUM_FRAMES);
    CRM.addSpectralModel(builder, SPECTRAL_MODELOffset);
    CRM.addPolarization(builder, POLARIZATIONOffset);
    CRM.addOrbitRegime(builder, ORBIT_REGIMEOffset);
    CRM.addIron(builder, IRON);
    CRM.addTaskGroup(builder, TASK_GROUPOffset);
    CRM.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
    CRM.addNoradCatId(builder, NORAD_CAT_ID);
    CRM.addEndTime(builder, END_TIMEOffset);
    CRM.addStartTime(builder, START_TIMEOffset);
    CRM.addSuffix(builder, SUFFIXOffset);
    CRM.addTaskCategory(builder, TASK_CATEGORY);
    CRM.addPriority(builder, PRIORITYOffset);
    CRM.addObType(builder, OB_TYPEOffset);
    CRM.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
    CRM.addIdSensor(builder, ID_SENSOROffset);
    CRM.addExternalId(builder, EXTERNAL_IDOffset);
    CRM.addDwellId(builder, DWELL_IDOffset);
    CRM.addTaskId(builder, TASK_IDOffset);
    CRM.addPlanIndex(builder, PLAN_INDEX);
    CRM.addIdPlan(builder, ID_PLANOffset);
    CRM.addType(builder, TYPEOffset);
    CRM.addClassification(builder, CLASSIFICATIONOffset);
    CRM.addId(builder, IDOffset);
    CRM.addUctFollowUp(builder, UCT_FOLLOW_UP);
    return CRM.endCRM(builder);
  }

  public static void startCRM(FlatBufferBuilder builder) { builder.startTable(78); }
  public static void addId(FlatBufferBuilder builder, int IDOffset) { builder.addOffset(0, IDOffset, 0); }
  public static void addClassification(FlatBufferBuilder builder, int CLASSIFICATIONOffset) { builder.addOffset(1, CLASSIFICATIONOffset, 0); }
  public static void addType(FlatBufferBuilder builder, int TYPEOffset) { builder.addOffset(2, TYPEOffset, 0); }
  public static void addIdPlan(FlatBufferBuilder builder, int ID_PLANOffset) { builder.addOffset(3, ID_PLANOffset, 0); }
  public static void addPlanIndex(FlatBufferBuilder builder, int PLAN_INDEX) { builder.addInt(4, PLAN_INDEX, 0); }
  public static void addTaskId(FlatBufferBuilder builder, int TASK_IDOffset) { builder.addOffset(5, TASK_IDOffset, 0); }
  public static void addDwellId(FlatBufferBuilder builder, int DWELL_IDOffset) { builder.addOffset(6, DWELL_IDOffset, 0); }
  public static void addExternalId(FlatBufferBuilder builder, int EXTERNAL_IDOffset) { builder.addOffset(7, EXTERNAL_IDOffset, 0); }
  public static void addIdSensor(FlatBufferBuilder builder, int ID_SENSOROffset) { builder.addOffset(8, ID_SENSOROffset, 0); }
  public static void addOrigSensorId(FlatBufferBuilder builder, int ORIG_SENSOR_IDOffset) { builder.addOffset(9, ORIG_SENSOR_IDOffset, 0); }
  public static void addObType(FlatBufferBuilder builder, int OB_TYPEOffset) { builder.addOffset(10, OB_TYPEOffset, 0); }
  public static void addPriority(FlatBufferBuilder builder, int PRIORITYOffset) { builder.addOffset(11, PRIORITYOffset, 0); }
  public static void addTaskCategory(FlatBufferBuilder builder, int TASK_CATEGORY) { builder.addInt(12, TASK_CATEGORY, 0); }
  public static void addSuffix(FlatBufferBuilder builder, int SUFFIXOffset) { builder.addOffset(13, SUFFIXOffset, 0); }
  public static void addUctFollowUp(FlatBufferBuilder builder, boolean UCT_FOLLOW_UP) { builder.addBoolean(14, UCT_FOLLOW_UP, false); }
  public static void addStartTime(FlatBufferBuilder builder, int START_TIMEOffset) { builder.addOffset(15, START_TIMEOffset, 0); }
  public static void addEndTime(FlatBufferBuilder builder, int END_TIMEOffset) { builder.addOffset(16, END_TIMEOffset, 0); }
  public static void addNoradCatId(FlatBufferBuilder builder, long NORAD_CAT_ID) { builder.addInt(17, (int) NORAD_CAT_ID, (int) 0L); }
  public static void addOrigObjectId(FlatBufferBuilder builder, int ORIG_OBJECT_IDOffset) { builder.addOffset(18, ORIG_OBJECT_IDOffset, 0); }
  public static void addTaskGroup(FlatBufferBuilder builder, int TASK_GROUPOffset) { builder.addOffset(19, TASK_GROUPOffset, 0); }
  public static void addIron(FlatBufferBuilder builder, int IRON) { builder.addInt(20, IRON, 0); }
  public static void addOrbitRegime(FlatBufferBuilder builder, int ORBIT_REGIMEOffset) { builder.addOffset(21, ORBIT_REGIMEOffset, 0); }
  public static void addTargetSize(FlatBufferBuilder builder, double TARGET_SIZE) { builder.addDouble(22, TARGET_SIZE, 0.0); }
  public static void addRcsMin(FlatBufferBuilder builder, double RCS_MIN) { builder.addDouble(23, RCS_MIN, 0.0); }
  public static void addRcs(FlatBufferBuilder builder, double RCS) { builder.addDouble(24, RCS, 0.0); }
  public static void addRcsMax(FlatBufferBuilder builder, double RCS_MAX) { builder.addDouble(25, RCS_MAX, 0.0); }
  public static void addFreqMin(FlatBufferBuilder builder, double FREQ_MIN) { builder.addDouble(26, FREQ_MIN, 0.0); }
  public static void addFreq(FlatBufferBuilder builder, double FREQ) { builder.addDouble(27, FREQ, 0.0); }
  public static void addFreqMax(FlatBufferBuilder builder, double FREQ_MAX) { builder.addDouble(28, FREQ_MAX, 0.0); }
  public static void addPolarization(FlatBufferBuilder builder, int POLARIZATIONOffset) { builder.addOffset(29, POLARIZATIONOffset, 0); }
  public static void addVisMagMin(FlatBufferBuilder builder, double VIS_MAG_MIN) { builder.addDouble(30, VIS_MAG_MIN, 0.0); }
  public static void addVisMag(FlatBufferBuilder builder, double VIS_MAG) { builder.addDouble(31, VIS_MAG, 0.0); }
  public static void addVisMagMax(FlatBufferBuilder builder, double VIS_MAG_MAX) { builder.addDouble(32, VIS_MAG_MAX, 0.0); }
  public static void addSpectralModel(FlatBufferBuilder builder, int SPECTRAL_MODELOffset) { builder.addOffset(33, SPECTRAL_MODELOffset, 0); }
  public static void addReflectance(FlatBufferBuilder builder, double REFLECTANCE) { builder.addDouble(34, REFLECTANCE, 0.0); }
  public static void addIrradiance(FlatBufferBuilder builder, double IRRADIANCE) { builder.addDouble(35, IRRADIANCE, 0.0); }
  public static void addNumFrames(FlatBufferBuilder builder, int NUM_FRAMES) { builder.addInt(36, NUM_FRAMES, 0); }
  public static void addFrameRate(FlatBufferBuilder builder, double FRAME_RATE) { builder.addDouble(37, FRAME_RATE, 0.0); }
  public static void addIntegrationTime(FlatBufferBuilder builder, double INTEGRATION_TIME) { builder.addDouble(38, INTEGRATION_TIME, 0.0); }
  public static void addNumTracks(FlatBufferBuilder builder, int NUM_TRACKS) { builder.addInt(39, NUM_TRACKS, 0); }
  public static void addNumObs(FlatBufferBuilder builder, int NUM_OBS) { builder.addInt(40, NUM_OBS, 0); }
  public static void addDuration(FlatBufferBuilder builder, int DURATION) { builder.addInt(41, DURATION, 0); }
  public static void addSrchPattern(FlatBufferBuilder builder, int SRCH_PATTERNOffset) { builder.addOffset(42, SRCH_PATTERNOffset, 0); }
  public static void addScenario(FlatBufferBuilder builder, int SCENARIOOffset) { builder.addOffset(43, SCENARIOOffset, 0); }
  public static void addIdElset(FlatBufferBuilder builder, int ID_ELSETOffset) { builder.addOffset(44, ID_ELSETOffset, 0); }
  public static void addIdManifold(FlatBufferBuilder builder, int ID_MANIFOLDOffset) { builder.addOffset(45, ID_MANIFOLDOffset, 0); }
  public static void addIdStateVector(FlatBufferBuilder builder, int ID_STATE_VECTOROffset) { builder.addOffset(46, ID_STATE_VECTOROffset, 0); }
  public static void addEsId(FlatBufferBuilder builder, int ES_IDOffset) { builder.addOffset(47, ES_IDOffset, 0); }
  public static void addEpoch(FlatBufferBuilder builder, int EPOCHOffset) { builder.addOffset(48, EPOCHOffset, 0); }
  public static void addSemiMajorAxis(FlatBufferBuilder builder, double SEMI_MAJOR_AXIS) { builder.addDouble(49, SEMI_MAJOR_AXIS, 0.0); }
  public static void addEccentricity(FlatBufferBuilder builder, double ECCENTRICITY) { builder.addDouble(50, ECCENTRICITY, 0.0); }
  public static void addInclination(FlatBufferBuilder builder, double INCLINATION) { builder.addDouble(51, INCLINATION, 0.0); }
  public static void addRaan(FlatBufferBuilder builder, double RAAN) { builder.addDouble(52, RAAN, 0.0); }
  public static void addArgOfPerigee(FlatBufferBuilder builder, double ARG_OF_PERIGEE) { builder.addDouble(53, ARG_OF_PERIGEE, 0.0); }
  public static void addMeanAnomaly(FlatBufferBuilder builder, double MEAN_ANOMALY) { builder.addDouble(54, MEAN_ANOMALY, 0.0); }
  public static void addRa(FlatBufferBuilder builder, double RA) { builder.addDouble(55, RA, 0.0); }
  public static void addDec(FlatBufferBuilder builder, double DEC) { builder.addDouble(56, DEC, 0.0); }
  public static void addAz(FlatBufferBuilder builder, double AZ) { builder.addDouble(57, AZ, 0.0); }
  public static void addEl(FlatBufferBuilder builder, double EL) { builder.addDouble(58, EL, 0.0); }
  public static void addRange(FlatBufferBuilder builder, double RANGE) { builder.addDouble(59, RANGE, 0.0); }
  public static void addExtentAz(FlatBufferBuilder builder, double EXTENT_AZ) { builder.addDouble(60, EXTENT_AZ, 0.0); }
  public static void addExtentEl(FlatBufferBuilder builder, double EXTENT_EL) { builder.addDouble(61, EXTENT_EL, 0.0); }
  public static void addExtentRange(FlatBufferBuilder builder, double EXTENT_RANGE) { builder.addDouble(62, EXTENT_RANGE, 0.0); }
  public static void addLat(FlatBufferBuilder builder, double LAT) { builder.addDouble(63, LAT, 0.0); }
  public static void addLon(FlatBufferBuilder builder, double LON) { builder.addDouble(64, LON, 0.0); }
  public static void addAlt(FlatBufferBuilder builder, double ALT) { builder.addDouble(65, ALT, 0.0); }
  public static void addStopLat(FlatBufferBuilder builder, double STOP_LAT) { builder.addDouble(66, STOP_LAT, 0.0); }
  public static void addStopLon(FlatBufferBuilder builder, double STOP_LON) { builder.addDouble(67, STOP_LON, 0.0); }
  public static void addStopAlt(FlatBufferBuilder builder, double STOP_ALT) { builder.addDouble(68, STOP_ALT, 0.0); }
  public static void addSrchInc(FlatBufferBuilder builder, double SRCH_INC) { builder.addDouble(69, SRCH_INC, 0.0); }
  public static void addXAngle(FlatBufferBuilder builder, double X_ANGLE) { builder.addDouble(70, X_ANGLE, 0.0); }
  public static void addYAngle(FlatBufferBuilder builder, double Y_ANGLE) { builder.addDouble(71, Y_ANGLE, 0.0); }
  public static void addOrientAngle(FlatBufferBuilder builder, double ORIENT_ANGLE) { builder.addDouble(72, ORIENT_ANGLE, 0.0); }
  public static void addCustomer(FlatBufferBuilder builder, int CUSTOMEROffset) { builder.addOffset(73, CUSTOMEROffset, 0); }
  public static void addNotes(FlatBufferBuilder builder, int NOTESOffset) { builder.addOffset(74, NOTESOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int SOURCEOffset) { builder.addOffset(75, SOURCEOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int ORIGINOffset) { builder.addOffset(76, ORIGINOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, int DATA_MODEOffset) { builder.addOffset(77, DATA_MODEOffset, 0); }
  public static int endCRM(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishCRMBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$CRM"); }
  public static void finishSizePrefixedCRMBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$CRM"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public CRM get(int j) { return get(new CRM(), j); }
    public CRM get(CRM obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

