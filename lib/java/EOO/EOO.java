// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Electro-Optical Observation
 */
@SuppressWarnings("unused")
public final class EOO extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static EOO getRootAsEOO(ByteBuffer _bb) { return getRootAsEOO(_bb, new EOO()); }
  public static EOO getRootAsEOO(ByteBuffer _bb, EOO obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean EOOBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$EOO"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public EOO __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record.
   */
  public String ID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   */
  public String CLASSIFICATION() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CLASSIFICATIONAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer CLASSIFICATIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
   */
  public String OB_TIME() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer OB_TIMEAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer OB_TIMEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Correlation score of the observation when compared to a known orbit state.
   */
  public float CORR_QUALITY() { int o = __offset(10); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Server will auto-populate with SAT_NO if available.
   */
  public String ID_ON_ORBIT() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ID_ON_ORBITAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer ID_ON_ORBITInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Unique ID of the sensor. Must have a corresponding sensor record on the server.
   */
  public String SENSOR_ID() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SENSOR_IDAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer SENSOR_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Accepted Collection Method
   */
  public byte COLLECT_METHOD() { int o = __offset(16); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
   */
  public int NORAD_CAT_ID() { int o = __offset(18); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Identifier for the collectRequest message if the collection was in response to tasking.
   */
  public String TASK_ID() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TASK_IDAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer TASK_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * Optional identifier to track a transaction.
   */
  public String TRANSACTION_ID() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TRANSACTION_IDAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer TRANSACTION_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * The user-defined set ID of a sequence of images.
   */
  public String IMAGE_SET_ID() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IMAGE_SET_IDAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer IMAGE_SET_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * The number of images in an image set.
   */
  public int IMAGE_SET_LENGTH() { int o = __offset(26); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The sequence ID of an image within an image set.
   */
  public int SEQUENCE_ID() { int o = __offset(28); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
   */
  public byte OB_POSITION() { int o = __offset(30); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Provider maintained ID. May not be consistent with 18SDS SAT_NO.
   */
  public String ORIG_OBJECT_ID() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIG_OBJECT_IDAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer ORIG_OBJECT_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * Sensor ID.
   */
  public String ORIG_SENSOR_ID() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIG_SENSOR_IDAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer ORIG_SENSOR_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Required if correlation is attempted. Indicates whether correlation succeeded.
   */
  public boolean UCT() { int o = __offset(36); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Line of sight azimuth angle in degrees and topocentric frame.
   */
  public float AZIMUTH() { int o = __offset(38); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight azimuth angle, in degrees.
   */
  public float AZIMUTH_UNC() { int o = __offset(40); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor line of sight azimuth angle bias in degrees.
   */
  public float AZIMUTH_BIAS() { int o = __offset(42); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Rate of change of the line of sight azimuth in degrees per second.
   */
  public float AZIMUTH_RATE() { int o = __offset(44); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Line of sight elevation in degrees and topocentric frame.
   */
  public float ELEVATION() { int o = __offset(46); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight elevation angle, in degrees.
   */
  public float ELEVATION_UNC() { int o = __offset(48); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor line of sight elevation bias in degrees.
   */
  public float ELEVATION_BIAS() { int o = __offset(50); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Rate of change of the line of sight elevation in degrees per second.
   */
  public float ELEVATION_RATE() { int o = __offset(52); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Line of sight range in km. Reported value should include all applicable corrections.
   */
  public float RANGE() { int o = __offset(54); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight range, in km.
   */
  public float RANGE_UNC() { int o = __offset(56); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor line of sight range bias in km.
   */
  public float RANGE_BIAS() { int o = __offset(58); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Range rate in km/s. Reported value should include all applicable corrections.
   */
  public float RANGE_RATE() { int o = __offset(60); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight range rate, in km/sec.
   */
  public float RANGE_RATE_UNC() { int o = __offset(62); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Right ascension in degrees. Required metric reporting field for EO observations.
   */
  public float RA() { int o = __offset(64); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Line of sight right ascension rate of change, in degrees/sec.
   */
  public float RA_RATE() { int o = __offset(66); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight right ascension angle, in degrees.
   */
  public float RA_UNC() { int o = __offset(68); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor line of sight right ascension bias in degrees.
   */
  public float RA_BIAS() { int o = __offset(70); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Declination in degrees. Required metric reporting field for EO observations.
   */
  public float DECLINATION() { int o = __offset(72); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Line of sight declination rate of change, in degrees/sec.
   */
  public float DECLINATION_RATE() { int o = __offset(74); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line of sight declination angle, in degrees.
   */
  public float DECLINATION_UNC() { int o = __offset(76); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor line of sight declination angle bias in degrees.
   */
  public float DECLINATION_BIAS() { int o = __offset(78); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
   */
  public float LOSX() { int o = __offset(80); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
   */
  public float LOSY() { int o = __offset(82); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
   */
  public float LOSZ() { int o = __offset(84); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * One sigma uncertainty in the line-of-sight direction vector components.
   */
  public float LOS_UNC() { int o = __offset(86); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * X-component of the velocity vector along the line of sight, in km/s.
   */
  public float LOSXVEL() { int o = __offset(88); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Y-component of the velocity vector along the line of sight, in km/s.
   */
  public float LOSYVEL() { int o = __offset(90); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Z-component of the velocity vector along the line of sight, in km/s.
   */
  public float LOSZVEL() { int o = __offset(92); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * WGS-84 latitude in decimal degrees at the time of the observation.
   */
  public float SENLAT() { int o = __offset(94); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * WGS-84 longitude in decimal degrees at the time of the observation.
   */
  public float SENLON() { int o = __offset(96); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
   */
  public float SENALT() { int o = __offset(98); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Cartesian X position in km at the time of the observation.
   */
  public float SENX() { int o = __offset(100); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Cartesian Y position in km at the time of the observation.
   */
  public float SENY() { int o = __offset(102); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Cartesian Z position in km at the time of the observation.
   */
  public float SENZ() { int o = __offset(104); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Total number of satellites in the field of view.
   */
  public int FOV_COUNT() { int o = __offset(106); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Number of uncorrelated satellites in the field of view (JCO).
   */
  public int FOV_COUNT_UCTS() { int o = __offset(108); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
   * the exposure duration should be the total integration time. This field is highly recommended / required if the 
   * observations are going to be used for photometric processing.
   */
  public float EXP_DURATION() { int o = __offset(110); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
   */
  public float ZEROPTD() { int o = __offset(112); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Net object signature = counts / EXP_DURATION.
   */
  public float NET_OBJ_SIG() { int o = __offset(114); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
   */
  public float NET_OBJ_SIG_UNC() { int o = __offset(116); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Measure of observed brightness calibrated against the Gaia G-band.
   */
  public float MAG() { int o = __offset(118); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Uncertainty of the observed brightness.
   */
  public float MAG_UNC() { int o = __offset(120); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * [Definition needed].
   */
  public float MAG_NORM_RANGE() { int o = __offset(122); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
   * and corresponding viewing geometry. It must NOT be computed from the orbit state.
   */
  public float GEOLAT() { int o = __offset(124); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
   * and viewing geometry. It must NOT be computed from the orbit state.
   */
  public float GEOLON() { int o = __offset(126); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
   */
  public float GEOALT() { int o = __offset(128); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
   */
  public float GEORANGE() { int o = __offset(130); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
   * empty part of the night sky.
   */
  public float SKY_BKGRND() { int o = __offset(132); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
   * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
   * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
   * object and the observer.
   */
  public float PRIMARY_EXTINCTION() { int o = __offset(134); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Primary Extinction Coefficient Uncertainty, in Magnitudes.
   */
  public float PRIMARY_EXTINCTION_UNC() { int o = __offset(136); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
   * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
   */
  public float SOLAR_PHASE_ANGLE() { int o = __offset(138); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
   * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
   * and positive when opening (after the opposition).
   */
  public float SOLAR_EQ_PHASE_ANGLE() { int o = __offset(140); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Angle from the sun to the equatorial plane.
   */
  public float SOLAR_DEC_ANGLE() { int o = __offset(142); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Shutter delay in seconds.
   */
  public float SHUTTER_DELAY() { int o = __offset(144); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sensor timing bias in seconds.
   */
  public float TIMING_BIAS() { int o = __offset(146); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
   */
  public String RAW_FILE_URI() { int o = __offset(148); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RAW_FILE_URIAsByteBuffer() { return __vector_as_bytebuffer(148, 1); }
  public ByteBuffer RAW_FILE_URIInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 148, 1); }
  /**
   * Intensity of the target for IR observations, in kw/sr/em.
   */
  public float INTENSITY() { int o = __offset(150); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Background intensity for IR observations, in kw/sr/um.
   */
  public float BG_INTENSITY() { int o = __offset(152); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Optional source-provided and searchable metadata or descriptor of the data.
   */
  public String DESCRIPTOR() { int o = __offset(154); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DESCRIPTORAsByteBuffer() { return __vector_as_bytebuffer(154, 1); }
  public ByteBuffer DESCRIPTORInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 154, 1); }
  /**
   * Source of the data.
   */
  public String SOURCE() { int o = __offset(156); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SOURCEAsByteBuffer() { return __vector_as_bytebuffer(156, 1); }
  public ByteBuffer SOURCEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 156, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source.
   * The origin may be different than the source if the source was a mediating system which forwarded 
   * the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   */
  public String ORIGIN() { int o = __offset(158); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIGINAsByteBuffer() { return __vector_as_bytebuffer(158, 1); }
  public ByteBuffer ORIGINInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 158, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
   */
  public byte DATA_MODE() { int o = __offset(160); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Time the row was created in the database, auto-populated by the system.
   */
  public String CREATED_AT() { int o = __offset(162); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CREATED_ATAsByteBuffer() { return __vector_as_bytebuffer(162, 1); }
  public ByteBuffer CREATED_ATInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 162, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   */
  public String CREATED_BY() { int o = __offset(164); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CREATED_BYAsByteBuffer() { return __vector_as_bytebuffer(164, 1); }
  public ByteBuffer CREATED_BYInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 164, 1); }
  /**
   * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
   */
  public RFM REFERENCE_FRAME() { return REFERENCE_FRAME(new RFM()); }
  public RFM REFERENCE_FRAME(RFM obj) { int o = __offset(166); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
   * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
   * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
   */
  public RFM SEN_REFERENCE_FRAME() { return SEN_REFERENCE_FRAME(new RFM()); }
  public RFM SEN_REFERENCE_FRAME(RFM obj) { int o = __offset(168); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
   */
  public boolean UMBRA() { int o = __offset(170); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
   * This field is highly recommended if the observations will be used for photometric processing.
   */
  public boolean PENUMBRA() { int o = __offset(172); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   */
  public String ORIG_NETWORK() { int o = __offset(174); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ORIG_NETWORKAsByteBuffer() { return __vector_as_bytebuffer(174, 1); }
  public ByteBuffer ORIG_NETWORKInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 174, 1); }
  /**
   * The source from which this record was received.
   */
  public String SOURCE_DL() { int o = __offset(176); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SOURCE_DLAsByteBuffer() { return __vector_as_bytebuffer(176, 1); }
  public ByteBuffer SOURCE_DLInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 176, 1); }
  /**
   * Device Type
   */
  public byte TYPE() { int o = __offset(178); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * True if measured, false if computed. Required if azimuth is reported.
   */
  public boolean AZIMUTH_MEASURED() { int o = __offset(180); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if measured, false if computed. Required if elevation is reported.
   */
  public boolean ELEVATION_MEASURED() { int o = __offset(182); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if measured, false if computed. Required if range is reported.
   */
  public boolean RANGE_MEASURED() { int o = __offset(184); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if measured, false if computed. Required if range-rate is reported.
   */
  public boolean RANGERATE_MEASURED() { int o = __offset(186); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if measured, false if computed. Required if right ascension is reported.
   */
  public boolean RA_MEASURED() { int o = __offset(188); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if measured, false if computed. Required if declination is reported.
   */
  public boolean DECLINATION_MEASURED() { int o = __offset(190); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * National Imagery Interpretability Rating Scale (NIIRS). Ranging from 0 (lowest) to 9 (highest).
   */
  public float NIIRS() { int o = __offset(192); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Ground sample distance in meters per pixel.
   */
  public float METERS_PER_PIXEL() { int o = __offset(194); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Signal-to-noise ratio of the image. Higher values indicate cleaner imagery.
   */
  public float IMAGE_SNR() { int o = __offset(196); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Bit depth of the image (e.g., 8, 12, 16).
   */
  public int IMAGE_BIT_DEPTH() { int o = __offset(198); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Width of the image in pixels.
   */
  public int IMAGE_WIDTH() { int o = __offset(200); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Height of the image in pixels.
   */
  public int IMAGE_HEIGHT() { int o = __offset(202); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Compression type used for the image, e.g., "JPEG", "PNG", "RAW", etc.
   */
  public String IMAGE_COMPRESSION() { int o = __offset(204); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IMAGE_COMPRESSIONAsByteBuffer() { return __vector_as_bytebuffer(204, 1); }
  public ByteBuffer IMAGE_COMPRESSIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 204, 1); }
  /**
   * Compression ratio used (original size / compressed size), if applicable.
   */
  public float IMAGE_COMPRESSION_RATIO() { int o = __offset(206); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * URI to the processed image used for this observation.
   */
  public String PROCESSED_IMAGE_URI() { int o = __offset(208); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PROCESSED_IMAGE_URIAsByteBuffer() { return __vector_as_bytebuffer(208, 1); }
  public ByteBuffer PROCESSED_IMAGE_URIInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 208, 1); }
  /**
   * Flag indicating whether the image was auto-enhanced (e.g., contrast stretch, denoise).
   */
  public boolean IMAGE_AUTO_ENHANCED() { int o = __offset(210); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if the observation was taken with multiple frames stacked into one image.
   */
  public boolean MULTI_FRAME_STACKED() { int o = __offset(212); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * True if synthetic tracking was used to create the image.
   */
  public boolean SYNTHETIC_TRACKING_USED() { int o = __offset(214); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Sharpness metric of the image based on the Tenengrad method or variance of Laplacian. Higher values indicate sharper images.
   */
  public float IMAGE_SHARPNESS() { int o = __offset(216); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Noise level of the image, estimated via pixel intensity variance in background regions.
   */
  public float IMAGE_NOISE_STDDEV() { int o = __offset(218); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Contrast metric of the image, such as Michelson contrast or RMS contrast.
   */
  public float IMAGE_CONTRAST() { int o = __offset(220); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Dynamic range of the image (max pixel value / min pixel value), indicating tonal spread.
   */
  public float IMAGE_DYNAMIC_RANGE() { int o = __offset(222); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Entropy of the image, representing the richness of information content. Higher entropy suggests higher texture detail.
   */
  public float IMAGE_ENTROPY() { int o = __offset(224); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Background uniformity metric (e.g., mean gradient in background areas). Lower values indicate more uniform background.
   */
  public float BACKGROUND_UNIFORMITY() { int o = __offset(226); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Mean background level, computed from non-object regions in pixel units.
   */
  public float BACKGROUND_MEAN_LEVEL() { int o = __offset(228); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Percentage of saturated pixels in the image. Indicates overexposure when high.
   */
  public float SATURATED_PIXEL_PERCENT() { int o = __offset(230); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Percentage of dead or zero-value pixels in the image. Indicates sensor defects or underexposure.
   */
  public float DEAD_PIXEL_PERCENT() { int o = __offset(232); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated Point Spread Function (PSF) Full Width at Half Maximum (FWHM) in pixels. Indicates image blur or focus.
   */
  public float PSF_FWHM() { int o = __offset(234); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated percentage of cloud cover in the image. Derived using cloud detection algorithms such as Fmask or machine learning classifiers.
   */
  public float CLOUD_COVER_PERCENT() { int o = __offset(236); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Confidence score of the cloud detection result, from 0 (low confidence) to 1 (high confidence).
   */
  public float CLOUD_DETECTION_CONFIDENCE() { int o = __offset(238); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated percentage of the image obscured by haze or atmospheric scattering effects.
   */
  public float HAZE_PERCENT() { int o = __offset(240); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated aerosol optical thickness (AOT) at 550 nm, indicating particulate matter in the atmosphere affecting image clarity.
   */
  public float AEROSOL_OPTICAL_THICKNESS() { int o = __offset(242); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated water vapor content (e.g., total column precipitable water) at the time of imaging, in mm.
   */
  public float WATER_VAPOR_CONTENT() { int o = __offset(244); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sun elevation angle at the time of image capture, in degrees above the horizon.
   */
  public float SUN_ELEVATION() { int o = __offset(246); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Sun azimuth angle at the time of image capture, in degrees from true north.
   */
  public float SUN_AZIMUTH() { int o = __offset(248); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * View zenith angle (sensor line-of-sight angle from nadir), in degrees.
   */
  public float VIEW_ZENITH_ANGLE() { int o = __offset(250); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * View azimuth angle (direction of sensor relative to north), in degrees.
   */
  public float VIEW_AZIMUTH_ANGLE() { int o = __offset(252); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Off-nadir angle of the sensor at the time of image capture, in degrees.
   */
  public float OFF_NADIR_ANGLE() { int o = __offset(254); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Ground coverage width of the image swath in kilometers.
   */
  public float SWATH_WIDTH_KM() { int o = __offset(256); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Mean terrain elevation in the image footprint, in meters above sea level.
   */
  public float MEAN_TERRAIN_ELEVATION() { int o = __offset(258); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Standard deviation of terrain elevation in the image footprint, in meters.
   */
  public float TERRAIN_ELEVATION_STDDEV() { int o = __offset(260); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Percentage of the image affected by shadows, derived via topographic or object shadow detection.
   */
  public float SHADOW_COVER_PERCENT() { int o = __offset(262); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Flag indicating whether sunglint is present in the image (true if high reflectance from water surface due to sun geometry).
   */
  public boolean SUNGLINT_PRESENT() { int o = __offset(264); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Percentage of image affected by sunglint.
   */
  public float SUNGLINT_PERCENT() { int o = __offset(266); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Estimated percentage of snow or ice coverage in the image footprint.
   */
  public float SNOW_ICE_COVER_PERCENT() { int o = __offset(268); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }
  /**
   * Total area covered by valid data (non-masked, usable imagery) in square kilometers.
   */
  public float VALID_DATA_AREA_KM2() { int o = __offset(270); return o != 0 ? bb.getFloat(o + bb_pos) : 0.0f; }

  public static void startEOO(FlatBufferBuilder builder) { builder.startTable(134); }
  public static void addId(FlatBufferBuilder builder, int IDOffset) { builder.addOffset(0, IDOffset, 0); }
  public static void addClassification(FlatBufferBuilder builder, int CLASSIFICATIONOffset) { builder.addOffset(1, CLASSIFICATIONOffset, 0); }
  public static void addObTime(FlatBufferBuilder builder, int OB_TIMEOffset) { builder.addOffset(2, OB_TIMEOffset, 0); }
  public static void addCorrQuality(FlatBufferBuilder builder, float CORR_QUALITY) { builder.addFloat(3, CORR_QUALITY, 0.0f); }
  public static void addIdOnOrbit(FlatBufferBuilder builder, int ID_ON_ORBITOffset) { builder.addOffset(4, ID_ON_ORBITOffset, 0); }
  public static void addSensorId(FlatBufferBuilder builder, int SENSOR_IDOffset) { builder.addOffset(5, SENSOR_IDOffset, 0); }
  public static void addCollectMethod(FlatBufferBuilder builder, byte COLLECT_METHOD) { builder.addByte(6, COLLECT_METHOD, 0); }
  public static void addNoradCatId(FlatBufferBuilder builder, int NORAD_CAT_ID) { builder.addInt(7, NORAD_CAT_ID, 0); }
  public static void addTaskId(FlatBufferBuilder builder, int TASK_IDOffset) { builder.addOffset(8, TASK_IDOffset, 0); }
  public static void addTransactionId(FlatBufferBuilder builder, int TRANSACTION_IDOffset) { builder.addOffset(9, TRANSACTION_IDOffset, 0); }
  public static void addImageSetId(FlatBufferBuilder builder, int IMAGE_SET_IDOffset) { builder.addOffset(10, IMAGE_SET_IDOffset, 0); }
  public static void addImageSetLength(FlatBufferBuilder builder, int IMAGE_SET_LENGTH) { builder.addInt(11, IMAGE_SET_LENGTH, 0); }
  public static void addSequenceId(FlatBufferBuilder builder, int SEQUENCE_ID) { builder.addInt(12, SEQUENCE_ID, 0); }
  public static void addObPosition(FlatBufferBuilder builder, byte OB_POSITION) { builder.addByte(13, OB_POSITION, 0); }
  public static void addOrigObjectId(FlatBufferBuilder builder, int ORIG_OBJECT_IDOffset) { builder.addOffset(14, ORIG_OBJECT_IDOffset, 0); }
  public static void addOrigSensorId(FlatBufferBuilder builder, int ORIG_SENSOR_IDOffset) { builder.addOffset(15, ORIG_SENSOR_IDOffset, 0); }
  public static void addUct(FlatBufferBuilder builder, boolean UCT) { builder.addBoolean(16, UCT, false); }
  public static void addAzimuth(FlatBufferBuilder builder, float AZIMUTH) { builder.addFloat(17, AZIMUTH, 0.0f); }
  public static void addAzimuthUnc(FlatBufferBuilder builder, float AZIMUTH_UNC) { builder.addFloat(18, AZIMUTH_UNC, 0.0f); }
  public static void addAzimuthBias(FlatBufferBuilder builder, float AZIMUTH_BIAS) { builder.addFloat(19, AZIMUTH_BIAS, 0.0f); }
  public static void addAzimuthRate(FlatBufferBuilder builder, float AZIMUTH_RATE) { builder.addFloat(20, AZIMUTH_RATE, 0.0f); }
  public static void addElevation(FlatBufferBuilder builder, float ELEVATION) { builder.addFloat(21, ELEVATION, 0.0f); }
  public static void addElevationUnc(FlatBufferBuilder builder, float ELEVATION_UNC) { builder.addFloat(22, ELEVATION_UNC, 0.0f); }
  public static void addElevationBias(FlatBufferBuilder builder, float ELEVATION_BIAS) { builder.addFloat(23, ELEVATION_BIAS, 0.0f); }
  public static void addElevationRate(FlatBufferBuilder builder, float ELEVATION_RATE) { builder.addFloat(24, ELEVATION_RATE, 0.0f); }
  public static void addRange(FlatBufferBuilder builder, float RANGE) { builder.addFloat(25, RANGE, 0.0f); }
  public static void addRangeUnc(FlatBufferBuilder builder, float RANGE_UNC) { builder.addFloat(26, RANGE_UNC, 0.0f); }
  public static void addRangeBias(FlatBufferBuilder builder, float RANGE_BIAS) { builder.addFloat(27, RANGE_BIAS, 0.0f); }
  public static void addRangeRate(FlatBufferBuilder builder, float RANGE_RATE) { builder.addFloat(28, RANGE_RATE, 0.0f); }
  public static void addRangeRateUnc(FlatBufferBuilder builder, float RANGE_RATE_UNC) { builder.addFloat(29, RANGE_RATE_UNC, 0.0f); }
  public static void addRa(FlatBufferBuilder builder, float RA) { builder.addFloat(30, RA, 0.0f); }
  public static void addRaRate(FlatBufferBuilder builder, float RA_RATE) { builder.addFloat(31, RA_RATE, 0.0f); }
  public static void addRaUnc(FlatBufferBuilder builder, float RA_UNC) { builder.addFloat(32, RA_UNC, 0.0f); }
  public static void addRaBias(FlatBufferBuilder builder, float RA_BIAS) { builder.addFloat(33, RA_BIAS, 0.0f); }
  public static void addDeclination(FlatBufferBuilder builder, float DECLINATION) { builder.addFloat(34, DECLINATION, 0.0f); }
  public static void addDeclinationRate(FlatBufferBuilder builder, float DECLINATION_RATE) { builder.addFloat(35, DECLINATION_RATE, 0.0f); }
  public static void addDeclinationUnc(FlatBufferBuilder builder, float DECLINATION_UNC) { builder.addFloat(36, DECLINATION_UNC, 0.0f); }
  public static void addDeclinationBias(FlatBufferBuilder builder, float DECLINATION_BIAS) { builder.addFloat(37, DECLINATION_BIAS, 0.0f); }
  public static void addLosx(FlatBufferBuilder builder, float LOSX) { builder.addFloat(38, LOSX, 0.0f); }
  public static void addLosy(FlatBufferBuilder builder, float LOSY) { builder.addFloat(39, LOSY, 0.0f); }
  public static void addLosz(FlatBufferBuilder builder, float LOSZ) { builder.addFloat(40, LOSZ, 0.0f); }
  public static void addLosUnc(FlatBufferBuilder builder, float LOS_UNC) { builder.addFloat(41, LOS_UNC, 0.0f); }
  public static void addLosxvel(FlatBufferBuilder builder, float LOSXVEL) { builder.addFloat(42, LOSXVEL, 0.0f); }
  public static void addLosyvel(FlatBufferBuilder builder, float LOSYVEL) { builder.addFloat(43, LOSYVEL, 0.0f); }
  public static void addLoszvel(FlatBufferBuilder builder, float LOSZVEL) { builder.addFloat(44, LOSZVEL, 0.0f); }
  public static void addSenlat(FlatBufferBuilder builder, float SENLAT) { builder.addFloat(45, SENLAT, 0.0f); }
  public static void addSenlon(FlatBufferBuilder builder, float SENLON) { builder.addFloat(46, SENLON, 0.0f); }
  public static void addSenalt(FlatBufferBuilder builder, float SENALT) { builder.addFloat(47, SENALT, 0.0f); }
  public static void addSenx(FlatBufferBuilder builder, float SENX) { builder.addFloat(48, SENX, 0.0f); }
  public static void addSeny(FlatBufferBuilder builder, float SENY) { builder.addFloat(49, SENY, 0.0f); }
  public static void addSenz(FlatBufferBuilder builder, float SENZ) { builder.addFloat(50, SENZ, 0.0f); }
  public static void addFovCount(FlatBufferBuilder builder, int FOV_COUNT) { builder.addInt(51, FOV_COUNT, 0); }
  public static void addFovCountUcts(FlatBufferBuilder builder, int FOV_COUNT_UCTS) { builder.addInt(52, FOV_COUNT_UCTS, 0); }
  public static void addExpDuration(FlatBufferBuilder builder, float EXP_DURATION) { builder.addFloat(53, EXP_DURATION, 0.0f); }
  public static void addZeroptd(FlatBufferBuilder builder, float ZEROPTD) { builder.addFloat(54, ZEROPTD, 0.0f); }
  public static void addNetObjSig(FlatBufferBuilder builder, float NET_OBJ_SIG) { builder.addFloat(55, NET_OBJ_SIG, 0.0f); }
  public static void addNetObjSigUnc(FlatBufferBuilder builder, float NET_OBJ_SIG_UNC) { builder.addFloat(56, NET_OBJ_SIG_UNC, 0.0f); }
  public static void addMag(FlatBufferBuilder builder, float MAG) { builder.addFloat(57, MAG, 0.0f); }
  public static void addMagUnc(FlatBufferBuilder builder, float MAG_UNC) { builder.addFloat(58, MAG_UNC, 0.0f); }
  public static void addMagNormRange(FlatBufferBuilder builder, float MAG_NORM_RANGE) { builder.addFloat(59, MAG_NORM_RANGE, 0.0f); }
  public static void addGeolat(FlatBufferBuilder builder, float GEOLAT) { builder.addFloat(60, GEOLAT, 0.0f); }
  public static void addGeolon(FlatBufferBuilder builder, float GEOLON) { builder.addFloat(61, GEOLON, 0.0f); }
  public static void addGeoalt(FlatBufferBuilder builder, float GEOALT) { builder.addFloat(62, GEOALT, 0.0f); }
  public static void addGeorange(FlatBufferBuilder builder, float GEORANGE) { builder.addFloat(63, GEORANGE, 0.0f); }
  public static void addSkyBkgrnd(FlatBufferBuilder builder, float SKY_BKGRND) { builder.addFloat(64, SKY_BKGRND, 0.0f); }
  public static void addPrimaryExtinction(FlatBufferBuilder builder, float PRIMARY_EXTINCTION) { builder.addFloat(65, PRIMARY_EXTINCTION, 0.0f); }
  public static void addPrimaryExtinctionUnc(FlatBufferBuilder builder, float PRIMARY_EXTINCTION_UNC) { builder.addFloat(66, PRIMARY_EXTINCTION_UNC, 0.0f); }
  public static void addSolarPhaseAngle(FlatBufferBuilder builder, float SOLAR_PHASE_ANGLE) { builder.addFloat(67, SOLAR_PHASE_ANGLE, 0.0f); }
  public static void addSolarEqPhaseAngle(FlatBufferBuilder builder, float SOLAR_EQ_PHASE_ANGLE) { builder.addFloat(68, SOLAR_EQ_PHASE_ANGLE, 0.0f); }
  public static void addSolarDecAngle(FlatBufferBuilder builder, float SOLAR_DEC_ANGLE) { builder.addFloat(69, SOLAR_DEC_ANGLE, 0.0f); }
  public static void addShutterDelay(FlatBufferBuilder builder, float SHUTTER_DELAY) { builder.addFloat(70, SHUTTER_DELAY, 0.0f); }
  public static void addTimingBias(FlatBufferBuilder builder, float TIMING_BIAS) { builder.addFloat(71, TIMING_BIAS, 0.0f); }
  public static void addRawFileUri(FlatBufferBuilder builder, int RAW_FILE_URIOffset) { builder.addOffset(72, RAW_FILE_URIOffset, 0); }
  public static void addIntensity(FlatBufferBuilder builder, float INTENSITY) { builder.addFloat(73, INTENSITY, 0.0f); }
  public static void addBgIntensity(FlatBufferBuilder builder, float BG_INTENSITY) { builder.addFloat(74, BG_INTENSITY, 0.0f); }
  public static void addDescriptor(FlatBufferBuilder builder, int DESCRIPTOROffset) { builder.addOffset(75, DESCRIPTOROffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int SOURCEOffset) { builder.addOffset(76, SOURCEOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int ORIGINOffset) { builder.addOffset(77, ORIGINOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte DATA_MODE) { builder.addByte(78, DATA_MODE, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int CREATED_ATOffset) { builder.addOffset(79, CREATED_ATOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int CREATED_BYOffset) { builder.addOffset(80, CREATED_BYOffset, 0); }
  public static void addReferenceFrame(FlatBufferBuilder builder, int REFERENCE_FRAMEOffset) { builder.addOffset(81, REFERENCE_FRAMEOffset, 0); }
  public static void addSenReferenceFrame(FlatBufferBuilder builder, int SEN_REFERENCE_FRAMEOffset) { builder.addOffset(82, SEN_REFERENCE_FRAMEOffset, 0); }
  public static void addUmbra(FlatBufferBuilder builder, boolean UMBRA) { builder.addBoolean(83, UMBRA, false); }
  public static void addPenumbra(FlatBufferBuilder builder, boolean PENUMBRA) { builder.addBoolean(84, PENUMBRA, false); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int ORIG_NETWORKOffset) { builder.addOffset(85, ORIG_NETWORKOffset, 0); }
  public static void addSourceDl(FlatBufferBuilder builder, int SOURCE_DLOffset) { builder.addOffset(86, SOURCE_DLOffset, 0); }
  public static void addType(FlatBufferBuilder builder, byte TYPE) { builder.addByte(87, TYPE, 0); }
  public static void addAzimuthMeasured(FlatBufferBuilder builder, boolean AZIMUTH_MEASURED) { builder.addBoolean(88, AZIMUTH_MEASURED, false); }
  public static void addElevationMeasured(FlatBufferBuilder builder, boolean ELEVATION_MEASURED) { builder.addBoolean(89, ELEVATION_MEASURED, false); }
  public static void addRangeMeasured(FlatBufferBuilder builder, boolean RANGE_MEASURED) { builder.addBoolean(90, RANGE_MEASURED, false); }
  public static void addRangerateMeasured(FlatBufferBuilder builder, boolean RANGERATE_MEASURED) { builder.addBoolean(91, RANGERATE_MEASURED, false); }
  public static void addRaMeasured(FlatBufferBuilder builder, boolean RA_MEASURED) { builder.addBoolean(92, RA_MEASURED, false); }
  public static void addDeclinationMeasured(FlatBufferBuilder builder, boolean DECLINATION_MEASURED) { builder.addBoolean(93, DECLINATION_MEASURED, false); }
  public static void addNiirs(FlatBufferBuilder builder, float NIIRS) { builder.addFloat(94, NIIRS, 0.0f); }
  public static void addMetersPerPixel(FlatBufferBuilder builder, float METERS_PER_PIXEL) { builder.addFloat(95, METERS_PER_PIXEL, 0.0f); }
  public static void addImageSnr(FlatBufferBuilder builder, float IMAGE_SNR) { builder.addFloat(96, IMAGE_SNR, 0.0f); }
  public static void addImageBitDepth(FlatBufferBuilder builder, int IMAGE_BIT_DEPTH) { builder.addInt(97, IMAGE_BIT_DEPTH, 0); }
  public static void addImageWidth(FlatBufferBuilder builder, int IMAGE_WIDTH) { builder.addInt(98, IMAGE_WIDTH, 0); }
  public static void addImageHeight(FlatBufferBuilder builder, int IMAGE_HEIGHT) { builder.addInt(99, IMAGE_HEIGHT, 0); }
  public static void addImageCompression(FlatBufferBuilder builder, int IMAGE_COMPRESSIONOffset) { builder.addOffset(100, IMAGE_COMPRESSIONOffset, 0); }
  public static void addImageCompressionRatio(FlatBufferBuilder builder, float IMAGE_COMPRESSION_RATIO) { builder.addFloat(101, IMAGE_COMPRESSION_RATIO, 0.0f); }
  public static void addProcessedImageUri(FlatBufferBuilder builder, int PROCESSED_IMAGE_URIOffset) { builder.addOffset(102, PROCESSED_IMAGE_URIOffset, 0); }
  public static void addImageAutoEnhanced(FlatBufferBuilder builder, boolean IMAGE_AUTO_ENHANCED) { builder.addBoolean(103, IMAGE_AUTO_ENHANCED, false); }
  public static void addMultiFrameStacked(FlatBufferBuilder builder, boolean MULTI_FRAME_STACKED) { builder.addBoolean(104, MULTI_FRAME_STACKED, false); }
  public static void addSyntheticTrackingUsed(FlatBufferBuilder builder, boolean SYNTHETIC_TRACKING_USED) { builder.addBoolean(105, SYNTHETIC_TRACKING_USED, false); }
  public static void addImageSharpness(FlatBufferBuilder builder, float IMAGE_SHARPNESS) { builder.addFloat(106, IMAGE_SHARPNESS, 0.0f); }
  public static void addImageNoiseStddev(FlatBufferBuilder builder, float IMAGE_NOISE_STDDEV) { builder.addFloat(107, IMAGE_NOISE_STDDEV, 0.0f); }
  public static void addImageContrast(FlatBufferBuilder builder, float IMAGE_CONTRAST) { builder.addFloat(108, IMAGE_CONTRAST, 0.0f); }
  public static void addImageDynamicRange(FlatBufferBuilder builder, float IMAGE_DYNAMIC_RANGE) { builder.addFloat(109, IMAGE_DYNAMIC_RANGE, 0.0f); }
  public static void addImageEntropy(FlatBufferBuilder builder, float IMAGE_ENTROPY) { builder.addFloat(110, IMAGE_ENTROPY, 0.0f); }
  public static void addBackgroundUniformity(FlatBufferBuilder builder, float BACKGROUND_UNIFORMITY) { builder.addFloat(111, BACKGROUND_UNIFORMITY, 0.0f); }
  public static void addBackgroundMeanLevel(FlatBufferBuilder builder, float BACKGROUND_MEAN_LEVEL) { builder.addFloat(112, BACKGROUND_MEAN_LEVEL, 0.0f); }
  public static void addSaturatedPixelPercent(FlatBufferBuilder builder, float SATURATED_PIXEL_PERCENT) { builder.addFloat(113, SATURATED_PIXEL_PERCENT, 0.0f); }
  public static void addDeadPixelPercent(FlatBufferBuilder builder, float DEAD_PIXEL_PERCENT) { builder.addFloat(114, DEAD_PIXEL_PERCENT, 0.0f); }
  public static void addPsfFwhm(FlatBufferBuilder builder, float PSF_FWHM) { builder.addFloat(115, PSF_FWHM, 0.0f); }
  public static void addCloudCoverPercent(FlatBufferBuilder builder, float CLOUD_COVER_PERCENT) { builder.addFloat(116, CLOUD_COVER_PERCENT, 0.0f); }
  public static void addCloudDetectionConfidence(FlatBufferBuilder builder, float CLOUD_DETECTION_CONFIDENCE) { builder.addFloat(117, CLOUD_DETECTION_CONFIDENCE, 0.0f); }
  public static void addHazePercent(FlatBufferBuilder builder, float HAZE_PERCENT) { builder.addFloat(118, HAZE_PERCENT, 0.0f); }
  public static void addAerosolOpticalThickness(FlatBufferBuilder builder, float AEROSOL_OPTICAL_THICKNESS) { builder.addFloat(119, AEROSOL_OPTICAL_THICKNESS, 0.0f); }
  public static void addWaterVaporContent(FlatBufferBuilder builder, float WATER_VAPOR_CONTENT) { builder.addFloat(120, WATER_VAPOR_CONTENT, 0.0f); }
  public static void addSunElevation(FlatBufferBuilder builder, float SUN_ELEVATION) { builder.addFloat(121, SUN_ELEVATION, 0.0f); }
  public static void addSunAzimuth(FlatBufferBuilder builder, float SUN_AZIMUTH) { builder.addFloat(122, SUN_AZIMUTH, 0.0f); }
  public static void addViewZenithAngle(FlatBufferBuilder builder, float VIEW_ZENITH_ANGLE) { builder.addFloat(123, VIEW_ZENITH_ANGLE, 0.0f); }
  public static void addViewAzimuthAngle(FlatBufferBuilder builder, float VIEW_AZIMUTH_ANGLE) { builder.addFloat(124, VIEW_AZIMUTH_ANGLE, 0.0f); }
  public static void addOffNadirAngle(FlatBufferBuilder builder, float OFF_NADIR_ANGLE) { builder.addFloat(125, OFF_NADIR_ANGLE, 0.0f); }
  public static void addSwathWidthKm(FlatBufferBuilder builder, float SWATH_WIDTH_KM) { builder.addFloat(126, SWATH_WIDTH_KM, 0.0f); }
  public static void addMeanTerrainElevation(FlatBufferBuilder builder, float MEAN_TERRAIN_ELEVATION) { builder.addFloat(127, MEAN_TERRAIN_ELEVATION, 0.0f); }
  public static void addTerrainElevationStddev(FlatBufferBuilder builder, float TERRAIN_ELEVATION_STDDEV) { builder.addFloat(128, TERRAIN_ELEVATION_STDDEV, 0.0f); }
  public static void addShadowCoverPercent(FlatBufferBuilder builder, float SHADOW_COVER_PERCENT) { builder.addFloat(129, SHADOW_COVER_PERCENT, 0.0f); }
  public static void addSunglintPresent(FlatBufferBuilder builder, boolean SUNGLINT_PRESENT) { builder.addBoolean(130, SUNGLINT_PRESENT, false); }
  public static void addSunglintPercent(FlatBufferBuilder builder, float SUNGLINT_PERCENT) { builder.addFloat(131, SUNGLINT_PERCENT, 0.0f); }
  public static void addSnowIceCoverPercent(FlatBufferBuilder builder, float SNOW_ICE_COVER_PERCENT) { builder.addFloat(132, SNOW_ICE_COVER_PERCENT, 0.0f); }
  public static void addValidDataAreaKm2(FlatBufferBuilder builder, float VALID_DATA_AREA_KM2) { builder.addFloat(133, VALID_DATA_AREA_KM2, 0.0f); }
  public static int endEOO(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishEOOBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$EOO"); }
  public static void finishSizePrefixedEOOBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$EOO"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public EOO get(int j) { return get(new EOO(), j); }
    public EOO get(EOO obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

