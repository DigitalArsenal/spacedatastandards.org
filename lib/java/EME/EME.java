// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Encrypted Message Envelope (EME)
 * Define a collection of Encrypted Message Envelopes with detailed ECIES encryption fields
 * Encrypted Message Envelope
 */
@SuppressWarnings("unused")
public final class EME extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_3_3(); }
  public static EME getRootAsEME(ByteBuffer _bb) { return getRootAsEME(_bb, new EME()); }
  public static EME getRootAsEME(ByteBuffer _bb, EME obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public EME __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Encrypted data blob, containing the ciphertext of the original plaintext message.
   */
  public int ENCRYPTED_BLOB(int j) { int o = __offset(4); return o != 0 ? bb.get(__vector(o) + j * 1) & 0xFF : 0; }
  public int ENCRYPTED_BLOBLength() { int o = __offset(4); return o != 0 ? __vector_len(o) : 0; }
  public ByteVector encryptedBlobVector() { return encryptedBlobVector(new ByteVector()); }
  public ByteVector encryptedBlobVector(ByteVector obj) { int o = __offset(4); return o != 0 ? obj.__assign(__vector(o), bb) : null; }
  public ByteBuffer ENCRYPTED_BLOBAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer ENCRYPTED_BLOBInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
   */
  public String EPHEMERAL_PUBLIC_KEY() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer EPHEMERAL_PUBLIC_KEYAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer EPHEMERAL_PUBLIC_KEYInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Message Authentication Code to verify the integrity and authenticity of the encrypted message.
   */
  public String MAC() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MACAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer MACInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
   */
  public String NONCE() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NONCEAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer NONCEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
   */
  public String TAG() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TAGAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer TAGInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Initialization vector used to introduce randomness in the encryption process, enhancing security.
   */
  public String IV() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IVAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer IVInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Identifier for the public key used, aiding in recipient key management and message decryption.
   */
  public String PUBLIC_KEY_IDENTIFIER() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PUBLIC_KEY_IDENTIFIERAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer PUBLIC_KEY_IDENTIFIERInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Specifies the set of cryptographic algorithms used in the encryption process.
   */
  public String CIPHER_SUITE() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CIPHER_SUITEAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer CIPHER_SUITEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
   */
  public String KDF_PARAMETERS() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer KDF_PARAMETERSAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer KDF_PARAMETERSInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
   */
  public String ENCRYPTION_ALGORITHM_PARAMETERS() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ENCRYPTION_ALGORITHM_PARAMETERSAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer ENCRYPTION_ALGORITHM_PARAMETERSInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }

  public static int createEME(FlatBufferBuilder builder,
      int ENCRYPTED_BLOBOffset,
      int EPHEMERAL_PUBLIC_KEYOffset,
      int MACOffset,
      int NONCEOffset,
      int TAGOffset,
      int IVOffset,
      int PUBLIC_KEY_IDENTIFIEROffset,
      int CIPHER_SUITEOffset,
      int KDF_PARAMETERSOffset,
      int ENCRYPTION_ALGORITHM_PARAMETERSOffset) {
    builder.startTable(10);
    EME.addEncryptionAlgorithmParameters(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset);
    EME.addKdfParameters(builder, KDF_PARAMETERSOffset);
    EME.addCipherSuite(builder, CIPHER_SUITEOffset);
    EME.addPublicKeyIdentifier(builder, PUBLIC_KEY_IDENTIFIEROffset);
    EME.addIv(builder, IVOffset);
    EME.addTag(builder, TAGOffset);
    EME.addNonce(builder, NONCEOffset);
    EME.addMac(builder, MACOffset);
    EME.addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset);
    EME.addEncryptedBlob(builder, ENCRYPTED_BLOBOffset);
    return EME.endEME(builder);
  }

  public static void startEME(FlatBufferBuilder builder) { builder.startTable(10); }
  public static void addEncryptedBlob(FlatBufferBuilder builder, int ENCRYPTED_BLOBOffset) { builder.addOffset(0, ENCRYPTED_BLOBOffset, 0); }
  public static int createEncryptedBlobVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }
  public static int createEncryptedBlobVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }
  public static void startEncryptedBlobVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }
  public static void addEphemeralPublicKey(FlatBufferBuilder builder, int EPHEMERAL_PUBLIC_KEYOffset) { builder.addOffset(1, EPHEMERAL_PUBLIC_KEYOffset, 0); }
  public static void addMac(FlatBufferBuilder builder, int MACOffset) { builder.addOffset(2, MACOffset, 0); }
  public static void addNonce(FlatBufferBuilder builder, int NONCEOffset) { builder.addOffset(3, NONCEOffset, 0); }
  public static void addTag(FlatBufferBuilder builder, int TAGOffset) { builder.addOffset(4, TAGOffset, 0); }
  public static void addIv(FlatBufferBuilder builder, int IVOffset) { builder.addOffset(5, IVOffset, 0); }
  public static void addPublicKeyIdentifier(FlatBufferBuilder builder, int PUBLIC_KEY_IDENTIFIEROffset) { builder.addOffset(6, PUBLIC_KEY_IDENTIFIEROffset, 0); }
  public static void addCipherSuite(FlatBufferBuilder builder, int CIPHER_SUITEOffset) { builder.addOffset(7, CIPHER_SUITEOffset, 0); }
  public static void addKdfParameters(FlatBufferBuilder builder, int KDF_PARAMETERSOffset) { builder.addOffset(8, KDF_PARAMETERSOffset, 0); }
  public static void addEncryptionAlgorithmParameters(FlatBufferBuilder builder, int ENCRYPTION_ALGORITHM_PARAMETERSOffset) { builder.addOffset(9, ENCRYPTION_ALGORITHM_PARAMETERSOffset, 0); }
  public static int endEME(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public EME get(int j) { return get(new EME(), j); }
    public EME get(EME obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

