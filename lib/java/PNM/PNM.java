// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Publish Notification Message
 * This table includes a comprehensive set of cryptographic hashes and a digital signature for file publication.
 */
@SuppressWarnings("unused")
public final class PNM extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_23_3_3(); }
  public static PNM getRootAsPNM(ByteBuffer _bb) { return getRootAsPNM(_bb, new PNM()); }
  public static PNM getRootAsPNM(ByteBuffer _bb, PNM obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean PNMBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$PNM"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public PNM __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * IPFS Content Identifier (CID)
   * The hash of a file stored on the InterPlanetary File System (IPFS).
   * Refer to the section on IPFS integration for details.
   */
  public String IPFS_CID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer IPFS_CIDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer IPFS_CIDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Ethereum Digital Signature
   * Digital signature of the IPFS file hash using Ethereum's signing mechanism.
   * Refer to the Ethereum Blockchain integration section for details.
   */
  public String ETH_DIGITAL_SIGNATURE() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ETH_DIGITAL_SIGNATUREAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer ETH_DIGITAL_SIGNATUREInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * SHA-512 File Hash
   * SHA-512 hash of the file for additional security verification.
   * Detailed in the security features section of the document.
   */
  public String SHA_512_FILE_HASH() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_512_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer SHA_512_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * SHA-256 File Hash
   * SHA-256 hash of the file for additional security verification.
   * Detailed in the security features section of the document.
   */
  public String SHA_256_FILE_HASH() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_256_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer SHA_256_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * MD5 File Digest
   * MD5 digest of the file for backward compatibility with older systems.
   * Located in the legacy support section of the document.
   */
  public String MD5_FILE_DIGEST() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MD5_FILE_DIGESTAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer MD5_FILE_DIGESTInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * SHA-1 File Hash
   * SHA-1 hash of the file, used in certain legacy systems for compatibility.
   * Refer to the legacy systems integration section for more information.
   */
  public String SHA_1_FILE_HASH() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_1_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer SHA_1_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Argon2 File Hash
   * Argon2 hash of the file, providing state-of-the-art password hashing.
   * This is mentioned in the advanced security measures section.
   */
  public String ARGON2_FILE_HASH() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ARGON2_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer ARGON2_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Blake2b File Hash
   * Blake2b hash of the file, known for high-speed cryptographic hashing.
   * Refer to the high-performance security solutions section.
   */
  public String BLAKE2B_FILE_HASH() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BLAKE2B_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer BLAKE2B_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * SHA-3 File Hash
   * SHA-3 hash of the file, offering a stronger alternative to SHA-2.
   * Located in the modern cryptographic standards section.
   */
  public String SHA_3_FILE_HASH() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_3_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer SHA_3_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * RIPEMD-160 File Hash
   * RIPEMD-160 hash of the file, often used in blockchain applications for address generation.
   * Discussed in the blockchain compatibility section.
   */
  public String RIPEMD_160_FILE_HASH() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RIPEMD_160_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer RIPEMD_160_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * Whirlpool File Hash
   * Whirlpool hash of the file, designed for integrity protection and digital fingerprinting.
   * Refer to the data integrity and authentication section.
   */
  public String WHIRLPOOL_FILE_HASH() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer WHIRLPOOL_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer WHIRLPOOL_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * Tiger File Hash
   * Tiger hash of the file, optimized for fast hashing on 64-bit platforms.
   * Detailed in the high-speed cryptographic operations section.
   */
  public String TIGER_FILE_HASH() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TIGER_FILE_HASHAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer TIGER_FILE_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * Cyclic Redundancy Check (CRC) 32
   * Cyclic redundancy check with a length of 32 bits.
   * Refer to CRC section for more details.
   */
  public String CRC32() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CRC32AsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer CRC32InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Adler-32 Checksum
   * Adler-32 checksum with a length of 32 bits.
   * Refer to the checksum section for more details.
   */
  public String ADLER32_CHECKSUM() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ADLER32_CHECKSUMAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer ADLER32_CHECKSUMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * Universal Hash Function Family - Rabin Fingerprint
   * Variable-length hash function using Rabin fingerprinting.
   * Refer to the Universal hash function families section for details.
   */
  public String RABIN_FINGERPRINT() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RABIN_FINGERPRINTAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer RABIN_FINGERPRINTInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * Non-Cryptographic Hash Function - Pearson Hashing
   * Non-cryptographic hash function with a length of 8 bits or more, using XOR or table lookup.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String PEARSON_HASHING() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PEARSON_HASHINGAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer PEARSON_HASHINGInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Keyed Cryptographic Hash Function - BLAKE2
   * Keyed hash function (prefix-MAC) with variable length.
   * Refer to the Keyed cryptographic hash functions section for details.
   */
  public String BLAKE2_KEYED_HASH() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BLAKE2_KEYED_HASHAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer BLAKE2_KEYED_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - BLAKE-256
   * Cryptographic hash function with a length of 256 bits, based on HAIFA structure.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String BLAKE_256() { int o = __offset(38); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BLAKE_256AsByteBuffer() { return __vector_as_bytebuffer(38, 1); }
  public ByteBuffer BLAKE_256InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 38, 1); }
  /**
   * CRC-8
   * Cyclic redundancy check with a length of 8 bits.
   * Refer to CRC section for more details.
   */
  public String CRC8() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CRC8AsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer CRC8InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * CRC-16
   * Cyclic redundancy check with a length of 16 bits.
   * Refer to CRC section for more details.
   */
  public String CRC16() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CRC16AsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer CRC16InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * CRC-64
   * Cyclic redundancy check with a length of 64 bits.
   * Refer to CRC section for more details.
   */
  public String CRC64() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CRC64AsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer CRC64InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }
  /**
   * BSD Checksum
   * BSD checksum with a length of 16 bits.
   * Refer to the checksum section for more details.
   */
  public String BSD_CHECKSUM() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BSD_CHECKSUMAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer BSD_CHECKSUMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * SYSV Checksum
   * SYSV checksum with a length of 16 bits.
   * Refer to the checksum section for more details.
   */
  public String SYSV_CHECKSUM() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SYSV_CHECKSUMAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer SYSV_CHECKSUMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * Sum8
   * Sum with a length of 8 bits.
   * Refer to the checksum section for more details.
   */
  public String SUM8() { int o = __offset(50); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SUM8AsByteBuffer() { return __vector_as_bytebuffer(50, 1); }
  public ByteBuffer SUM8InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 50, 1); }
  /**
   * Internet Checksum
   * Internet checksum with a length of 16 bits.
   * Refer to the checksum section for more details.
   */
  public String INTERNET_CHECKSUM() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer INTERNET_CHECKSUMAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer INTERNET_CHECKSUMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * Sum24
   * Sum with a length of 24 bits.
   * Refer to the checksum section for more details.
   */
  public String SUM24() { int o = __offset(54); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SUM24AsByteBuffer() { return __vector_as_bytebuffer(54, 1); }
  public ByteBuffer SUM24InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 54, 1); }
  /**
   * Sum32
   * Sum with a length of 32 bits.
   * Refer to the checksum section for more details.
   */
  public String SUM32() { int o = __offset(56); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SUM32AsByteBuffer() { return __vector_as_bytebuffer(56, 1); }
  public ByteBuffer SUM32InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 56, 1); }
  /**
   * Fletcher-4
   * Sum with a length of 4 bits.
   * Refer to the checksum section for more details.
   */
  public String FLETCHER_4() { int o = __offset(58); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FLETCHER_4AsByteBuffer() { return __vector_as_bytebuffer(58, 1); }
  public ByteBuffer FLETCHER_4InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 58, 1); }
  /**
   * Fletcher-8
   * Sum with a length of 8 bits.
   * Refer to the checksum section for more details.
   */
  public String FLETCHER_8() { int o = __offset(60); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FLETCHER_8AsByteBuffer() { return __vector_as_bytebuffer(60, 1); }
  public ByteBuffer FLETCHER_8InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 60, 1); }
  /**
   * Fletcher-16
   * Sum with a length of 16 bits.
   * Refer to the checksum section for more details.
   */
  public String FLETCHER_16() { int o = __offset(62); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FLETCHER_16AsByteBuffer() { return __vector_as_bytebuffer(62, 1); }
  public ByteBuffer FLETCHER_16InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 62, 1); }
  /**
   * Fletcher-32
   * Sum with a length of 32 bits.
   * Refer to the checksum section for more details.
   */
  public String FLETCHER_32() { int o = __offset(64); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FLETCHER_32AsByteBuffer() { return __vector_as_bytebuffer(64, 1); }
  public ByteBuffer FLETCHER_32InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 64, 1); }
  /**
   * Luhn Algorithm
   * Luhn algorithm with a length of 1 decimal digit.
   * Refer to the checksum section for more details.
   */
  public String LUNH_ALGORITHM() { int o = __offset(66); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer LUNH_ALGORITHMAsByteBuffer() { return __vector_as_bytebuffer(66, 1); }
  public ByteBuffer LUNH_ALGORITHMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 66, 1); }
  /**
   * Verhoeff Algorithm
   * Verhoeff algorithm with a length of 1 decimal digit.
   * Refer to the checksum section for more details.
   */
  public String VERHOEFF_ALGORITHM() { int o = __offset(68); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer VERHOEFF_ALGORITHMAsByteBuffer() { return __vector_as_bytebuffer(68, 1); }
  public ByteBuffer VERHOEFF_ALGORITHMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 68, 1); }
  /**
   * Damm Algorithm
   * Damm algorithm with a length of 1 decimal digit.
   * Refer to the checksum section for more details.
   */
  public String DAMM_ALGORITHM() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DAMM_ALGORITHMAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer DAMM_ALGORITHMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * Universal Hash Function Family - Tabulation Hashing
   * Variable-length hash function using tabulation hashing.
   * Refer to the Universal hash function families section for details.
   */
  public String TABULATION_HASHING() { int o = __offset(72); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TABULATION_HASHINGAsByteBuffer() { return __vector_as_bytebuffer(72, 1); }
  public ByteBuffer TABULATION_HASHINGInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 72, 1); }
  /**
   * Universal Hash Function Family - Universal One-Way Hash Function
   * Universal one-way hash function with arbitrary length.
   * Refer to the Universal hash function families section for details.
   */
  public String UNIVERSAL_ONE_WAY_HASH_FUNCTION() { int o = __offset(74); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer UNIVERSAL_ONE_WAY_HASH_FUNCTIONAsByteBuffer() { return __vector_as_bytebuffer(74, 1); }
  public ByteBuffer UNIVERSAL_ONE_WAY_HASH_FUNCTIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 74, 1); }
  /**
   * Universal Hash Function Family - Zobrist Hashing
   * Variable-length hash function using Zobrist hashing.
   * Refer to the Universal hash function families section for details.
   */
  public String ZOBRIST_HASHING() { int o = __offset(76); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ZOBRIST_HASHINGAsByteBuffer() { return __vector_as_bytebuffer(76, 1); }
  public ByteBuffer ZOBRIST_HASHINGInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 76, 1); }
  /**
   * Non-Cryptographic Hash Function - Paul Hsieh's SuperFastHash
   * Non-cryptographic hash function with a length of 32 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String PAUL_HSIEHS_SUPERFASTHASH() { int o = __offset(78); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PAUL_HSIEHS_SUPERFASTHASHAsByteBuffer() { return __vector_as_bytebuffer(78, 1); }
  public ByteBuffer PAUL_HSIEHS_SUPERFASTHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 78, 1); }
  /**
   * Non-Cryptographic Hash Function - Buzhash
   * Non-cryptographic hash function with variable length.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String BUZHASH() { int o = __offset(80); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BUZHASHAsByteBuffer() { return __vector_as_bytebuffer(80, 1); }
  public ByteBuffer BUZHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 80, 1); }
  /**
   * Non-Cryptographic Hash Function - Fowler-Noll-Vo Hash Function (FNV Hash)
   * Non-cryptographic hash function with variable length.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String FNV_HASH() { int o = __offset(82); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FNV_HASHAsByteBuffer() { return __vector_as_bytebuffer(82, 1); }
  public ByteBuffer FNV_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 82, 1); }
  /**
   * Non-Cryptographic Hash Function - Jenkins Hash Function
   * Non-cryptographic hash function with a length of 32 or 64 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String JENKINS_HASH_FUNCTION() { int o = __offset(84); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer JENKINS_HASH_FUNCTIONAsByteBuffer() { return __vector_as_bytebuffer(84, 1); }
  public ByteBuffer JENKINS_HASH_FUNCTIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 84, 1); }
  /**
   * Non-Cryptographic Hash Function - Bernstein's Hash (djb2)
   * Non-cryptographic hash function with a length of 32 or 64 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String BERNSTEINS_HASH_DJB2() { int o = __offset(86); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BERNSTEINS_HASH_DJB2AsByteBuffer() { return __vector_as_bytebuffer(86, 1); }
  public ByteBuffer BERNSTEINS_HASH_DJB2InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 86, 1); }
  /**
   * Non-Cryptographic Hash Function - PJW Hash / Elf Hash
   * Non-cryptographic hash function with a length of 32 or 64 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String PJW_HASH_ELF_HASH() { int o = __offset(88); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PJW_HASH_ELF_HASHAsByteBuffer() { return __vector_as_bytebuffer(88, 1); }
  public ByteBuffer PJW_HASH_ELF_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 88, 1); }
  /**
   * Non-Cryptographic Hash Function - MurmurHash
   * Non-cryptographic hash function with a length of 32, 64, or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String MURMURHASH() { int o = __offset(90); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MURMURHASHAsByteBuffer() { return __vector_as_bytebuffer(90, 1); }
  public ByteBuffer MURMURHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 90, 1); }
  /**
   * Non-Cryptographic Hash Function - Fast-Hash
   * Non-cryptographic hash function with a length of 32 or 64 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String FAST_HASH() { int o = __offset(92); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FAST_HASHAsByteBuffer() { return __vector_as_bytebuffer(92, 1); }
  public ByteBuffer FAST_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 92, 1); }
  /**
   * Non-Cryptographic Hash Function - SpookyHash
   * Non-cryptographic hash function with a length of 32, 64, or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String SPOOKYHASH() { int o = __offset(94); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SPOOKYHASHAsByteBuffer() { return __vector_as_bytebuffer(94, 1); }
  public ByteBuffer SPOOKYHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 94, 1); }
  /**
   * Non-Cryptographic Hash Function - CityHash
   * Non-cryptographic hash function with a length of 32, 64, 128, or 256 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String CITYHASH() { int o = __offset(96); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer CITYHASHAsByteBuffer() { return __vector_as_bytebuffer(96, 1); }
  public ByteBuffer CITYHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 96, 1); }
  /**
   * Non-Cryptographic Hash Function - FarmHash
   * Non-cryptographic hash function with a length of 32, 64, or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String FARMHASH() { int o = __offset(98); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FARMHASHAsByteBuffer() { return __vector_as_bytebuffer(98, 1); }
  public ByteBuffer FARMHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 98, 1); }
  /**
   * Non-Cryptographic Hash Function - MetroHash
   * Non-cryptographic hash function with a length of 64 or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String METROHASH() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer METROHASHAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer METROHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * Non-Cryptographic Hash Function - Numeric Hash (nhash)
   * Non-cryptographic hash function with variable length.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String NUMERIC_HASH() { int o = __offset(102); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer NUMERIC_HASHAsByteBuffer() { return __vector_as_bytebuffer(102, 1); }
  public ByteBuffer NUMERIC_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 102, 1); }
  /**
   * Non-Cryptographic Hash Function - xxHash
   * Non-cryptographic hash function with a length of 32, 64, or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String XXHASH() { int o = __offset(104); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer XXHASHAsByteBuffer() { return __vector_as_bytebuffer(104, 1); }
  public ByteBuffer XXHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 104, 1); }
  /**
   * Non-Cryptographic Hash Function - t1ha (Fast Positive Hash)
   * Non-cryptographic hash function with a length of 64 or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String T1HA() { int o = __offset(106); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer T1HAAsByteBuffer() { return __vector_as_bytebuffer(106, 1); }
  public ByteBuffer T1HAInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 106, 1); }
  /**
   * Non-Cryptographic Hash Function - GxHash
   * Non-cryptographic hash function with a length of 32, 64, or 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String GXHASH() { int o = __offset(108); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer GXHASHAsByteBuffer() { return __vector_as_bytebuffer(108, 1); }
  public ByteBuffer GXHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 108, 1); }
  /**
   * Non-Cryptographic Hash Function - pHash
   * Non-cryptographic hash function with fixed or variable length.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String PHASH() { int o = __offset(110); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PHASHAsByteBuffer() { return __vector_as_bytebuffer(110, 1); }
  public ByteBuffer PHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 110, 1); }
  /**
   * Non-Cryptographic Hash Function - dhash
   * Non-cryptographic hash function with a length of 128 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String DHASH() { int o = __offset(112); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DHASHAsByteBuffer() { return __vector_as_bytebuffer(112, 1); }
  public ByteBuffer DHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 112, 1); }
  /**
   * Non-Cryptographic Hash Function - SDBM
   * Non-cryptographic hash function with a length of 32 or 64 bits.
   * Refer to the Non-cryptographic hash functions section for details.
   */
  public String SDBM() { int o = __offset(114); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SDBMAsByteBuffer() { return __vector_as_bytebuffer(114, 1); }
  public ByteBuffer SDBMInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 114, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - OSDB Hash
   * Cryptographic hash function with a length of 64 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String OSDB_HASH() { int o = __offset(116); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer OSDB_HASHAsByteBuffer() { return __vector_as_bytebuffer(116, 1); }
  public ByteBuffer OSDB_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 116, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - komihash
   * Cryptographic hash function with a length of 64 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String KOMIHASH() { int o = __offset(118); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer KOMIHASHAsByteBuffer() { return __vector_as_bytebuffer(118, 1); }
  public ByteBuffer KOMIHASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 118, 1); }
  /**
   * Keyed Cryptographic Hash Function - BLAKE3
   * Keyed hash function with arbitrary length.
   * Refer to the Keyed cryptographic hash functions section for details.
   */
  public String BLAKE3() { int o = __offset(120); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer BLAKE3AsByteBuffer() { return __vector_as_bytebuffer(120, 1); }
  public ByteBuffer BLAKE3InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 120, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - ECOH
   * Cryptographic hash function with a length of 224 to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String ECOH() { int o = __offset(122); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ECOHAsByteBuffer() { return __vector_as_bytebuffer(122, 1); }
  public ByteBuffer ECOHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 122, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - FSB
   * Cryptographic hash function with a length of 160 to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String FSB() { int o = __offset(124); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer FSBAsByteBuffer() { return __vector_as_bytebuffer(124, 1); }
  public ByteBuffer FSBInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 124, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - GOST
   * Cryptographic hash function with a length of 256 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String GOST() { int o = __offset(126); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer GOSTAsByteBuffer() { return __vector_as_bytebuffer(126, 1); }
  public ByteBuffer GOSTInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 126, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Grøstl
   * Cryptographic hash function with a length of up to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String GROSTL() { int o = __offset(128); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer GROSTLAsByteBuffer() { return __vector_as_bytebuffer(128, 1); }
  public ByteBuffer GROSTLInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 128, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - HAS-160
   * Cryptographic hash function with a length of 160 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String HAS_160() { int o = __offset(130); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer HAS_160AsByteBuffer() { return __vector_as_bytebuffer(130, 1); }
  public ByteBuffer HAS_160InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 130, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - HAVAL
   * Cryptographic hash function with a length of 128 to 256 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String HAVAL() { int o = __offset(132); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer HAVALAsByteBuffer() { return __vector_as_bytebuffer(132, 1); }
  public ByteBuffer HAVALInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 132, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - JH
   * Cryptographic hash function with a length of 224 to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String JH() { int o = __offset(134); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer JHAsByteBuffer() { return __vector_as_bytebuffer(134, 1); }
  public ByteBuffer JHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 134, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - LSH
   * Cryptographic hash function with a length of 256 to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String LSH() { int o = __offset(136); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer LSHAsByteBuffer() { return __vector_as_bytebuffer(136, 1); }
  public ByteBuffer LSHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 136, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - MD2
   * Cryptographic hash function with a length of 128 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String MD2() { int o = __offset(138); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MD2AsByteBuffer() { return __vector_as_bytebuffer(138, 1); }
  public ByteBuffer MD2InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 138, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - MD4
   * Cryptographic hash function with a length of 128 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String MD4() { int o = __offset(140); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MD4AsByteBuffer() { return __vector_as_bytebuffer(140, 1); }
  public ByteBuffer MD4InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 140, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - MD5
   * Cryptographic hash function with a length of 128 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String MD5() { int o = __offset(142); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MD5AsByteBuffer() { return __vector_as_bytebuffer(142, 1); }
  public ByteBuffer MD5InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 142, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - MD6
   * Cryptographic hash function with a length of up to 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String MD6() { int o = __offset(144); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer MD6AsByteBuffer() { return __vector_as_bytebuffer(144, 1); }
  public ByteBuffer MD6InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 144, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - RadioGatún
   * Cryptographic hash function with arbitrary length.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String RADIOGATUN() { int o = __offset(146); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RADIOGATUNAsByteBuffer() { return __vector_as_bytebuffer(146, 1); }
  public ByteBuffer RADIOGATUNInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 146, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - RIPEMD
   * Cryptographic hash function with a length of 128 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String RIPEMD() { int o = __offset(148); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RIPEMDAsByteBuffer() { return __vector_as_bytebuffer(148, 1); }
  public ByteBuffer RIPEMDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 148, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - RIPEMD-128
   * Cryptographic hash function with a length of 128 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String RIPEMD_128() { int o = __offset(150); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RIPEMD_128AsByteBuffer() { return __vector_as_bytebuffer(150, 1); }
  public ByteBuffer RIPEMD_128InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 150, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - RIPEMD-256
   * Cryptographic hash function with a length of 256 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String RIPEMD_256() { int o = __offset(152); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RIPEMD_256AsByteBuffer() { return __vector_as_bytebuffer(152, 1); }
  public ByteBuffer RIPEMD_256InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 152, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - RIPEMD-320
   * Cryptographic hash function with a length of 320 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String RIPEMD_320() { int o = __offset(154); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer RIPEMD_320AsByteBuffer() { return __vector_as_bytebuffer(154, 1); }
  public ByteBuffer RIPEMD_320InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 154, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-1
   * Cryptographic hash function with a length of 160 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_1() { int o = __offset(156); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_1AsByteBuffer() { return __vector_as_bytebuffer(156, 1); }
  public ByteBuffer SHA_1InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 156, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-224
   * Cryptographic hash function with a length of 224 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_224() { int o = __offset(158); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_224AsByteBuffer() { return __vector_as_bytebuffer(158, 1); }
  public ByteBuffer SHA_224InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 158, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-256
   * Cryptographic hash function with a length of 256 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_256() { int o = __offset(160); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_256AsByteBuffer() { return __vector_as_bytebuffer(160, 1); }
  public ByteBuffer SHA_256InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 160, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-384
   * Cryptographic hash function with a length of 384 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_384() { int o = __offset(162); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_384AsByteBuffer() { return __vector_as_bytebuffer(162, 1); }
  public ByteBuffer SHA_384InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 162, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-512
   * Cryptographic hash function with a length of 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_512() { int o = __offset(164); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_512AsByteBuffer() { return __vector_as_bytebuffer(164, 1); }
  public ByteBuffer SHA_512InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 164, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SHA-3
   * Cryptographic hash function with arbitrary length.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SHA_3() { int o = __offset(166); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SHA_3AsByteBuffer() { return __vector_as_bytebuffer(166, 1); }
  public ByteBuffer SHA_3InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 166, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Skein
   * Cryptographic hash function with arbitrary length.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SKEIN() { int o = __offset(168); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SKEINAsByteBuffer() { return __vector_as_bytebuffer(168, 1); }
  public ByteBuffer SKEINInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 168, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Snefru
   * Cryptographic hash function with a length of 128 or 256 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SNEFRU() { int o = __offset(170); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SNEFRUAsByteBuffer() { return __vector_as_bytebuffer(170, 1); }
  public ByteBuffer SNEFRUInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 170, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Spectral Hash
   * Cryptographic hash function with a length of 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SPECTRAL_HASH() { int o = __offset(172); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SPECTRAL_HASHAsByteBuffer() { return __vector_as_bytebuffer(172, 1); }
  public ByteBuffer SPECTRAL_HASHInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 172, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Streebog
   * Cryptographic hash function with a length of 256 or 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String STREEBOG() { int o = __offset(174); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer STREEBOGAsByteBuffer() { return __vector_as_bytebuffer(174, 1); }
  public ByteBuffer STREEBOGInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 174, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - SWIFFT
   * Cryptographic hash function with a length of 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String SWIFFT() { int o = __offset(176); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SWIFFTAsByteBuffer() { return __vector_as_bytebuffer(176, 1); }
  public ByteBuffer SWIFFTInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 176, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Tiger
   * Cryptographic hash function with a length of 192 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String TIGER() { int o = __offset(178); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TIGERAsByteBuffer() { return __vector_as_bytebuffer(178, 1); }
  public ByteBuffer TIGERInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 178, 1); }
  /**
   * Unkeyed Cryptographic Hash Function - Whirlpool
   * Cryptographic hash function with a length of 512 bits.
   * Refer to the Unkeyed cryptographic hash functions section for details.
   */
  public String WHIRLPOOL() { int o = __offset(180); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer WHIRLPOOLAsByteBuffer() { return __vector_as_bytebuffer(180, 1); }
  public ByteBuffer WHIRLPOOLInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 180, 1); }

  public static int createPNM(FlatBufferBuilder builder,
      int IPFS_CIDOffset,
      int ETH_DIGITAL_SIGNATUREOffset,
      int SHA_512_FILE_HASHOffset,
      int SHA_256_FILE_HASHOffset,
      int MD5_FILE_DIGESTOffset,
      int SHA_1_FILE_HASHOffset,
      int ARGON2_FILE_HASHOffset,
      int BLAKE2B_FILE_HASHOffset,
      int SHA_3_FILE_HASHOffset,
      int RIPEMD_160_FILE_HASHOffset,
      int WHIRLPOOL_FILE_HASHOffset,
      int TIGER_FILE_HASHOffset,
      int CRC32Offset,
      int ADLER32_CHECKSUMOffset,
      int RABIN_FINGERPRINTOffset,
      int PEARSON_HASHINGOffset,
      int BLAKE2_KEYED_HASHOffset,
      int BLAKE_256Offset,
      int CRC8Offset,
      int CRC16Offset,
      int CRC64Offset,
      int BSD_CHECKSUMOffset,
      int SYSV_CHECKSUMOffset,
      int SUM8Offset,
      int INTERNET_CHECKSUMOffset,
      int SUM24Offset,
      int SUM32Offset,
      int FLETCHER_4Offset,
      int FLETCHER_8Offset,
      int FLETCHER_16Offset,
      int FLETCHER_32Offset,
      int LUNH_ALGORITHMOffset,
      int VERHOEFF_ALGORITHMOffset,
      int DAMM_ALGORITHMOffset,
      int TABULATION_HASHINGOffset,
      int UNIVERSAL_ONE_WAY_HASH_FUNCTIONOffset,
      int ZOBRIST_HASHINGOffset,
      int PAUL_HSIEHS_SUPERFASTHASHOffset,
      int BUZHASHOffset,
      int FNV_HASHOffset,
      int JENKINS_HASH_FUNCTIONOffset,
      int BERNSTEINS_HASH_DJB2Offset,
      int PJW_HASH_ELF_HASHOffset,
      int MURMURHASHOffset,
      int FAST_HASHOffset,
      int SPOOKYHASHOffset,
      int CITYHASHOffset,
      int FARMHASHOffset,
      int METROHASHOffset,
      int NUMERIC_HASHOffset,
      int XXHASHOffset,
      int T1HAOffset,
      int GXHASHOffset,
      int PHASHOffset,
      int DHASHOffset,
      int SDBMOffset,
      int OSDB_HASHOffset,
      int KOMIHASHOffset,
      int BLAKE3Offset,
      int ECOHOffset,
      int FSBOffset,
      int GOSTOffset,
      int GROSTLOffset,
      int HAS_160Offset,
      int HAVALOffset,
      int JHOffset,
      int LSHOffset,
      int MD2Offset,
      int MD4Offset,
      int MD5Offset,
      int MD6Offset,
      int RADIOGATUNOffset,
      int RIPEMDOffset,
      int RIPEMD_128Offset,
      int RIPEMD_256Offset,
      int RIPEMD_320Offset,
      int SHA_1Offset,
      int SHA_224Offset,
      int SHA_256Offset,
      int SHA_384Offset,
      int SHA_512Offset,
      int SHA_3Offset,
      int SKEINOffset,
      int SNEFRUOffset,
      int SPECTRAL_HASHOffset,
      int STREEBOGOffset,
      int SWIFFTOffset,
      int TIGEROffset,
      int WHIRLPOOLOffset) {
    builder.startTable(89);
    PNM.addWhirlpool(builder, WHIRLPOOLOffset);
    PNM.addTiger(builder, TIGEROffset);
    PNM.addSwifft(builder, SWIFFTOffset);
    PNM.addStreebog(builder, STREEBOGOffset);
    PNM.addSpectralHash(builder, SPECTRAL_HASHOffset);
    PNM.addSnefru(builder, SNEFRUOffset);
    PNM.addSkein(builder, SKEINOffset);
    PNM.addSha3(builder, SHA_3Offset);
    PNM.addSha512(builder, SHA_512Offset);
    PNM.addSha384(builder, SHA_384Offset);
    PNM.addSha256(builder, SHA_256Offset);
    PNM.addSha224(builder, SHA_224Offset);
    PNM.addSha1(builder, SHA_1Offset);
    PNM.addRipemd320(builder, RIPEMD_320Offset);
    PNM.addRipemd256(builder, RIPEMD_256Offset);
    PNM.addRipemd128(builder, RIPEMD_128Offset);
    PNM.addRipemd(builder, RIPEMDOffset);
    PNM.addRadiogatun(builder, RADIOGATUNOffset);
    PNM.addMd6(builder, MD6Offset);
    PNM.addMd5(builder, MD5Offset);
    PNM.addMd4(builder, MD4Offset);
    PNM.addMd2(builder, MD2Offset);
    PNM.addLsh(builder, LSHOffset);
    PNM.addJh(builder, JHOffset);
    PNM.addHaval(builder, HAVALOffset);
    PNM.addHas160(builder, HAS_160Offset);
    PNM.addGrostl(builder, GROSTLOffset);
    PNM.addGost(builder, GOSTOffset);
    PNM.addFsb(builder, FSBOffset);
    PNM.addEcoh(builder, ECOHOffset);
    PNM.addBlake3(builder, BLAKE3Offset);
    PNM.addKomihash(builder, KOMIHASHOffset);
    PNM.addOsdbHash(builder, OSDB_HASHOffset);
    PNM.addSdbm(builder, SDBMOffset);
    PNM.addDhash(builder, DHASHOffset);
    PNM.addPhash(builder, PHASHOffset);
    PNM.addGxhash(builder, GXHASHOffset);
    PNM.addT1Ha(builder, T1HAOffset);
    PNM.addXxhash(builder, XXHASHOffset);
    PNM.addNumericHash(builder, NUMERIC_HASHOffset);
    PNM.addMetrohash(builder, METROHASHOffset);
    PNM.addFarmhash(builder, FARMHASHOffset);
    PNM.addCityhash(builder, CITYHASHOffset);
    PNM.addSpookyhash(builder, SPOOKYHASHOffset);
    PNM.addFastHash(builder, FAST_HASHOffset);
    PNM.addMurmurhash(builder, MURMURHASHOffset);
    PNM.addPjwHashElfHash(builder, PJW_HASH_ELF_HASHOffset);
    PNM.addBernsteinsHashDjb2(builder, BERNSTEINS_HASH_DJB2Offset);
    PNM.addJenkinsHashFunction(builder, JENKINS_HASH_FUNCTIONOffset);
    PNM.addFnvHash(builder, FNV_HASHOffset);
    PNM.addBuzhash(builder, BUZHASHOffset);
    PNM.addPaulHsiehsSuperfasthash(builder, PAUL_HSIEHS_SUPERFASTHASHOffset);
    PNM.addZobristHashing(builder, ZOBRIST_HASHINGOffset);
    PNM.addUniversalOneWayHashFunction(builder, UNIVERSAL_ONE_WAY_HASH_FUNCTIONOffset);
    PNM.addTabulationHashing(builder, TABULATION_HASHINGOffset);
    PNM.addDammAlgorithm(builder, DAMM_ALGORITHMOffset);
    PNM.addVerhoeffAlgorithm(builder, VERHOEFF_ALGORITHMOffset);
    PNM.addLunhAlgorithm(builder, LUNH_ALGORITHMOffset);
    PNM.addFletcher32(builder, FLETCHER_32Offset);
    PNM.addFletcher16(builder, FLETCHER_16Offset);
    PNM.addFletcher8(builder, FLETCHER_8Offset);
    PNM.addFletcher4(builder, FLETCHER_4Offset);
    PNM.addSum32(builder, SUM32Offset);
    PNM.addSum24(builder, SUM24Offset);
    PNM.addInternetChecksum(builder, INTERNET_CHECKSUMOffset);
    PNM.addSum8(builder, SUM8Offset);
    PNM.addSysvChecksum(builder, SYSV_CHECKSUMOffset);
    PNM.addBsdChecksum(builder, BSD_CHECKSUMOffset);
    PNM.addCrc64(builder, CRC64Offset);
    PNM.addCrc16(builder, CRC16Offset);
    PNM.addCrc8(builder, CRC8Offset);
    PNM.addBlake256(builder, BLAKE_256Offset);
    PNM.addBlake2KeyedHash(builder, BLAKE2_KEYED_HASHOffset);
    PNM.addPearsonHashing(builder, PEARSON_HASHINGOffset);
    PNM.addRabinFingerprint(builder, RABIN_FINGERPRINTOffset);
    PNM.addAdler32Checksum(builder, ADLER32_CHECKSUMOffset);
    PNM.addCrc32(builder, CRC32Offset);
    PNM.addTigerFileHash(builder, TIGER_FILE_HASHOffset);
    PNM.addWhirlpoolFileHash(builder, WHIRLPOOL_FILE_HASHOffset);
    PNM.addRipemd160FileHash(builder, RIPEMD_160_FILE_HASHOffset);
    PNM.addSha3FileHash(builder, SHA_3_FILE_HASHOffset);
    PNM.addBlake2BFileHash(builder, BLAKE2B_FILE_HASHOffset);
    PNM.addArgon2FileHash(builder, ARGON2_FILE_HASHOffset);
    PNM.addSha1FileHash(builder, SHA_1_FILE_HASHOffset);
    PNM.addMd5FileDigest(builder, MD5_FILE_DIGESTOffset);
    PNM.addSha256FileHash(builder, SHA_256_FILE_HASHOffset);
    PNM.addSha512FileHash(builder, SHA_512_FILE_HASHOffset);
    PNM.addEthDigitalSignature(builder, ETH_DIGITAL_SIGNATUREOffset);
    PNM.addIpfsCid(builder, IPFS_CIDOffset);
    return PNM.endPNM(builder);
  }

  public static void startPNM(FlatBufferBuilder builder) { builder.startTable(89); }
  public static void addIpfsCid(FlatBufferBuilder builder, int IPFS_CIDOffset) { builder.addOffset(0, IPFS_CIDOffset, 0); }
  public static void addEthDigitalSignature(FlatBufferBuilder builder, int ETH_DIGITAL_SIGNATUREOffset) { builder.addOffset(1, ETH_DIGITAL_SIGNATUREOffset, 0); }
  public static void addSha512FileHash(FlatBufferBuilder builder, int SHA_512_FILE_HASHOffset) { builder.addOffset(2, SHA_512_FILE_HASHOffset, 0); }
  public static void addSha256FileHash(FlatBufferBuilder builder, int SHA_256_FILE_HASHOffset) { builder.addOffset(3, SHA_256_FILE_HASHOffset, 0); }
  public static void addMd5FileDigest(FlatBufferBuilder builder, int MD5_FILE_DIGESTOffset) { builder.addOffset(4, MD5_FILE_DIGESTOffset, 0); }
  public static void addSha1FileHash(FlatBufferBuilder builder, int SHA_1_FILE_HASHOffset) { builder.addOffset(5, SHA_1_FILE_HASHOffset, 0); }
  public static void addArgon2FileHash(FlatBufferBuilder builder, int ARGON2_FILE_HASHOffset) { builder.addOffset(6, ARGON2_FILE_HASHOffset, 0); }
  public static void addBlake2BFileHash(FlatBufferBuilder builder, int BLAKE2B_FILE_HASHOffset) { builder.addOffset(7, BLAKE2B_FILE_HASHOffset, 0); }
  public static void addSha3FileHash(FlatBufferBuilder builder, int SHA_3_FILE_HASHOffset) { builder.addOffset(8, SHA_3_FILE_HASHOffset, 0); }
  public static void addRipemd160FileHash(FlatBufferBuilder builder, int RIPEMD_160_FILE_HASHOffset) { builder.addOffset(9, RIPEMD_160_FILE_HASHOffset, 0); }
  public static void addWhirlpoolFileHash(FlatBufferBuilder builder, int WHIRLPOOL_FILE_HASHOffset) { builder.addOffset(10, WHIRLPOOL_FILE_HASHOffset, 0); }
  public static void addTigerFileHash(FlatBufferBuilder builder, int TIGER_FILE_HASHOffset) { builder.addOffset(11, TIGER_FILE_HASHOffset, 0); }
  public static void addCrc32(FlatBufferBuilder builder, int CRC32Offset) { builder.addOffset(12, CRC32Offset, 0); }
  public static void addAdler32Checksum(FlatBufferBuilder builder, int ADLER32_CHECKSUMOffset) { builder.addOffset(13, ADLER32_CHECKSUMOffset, 0); }
  public static void addRabinFingerprint(FlatBufferBuilder builder, int RABIN_FINGERPRINTOffset) { builder.addOffset(14, RABIN_FINGERPRINTOffset, 0); }
  public static void addPearsonHashing(FlatBufferBuilder builder, int PEARSON_HASHINGOffset) { builder.addOffset(15, PEARSON_HASHINGOffset, 0); }
  public static void addBlake2KeyedHash(FlatBufferBuilder builder, int BLAKE2_KEYED_HASHOffset) { builder.addOffset(16, BLAKE2_KEYED_HASHOffset, 0); }
  public static void addBlake256(FlatBufferBuilder builder, int BLAKE_256Offset) { builder.addOffset(17, BLAKE_256Offset, 0); }
  public static void addCrc8(FlatBufferBuilder builder, int CRC8Offset) { builder.addOffset(18, CRC8Offset, 0); }
  public static void addCrc16(FlatBufferBuilder builder, int CRC16Offset) { builder.addOffset(19, CRC16Offset, 0); }
  public static void addCrc64(FlatBufferBuilder builder, int CRC64Offset) { builder.addOffset(20, CRC64Offset, 0); }
  public static void addBsdChecksum(FlatBufferBuilder builder, int BSD_CHECKSUMOffset) { builder.addOffset(21, BSD_CHECKSUMOffset, 0); }
  public static void addSysvChecksum(FlatBufferBuilder builder, int SYSV_CHECKSUMOffset) { builder.addOffset(22, SYSV_CHECKSUMOffset, 0); }
  public static void addSum8(FlatBufferBuilder builder, int SUM8Offset) { builder.addOffset(23, SUM8Offset, 0); }
  public static void addInternetChecksum(FlatBufferBuilder builder, int INTERNET_CHECKSUMOffset) { builder.addOffset(24, INTERNET_CHECKSUMOffset, 0); }
  public static void addSum24(FlatBufferBuilder builder, int SUM24Offset) { builder.addOffset(25, SUM24Offset, 0); }
  public static void addSum32(FlatBufferBuilder builder, int SUM32Offset) { builder.addOffset(26, SUM32Offset, 0); }
  public static void addFletcher4(FlatBufferBuilder builder, int FLETCHER_4Offset) { builder.addOffset(27, FLETCHER_4Offset, 0); }
  public static void addFletcher8(FlatBufferBuilder builder, int FLETCHER_8Offset) { builder.addOffset(28, FLETCHER_8Offset, 0); }
  public static void addFletcher16(FlatBufferBuilder builder, int FLETCHER_16Offset) { builder.addOffset(29, FLETCHER_16Offset, 0); }
  public static void addFletcher32(FlatBufferBuilder builder, int FLETCHER_32Offset) { builder.addOffset(30, FLETCHER_32Offset, 0); }
  public static void addLunhAlgorithm(FlatBufferBuilder builder, int LUNH_ALGORITHMOffset) { builder.addOffset(31, LUNH_ALGORITHMOffset, 0); }
  public static void addVerhoeffAlgorithm(FlatBufferBuilder builder, int VERHOEFF_ALGORITHMOffset) { builder.addOffset(32, VERHOEFF_ALGORITHMOffset, 0); }
  public static void addDammAlgorithm(FlatBufferBuilder builder, int DAMM_ALGORITHMOffset) { builder.addOffset(33, DAMM_ALGORITHMOffset, 0); }
  public static void addTabulationHashing(FlatBufferBuilder builder, int TABULATION_HASHINGOffset) { builder.addOffset(34, TABULATION_HASHINGOffset, 0); }
  public static void addUniversalOneWayHashFunction(FlatBufferBuilder builder, int UNIVERSAL_ONE_WAY_HASH_FUNCTIONOffset) { builder.addOffset(35, UNIVERSAL_ONE_WAY_HASH_FUNCTIONOffset, 0); }
  public static void addZobristHashing(FlatBufferBuilder builder, int ZOBRIST_HASHINGOffset) { builder.addOffset(36, ZOBRIST_HASHINGOffset, 0); }
  public static void addPaulHsiehsSuperfasthash(FlatBufferBuilder builder, int PAUL_HSIEHS_SUPERFASTHASHOffset) { builder.addOffset(37, PAUL_HSIEHS_SUPERFASTHASHOffset, 0); }
  public static void addBuzhash(FlatBufferBuilder builder, int BUZHASHOffset) { builder.addOffset(38, BUZHASHOffset, 0); }
  public static void addFnvHash(FlatBufferBuilder builder, int FNV_HASHOffset) { builder.addOffset(39, FNV_HASHOffset, 0); }
  public static void addJenkinsHashFunction(FlatBufferBuilder builder, int JENKINS_HASH_FUNCTIONOffset) { builder.addOffset(40, JENKINS_HASH_FUNCTIONOffset, 0); }
  public static void addBernsteinsHashDjb2(FlatBufferBuilder builder, int BERNSTEINS_HASH_DJB2Offset) { builder.addOffset(41, BERNSTEINS_HASH_DJB2Offset, 0); }
  public static void addPjwHashElfHash(FlatBufferBuilder builder, int PJW_HASH_ELF_HASHOffset) { builder.addOffset(42, PJW_HASH_ELF_HASHOffset, 0); }
  public static void addMurmurhash(FlatBufferBuilder builder, int MURMURHASHOffset) { builder.addOffset(43, MURMURHASHOffset, 0); }
  public static void addFastHash(FlatBufferBuilder builder, int FAST_HASHOffset) { builder.addOffset(44, FAST_HASHOffset, 0); }
  public static void addSpookyhash(FlatBufferBuilder builder, int SPOOKYHASHOffset) { builder.addOffset(45, SPOOKYHASHOffset, 0); }
  public static void addCityhash(FlatBufferBuilder builder, int CITYHASHOffset) { builder.addOffset(46, CITYHASHOffset, 0); }
  public static void addFarmhash(FlatBufferBuilder builder, int FARMHASHOffset) { builder.addOffset(47, FARMHASHOffset, 0); }
  public static void addMetrohash(FlatBufferBuilder builder, int METROHASHOffset) { builder.addOffset(48, METROHASHOffset, 0); }
  public static void addNumericHash(FlatBufferBuilder builder, int NUMERIC_HASHOffset) { builder.addOffset(49, NUMERIC_HASHOffset, 0); }
  public static void addXxhash(FlatBufferBuilder builder, int XXHASHOffset) { builder.addOffset(50, XXHASHOffset, 0); }
  public static void addT1Ha(FlatBufferBuilder builder, int T1HAOffset) { builder.addOffset(51, T1HAOffset, 0); }
  public static void addGxhash(FlatBufferBuilder builder, int GXHASHOffset) { builder.addOffset(52, GXHASHOffset, 0); }
  public static void addPhash(FlatBufferBuilder builder, int PHASHOffset) { builder.addOffset(53, PHASHOffset, 0); }
  public static void addDhash(FlatBufferBuilder builder, int DHASHOffset) { builder.addOffset(54, DHASHOffset, 0); }
  public static void addSdbm(FlatBufferBuilder builder, int SDBMOffset) { builder.addOffset(55, SDBMOffset, 0); }
  public static void addOsdbHash(FlatBufferBuilder builder, int OSDB_HASHOffset) { builder.addOffset(56, OSDB_HASHOffset, 0); }
  public static void addKomihash(FlatBufferBuilder builder, int KOMIHASHOffset) { builder.addOffset(57, KOMIHASHOffset, 0); }
  public static void addBlake3(FlatBufferBuilder builder, int BLAKE3Offset) { builder.addOffset(58, BLAKE3Offset, 0); }
  public static void addEcoh(FlatBufferBuilder builder, int ECOHOffset) { builder.addOffset(59, ECOHOffset, 0); }
  public static void addFsb(FlatBufferBuilder builder, int FSBOffset) { builder.addOffset(60, FSBOffset, 0); }
  public static void addGost(FlatBufferBuilder builder, int GOSTOffset) { builder.addOffset(61, GOSTOffset, 0); }
  public static void addGrostl(FlatBufferBuilder builder, int GROSTLOffset) { builder.addOffset(62, GROSTLOffset, 0); }
  public static void addHas160(FlatBufferBuilder builder, int HAS_160Offset) { builder.addOffset(63, HAS_160Offset, 0); }
  public static void addHaval(FlatBufferBuilder builder, int HAVALOffset) { builder.addOffset(64, HAVALOffset, 0); }
  public static void addJh(FlatBufferBuilder builder, int JHOffset) { builder.addOffset(65, JHOffset, 0); }
  public static void addLsh(FlatBufferBuilder builder, int LSHOffset) { builder.addOffset(66, LSHOffset, 0); }
  public static void addMd2(FlatBufferBuilder builder, int MD2Offset) { builder.addOffset(67, MD2Offset, 0); }
  public static void addMd4(FlatBufferBuilder builder, int MD4Offset) { builder.addOffset(68, MD4Offset, 0); }
  public static void addMd5(FlatBufferBuilder builder, int MD5Offset) { builder.addOffset(69, MD5Offset, 0); }
  public static void addMd6(FlatBufferBuilder builder, int MD6Offset) { builder.addOffset(70, MD6Offset, 0); }
  public static void addRadiogatun(FlatBufferBuilder builder, int RADIOGATUNOffset) { builder.addOffset(71, RADIOGATUNOffset, 0); }
  public static void addRipemd(FlatBufferBuilder builder, int RIPEMDOffset) { builder.addOffset(72, RIPEMDOffset, 0); }
  public static void addRipemd128(FlatBufferBuilder builder, int RIPEMD_128Offset) { builder.addOffset(73, RIPEMD_128Offset, 0); }
  public static void addRipemd256(FlatBufferBuilder builder, int RIPEMD_256Offset) { builder.addOffset(74, RIPEMD_256Offset, 0); }
  public static void addRipemd320(FlatBufferBuilder builder, int RIPEMD_320Offset) { builder.addOffset(75, RIPEMD_320Offset, 0); }
  public static void addSha1(FlatBufferBuilder builder, int SHA_1Offset) { builder.addOffset(76, SHA_1Offset, 0); }
  public static void addSha224(FlatBufferBuilder builder, int SHA_224Offset) { builder.addOffset(77, SHA_224Offset, 0); }
  public static void addSha256(FlatBufferBuilder builder, int SHA_256Offset) { builder.addOffset(78, SHA_256Offset, 0); }
  public static void addSha384(FlatBufferBuilder builder, int SHA_384Offset) { builder.addOffset(79, SHA_384Offset, 0); }
  public static void addSha512(FlatBufferBuilder builder, int SHA_512Offset) { builder.addOffset(80, SHA_512Offset, 0); }
  public static void addSha3(FlatBufferBuilder builder, int SHA_3Offset) { builder.addOffset(81, SHA_3Offset, 0); }
  public static void addSkein(FlatBufferBuilder builder, int SKEINOffset) { builder.addOffset(82, SKEINOffset, 0); }
  public static void addSnefru(FlatBufferBuilder builder, int SNEFRUOffset) { builder.addOffset(83, SNEFRUOffset, 0); }
  public static void addSpectralHash(FlatBufferBuilder builder, int SPECTRAL_HASHOffset) { builder.addOffset(84, SPECTRAL_HASHOffset, 0); }
  public static void addStreebog(FlatBufferBuilder builder, int STREEBOGOffset) { builder.addOffset(85, STREEBOGOffset, 0); }
  public static void addSwifft(FlatBufferBuilder builder, int SWIFFTOffset) { builder.addOffset(86, SWIFFTOffset, 0); }
  public static void addTiger(FlatBufferBuilder builder, int TIGEROffset) { builder.addOffset(87, TIGEROffset, 0); }
  public static void addWhirlpool(FlatBufferBuilder builder, int WHIRLPOOLOffset) { builder.addOffset(88, WHIRLPOOLOffset, 0); }
  public static int endPNM(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishPNMBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$PNM"); }
  public static void finishSizePrefixedPNMBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$PNM"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public PNM get(int j) { return get(new PNM(), j); }
    public PNM get(PNM obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

