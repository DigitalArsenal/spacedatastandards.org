// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Storefront Listing - Data marketplace listing
 */
@SuppressWarnings("unused")
public final class STF extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static STF getRootAsSTF(ByteBuffer _bb) { return getRootAsSTF(_bb, new STF()); }
  public static STF getRootAsSTF(ByteBuffer _bb, STF obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean STFBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "$STF"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public STF __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier for the listing
   */
  public String LISTING_ID() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer LISTING_IDAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer LISTING_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Peer ID of the data provider
   */
  public String PROVIDER_PEER_ID() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PROVIDER_PEER_IDAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer PROVIDER_PEER_IDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * IPFS CID of provider's EPM (Entity Profile Message)
   */
  public String PROVIDER_EPM_CID() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer PROVIDER_EPM_CIDAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer PROVIDER_EPM_CIDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Title of the data listing
   */
  public String TITLE() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer TITLEAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer TITLEInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Detailed description of the data offering
   */
  public String DESCRIPTION() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer DESCRIPTIONAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer DESCRIPTIONInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
   */
  public String DATA_TYPES(int j) { int o = __offset(14); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int DATA_TYPESLength() { int o = __offset(14); return o != 0 ? __vector_len(o) : 0; }
  public StringVector dataTypesVector() { return dataTypesVector(new StringVector()); }
  public StringVector dataTypesVector(StringVector obj) { int o = __offset(14); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Coverage information (spatial and temporal)
   */
  public DataCoverage COVERAGE() { return COVERAGE(new DataCoverage()); }
  public DataCoverage COVERAGE(DataCoverage obj) { int o = __offset(16); return o != 0 ? obj.__assign(__indirect(o + bb_pos), bb) : null; }
  /**
   * IPFS CID of sample data
   */
  public String SAMPLE_CID() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer SAMPLE_CIDAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer SAMPLE_CIDInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * Type of access offered
   */
  public byte ACCESS_TYPE() { int o = __offset(20); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Whether encryption is required for data delivery
   */
  public boolean ENCRYPTION_REQUIRED() { int o = __offset(22); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Available pricing tiers
   */
  public PricingTier PRICING(int j) { return PRICING(new PricingTier(), j); }
  public PricingTier PRICING(PricingTier obj, int j) { int o = __offset(24); return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null; }
  public int PRICINGLength() { int o = __offset(24); return o != 0 ? __vector_len(o) : 0; }
  public PricingTier.Vector pricingVector() { return pricingVector(new PricingTier.Vector()); }
  public PricingTier.Vector pricingVector(PricingTier.Vector obj) { int o = __offset(24); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Payment methods accepted
   */
  public byte ACCEPTED_PAYMENTS(int j) { int o = __offset(26); return o != 0 ? bb.get(__vector(o) + j * 1) : 0; }
  public int ACCEPTED_PAYMENTSLength() { int o = __offset(26); return o != 0 ? __vector_len(o) : 0; }
  public ByteVector acceptedPaymentsVector() { return acceptedPaymentsVector(new ByteVector()); }
  public ByteVector acceptedPaymentsVector(ByteVector obj) { int o = __offset(26); return o != 0 ? obj.__assign(__vector(o), bb) : null; }
  public ByteBuffer ACCEPTED_PAYMENTSAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer ACCEPTED_PAYMENTSInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * Unix timestamp when listing was created
   */
  public long CREATED_AT() { int o = __offset(28); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Unix timestamp when listing was last updated
   */
  public long UPDATED_AT() { int o = __offset(30); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * Whether the listing is currently active
   */
  public boolean ACTIVE() { int o = __offset(32); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Ed25519 signature from provider
   */
  public int SIGNATURE(int j) { int o = __offset(34); return o != 0 ? bb.get(__vector(o) + j * 1) & 0xFF : 0; }
  public int SIGNATURELength() { int o = __offset(34); return o != 0 ? __vector_len(o) : 0; }
  public ByteVector signatureVector() { return signatureVector(new ByteVector()); }
  public ByteVector signatureVector(ByteVector obj) { int o = __offset(34); return o != 0 ? obj.__assign(__vector(o), bb) : null; }
  public ByteBuffer SIGNATUREAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer SIGNATUREInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }

  public static int createSTF(FlatBufferBuilder builder,
      int LISTING_IDOffset,
      int PROVIDER_PEER_IDOffset,
      int PROVIDER_EPM_CIDOffset,
      int TITLEOffset,
      int DESCRIPTIONOffset,
      int DATA_TYPESOffset,
      int COVERAGEOffset,
      int SAMPLE_CIDOffset,
      byte ACCESS_TYPE,
      boolean ENCRYPTION_REQUIRED,
      int PRICINGOffset,
      int ACCEPTED_PAYMENTSOffset,
      long CREATED_AT,
      long UPDATED_AT,
      boolean ACTIVE,
      int SIGNATUREOffset) {
    builder.startTable(16);
    STF.addUpdatedAt(builder, UPDATED_AT);
    STF.addCreatedAt(builder, CREATED_AT);
    STF.addSignature(builder, SIGNATUREOffset);
    STF.addAcceptedPayments(builder, ACCEPTED_PAYMENTSOffset);
    STF.addPricing(builder, PRICINGOffset);
    STF.addSampleCid(builder, SAMPLE_CIDOffset);
    STF.addCoverage(builder, COVERAGEOffset);
    STF.addDataTypes(builder, DATA_TYPESOffset);
    STF.addDescription(builder, DESCRIPTIONOffset);
    STF.addTitle(builder, TITLEOffset);
    STF.addProviderEpmCid(builder, PROVIDER_EPM_CIDOffset);
    STF.addProviderPeerId(builder, PROVIDER_PEER_IDOffset);
    STF.addListingId(builder, LISTING_IDOffset);
    STF.addActive(builder, ACTIVE);
    STF.addEncryptionRequired(builder, ENCRYPTION_REQUIRED);
    STF.addAccessType(builder, ACCESS_TYPE);
    return STF.endSTF(builder);
  }

  public static void startSTF(FlatBufferBuilder builder) { builder.startTable(16); }
  public static void addListingId(FlatBufferBuilder builder, int LISTING_IDOffset) { builder.addOffset(0, LISTING_IDOffset, 0); }
  public static void addProviderPeerId(FlatBufferBuilder builder, int PROVIDER_PEER_IDOffset) { builder.addOffset(1, PROVIDER_PEER_IDOffset, 0); }
  public static void addProviderEpmCid(FlatBufferBuilder builder, int PROVIDER_EPM_CIDOffset) { builder.addOffset(2, PROVIDER_EPM_CIDOffset, 0); }
  public static void addTitle(FlatBufferBuilder builder, int TITLEOffset) { builder.addOffset(3, TITLEOffset, 0); }
  public static void addDescription(FlatBufferBuilder builder, int DESCRIPTIONOffset) { builder.addOffset(4, DESCRIPTIONOffset, 0); }
  public static void addDataTypes(FlatBufferBuilder builder, int DATA_TYPESOffset) { builder.addOffset(5, DATA_TYPESOffset, 0); }
  public static int createDataTypesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startDataTypesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCoverage(FlatBufferBuilder builder, int COVERAGEOffset) { builder.addOffset(6, COVERAGEOffset, 0); }
  public static void addSampleCid(FlatBufferBuilder builder, int SAMPLE_CIDOffset) { builder.addOffset(7, SAMPLE_CIDOffset, 0); }
  public static void addAccessType(FlatBufferBuilder builder, byte ACCESS_TYPE) { builder.addByte(8, ACCESS_TYPE, 0); }
  public static void addEncryptionRequired(FlatBufferBuilder builder, boolean ENCRYPTION_REQUIRED) { builder.addBoolean(9, ENCRYPTION_REQUIRED, false); }
  public static void addPricing(FlatBufferBuilder builder, int PRICINGOffset) { builder.addOffset(10, PRICINGOffset, 0); }
  public static int createPricingVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startPricingVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addAcceptedPayments(FlatBufferBuilder builder, int ACCEPTED_PAYMENTSOffset) { builder.addOffset(11, ACCEPTED_PAYMENTSOffset, 0); }
  public static int createAcceptedPaymentsVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }
  public static int createAcceptedPaymentsVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }
  public static void startAcceptedPaymentsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }
  public static void addCreatedAt(FlatBufferBuilder builder, long CREATED_AT) { builder.addLong(12, CREATED_AT, 0L); }
  public static void addUpdatedAt(FlatBufferBuilder builder, long UPDATED_AT) { builder.addLong(13, UPDATED_AT, 0L); }
  public static void addActive(FlatBufferBuilder builder, boolean ACTIVE) { builder.addBoolean(14, ACTIVE, false); }
  public static void addSignature(FlatBufferBuilder builder, int SIGNATUREOffset) { builder.addOffset(15, SIGNATUREOffset, 0); }
  public static int createSignatureVector(FlatBufferBuilder builder, byte[] data) { return builder.createByteVector(data); }
  public static int createSignatureVector(FlatBufferBuilder builder, ByteBuffer data) { return builder.createByteVector(data); }
  public static void startSignatureVector(FlatBufferBuilder builder, int numElems) { builder.startVector(1, numElems, 1); }
  public static int endSTF(FlatBufferBuilder builder) {
    int o = builder.endTable();
    builder.required(o, 4);  // LISTING_ID
    builder.required(o, 6);  // PROVIDER_PEER_ID
    builder.required(o, 10);  // TITLE
    return o;
  }
  public static void finishSTFBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "$STF"); }
  public static void finishSizePrefixedSTFBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "$STF"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public STF get(int j) { return get(new STF(), j); }
    public STF get(STF obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

