// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { MPE } from './MPE.js';
import { meanElementTheory } from './meanElementTheory.js';
import { referenceFrame } from './referenceFrame.js';
import { timeSystem } from './timeSystem.js';
/**
 * Collection of MPE Records
 */
export class MPECOLLECTION {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMPECOLLECTION(bb, obj) {
        return (obj || new MPECOLLECTION()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMPECOLLECTION(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new MPECOLLECTION()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$MPE');
    }
    CLASSIFICATION_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Name of the reference frame (TEME, EME2000, etc.)
     */
    REF_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : referenceFrame.TEME;
    }
    /**
     * Epoch of the Reference Frame. (UNIX TimeStamp)
     */
    REF_FRAME_EPOCH() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Time system used for the orbit state and covariance matrix. (UTC)
     */
    TIME_SYSTEM() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : timeSystem.UTC;
    }
    /**
     * Description of the Mean Element Theory. (SGP4,DSST,USM)
     */
    MEAN_ELEMENT_THEORY() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : meanElementTheory.SGP4;
    }
    /**
     * Array of MPE records
     */
    RECORDS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new MPE()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    recordsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMPECOLLECTION(builder) {
        builder.startObject(6);
    }
    static addClassificationType(builder, CLASSIFICATION_TYPEOffset) {
        builder.addFieldOffset(0, CLASSIFICATION_TYPEOffset, 0);
    }
    static addRefFrame(builder, REF_FRAME) {
        builder.addFieldInt8(1, REF_FRAME, referenceFrame.TEME);
    }
    static addRefFrameEpoch(builder, REF_FRAME_EPOCH) {
        builder.addFieldFloat64(2, REF_FRAME_EPOCH, 0.0);
    }
    static addTimeSystem(builder, TIME_SYSTEM) {
        builder.addFieldInt8(3, TIME_SYSTEM, timeSystem.UTC);
    }
    static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
        builder.addFieldInt8(4, MEAN_ELEMENT_THEORY, meanElementTheory.SGP4);
    }
    static addRecords(builder, RECORDSOffset) {
        builder.addFieldOffset(5, RECORDSOffset, 0);
    }
    static createRecordsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRecordsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endMPECOLLECTION(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMPECOLLECTIONBuffer(builder, offset) {
        builder.finish(offset, '$MPE');
    }
    static finishSizePrefixedMPECOLLECTIONBuffer(builder, offset) {
        builder.finish(offset, '$MPE', true);
    }
    static createMPECOLLECTION(builder, CLASSIFICATION_TYPEOffset, REF_FRAME, REF_FRAME_EPOCH, TIME_SYSTEM, MEAN_ELEMENT_THEORY, RECORDSOffset) {
        MPECOLLECTION.startMPECOLLECTION(builder);
        MPECOLLECTION.addClassificationType(builder, CLASSIFICATION_TYPEOffset);
        MPECOLLECTION.addRefFrame(builder, REF_FRAME);
        MPECOLLECTION.addRefFrameEpoch(builder, REF_FRAME_EPOCH);
        MPECOLLECTION.addTimeSystem(builder, TIME_SYSTEM);
        MPECOLLECTION.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
        MPECOLLECTION.addRecords(builder, RECORDSOffset);
        return MPECOLLECTION.endMPECOLLECTION(builder);
    }
    unpack() {
        return new MPECOLLECTIONT(this.CLASSIFICATION_TYPE(), this.REF_FRAME(), this.REF_FRAME_EPOCH(), this.TIME_SYSTEM(), this.MEAN_ELEMENT_THEORY(), this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength()));
    }
    unpackTo(_o) {
        _o.CLASSIFICATION_TYPE = this.CLASSIFICATION_TYPE();
        _o.REF_FRAME = this.REF_FRAME();
        _o.REF_FRAME_EPOCH = this.REF_FRAME_EPOCH();
        _o.TIME_SYSTEM = this.TIME_SYSTEM();
        _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
        _o.RECORDS = this.bb.createObjList(this.RECORDS.bind(this), this.recordsLength());
    }
}
export class MPECOLLECTIONT {
    constructor(CLASSIFICATION_TYPE = null, REF_FRAME = referenceFrame.TEME, REF_FRAME_EPOCH = 0.0, TIME_SYSTEM = timeSystem.UTC, MEAN_ELEMENT_THEORY = meanElementTheory.SGP4, RECORDS = []) {
        this.CLASSIFICATION_TYPE = CLASSIFICATION_TYPE;
        this.REF_FRAME = REF_FRAME;
        this.REF_FRAME_EPOCH = REF_FRAME_EPOCH;
        this.TIME_SYSTEM = TIME_SYSTEM;
        this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
        this.RECORDS = RECORDS;
    }
    pack(builder) {
        const CLASSIFICATION_TYPE = (this.CLASSIFICATION_TYPE !== null ? builder.createString(this.CLASSIFICATION_TYPE) : 0);
        const RECORDS = MPECOLLECTION.createRecordsVector(builder, builder.createObjectOffsetList(this.RECORDS));
        return MPECOLLECTION.createMPECOLLECTION(builder, CLASSIFICATION_TYPE, this.REF_FRAME, this.REF_FRAME_EPOCH, this.TIME_SYSTEM, this.MEAN_ELEMENT_THEORY, RECORDS);
    }
}
