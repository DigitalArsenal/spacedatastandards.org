// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { attitudeStateType } from './attitudeStateType.js';
/**
 * Attitude State Data
 */
export class attitudeState {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsattitudeState(bb, obj) {
        return (obj || new attitudeState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsattitudeState(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new attitudeState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Attitude state type
     */
    ATT_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : attitudeStateType.QUATERNION;
    }
    REF_FRAME_A(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    REF_FRAME_B(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ATT_DIR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    EPOCH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Quaternion scalar component (q0 or qc)
     */
    Q1() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component i
     */
    Q2() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component j
     */
    Q3() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component k
     */
    QC() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle X in degrees
     */
    ANGLE_1() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle Y in degrees
     */
    ANGLE_2() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle Z in degrees
     */
    ANGLE_3() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    EULER_ROT_SEQ(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Angular velocity X in deg/s
     */
    ANGVEL_X() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angular velocity Y in deg/s
     */
    ANGVEL_Y() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angular velocity Z in deg/s
     */
    ANGVEL_Z() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Spin alpha in degrees
     */
    SPIN_ALPHA() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Spin delta in degrees
     */
    SPIN_DELTA() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Spin angle in degrees
     */
    SPIN_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Spin angle velocity in deg/s
     */
    SPIN_ANGLE_VEL() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Nutation angle in degrees
     */
    NUTATION() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Nutation period in seconds
     */
    NUTATION_PERIOD() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Nutation phase in degrees
     */
    NUTATION_PHASE() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    static startattitudeState(builder) {
        builder.startObject(23);
    }
    static addAttType(builder, ATT_TYPE) {
        builder.addFieldInt8(0, ATT_TYPE, attitudeStateType.QUATERNION);
    }
    static addRefFrameA(builder, REF_FRAME_AOffset) {
        builder.addFieldOffset(1, REF_FRAME_AOffset, 0);
    }
    static addRefFrameB(builder, REF_FRAME_BOffset) {
        builder.addFieldOffset(2, REF_FRAME_BOffset, 0);
    }
    static addAttDir(builder, ATT_DIROffset) {
        builder.addFieldOffset(3, ATT_DIROffset, 0);
    }
    static addEpoch(builder, EPOCHOffset) {
        builder.addFieldOffset(4, EPOCHOffset, 0);
    }
    static addQ1(builder, Q1) {
        builder.addFieldFloat64(5, Q1, 0.0);
    }
    static addQ2(builder, Q2) {
        builder.addFieldFloat64(6, Q2, 0.0);
    }
    static addQ3(builder, Q3) {
        builder.addFieldFloat64(7, Q3, 0.0);
    }
    static addQc(builder, QC) {
        builder.addFieldFloat64(8, QC, 0.0);
    }
    static addAngle1(builder, ANGLE_1) {
        builder.addFieldFloat64(9, ANGLE_1, 0.0);
    }
    static addAngle2(builder, ANGLE_2) {
        builder.addFieldFloat64(10, ANGLE_2, 0.0);
    }
    static addAngle3(builder, ANGLE_3) {
        builder.addFieldFloat64(11, ANGLE_3, 0.0);
    }
    static addEulerRotSeq(builder, EULER_ROT_SEQOffset) {
        builder.addFieldOffset(12, EULER_ROT_SEQOffset, 0);
    }
    static addAngvelX(builder, ANGVEL_X) {
        builder.addFieldFloat64(13, ANGVEL_X, 0.0);
    }
    static addAngvelY(builder, ANGVEL_Y) {
        builder.addFieldFloat64(14, ANGVEL_Y, 0.0);
    }
    static addAngvelZ(builder, ANGVEL_Z) {
        builder.addFieldFloat64(15, ANGVEL_Z, 0.0);
    }
    static addSpinAlpha(builder, SPIN_ALPHA) {
        builder.addFieldFloat64(16, SPIN_ALPHA, 0.0);
    }
    static addSpinDelta(builder, SPIN_DELTA) {
        builder.addFieldFloat64(17, SPIN_DELTA, 0.0);
    }
    static addSpinAngle(builder, SPIN_ANGLE) {
        builder.addFieldFloat64(18, SPIN_ANGLE, 0.0);
    }
    static addSpinAngleVel(builder, SPIN_ANGLE_VEL) {
        builder.addFieldFloat64(19, SPIN_ANGLE_VEL, 0.0);
    }
    static addNutation(builder, NUTATION) {
        builder.addFieldFloat64(20, NUTATION, 0.0);
    }
    static addNutationPeriod(builder, NUTATION_PERIOD) {
        builder.addFieldFloat64(21, NUTATION_PERIOD, 0.0);
    }
    static addNutationPhase(builder, NUTATION_PHASE) {
        builder.addFieldFloat64(22, NUTATION_PHASE, 0.0);
    }
    static endattitudeState(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createattitudeState(builder, ATT_TYPE, REF_FRAME_AOffset, REF_FRAME_BOffset, ATT_DIROffset, EPOCHOffset, Q1, Q2, Q3, QC, ANGLE_1, ANGLE_2, ANGLE_3, EULER_ROT_SEQOffset, ANGVEL_X, ANGVEL_Y, ANGVEL_Z, SPIN_ALPHA, SPIN_DELTA, SPIN_ANGLE, SPIN_ANGLE_VEL, NUTATION, NUTATION_PERIOD, NUTATION_PHASE) {
        attitudeState.startattitudeState(builder);
        attitudeState.addAttType(builder, ATT_TYPE);
        attitudeState.addRefFrameA(builder, REF_FRAME_AOffset);
        attitudeState.addRefFrameB(builder, REF_FRAME_BOffset);
        attitudeState.addAttDir(builder, ATT_DIROffset);
        attitudeState.addEpoch(builder, EPOCHOffset);
        attitudeState.addQ1(builder, Q1);
        attitudeState.addQ2(builder, Q2);
        attitudeState.addQ3(builder, Q3);
        attitudeState.addQc(builder, QC);
        attitudeState.addAngle1(builder, ANGLE_1);
        attitudeState.addAngle2(builder, ANGLE_2);
        attitudeState.addAngle3(builder, ANGLE_3);
        attitudeState.addEulerRotSeq(builder, EULER_ROT_SEQOffset);
        attitudeState.addAngvelX(builder, ANGVEL_X);
        attitudeState.addAngvelY(builder, ANGVEL_Y);
        attitudeState.addAngvelZ(builder, ANGVEL_Z);
        attitudeState.addSpinAlpha(builder, SPIN_ALPHA);
        attitudeState.addSpinDelta(builder, SPIN_DELTA);
        attitudeState.addSpinAngle(builder, SPIN_ANGLE);
        attitudeState.addSpinAngleVel(builder, SPIN_ANGLE_VEL);
        attitudeState.addNutation(builder, NUTATION);
        attitudeState.addNutationPeriod(builder, NUTATION_PERIOD);
        attitudeState.addNutationPhase(builder, NUTATION_PHASE);
        return attitudeState.endattitudeState(builder);
    }
    unpack() {
        return new attitudeStateT(this.ATT_TYPE(), this.REF_FRAME_A(), this.REF_FRAME_B(), this.ATT_DIR(), this.EPOCH(), this.Q1(), this.Q2(), this.Q3(), this.QC(), this.ANGLE_1(), this.ANGLE_2(), this.ANGLE_3(), this.EULER_ROT_SEQ(), this.ANGVEL_X(), this.ANGVEL_Y(), this.ANGVEL_Z(), this.SPIN_ALPHA(), this.SPIN_DELTA(), this.SPIN_ANGLE(), this.SPIN_ANGLE_VEL(), this.NUTATION(), this.NUTATION_PERIOD(), this.NUTATION_PHASE());
    }
    unpackTo(_o) {
        _o.ATT_TYPE = this.ATT_TYPE();
        _o.REF_FRAME_A = this.REF_FRAME_A();
        _o.REF_FRAME_B = this.REF_FRAME_B();
        _o.ATT_DIR = this.ATT_DIR();
        _o.EPOCH = this.EPOCH();
        _o.Q1 = this.Q1();
        _o.Q2 = this.Q2();
        _o.Q3 = this.Q3();
        _o.QC = this.QC();
        _o.ANGLE_1 = this.ANGLE_1();
        _o.ANGLE_2 = this.ANGLE_2();
        _o.ANGLE_3 = this.ANGLE_3();
        _o.EULER_ROT_SEQ = this.EULER_ROT_SEQ();
        _o.ANGVEL_X = this.ANGVEL_X();
        _o.ANGVEL_Y = this.ANGVEL_Y();
        _o.ANGVEL_Z = this.ANGVEL_Z();
        _o.SPIN_ALPHA = this.SPIN_ALPHA();
        _o.SPIN_DELTA = this.SPIN_DELTA();
        _o.SPIN_ANGLE = this.SPIN_ANGLE();
        _o.SPIN_ANGLE_VEL = this.SPIN_ANGLE_VEL();
        _o.NUTATION = this.NUTATION();
        _o.NUTATION_PERIOD = this.NUTATION_PERIOD();
        _o.NUTATION_PHASE = this.NUTATION_PHASE();
    }
}
export class attitudeStateT {
    constructor(ATT_TYPE = attitudeStateType.QUATERNION, REF_FRAME_A = null, REF_FRAME_B = null, ATT_DIR = null, EPOCH = null, Q1 = 0.0, Q2 = 0.0, Q3 = 0.0, QC = 0.0, ANGLE_1 = 0.0, ANGLE_2 = 0.0, ANGLE_3 = 0.0, EULER_ROT_SEQ = null, ANGVEL_X = 0.0, ANGVEL_Y = 0.0, ANGVEL_Z = 0.0, SPIN_ALPHA = 0.0, SPIN_DELTA = 0.0, SPIN_ANGLE = 0.0, SPIN_ANGLE_VEL = 0.0, NUTATION = 0.0, NUTATION_PERIOD = 0.0, NUTATION_PHASE = 0.0) {
        this.ATT_TYPE = ATT_TYPE;
        this.REF_FRAME_A = REF_FRAME_A;
        this.REF_FRAME_B = REF_FRAME_B;
        this.ATT_DIR = ATT_DIR;
        this.EPOCH = EPOCH;
        this.Q1 = Q1;
        this.Q2 = Q2;
        this.Q3 = Q3;
        this.QC = QC;
        this.ANGLE_1 = ANGLE_1;
        this.ANGLE_2 = ANGLE_2;
        this.ANGLE_3 = ANGLE_3;
        this.EULER_ROT_SEQ = EULER_ROT_SEQ;
        this.ANGVEL_X = ANGVEL_X;
        this.ANGVEL_Y = ANGVEL_Y;
        this.ANGVEL_Z = ANGVEL_Z;
        this.SPIN_ALPHA = SPIN_ALPHA;
        this.SPIN_DELTA = SPIN_DELTA;
        this.SPIN_ANGLE = SPIN_ANGLE;
        this.SPIN_ANGLE_VEL = SPIN_ANGLE_VEL;
        this.NUTATION = NUTATION;
        this.NUTATION_PERIOD = NUTATION_PERIOD;
        this.NUTATION_PHASE = NUTATION_PHASE;
    }
    pack(builder) {
        const REF_FRAME_A = (this.REF_FRAME_A !== null ? builder.createString(this.REF_FRAME_A) : 0);
        const REF_FRAME_B = (this.REF_FRAME_B !== null ? builder.createString(this.REF_FRAME_B) : 0);
        const ATT_DIR = (this.ATT_DIR !== null ? builder.createString(this.ATT_DIR) : 0);
        const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH) : 0);
        const EULER_ROT_SEQ = (this.EULER_ROT_SEQ !== null ? builder.createString(this.EULER_ROT_SEQ) : 0);
        return attitudeState.createattitudeState(builder, this.ATT_TYPE, REF_FRAME_A, REF_FRAME_B, ATT_DIR, EPOCH, this.Q1, this.Q2, this.Q3, this.QC, this.ANGLE_1, this.ANGLE_2, this.ANGLE_3, EULER_ROT_SEQ, this.ANGVEL_X, this.ANGVEL_Y, this.ANGVEL_Z, this.SPIN_ALPHA, this.SPIN_DELTA, this.SPIN_ANGLE, this.SPIN_ANGLE_VEL, this.NUTATION, this.NUTATION_PERIOD, this.NUTATION_PHASE);
    }
}
