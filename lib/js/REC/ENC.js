// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { KDF } from './KDF.js';
import { KeyExchange } from './KeyExchange.js';
import { SymmetricAlgo } from './SymmetricAlgo.js';
/**
 * Encryption Header containing all parameters needed for decryption
 */
export class ENC {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsENC(bb, obj) {
        return (obj || new ENC()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsENC(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ENC()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$ENC');
    }
    /**
     * Schema version for forward compatibility
     */
    VERSION() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 1;
    }
    /**
     * Key exchange algorithm used
     */
    KEY_EXCHANGE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : KeyExchange.X25519;
    }
    /**
     * Symmetric encryption algorithm used
     */
    SYMMETRIC() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : SymmetricAlgo.AES_256_CTR;
    }
    /**
     * Key derivation function used
     */
    KEY_DERIVATION() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : KDF.HKDF_SHA256;
    }
    /**
     * Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
     */
    EPHEMERAL_PUBLIC_KEY(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    ephemeralPublicKeyLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    ephemeralPublicKeyArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
     */
    NONCE_START(index) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    nonceStartLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    nonceStartArray() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Optional identifier for the recipient's public key (up to 32 bytes)
     */
    RECIPIENT_KEY_ID(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    recipientKeyIdLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recipientKeyIdArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    CONTEXT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
     */
    SCHEMA_HASH(index) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    schemaHashLength() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    schemaHashArray() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    ROOT_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Optional Unix timestamp (milliseconds) when encryption was performed
     */
    TIMESTAMP() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    static startENC(builder) {
        builder.startObject(11);
    }
    static addVersion(builder, VERSION) {
        builder.addFieldInt8(0, VERSION, 1);
    }
    static addKeyExchange(builder, KEY_EXCHANGE) {
        builder.addFieldInt8(1, KEY_EXCHANGE, KeyExchange.X25519);
    }
    static addSymmetric(builder, SYMMETRIC) {
        builder.addFieldInt8(2, SYMMETRIC, SymmetricAlgo.AES_256_CTR);
    }
    static addKeyDerivation(builder, KEY_DERIVATION) {
        builder.addFieldInt8(3, KEY_DERIVATION, KDF.HKDF_SHA256);
    }
    static addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset) {
        builder.addFieldOffset(4, EPHEMERAL_PUBLIC_KEYOffset, 0);
    }
    static createEphemeralPublicKeyVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEphemeralPublicKeyVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addNonceStart(builder, NONCE_STARTOffset) {
        builder.addFieldOffset(5, NONCE_STARTOffset, 0);
    }
    static createNonceStartVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startNonceStartVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addRecipientKeyId(builder, RECIPIENT_KEY_IDOffset) {
        builder.addFieldOffset(6, RECIPIENT_KEY_IDOffset, 0);
    }
    static createRecipientKeyIdVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startRecipientKeyIdVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addContext(builder, CONTEXTOffset) {
        builder.addFieldOffset(7, CONTEXTOffset, 0);
    }
    static addSchemaHash(builder, SCHEMA_HASHOffset) {
        builder.addFieldOffset(8, SCHEMA_HASHOffset, 0);
    }
    static createSchemaHashVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startSchemaHashVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addRootType(builder, ROOT_TYPEOffset) {
        builder.addFieldOffset(9, ROOT_TYPEOffset, 0);
    }
    static addTimestamp(builder, TIMESTAMP) {
        builder.addFieldInt64(10, TIMESTAMP, BigInt('0'));
    }
    static endENC(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 12); // EPHEMERAL_PUBLIC_KEY
        builder.requiredField(offset, 14); // NONCE_START
        return offset;
    }
    static finishENCBuffer(builder, offset) {
        builder.finish(offset, '$ENC');
    }
    static finishSizePrefixedENCBuffer(builder, offset) {
        builder.finish(offset, '$ENC', true);
    }
    static createENC(builder, VERSION, KEY_EXCHANGE, SYMMETRIC, KEY_DERIVATION, EPHEMERAL_PUBLIC_KEYOffset, NONCE_STARTOffset, RECIPIENT_KEY_IDOffset, CONTEXTOffset, SCHEMA_HASHOffset, ROOT_TYPEOffset, TIMESTAMP) {
        ENC.startENC(builder);
        ENC.addVersion(builder, VERSION);
        ENC.addKeyExchange(builder, KEY_EXCHANGE);
        ENC.addSymmetric(builder, SYMMETRIC);
        ENC.addKeyDerivation(builder, KEY_DERIVATION);
        ENC.addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset);
        ENC.addNonceStart(builder, NONCE_STARTOffset);
        ENC.addRecipientKeyId(builder, RECIPIENT_KEY_IDOffset);
        ENC.addContext(builder, CONTEXTOffset);
        ENC.addSchemaHash(builder, SCHEMA_HASHOffset);
        ENC.addRootType(builder, ROOT_TYPEOffset);
        ENC.addTimestamp(builder, TIMESTAMP);
        return ENC.endENC(builder);
    }
    unpack() {
        return new ENCT(this.VERSION(), this.KEY_EXCHANGE(), this.SYMMETRIC(), this.KEY_DERIVATION(), this.bb.createScalarList(this.EPHEMERAL_PUBLIC_KEY.bind(this), this.ephemeralPublicKeyLength()), this.bb.createScalarList(this.NONCE_START.bind(this), this.nonceStartLength()), this.bb.createScalarList(this.RECIPIENT_KEY_ID.bind(this), this.recipientKeyIdLength()), this.CONTEXT(), this.bb.createScalarList(this.SCHEMA_HASH.bind(this), this.schemaHashLength()), this.ROOT_TYPE(), this.TIMESTAMP());
    }
    unpackTo(_o) {
        _o.VERSION = this.VERSION();
        _o.KEY_EXCHANGE = this.KEY_EXCHANGE();
        _o.SYMMETRIC = this.SYMMETRIC();
        _o.KEY_DERIVATION = this.KEY_DERIVATION();
        _o.EPHEMERAL_PUBLIC_KEY = this.bb.createScalarList(this.EPHEMERAL_PUBLIC_KEY.bind(this), this.ephemeralPublicKeyLength());
        _o.NONCE_START = this.bb.createScalarList(this.NONCE_START.bind(this), this.nonceStartLength());
        _o.RECIPIENT_KEY_ID = this.bb.createScalarList(this.RECIPIENT_KEY_ID.bind(this), this.recipientKeyIdLength());
        _o.CONTEXT = this.CONTEXT();
        _o.SCHEMA_HASH = this.bb.createScalarList(this.SCHEMA_HASH.bind(this), this.schemaHashLength());
        _o.ROOT_TYPE = this.ROOT_TYPE();
        _o.TIMESTAMP = this.TIMESTAMP();
    }
}
export class ENCT {
    constructor(VERSION = 1, KEY_EXCHANGE = KeyExchange.X25519, SYMMETRIC = SymmetricAlgo.AES_256_CTR, KEY_DERIVATION = KDF.HKDF_SHA256, EPHEMERAL_PUBLIC_KEY = [], NONCE_START = [], RECIPIENT_KEY_ID = [], CONTEXT = null, SCHEMA_HASH = [], ROOT_TYPE = null, TIMESTAMP = BigInt('0')) {
        this.VERSION = VERSION;
        this.KEY_EXCHANGE = KEY_EXCHANGE;
        this.SYMMETRIC = SYMMETRIC;
        this.KEY_DERIVATION = KEY_DERIVATION;
        this.EPHEMERAL_PUBLIC_KEY = EPHEMERAL_PUBLIC_KEY;
        this.NONCE_START = NONCE_START;
        this.RECIPIENT_KEY_ID = RECIPIENT_KEY_ID;
        this.CONTEXT = CONTEXT;
        this.SCHEMA_HASH = SCHEMA_HASH;
        this.ROOT_TYPE = ROOT_TYPE;
        this.TIMESTAMP = TIMESTAMP;
    }
    pack(builder) {
        const EPHEMERAL_PUBLIC_KEY = ENC.createEphemeralPublicKeyVector(builder, this.EPHEMERAL_PUBLIC_KEY);
        const NONCE_START = ENC.createNonceStartVector(builder, this.NONCE_START);
        const RECIPIENT_KEY_ID = ENC.createRecipientKeyIdVector(builder, this.RECIPIENT_KEY_ID);
        const CONTEXT = (this.CONTEXT !== null ? builder.createString(this.CONTEXT) : 0);
        const SCHEMA_HASH = ENC.createSchemaHashVector(builder, this.SCHEMA_HASH);
        const ROOT_TYPE = (this.ROOT_TYPE !== null ? builder.createString(this.ROOT_TYPE) : 0);
        return ENC.createENC(builder, this.VERSION, this.KEY_EXCHANGE, this.SYMMETRIC, this.KEY_DERIVATION, EPHEMERAL_PUBLIC_KEY, NONCE_START, RECIPIENT_KEY_ID, CONTEXT, SCHEMA_HASH, ROOT_TYPE, this.TIMESTAMP);
    }
}
