// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { meanElementTheory } from './meanElementTheory.js';
/**
 * Minimum Propagatable Element Set
 */
export class MPE {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMPE(bb, obj) {
        return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMPE(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$MPE');
    }
    ENTITY_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Epoch of Mean Keplerian elements. (UNIX TimeStamp)
     */
    EPOCH() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Semi-major axis in km or mean motion in rev/day
     */
    MEAN_MOTION() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Eccentricity
     */
    ECCENTRICITY() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Inclination
     */
    INCLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension of ascending node
     */
    RA_OF_ASC_NODE() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Argument of pericenter
     */
    ARG_OF_PERICENTER() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean anomaly
     */
    MEAN_ANOMALY() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
     */
    BSTAR() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Description of the Mean Element Theory. (SGP4,DSST,USM)
     */
    MEAN_ELEMENT_THEORY() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : meanElementTheory.SGP4;
    }
    static startMPE(builder) {
        builder.startObject(10);
    }
    static addEntityId(builder, ENTITY_IDOffset) {
        builder.addFieldOffset(0, ENTITY_IDOffset, 0);
    }
    static addEpoch(builder, EPOCH) {
        builder.addFieldFloat64(1, EPOCH, 0.0);
    }
    static addMeanMotion(builder, MEAN_MOTION) {
        builder.addFieldFloat64(2, MEAN_MOTION, 0.0);
    }
    static addEccentricity(builder, ECCENTRICITY) {
        builder.addFieldFloat64(3, ECCENTRICITY, 0.0);
    }
    static addInclination(builder, INCLINATION) {
        builder.addFieldFloat64(4, INCLINATION, 0.0);
    }
    static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
        builder.addFieldFloat64(5, RA_OF_ASC_NODE, 0.0);
    }
    static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
        builder.addFieldFloat64(6, ARG_OF_PERICENTER, 0.0);
    }
    static addMeanAnomaly(builder, MEAN_ANOMALY) {
        builder.addFieldFloat64(7, MEAN_ANOMALY, 0.0);
    }
    static addBstar(builder, BSTAR) {
        builder.addFieldFloat64(8, BSTAR, 0.0);
    }
    static addMeanElementTheory(builder, MEAN_ELEMENT_THEORY) {
        builder.addFieldInt8(9, MEAN_ELEMENT_THEORY, meanElementTheory.SGP4);
    }
    static endMPE(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMPEBuffer(builder, offset) {
        builder.finish(offset, '$MPE');
    }
    static finishSizePrefixedMPEBuffer(builder, offset) {
        builder.finish(offset, '$MPE', true);
    }
    static createMPE(builder, ENTITY_IDOffset, EPOCH, MEAN_MOTION, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, BSTAR, MEAN_ELEMENT_THEORY) {
        MPE.startMPE(builder);
        MPE.addEntityId(builder, ENTITY_IDOffset);
        MPE.addEpoch(builder, EPOCH);
        MPE.addMeanMotion(builder, MEAN_MOTION);
        MPE.addEccentricity(builder, ECCENTRICITY);
        MPE.addInclination(builder, INCLINATION);
        MPE.addRaOfAscNode(builder, RA_OF_ASC_NODE);
        MPE.addArgOfPericenter(builder, ARG_OF_PERICENTER);
        MPE.addMeanAnomaly(builder, MEAN_ANOMALY);
        MPE.addBstar(builder, BSTAR);
        MPE.addMeanElementTheory(builder, MEAN_ELEMENT_THEORY);
        return MPE.endMPE(builder);
    }
    unpack() {
        return new MPET(this.ENTITY_ID(), this.EPOCH(), this.MEAN_MOTION(), this.ECCENTRICITY(), this.INCLINATION(), this.RA_OF_ASC_NODE(), this.ARG_OF_PERICENTER(), this.MEAN_ANOMALY(), this.BSTAR(), this.MEAN_ELEMENT_THEORY());
    }
    unpackTo(_o) {
        _o.ENTITY_ID = this.ENTITY_ID();
        _o.EPOCH = this.EPOCH();
        _o.MEAN_MOTION = this.MEAN_MOTION();
        _o.ECCENTRICITY = this.ECCENTRICITY();
        _o.INCLINATION = this.INCLINATION();
        _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
        _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
        _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
        _o.BSTAR = this.BSTAR();
        _o.MEAN_ELEMENT_THEORY = this.MEAN_ELEMENT_THEORY();
    }
}
export class MPET {
    constructor(ENTITY_ID = null, EPOCH = 0.0, MEAN_MOTION = 0.0, ECCENTRICITY = 0.0, INCLINATION = 0.0, RA_OF_ASC_NODE = 0.0, ARG_OF_PERICENTER = 0.0, MEAN_ANOMALY = 0.0, BSTAR = 0.0, MEAN_ELEMENT_THEORY = meanElementTheory.SGP4) {
        this.ENTITY_ID = ENTITY_ID;
        this.EPOCH = EPOCH;
        this.MEAN_MOTION = MEAN_MOTION;
        this.ECCENTRICITY = ECCENTRICITY;
        this.INCLINATION = INCLINATION;
        this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
        this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
        this.MEAN_ANOMALY = MEAN_ANOMALY;
        this.BSTAR = BSTAR;
        this.MEAN_ELEMENT_THEORY = MEAN_ELEMENT_THEORY;
    }
    pack(builder) {
        const ENTITY_ID = (this.ENTITY_ID !== null ? builder.createString(this.ENTITY_ID) : 0);
        return MPE.createMPE(builder, ENTITY_ID, this.EPOCH, this.MEAN_MOTION, this.ECCENTRICITY, this.INCLINATION, this.RA_OF_ASC_NODE, this.ARG_OF_PERICENTER, this.MEAN_ANOMALY, this.BSTAR, this.MEAN_ELEMENT_THEORY);
    }
}
