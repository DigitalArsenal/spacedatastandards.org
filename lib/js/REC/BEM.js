// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { beamContour } from './beamContour.js';
import { beamPolarization } from './beamPolarization.js';
import { beamType } from './beamType.js';
/**
 * Antenna Beam
 */
export class BEM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBEM(bb, obj) {
        return (obj || new BEM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBEM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BEM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$BEM');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BEAM_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_ENTITY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_ANTENNA(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Beam type
     */
    TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : beamType.SPOT;
    }
    /**
     * Beam polarization
     */
    POLARIZATION() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : beamPolarization.RHCP;
    }
    /**
     * Peak gain in dBi
     */
    PEAK_GAIN() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Edge-of-coverage gain in dBi
     */
    EOC_GAIN() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Beam center latitude in degrees
     */
    CENTER_LATITUDE() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Beam center longitude in degrees
     */
    CENTER_LONGITUDE() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Beamwidth (3dB) in degrees
     */
    BEAMWIDTH() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Operating frequency in MHz
     */
    FREQUENCY() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * EIRP at beam center in dBW
     */
    EIRP() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * G/T at beam center in dB/K
     */
    G_OVER_T() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Beam footprint area in km^2
     */
    FOOTPRINT_AREA() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Beam contour definitions
     */
    BEAM_CONTOURS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? (obj || new beamContour()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    beamContoursLength() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    NOTES(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startBEM(builder) {
        builder.startObject(17);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addBeamName(builder, BEAM_NAMEOffset) {
        builder.addFieldOffset(1, BEAM_NAMEOffset, 0);
    }
    static addIdEntity(builder, ID_ENTITYOffset) {
        builder.addFieldOffset(2, ID_ENTITYOffset, 0);
    }
    static addIdAntenna(builder, ID_ANTENNAOffset) {
        builder.addFieldOffset(3, ID_ANTENNAOffset, 0);
    }
    static addType(builder, TYPE) {
        builder.addFieldInt8(4, TYPE, beamType.SPOT);
    }
    static addPolarization(builder, POLARIZATION) {
        builder.addFieldInt8(5, POLARIZATION, beamPolarization.RHCP);
    }
    static addPeakGain(builder, PEAK_GAIN) {
        builder.addFieldFloat64(6, PEAK_GAIN, 0.0);
    }
    static addEocGain(builder, EOC_GAIN) {
        builder.addFieldFloat64(7, EOC_GAIN, 0.0);
    }
    static addCenterLatitude(builder, CENTER_LATITUDE) {
        builder.addFieldFloat64(8, CENTER_LATITUDE, 0.0);
    }
    static addCenterLongitude(builder, CENTER_LONGITUDE) {
        builder.addFieldFloat64(9, CENTER_LONGITUDE, 0.0);
    }
    static addBeamwidth(builder, BEAMWIDTH) {
        builder.addFieldFloat64(10, BEAMWIDTH, 0.0);
    }
    static addFrequency(builder, FREQUENCY) {
        builder.addFieldFloat64(11, FREQUENCY, 0.0);
    }
    static addEirp(builder, EIRP) {
        builder.addFieldFloat64(12, EIRP, 0.0);
    }
    static addGOverT(builder, G_OVER_T) {
        builder.addFieldFloat64(13, G_OVER_T, 0.0);
    }
    static addFootprintArea(builder, FOOTPRINT_AREA) {
        builder.addFieldFloat64(14, FOOTPRINT_AREA, 0.0);
    }
    static addBeamContours(builder, BEAM_CONTOURSOffset) {
        builder.addFieldOffset(15, BEAM_CONTOURSOffset, 0);
    }
    static createBeamContoursVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBeamContoursVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addNotes(builder, NOTESOffset) {
        builder.addFieldOffset(16, NOTESOffset, 0);
    }
    static endBEM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishBEMBuffer(builder, offset) {
        builder.finish(offset, '$BEM');
    }
    static finishSizePrefixedBEMBuffer(builder, offset) {
        builder.finish(offset, '$BEM', true);
    }
    static createBEM(builder, IDOffset, BEAM_NAMEOffset, ID_ENTITYOffset, ID_ANTENNAOffset, TYPE, POLARIZATION, PEAK_GAIN, EOC_GAIN, CENTER_LATITUDE, CENTER_LONGITUDE, BEAMWIDTH, FREQUENCY, EIRP, G_OVER_T, FOOTPRINT_AREA, BEAM_CONTOURSOffset, NOTESOffset) {
        BEM.startBEM(builder);
        BEM.addId(builder, IDOffset);
        BEM.addBeamName(builder, BEAM_NAMEOffset);
        BEM.addIdEntity(builder, ID_ENTITYOffset);
        BEM.addIdAntenna(builder, ID_ANTENNAOffset);
        BEM.addType(builder, TYPE);
        BEM.addPolarization(builder, POLARIZATION);
        BEM.addPeakGain(builder, PEAK_GAIN);
        BEM.addEocGain(builder, EOC_GAIN);
        BEM.addCenterLatitude(builder, CENTER_LATITUDE);
        BEM.addCenterLongitude(builder, CENTER_LONGITUDE);
        BEM.addBeamwidth(builder, BEAMWIDTH);
        BEM.addFrequency(builder, FREQUENCY);
        BEM.addEirp(builder, EIRP);
        BEM.addGOverT(builder, G_OVER_T);
        BEM.addFootprintArea(builder, FOOTPRINT_AREA);
        BEM.addBeamContours(builder, BEAM_CONTOURSOffset);
        BEM.addNotes(builder, NOTESOffset);
        return BEM.endBEM(builder);
    }
    unpack() {
        return new BEMT(this.ID(), this.BEAM_NAME(), this.ID_ENTITY(), this.ID_ANTENNA(), this.TYPE(), this.POLARIZATION(), this.PEAK_GAIN(), this.EOC_GAIN(), this.CENTER_LATITUDE(), this.CENTER_LONGITUDE(), this.BEAMWIDTH(), this.FREQUENCY(), this.EIRP(), this.G_OVER_T(), this.FOOTPRINT_AREA(), this.bb.createObjList(this.BEAM_CONTOURS.bind(this), this.beamContoursLength()), this.NOTES());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.BEAM_NAME = this.BEAM_NAME();
        _o.ID_ENTITY = this.ID_ENTITY();
        _o.ID_ANTENNA = this.ID_ANTENNA();
        _o.TYPE = this.TYPE();
        _o.POLARIZATION = this.POLARIZATION();
        _o.PEAK_GAIN = this.PEAK_GAIN();
        _o.EOC_GAIN = this.EOC_GAIN();
        _o.CENTER_LATITUDE = this.CENTER_LATITUDE();
        _o.CENTER_LONGITUDE = this.CENTER_LONGITUDE();
        _o.BEAMWIDTH = this.BEAMWIDTH();
        _o.FREQUENCY = this.FREQUENCY();
        _o.EIRP = this.EIRP();
        _o.G_OVER_T = this.G_OVER_T();
        _o.FOOTPRINT_AREA = this.FOOTPRINT_AREA();
        _o.BEAM_CONTOURS = this.bb.createObjList(this.BEAM_CONTOURS.bind(this), this.beamContoursLength());
        _o.NOTES = this.NOTES();
    }
}
export class BEMT {
    constructor(ID = null, BEAM_NAME = null, ID_ENTITY = null, ID_ANTENNA = null, TYPE = beamType.SPOT, POLARIZATION = beamPolarization.RHCP, PEAK_GAIN = 0.0, EOC_GAIN = 0.0, CENTER_LATITUDE = 0.0, CENTER_LONGITUDE = 0.0, BEAMWIDTH = 0.0, FREQUENCY = 0.0, EIRP = 0.0, G_OVER_T = 0.0, FOOTPRINT_AREA = 0.0, BEAM_CONTOURS = [], NOTES = null) {
        this.ID = ID;
        this.BEAM_NAME = BEAM_NAME;
        this.ID_ENTITY = ID_ENTITY;
        this.ID_ANTENNA = ID_ANTENNA;
        this.TYPE = TYPE;
        this.POLARIZATION = POLARIZATION;
        this.PEAK_GAIN = PEAK_GAIN;
        this.EOC_GAIN = EOC_GAIN;
        this.CENTER_LATITUDE = CENTER_LATITUDE;
        this.CENTER_LONGITUDE = CENTER_LONGITUDE;
        this.BEAMWIDTH = BEAMWIDTH;
        this.FREQUENCY = FREQUENCY;
        this.EIRP = EIRP;
        this.G_OVER_T = G_OVER_T;
        this.FOOTPRINT_AREA = FOOTPRINT_AREA;
        this.BEAM_CONTOURS = BEAM_CONTOURS;
        this.NOTES = NOTES;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const BEAM_NAME = (this.BEAM_NAME !== null ? builder.createString(this.BEAM_NAME) : 0);
        const ID_ENTITY = (this.ID_ENTITY !== null ? builder.createString(this.ID_ENTITY) : 0);
        const ID_ANTENNA = (this.ID_ANTENNA !== null ? builder.createString(this.ID_ANTENNA) : 0);
        const BEAM_CONTOURS = BEM.createBeamContoursVector(builder, builder.createObjectOffsetList(this.BEAM_CONTOURS));
        const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES) : 0);
        return BEM.createBEM(builder, ID, BEAM_NAME, ID_ENTITY, ID_ANTENNA, this.TYPE, this.POLARIZATION, this.PEAK_GAIN, this.EOC_GAIN, this.CENTER_LATITUDE, this.CENTER_LONGITUDE, this.BEAMWIDTH, this.FREQUENCY, this.EIRP, this.G_OVER_T, this.FOOTPRINT_AREA, BEAM_CONTOURS, NOTES);
    }
}
