// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { Header } from './Header.js';
import { Maneuver } from './Maneuver.js';
import { Metadata } from './Metadata.js';
import { OrbitDetermination } from './OrbitDetermination.js';
import { Perturbations } from './Perturbations.js';
import { PhysicalProperties } from './PhysicalProperties.js';
import { UserDefinedParameters } from './UserDefinedParameters.js';
/**
 * Orbit Comprehensive Message
 */
export class OCM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsOCM(bb, obj) {
        return (obj || new OCM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsOCM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new OCM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$OCM');
    }
    /**
     * Header section of the OCM.
     */
    HEADER(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new Header()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Metadata section of the OCM.
     */
    METADATA(obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new Metadata()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    TRAJ_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Time interval between state vectors in seconds (required for time-series data).
     */
    STATE_STEP_SIZE() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Number of components per state vector.
     * 6 = position + velocity (X, Y, Z, X_DOT, Y_DOT, Z_DOT)
     * 9 = position + velocity + acceleration (adds X_DDOT, Y_DDOT, Z_DDOT)
     */
    STATE_VECTOR_SIZE() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 6;
    }
    /**
     * State data as row-major array of doubles.
     * Layout: [X0, Y0, Z0, X_DOT0, Y_DOT0, Z_DOT0, X1, Y1, Z1, ...]
     * Time reconstruction: epoch[i] = METADATA.START_TIME + (i * STATE_STEP_SIZE)
     * Length must be divisible by STATE_VECTOR_SIZE.
     */
    STATE_DATA(index) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    stateDataLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    stateDataArray() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Covariance data as flat array (21 elements per epoch for 6x6 lower triangular).
     * Time alignment matches STATE_DATA epochs.
     */
    COVARIANCE_DATA(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    covarianceDataLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    covarianceDataArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Physical properties of the space object.
     */
    PHYSICAL_PROPERTIES(obj) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? (obj || new PhysicalProperties()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Maneuver data.
     */
    MANEUVER_DATA(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? (obj || new Maneuver()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    maneuverDataLength() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Perturbations parameters used.
     */
    PERTURBATIONS(obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new Perturbations()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Orbit determination data.
     */
    ORBIT_DETERMINATION(obj) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? (obj || new OrbitDetermination()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * User-defined parameters and supplemental comments.
     */
    USER_DEFINED_PARAMETERS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? (obj || new UserDefinedParameters()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    userDefinedParametersLength() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startOCM(builder) {
        builder.startObject(12);
    }
    static addHeader(builder, HEADEROffset) {
        builder.addFieldOffset(0, HEADEROffset, 0);
    }
    static addMetadata(builder, METADATAOffset) {
        builder.addFieldOffset(1, METADATAOffset, 0);
    }
    static addTrajType(builder, TRAJ_TYPEOffset) {
        builder.addFieldOffset(2, TRAJ_TYPEOffset, 0);
    }
    static addStateStepSize(builder, STATE_STEP_SIZE) {
        builder.addFieldFloat64(3, STATE_STEP_SIZE, 0.0);
    }
    static addStateVectorSize(builder, STATE_VECTOR_SIZE) {
        builder.addFieldInt8(4, STATE_VECTOR_SIZE, 6);
    }
    static addStateData(builder, STATE_DATAOffset) {
        builder.addFieldOffset(5, STATE_DATAOffset, 0);
    }
    static createStateDataVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startStateDataVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addCovarianceData(builder, COVARIANCE_DATAOffset) {
        builder.addFieldOffset(6, COVARIANCE_DATAOffset, 0);
    }
    static createCovarianceDataVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startCovarianceDataVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addPhysicalProperties(builder, PHYSICAL_PROPERTIESOffset) {
        builder.addFieldOffset(7, PHYSICAL_PROPERTIESOffset, 0);
    }
    static addManeuverData(builder, MANEUVER_DATAOffset) {
        builder.addFieldOffset(8, MANEUVER_DATAOffset, 0);
    }
    static createManeuverDataVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startManeuverDataVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPerturbations(builder, PERTURBATIONSOffset) {
        builder.addFieldOffset(9, PERTURBATIONSOffset, 0);
    }
    static addOrbitDetermination(builder, ORBIT_DETERMINATIONOffset) {
        builder.addFieldOffset(10, ORBIT_DETERMINATIONOffset, 0);
    }
    static addUserDefinedParameters(builder, USER_DEFINED_PARAMETERSOffset) {
        builder.addFieldOffset(11, USER_DEFINED_PARAMETERSOffset, 0);
    }
    static createUserDefinedParametersVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startUserDefinedParametersVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endOCM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishOCMBuffer(builder, offset) {
        builder.finish(offset, '$OCM');
    }
    static finishSizePrefixedOCMBuffer(builder, offset) {
        builder.finish(offset, '$OCM', true);
    }
    unpack() {
        return new OCMT((this.HEADER() !== null ? this.HEADER().unpack() : null), (this.METADATA() !== null ? this.METADATA().unpack() : null), this.TRAJ_TYPE(), this.STATE_STEP_SIZE(), this.STATE_VECTOR_SIZE(), this.bb.createScalarList(this.STATE_DATA.bind(this), this.stateDataLength()), this.bb.createScalarList(this.COVARIANCE_DATA.bind(this), this.covarianceDataLength()), (this.PHYSICAL_PROPERTIES() !== null ? this.PHYSICAL_PROPERTIES().unpack() : null), this.bb.createObjList(this.MANEUVER_DATA.bind(this), this.maneuverDataLength()), (this.PERTURBATIONS() !== null ? this.PERTURBATIONS().unpack() : null), (this.ORBIT_DETERMINATION() !== null ? this.ORBIT_DETERMINATION().unpack() : null), this.bb.createObjList(this.USER_DEFINED_PARAMETERS.bind(this), this.userDefinedParametersLength()));
    }
    unpackTo(_o) {
        _o.HEADER = (this.HEADER() !== null ? this.HEADER().unpack() : null);
        _o.METADATA = (this.METADATA() !== null ? this.METADATA().unpack() : null);
        _o.TRAJ_TYPE = this.TRAJ_TYPE();
        _o.STATE_STEP_SIZE = this.STATE_STEP_SIZE();
        _o.STATE_VECTOR_SIZE = this.STATE_VECTOR_SIZE();
        _o.STATE_DATA = this.bb.createScalarList(this.STATE_DATA.bind(this), this.stateDataLength());
        _o.COVARIANCE_DATA = this.bb.createScalarList(this.COVARIANCE_DATA.bind(this), this.covarianceDataLength());
        _o.PHYSICAL_PROPERTIES = (this.PHYSICAL_PROPERTIES() !== null ? this.PHYSICAL_PROPERTIES().unpack() : null);
        _o.MANEUVER_DATA = this.bb.createObjList(this.MANEUVER_DATA.bind(this), this.maneuverDataLength());
        _o.PERTURBATIONS = (this.PERTURBATIONS() !== null ? this.PERTURBATIONS().unpack() : null);
        _o.ORBIT_DETERMINATION = (this.ORBIT_DETERMINATION() !== null ? this.ORBIT_DETERMINATION().unpack() : null);
        _o.USER_DEFINED_PARAMETERS = this.bb.createObjList(this.USER_DEFINED_PARAMETERS.bind(this), this.userDefinedParametersLength());
    }
}
export class OCMT {
    constructor(HEADER = null, METADATA = null, TRAJ_TYPE = null, STATE_STEP_SIZE = 0.0, STATE_VECTOR_SIZE = 6, STATE_DATA = [], COVARIANCE_DATA = [], PHYSICAL_PROPERTIES = null, MANEUVER_DATA = [], PERTURBATIONS = null, ORBIT_DETERMINATION = null, USER_DEFINED_PARAMETERS = []) {
        this.HEADER = HEADER;
        this.METADATA = METADATA;
        this.TRAJ_TYPE = TRAJ_TYPE;
        this.STATE_STEP_SIZE = STATE_STEP_SIZE;
        this.STATE_VECTOR_SIZE = STATE_VECTOR_SIZE;
        this.STATE_DATA = STATE_DATA;
        this.COVARIANCE_DATA = COVARIANCE_DATA;
        this.PHYSICAL_PROPERTIES = PHYSICAL_PROPERTIES;
        this.MANEUVER_DATA = MANEUVER_DATA;
        this.PERTURBATIONS = PERTURBATIONS;
        this.ORBIT_DETERMINATION = ORBIT_DETERMINATION;
        this.USER_DEFINED_PARAMETERS = USER_DEFINED_PARAMETERS;
    }
    pack(builder) {
        const HEADER = (this.HEADER !== null ? this.HEADER.pack(builder) : 0);
        const METADATA = (this.METADATA !== null ? this.METADATA.pack(builder) : 0);
        const TRAJ_TYPE = (this.TRAJ_TYPE !== null ? builder.createString(this.TRAJ_TYPE) : 0);
        const STATE_DATA = OCM.createStateDataVector(builder, this.STATE_DATA);
        const COVARIANCE_DATA = OCM.createCovarianceDataVector(builder, this.COVARIANCE_DATA);
        const PHYSICAL_PROPERTIES = (this.PHYSICAL_PROPERTIES !== null ? this.PHYSICAL_PROPERTIES.pack(builder) : 0);
        const MANEUVER_DATA = OCM.createManeuverDataVector(builder, builder.createObjectOffsetList(this.MANEUVER_DATA));
        const PERTURBATIONS = (this.PERTURBATIONS !== null ? this.PERTURBATIONS.pack(builder) : 0);
        const ORBIT_DETERMINATION = (this.ORBIT_DETERMINATION !== null ? this.ORBIT_DETERMINATION.pack(builder) : 0);
        const USER_DEFINED_PARAMETERS = OCM.createUserDefinedParametersVector(builder, builder.createObjectOffsetList(this.USER_DEFINED_PARAMETERS));
        OCM.startOCM(builder);
        OCM.addHeader(builder, HEADER);
        OCM.addMetadata(builder, METADATA);
        OCM.addTrajType(builder, TRAJ_TYPE);
        OCM.addStateStepSize(builder, this.STATE_STEP_SIZE);
        OCM.addStateVectorSize(builder, this.STATE_VECTOR_SIZE);
        OCM.addStateData(builder, STATE_DATA);
        OCM.addCovarianceData(builder, COVARIANCE_DATA);
        OCM.addPhysicalProperties(builder, PHYSICAL_PROPERTIES);
        OCM.addManeuverData(builder, MANEUVER_DATA);
        OCM.addPerturbations(builder, PERTURBATIONS);
        OCM.addOrbitDetermination(builder, ORBIT_DETERMINATION);
        OCM.addUserDefinedParameters(builder, USER_DEFINED_PARAMETERS);
        return OCM.endOCM(builder);
    }
}
