// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { attMotionType } from './attMotionType.js';
import { attRepresentation } from './attRepresentation.js';
/**
 * Attitude Data Point
 */
export class ATD {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsATD(bb, obj) {
        return (obj || new ATD()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsATD(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ATD()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$ATD');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    AS_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Satellite catalog number
     */
    SAT_NO() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ORIG_OBJECT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    EPOCH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Attitude representation used
     */
    REPRESENTATION() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : attRepresentation.QUATERNION;
    }
    /**
     * Motion characterization
     */
    MOTION_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : attMotionType.STABILIZED;
    }
    /**
     * Quaternion scalar component (q0 or qc)
     */
    QC() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component 1
     */
    Q1() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component 2
     */
    Q2() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector component 3
     */
    Q3() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion scalar rate (rad/s)
     */
    QC_DOT() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector rate 1 (rad/s)
     */
    Q1_DOT() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector rate 2 (rad/s)
     */
    Q2_DOT() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Quaternion vector rate 3 (rad/s)
     */
    Q3_DOT() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle X (degrees)
     */
    X_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle Y (degrees)
     */
    Y_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Euler angle Z (degrees)
     */
    Z_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angular rate about X (deg/s)
     */
    X_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angular rate about Y (deg/s)
     */
    Y_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angular rate about Z (deg/s)
     */
    Z_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension of spin axis (degrees)
     */
    RA() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Declination of spin axis (degrees)
     */
    DECLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Coning half-angle (degrees)
     */
    CONING_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Precession period (seconds)
     */
    PREC_PERIOD() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Spin period (seconds)
     */
    SPIN_PERIOD() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Attitude uncertainty (degrees, 1-sigma)
     */
    ATTITUDE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Rate uncertainty (deg/s, 1-sigma)
     */
    RATE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Data quality (0-9, 9=best)
     */
    QUALITY() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    REF_FRAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startATD(builder) {
        builder.startObject(31);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addAsId(builder, AS_IDOffset) {
        builder.addFieldOffset(1, AS_IDOffset, 0);
    }
    static addSatNo(builder, SAT_NO) {
        builder.addFieldInt32(2, SAT_NO, 0);
    }
    static addOrigObjectId(builder, ORIG_OBJECT_IDOffset) {
        builder.addFieldOffset(3, ORIG_OBJECT_IDOffset, 0);
    }
    static addEpoch(builder, EPOCHOffset) {
        builder.addFieldOffset(4, EPOCHOffset, 0);
    }
    static addRepresentation(builder, REPRESENTATION) {
        builder.addFieldInt8(5, REPRESENTATION, attRepresentation.QUATERNION);
    }
    static addMotionType(builder, MOTION_TYPE) {
        builder.addFieldInt8(6, MOTION_TYPE, attMotionType.STABILIZED);
    }
    static addQc(builder, QC) {
        builder.addFieldFloat64(7, QC, 0.0);
    }
    static addQ1(builder, Q1) {
        builder.addFieldFloat64(8, Q1, 0.0);
    }
    static addQ2(builder, Q2) {
        builder.addFieldFloat64(9, Q2, 0.0);
    }
    static addQ3(builder, Q3) {
        builder.addFieldFloat64(10, Q3, 0.0);
    }
    static addQcDot(builder, QC_DOT) {
        builder.addFieldFloat64(11, QC_DOT, 0.0);
    }
    static addQ1Dot(builder, Q1_DOT) {
        builder.addFieldFloat64(12, Q1_DOT, 0.0);
    }
    static addQ2Dot(builder, Q2_DOT) {
        builder.addFieldFloat64(13, Q2_DOT, 0.0);
    }
    static addQ3Dot(builder, Q3_DOT) {
        builder.addFieldFloat64(14, Q3_DOT, 0.0);
    }
    static addXAngle(builder, X_ANGLE) {
        builder.addFieldFloat64(15, X_ANGLE, 0.0);
    }
    static addYAngle(builder, Y_ANGLE) {
        builder.addFieldFloat64(16, Y_ANGLE, 0.0);
    }
    static addZAngle(builder, Z_ANGLE) {
        builder.addFieldFloat64(17, Z_ANGLE, 0.0);
    }
    static addXRate(builder, X_RATE) {
        builder.addFieldFloat64(18, X_RATE, 0.0);
    }
    static addYRate(builder, Y_RATE) {
        builder.addFieldFloat64(19, Y_RATE, 0.0);
    }
    static addZRate(builder, Z_RATE) {
        builder.addFieldFloat64(20, Z_RATE, 0.0);
    }
    static addRa(builder, RA) {
        builder.addFieldFloat64(21, RA, 0.0);
    }
    static addDeclination(builder, DECLINATION) {
        builder.addFieldFloat64(22, DECLINATION, 0.0);
    }
    static addConingAngle(builder, CONING_ANGLE) {
        builder.addFieldFloat64(23, CONING_ANGLE, 0.0);
    }
    static addPrecPeriod(builder, PREC_PERIOD) {
        builder.addFieldFloat64(24, PREC_PERIOD, 0.0);
    }
    static addSpinPeriod(builder, SPIN_PERIOD) {
        builder.addFieldFloat64(25, SPIN_PERIOD, 0.0);
    }
    static addAttitudeUnc(builder, ATTITUDE_UNC) {
        builder.addFieldFloat64(26, ATTITUDE_UNC, 0.0);
    }
    static addRateUnc(builder, RATE_UNC) {
        builder.addFieldFloat64(27, RATE_UNC, 0.0);
    }
    static addQuality(builder, QUALITY) {
        builder.addFieldInt8(28, QUALITY, 0);
    }
    static addRefFrame(builder, REF_FRAMEOffset) {
        builder.addFieldOffset(29, REF_FRAMEOffset, 0);
    }
    static addSensorId(builder, SENSOR_IDOffset) {
        builder.addFieldOffset(30, SENSOR_IDOffset, 0);
    }
    static endATD(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishATDBuffer(builder, offset) {
        builder.finish(offset, '$ATD');
    }
    static finishSizePrefixedATDBuffer(builder, offset) {
        builder.finish(offset, '$ATD', true);
    }
    static createATD(builder, IDOffset, AS_IDOffset, SAT_NO, ORIG_OBJECT_IDOffset, EPOCHOffset, REPRESENTATION, MOTION_TYPE, QC, Q1, Q2, Q3, QC_DOT, Q1_DOT, Q2_DOT, Q3_DOT, X_ANGLE, Y_ANGLE, Z_ANGLE, X_RATE, Y_RATE, Z_RATE, RA, DECLINATION, CONING_ANGLE, PREC_PERIOD, SPIN_PERIOD, ATTITUDE_UNC, RATE_UNC, QUALITY, REF_FRAMEOffset, SENSOR_IDOffset) {
        ATD.startATD(builder);
        ATD.addId(builder, IDOffset);
        ATD.addAsId(builder, AS_IDOffset);
        ATD.addSatNo(builder, SAT_NO);
        ATD.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
        ATD.addEpoch(builder, EPOCHOffset);
        ATD.addRepresentation(builder, REPRESENTATION);
        ATD.addMotionType(builder, MOTION_TYPE);
        ATD.addQc(builder, QC);
        ATD.addQ1(builder, Q1);
        ATD.addQ2(builder, Q2);
        ATD.addQ3(builder, Q3);
        ATD.addQcDot(builder, QC_DOT);
        ATD.addQ1Dot(builder, Q1_DOT);
        ATD.addQ2Dot(builder, Q2_DOT);
        ATD.addQ3Dot(builder, Q3_DOT);
        ATD.addXAngle(builder, X_ANGLE);
        ATD.addYAngle(builder, Y_ANGLE);
        ATD.addZAngle(builder, Z_ANGLE);
        ATD.addXRate(builder, X_RATE);
        ATD.addYRate(builder, Y_RATE);
        ATD.addZRate(builder, Z_RATE);
        ATD.addRa(builder, RA);
        ATD.addDeclination(builder, DECLINATION);
        ATD.addConingAngle(builder, CONING_ANGLE);
        ATD.addPrecPeriod(builder, PREC_PERIOD);
        ATD.addSpinPeriod(builder, SPIN_PERIOD);
        ATD.addAttitudeUnc(builder, ATTITUDE_UNC);
        ATD.addRateUnc(builder, RATE_UNC);
        ATD.addQuality(builder, QUALITY);
        ATD.addRefFrame(builder, REF_FRAMEOffset);
        ATD.addSensorId(builder, SENSOR_IDOffset);
        return ATD.endATD(builder);
    }
    unpack() {
        return new ATDT(this.ID(), this.AS_ID(), this.SAT_NO(), this.ORIG_OBJECT_ID(), this.EPOCH(), this.REPRESENTATION(), this.MOTION_TYPE(), this.QC(), this.Q1(), this.Q2(), this.Q3(), this.QC_DOT(), this.Q1_DOT(), this.Q2_DOT(), this.Q3_DOT(), this.X_ANGLE(), this.Y_ANGLE(), this.Z_ANGLE(), this.X_RATE(), this.Y_RATE(), this.Z_RATE(), this.RA(), this.DECLINATION(), this.CONING_ANGLE(), this.PREC_PERIOD(), this.SPIN_PERIOD(), this.ATTITUDE_UNC(), this.RATE_UNC(), this.QUALITY(), this.REF_FRAME(), this.SENSOR_ID());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.AS_ID = this.AS_ID();
        _o.SAT_NO = this.SAT_NO();
        _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
        _o.EPOCH = this.EPOCH();
        _o.REPRESENTATION = this.REPRESENTATION();
        _o.MOTION_TYPE = this.MOTION_TYPE();
        _o.QC = this.QC();
        _o.Q1 = this.Q1();
        _o.Q2 = this.Q2();
        _o.Q3 = this.Q3();
        _o.QC_DOT = this.QC_DOT();
        _o.Q1_DOT = this.Q1_DOT();
        _o.Q2_DOT = this.Q2_DOT();
        _o.Q3_DOT = this.Q3_DOT();
        _o.X_ANGLE = this.X_ANGLE();
        _o.Y_ANGLE = this.Y_ANGLE();
        _o.Z_ANGLE = this.Z_ANGLE();
        _o.X_RATE = this.X_RATE();
        _o.Y_RATE = this.Y_RATE();
        _o.Z_RATE = this.Z_RATE();
        _o.RA = this.RA();
        _o.DECLINATION = this.DECLINATION();
        _o.CONING_ANGLE = this.CONING_ANGLE();
        _o.PREC_PERIOD = this.PREC_PERIOD();
        _o.SPIN_PERIOD = this.SPIN_PERIOD();
        _o.ATTITUDE_UNC = this.ATTITUDE_UNC();
        _o.RATE_UNC = this.RATE_UNC();
        _o.QUALITY = this.QUALITY();
        _o.REF_FRAME = this.REF_FRAME();
        _o.SENSOR_ID = this.SENSOR_ID();
    }
}
export class ATDT {
    constructor(ID = null, AS_ID = null, SAT_NO = 0, ORIG_OBJECT_ID = null, EPOCH = null, REPRESENTATION = attRepresentation.QUATERNION, MOTION_TYPE = attMotionType.STABILIZED, QC = 0.0, Q1 = 0.0, Q2 = 0.0, Q3 = 0.0, QC_DOT = 0.0, Q1_DOT = 0.0, Q2_DOT = 0.0, Q3_DOT = 0.0, X_ANGLE = 0.0, Y_ANGLE = 0.0, Z_ANGLE = 0.0, X_RATE = 0.0, Y_RATE = 0.0, Z_RATE = 0.0, RA = 0.0, DECLINATION = 0.0, CONING_ANGLE = 0.0, PREC_PERIOD = 0.0, SPIN_PERIOD = 0.0, ATTITUDE_UNC = 0.0, RATE_UNC = 0.0, QUALITY = 0, REF_FRAME = null, SENSOR_ID = null) {
        this.ID = ID;
        this.AS_ID = AS_ID;
        this.SAT_NO = SAT_NO;
        this.ORIG_OBJECT_ID = ORIG_OBJECT_ID;
        this.EPOCH = EPOCH;
        this.REPRESENTATION = REPRESENTATION;
        this.MOTION_TYPE = MOTION_TYPE;
        this.QC = QC;
        this.Q1 = Q1;
        this.Q2 = Q2;
        this.Q3 = Q3;
        this.QC_DOT = QC_DOT;
        this.Q1_DOT = Q1_DOT;
        this.Q2_DOT = Q2_DOT;
        this.Q3_DOT = Q3_DOT;
        this.X_ANGLE = X_ANGLE;
        this.Y_ANGLE = Y_ANGLE;
        this.Z_ANGLE = Z_ANGLE;
        this.X_RATE = X_RATE;
        this.Y_RATE = Y_RATE;
        this.Z_RATE = Z_RATE;
        this.RA = RA;
        this.DECLINATION = DECLINATION;
        this.CONING_ANGLE = CONING_ANGLE;
        this.PREC_PERIOD = PREC_PERIOD;
        this.SPIN_PERIOD = SPIN_PERIOD;
        this.ATTITUDE_UNC = ATTITUDE_UNC;
        this.RATE_UNC = RATE_UNC;
        this.QUALITY = QUALITY;
        this.REF_FRAME = REF_FRAME;
        this.SENSOR_ID = SENSOR_ID;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const AS_ID = (this.AS_ID !== null ? builder.createString(this.AS_ID) : 0);
        const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID) : 0);
        const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH) : 0);
        const REF_FRAME = (this.REF_FRAME !== null ? builder.createString(this.REF_FRAME) : 0);
        const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID) : 0);
        return ATD.createATD(builder, ID, AS_ID, this.SAT_NO, ORIG_OBJECT_ID, EPOCH, this.REPRESENTATION, this.MOTION_TYPE, this.QC, this.Q1, this.Q2, this.Q3, this.QC_DOT, this.Q1_DOT, this.Q2_DOT, this.Q3_DOT, this.X_ANGLE, this.Y_ANGLE, this.Z_ANGLE, this.X_RATE, this.Y_RATE, this.Z_RATE, this.RA, this.DECLINATION, this.CONING_ANGLE, this.PREC_PERIOD, this.SPIN_PERIOD, this.ATTITUDE_UNC, this.RATE_UNC, this.QUALITY, REF_FRAME, SENSOR_ID);
    }
}
