// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Space Data Link Security (CCSDS 355.0-B-1)
 */
export class SDL {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSDL(bb, obj) {
        return (obj || new SDL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSDL(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SDL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$SDL');
    }
    /**
     * Security Parameter Index
     */
    SPI() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Initialization vector length in bytes
     */
    IV_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Initialization vector
     */
    IV(index) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    ivLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    ivArray() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * MAC length in bytes
     */
    MAC_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Message authentication code
     */
    MAC(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    macLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    macArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Pad length
     */
    PAD_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Security payload
     */
    PAYLOAD(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    payloadLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    payloadArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSDL(builder) {
        builder.startObject(7);
    }
    static addSpi(builder, SPI) {
        builder.addFieldInt16(0, SPI, 0);
    }
    static addIvLength(builder, IV_LENGTH) {
        builder.addFieldInt8(1, IV_LENGTH, 0);
    }
    static addIv(builder, IVOffset) {
        builder.addFieldOffset(2, IVOffset, 0);
    }
    static createIvVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startIvVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addMacLength(builder, MAC_LENGTH) {
        builder.addFieldInt8(3, MAC_LENGTH, 0);
    }
    static addMac(builder, MACOffset) {
        builder.addFieldOffset(4, MACOffset, 0);
    }
    static createMacVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startMacVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addPadLength(builder, PAD_LENGTH) {
        builder.addFieldInt8(5, PAD_LENGTH, 0);
    }
    static addPayload(builder, PAYLOADOffset) {
        builder.addFieldOffset(6, PAYLOADOffset, 0);
    }
    static createPayloadVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startPayloadVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSDL(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSDLBuffer(builder, offset) {
        builder.finish(offset, '$SDL');
    }
    static finishSizePrefixedSDLBuffer(builder, offset) {
        builder.finish(offset, '$SDL', true);
    }
    static createSDL(builder, SPI, IV_LENGTH, IVOffset, MAC_LENGTH, MACOffset, PAD_LENGTH, PAYLOADOffset) {
        SDL.startSDL(builder);
        SDL.addSpi(builder, SPI);
        SDL.addIvLength(builder, IV_LENGTH);
        SDL.addIv(builder, IVOffset);
        SDL.addMacLength(builder, MAC_LENGTH);
        SDL.addMac(builder, MACOffset);
        SDL.addPadLength(builder, PAD_LENGTH);
        SDL.addPayload(builder, PAYLOADOffset);
        return SDL.endSDL(builder);
    }
    unpack() {
        return new SDLT(this.SPI(), this.IV_LENGTH(), this.bb.createScalarList(this.IV.bind(this), this.ivLength()), this.MAC_LENGTH(), this.bb.createScalarList(this.MAC.bind(this), this.macLength()), this.PAD_LENGTH(), this.bb.createScalarList(this.PAYLOAD.bind(this), this.payloadLength()));
    }
    unpackTo(_o) {
        _o.SPI = this.SPI();
        _o.IV_LENGTH = this.IV_LENGTH();
        _o.IV = this.bb.createScalarList(this.IV.bind(this), this.ivLength());
        _o.MAC_LENGTH = this.MAC_LENGTH();
        _o.MAC = this.bb.createScalarList(this.MAC.bind(this), this.macLength());
        _o.PAD_LENGTH = this.PAD_LENGTH();
        _o.PAYLOAD = this.bb.createScalarList(this.PAYLOAD.bind(this), this.payloadLength());
    }
}
export class SDLT {
    constructor(SPI = 0, IV_LENGTH = 0, IV = [], MAC_LENGTH = 0, MAC = [], PAD_LENGTH = 0, PAYLOAD = []) {
        this.SPI = SPI;
        this.IV_LENGTH = IV_LENGTH;
        this.IV = IV;
        this.MAC_LENGTH = MAC_LENGTH;
        this.MAC = MAC;
        this.PAD_LENGTH = PAD_LENGTH;
        this.PAYLOAD = PAYLOAD;
    }
    pack(builder) {
        const IV = SDL.createIvVector(builder, this.IV);
        const MAC = SDL.createMacVector(builder, this.MAC);
        const PAYLOAD = SDL.createPayloadVector(builder, this.PAYLOAD);
        return SDL.createSDL(builder, this.SPI, this.IV_LENGTH, IV, this.MAC_LENGTH, MAC, this.PAD_LENGTH, PAYLOAD);
    }
}
