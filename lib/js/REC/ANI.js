// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { analyticType } from './analyticType.js';
/**
 * Analytic Imagery Product
 */
export class ANI {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsANI(bb, obj) {
        return (obj || new ANI()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsANI(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ANI()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$ANI');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Analytic product type
     */
    ANALYTIC_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : analyticType.SPECTRAL;
    }
    ALGORITHM(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ALGORITHM_VERSION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PROCESSING_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    OBS_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Target satellite number (if applicable)
     */
    SAT_NO() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    OBJECT_DESIGNATOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Center right ascension in degrees
     */
    RA() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Center declination in degrees
     */
    DEC() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Field of view in degrees
     */
    FOV() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Visual magnitude estimate
     */
    VISUAL_MAG() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Magnitude uncertainty
     */
    MAG_UNCERTAINTY() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Detected object count
     */
    OBJECT_COUNT() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    LABELS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    labelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Classification confidence scores (0.0-1.0)
     */
    CONFIDENCE(index) {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    confidenceLength() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    confidenceArray() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Feature vector or extracted parameters
     */
    FEATURES(index) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    featuresLength() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    featuresArray() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Quality score (0.0-1.0)
     */
    QUALITY() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    NOTES(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startANI(builder) {
        builder.startObject(21);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addSourceId(builder, SOURCE_IDOffset) {
        builder.addFieldOffset(1, SOURCE_IDOffset, 0);
    }
    static addSourceType(builder, SOURCE_TYPEOffset) {
        builder.addFieldOffset(2, SOURCE_TYPEOffset, 0);
    }
    static addAnalyticType(builder, ANALYTIC_TYPE) {
        builder.addFieldInt8(3, ANALYTIC_TYPE, analyticType.SPECTRAL);
    }
    static addAlgorithm(builder, ALGORITHMOffset) {
        builder.addFieldOffset(4, ALGORITHMOffset, 0);
    }
    static addAlgorithmVersion(builder, ALGORITHM_VERSIONOffset) {
        builder.addFieldOffset(5, ALGORITHM_VERSIONOffset, 0);
    }
    static addProcessingTime(builder, PROCESSING_TIMEOffset) {
        builder.addFieldOffset(6, PROCESSING_TIMEOffset, 0);
    }
    static addObsTime(builder, OBS_TIMEOffset) {
        builder.addFieldOffset(7, OBS_TIMEOffset, 0);
    }
    static addSatNo(builder, SAT_NO) {
        builder.addFieldInt32(8, SAT_NO, 0);
    }
    static addObjectDesignator(builder, OBJECT_DESIGNATOROffset) {
        builder.addFieldOffset(9, OBJECT_DESIGNATOROffset, 0);
    }
    static addRa(builder, RA) {
        builder.addFieldFloat64(10, RA, 0.0);
    }
    static addDec(builder, DEC) {
        builder.addFieldFloat64(11, DEC, 0.0);
    }
    static addFov(builder, FOV) {
        builder.addFieldFloat64(12, FOV, 0.0);
    }
    static addVisualMag(builder, VISUAL_MAG) {
        builder.addFieldFloat64(13, VISUAL_MAG, 0.0);
    }
    static addMagUncertainty(builder, MAG_UNCERTAINTY) {
        builder.addFieldFloat64(14, MAG_UNCERTAINTY, 0.0);
    }
    static addObjectCount(builder, OBJECT_COUNT) {
        builder.addFieldInt32(15, OBJECT_COUNT, 0);
    }
    static addLabels(builder, LABELSOffset) {
        builder.addFieldOffset(16, LABELSOffset, 0);
    }
    static createLabelsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startLabelsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addConfidence(builder, CONFIDENCEOffset) {
        builder.addFieldOffset(17, CONFIDENCEOffset, 0);
    }
    static createConfidenceVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startConfidenceVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addFeatures(builder, FEATURESOffset) {
        builder.addFieldOffset(18, FEATURESOffset, 0);
    }
    static createFeaturesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addQuality(builder, QUALITY) {
        builder.addFieldFloat64(19, QUALITY, 0.0);
    }
    static addNotes(builder, NOTESOffset) {
        builder.addFieldOffset(20, NOTESOffset, 0);
    }
    static endANI(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishANIBuffer(builder, offset) {
        builder.finish(offset, '$ANI');
    }
    static finishSizePrefixedANIBuffer(builder, offset) {
        builder.finish(offset, '$ANI', true);
    }
    static createANI(builder, IDOffset, SOURCE_IDOffset, SOURCE_TYPEOffset, ANALYTIC_TYPE, ALGORITHMOffset, ALGORITHM_VERSIONOffset, PROCESSING_TIMEOffset, OBS_TIMEOffset, SAT_NO, OBJECT_DESIGNATOROffset, RA, DEC, FOV, VISUAL_MAG, MAG_UNCERTAINTY, OBJECT_COUNT, LABELSOffset, CONFIDENCEOffset, FEATURESOffset, QUALITY, NOTESOffset) {
        ANI.startANI(builder);
        ANI.addId(builder, IDOffset);
        ANI.addSourceId(builder, SOURCE_IDOffset);
        ANI.addSourceType(builder, SOURCE_TYPEOffset);
        ANI.addAnalyticType(builder, ANALYTIC_TYPE);
        ANI.addAlgorithm(builder, ALGORITHMOffset);
        ANI.addAlgorithmVersion(builder, ALGORITHM_VERSIONOffset);
        ANI.addProcessingTime(builder, PROCESSING_TIMEOffset);
        ANI.addObsTime(builder, OBS_TIMEOffset);
        ANI.addSatNo(builder, SAT_NO);
        ANI.addObjectDesignator(builder, OBJECT_DESIGNATOROffset);
        ANI.addRa(builder, RA);
        ANI.addDec(builder, DEC);
        ANI.addFov(builder, FOV);
        ANI.addVisualMag(builder, VISUAL_MAG);
        ANI.addMagUncertainty(builder, MAG_UNCERTAINTY);
        ANI.addObjectCount(builder, OBJECT_COUNT);
        ANI.addLabels(builder, LABELSOffset);
        ANI.addConfidence(builder, CONFIDENCEOffset);
        ANI.addFeatures(builder, FEATURESOffset);
        ANI.addQuality(builder, QUALITY);
        ANI.addNotes(builder, NOTESOffset);
        return ANI.endANI(builder);
    }
    unpack() {
        return new ANIT(this.ID(), this.SOURCE_ID(), this.SOURCE_TYPE(), this.ANALYTIC_TYPE(), this.ALGORITHM(), this.ALGORITHM_VERSION(), this.PROCESSING_TIME(), this.OBS_TIME(), this.SAT_NO(), this.OBJECT_DESIGNATOR(), this.RA(), this.DEC(), this.FOV(), this.VISUAL_MAG(), this.MAG_UNCERTAINTY(), this.OBJECT_COUNT(), this.bb.createScalarList(this.LABELS.bind(this), this.labelsLength()), this.bb.createScalarList(this.CONFIDENCE.bind(this), this.confidenceLength()), this.bb.createScalarList(this.FEATURES.bind(this), this.featuresLength()), this.QUALITY(), this.NOTES());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.SOURCE_ID = this.SOURCE_ID();
        _o.SOURCE_TYPE = this.SOURCE_TYPE();
        _o.ANALYTIC_TYPE = this.ANALYTIC_TYPE();
        _o.ALGORITHM = this.ALGORITHM();
        _o.ALGORITHM_VERSION = this.ALGORITHM_VERSION();
        _o.PROCESSING_TIME = this.PROCESSING_TIME();
        _o.OBS_TIME = this.OBS_TIME();
        _o.SAT_NO = this.SAT_NO();
        _o.OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR();
        _o.RA = this.RA();
        _o.DEC = this.DEC();
        _o.FOV = this.FOV();
        _o.VISUAL_MAG = this.VISUAL_MAG();
        _o.MAG_UNCERTAINTY = this.MAG_UNCERTAINTY();
        _o.OBJECT_COUNT = this.OBJECT_COUNT();
        _o.LABELS = this.bb.createScalarList(this.LABELS.bind(this), this.labelsLength());
        _o.CONFIDENCE = this.bb.createScalarList(this.CONFIDENCE.bind(this), this.confidenceLength());
        _o.FEATURES = this.bb.createScalarList(this.FEATURES.bind(this), this.featuresLength());
        _o.QUALITY = this.QUALITY();
        _o.NOTES = this.NOTES();
    }
}
export class ANIT {
    constructor(ID = null, SOURCE_ID = null, SOURCE_TYPE = null, ANALYTIC_TYPE = analyticType.SPECTRAL, ALGORITHM = null, ALGORITHM_VERSION = null, PROCESSING_TIME = null, OBS_TIME = null, SAT_NO = 0, OBJECT_DESIGNATOR = null, RA = 0.0, DEC = 0.0, FOV = 0.0, VISUAL_MAG = 0.0, MAG_UNCERTAINTY = 0.0, OBJECT_COUNT = 0, LABELS = [], CONFIDENCE = [], FEATURES = [], QUALITY = 0.0, NOTES = null) {
        this.ID = ID;
        this.SOURCE_ID = SOURCE_ID;
        this.SOURCE_TYPE = SOURCE_TYPE;
        this.ANALYTIC_TYPE = ANALYTIC_TYPE;
        this.ALGORITHM = ALGORITHM;
        this.ALGORITHM_VERSION = ALGORITHM_VERSION;
        this.PROCESSING_TIME = PROCESSING_TIME;
        this.OBS_TIME = OBS_TIME;
        this.SAT_NO = SAT_NO;
        this.OBJECT_DESIGNATOR = OBJECT_DESIGNATOR;
        this.RA = RA;
        this.DEC = DEC;
        this.FOV = FOV;
        this.VISUAL_MAG = VISUAL_MAG;
        this.MAG_UNCERTAINTY = MAG_UNCERTAINTY;
        this.OBJECT_COUNT = OBJECT_COUNT;
        this.LABELS = LABELS;
        this.CONFIDENCE = CONFIDENCE;
        this.FEATURES = FEATURES;
        this.QUALITY = QUALITY;
        this.NOTES = NOTES;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const SOURCE_ID = (this.SOURCE_ID !== null ? builder.createString(this.SOURCE_ID) : 0);
        const SOURCE_TYPE = (this.SOURCE_TYPE !== null ? builder.createString(this.SOURCE_TYPE) : 0);
        const ALGORITHM = (this.ALGORITHM !== null ? builder.createString(this.ALGORITHM) : 0);
        const ALGORITHM_VERSION = (this.ALGORITHM_VERSION !== null ? builder.createString(this.ALGORITHM_VERSION) : 0);
        const PROCESSING_TIME = (this.PROCESSING_TIME !== null ? builder.createString(this.PROCESSING_TIME) : 0);
        const OBS_TIME = (this.OBS_TIME !== null ? builder.createString(this.OBS_TIME) : 0);
        const OBJECT_DESIGNATOR = (this.OBJECT_DESIGNATOR !== null ? builder.createString(this.OBJECT_DESIGNATOR) : 0);
        const LABELS = ANI.createLabelsVector(builder, builder.createObjectOffsetList(this.LABELS));
        const CONFIDENCE = ANI.createConfidenceVector(builder, this.CONFIDENCE);
        const FEATURES = ANI.createFeaturesVector(builder, this.FEATURES);
        const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES) : 0);
        return ANI.createANI(builder, ID, SOURCE_ID, SOURCE_TYPE, this.ANALYTIC_TYPE, ALGORITHM, ALGORITHM_VERSION, PROCESSING_TIME, OBS_TIME, this.SAT_NO, OBJECT_DESIGNATOR, this.RA, this.DEC, this.FOV, this.VISUAL_MAG, this.MAG_UNCERTAINTY, this.OBJECT_COUNT, LABELS, CONFIDENCE, FEATURES, this.QUALITY, NOTES);
    }
}
