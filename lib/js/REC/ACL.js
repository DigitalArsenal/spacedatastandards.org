// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { accessType } from './accessType.js';
import { paymentMethod } from './paymentMethod.js';
/**
 * Access Control Grant - Permission to access purchased data
 */
export class ACL {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsACL(bb, obj) {
        return (obj || new ACL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsACL(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ACL()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$ACL');
    }
    GRANT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    LISTING_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BUYER_PEER_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Buyer's encryption public key for encrypted delivery
     */
    BUYER_ENCRYPTION_PUBKEY(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    buyerEncryptionPubkeyLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buyerEncryptionPubkeyArray() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Type of access granted
     */
    ACCESS_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : accessType.OneTime;
    }
    TIER_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Unix timestamp when access was granted
     */
    GRANTED_AT() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Unix timestamp when access expires (0 = never expires)
     */
    EXPIRES_AT() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    PAYMENT_TX_HASH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Payment method used
     */
    PAYMENT_METHOD() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : paymentMethod.Crypto_ETH;
    }
    /**
     * Ed25519 signature from provider
     */
    PROVIDER_SIGNATURE(index) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    providerSignatureLength() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    providerSignatureArray() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startACL(builder) {
        builder.startObject(11);
    }
    static addGrantId(builder, GRANT_IDOffset) {
        builder.addFieldOffset(0, GRANT_IDOffset, 0);
    }
    static addListingId(builder, LISTING_IDOffset) {
        builder.addFieldOffset(1, LISTING_IDOffset, 0);
    }
    static addBuyerPeerId(builder, BUYER_PEER_IDOffset) {
        builder.addFieldOffset(2, BUYER_PEER_IDOffset, 0);
    }
    static addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset) {
        builder.addFieldOffset(3, BUYER_ENCRYPTION_PUBKEYOffset, 0);
    }
    static createBuyerEncryptionPubkeyVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startBuyerEncryptionPubkeyVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addAccessType(builder, ACCESS_TYPE) {
        builder.addFieldInt8(4, ACCESS_TYPE, accessType.OneTime);
    }
    static addTierName(builder, TIER_NAMEOffset) {
        builder.addFieldOffset(5, TIER_NAMEOffset, 0);
    }
    static addGrantedAt(builder, GRANTED_AT) {
        builder.addFieldInt64(6, GRANTED_AT, BigInt('0'));
    }
    static addExpiresAt(builder, EXPIRES_AT) {
        builder.addFieldInt64(7, EXPIRES_AT, BigInt('0'));
    }
    static addPaymentTxHash(builder, PAYMENT_TX_HASHOffset) {
        builder.addFieldOffset(8, PAYMENT_TX_HASHOffset, 0);
    }
    static addPaymentMethod(builder, PAYMENT_METHOD) {
        builder.addFieldInt8(9, PAYMENT_METHOD, paymentMethod.Crypto_ETH);
    }
    static addProviderSignature(builder, PROVIDER_SIGNATUREOffset) {
        builder.addFieldOffset(10, PROVIDER_SIGNATUREOffset, 0);
    }
    static createProviderSignatureVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startProviderSignatureVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endACL(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // GRANT_ID
        builder.requiredField(offset, 6); // LISTING_ID
        builder.requiredField(offset, 8); // BUYER_PEER_ID
        return offset;
    }
    static finishACLBuffer(builder, offset) {
        builder.finish(offset, '$ACL');
    }
    static finishSizePrefixedACLBuffer(builder, offset) {
        builder.finish(offset, '$ACL', true);
    }
    static createACL(builder, GRANT_IDOffset, LISTING_IDOffset, BUYER_PEER_IDOffset, BUYER_ENCRYPTION_PUBKEYOffset, ACCESS_TYPE, TIER_NAMEOffset, GRANTED_AT, EXPIRES_AT, PAYMENT_TX_HASHOffset, PAYMENT_METHOD, PROVIDER_SIGNATUREOffset) {
        ACL.startACL(builder);
        ACL.addGrantId(builder, GRANT_IDOffset);
        ACL.addListingId(builder, LISTING_IDOffset);
        ACL.addBuyerPeerId(builder, BUYER_PEER_IDOffset);
        ACL.addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset);
        ACL.addAccessType(builder, ACCESS_TYPE);
        ACL.addTierName(builder, TIER_NAMEOffset);
        ACL.addGrantedAt(builder, GRANTED_AT);
        ACL.addExpiresAt(builder, EXPIRES_AT);
        ACL.addPaymentTxHash(builder, PAYMENT_TX_HASHOffset);
        ACL.addPaymentMethod(builder, PAYMENT_METHOD);
        ACL.addProviderSignature(builder, PROVIDER_SIGNATUREOffset);
        return ACL.endACL(builder);
    }
    unpack() {
        return new ACLT(this.GRANT_ID(), this.LISTING_ID(), this.BUYER_PEER_ID(), this.bb.createScalarList(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength()), this.ACCESS_TYPE(), this.TIER_NAME(), this.GRANTED_AT(), this.EXPIRES_AT(), this.PAYMENT_TX_HASH(), this.PAYMENT_METHOD(), this.bb.createScalarList(this.PROVIDER_SIGNATURE.bind(this), this.providerSignatureLength()));
    }
    unpackTo(_o) {
        _o.GRANT_ID = this.GRANT_ID();
        _o.LISTING_ID = this.LISTING_ID();
        _o.BUYER_PEER_ID = this.BUYER_PEER_ID();
        _o.BUYER_ENCRYPTION_PUBKEY = this.bb.createScalarList(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength());
        _o.ACCESS_TYPE = this.ACCESS_TYPE();
        _o.TIER_NAME = this.TIER_NAME();
        _o.GRANTED_AT = this.GRANTED_AT();
        _o.EXPIRES_AT = this.EXPIRES_AT();
        _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH();
        _o.PAYMENT_METHOD = this.PAYMENT_METHOD();
        _o.PROVIDER_SIGNATURE = this.bb.createScalarList(this.PROVIDER_SIGNATURE.bind(this), this.providerSignatureLength());
    }
}
export class ACLT {
    constructor(GRANT_ID = null, LISTING_ID = null, BUYER_PEER_ID = null, BUYER_ENCRYPTION_PUBKEY = [], ACCESS_TYPE = accessType.OneTime, TIER_NAME = null, GRANTED_AT = BigInt('0'), EXPIRES_AT = BigInt('0'), PAYMENT_TX_HASH = null, PAYMENT_METHOD = paymentMethod.Crypto_ETH, PROVIDER_SIGNATURE = []) {
        this.GRANT_ID = GRANT_ID;
        this.LISTING_ID = LISTING_ID;
        this.BUYER_PEER_ID = BUYER_PEER_ID;
        this.BUYER_ENCRYPTION_PUBKEY = BUYER_ENCRYPTION_PUBKEY;
        this.ACCESS_TYPE = ACCESS_TYPE;
        this.TIER_NAME = TIER_NAME;
        this.GRANTED_AT = GRANTED_AT;
        this.EXPIRES_AT = EXPIRES_AT;
        this.PAYMENT_TX_HASH = PAYMENT_TX_HASH;
        this.PAYMENT_METHOD = PAYMENT_METHOD;
        this.PROVIDER_SIGNATURE = PROVIDER_SIGNATURE;
    }
    pack(builder) {
        const GRANT_ID = (this.GRANT_ID !== null ? builder.createString(this.GRANT_ID) : 0);
        const LISTING_ID = (this.LISTING_ID !== null ? builder.createString(this.LISTING_ID) : 0);
        const BUYER_PEER_ID = (this.BUYER_PEER_ID !== null ? builder.createString(this.BUYER_PEER_ID) : 0);
        const BUYER_ENCRYPTION_PUBKEY = ACL.createBuyerEncryptionPubkeyVector(builder, this.BUYER_ENCRYPTION_PUBKEY);
        const TIER_NAME = (this.TIER_NAME !== null ? builder.createString(this.TIER_NAME) : 0);
        const PAYMENT_TX_HASH = (this.PAYMENT_TX_HASH !== null ? builder.createString(this.PAYMENT_TX_HASH) : 0);
        const PROVIDER_SIGNATURE = ACL.createProviderSignatureVector(builder, this.PROVIDER_SIGNATURE);
        return ACL.createACL(builder, GRANT_ID, LISTING_ID, BUYER_PEER_ID, BUYER_ENCRYPTION_PUBKEY, this.ACCESS_TYPE, TIER_NAME, this.GRANTED_AT, this.EXPIRES_AT, PAYMENT_TX_HASH, this.PAYMENT_METHOD, PROVIDER_SIGNATURE);
    }
}
