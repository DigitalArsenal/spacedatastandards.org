// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { CAT } from './CAT.js';
/**
 * Conjunction Summary Message
 */
export class CSM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCSM(bb, obj) {
        return (obj || new CSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCSM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$CSM');
    }
    /**
     * Satellite name for the first object
     */
    OBJECT_1(obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new CAT()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Days since epoch for the first object
     */
    DSE_1() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Satellite name for the second object
     */
    OBJECT_2(obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new CAT()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Days since epoch for the second object
     */
    DSE_2() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Time of closest approach as a Unix timestamp
     */
    TCA() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The distance or range between the two objects at TCA
     */
    TCA_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The magnitude of the relative velocity at TCA
     */
    TCA_RELATIVE_SPEED() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Maximum probability
     */
    MAX_PROB() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Standard deviation that produces the maximum probability
     */
    DILUTION() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    static startCSM(builder) {
        builder.startObject(9);
    }
    static addObject1(builder, OBJECT_1Offset) {
        builder.addFieldOffset(0, OBJECT_1Offset, 0);
    }
    static addDse1(builder, DSE_1) {
        builder.addFieldFloat64(1, DSE_1, 0.0);
    }
    static addObject2(builder, OBJECT_2Offset) {
        builder.addFieldOffset(2, OBJECT_2Offset, 0);
    }
    static addDse2(builder, DSE_2) {
        builder.addFieldFloat64(3, DSE_2, 0.0);
    }
    static addTca(builder, TCA) {
        builder.addFieldFloat64(4, TCA, 0.0);
    }
    static addTcaRange(builder, TCA_RANGE) {
        builder.addFieldFloat64(5, TCA_RANGE, 0.0);
    }
    static addTcaRelativeSpeed(builder, TCA_RELATIVE_SPEED) {
        builder.addFieldFloat64(6, TCA_RELATIVE_SPEED, 0.0);
    }
    static addMaxProb(builder, MAX_PROB) {
        builder.addFieldFloat64(7, MAX_PROB, 0.0);
    }
    static addDilution(builder, DILUTION) {
        builder.addFieldFloat64(8, DILUTION, 0.0);
    }
    static endCSM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishCSMBuffer(builder, offset) {
        builder.finish(offset, '$CSM');
    }
    static finishSizePrefixedCSMBuffer(builder, offset) {
        builder.finish(offset, '$CSM', true);
    }
    unpack() {
        return new CSMT((this.OBJECT_1() !== null ? this.OBJECT_1().unpack() : null), this.DSE_1(), (this.OBJECT_2() !== null ? this.OBJECT_2().unpack() : null), this.DSE_2(), this.TCA(), this.TCA_RANGE(), this.TCA_RELATIVE_SPEED(), this.MAX_PROB(), this.DILUTION());
    }
    unpackTo(_o) {
        _o.OBJECT_1 = (this.OBJECT_1() !== null ? this.OBJECT_1().unpack() : null);
        _o.DSE_1 = this.DSE_1();
        _o.OBJECT_2 = (this.OBJECT_2() !== null ? this.OBJECT_2().unpack() : null);
        _o.DSE_2 = this.DSE_2();
        _o.TCA = this.TCA();
        _o.TCA_RANGE = this.TCA_RANGE();
        _o.TCA_RELATIVE_SPEED = this.TCA_RELATIVE_SPEED();
        _o.MAX_PROB = this.MAX_PROB();
        _o.DILUTION = this.DILUTION();
    }
}
export class CSMT {
    constructor(OBJECT_1 = null, DSE_1 = 0.0, OBJECT_2 = null, DSE_2 = 0.0, TCA = 0.0, TCA_RANGE = 0.0, TCA_RELATIVE_SPEED = 0.0, MAX_PROB = 0.0, DILUTION = 0.0) {
        this.OBJECT_1 = OBJECT_1;
        this.DSE_1 = DSE_1;
        this.OBJECT_2 = OBJECT_2;
        this.DSE_2 = DSE_2;
        this.TCA = TCA;
        this.TCA_RANGE = TCA_RANGE;
        this.TCA_RELATIVE_SPEED = TCA_RELATIVE_SPEED;
        this.MAX_PROB = MAX_PROB;
        this.DILUTION = DILUTION;
    }
    pack(builder) {
        const OBJECT_1 = (this.OBJECT_1 !== null ? this.OBJECT_1.pack(builder) : 0);
        const OBJECT_2 = (this.OBJECT_2 !== null ? this.OBJECT_2.pack(builder) : 0);
        CSM.startCSM(builder);
        CSM.addObject1(builder, OBJECT_1);
        CSM.addDse1(builder, this.DSE_1);
        CSM.addObject2(builder, OBJECT_2);
        CSM.addDse2(builder, this.DSE_2);
        CSM.addTca(builder, this.TCA);
        CSM.addTcaRange(builder, this.TCA_RANGE);
        CSM.addTcaRelativeSpeed(builder, this.TCA_RELATIVE_SPEED);
        CSM.addMaxProb(builder, this.MAX_PROB);
        CSM.addDilution(builder, this.DILUTION);
        return CSM.endCSM(builder);
    }
}
