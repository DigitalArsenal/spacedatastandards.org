// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
export class Header {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsHeader(bb, obj) {
        return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsHeader(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    CCSDS_OCM_VERS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    COMMENT(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    commentLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    CLASSIFICATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CREATION_DATE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIGINATOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    MESSAGE_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startHeader(builder) {
        builder.startObject(6);
    }
    static addCcsdsOcmVers(builder, CCSDS_OCM_VERSOffset) {
        builder.addFieldOffset(0, CCSDS_OCM_VERSOffset, 0);
    }
    static addComment(builder, COMMENTOffset) {
        builder.addFieldOffset(1, COMMENTOffset, 0);
    }
    static createCommentVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCommentVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addClassification(builder, CLASSIFICATIONOffset) {
        builder.addFieldOffset(2, CLASSIFICATIONOffset, 0);
    }
    static addCreationDate(builder, CREATION_DATEOffset) {
        builder.addFieldOffset(3, CREATION_DATEOffset, 0);
    }
    static addOriginator(builder, ORIGINATOROffset) {
        builder.addFieldOffset(4, ORIGINATOROffset, 0);
    }
    static addMessageId(builder, MESSAGE_IDOffset) {
        builder.addFieldOffset(5, MESSAGE_IDOffset, 0);
    }
    static endHeader(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createHeader(builder, CCSDS_OCM_VERSOffset, COMMENTOffset, CLASSIFICATIONOffset, CREATION_DATEOffset, ORIGINATOROffset, MESSAGE_IDOffset) {
        Header.startHeader(builder);
        Header.addCcsdsOcmVers(builder, CCSDS_OCM_VERSOffset);
        Header.addComment(builder, COMMENTOffset);
        Header.addClassification(builder, CLASSIFICATIONOffset);
        Header.addCreationDate(builder, CREATION_DATEOffset);
        Header.addOriginator(builder, ORIGINATOROffset);
        Header.addMessageId(builder, MESSAGE_IDOffset);
        return Header.endHeader(builder);
    }
    unpack() {
        return new HeaderT(this.CCSDS_OCM_VERS(), this.bb.createScalarList(this.COMMENT.bind(this), this.commentLength()), this.CLASSIFICATION(), this.CREATION_DATE(), this.ORIGINATOR(), this.MESSAGE_ID());
    }
    unpackTo(_o) {
        _o.CCSDS_OCM_VERS = this.CCSDS_OCM_VERS();
        _o.COMMENT = this.bb.createScalarList(this.COMMENT.bind(this), this.commentLength());
        _o.CLASSIFICATION = this.CLASSIFICATION();
        _o.CREATION_DATE = this.CREATION_DATE();
        _o.ORIGINATOR = this.ORIGINATOR();
        _o.MESSAGE_ID = this.MESSAGE_ID();
    }
}
export class HeaderT {
    constructor(CCSDS_OCM_VERS = null, COMMENT = [], CLASSIFICATION = null, CREATION_DATE = null, ORIGINATOR = null, MESSAGE_ID = null) {
        this.CCSDS_OCM_VERS = CCSDS_OCM_VERS;
        this.COMMENT = COMMENT;
        this.CLASSIFICATION = CLASSIFICATION;
        this.CREATION_DATE = CREATION_DATE;
        this.ORIGINATOR = ORIGINATOR;
        this.MESSAGE_ID = MESSAGE_ID;
    }
    pack(builder) {
        const CCSDS_OCM_VERS = (this.CCSDS_OCM_VERS !== null ? builder.createString(this.CCSDS_OCM_VERS) : 0);
        const COMMENT = Header.createCommentVector(builder, builder.createObjectOffsetList(this.COMMENT));
        const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION) : 0);
        const CREATION_DATE = (this.CREATION_DATE !== null ? builder.createString(this.CREATION_DATE) : 0);
        const ORIGINATOR = (this.ORIGINATOR !== null ? builder.createString(this.ORIGINATOR) : 0);
        const MESSAGE_ID = (this.MESSAGE_ID !== null ? builder.createString(this.MESSAGE_ID) : 0);
        return Header.createHeader(builder, CCSDS_OCM_VERS, COMMENT, CLASSIFICATION, CREATION_DATE, ORIGINATOR, MESSAGE_ID);
    }
}
