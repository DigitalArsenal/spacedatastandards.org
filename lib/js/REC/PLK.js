// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { licenseType } from './licenseType.js';
/**
 * Plugin License Key - Issued license for plugin access
 * Uses ECIES: both parties derive symmetric key via X25519 ECDH
 * Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
 */
export class PLK {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPLK(bb, obj) {
        return (obj || new PLK()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPLK(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PLK()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$PLK');
    }
    LICENSE_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PLUGIN_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PLUGIN_VERSION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    LICENSEE_ORG(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    LICENSEE_EMAIL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    LICENSEE_PEER_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Licensee's X25519 public key (32 bytes)
     */
    LICENSEE_PUBKEY(index) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    licenseePubkeyLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    licenseePubkeyArray() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Issuer's X25519 public key (32 bytes)
     * Used with licensee's private key to derive shared secret via ECDH
     */
    ISSUER_PUBKEY(index) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    issuerPubkeyLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    issuerPubkeyArray() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    ALLOWED_DOMAINS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    allowedDomainsLength() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    ALLOWED_TLDS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    allowedTldsLength() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Type of license
     */
    LICENSE_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : licenseType.Trial;
    }
    /**
     * Maximum concurrent activations (0 = unlimited)
     */
    MAX_ACTIVATIONS() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Unix timestamp when license was issued
     */
    ISSUED_AT() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Unix timestamp when license becomes valid
     */
    VALID_FROM() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    /**
     * Unix timestamp when license expires (0 = never expires)
     */
    EXPIRES_AT() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    ISSUER_PEER_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Ed25519 signature from issuer over all fields (except SIGNATURE)
     */
    SIGNATURE(index) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    signatureLength() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    signatureArray() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startPLK(builder) {
        builder.startObject(17);
    }
    static addLicenseId(builder, LICENSE_IDOffset) {
        builder.addFieldOffset(0, LICENSE_IDOffset, 0);
    }
    static addPluginId(builder, PLUGIN_IDOffset) {
        builder.addFieldOffset(1, PLUGIN_IDOffset, 0);
    }
    static addPluginVersion(builder, PLUGIN_VERSIONOffset) {
        builder.addFieldOffset(2, PLUGIN_VERSIONOffset, 0);
    }
    static addLicenseeOrg(builder, LICENSEE_ORGOffset) {
        builder.addFieldOffset(3, LICENSEE_ORGOffset, 0);
    }
    static addLicenseeEmail(builder, LICENSEE_EMAILOffset) {
        builder.addFieldOffset(4, LICENSEE_EMAILOffset, 0);
    }
    static addLicenseePeerId(builder, LICENSEE_PEER_IDOffset) {
        builder.addFieldOffset(5, LICENSEE_PEER_IDOffset, 0);
    }
    static addLicenseePubkey(builder, LICENSEE_PUBKEYOffset) {
        builder.addFieldOffset(6, LICENSEE_PUBKEYOffset, 0);
    }
    static createLicenseePubkeyVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startLicenseePubkeyVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addIssuerPubkey(builder, ISSUER_PUBKEYOffset) {
        builder.addFieldOffset(7, ISSUER_PUBKEYOffset, 0);
    }
    static createIssuerPubkeyVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startIssuerPubkeyVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addAllowedDomains(builder, ALLOWED_DOMAINSOffset) {
        builder.addFieldOffset(8, ALLOWED_DOMAINSOffset, 0);
    }
    static createAllowedDomainsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startAllowedDomainsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addAllowedTlds(builder, ALLOWED_TLDSOffset) {
        builder.addFieldOffset(9, ALLOWED_TLDSOffset, 0);
    }
    static createAllowedTldsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startAllowedTldsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addLicenseType(builder, LICENSE_TYPE) {
        builder.addFieldInt8(10, LICENSE_TYPE, licenseType.Trial);
    }
    static addMaxActivations(builder, MAX_ACTIVATIONS) {
        builder.addFieldInt32(11, MAX_ACTIVATIONS, 0);
    }
    static addIssuedAt(builder, ISSUED_AT) {
        builder.addFieldInt64(12, ISSUED_AT, BigInt('0'));
    }
    static addValidFrom(builder, VALID_FROM) {
        builder.addFieldInt64(13, VALID_FROM, BigInt('0'));
    }
    static addExpiresAt(builder, EXPIRES_AT) {
        builder.addFieldInt64(14, EXPIRES_AT, BigInt('0'));
    }
    static addIssuerPeerId(builder, ISSUER_PEER_IDOffset) {
        builder.addFieldOffset(15, ISSUER_PEER_IDOffset, 0);
    }
    static addSignature(builder, SIGNATUREOffset) {
        builder.addFieldOffset(16, SIGNATUREOffset, 0);
    }
    static createSignatureVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startSignatureVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endPLK(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // LICENSE_ID
        builder.requiredField(offset, 6); // PLUGIN_ID
        builder.requiredField(offset, 10); // LICENSEE_ORG
        return offset;
    }
    static finishPLKBuffer(builder, offset) {
        builder.finish(offset, '$PLK');
    }
    static finishSizePrefixedPLKBuffer(builder, offset) {
        builder.finish(offset, '$PLK', true);
    }
    static createPLK(builder, LICENSE_IDOffset, PLUGIN_IDOffset, PLUGIN_VERSIONOffset, LICENSEE_ORGOffset, LICENSEE_EMAILOffset, LICENSEE_PEER_IDOffset, LICENSEE_PUBKEYOffset, ISSUER_PUBKEYOffset, ALLOWED_DOMAINSOffset, ALLOWED_TLDSOffset, LICENSE_TYPE, MAX_ACTIVATIONS, ISSUED_AT, VALID_FROM, EXPIRES_AT, ISSUER_PEER_IDOffset, SIGNATUREOffset) {
        PLK.startPLK(builder);
        PLK.addLicenseId(builder, LICENSE_IDOffset);
        PLK.addPluginId(builder, PLUGIN_IDOffset);
        PLK.addPluginVersion(builder, PLUGIN_VERSIONOffset);
        PLK.addLicenseeOrg(builder, LICENSEE_ORGOffset);
        PLK.addLicenseeEmail(builder, LICENSEE_EMAILOffset);
        PLK.addLicenseePeerId(builder, LICENSEE_PEER_IDOffset);
        PLK.addLicenseePubkey(builder, LICENSEE_PUBKEYOffset);
        PLK.addIssuerPubkey(builder, ISSUER_PUBKEYOffset);
        PLK.addAllowedDomains(builder, ALLOWED_DOMAINSOffset);
        PLK.addAllowedTlds(builder, ALLOWED_TLDSOffset);
        PLK.addLicenseType(builder, LICENSE_TYPE);
        PLK.addMaxActivations(builder, MAX_ACTIVATIONS);
        PLK.addIssuedAt(builder, ISSUED_AT);
        PLK.addValidFrom(builder, VALID_FROM);
        PLK.addExpiresAt(builder, EXPIRES_AT);
        PLK.addIssuerPeerId(builder, ISSUER_PEER_IDOffset);
        PLK.addSignature(builder, SIGNATUREOffset);
        return PLK.endPLK(builder);
    }
    unpack() {
        return new PLKT(this.LICENSE_ID(), this.PLUGIN_ID(), this.PLUGIN_VERSION(), this.LICENSEE_ORG(), this.LICENSEE_EMAIL(), this.LICENSEE_PEER_ID(), this.bb.createScalarList(this.LICENSEE_PUBKEY.bind(this), this.licenseePubkeyLength()), this.bb.createScalarList(this.ISSUER_PUBKEY.bind(this), this.issuerPubkeyLength()), this.bb.createScalarList(this.ALLOWED_DOMAINS.bind(this), this.allowedDomainsLength()), this.bb.createScalarList(this.ALLOWED_TLDS.bind(this), this.allowedTldsLength()), this.LICENSE_TYPE(), this.MAX_ACTIVATIONS(), this.ISSUED_AT(), this.VALID_FROM(), this.EXPIRES_AT(), this.ISSUER_PEER_ID(), this.bb.createScalarList(this.SIGNATURE.bind(this), this.signatureLength()));
    }
    unpackTo(_o) {
        _o.LICENSE_ID = this.LICENSE_ID();
        _o.PLUGIN_ID = this.PLUGIN_ID();
        _o.PLUGIN_VERSION = this.PLUGIN_VERSION();
        _o.LICENSEE_ORG = this.LICENSEE_ORG();
        _o.LICENSEE_EMAIL = this.LICENSEE_EMAIL();
        _o.LICENSEE_PEER_ID = this.LICENSEE_PEER_ID();
        _o.LICENSEE_PUBKEY = this.bb.createScalarList(this.LICENSEE_PUBKEY.bind(this), this.licenseePubkeyLength());
        _o.ISSUER_PUBKEY = this.bb.createScalarList(this.ISSUER_PUBKEY.bind(this), this.issuerPubkeyLength());
        _o.ALLOWED_DOMAINS = this.bb.createScalarList(this.ALLOWED_DOMAINS.bind(this), this.allowedDomainsLength());
        _o.ALLOWED_TLDS = this.bb.createScalarList(this.ALLOWED_TLDS.bind(this), this.allowedTldsLength());
        _o.LICENSE_TYPE = this.LICENSE_TYPE();
        _o.MAX_ACTIVATIONS = this.MAX_ACTIVATIONS();
        _o.ISSUED_AT = this.ISSUED_AT();
        _o.VALID_FROM = this.VALID_FROM();
        _o.EXPIRES_AT = this.EXPIRES_AT();
        _o.ISSUER_PEER_ID = this.ISSUER_PEER_ID();
        _o.SIGNATURE = this.bb.createScalarList(this.SIGNATURE.bind(this), this.signatureLength());
    }
}
export class PLKT {
    constructor(LICENSE_ID = null, PLUGIN_ID = null, PLUGIN_VERSION = null, LICENSEE_ORG = null, LICENSEE_EMAIL = null, LICENSEE_PEER_ID = null, LICENSEE_PUBKEY = [], ISSUER_PUBKEY = [], ALLOWED_DOMAINS = [], ALLOWED_TLDS = [], LICENSE_TYPE = licenseType.Trial, MAX_ACTIVATIONS = 0, ISSUED_AT = BigInt('0'), VALID_FROM = BigInt('0'), EXPIRES_AT = BigInt('0'), ISSUER_PEER_ID = null, SIGNATURE = []) {
        this.LICENSE_ID = LICENSE_ID;
        this.PLUGIN_ID = PLUGIN_ID;
        this.PLUGIN_VERSION = PLUGIN_VERSION;
        this.LICENSEE_ORG = LICENSEE_ORG;
        this.LICENSEE_EMAIL = LICENSEE_EMAIL;
        this.LICENSEE_PEER_ID = LICENSEE_PEER_ID;
        this.LICENSEE_PUBKEY = LICENSEE_PUBKEY;
        this.ISSUER_PUBKEY = ISSUER_PUBKEY;
        this.ALLOWED_DOMAINS = ALLOWED_DOMAINS;
        this.ALLOWED_TLDS = ALLOWED_TLDS;
        this.LICENSE_TYPE = LICENSE_TYPE;
        this.MAX_ACTIVATIONS = MAX_ACTIVATIONS;
        this.ISSUED_AT = ISSUED_AT;
        this.VALID_FROM = VALID_FROM;
        this.EXPIRES_AT = EXPIRES_AT;
        this.ISSUER_PEER_ID = ISSUER_PEER_ID;
        this.SIGNATURE = SIGNATURE;
    }
    pack(builder) {
        const LICENSE_ID = (this.LICENSE_ID !== null ? builder.createString(this.LICENSE_ID) : 0);
        const PLUGIN_ID = (this.PLUGIN_ID !== null ? builder.createString(this.PLUGIN_ID) : 0);
        const PLUGIN_VERSION = (this.PLUGIN_VERSION !== null ? builder.createString(this.PLUGIN_VERSION) : 0);
        const LICENSEE_ORG = (this.LICENSEE_ORG !== null ? builder.createString(this.LICENSEE_ORG) : 0);
        const LICENSEE_EMAIL = (this.LICENSEE_EMAIL !== null ? builder.createString(this.LICENSEE_EMAIL) : 0);
        const LICENSEE_PEER_ID = (this.LICENSEE_PEER_ID !== null ? builder.createString(this.LICENSEE_PEER_ID) : 0);
        const LICENSEE_PUBKEY = PLK.createLicenseePubkeyVector(builder, this.LICENSEE_PUBKEY);
        const ISSUER_PUBKEY = PLK.createIssuerPubkeyVector(builder, this.ISSUER_PUBKEY);
        const ALLOWED_DOMAINS = PLK.createAllowedDomainsVector(builder, builder.createObjectOffsetList(this.ALLOWED_DOMAINS));
        const ALLOWED_TLDS = PLK.createAllowedTldsVector(builder, builder.createObjectOffsetList(this.ALLOWED_TLDS));
        const ISSUER_PEER_ID = (this.ISSUER_PEER_ID !== null ? builder.createString(this.ISSUER_PEER_ID) : 0);
        const SIGNATURE = PLK.createSignatureVector(builder, this.SIGNATURE);
        return PLK.createPLK(builder, LICENSE_ID, PLUGIN_ID, PLUGIN_VERSION, LICENSEE_ORG, LICENSEE_EMAIL, LICENSEE_PEER_ID, LICENSEE_PUBKEY, ISSUER_PUBKEY, ALLOWED_DOMAINS, ALLOWED_TLDS, this.LICENSE_TYPE, this.MAX_ACTIVATIONS, this.ISSUED_AT, this.VALID_FROM, this.EXPIRES_AT, ISSUER_PEER_ID, SIGNATURE);
    }
}
