// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Short-Wave Infrared Observation
 */
export class SWR {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSWR(bb, obj) {
        return (obj || new SWR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSWR(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SWR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$SWR');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ON_ORBIT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_OBJECT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Satellite catalog number
     */
    SAT_NO() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    TS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Solar phase angle (degrees)
     */
    SOLAR_PHASE_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sub-observer latitude (degrees)
     */
    LAT() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sub-observer longitude (degrees)
     */
    LON() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    LOCATION_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BAD_WAVE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Measured wavelengths (micrometers)
     */
    WAVELENGTHS(index) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    wavelengthsLength() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    wavelengthsArray() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Absolute flux values (W/m^2/um)
     */
    ABS_FLUXES(index) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    absFluxesLength() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    absFluxesArray() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Ratio reference wavelengths (micrometers)
     */
    RATIO_WAVELENGTHS(index) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    ratioWavelengthsLength() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    ratioWavelengthsArray() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Flux ratios (normalized)
     */
    FLUX_RATIOS(index) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    fluxRatiosLength() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    fluxRatiosArray() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Effective temperature (Kelvin)
     */
    TEMPERATURE() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Signal-to-noise ratio
     */
    SIGNAL_NOISE_RATIO() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Integration time (seconds)
     */
    INTEGRATION_TIME() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Data quality (0-9, 9=best)
     */
    QUALITY() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    static startSWR(builder) {
        builder.startObject(18);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addOnOrbit(builder, ON_ORBITOffset) {
        builder.addFieldOffset(1, ON_ORBITOffset, 0);
    }
    static addOrigObjectId(builder, ORIG_OBJECT_IDOffset) {
        builder.addFieldOffset(2, ORIG_OBJECT_IDOffset, 0);
    }
    static addSatNo(builder, SAT_NO) {
        builder.addFieldInt32(3, SAT_NO, 0);
    }
    static addTs(builder, TSOffset) {
        builder.addFieldOffset(4, TSOffset, 0);
    }
    static addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE) {
        builder.addFieldFloat64(5, SOLAR_PHASE_ANGLE, 0.0);
    }
    static addLat(builder, LAT) {
        builder.addFieldFloat64(6, LAT, 0.0);
    }
    static addLon(builder, LON) {
        builder.addFieldFloat64(7, LON, 0.0);
    }
    static addLocationName(builder, LOCATION_NAMEOffset) {
        builder.addFieldOffset(8, LOCATION_NAMEOffset, 0);
    }
    static addBadWave(builder, BAD_WAVEOffset) {
        builder.addFieldOffset(9, BAD_WAVEOffset, 0);
    }
    static addWavelengths(builder, WAVELENGTHSOffset) {
        builder.addFieldOffset(10, WAVELENGTHSOffset, 0);
    }
    static createWavelengthsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startWavelengthsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addAbsFluxes(builder, ABS_FLUXESOffset) {
        builder.addFieldOffset(11, ABS_FLUXESOffset, 0);
    }
    static createAbsFluxesVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startAbsFluxesVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addRatioWavelengths(builder, RATIO_WAVELENGTHSOffset) {
        builder.addFieldOffset(12, RATIO_WAVELENGTHSOffset, 0);
    }
    static createRatioWavelengthsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startRatioWavelengthsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addFluxRatios(builder, FLUX_RATIOSOffset) {
        builder.addFieldOffset(13, FLUX_RATIOSOffset, 0);
    }
    static createFluxRatiosVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startFluxRatiosVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addTemperature(builder, TEMPERATURE) {
        builder.addFieldFloat64(14, TEMPERATURE, 0.0);
    }
    static addSignalNoiseRatio(builder, SIGNAL_NOISE_RATIO) {
        builder.addFieldFloat64(15, SIGNAL_NOISE_RATIO, 0.0);
    }
    static addIntegrationTime(builder, INTEGRATION_TIME) {
        builder.addFieldFloat64(16, INTEGRATION_TIME, 0.0);
    }
    static addQuality(builder, QUALITY) {
        builder.addFieldInt8(17, QUALITY, 0);
    }
    static endSWR(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSWRBuffer(builder, offset) {
        builder.finish(offset, '$SWR');
    }
    static finishSizePrefixedSWRBuffer(builder, offset) {
        builder.finish(offset, '$SWR', true);
    }
    static createSWR(builder, IDOffset, ON_ORBITOffset, ORIG_OBJECT_IDOffset, SAT_NO, TSOffset, SOLAR_PHASE_ANGLE, LAT, LON, LOCATION_NAMEOffset, BAD_WAVEOffset, WAVELENGTHSOffset, ABS_FLUXESOffset, RATIO_WAVELENGTHSOffset, FLUX_RATIOSOffset, TEMPERATURE, SIGNAL_NOISE_RATIO, INTEGRATION_TIME, QUALITY) {
        SWR.startSWR(builder);
        SWR.addId(builder, IDOffset);
        SWR.addOnOrbit(builder, ON_ORBITOffset);
        SWR.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
        SWR.addSatNo(builder, SAT_NO);
        SWR.addTs(builder, TSOffset);
        SWR.addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE);
        SWR.addLat(builder, LAT);
        SWR.addLon(builder, LON);
        SWR.addLocationName(builder, LOCATION_NAMEOffset);
        SWR.addBadWave(builder, BAD_WAVEOffset);
        SWR.addWavelengths(builder, WAVELENGTHSOffset);
        SWR.addAbsFluxes(builder, ABS_FLUXESOffset);
        SWR.addRatioWavelengths(builder, RATIO_WAVELENGTHSOffset);
        SWR.addFluxRatios(builder, FLUX_RATIOSOffset);
        SWR.addTemperature(builder, TEMPERATURE);
        SWR.addSignalNoiseRatio(builder, SIGNAL_NOISE_RATIO);
        SWR.addIntegrationTime(builder, INTEGRATION_TIME);
        SWR.addQuality(builder, QUALITY);
        return SWR.endSWR(builder);
    }
    unpack() {
        return new SWRT(this.ID(), this.ON_ORBIT(), this.ORIG_OBJECT_ID(), this.SAT_NO(), this.TS(), this.SOLAR_PHASE_ANGLE(), this.LAT(), this.LON(), this.LOCATION_NAME(), this.BAD_WAVE(), this.bb.createScalarList(this.WAVELENGTHS.bind(this), this.wavelengthsLength()), this.bb.createScalarList(this.ABS_FLUXES.bind(this), this.absFluxesLength()), this.bb.createScalarList(this.RATIO_WAVELENGTHS.bind(this), this.ratioWavelengthsLength()), this.bb.createScalarList(this.FLUX_RATIOS.bind(this), this.fluxRatiosLength()), this.TEMPERATURE(), this.SIGNAL_NOISE_RATIO(), this.INTEGRATION_TIME(), this.QUALITY());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.ON_ORBIT = this.ON_ORBIT();
        _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
        _o.SAT_NO = this.SAT_NO();
        _o.TS = this.TS();
        _o.SOLAR_PHASE_ANGLE = this.SOLAR_PHASE_ANGLE();
        _o.LAT = this.LAT();
        _o.LON = this.LON();
        _o.LOCATION_NAME = this.LOCATION_NAME();
        _o.BAD_WAVE = this.BAD_WAVE();
        _o.WAVELENGTHS = this.bb.createScalarList(this.WAVELENGTHS.bind(this), this.wavelengthsLength());
        _o.ABS_FLUXES = this.bb.createScalarList(this.ABS_FLUXES.bind(this), this.absFluxesLength());
        _o.RATIO_WAVELENGTHS = this.bb.createScalarList(this.RATIO_WAVELENGTHS.bind(this), this.ratioWavelengthsLength());
        _o.FLUX_RATIOS = this.bb.createScalarList(this.FLUX_RATIOS.bind(this), this.fluxRatiosLength());
        _o.TEMPERATURE = this.TEMPERATURE();
        _o.SIGNAL_NOISE_RATIO = this.SIGNAL_NOISE_RATIO();
        _o.INTEGRATION_TIME = this.INTEGRATION_TIME();
        _o.QUALITY = this.QUALITY();
    }
}
export class SWRT {
    constructor(ID = null, ON_ORBIT = null, ORIG_OBJECT_ID = null, SAT_NO = 0, TS = null, SOLAR_PHASE_ANGLE = 0.0, LAT = 0.0, LON = 0.0, LOCATION_NAME = null, BAD_WAVE = null, WAVELENGTHS = [], ABS_FLUXES = [], RATIO_WAVELENGTHS = [], FLUX_RATIOS = [], TEMPERATURE = 0.0, SIGNAL_NOISE_RATIO = 0.0, INTEGRATION_TIME = 0.0, QUALITY = 0) {
        this.ID = ID;
        this.ON_ORBIT = ON_ORBIT;
        this.ORIG_OBJECT_ID = ORIG_OBJECT_ID;
        this.SAT_NO = SAT_NO;
        this.TS = TS;
        this.SOLAR_PHASE_ANGLE = SOLAR_PHASE_ANGLE;
        this.LAT = LAT;
        this.LON = LON;
        this.LOCATION_NAME = LOCATION_NAME;
        this.BAD_WAVE = BAD_WAVE;
        this.WAVELENGTHS = WAVELENGTHS;
        this.ABS_FLUXES = ABS_FLUXES;
        this.RATIO_WAVELENGTHS = RATIO_WAVELENGTHS;
        this.FLUX_RATIOS = FLUX_RATIOS;
        this.TEMPERATURE = TEMPERATURE;
        this.SIGNAL_NOISE_RATIO = SIGNAL_NOISE_RATIO;
        this.INTEGRATION_TIME = INTEGRATION_TIME;
        this.QUALITY = QUALITY;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const ON_ORBIT = (this.ON_ORBIT !== null ? builder.createString(this.ON_ORBIT) : 0);
        const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID) : 0);
        const TS = (this.TS !== null ? builder.createString(this.TS) : 0);
        const LOCATION_NAME = (this.LOCATION_NAME !== null ? builder.createString(this.LOCATION_NAME) : 0);
        const BAD_WAVE = (this.BAD_WAVE !== null ? builder.createString(this.BAD_WAVE) : 0);
        const WAVELENGTHS = SWR.createWavelengthsVector(builder, this.WAVELENGTHS);
        const ABS_FLUXES = SWR.createAbsFluxesVector(builder, this.ABS_FLUXES);
        const RATIO_WAVELENGTHS = SWR.createRatioWavelengthsVector(builder, this.RATIO_WAVELENGTHS);
        const FLUX_RATIOS = SWR.createFluxRatiosVector(builder, this.FLUX_RATIOS);
        return SWR.createSWR(builder, ID, ON_ORBIT, ORIG_OBJECT_ID, this.SAT_NO, TS, this.SOLAR_PHASE_ANGLE, this.LAT, this.LON, LOCATION_NAME, BAD_WAVE, WAVELENGTHS, ABS_FLUXES, RATIO_WAVELENGTHS, FLUX_RATIOS, this.TEMPERATURE, this.SIGNAL_NOISE_RATIO, this.INTEGRATION_TIME, this.QUALITY);
    }
}
