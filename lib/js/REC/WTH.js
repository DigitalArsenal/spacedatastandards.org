// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Weather Data
 */
export class WTH {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsWTH(bb, obj) {
        return (obj || new WTH()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsWTH(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new WTH()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$WTH');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_SENSOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    OB_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    FILE_CREATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Quality control value
     */
    QC_VALUE() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Terminal altitude (km)
     */
    TERM_ALT() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Average transmit power (dBm)
     */
    AVG_TX_PWR() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Average reflected power (dBm)
     */
    AVG_REF_PWR() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sector number
     */
    SECTOR_NUM() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Number of data elements
     */
    NUM_ELEMENTS() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Checksum
     */
    CHECKSUM() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Signal power values (dBm)
     */
    SIG_PWRS(index) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    sigPwrsLength() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    sigPwrsArray() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Noise level values (dBm)
     */
    NOISE_LVLS(index) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    noiseLvlsLength() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    noiseLvlsArray() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Spectral width values (m/s)
     */
    SPEC_WIDTHS(index) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    specWidthsLength() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    specWidthsArray() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * First guess average values
     */
    FIRST_GUESS_AVGS(index) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    firstGuessAvgsLength() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    firstGuessAvgsArray() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Time domain average sample numbers
     */
    TD_AVG_SAMPLE_NUMS(index) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    tdAvgSampleNumsLength() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    tdAvgSampleNumsArray() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Co-integration values
     */
    CO_INTEGS(index) {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    coIntegsLength() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    coIntegsArray() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Spectral average values
     */
    SPEC_AVGS(index) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    specAvgsLength() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    specAvgsArray() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Interpulse periods (microseconds)
     */
    INTERPULSE_PERIODS(index) {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    interpulsePeriodsLength() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    interpulsePeriodsArray() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Doppler velocities (m/s)
     */
    DOPP_VELS(index) {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    doppVelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    doppVelsArray() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Consecutive records count
     */
    CONS_RECS(index) {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    consRecsLength() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    consRecsArray() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Signal-to-noise ratios (dB)
     */
    SNRS(index) {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
    snrsLength() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    snrsArray() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Signal strength (dBm)
     */
    SIG_STRENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Error ellipse semi-major axis (km)
     */
    SEMI_MAJOR_AXIS() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Error ellipse semi-minor axis (km)
     */
    SEMI_MINOR_AXIS() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Error ellipse orientation angle (degrees)
     */
    ANGLE_ORIENTATION() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Lightning event number
     */
    LIGHT_EVENT_NUM() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    LIGHT_DET_SENSORS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    lightDetSensorsLength() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Position confidence (0-1)
     */
    POS_CONFIDENCE() {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    SRC_TYPS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    srcTypsLength() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    SRC_IDS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    srcIdsLength() {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startWTH(builder) {
        builder.startObject(32);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addIdSensor(builder, ID_SENSOROffset) {
        builder.addFieldOffset(1, ID_SENSOROffset, 0);
    }
    static addOrigSensorId(builder, ORIG_SENSOR_IDOffset) {
        builder.addFieldOffset(2, ORIG_SENSOR_IDOffset, 0);
    }
    static addObTime(builder, OB_TIMEOffset) {
        builder.addFieldOffset(3, OB_TIMEOffset, 0);
    }
    static addFileCreation(builder, FILE_CREATIONOffset) {
        builder.addFieldOffset(4, FILE_CREATIONOffset, 0);
    }
    static addQcValue(builder, QC_VALUE) {
        builder.addFieldInt8(5, QC_VALUE, 0);
    }
    static addTermAlt(builder, TERM_ALT) {
        builder.addFieldFloat64(6, TERM_ALT, 0.0);
    }
    static addAvgTxPwr(builder, AVG_TX_PWR) {
        builder.addFieldFloat64(7, AVG_TX_PWR, 0.0);
    }
    static addAvgRefPwr(builder, AVG_REF_PWR) {
        builder.addFieldFloat64(8, AVG_REF_PWR, 0.0);
    }
    static addSectorNum(builder, SECTOR_NUM) {
        builder.addFieldInt16(9, SECTOR_NUM, 0);
    }
    static addNumElements(builder, NUM_ELEMENTS) {
        builder.addFieldInt16(10, NUM_ELEMENTS, 0);
    }
    static addChecksum(builder, CHECKSUM) {
        builder.addFieldInt32(11, CHECKSUM, 0);
    }
    static addSigPwrs(builder, SIG_PWRSOffset) {
        builder.addFieldOffset(12, SIG_PWRSOffset, 0);
    }
    static createSigPwrsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startSigPwrsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addNoiseLvls(builder, NOISE_LVLSOffset) {
        builder.addFieldOffset(13, NOISE_LVLSOffset, 0);
    }
    static createNoiseLvlsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startNoiseLvlsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addSpecWidths(builder, SPEC_WIDTHSOffset) {
        builder.addFieldOffset(14, SPEC_WIDTHSOffset, 0);
    }
    static createSpecWidthsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startSpecWidthsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addFirstGuessAvgs(builder, FIRST_GUESS_AVGSOffset) {
        builder.addFieldOffset(15, FIRST_GUESS_AVGSOffset, 0);
    }
    static createFirstGuessAvgsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startFirstGuessAvgsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addTdAvgSampleNums(builder, TD_AVG_SAMPLE_NUMSOffset) {
        builder.addFieldOffset(16, TD_AVG_SAMPLE_NUMSOffset, 0);
    }
    static createTdAvgSampleNumsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startTdAvgSampleNumsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addCoIntegs(builder, CO_INTEGSOffset) {
        builder.addFieldOffset(17, CO_INTEGSOffset, 0);
    }
    static createCoIntegsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startCoIntegsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addSpecAvgs(builder, SPEC_AVGSOffset) {
        builder.addFieldOffset(18, SPEC_AVGSOffset, 0);
    }
    static createSpecAvgsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startSpecAvgsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addInterpulsePeriods(builder, INTERPULSE_PERIODSOffset) {
        builder.addFieldOffset(19, INTERPULSE_PERIODSOffset, 0);
    }
    static createInterpulsePeriodsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startInterpulsePeriodsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addDoppVels(builder, DOPP_VELSOffset) {
        builder.addFieldOffset(20, DOPP_VELSOffset, 0);
    }
    static createDoppVelsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startDoppVelsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addConsRecs(builder, CONS_RECSOffset) {
        builder.addFieldOffset(21, CONS_RECSOffset, 0);
    }
    static createConsRecsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startConsRecsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addSnrs(builder, SNRSOffset) {
        builder.addFieldOffset(22, SNRSOffset, 0);
    }
    static createSnrsVector(builder, data) {
        builder.startVector(8, data.length, 8);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addFloat64(data[i]);
        }
        return builder.endVector();
    }
    static startSnrsVector(builder, numElems) {
        builder.startVector(8, numElems, 8);
    }
    static addSigStrength(builder, SIG_STRENGTH) {
        builder.addFieldFloat64(23, SIG_STRENGTH, 0.0);
    }
    static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
        builder.addFieldFloat64(24, SEMI_MAJOR_AXIS, 0.0);
    }
    static addSemiMinorAxis(builder, SEMI_MINOR_AXIS) {
        builder.addFieldFloat64(25, SEMI_MINOR_AXIS, 0.0);
    }
    static addAngleOrientation(builder, ANGLE_ORIENTATION) {
        builder.addFieldFloat64(26, ANGLE_ORIENTATION, 0.0);
    }
    static addLightEventNum(builder, LIGHT_EVENT_NUM) {
        builder.addFieldInt32(27, LIGHT_EVENT_NUM, 0);
    }
    static addLightDetSensors(builder, LIGHT_DET_SENSORSOffset) {
        builder.addFieldOffset(28, LIGHT_DET_SENSORSOffset, 0);
    }
    static createLightDetSensorsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startLightDetSensorsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPosConfidence(builder, POS_CONFIDENCE) {
        builder.addFieldFloat64(29, POS_CONFIDENCE, 0.0);
    }
    static addSrcTyps(builder, SRC_TYPSOffset) {
        builder.addFieldOffset(30, SRC_TYPSOffset, 0);
    }
    static createSrcTypsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSrcTypsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addSrcIds(builder, SRC_IDSOffset) {
        builder.addFieldOffset(31, SRC_IDSOffset, 0);
    }
    static createSrcIdsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startSrcIdsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endWTH(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishWTHBuffer(builder, offset) {
        builder.finish(offset, '$WTH');
    }
    static finishSizePrefixedWTHBuffer(builder, offset) {
        builder.finish(offset, '$WTH', true);
    }
    static createWTH(builder, IDOffset, ID_SENSOROffset, ORIG_SENSOR_IDOffset, OB_TIMEOffset, FILE_CREATIONOffset, QC_VALUE, TERM_ALT, AVG_TX_PWR, AVG_REF_PWR, SECTOR_NUM, NUM_ELEMENTS, CHECKSUM, SIG_PWRSOffset, NOISE_LVLSOffset, SPEC_WIDTHSOffset, FIRST_GUESS_AVGSOffset, TD_AVG_SAMPLE_NUMSOffset, CO_INTEGSOffset, SPEC_AVGSOffset, INTERPULSE_PERIODSOffset, DOPP_VELSOffset, CONS_RECSOffset, SNRSOffset, SIG_STRENGTH, SEMI_MAJOR_AXIS, SEMI_MINOR_AXIS, ANGLE_ORIENTATION, LIGHT_EVENT_NUM, LIGHT_DET_SENSORSOffset, POS_CONFIDENCE, SRC_TYPSOffset, SRC_IDSOffset) {
        WTH.startWTH(builder);
        WTH.addId(builder, IDOffset);
        WTH.addIdSensor(builder, ID_SENSOROffset);
        WTH.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
        WTH.addObTime(builder, OB_TIMEOffset);
        WTH.addFileCreation(builder, FILE_CREATIONOffset);
        WTH.addQcValue(builder, QC_VALUE);
        WTH.addTermAlt(builder, TERM_ALT);
        WTH.addAvgTxPwr(builder, AVG_TX_PWR);
        WTH.addAvgRefPwr(builder, AVG_REF_PWR);
        WTH.addSectorNum(builder, SECTOR_NUM);
        WTH.addNumElements(builder, NUM_ELEMENTS);
        WTH.addChecksum(builder, CHECKSUM);
        WTH.addSigPwrs(builder, SIG_PWRSOffset);
        WTH.addNoiseLvls(builder, NOISE_LVLSOffset);
        WTH.addSpecWidths(builder, SPEC_WIDTHSOffset);
        WTH.addFirstGuessAvgs(builder, FIRST_GUESS_AVGSOffset);
        WTH.addTdAvgSampleNums(builder, TD_AVG_SAMPLE_NUMSOffset);
        WTH.addCoIntegs(builder, CO_INTEGSOffset);
        WTH.addSpecAvgs(builder, SPEC_AVGSOffset);
        WTH.addInterpulsePeriods(builder, INTERPULSE_PERIODSOffset);
        WTH.addDoppVels(builder, DOPP_VELSOffset);
        WTH.addConsRecs(builder, CONS_RECSOffset);
        WTH.addSnrs(builder, SNRSOffset);
        WTH.addSigStrength(builder, SIG_STRENGTH);
        WTH.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
        WTH.addSemiMinorAxis(builder, SEMI_MINOR_AXIS);
        WTH.addAngleOrientation(builder, ANGLE_ORIENTATION);
        WTH.addLightEventNum(builder, LIGHT_EVENT_NUM);
        WTH.addLightDetSensors(builder, LIGHT_DET_SENSORSOffset);
        WTH.addPosConfidence(builder, POS_CONFIDENCE);
        WTH.addSrcTyps(builder, SRC_TYPSOffset);
        WTH.addSrcIds(builder, SRC_IDSOffset);
        return WTH.endWTH(builder);
    }
    unpack() {
        return new WTHT(this.ID(), this.ID_SENSOR(), this.ORIG_SENSOR_ID(), this.OB_TIME(), this.FILE_CREATION(), this.QC_VALUE(), this.TERM_ALT(), this.AVG_TX_PWR(), this.AVG_REF_PWR(), this.SECTOR_NUM(), this.NUM_ELEMENTS(), this.CHECKSUM(), this.bb.createScalarList(this.SIG_PWRS.bind(this), this.sigPwrsLength()), this.bb.createScalarList(this.NOISE_LVLS.bind(this), this.noiseLvlsLength()), this.bb.createScalarList(this.SPEC_WIDTHS.bind(this), this.specWidthsLength()), this.bb.createScalarList(this.FIRST_GUESS_AVGS.bind(this), this.firstGuessAvgsLength()), this.bb.createScalarList(this.TD_AVG_SAMPLE_NUMS.bind(this), this.tdAvgSampleNumsLength()), this.bb.createScalarList(this.CO_INTEGS.bind(this), this.coIntegsLength()), this.bb.createScalarList(this.SPEC_AVGS.bind(this), this.specAvgsLength()), this.bb.createScalarList(this.INTERPULSE_PERIODS.bind(this), this.interpulsePeriodsLength()), this.bb.createScalarList(this.DOPP_VELS.bind(this), this.doppVelsLength()), this.bb.createScalarList(this.CONS_RECS.bind(this), this.consRecsLength()), this.bb.createScalarList(this.SNRS.bind(this), this.snrsLength()), this.SIG_STRENGTH(), this.SEMI_MAJOR_AXIS(), this.SEMI_MINOR_AXIS(), this.ANGLE_ORIENTATION(), this.LIGHT_EVENT_NUM(), this.bb.createScalarList(this.LIGHT_DET_SENSORS.bind(this), this.lightDetSensorsLength()), this.POS_CONFIDENCE(), this.bb.createScalarList(this.SRC_TYPS.bind(this), this.srcTypsLength()), this.bb.createScalarList(this.SRC_IDS.bind(this), this.srcIdsLength()));
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.ID_SENSOR = this.ID_SENSOR();
        _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
        _o.OB_TIME = this.OB_TIME();
        _o.FILE_CREATION = this.FILE_CREATION();
        _o.QC_VALUE = this.QC_VALUE();
        _o.TERM_ALT = this.TERM_ALT();
        _o.AVG_TX_PWR = this.AVG_TX_PWR();
        _o.AVG_REF_PWR = this.AVG_REF_PWR();
        _o.SECTOR_NUM = this.SECTOR_NUM();
        _o.NUM_ELEMENTS = this.NUM_ELEMENTS();
        _o.CHECKSUM = this.CHECKSUM();
        _o.SIG_PWRS = this.bb.createScalarList(this.SIG_PWRS.bind(this), this.sigPwrsLength());
        _o.NOISE_LVLS = this.bb.createScalarList(this.NOISE_LVLS.bind(this), this.noiseLvlsLength());
        _o.SPEC_WIDTHS = this.bb.createScalarList(this.SPEC_WIDTHS.bind(this), this.specWidthsLength());
        _o.FIRST_GUESS_AVGS = this.bb.createScalarList(this.FIRST_GUESS_AVGS.bind(this), this.firstGuessAvgsLength());
        _o.TD_AVG_SAMPLE_NUMS = this.bb.createScalarList(this.TD_AVG_SAMPLE_NUMS.bind(this), this.tdAvgSampleNumsLength());
        _o.CO_INTEGS = this.bb.createScalarList(this.CO_INTEGS.bind(this), this.coIntegsLength());
        _o.SPEC_AVGS = this.bb.createScalarList(this.SPEC_AVGS.bind(this), this.specAvgsLength());
        _o.INTERPULSE_PERIODS = this.bb.createScalarList(this.INTERPULSE_PERIODS.bind(this), this.interpulsePeriodsLength());
        _o.DOPP_VELS = this.bb.createScalarList(this.DOPP_VELS.bind(this), this.doppVelsLength());
        _o.CONS_RECS = this.bb.createScalarList(this.CONS_RECS.bind(this), this.consRecsLength());
        _o.SNRS = this.bb.createScalarList(this.SNRS.bind(this), this.snrsLength());
        _o.SIG_STRENGTH = this.SIG_STRENGTH();
        _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
        _o.SEMI_MINOR_AXIS = this.SEMI_MINOR_AXIS();
        _o.ANGLE_ORIENTATION = this.ANGLE_ORIENTATION();
        _o.LIGHT_EVENT_NUM = this.LIGHT_EVENT_NUM();
        _o.LIGHT_DET_SENSORS = this.bb.createScalarList(this.LIGHT_DET_SENSORS.bind(this), this.lightDetSensorsLength());
        _o.POS_CONFIDENCE = this.POS_CONFIDENCE();
        _o.SRC_TYPS = this.bb.createScalarList(this.SRC_TYPS.bind(this), this.srcTypsLength());
        _o.SRC_IDS = this.bb.createScalarList(this.SRC_IDS.bind(this), this.srcIdsLength());
    }
}
export class WTHT {
    constructor(ID = null, ID_SENSOR = null, ORIG_SENSOR_ID = null, OB_TIME = null, FILE_CREATION = null, QC_VALUE = 0, TERM_ALT = 0.0, AVG_TX_PWR = 0.0, AVG_REF_PWR = 0.0, SECTOR_NUM = 0, NUM_ELEMENTS = 0, CHECKSUM = 0, SIG_PWRS = [], NOISE_LVLS = [], SPEC_WIDTHS = [], FIRST_GUESS_AVGS = [], TD_AVG_SAMPLE_NUMS = [], CO_INTEGS = [], SPEC_AVGS = [], INTERPULSE_PERIODS = [], DOPP_VELS = [], CONS_RECS = [], SNRS = [], SIG_STRENGTH = 0.0, SEMI_MAJOR_AXIS = 0.0, SEMI_MINOR_AXIS = 0.0, ANGLE_ORIENTATION = 0.0, LIGHT_EVENT_NUM = 0, LIGHT_DET_SENSORS = [], POS_CONFIDENCE = 0.0, SRC_TYPS = [], SRC_IDS = []) {
        this.ID = ID;
        this.ID_SENSOR = ID_SENSOR;
        this.ORIG_SENSOR_ID = ORIG_SENSOR_ID;
        this.OB_TIME = OB_TIME;
        this.FILE_CREATION = FILE_CREATION;
        this.QC_VALUE = QC_VALUE;
        this.TERM_ALT = TERM_ALT;
        this.AVG_TX_PWR = AVG_TX_PWR;
        this.AVG_REF_PWR = AVG_REF_PWR;
        this.SECTOR_NUM = SECTOR_NUM;
        this.NUM_ELEMENTS = NUM_ELEMENTS;
        this.CHECKSUM = CHECKSUM;
        this.SIG_PWRS = SIG_PWRS;
        this.NOISE_LVLS = NOISE_LVLS;
        this.SPEC_WIDTHS = SPEC_WIDTHS;
        this.FIRST_GUESS_AVGS = FIRST_GUESS_AVGS;
        this.TD_AVG_SAMPLE_NUMS = TD_AVG_SAMPLE_NUMS;
        this.CO_INTEGS = CO_INTEGS;
        this.SPEC_AVGS = SPEC_AVGS;
        this.INTERPULSE_PERIODS = INTERPULSE_PERIODS;
        this.DOPP_VELS = DOPP_VELS;
        this.CONS_RECS = CONS_RECS;
        this.SNRS = SNRS;
        this.SIG_STRENGTH = SIG_STRENGTH;
        this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
        this.SEMI_MINOR_AXIS = SEMI_MINOR_AXIS;
        this.ANGLE_ORIENTATION = ANGLE_ORIENTATION;
        this.LIGHT_EVENT_NUM = LIGHT_EVENT_NUM;
        this.LIGHT_DET_SENSORS = LIGHT_DET_SENSORS;
        this.POS_CONFIDENCE = POS_CONFIDENCE;
        this.SRC_TYPS = SRC_TYPS;
        this.SRC_IDS = SRC_IDS;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const ID_SENSOR = (this.ID_SENSOR !== null ? builder.createString(this.ID_SENSOR) : 0);
        const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID) : 0);
        const OB_TIME = (this.OB_TIME !== null ? builder.createString(this.OB_TIME) : 0);
        const FILE_CREATION = (this.FILE_CREATION !== null ? builder.createString(this.FILE_CREATION) : 0);
        const SIG_PWRS = WTH.createSigPwrsVector(builder, this.SIG_PWRS);
        const NOISE_LVLS = WTH.createNoiseLvlsVector(builder, this.NOISE_LVLS);
        const SPEC_WIDTHS = WTH.createSpecWidthsVector(builder, this.SPEC_WIDTHS);
        const FIRST_GUESS_AVGS = WTH.createFirstGuessAvgsVector(builder, this.FIRST_GUESS_AVGS);
        const TD_AVG_SAMPLE_NUMS = WTH.createTdAvgSampleNumsVector(builder, this.TD_AVG_SAMPLE_NUMS);
        const CO_INTEGS = WTH.createCoIntegsVector(builder, this.CO_INTEGS);
        const SPEC_AVGS = WTH.createSpecAvgsVector(builder, this.SPEC_AVGS);
        const INTERPULSE_PERIODS = WTH.createInterpulsePeriodsVector(builder, this.INTERPULSE_PERIODS);
        const DOPP_VELS = WTH.createDoppVelsVector(builder, this.DOPP_VELS);
        const CONS_RECS = WTH.createConsRecsVector(builder, this.CONS_RECS);
        const SNRS = WTH.createSnrsVector(builder, this.SNRS);
        const LIGHT_DET_SENSORS = WTH.createLightDetSensorsVector(builder, builder.createObjectOffsetList(this.LIGHT_DET_SENSORS));
        const SRC_TYPS = WTH.createSrcTypsVector(builder, builder.createObjectOffsetList(this.SRC_TYPS));
        const SRC_IDS = WTH.createSrcIdsVector(builder, builder.createObjectOffsetList(this.SRC_IDS));
        return WTH.createWTH(builder, ID, ID_SENSOR, ORIG_SENSOR_ID, OB_TIME, FILE_CREATION, this.QC_VALUE, this.TERM_ALT, this.AVG_TX_PWR, this.AVG_REF_PWR, this.SECTOR_NUM, this.NUM_ELEMENTS, this.CHECKSUM, SIG_PWRS, NOISE_LVLS, SPEC_WIDTHS, FIRST_GUESS_AVGS, TD_AVG_SAMPLE_NUMS, CO_INTEGS, SPEC_AVGS, INTERPULSE_PERIODS, DOPP_VELS, CONS_RECS, SNRS, this.SIG_STRENGTH, this.SEMI_MAJOR_AXIS, this.SEMI_MINOR_AXIS, this.ANGLE_ORIENTATION, this.LIGHT_EVENT_NUM, LIGHT_DET_SENSORS, this.POS_CONFIDENCE, SRC_TYPS, SRC_IDS);
    }
}
