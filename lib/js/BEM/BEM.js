// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Antenna Beam
 */
export class BEM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsBEM(bb, obj) {
        return (obj || new BEM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBEM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BEM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$BEM');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BEAM_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    NOTES(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BEAM_CONTOURS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    beamContoursLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startBEM(builder) {
        builder.startObject(4);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addBeamName(builder, BEAM_NAMEOffset) {
        builder.addFieldOffset(1, BEAM_NAMEOffset, 0);
    }
    static addNotes(builder, NOTESOffset) {
        builder.addFieldOffset(2, NOTESOffset, 0);
    }
    static addBeamContours(builder, BEAM_CONTOURSOffset) {
        builder.addFieldOffset(3, BEAM_CONTOURSOffset, 0);
    }
    static createBeamContoursVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBeamContoursVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endBEM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishBEMBuffer(builder, offset) {
        builder.finish(offset, '$BEM');
    }
    static finishSizePrefixedBEMBuffer(builder, offset) {
        builder.finish(offset, '$BEM', true);
    }
    static createBEM(builder, IDOffset, BEAM_NAMEOffset, NOTESOffset, BEAM_CONTOURSOffset) {
        BEM.startBEM(builder);
        BEM.addId(builder, IDOffset);
        BEM.addBeamName(builder, BEAM_NAMEOffset);
        BEM.addNotes(builder, NOTESOffset);
        BEM.addBeamContours(builder, BEAM_CONTOURSOffset);
        return BEM.endBEM(builder);
    }
    unpack() {
        return new BEMT(this.ID(), this.BEAM_NAME(), this.NOTES(), this.bb.createScalarList(this.BEAM_CONTOURS.bind(this), this.beamContoursLength()));
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.BEAM_NAME = this.BEAM_NAME();
        _o.NOTES = this.NOTES();
        _o.BEAM_CONTOURS = this.bb.createScalarList(this.BEAM_CONTOURS.bind(this), this.beamContoursLength());
    }
}
export class BEMT {
    constructor(ID = null, BEAM_NAME = null, NOTES = null, BEAM_CONTOURS = []) {
        this.ID = ID;
        this.BEAM_NAME = BEAM_NAME;
        this.NOTES = NOTES;
        this.BEAM_CONTOURS = BEAM_CONTOURS;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const BEAM_NAME = (this.BEAM_NAME !== null ? builder.createString(this.BEAM_NAME) : 0);
        const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES) : 0);
        const BEAM_CONTOURS = BEM.createBeamContoursVector(builder, builder.createObjectOffsetList(this.BEAM_CONTOURS));
        return BEM.createBEM(builder, ID, BEAM_NAME, NOTES, BEAM_CONTOURS);
    }
}
