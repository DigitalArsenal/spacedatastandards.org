// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Sensor Systems
 */
export class SNR {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSNR(bb, obj) {
        return (obj || new SNR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSNR(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SNR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$SNR');
    }
    TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    MODE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    RESERVED1() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    MAX_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    MIN_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    FOV_AZIMUTH() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    FOV_ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ANGULAR_RESOLUTION() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RANGE_RESOLUTION() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    UPDATE_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    DETECTION_THRESHOLD() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    AZIMUTH_SCAN_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ELEVATION_SCAN_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    POWER() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    FREQUENCY() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RESERVED(index) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    reservedLength() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    reservedArray() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSNR(builder) {
        builder.startObject(16);
    }
    static addType(builder, TYPE) {
        builder.addFieldInt8(0, TYPE, 0);
    }
    static addMode(builder, MODE) {
        builder.addFieldInt8(1, MODE, 0);
    }
    static addReserved1(builder, RESERVED1) {
        builder.addFieldInt16(2, RESERVED1, 0);
    }
    static addMaxRange(builder, MAX_RANGE) {
        builder.addFieldFloat64(3, MAX_RANGE, 0.0);
    }
    static addMinRange(builder, MIN_RANGE) {
        builder.addFieldFloat64(4, MIN_RANGE, 0.0);
    }
    static addFovAzimuth(builder, FOV_AZIMUTH) {
        builder.addFieldFloat32(5, FOV_AZIMUTH, 0.0);
    }
    static addFovElevation(builder, FOV_ELEVATION) {
        builder.addFieldFloat32(6, FOV_ELEVATION, 0.0);
    }
    static addAngularResolution(builder, ANGULAR_RESOLUTION) {
        builder.addFieldFloat32(7, ANGULAR_RESOLUTION, 0.0);
    }
    static addRangeResolution(builder, RANGE_RESOLUTION) {
        builder.addFieldFloat32(8, RANGE_RESOLUTION, 0.0);
    }
    static addUpdateRate(builder, UPDATE_RATE) {
        builder.addFieldFloat32(9, UPDATE_RATE, 0.0);
    }
    static addDetectionThreshold(builder, DETECTION_THRESHOLD) {
        builder.addFieldFloat32(10, DETECTION_THRESHOLD, 0.0);
    }
    static addAzimuthScanRate(builder, AZIMUTH_SCAN_RATE) {
        builder.addFieldFloat32(11, AZIMUTH_SCAN_RATE, 0.0);
    }
    static addElevationScanRate(builder, ELEVATION_SCAN_RATE) {
        builder.addFieldFloat32(12, ELEVATION_SCAN_RATE, 0.0);
    }
    static addPower(builder, POWER) {
        builder.addFieldFloat32(13, POWER, 0.0);
    }
    static addFrequency(builder, FREQUENCY) {
        builder.addFieldFloat32(14, FREQUENCY, 0.0);
    }
    static addReserved(builder, RESERVEDOffset) {
        builder.addFieldOffset(15, RESERVEDOffset, 0);
    }
    static createReservedVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startReservedVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSNR(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSNRBuffer(builder, offset) {
        builder.finish(offset, '$SNR');
    }
    static finishSizePrefixedSNRBuffer(builder, offset) {
        builder.finish(offset, '$SNR', true);
    }
    static createSNR(builder, TYPE, MODE, RESERVED1, MAX_RANGE, MIN_RANGE, FOV_AZIMUTH, FOV_ELEVATION, ANGULAR_RESOLUTION, RANGE_RESOLUTION, UPDATE_RATE, DETECTION_THRESHOLD, AZIMUTH_SCAN_RATE, ELEVATION_SCAN_RATE, POWER, FREQUENCY, RESERVEDOffset) {
        SNR.startSNR(builder);
        SNR.addType(builder, TYPE);
        SNR.addMode(builder, MODE);
        SNR.addReserved1(builder, RESERVED1);
        SNR.addMaxRange(builder, MAX_RANGE);
        SNR.addMinRange(builder, MIN_RANGE);
        SNR.addFovAzimuth(builder, FOV_AZIMUTH);
        SNR.addFovElevation(builder, FOV_ELEVATION);
        SNR.addAngularResolution(builder, ANGULAR_RESOLUTION);
        SNR.addRangeResolution(builder, RANGE_RESOLUTION);
        SNR.addUpdateRate(builder, UPDATE_RATE);
        SNR.addDetectionThreshold(builder, DETECTION_THRESHOLD);
        SNR.addAzimuthScanRate(builder, AZIMUTH_SCAN_RATE);
        SNR.addElevationScanRate(builder, ELEVATION_SCAN_RATE);
        SNR.addPower(builder, POWER);
        SNR.addFrequency(builder, FREQUENCY);
        SNR.addReserved(builder, RESERVEDOffset);
        return SNR.endSNR(builder);
    }
    unpack() {
        return new SNRT(this.TYPE(), this.MODE(), this.RESERVED1(), this.MAX_RANGE(), this.MIN_RANGE(), this.FOV_AZIMUTH(), this.FOV_ELEVATION(), this.ANGULAR_RESOLUTION(), this.RANGE_RESOLUTION(), this.UPDATE_RATE(), this.DETECTION_THRESHOLD(), this.AZIMUTH_SCAN_RATE(), this.ELEVATION_SCAN_RATE(), this.POWER(), this.FREQUENCY(), this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength()));
    }
    unpackTo(_o) {
        _o.TYPE = this.TYPE();
        _o.MODE = this.MODE();
        _o.RESERVED1 = this.RESERVED1();
        _o.MAX_RANGE = this.MAX_RANGE();
        _o.MIN_RANGE = this.MIN_RANGE();
        _o.FOV_AZIMUTH = this.FOV_AZIMUTH();
        _o.FOV_ELEVATION = this.FOV_ELEVATION();
        _o.ANGULAR_RESOLUTION = this.ANGULAR_RESOLUTION();
        _o.RANGE_RESOLUTION = this.RANGE_RESOLUTION();
        _o.UPDATE_RATE = this.UPDATE_RATE();
        _o.DETECTION_THRESHOLD = this.DETECTION_THRESHOLD();
        _o.AZIMUTH_SCAN_RATE = this.AZIMUTH_SCAN_RATE();
        _o.ELEVATION_SCAN_RATE = this.ELEVATION_SCAN_RATE();
        _o.POWER = this.POWER();
        _o.FREQUENCY = this.FREQUENCY();
        _o.RESERVED = this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength());
    }
}
export class SNRT {
    constructor(TYPE = 0, MODE = 0, RESERVED1 = 0, MAX_RANGE = 0.0, MIN_RANGE = 0.0, FOV_AZIMUTH = 0.0, FOV_ELEVATION = 0.0, ANGULAR_RESOLUTION = 0.0, RANGE_RESOLUTION = 0.0, UPDATE_RATE = 0.0, DETECTION_THRESHOLD = 0.0, AZIMUTH_SCAN_RATE = 0.0, ELEVATION_SCAN_RATE = 0.0, POWER = 0.0, FREQUENCY = 0.0, RESERVED = []) {
        this.TYPE = TYPE;
        this.MODE = MODE;
        this.RESERVED1 = RESERVED1;
        this.MAX_RANGE = MAX_RANGE;
        this.MIN_RANGE = MIN_RANGE;
        this.FOV_AZIMUTH = FOV_AZIMUTH;
        this.FOV_ELEVATION = FOV_ELEVATION;
        this.ANGULAR_RESOLUTION = ANGULAR_RESOLUTION;
        this.RANGE_RESOLUTION = RANGE_RESOLUTION;
        this.UPDATE_RATE = UPDATE_RATE;
        this.DETECTION_THRESHOLD = DETECTION_THRESHOLD;
        this.AZIMUTH_SCAN_RATE = AZIMUTH_SCAN_RATE;
        this.ELEVATION_SCAN_RATE = ELEVATION_SCAN_RATE;
        this.POWER = POWER;
        this.FREQUENCY = FREQUENCY;
        this.RESERVED = RESERVED;
    }
    pack(builder) {
        const RESERVED = SNR.createReservedVector(builder, this.RESERVED);
        return SNR.createSNR(builder, this.TYPE, this.MODE, this.RESERVED1, this.MAX_RANGE, this.MIN_RANGE, this.FOV_AZIMUTH, this.FOV_ELEVATION, this.ANGULAR_RESOLUTION, this.RANGE_RESOLUTION, this.UPDATE_RATE, this.DETECTION_THRESHOLD, this.AZIMUTH_SCAN_RATE, this.ELEVATION_SCAN_RATE, this.POWER, this.FREQUENCY, RESERVED);
    }
}
