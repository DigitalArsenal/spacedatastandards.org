// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { ContactPoint } from './ContactPoint.js';
import { CryptoKey } from './CryptoKey.js';
import { Entity, unionToEntity } from './Entity.js';
import { Occupation } from './Occupation.js';
/**
 * Entity Profile Message
 */
export class EPM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEPM(bb, obj) {
        return (obj || new EPM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEPM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EPM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ALTERNATE_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    DESCRIPTION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    IMAGE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SAME_AS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    URL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TELEPHONE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    EMAIL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Cryptographic key information associated with the entity
     */
    KEY(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? (obj || new CryptoKey()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    keyLength() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Contact points for the entity
     */
    CONTACT_POINT(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new ContactPoint()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    contactPointLength() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Address of the entity, using the ContactPoint structure
     */
    ADDRESS(obj) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? (obj || new ContactPoint()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    JOB_TITLE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    entityType() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : Entity.NONE;
    }
    /**
     * Union type to represent either a person or an organization
     */
    ENTITY(obj) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Occupation of the entity (applicable to persons)
     */
    HAS_OCCUPATION(obj) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? (obj || new Occupation()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startEPM(builder) {
        builder.startObject(15);
    }
    static addName(builder, NAMEOffset) {
        builder.addFieldOffset(0, NAMEOffset, 0);
    }
    static addAlternateName(builder, ALTERNATE_NAMEOffset) {
        builder.addFieldOffset(1, ALTERNATE_NAMEOffset, 0);
    }
    static addDescription(builder, DESCRIPTIONOffset) {
        builder.addFieldOffset(2, DESCRIPTIONOffset, 0);
    }
    static addImage(builder, IMAGEOffset) {
        builder.addFieldOffset(3, IMAGEOffset, 0);
    }
    static addSameAs(builder, SAME_ASOffset) {
        builder.addFieldOffset(4, SAME_ASOffset, 0);
    }
    static addUrl(builder, URLOffset) {
        builder.addFieldOffset(5, URLOffset, 0);
    }
    static addTelephone(builder, TELEPHONEOffset) {
        builder.addFieldOffset(6, TELEPHONEOffset, 0);
    }
    static addEmail(builder, EMAILOffset) {
        builder.addFieldOffset(7, EMAILOffset, 0);
    }
    static addKey(builder, KEYOffset) {
        builder.addFieldOffset(8, KEYOffset, 0);
    }
    static createKeyVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startKeyVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addContactPoint(builder, CONTACT_POINTOffset) {
        builder.addFieldOffset(9, CONTACT_POINTOffset, 0);
    }
    static createContactPointVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startContactPointVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addAddress(builder, ADDRESSOffset) {
        builder.addFieldOffset(10, ADDRESSOffset, 0);
    }
    static addJobTitle(builder, JOB_TITLEOffset) {
        builder.addFieldOffset(11, JOB_TITLEOffset, 0);
    }
    static addEntityType(builder, entityType) {
        builder.addFieldInt8(12, entityType, Entity.NONE);
    }
    static addEntity(builder, ENTITYOffset) {
        builder.addFieldOffset(13, ENTITYOffset, 0);
    }
    static addHasOccupation(builder, HAS_OCCUPATIONOffset) {
        builder.addFieldOffset(14, HAS_OCCUPATIONOffset, 0);
    }
    static endEPM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    unpack() {
        return new EPMT(this.NAME(), this.ALTERNATE_NAME(), this.DESCRIPTION(), this.IMAGE(), this.SAME_AS(), this.URL(), this.TELEPHONE(), this.EMAIL(), this.bb.createObjList(this.KEY.bind(this), this.keyLength()), this.bb.createObjList(this.CONTACT_POINT.bind(this), this.contactPointLength()), (this.ADDRESS() !== null ? this.ADDRESS().unpack() : null), this.JOB_TITLE(), this.entityType(), (() => {
            const temp = unionToEntity(this.entityType(), this.ENTITY.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })(), (this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null));
    }
    unpackTo(_o) {
        _o.NAME = this.NAME();
        _o.ALTERNATE_NAME = this.ALTERNATE_NAME();
        _o.DESCRIPTION = this.DESCRIPTION();
        _o.IMAGE = this.IMAGE();
        _o.SAME_AS = this.SAME_AS();
        _o.URL = this.URL();
        _o.TELEPHONE = this.TELEPHONE();
        _o.EMAIL = this.EMAIL();
        _o.KEY = this.bb.createObjList(this.KEY.bind(this), this.keyLength());
        _o.CONTACT_POINT = this.bb.createObjList(this.CONTACT_POINT.bind(this), this.contactPointLength());
        _o.ADDRESS = (this.ADDRESS() !== null ? this.ADDRESS().unpack() : null);
        _o.JOB_TITLE = this.JOB_TITLE();
        _o.entityType = this.entityType();
        _o.ENTITY = (() => {
            const temp = unionToEntity(this.entityType(), this.ENTITY.bind(this));
            if (temp === null) {
                return null;
            }
            return temp.unpack();
        })();
        _o.HAS_OCCUPATION = (this.HAS_OCCUPATION() !== null ? this.HAS_OCCUPATION().unpack() : null);
    }
}
export class EPMT {
    constructor(NAME = null, ALTERNATE_NAME = null, DESCRIPTION = null, IMAGE = null, SAME_AS = null, URL = null, TELEPHONE = null, EMAIL = null, KEY = [], CONTACT_POINT = [], ADDRESS = null, JOB_TITLE = null, entityType = Entity.NONE, ENTITY = null, HAS_OCCUPATION = null) {
        this.NAME = NAME;
        this.ALTERNATE_NAME = ALTERNATE_NAME;
        this.DESCRIPTION = DESCRIPTION;
        this.IMAGE = IMAGE;
        this.SAME_AS = SAME_AS;
        this.URL = URL;
        this.TELEPHONE = TELEPHONE;
        this.EMAIL = EMAIL;
        this.KEY = KEY;
        this.CONTACT_POINT = CONTACT_POINT;
        this.ADDRESS = ADDRESS;
        this.JOB_TITLE = JOB_TITLE;
        this.entityType = entityType;
        this.ENTITY = ENTITY;
        this.HAS_OCCUPATION = HAS_OCCUPATION;
    }
    pack(builder) {
        const NAME = (this.NAME !== null ? builder.createString(this.NAME) : 0);
        const ALTERNATE_NAME = (this.ALTERNATE_NAME !== null ? builder.createString(this.ALTERNATE_NAME) : 0);
        const DESCRIPTION = (this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION) : 0);
        const IMAGE = (this.IMAGE !== null ? builder.createString(this.IMAGE) : 0);
        const SAME_AS = (this.SAME_AS !== null ? builder.createString(this.SAME_AS) : 0);
        const URL = (this.URL !== null ? builder.createString(this.URL) : 0);
        const TELEPHONE = (this.TELEPHONE !== null ? builder.createString(this.TELEPHONE) : 0);
        const EMAIL = (this.EMAIL !== null ? builder.createString(this.EMAIL) : 0);
        const KEY = EPM.createKeyVector(builder, builder.createObjectOffsetList(this.KEY));
        const CONTACT_POINT = EPM.createContactPointVector(builder, builder.createObjectOffsetList(this.CONTACT_POINT));
        const ADDRESS = (this.ADDRESS !== null ? this.ADDRESS.pack(builder) : 0);
        const JOB_TITLE = (this.JOB_TITLE !== null ? builder.createString(this.JOB_TITLE) : 0);
        const ENTITY = builder.createObjectOffset(this.ENTITY);
        const HAS_OCCUPATION = (this.HAS_OCCUPATION !== null ? this.HAS_OCCUPATION.pack(builder) : 0);
        EPM.startEPM(builder);
        EPM.addName(builder, NAME);
        EPM.addAlternateName(builder, ALTERNATE_NAME);
        EPM.addDescription(builder, DESCRIPTION);
        EPM.addImage(builder, IMAGE);
        EPM.addSameAs(builder, SAME_AS);
        EPM.addUrl(builder, URL);
        EPM.addTelephone(builder, TELEPHONE);
        EPM.addEmail(builder, EMAIL);
        EPM.addKey(builder, KEY);
        EPM.addContactPoint(builder, CONTACT_POINT);
        EPM.addAddress(builder, ADDRESS);
        EPM.addJobTitle(builder, JOB_TITLE);
        EPM.addEntityType(builder, this.entityType);
        EPM.addEntity(builder, ENTITY);
        EPM.addHasOccupation(builder, HAS_OCCUPATION);
        return EPM.endEPM(builder);
    }
}
