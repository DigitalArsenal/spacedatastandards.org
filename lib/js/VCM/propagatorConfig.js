// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { propagatorType } from './propagatorType.js';
/**
 * Propagator configuration structure to describe propagation settings
 */
export class propagatorConfig {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAspropagatorConfig(bb, obj) {
        return (obj || new propagatorConfig()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAspropagatorConfig(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new propagatorConfig()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    PROPAGATOR_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PROPAGATOR_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : propagatorType.NONE;
    }
    FORCE_MODELS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    forceModelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    EPOCH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TIME_STEP() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    ZONAL_HARMONIC_TERMS(index) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    zonalHarmonicTermsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    zonalHarmonicTermsArray() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Int8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startpropagatorConfig(builder) {
        builder.startObject(6);
    }
    static addPropagatorName(builder, PROPAGATOR_NAMEOffset) {
        builder.addFieldOffset(0, PROPAGATOR_NAMEOffset, 0);
    }
    static addPropagatorType(builder, PROPAGATOR_TYPE) {
        builder.addFieldInt8(1, PROPAGATOR_TYPE, propagatorType.NONE);
    }
    static addForceModels(builder, FORCE_MODELSOffset) {
        builder.addFieldOffset(2, FORCE_MODELSOffset, 0);
    }
    static createForceModelsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startForceModelsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEpoch(builder, EPOCHOffset) {
        builder.addFieldOffset(3, EPOCHOffset, 0);
    }
    static addTimeStep(builder, TIME_STEP) {
        builder.addFieldFloat64(4, TIME_STEP, 0.0);
    }
    static addZonalHarmonicTerms(builder, ZONAL_HARMONIC_TERMSOffset) {
        builder.addFieldOffset(5, ZONAL_HARMONIC_TERMSOffset, 0);
    }
    static createZonalHarmonicTermsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startZonalHarmonicTermsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endpropagatorConfig(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createpropagatorConfig(builder, PROPAGATOR_NAMEOffset, PROPAGATOR_TYPE, FORCE_MODELSOffset, EPOCHOffset, TIME_STEP, ZONAL_HARMONIC_TERMSOffset) {
        propagatorConfig.startpropagatorConfig(builder);
        propagatorConfig.addPropagatorName(builder, PROPAGATOR_NAMEOffset);
        propagatorConfig.addPropagatorType(builder, PROPAGATOR_TYPE);
        propagatorConfig.addForceModels(builder, FORCE_MODELSOffset);
        propagatorConfig.addEpoch(builder, EPOCHOffset);
        propagatorConfig.addTimeStep(builder, TIME_STEP);
        propagatorConfig.addZonalHarmonicTerms(builder, ZONAL_HARMONIC_TERMSOffset);
        return propagatorConfig.endpropagatorConfig(builder);
    }
    unpack() {
        return new propagatorConfigT(this.PROPAGATOR_NAME(), this.PROPAGATOR_TYPE(), this.bb.createScalarList(this.FORCE_MODELS.bind(this), this.forceModelsLength()), this.EPOCH(), this.TIME_STEP(), this.bb.createScalarList(this.ZONAL_HARMONIC_TERMS.bind(this), this.zonalHarmonicTermsLength()));
    }
    unpackTo(_o) {
        _o.PROPAGATOR_NAME = this.PROPAGATOR_NAME();
        _o.PROPAGATOR_TYPE = this.PROPAGATOR_TYPE();
        _o.FORCE_MODELS = this.bb.createScalarList(this.FORCE_MODELS.bind(this), this.forceModelsLength());
        _o.EPOCH = this.EPOCH();
        _o.TIME_STEP = this.TIME_STEP();
        _o.ZONAL_HARMONIC_TERMS = this.bb.createScalarList(this.ZONAL_HARMONIC_TERMS.bind(this), this.zonalHarmonicTermsLength());
    }
}
export class propagatorConfigT {
    constructor(PROPAGATOR_NAME = null, PROPAGATOR_TYPE = propagatorType.NONE, FORCE_MODELS = [], EPOCH = null, TIME_STEP = 0.0, ZONAL_HARMONIC_TERMS = []) {
        this.PROPAGATOR_NAME = PROPAGATOR_NAME;
        this.PROPAGATOR_TYPE = PROPAGATOR_TYPE;
        this.FORCE_MODELS = FORCE_MODELS;
        this.EPOCH = EPOCH;
        this.TIME_STEP = TIME_STEP;
        this.ZONAL_HARMONIC_TERMS = ZONAL_HARMONIC_TERMS;
    }
    pack(builder) {
        const PROPAGATOR_NAME = (this.PROPAGATOR_NAME !== null ? builder.createString(this.PROPAGATOR_NAME) : 0);
        const FORCE_MODELS = propagatorConfig.createForceModelsVector(builder, builder.createObjectOffsetList(this.FORCE_MODELS));
        const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH) : 0);
        const ZONAL_HARMONIC_TERMS = propagatorConfig.createZonalHarmonicTermsVector(builder, this.ZONAL_HARMONIC_TERMS);
        return propagatorConfig.createpropagatorConfig(builder, PROPAGATOR_NAME, this.PROPAGATOR_TYPE, FORCE_MODELS, EPOCH, this.TIME_STEP, ZONAL_HARMONIC_TERMS);
    }
}
