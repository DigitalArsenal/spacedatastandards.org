// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Weapons and Munitions
 */
export class WPN {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsWPN(bb, obj) {
        return (obj || new WPN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsWPN(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new WPN()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$WPN');
    }
    CALIBER() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    MUZZLE_VELOCITY() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RATE_OF_FIRE() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    DISPERSION() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    AMMO_CAPACITY() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    BURST_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    RELOAD_TIME() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    OVERHEAT_ROUNDS() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    COOLDOWN_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ELEVATION_MIN() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ELEVATION_MAX() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    TRAVERSE_MIN() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    TRAVERSE_MAX() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    SLEW_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    WEAPON_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    FUZE_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    RESERVED(index) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    reservedLength() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    reservedArray() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startWPN(builder) {
        builder.startObject(17);
    }
    static addCaliber(builder, CALIBER) {
        builder.addFieldFloat32(0, CALIBER, 0.0);
    }
    static addMuzzleVelocity(builder, MUZZLE_VELOCITY) {
        builder.addFieldFloat32(1, MUZZLE_VELOCITY, 0.0);
    }
    static addRateOfFire(builder, RATE_OF_FIRE) {
        builder.addFieldFloat32(2, RATE_OF_FIRE, 0.0);
    }
    static addDispersion(builder, DISPERSION) {
        builder.addFieldFloat32(3, DISPERSION, 0.0);
    }
    static addAmmoCapacity(builder, AMMO_CAPACITY) {
        builder.addFieldInt16(4, AMMO_CAPACITY, 0);
    }
    static addBurstLength(builder, BURST_LENGTH) {
        builder.addFieldInt16(5, BURST_LENGTH, 0);
    }
    static addReloadTime(builder, RELOAD_TIME) {
        builder.addFieldFloat32(6, RELOAD_TIME, 0.0);
    }
    static addOverheatRounds(builder, OVERHEAT_ROUNDS) {
        builder.addFieldInt16(7, OVERHEAT_ROUNDS, 0);
    }
    static addCooldownRate(builder, COOLDOWN_RATE) {
        builder.addFieldFloat32(8, COOLDOWN_RATE, 0.0);
    }
    static addElevationMin(builder, ELEVATION_MIN) {
        builder.addFieldFloat32(9, ELEVATION_MIN, 0.0);
    }
    static addElevationMax(builder, ELEVATION_MAX) {
        builder.addFieldFloat32(10, ELEVATION_MAX, 0.0);
    }
    static addTraverseMin(builder, TRAVERSE_MIN) {
        builder.addFieldFloat32(11, TRAVERSE_MIN, 0.0);
    }
    static addTraverseMax(builder, TRAVERSE_MAX) {
        builder.addFieldFloat32(12, TRAVERSE_MAX, 0.0);
    }
    static addSlewRate(builder, SLEW_RATE) {
        builder.addFieldFloat32(13, SLEW_RATE, 0.0);
    }
    static addWeaponType(builder, WEAPON_TYPE) {
        builder.addFieldInt8(14, WEAPON_TYPE, 0);
    }
    static addFuzeType(builder, FUZE_TYPE) {
        builder.addFieldInt8(15, FUZE_TYPE, 0);
    }
    static addReserved(builder, RESERVEDOffset) {
        builder.addFieldOffset(16, RESERVEDOffset, 0);
    }
    static createReservedVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startReservedVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endWPN(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishWPNBuffer(builder, offset) {
        builder.finish(offset, '$WPN');
    }
    static finishSizePrefixedWPNBuffer(builder, offset) {
        builder.finish(offset, '$WPN', true);
    }
    static createWPN(builder, CALIBER, MUZZLE_VELOCITY, RATE_OF_FIRE, DISPERSION, AMMO_CAPACITY, BURST_LENGTH, RELOAD_TIME, OVERHEAT_ROUNDS, COOLDOWN_RATE, ELEVATION_MIN, ELEVATION_MAX, TRAVERSE_MIN, TRAVERSE_MAX, SLEW_RATE, WEAPON_TYPE, FUZE_TYPE, RESERVEDOffset) {
        WPN.startWPN(builder);
        WPN.addCaliber(builder, CALIBER);
        WPN.addMuzzleVelocity(builder, MUZZLE_VELOCITY);
        WPN.addRateOfFire(builder, RATE_OF_FIRE);
        WPN.addDispersion(builder, DISPERSION);
        WPN.addAmmoCapacity(builder, AMMO_CAPACITY);
        WPN.addBurstLength(builder, BURST_LENGTH);
        WPN.addReloadTime(builder, RELOAD_TIME);
        WPN.addOverheatRounds(builder, OVERHEAT_ROUNDS);
        WPN.addCooldownRate(builder, COOLDOWN_RATE);
        WPN.addElevationMin(builder, ELEVATION_MIN);
        WPN.addElevationMax(builder, ELEVATION_MAX);
        WPN.addTraverseMin(builder, TRAVERSE_MIN);
        WPN.addTraverseMax(builder, TRAVERSE_MAX);
        WPN.addSlewRate(builder, SLEW_RATE);
        WPN.addWeaponType(builder, WEAPON_TYPE);
        WPN.addFuzeType(builder, FUZE_TYPE);
        WPN.addReserved(builder, RESERVEDOffset);
        return WPN.endWPN(builder);
    }
    unpack() {
        return new WPNT(this.CALIBER(), this.MUZZLE_VELOCITY(), this.RATE_OF_FIRE(), this.DISPERSION(), this.AMMO_CAPACITY(), this.BURST_LENGTH(), this.RELOAD_TIME(), this.OVERHEAT_ROUNDS(), this.COOLDOWN_RATE(), this.ELEVATION_MIN(), this.ELEVATION_MAX(), this.TRAVERSE_MIN(), this.TRAVERSE_MAX(), this.SLEW_RATE(), this.WEAPON_TYPE(), this.FUZE_TYPE(), this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength()));
    }
    unpackTo(_o) {
        _o.CALIBER = this.CALIBER();
        _o.MUZZLE_VELOCITY = this.MUZZLE_VELOCITY();
        _o.RATE_OF_FIRE = this.RATE_OF_FIRE();
        _o.DISPERSION = this.DISPERSION();
        _o.AMMO_CAPACITY = this.AMMO_CAPACITY();
        _o.BURST_LENGTH = this.BURST_LENGTH();
        _o.RELOAD_TIME = this.RELOAD_TIME();
        _o.OVERHEAT_ROUNDS = this.OVERHEAT_ROUNDS();
        _o.COOLDOWN_RATE = this.COOLDOWN_RATE();
        _o.ELEVATION_MIN = this.ELEVATION_MIN();
        _o.ELEVATION_MAX = this.ELEVATION_MAX();
        _o.TRAVERSE_MIN = this.TRAVERSE_MIN();
        _o.TRAVERSE_MAX = this.TRAVERSE_MAX();
        _o.SLEW_RATE = this.SLEW_RATE();
        _o.WEAPON_TYPE = this.WEAPON_TYPE();
        _o.FUZE_TYPE = this.FUZE_TYPE();
        _o.RESERVED = this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength());
    }
}
export class WPNT {
    constructor(CALIBER = 0.0, MUZZLE_VELOCITY = 0.0, RATE_OF_FIRE = 0.0, DISPERSION = 0.0, AMMO_CAPACITY = 0, BURST_LENGTH = 0, RELOAD_TIME = 0.0, OVERHEAT_ROUNDS = 0, COOLDOWN_RATE = 0.0, ELEVATION_MIN = 0.0, ELEVATION_MAX = 0.0, TRAVERSE_MIN = 0.0, TRAVERSE_MAX = 0.0, SLEW_RATE = 0.0, WEAPON_TYPE = 0, FUZE_TYPE = 0, RESERVED = []) {
        this.CALIBER = CALIBER;
        this.MUZZLE_VELOCITY = MUZZLE_VELOCITY;
        this.RATE_OF_FIRE = RATE_OF_FIRE;
        this.DISPERSION = DISPERSION;
        this.AMMO_CAPACITY = AMMO_CAPACITY;
        this.BURST_LENGTH = BURST_LENGTH;
        this.RELOAD_TIME = RELOAD_TIME;
        this.OVERHEAT_ROUNDS = OVERHEAT_ROUNDS;
        this.COOLDOWN_RATE = COOLDOWN_RATE;
        this.ELEVATION_MIN = ELEVATION_MIN;
        this.ELEVATION_MAX = ELEVATION_MAX;
        this.TRAVERSE_MIN = TRAVERSE_MIN;
        this.TRAVERSE_MAX = TRAVERSE_MAX;
        this.SLEW_RATE = SLEW_RATE;
        this.WEAPON_TYPE = WEAPON_TYPE;
        this.FUZE_TYPE = FUZE_TYPE;
        this.RESERVED = RESERVED;
    }
    pack(builder) {
        const RESERVED = WPN.createReservedVector(builder, this.RESERVED);
        return WPN.createWPN(builder, this.CALIBER, this.MUZZLE_VELOCITY, this.RATE_OF_FIRE, this.DISPERSION, this.AMMO_CAPACITY, this.BURST_LENGTH, this.RELOAD_TIME, this.OVERHEAT_ROUNDS, this.COOLDOWN_RATE, this.ELEVATION_MIN, this.ELEVATION_MAX, this.TRAVERSE_MIN, this.TRAVERSE_MAX, this.SLEW_RATE, this.WEAPON_TYPE, this.FUZE_TYPE, RESERVED);
    }
}
