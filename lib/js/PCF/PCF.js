// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Propagator Configuration
 */
export class PCF {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPCF(bb, obj) {
        return (obj || new PCF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPCF(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PCF()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$PCF');
    }
    STEP_SIZE() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    TOLERANCE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    MIN_STEP() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    MAX_STEP() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    MAX_ITERATIONS() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    GRAVITY_DEGREE() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    GRAVITY_ORDER() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    INTEGRATOR() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    OUTPUT_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    FORCE_FLAGS() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    DRAG_COEFFICIENT() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    SRP_COEFFICIENT() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    AREA_MASS_RATIO() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RESERVED(index) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    reservedLength() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    reservedArray() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startPCF(builder) {
        builder.startObject(14);
    }
    static addStepSize(builder, STEP_SIZE) {
        builder.addFieldFloat64(0, STEP_SIZE, 0.0);
    }
    static addTolerance(builder, TOLERANCE) {
        builder.addFieldFloat64(1, TOLERANCE, 0.0);
    }
    static addMinStep(builder, MIN_STEP) {
        builder.addFieldFloat64(2, MIN_STEP, 0.0);
    }
    static addMaxStep(builder, MAX_STEP) {
        builder.addFieldFloat64(3, MAX_STEP, 0.0);
    }
    static addMaxIterations(builder, MAX_ITERATIONS) {
        builder.addFieldInt32(4, MAX_ITERATIONS, 0);
    }
    static addGravityDegree(builder, GRAVITY_DEGREE) {
        builder.addFieldInt16(5, GRAVITY_DEGREE, 0);
    }
    static addGravityOrder(builder, GRAVITY_ORDER) {
        builder.addFieldInt16(6, GRAVITY_ORDER, 0);
    }
    static addIntegrator(builder, INTEGRATOR) {
        builder.addFieldInt8(7, INTEGRATOR, 0);
    }
    static addOutputFrame(builder, OUTPUT_FRAME) {
        builder.addFieldInt8(8, OUTPUT_FRAME, 0);
    }
    static addForceFlags(builder, FORCE_FLAGS) {
        builder.addFieldInt16(9, FORCE_FLAGS, 0);
    }
    static addDragCoefficient(builder, DRAG_COEFFICIENT) {
        builder.addFieldFloat32(10, DRAG_COEFFICIENT, 0.0);
    }
    static addSrpCoefficient(builder, SRP_COEFFICIENT) {
        builder.addFieldFloat32(11, SRP_COEFFICIENT, 0.0);
    }
    static addAreaMassRatio(builder, AREA_MASS_RATIO) {
        builder.addFieldFloat32(12, AREA_MASS_RATIO, 0.0);
    }
    static addReserved(builder, RESERVEDOffset) {
        builder.addFieldOffset(13, RESERVEDOffset, 0);
    }
    static createReservedVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startReservedVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endPCF(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishPCFBuffer(builder, offset) {
        builder.finish(offset, '$PCF');
    }
    static finishSizePrefixedPCFBuffer(builder, offset) {
        builder.finish(offset, '$PCF', true);
    }
    static createPCF(builder, STEP_SIZE, TOLERANCE, MIN_STEP, MAX_STEP, MAX_ITERATIONS, GRAVITY_DEGREE, GRAVITY_ORDER, INTEGRATOR, OUTPUT_FRAME, FORCE_FLAGS, DRAG_COEFFICIENT, SRP_COEFFICIENT, AREA_MASS_RATIO, RESERVEDOffset) {
        PCF.startPCF(builder);
        PCF.addStepSize(builder, STEP_SIZE);
        PCF.addTolerance(builder, TOLERANCE);
        PCF.addMinStep(builder, MIN_STEP);
        PCF.addMaxStep(builder, MAX_STEP);
        PCF.addMaxIterations(builder, MAX_ITERATIONS);
        PCF.addGravityDegree(builder, GRAVITY_DEGREE);
        PCF.addGravityOrder(builder, GRAVITY_ORDER);
        PCF.addIntegrator(builder, INTEGRATOR);
        PCF.addOutputFrame(builder, OUTPUT_FRAME);
        PCF.addForceFlags(builder, FORCE_FLAGS);
        PCF.addDragCoefficient(builder, DRAG_COEFFICIENT);
        PCF.addSrpCoefficient(builder, SRP_COEFFICIENT);
        PCF.addAreaMassRatio(builder, AREA_MASS_RATIO);
        PCF.addReserved(builder, RESERVEDOffset);
        return PCF.endPCF(builder);
    }
    unpack() {
        return new PCFT(this.STEP_SIZE(), this.TOLERANCE(), this.MIN_STEP(), this.MAX_STEP(), this.MAX_ITERATIONS(), this.GRAVITY_DEGREE(), this.GRAVITY_ORDER(), this.INTEGRATOR(), this.OUTPUT_FRAME(), this.FORCE_FLAGS(), this.DRAG_COEFFICIENT(), this.SRP_COEFFICIENT(), this.AREA_MASS_RATIO(), this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength()));
    }
    unpackTo(_o) {
        _o.STEP_SIZE = this.STEP_SIZE();
        _o.TOLERANCE = this.TOLERANCE();
        _o.MIN_STEP = this.MIN_STEP();
        _o.MAX_STEP = this.MAX_STEP();
        _o.MAX_ITERATIONS = this.MAX_ITERATIONS();
        _o.GRAVITY_DEGREE = this.GRAVITY_DEGREE();
        _o.GRAVITY_ORDER = this.GRAVITY_ORDER();
        _o.INTEGRATOR = this.INTEGRATOR();
        _o.OUTPUT_FRAME = this.OUTPUT_FRAME();
        _o.FORCE_FLAGS = this.FORCE_FLAGS();
        _o.DRAG_COEFFICIENT = this.DRAG_COEFFICIENT();
        _o.SRP_COEFFICIENT = this.SRP_COEFFICIENT();
        _o.AREA_MASS_RATIO = this.AREA_MASS_RATIO();
        _o.RESERVED = this.bb.createScalarList(this.RESERVED.bind(this), this.reservedLength());
    }
}
export class PCFT {
    constructor(STEP_SIZE = 0.0, TOLERANCE = 0.0, MIN_STEP = 0.0, MAX_STEP = 0.0, MAX_ITERATIONS = 0, GRAVITY_DEGREE = 0, GRAVITY_ORDER = 0, INTEGRATOR = 0, OUTPUT_FRAME = 0, FORCE_FLAGS = 0, DRAG_COEFFICIENT = 0.0, SRP_COEFFICIENT = 0.0, AREA_MASS_RATIO = 0.0, RESERVED = []) {
        this.STEP_SIZE = STEP_SIZE;
        this.TOLERANCE = TOLERANCE;
        this.MIN_STEP = MIN_STEP;
        this.MAX_STEP = MAX_STEP;
        this.MAX_ITERATIONS = MAX_ITERATIONS;
        this.GRAVITY_DEGREE = GRAVITY_DEGREE;
        this.GRAVITY_ORDER = GRAVITY_ORDER;
        this.INTEGRATOR = INTEGRATOR;
        this.OUTPUT_FRAME = OUTPUT_FRAME;
        this.FORCE_FLAGS = FORCE_FLAGS;
        this.DRAG_COEFFICIENT = DRAG_COEFFICIENT;
        this.SRP_COEFFICIENT = SRP_COEFFICIENT;
        this.AREA_MASS_RATIO = AREA_MASS_RATIO;
        this.RESERVED = RESERVED;
    }
    pack(builder) {
        const RESERVED = PCF.createReservedVector(builder, this.RESERVED);
        return PCF.createPCF(builder, this.STEP_SIZE, this.TOLERANCE, this.MIN_STEP, this.MAX_STEP, this.MAX_ITERATIONS, this.GRAVITY_DEGREE, this.GRAVITY_ORDER, this.INTEGRATOR, this.OUTPUT_FRAME, this.FORCE_FLAGS, this.DRAG_COEFFICIENT, this.SRP_COEFFICIENT, this.AREA_MASS_RATIO, RESERVED);
    }
}
