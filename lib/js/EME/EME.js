// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Encrypted Message Envelope
 */
export class EME {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEME(bb, obj) {
        return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEME(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$EME');
    }
    /**
     * Encrypted data blob, containing the ciphertext of the original plaintext message.
     */
    ENCRYPTED_BLOB(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    encryptedBlobLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    encryptedBlobArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    EPHEMERAL_PUBLIC_KEY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    MAC(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
     */
    NONCE_START(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    nonceStartLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    nonceStartArray() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    TAG(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    IV(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SALT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PUBLIC_KEY_IDENTIFIER(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CIPHER_SUITE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    KDF_PARAMETERS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ENCRYPTION_ALGORITHM_PARAMETERS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startEME(builder) {
        builder.startObject(11);
    }
    static addEncryptedBlob(builder, ENCRYPTED_BLOBOffset) {
        builder.addFieldOffset(0, ENCRYPTED_BLOBOffset, 0);
    }
    static createEncryptedBlobVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEncryptedBlobVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset) {
        builder.addFieldOffset(1, EPHEMERAL_PUBLIC_KEYOffset, 0);
    }
    static addMac(builder, MACOffset) {
        builder.addFieldOffset(2, MACOffset, 0);
    }
    static addNonceStart(builder, NONCE_STARTOffset) {
        builder.addFieldOffset(3, NONCE_STARTOffset, 0);
    }
    static createNonceStartVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startNonceStartVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTag(builder, TAGOffset) {
        builder.addFieldOffset(4, TAGOffset, 0);
    }
    static addIv(builder, IVOffset) {
        builder.addFieldOffset(5, IVOffset, 0);
    }
    static addSalt(builder, SALTOffset) {
        builder.addFieldOffset(6, SALTOffset, 0);
    }
    static addPublicKeyIdentifier(builder, PUBLIC_KEY_IDENTIFIEROffset) {
        builder.addFieldOffset(7, PUBLIC_KEY_IDENTIFIEROffset, 0);
    }
    static addCipherSuite(builder, CIPHER_SUITEOffset) {
        builder.addFieldOffset(8, CIPHER_SUITEOffset, 0);
    }
    static addKdfParameters(builder, KDF_PARAMETERSOffset) {
        builder.addFieldOffset(9, KDF_PARAMETERSOffset, 0);
    }
    static addEncryptionAlgorithmParameters(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset) {
        builder.addFieldOffset(10, ENCRYPTION_ALGORITHM_PARAMETERSOffset, 0);
    }
    static endEME(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishEMEBuffer(builder, offset) {
        builder.finish(offset, '$EME');
    }
    static finishSizePrefixedEMEBuffer(builder, offset) {
        builder.finish(offset, '$EME', true);
    }
    static createEME(builder, ENCRYPTED_BLOBOffset, EPHEMERAL_PUBLIC_KEYOffset, MACOffset, NONCE_STARTOffset, TAGOffset, IVOffset, SALTOffset, PUBLIC_KEY_IDENTIFIEROffset, CIPHER_SUITEOffset, KDF_PARAMETERSOffset, ENCRYPTION_ALGORITHM_PARAMETERSOffset) {
        EME.startEME(builder);
        EME.addEncryptedBlob(builder, ENCRYPTED_BLOBOffset);
        EME.addEphemeralPublicKey(builder, EPHEMERAL_PUBLIC_KEYOffset);
        EME.addMac(builder, MACOffset);
        EME.addNonceStart(builder, NONCE_STARTOffset);
        EME.addTag(builder, TAGOffset);
        EME.addIv(builder, IVOffset);
        EME.addSalt(builder, SALTOffset);
        EME.addPublicKeyIdentifier(builder, PUBLIC_KEY_IDENTIFIEROffset);
        EME.addCipherSuite(builder, CIPHER_SUITEOffset);
        EME.addKdfParameters(builder, KDF_PARAMETERSOffset);
        EME.addEncryptionAlgorithmParameters(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset);
        return EME.endEME(builder);
    }
    unpack() {
        return new EMET(this.bb.createScalarList(this.ENCRYPTED_BLOB.bind(this), this.encryptedBlobLength()), this.EPHEMERAL_PUBLIC_KEY(), this.MAC(), this.bb.createScalarList(this.NONCE_START.bind(this), this.nonceStartLength()), this.TAG(), this.IV(), this.SALT(), this.PUBLIC_KEY_IDENTIFIER(), this.CIPHER_SUITE(), this.KDF_PARAMETERS(), this.ENCRYPTION_ALGORITHM_PARAMETERS());
    }
    unpackTo(_o) {
        _o.ENCRYPTED_BLOB = this.bb.createScalarList(this.ENCRYPTED_BLOB.bind(this), this.encryptedBlobLength());
        _o.EPHEMERAL_PUBLIC_KEY = this.EPHEMERAL_PUBLIC_KEY();
        _o.MAC = this.MAC();
        _o.NONCE_START = this.bb.createScalarList(this.NONCE_START.bind(this), this.nonceStartLength());
        _o.TAG = this.TAG();
        _o.IV = this.IV();
        _o.SALT = this.SALT();
        _o.PUBLIC_KEY_IDENTIFIER = this.PUBLIC_KEY_IDENTIFIER();
        _o.CIPHER_SUITE = this.CIPHER_SUITE();
        _o.KDF_PARAMETERS = this.KDF_PARAMETERS();
        _o.ENCRYPTION_ALGORITHM_PARAMETERS = this.ENCRYPTION_ALGORITHM_PARAMETERS();
    }
}
export class EMET {
    constructor(ENCRYPTED_BLOB = [], EPHEMERAL_PUBLIC_KEY = null, MAC = null, NONCE_START = [], TAG = null, IV = null, SALT = null, PUBLIC_KEY_IDENTIFIER = null, CIPHER_SUITE = null, KDF_PARAMETERS = null, ENCRYPTION_ALGORITHM_PARAMETERS = null) {
        this.ENCRYPTED_BLOB = ENCRYPTED_BLOB;
        this.EPHEMERAL_PUBLIC_KEY = EPHEMERAL_PUBLIC_KEY;
        this.MAC = MAC;
        this.NONCE_START = NONCE_START;
        this.TAG = TAG;
        this.IV = IV;
        this.SALT = SALT;
        this.PUBLIC_KEY_IDENTIFIER = PUBLIC_KEY_IDENTIFIER;
        this.CIPHER_SUITE = CIPHER_SUITE;
        this.KDF_PARAMETERS = KDF_PARAMETERS;
        this.ENCRYPTION_ALGORITHM_PARAMETERS = ENCRYPTION_ALGORITHM_PARAMETERS;
    }
    pack(builder) {
        const ENCRYPTED_BLOB = EME.createEncryptedBlobVector(builder, this.ENCRYPTED_BLOB);
        const EPHEMERAL_PUBLIC_KEY = (this.EPHEMERAL_PUBLIC_KEY !== null ? builder.createString(this.EPHEMERAL_PUBLIC_KEY) : 0);
        const MAC = (this.MAC !== null ? builder.createString(this.MAC) : 0);
        const NONCE_START = EME.createNonceStartVector(builder, this.NONCE_START);
        const TAG = (this.TAG !== null ? builder.createString(this.TAG) : 0);
        const IV = (this.IV !== null ? builder.createString(this.IV) : 0);
        const SALT = (this.SALT !== null ? builder.createString(this.SALT) : 0);
        const PUBLIC_KEY_IDENTIFIER = (this.PUBLIC_KEY_IDENTIFIER !== null ? builder.createString(this.PUBLIC_KEY_IDENTIFIER) : 0);
        const CIPHER_SUITE = (this.CIPHER_SUITE !== null ? builder.createString(this.CIPHER_SUITE) : 0);
        const KDF_PARAMETERS = (this.KDF_PARAMETERS !== null ? builder.createString(this.KDF_PARAMETERS) : 0);
        const ENCRYPTION_ALGORITHM_PARAMETERS = (this.ENCRYPTION_ALGORITHM_PARAMETERS !== null ? builder.createString(this.ENCRYPTION_ALGORITHM_PARAMETERS) : 0);
        return EME.createEME(builder, ENCRYPTED_BLOB, EPHEMERAL_PUBLIC_KEY, MAC, NONCE_START, TAG, IV, SALT, PUBLIC_KEY_IDENTIFIER, CIPHER_SUITE, KDF_PARAMETERS, ENCRYPTION_ALGORITHM_PARAMETERS);
    }
}
