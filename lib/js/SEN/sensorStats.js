// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Sensor Operational Statistics
 */
export class sensorStats {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAssensorStats(bb, obj) {
        return (obj || new sensorStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAssensorStats(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new sensorStats()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    PERIOD_START(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PERIOD_END(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Total observation attempts
     */
    OBS_ATTEMPTED() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Successful observations
     */
    OBS_SUCCESSFUL() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Failed observations
     */
    OBS_FAILED() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Uptime fraction (0.0-1.0)
     */
    UPTIME() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Average tracking accuracy in arcseconds
     */
    AVG_ACCURACY() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Detected objects count
     */
    DETECTIONS() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Uncorrelated tracks count
     */
    UCT_COUNT() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    static startsensorStats(builder) {
        builder.startObject(9);
    }
    static addPeriodStart(builder, PERIOD_STARTOffset) {
        builder.addFieldOffset(0, PERIOD_STARTOffset, 0);
    }
    static addPeriodEnd(builder, PERIOD_ENDOffset) {
        builder.addFieldOffset(1, PERIOD_ENDOffset, 0);
    }
    static addObsAttempted(builder, OBS_ATTEMPTED) {
        builder.addFieldInt32(2, OBS_ATTEMPTED, 0);
    }
    static addObsSuccessful(builder, OBS_SUCCESSFUL) {
        builder.addFieldInt32(3, OBS_SUCCESSFUL, 0);
    }
    static addObsFailed(builder, OBS_FAILED) {
        builder.addFieldInt32(4, OBS_FAILED, 0);
    }
    static addUptime(builder, UPTIME) {
        builder.addFieldFloat64(5, UPTIME, 0.0);
    }
    static addAvgAccuracy(builder, AVG_ACCURACY) {
        builder.addFieldFloat64(6, AVG_ACCURACY, 0.0);
    }
    static addDetections(builder, DETECTIONS) {
        builder.addFieldInt32(7, DETECTIONS, 0);
    }
    static addUctCount(builder, UCT_COUNT) {
        builder.addFieldInt32(8, UCT_COUNT, 0);
    }
    static endsensorStats(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createsensorStats(builder, PERIOD_STARTOffset, PERIOD_ENDOffset, OBS_ATTEMPTED, OBS_SUCCESSFUL, OBS_FAILED, UPTIME, AVG_ACCURACY, DETECTIONS, UCT_COUNT) {
        sensorStats.startsensorStats(builder);
        sensorStats.addPeriodStart(builder, PERIOD_STARTOffset);
        sensorStats.addPeriodEnd(builder, PERIOD_ENDOffset);
        sensorStats.addObsAttempted(builder, OBS_ATTEMPTED);
        sensorStats.addObsSuccessful(builder, OBS_SUCCESSFUL);
        sensorStats.addObsFailed(builder, OBS_FAILED);
        sensorStats.addUptime(builder, UPTIME);
        sensorStats.addAvgAccuracy(builder, AVG_ACCURACY);
        sensorStats.addDetections(builder, DETECTIONS);
        sensorStats.addUctCount(builder, UCT_COUNT);
        return sensorStats.endsensorStats(builder);
    }
    unpack() {
        return new sensorStatsT(this.PERIOD_START(), this.PERIOD_END(), this.OBS_ATTEMPTED(), this.OBS_SUCCESSFUL(), this.OBS_FAILED(), this.UPTIME(), this.AVG_ACCURACY(), this.DETECTIONS(), this.UCT_COUNT());
    }
    unpackTo(_o) {
        _o.PERIOD_START = this.PERIOD_START();
        _o.PERIOD_END = this.PERIOD_END();
        _o.OBS_ATTEMPTED = this.OBS_ATTEMPTED();
        _o.OBS_SUCCESSFUL = this.OBS_SUCCESSFUL();
        _o.OBS_FAILED = this.OBS_FAILED();
        _o.UPTIME = this.UPTIME();
        _o.AVG_ACCURACY = this.AVG_ACCURACY();
        _o.DETECTIONS = this.DETECTIONS();
        _o.UCT_COUNT = this.UCT_COUNT();
    }
}
export class sensorStatsT {
    constructor(PERIOD_START = null, PERIOD_END = null, OBS_ATTEMPTED = 0, OBS_SUCCESSFUL = 0, OBS_FAILED = 0, UPTIME = 0.0, AVG_ACCURACY = 0.0, DETECTIONS = 0, UCT_COUNT = 0) {
        this.PERIOD_START = PERIOD_START;
        this.PERIOD_END = PERIOD_END;
        this.OBS_ATTEMPTED = OBS_ATTEMPTED;
        this.OBS_SUCCESSFUL = OBS_SUCCESSFUL;
        this.OBS_FAILED = OBS_FAILED;
        this.UPTIME = UPTIME;
        this.AVG_ACCURACY = AVG_ACCURACY;
        this.DETECTIONS = DETECTIONS;
        this.UCT_COUNT = UCT_COUNT;
    }
    pack(builder) {
        const PERIOD_START = (this.PERIOD_START !== null ? builder.createString(this.PERIOD_START) : 0);
        const PERIOD_END = (this.PERIOD_END !== null ? builder.createString(this.PERIOD_END) : 0);
        return sensorStats.createsensorStats(builder, PERIOD_START, PERIOD_END, this.OBS_ATTEMPTED, this.OBS_SUCCESSFUL, this.OBS_FAILED, this.UPTIME, this.AVG_ACCURACY, this.DETECTIONS, this.UCT_COUNT);
    }
}
