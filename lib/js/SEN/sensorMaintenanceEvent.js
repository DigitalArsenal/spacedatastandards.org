// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { maintenanceType } from './maintenanceType.js';
/**
 * Sensor Maintenance Event
 */
export class sensorMaintenanceEvent {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAssensorMaintenanceEvent(bb, obj) {
        return (obj || new sensorMaintenanceEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAssensorMaintenanceEvent(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new sensorMaintenanceEvent()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    START_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    END_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Type of maintenance
     */
    TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : maintenanceType.SCHEDULED;
    }
    DESCRIPTION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    COMPONENTS(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    componentsLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startsensorMaintenanceEvent(builder) {
        builder.startObject(5);
    }
    static addStartTime(builder, START_TIMEOffset) {
        builder.addFieldOffset(0, START_TIMEOffset, 0);
    }
    static addEndTime(builder, END_TIMEOffset) {
        builder.addFieldOffset(1, END_TIMEOffset, 0);
    }
    static addType(builder, TYPE) {
        builder.addFieldInt8(2, TYPE, maintenanceType.SCHEDULED);
    }
    static addDescription(builder, DESCRIPTIONOffset) {
        builder.addFieldOffset(3, DESCRIPTIONOffset, 0);
    }
    static addComponents(builder, COMPONENTSOffset) {
        builder.addFieldOffset(4, COMPONENTSOffset, 0);
    }
    static createComponentsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startComponentsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endsensorMaintenanceEvent(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createsensorMaintenanceEvent(builder, START_TIMEOffset, END_TIMEOffset, TYPE, DESCRIPTIONOffset, COMPONENTSOffset) {
        sensorMaintenanceEvent.startsensorMaintenanceEvent(builder);
        sensorMaintenanceEvent.addStartTime(builder, START_TIMEOffset);
        sensorMaintenanceEvent.addEndTime(builder, END_TIMEOffset);
        sensorMaintenanceEvent.addType(builder, TYPE);
        sensorMaintenanceEvent.addDescription(builder, DESCRIPTIONOffset);
        sensorMaintenanceEvent.addComponents(builder, COMPONENTSOffset);
        return sensorMaintenanceEvent.endsensorMaintenanceEvent(builder);
    }
    unpack() {
        return new sensorMaintenanceEventT(this.START_TIME(), this.END_TIME(), this.TYPE(), this.DESCRIPTION(), this.bb.createScalarList(this.COMPONENTS.bind(this), this.componentsLength()));
    }
    unpackTo(_o) {
        _o.START_TIME = this.START_TIME();
        _o.END_TIME = this.END_TIME();
        _o.TYPE = this.TYPE();
        _o.DESCRIPTION = this.DESCRIPTION();
        _o.COMPONENTS = this.bb.createScalarList(this.COMPONENTS.bind(this), this.componentsLength());
    }
}
export class sensorMaintenanceEventT {
    constructor(START_TIME = null, END_TIME = null, TYPE = maintenanceType.SCHEDULED, DESCRIPTION = null, COMPONENTS = []) {
        this.START_TIME = START_TIME;
        this.END_TIME = END_TIME;
        this.TYPE = TYPE;
        this.DESCRIPTION = DESCRIPTION;
        this.COMPONENTS = COMPONENTS;
    }
    pack(builder) {
        const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME) : 0);
        const END_TIME = (this.END_TIME !== null ? builder.createString(this.END_TIME) : 0);
        const DESCRIPTION = (this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION) : 0);
        const COMPONENTS = sensorMaintenanceEvent.createComponentsVector(builder, builder.createObjectOffsetList(this.COMPONENTS));
        return sensorMaintenanceEvent.createsensorMaintenanceEvent(builder, START_TIME, END_TIME, this.TYPE, DESCRIPTION, COMPONENTS);
    }
}
