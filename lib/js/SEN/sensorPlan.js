// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Sensor Tasking Plan
 */
export class sensorPlan {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAssensorPlan(bb, obj) {
        return (obj || new sensorPlan()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAssensorPlan(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new sensorPlan()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    START_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    END_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TARGET_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Priority level (1=highest)
     */
    PRIORITY() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    MODE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Minimum elevation in degrees
     */
    MIN_ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Maximum range in km
     */
    MAX_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    static startsensorPlan(builder) {
        builder.startObject(7);
    }
    static addStartTime(builder, START_TIMEOffset) {
        builder.addFieldOffset(0, START_TIMEOffset, 0);
    }
    static addEndTime(builder, END_TIMEOffset) {
        builder.addFieldOffset(1, END_TIMEOffset, 0);
    }
    static addTargetId(builder, TARGET_IDOffset) {
        builder.addFieldOffset(2, TARGET_IDOffset, 0);
    }
    static addPriority(builder, PRIORITY) {
        builder.addFieldInt8(3, PRIORITY, 0);
    }
    static addMode(builder, MODEOffset) {
        builder.addFieldOffset(4, MODEOffset, 0);
    }
    static addMinElevation(builder, MIN_ELEVATION) {
        builder.addFieldFloat64(5, MIN_ELEVATION, 0.0);
    }
    static addMaxRange(builder, MAX_RANGE) {
        builder.addFieldFloat64(6, MAX_RANGE, 0.0);
    }
    static endsensorPlan(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createsensorPlan(builder, START_TIMEOffset, END_TIMEOffset, TARGET_IDOffset, PRIORITY, MODEOffset, MIN_ELEVATION, MAX_RANGE) {
        sensorPlan.startsensorPlan(builder);
        sensorPlan.addStartTime(builder, START_TIMEOffset);
        sensorPlan.addEndTime(builder, END_TIMEOffset);
        sensorPlan.addTargetId(builder, TARGET_IDOffset);
        sensorPlan.addPriority(builder, PRIORITY);
        sensorPlan.addMode(builder, MODEOffset);
        sensorPlan.addMinElevation(builder, MIN_ELEVATION);
        sensorPlan.addMaxRange(builder, MAX_RANGE);
        return sensorPlan.endsensorPlan(builder);
    }
    unpack() {
        return new sensorPlanT(this.START_TIME(), this.END_TIME(), this.TARGET_ID(), this.PRIORITY(), this.MODE(), this.MIN_ELEVATION(), this.MAX_RANGE());
    }
    unpackTo(_o) {
        _o.START_TIME = this.START_TIME();
        _o.END_TIME = this.END_TIME();
        _o.TARGET_ID = this.TARGET_ID();
        _o.PRIORITY = this.PRIORITY();
        _o.MODE = this.MODE();
        _o.MIN_ELEVATION = this.MIN_ELEVATION();
        _o.MAX_RANGE = this.MAX_RANGE();
    }
}
export class sensorPlanT {
    constructor(START_TIME = null, END_TIME = null, TARGET_ID = null, PRIORITY = 0, MODE = null, MIN_ELEVATION = 0.0, MAX_RANGE = 0.0) {
        this.START_TIME = START_TIME;
        this.END_TIME = END_TIME;
        this.TARGET_ID = TARGET_ID;
        this.PRIORITY = PRIORITY;
        this.MODE = MODE;
        this.MIN_ELEVATION = MIN_ELEVATION;
        this.MAX_RANGE = MAX_RANGE;
    }
    pack(builder) {
        const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME) : 0);
        const END_TIME = (this.END_TIME !== null ? builder.createString(this.END_TIME) : 0);
        const TARGET_ID = (this.TARGET_ID !== null ? builder.createString(this.TARGET_ID) : 0);
        const MODE = (this.MODE !== null ? builder.createString(this.MODE) : 0);
        return sensorPlan.createsensorPlan(builder, START_TIME, END_TIME, TARGET_ID, this.PRIORITY, MODE, this.MIN_ELEVATION, this.MAX_RANGE);
    }
}
