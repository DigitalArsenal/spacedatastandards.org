// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { ByteOrderType } from './ByteOrderType.js';
import { ContextCalibrator } from './ContextCalibrator.js';
import { FloatEncodingType } from './FloatEncodingType.js';
/**
 * Float data encoding specification
 */
export class FloatDataEncoding {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsFloatDataEncoding(bb, obj) {
        return (obj || new FloatDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatDataEncoding(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FloatDataEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bits (typically 32 or 64)
     */
    SIZE_IN_BITS() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Byte ordering
     */
    BYTE_ORDER() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : ByteOrderType.BIG_ENDIAN;
    }
    /**
     * Float encoding format
     */
    ENCODING() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : FloatEncodingType.IEEE754_1985;
    }
    DEFAULT_CALIBRATOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Context-dependent calibrators
     */
    CONTEXT_CALIBRATOR_LIST(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new ContextCalibrator()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    contextCalibratorListLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFloatDataEncoding(builder) {
        builder.startObject(5);
    }
    static addSizeInBits(builder, SIZE_IN_BITS) {
        builder.addFieldInt16(0, SIZE_IN_BITS, 0);
    }
    static addByteOrder(builder, BYTE_ORDER) {
        builder.addFieldInt8(1, BYTE_ORDER, ByteOrderType.BIG_ENDIAN);
    }
    static addEncoding(builder, ENCODING) {
        builder.addFieldInt8(2, ENCODING, FloatEncodingType.IEEE754_1985);
    }
    static addDefaultCalibrator(builder, DEFAULT_CALIBRATOROffset) {
        builder.addFieldOffset(3, DEFAULT_CALIBRATOROffset, 0);
    }
    static addContextCalibratorList(builder, CONTEXT_CALIBRATOR_LISTOffset) {
        builder.addFieldOffset(4, CONTEXT_CALIBRATOR_LISTOffset, 0);
    }
    static createContextCalibratorListVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startContextCalibratorListVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endFloatDataEncoding(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createFloatDataEncoding(builder, SIZE_IN_BITS, BYTE_ORDER, ENCODING, DEFAULT_CALIBRATOROffset, CONTEXT_CALIBRATOR_LISTOffset) {
        FloatDataEncoding.startFloatDataEncoding(builder);
        FloatDataEncoding.addSizeInBits(builder, SIZE_IN_BITS);
        FloatDataEncoding.addByteOrder(builder, BYTE_ORDER);
        FloatDataEncoding.addEncoding(builder, ENCODING);
        FloatDataEncoding.addDefaultCalibrator(builder, DEFAULT_CALIBRATOROffset);
        FloatDataEncoding.addContextCalibratorList(builder, CONTEXT_CALIBRATOR_LISTOffset);
        return FloatDataEncoding.endFloatDataEncoding(builder);
    }
    unpack() {
        return new FloatDataEncodingT(this.SIZE_IN_BITS(), this.BYTE_ORDER(), this.ENCODING(), this.DEFAULT_CALIBRATOR(), this.bb.createObjList(this.CONTEXT_CALIBRATOR_LIST.bind(this), this.contextCalibratorListLength()));
    }
    unpackTo(_o) {
        _o.SIZE_IN_BITS = this.SIZE_IN_BITS();
        _o.BYTE_ORDER = this.BYTE_ORDER();
        _o.ENCODING = this.ENCODING();
        _o.DEFAULT_CALIBRATOR = this.DEFAULT_CALIBRATOR();
        _o.CONTEXT_CALIBRATOR_LIST = this.bb.createObjList(this.CONTEXT_CALIBRATOR_LIST.bind(this), this.contextCalibratorListLength());
    }
}
export class FloatDataEncodingT {
    constructor(SIZE_IN_BITS = 0, BYTE_ORDER = ByteOrderType.BIG_ENDIAN, ENCODING = FloatEncodingType.IEEE754_1985, DEFAULT_CALIBRATOR = null, CONTEXT_CALIBRATOR_LIST = []) {
        this.SIZE_IN_BITS = SIZE_IN_BITS;
        this.BYTE_ORDER = BYTE_ORDER;
        this.ENCODING = ENCODING;
        this.DEFAULT_CALIBRATOR = DEFAULT_CALIBRATOR;
        this.CONTEXT_CALIBRATOR_LIST = CONTEXT_CALIBRATOR_LIST;
    }
    pack(builder) {
        const DEFAULT_CALIBRATOR = (this.DEFAULT_CALIBRATOR !== null ? builder.createString(this.DEFAULT_CALIBRATOR) : 0);
        const CONTEXT_CALIBRATOR_LIST = FloatDataEncoding.createContextCalibratorListVector(builder, builder.createObjectOffsetList(this.CONTEXT_CALIBRATOR_LIST));
        return FloatDataEncoding.createFloatDataEncoding(builder, this.SIZE_IN_BITS, this.BYTE_ORDER, this.ENCODING, DEFAULT_CALIBRATOR, CONTEXT_CALIBRATOR_LIST);
    }
}
