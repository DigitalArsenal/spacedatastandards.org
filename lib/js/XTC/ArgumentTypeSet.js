// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { AggregateArgumentType } from './AggregateArgumentType.js';
import { BinaryArgumentType } from './BinaryArgumentType.js';
import { BooleanArgumentType } from './BooleanArgumentType.js';
import { EnumeratedArgumentType } from './EnumeratedArgumentType.js';
import { FloatArgumentType } from './FloatArgumentType.js';
import { IntegerArgumentType } from './IntegerArgumentType.js';
import { StringArgumentType } from './StringArgumentType.js';
/**
 * Collection of argument types
 */
export class ArgumentTypeSet {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsArgumentTypeSet(bb, obj) {
        return (obj || new ArgumentTypeSet()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsArgumentTypeSet(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new ArgumentTypeSet()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Integer argument types
     */
    INTEGER_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new IntegerArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    integerTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Float argument types
     */
    FLOAT_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new FloatArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    floatTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * String argument types
     */
    STRING_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new StringArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    stringTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Boolean argument types
     */
    BOOLEAN_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new BooleanArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    booleanTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Enumerated argument types
     */
    ENUMERATED_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new EnumeratedArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    enumeratedTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Binary argument types
     */
    BINARY_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new BinaryArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    binaryTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Aggregate argument types
     */
    AGGREGATE_TYPES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new AggregateArgumentType()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    aggregateTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startArgumentTypeSet(builder) {
        builder.startObject(7);
    }
    static addIntegerTypes(builder, INTEGER_TYPESOffset) {
        builder.addFieldOffset(0, INTEGER_TYPESOffset, 0);
    }
    static createIntegerTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startIntegerTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addFloatTypes(builder, FLOAT_TYPESOffset) {
        builder.addFieldOffset(1, FLOAT_TYPESOffset, 0);
    }
    static createFloatTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startFloatTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addStringTypes(builder, STRING_TYPESOffset) {
        builder.addFieldOffset(2, STRING_TYPESOffset, 0);
    }
    static createStringTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startStringTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addBooleanTypes(builder, BOOLEAN_TYPESOffset) {
        builder.addFieldOffset(3, BOOLEAN_TYPESOffset, 0);
    }
    static createBooleanTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBooleanTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEnumeratedTypes(builder, ENUMERATED_TYPESOffset) {
        builder.addFieldOffset(4, ENUMERATED_TYPESOffset, 0);
    }
    static createEnumeratedTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startEnumeratedTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addBinaryTypes(builder, BINARY_TYPESOffset) {
        builder.addFieldOffset(5, BINARY_TYPESOffset, 0);
    }
    static createBinaryTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBinaryTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addAggregateTypes(builder, AGGREGATE_TYPESOffset) {
        builder.addFieldOffset(6, AGGREGATE_TYPESOffset, 0);
    }
    static createAggregateTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startAggregateTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endArgumentTypeSet(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createArgumentTypeSet(builder, INTEGER_TYPESOffset, FLOAT_TYPESOffset, STRING_TYPESOffset, BOOLEAN_TYPESOffset, ENUMERATED_TYPESOffset, BINARY_TYPESOffset, AGGREGATE_TYPESOffset) {
        ArgumentTypeSet.startArgumentTypeSet(builder);
        ArgumentTypeSet.addIntegerTypes(builder, INTEGER_TYPESOffset);
        ArgumentTypeSet.addFloatTypes(builder, FLOAT_TYPESOffset);
        ArgumentTypeSet.addStringTypes(builder, STRING_TYPESOffset);
        ArgumentTypeSet.addBooleanTypes(builder, BOOLEAN_TYPESOffset);
        ArgumentTypeSet.addEnumeratedTypes(builder, ENUMERATED_TYPESOffset);
        ArgumentTypeSet.addBinaryTypes(builder, BINARY_TYPESOffset);
        ArgumentTypeSet.addAggregateTypes(builder, AGGREGATE_TYPESOffset);
        return ArgumentTypeSet.endArgumentTypeSet(builder);
    }
    unpack() {
        return new ArgumentTypeSetT(this.bb.createObjList(this.INTEGER_TYPES.bind(this), this.integerTypesLength()), this.bb.createObjList(this.FLOAT_TYPES.bind(this), this.floatTypesLength()), this.bb.createObjList(this.STRING_TYPES.bind(this), this.stringTypesLength()), this.bb.createObjList(this.BOOLEAN_TYPES.bind(this), this.booleanTypesLength()), this.bb.createObjList(this.ENUMERATED_TYPES.bind(this), this.enumeratedTypesLength()), this.bb.createObjList(this.BINARY_TYPES.bind(this), this.binaryTypesLength()), this.bb.createObjList(this.AGGREGATE_TYPES.bind(this), this.aggregateTypesLength()));
    }
    unpackTo(_o) {
        _o.INTEGER_TYPES = this.bb.createObjList(this.INTEGER_TYPES.bind(this), this.integerTypesLength());
        _o.FLOAT_TYPES = this.bb.createObjList(this.FLOAT_TYPES.bind(this), this.floatTypesLength());
        _o.STRING_TYPES = this.bb.createObjList(this.STRING_TYPES.bind(this), this.stringTypesLength());
        _o.BOOLEAN_TYPES = this.bb.createObjList(this.BOOLEAN_TYPES.bind(this), this.booleanTypesLength());
        _o.ENUMERATED_TYPES = this.bb.createObjList(this.ENUMERATED_TYPES.bind(this), this.enumeratedTypesLength());
        _o.BINARY_TYPES = this.bb.createObjList(this.BINARY_TYPES.bind(this), this.binaryTypesLength());
        _o.AGGREGATE_TYPES = this.bb.createObjList(this.AGGREGATE_TYPES.bind(this), this.aggregateTypesLength());
    }
}
export class ArgumentTypeSetT {
    constructor(INTEGER_TYPES = [], FLOAT_TYPES = [], STRING_TYPES = [], BOOLEAN_TYPES = [], ENUMERATED_TYPES = [], BINARY_TYPES = [], AGGREGATE_TYPES = []) {
        this.INTEGER_TYPES = INTEGER_TYPES;
        this.FLOAT_TYPES = FLOAT_TYPES;
        this.STRING_TYPES = STRING_TYPES;
        this.BOOLEAN_TYPES = BOOLEAN_TYPES;
        this.ENUMERATED_TYPES = ENUMERATED_TYPES;
        this.BINARY_TYPES = BINARY_TYPES;
        this.AGGREGATE_TYPES = AGGREGATE_TYPES;
    }
    pack(builder) {
        const INTEGER_TYPES = ArgumentTypeSet.createIntegerTypesVector(builder, builder.createObjectOffsetList(this.INTEGER_TYPES));
        const FLOAT_TYPES = ArgumentTypeSet.createFloatTypesVector(builder, builder.createObjectOffsetList(this.FLOAT_TYPES));
        const STRING_TYPES = ArgumentTypeSet.createStringTypesVector(builder, builder.createObjectOffsetList(this.STRING_TYPES));
        const BOOLEAN_TYPES = ArgumentTypeSet.createBooleanTypesVector(builder, builder.createObjectOffsetList(this.BOOLEAN_TYPES));
        const ENUMERATED_TYPES = ArgumentTypeSet.createEnumeratedTypesVector(builder, builder.createObjectOffsetList(this.ENUMERATED_TYPES));
        const BINARY_TYPES = ArgumentTypeSet.createBinaryTypesVector(builder, builder.createObjectOffsetList(this.BINARY_TYPES));
        const AGGREGATE_TYPES = ArgumentTypeSet.createAggregateTypesVector(builder, builder.createObjectOffsetList(this.AGGREGATE_TYPES));
        return ArgumentTypeSet.createArgumentTypeSet(builder, INTEGER_TYPES, FLOAT_TYPES, STRING_TYPES, BOOLEAN_TYPES, ENUMERATED_TYPES, BINARY_TYPES, AGGREGATE_TYPES);
    }
}
