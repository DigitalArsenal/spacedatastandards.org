// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
/**
 * Collection Request Message
 */
export class CRM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsCRM(bb, obj) {
        return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsCRM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new CRM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CLASSIFICATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_PLAN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Index number for records within a collection plan or schedule.
     */
    PLAN_INDEX() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    TASK_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    DWELL_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    EXTERNAL_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_SENSOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    OB_TYPE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PRIORITY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The tasking category associated with this request.
     */
    TASK_CATEGORY() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    SUFFIX(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Boolean indicating that this collect request is UCT follow-up.
     */
    UCT_FOLLOW_UP() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    START_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    END_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Satellite/catalog number of the target on-orbit object for this request.
     */
    NORAD_CAT_ID() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    ORIG_OBJECT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TASK_GROUP(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Inter-Range Operations Number.
     */
    IRON() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    ORBIT_REGIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The minimum object (diameter) size, in meters, to be reported.
     */
    TARGET_SIZE() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The minimum Radar Cross-Section of the target, in m^2.
     */
    RCS_MIN() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The Radar Cross-Section of the target, in m^2.
     */
    RCS() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The maximum Radar Cross-Section of the target, in m^2.
     */
    RCS_MAX() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The minimum frequency of interest, in MHz.
     */
    FREQ_MIN() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The estimated or expected emission frequency of the target, in MHz.
     */
    FREQ() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The maximum frequency of interest, in MHz.
     */
    FREQ_MAX() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    POLARIZATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    VIS_MAG_MIN() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    VIS_MAG() {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
     */
    VIS_MAG_MAX() {
        const offset = this.bb.__offset(this.bb_pos, 68);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    SPECTRAL_MODEL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The fraction of solar energy reflected from target.
     */
    REFLECTANCE() {
        const offset = this.bb.__offset(this.bb_pos, 72);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The target object irradiance value.
     */
    IRRADIANCE() {
        const offset = this.bb.__offset(this.bb_pos, 74);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * For optical sensors, the requested number of frames to capture at each sensor step.
     */
    NUM_FRAMES() {
        const offset = this.bb.__offset(this.bb_pos, 76);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * For optical sensors, the frame rate of the camera, in Hz.
     */
    FRAME_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 78);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * For optical sensors, the integration time per camera frame, in milliseconds.
     */
    INTEGRATION_TIME() {
        const offset = this.bb.__offset(this.bb_pos, 80);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The number of requested tracks on the target.
     */
    NUM_TRACKS() {
        const offset = this.bb.__offset(this.bb_pos, 82);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The number of requested observations on the target.
     */
    NUM_OBS() {
        const offset = this.bb.__offset(this.bb_pos, 84);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The duration of the collect request, in seconds.
     */
    DURATION() {
        const offset = this.bb.__offset(this.bb_pos, 86);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    SRCH_PATTERN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 88);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SCENARIO(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 90);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_ELSET(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 92);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_MANIFOLD(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 94);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ID_STATE_VECTOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 96);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ES_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    EPOCH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 100);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The average of the periapsis and apoapsis distances, in kilometers.
     */
    SEMI_MAJOR_AXIS() {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The orbital eccentricity of an astronomical object.
     */
    ECCENTRICITY() {
        const offset = this.bb.__offset(this.bb_pos, 104);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angle, in degrees, between the equator and the orbit plane.
     */
    INCLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 106);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension of the ascending node, in degrees.
     */
    RAAN() {
        const offset = this.bb.__offset(this.bb_pos, 108);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The argument of perigee, in degrees.
     */
    ARG_OF_PERIGEE() {
        const offset = this.bb.__offset(this.bb_pos, 110);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
     */
    MEAN_ANOMALY() {
        const offset = this.bb.__offset(this.bb_pos, 112);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The expected or directed right ascension angle, in degrees.
     */
    RA() {
        const offset = this.bb.__offset(this.bb_pos, 114);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The expected or directed declination angle, in degrees.
     */
    DEC() {
        const offset = this.bb.__offset(this.bb_pos, 116);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The expected or directed azimuth angle, in degrees.
     */
    AZ() {
        const offset = this.bb.__offset(this.bb_pos, 118);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The expected or directed elevation angle, in degrees.
     */
    EL() {
        const offset = this.bb.__offset(this.bb_pos, 120);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The expected acquisition range or defined center range, in km.
     */
    RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 122);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The extent of the azimuth angle, in degrees, from center azimuth.
     */
    EXTENT_AZ() {
        const offset = this.bb.__offset(this.bb_pos, 124);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The extent of the elevation angle, in degrees, from center elevation.
     */
    EXTENT_EL() {
        const offset = this.bb.__offset(this.bb_pos, 126);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The extent of the range, in km, from center range.
     */
    EXTENT_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 128);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 latitude, in degrees.
     */
    LAT() {
        const offset = this.bb.__offset(this.bb_pos, 130);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 longitude, in degrees.
     */
    LON() {
        const offset = this.bb.__offset(this.bb_pos, 132);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Height above WGS-84 ellipsoid (HAE), in kilometers.
     */
    ALT() {
        const offset = this.bb.__offset(this.bb_pos, 134);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The stopping WGS-84 latitude of a volume definition, in degrees.
     */
    STOP_LAT() {
        const offset = this.bb.__offset(this.bb_pos, 136);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The stopping WGS-84 longitude of a volume definition, in degrees.
     */
    STOP_LON() {
        const offset = this.bb.__offset(this.bb_pos, 138);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
     */
    STOP_ALT() {
        const offset = this.bb.__offset(this.bb_pos, 140);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The maximum inclination, in degrees, to be used in search operations.
     */
    SRCH_INC() {
        const offset = this.bb.__offset(this.bb_pos, 142);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angular distance, in degrees, in the sensor-x direction from scan center.
     */
    X_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 144);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angular distance, in degrees, in the sensor-y direction from scan center.
     */
    Y_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 146);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
     */
    ORIENT_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 148);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    CUSTOMER(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 150);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    NOTES(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 152);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 154);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIGIN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 156);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    DATA_MODE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 158);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startCRM(builder) {
        builder.startObject(78);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addClassification(builder, CLASSIFICATIONOffset) {
        builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
    }
    static addType(builder, TYPEOffset) {
        builder.addFieldOffset(2, TYPEOffset, 0);
    }
    static addIdPlan(builder, ID_PLANOffset) {
        builder.addFieldOffset(3, ID_PLANOffset, 0);
    }
    static addPlanIndex(builder, PLAN_INDEX) {
        builder.addFieldInt32(4, PLAN_INDEX, 0);
    }
    static addTaskId(builder, TASK_IDOffset) {
        builder.addFieldOffset(5, TASK_IDOffset, 0);
    }
    static addDwellId(builder, DWELL_IDOffset) {
        builder.addFieldOffset(6, DWELL_IDOffset, 0);
    }
    static addExternalId(builder, EXTERNAL_IDOffset) {
        builder.addFieldOffset(7, EXTERNAL_IDOffset, 0);
    }
    static addIdSensor(builder, ID_SENSOROffset) {
        builder.addFieldOffset(8, ID_SENSOROffset, 0);
    }
    static addOrigSensorId(builder, ORIG_SENSOR_IDOffset) {
        builder.addFieldOffset(9, ORIG_SENSOR_IDOffset, 0);
    }
    static addObType(builder, OB_TYPEOffset) {
        builder.addFieldOffset(10, OB_TYPEOffset, 0);
    }
    static addPriority(builder, PRIORITYOffset) {
        builder.addFieldOffset(11, PRIORITYOffset, 0);
    }
    static addTaskCategory(builder, TASK_CATEGORY) {
        builder.addFieldInt32(12, TASK_CATEGORY, 0);
    }
    static addSuffix(builder, SUFFIXOffset) {
        builder.addFieldOffset(13, SUFFIXOffset, 0);
    }
    static addUctFollowUp(builder, UCT_FOLLOW_UP) {
        builder.addFieldInt8(14, +UCT_FOLLOW_UP, +false);
    }
    static addStartTime(builder, START_TIMEOffset) {
        builder.addFieldOffset(15, START_TIMEOffset, 0);
    }
    static addEndTime(builder, END_TIMEOffset) {
        builder.addFieldOffset(16, END_TIMEOffset, 0);
    }
    static addNoradCatId(builder, NORAD_CAT_ID) {
        builder.addFieldInt32(17, NORAD_CAT_ID, 0);
    }
    static addOrigObjectId(builder, ORIG_OBJECT_IDOffset) {
        builder.addFieldOffset(18, ORIG_OBJECT_IDOffset, 0);
    }
    static addTaskGroup(builder, TASK_GROUPOffset) {
        builder.addFieldOffset(19, TASK_GROUPOffset, 0);
    }
    static addIron(builder, IRON) {
        builder.addFieldInt32(20, IRON, 0);
    }
    static addOrbitRegime(builder, ORBIT_REGIMEOffset) {
        builder.addFieldOffset(21, ORBIT_REGIMEOffset, 0);
    }
    static addTargetSize(builder, TARGET_SIZE) {
        builder.addFieldFloat64(22, TARGET_SIZE, 0.0);
    }
    static addRcsMin(builder, RCS_MIN) {
        builder.addFieldFloat64(23, RCS_MIN, 0.0);
    }
    static addRcs(builder, RCS) {
        builder.addFieldFloat64(24, RCS, 0.0);
    }
    static addRcsMax(builder, RCS_MAX) {
        builder.addFieldFloat64(25, RCS_MAX, 0.0);
    }
    static addFreqMin(builder, FREQ_MIN) {
        builder.addFieldFloat64(26, FREQ_MIN, 0.0);
    }
    static addFreq(builder, FREQ) {
        builder.addFieldFloat64(27, FREQ, 0.0);
    }
    static addFreqMax(builder, FREQ_MAX) {
        builder.addFieldFloat64(28, FREQ_MAX, 0.0);
    }
    static addPolarization(builder, POLARIZATIONOffset) {
        builder.addFieldOffset(29, POLARIZATIONOffset, 0);
    }
    static addVisMagMin(builder, VIS_MAG_MIN) {
        builder.addFieldFloat64(30, VIS_MAG_MIN, 0.0);
    }
    static addVisMag(builder, VIS_MAG) {
        builder.addFieldFloat64(31, VIS_MAG, 0.0);
    }
    static addVisMagMax(builder, VIS_MAG_MAX) {
        builder.addFieldFloat64(32, VIS_MAG_MAX, 0.0);
    }
    static addSpectralModel(builder, SPECTRAL_MODELOffset) {
        builder.addFieldOffset(33, SPECTRAL_MODELOffset, 0);
    }
    static addReflectance(builder, REFLECTANCE) {
        builder.addFieldFloat64(34, REFLECTANCE, 0.0);
    }
    static addIrradiance(builder, IRRADIANCE) {
        builder.addFieldFloat64(35, IRRADIANCE, 0.0);
    }
    static addNumFrames(builder, NUM_FRAMES) {
        builder.addFieldInt32(36, NUM_FRAMES, 0);
    }
    static addFrameRate(builder, FRAME_RATE) {
        builder.addFieldFloat64(37, FRAME_RATE, 0.0);
    }
    static addIntegrationTime(builder, INTEGRATION_TIME) {
        builder.addFieldFloat64(38, INTEGRATION_TIME, 0.0);
    }
    static addNumTracks(builder, NUM_TRACKS) {
        builder.addFieldInt32(39, NUM_TRACKS, 0);
    }
    static addNumObs(builder, NUM_OBS) {
        builder.addFieldInt32(40, NUM_OBS, 0);
    }
    static addDuration(builder, DURATION) {
        builder.addFieldInt32(41, DURATION, 0);
    }
    static addSrchPattern(builder, SRCH_PATTERNOffset) {
        builder.addFieldOffset(42, SRCH_PATTERNOffset, 0);
    }
    static addScenario(builder, SCENARIOOffset) {
        builder.addFieldOffset(43, SCENARIOOffset, 0);
    }
    static addIdElset(builder, ID_ELSETOffset) {
        builder.addFieldOffset(44, ID_ELSETOffset, 0);
    }
    static addIdManifold(builder, ID_MANIFOLDOffset) {
        builder.addFieldOffset(45, ID_MANIFOLDOffset, 0);
    }
    static addIdStateVector(builder, ID_STATE_VECTOROffset) {
        builder.addFieldOffset(46, ID_STATE_VECTOROffset, 0);
    }
    static addEsId(builder, ES_IDOffset) {
        builder.addFieldOffset(47, ES_IDOffset, 0);
    }
    static addEpoch(builder, EPOCHOffset) {
        builder.addFieldOffset(48, EPOCHOffset, 0);
    }
    static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
        builder.addFieldFloat64(49, SEMI_MAJOR_AXIS, 0.0);
    }
    static addEccentricity(builder, ECCENTRICITY) {
        builder.addFieldFloat64(50, ECCENTRICITY, 0.0);
    }
    static addInclination(builder, INCLINATION) {
        builder.addFieldFloat64(51, INCLINATION, 0.0);
    }
    static addRaan(builder, RAAN) {
        builder.addFieldFloat64(52, RAAN, 0.0);
    }
    static addArgOfPerigee(builder, ARG_OF_PERIGEE) {
        builder.addFieldFloat64(53, ARG_OF_PERIGEE, 0.0);
    }
    static addMeanAnomaly(builder, MEAN_ANOMALY) {
        builder.addFieldFloat64(54, MEAN_ANOMALY, 0.0);
    }
    static addRa(builder, RA) {
        builder.addFieldFloat64(55, RA, 0.0);
    }
    static addDec(builder, DEC) {
        builder.addFieldFloat64(56, DEC, 0.0);
    }
    static addAz(builder, AZ) {
        builder.addFieldFloat64(57, AZ, 0.0);
    }
    static addEl(builder, EL) {
        builder.addFieldFloat64(58, EL, 0.0);
    }
    static addRange(builder, RANGE) {
        builder.addFieldFloat64(59, RANGE, 0.0);
    }
    static addExtentAz(builder, EXTENT_AZ) {
        builder.addFieldFloat64(60, EXTENT_AZ, 0.0);
    }
    static addExtentEl(builder, EXTENT_EL) {
        builder.addFieldFloat64(61, EXTENT_EL, 0.0);
    }
    static addExtentRange(builder, EXTENT_RANGE) {
        builder.addFieldFloat64(62, EXTENT_RANGE, 0.0);
    }
    static addLat(builder, LAT) {
        builder.addFieldFloat64(63, LAT, 0.0);
    }
    static addLon(builder, LON) {
        builder.addFieldFloat64(64, LON, 0.0);
    }
    static addAlt(builder, ALT) {
        builder.addFieldFloat64(65, ALT, 0.0);
    }
    static addStopLat(builder, STOP_LAT) {
        builder.addFieldFloat64(66, STOP_LAT, 0.0);
    }
    static addStopLon(builder, STOP_LON) {
        builder.addFieldFloat64(67, STOP_LON, 0.0);
    }
    static addStopAlt(builder, STOP_ALT) {
        builder.addFieldFloat64(68, STOP_ALT, 0.0);
    }
    static addSrchInc(builder, SRCH_INC) {
        builder.addFieldFloat64(69, SRCH_INC, 0.0);
    }
    static addXAngle(builder, X_ANGLE) {
        builder.addFieldFloat64(70, X_ANGLE, 0.0);
    }
    static addYAngle(builder, Y_ANGLE) {
        builder.addFieldFloat64(71, Y_ANGLE, 0.0);
    }
    static addOrientAngle(builder, ORIENT_ANGLE) {
        builder.addFieldFloat64(72, ORIENT_ANGLE, 0.0);
    }
    static addCustomer(builder, CUSTOMEROffset) {
        builder.addFieldOffset(73, CUSTOMEROffset, 0);
    }
    static addNotes(builder, NOTESOffset) {
        builder.addFieldOffset(74, NOTESOffset, 0);
    }
    static addSource(builder, SOURCEOffset) {
        builder.addFieldOffset(75, SOURCEOffset, 0);
    }
    static addOrigin(builder, ORIGINOffset) {
        builder.addFieldOffset(76, ORIGINOffset, 0);
    }
    static addDataMode(builder, DATA_MODEOffset) {
        builder.addFieldOffset(77, DATA_MODEOffset, 0);
    }
    static endCRM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createCRM(builder, IDOffset, CLASSIFICATIONOffset, TYPEOffset, ID_PLANOffset, PLAN_INDEX, TASK_IDOffset, DWELL_IDOffset, EXTERNAL_IDOffset, ID_SENSOROffset, ORIG_SENSOR_IDOffset, OB_TYPEOffset, PRIORITYOffset, TASK_CATEGORY, SUFFIXOffset, UCT_FOLLOW_UP, START_TIMEOffset, END_TIMEOffset, NORAD_CAT_ID, ORIG_OBJECT_IDOffset, TASK_GROUPOffset, IRON, ORBIT_REGIMEOffset, TARGET_SIZE, RCS_MIN, RCS, RCS_MAX, FREQ_MIN, FREQ, FREQ_MAX, POLARIZATIONOffset, VIS_MAG_MIN, VIS_MAG, VIS_MAG_MAX, SPECTRAL_MODELOffset, REFLECTANCE, IRRADIANCE, NUM_FRAMES, FRAME_RATE, INTEGRATION_TIME, NUM_TRACKS, NUM_OBS, DURATION, SRCH_PATTERNOffset, SCENARIOOffset, ID_ELSETOffset, ID_MANIFOLDOffset, ID_STATE_VECTOROffset, ES_IDOffset, EPOCHOffset, SEMI_MAJOR_AXIS, ECCENTRICITY, INCLINATION, RAAN, ARG_OF_PERIGEE, MEAN_ANOMALY, RA, DEC, AZ, EL, RANGE, EXTENT_AZ, EXTENT_EL, EXTENT_RANGE, LAT, LON, ALT, STOP_LAT, STOP_LON, STOP_ALT, SRCH_INC, X_ANGLE, Y_ANGLE, ORIENT_ANGLE, CUSTOMEROffset, NOTESOffset, SOURCEOffset, ORIGINOffset, DATA_MODEOffset) {
        CRM.startCRM(builder);
        CRM.addId(builder, IDOffset);
        CRM.addClassification(builder, CLASSIFICATIONOffset);
        CRM.addType(builder, TYPEOffset);
        CRM.addIdPlan(builder, ID_PLANOffset);
        CRM.addPlanIndex(builder, PLAN_INDEX);
        CRM.addTaskId(builder, TASK_IDOffset);
        CRM.addDwellId(builder, DWELL_IDOffset);
        CRM.addExternalId(builder, EXTERNAL_IDOffset);
        CRM.addIdSensor(builder, ID_SENSOROffset);
        CRM.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
        CRM.addObType(builder, OB_TYPEOffset);
        CRM.addPriority(builder, PRIORITYOffset);
        CRM.addTaskCategory(builder, TASK_CATEGORY);
        CRM.addSuffix(builder, SUFFIXOffset);
        CRM.addUctFollowUp(builder, UCT_FOLLOW_UP);
        CRM.addStartTime(builder, START_TIMEOffset);
        CRM.addEndTime(builder, END_TIMEOffset);
        CRM.addNoradCatId(builder, NORAD_CAT_ID);
        CRM.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
        CRM.addTaskGroup(builder, TASK_GROUPOffset);
        CRM.addIron(builder, IRON);
        CRM.addOrbitRegime(builder, ORBIT_REGIMEOffset);
        CRM.addTargetSize(builder, TARGET_SIZE);
        CRM.addRcsMin(builder, RCS_MIN);
        CRM.addRcs(builder, RCS);
        CRM.addRcsMax(builder, RCS_MAX);
        CRM.addFreqMin(builder, FREQ_MIN);
        CRM.addFreq(builder, FREQ);
        CRM.addFreqMax(builder, FREQ_MAX);
        CRM.addPolarization(builder, POLARIZATIONOffset);
        CRM.addVisMagMin(builder, VIS_MAG_MIN);
        CRM.addVisMag(builder, VIS_MAG);
        CRM.addVisMagMax(builder, VIS_MAG_MAX);
        CRM.addSpectralModel(builder, SPECTRAL_MODELOffset);
        CRM.addReflectance(builder, REFLECTANCE);
        CRM.addIrradiance(builder, IRRADIANCE);
        CRM.addNumFrames(builder, NUM_FRAMES);
        CRM.addFrameRate(builder, FRAME_RATE);
        CRM.addIntegrationTime(builder, INTEGRATION_TIME);
        CRM.addNumTracks(builder, NUM_TRACKS);
        CRM.addNumObs(builder, NUM_OBS);
        CRM.addDuration(builder, DURATION);
        CRM.addSrchPattern(builder, SRCH_PATTERNOffset);
        CRM.addScenario(builder, SCENARIOOffset);
        CRM.addIdElset(builder, ID_ELSETOffset);
        CRM.addIdManifold(builder, ID_MANIFOLDOffset);
        CRM.addIdStateVector(builder, ID_STATE_VECTOROffset);
        CRM.addEsId(builder, ES_IDOffset);
        CRM.addEpoch(builder, EPOCHOffset);
        CRM.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
        CRM.addEccentricity(builder, ECCENTRICITY);
        CRM.addInclination(builder, INCLINATION);
        CRM.addRaan(builder, RAAN);
        CRM.addArgOfPerigee(builder, ARG_OF_PERIGEE);
        CRM.addMeanAnomaly(builder, MEAN_ANOMALY);
        CRM.addRa(builder, RA);
        CRM.addDec(builder, DEC);
        CRM.addAz(builder, AZ);
        CRM.addEl(builder, EL);
        CRM.addRange(builder, RANGE);
        CRM.addExtentAz(builder, EXTENT_AZ);
        CRM.addExtentEl(builder, EXTENT_EL);
        CRM.addExtentRange(builder, EXTENT_RANGE);
        CRM.addLat(builder, LAT);
        CRM.addLon(builder, LON);
        CRM.addAlt(builder, ALT);
        CRM.addStopLat(builder, STOP_LAT);
        CRM.addStopLon(builder, STOP_LON);
        CRM.addStopAlt(builder, STOP_ALT);
        CRM.addSrchInc(builder, SRCH_INC);
        CRM.addXAngle(builder, X_ANGLE);
        CRM.addYAngle(builder, Y_ANGLE);
        CRM.addOrientAngle(builder, ORIENT_ANGLE);
        CRM.addCustomer(builder, CUSTOMEROffset);
        CRM.addNotes(builder, NOTESOffset);
        CRM.addSource(builder, SOURCEOffset);
        CRM.addOrigin(builder, ORIGINOffset);
        CRM.addDataMode(builder, DATA_MODEOffset);
        return CRM.endCRM(builder);
    }
    unpack() {
        return new CRMT(this.ID(), this.CLASSIFICATION(), this.TYPE(), this.ID_PLAN(), this.PLAN_INDEX(), this.TASK_ID(), this.DWELL_ID(), this.EXTERNAL_ID(), this.ID_SENSOR(), this.ORIG_SENSOR_ID(), this.OB_TYPE(), this.PRIORITY(), this.TASK_CATEGORY(), this.SUFFIX(), this.UCT_FOLLOW_UP(), this.START_TIME(), this.END_TIME(), this.NORAD_CAT_ID(), this.ORIG_OBJECT_ID(), this.TASK_GROUP(), this.IRON(), this.ORBIT_REGIME(), this.TARGET_SIZE(), this.RCS_MIN(), this.RCS(), this.RCS_MAX(), this.FREQ_MIN(), this.FREQ(), this.FREQ_MAX(), this.POLARIZATION(), this.VIS_MAG_MIN(), this.VIS_MAG(), this.VIS_MAG_MAX(), this.SPECTRAL_MODEL(), this.REFLECTANCE(), this.IRRADIANCE(), this.NUM_FRAMES(), this.FRAME_RATE(), this.INTEGRATION_TIME(), this.NUM_TRACKS(), this.NUM_OBS(), this.DURATION(), this.SRCH_PATTERN(), this.SCENARIO(), this.ID_ELSET(), this.ID_MANIFOLD(), this.ID_STATE_VECTOR(), this.ES_ID(), this.EPOCH(), this.SEMI_MAJOR_AXIS(), this.ECCENTRICITY(), this.INCLINATION(), this.RAAN(), this.ARG_OF_PERIGEE(), this.MEAN_ANOMALY(), this.RA(), this.DEC(), this.AZ(), this.EL(), this.RANGE(), this.EXTENT_AZ(), this.EXTENT_EL(), this.EXTENT_RANGE(), this.LAT(), this.LON(), this.ALT(), this.STOP_LAT(), this.STOP_LON(), this.STOP_ALT(), this.SRCH_INC(), this.X_ANGLE(), this.Y_ANGLE(), this.ORIENT_ANGLE(), this.CUSTOMER(), this.NOTES(), this.SOURCE(), this.ORIGIN(), this.DATA_MODE());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.CLASSIFICATION = this.CLASSIFICATION();
        _o.TYPE = this.TYPE();
        _o.ID_PLAN = this.ID_PLAN();
        _o.PLAN_INDEX = this.PLAN_INDEX();
        _o.TASK_ID = this.TASK_ID();
        _o.DWELL_ID = this.DWELL_ID();
        _o.EXTERNAL_ID = this.EXTERNAL_ID();
        _o.ID_SENSOR = this.ID_SENSOR();
        _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
        _o.OB_TYPE = this.OB_TYPE();
        _o.PRIORITY = this.PRIORITY();
        _o.TASK_CATEGORY = this.TASK_CATEGORY();
        _o.SUFFIX = this.SUFFIX();
        _o.UCT_FOLLOW_UP = this.UCT_FOLLOW_UP();
        _o.START_TIME = this.START_TIME();
        _o.END_TIME = this.END_TIME();
        _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
        _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
        _o.TASK_GROUP = this.TASK_GROUP();
        _o.IRON = this.IRON();
        _o.ORBIT_REGIME = this.ORBIT_REGIME();
        _o.TARGET_SIZE = this.TARGET_SIZE();
        _o.RCS_MIN = this.RCS_MIN();
        _o.RCS = this.RCS();
        _o.RCS_MAX = this.RCS_MAX();
        _o.FREQ_MIN = this.FREQ_MIN();
        _o.FREQ = this.FREQ();
        _o.FREQ_MAX = this.FREQ_MAX();
        _o.POLARIZATION = this.POLARIZATION();
        _o.VIS_MAG_MIN = this.VIS_MAG_MIN();
        _o.VIS_MAG = this.VIS_MAG();
        _o.VIS_MAG_MAX = this.VIS_MAG_MAX();
        _o.SPECTRAL_MODEL = this.SPECTRAL_MODEL();
        _o.REFLECTANCE = this.REFLECTANCE();
        _o.IRRADIANCE = this.IRRADIANCE();
        _o.NUM_FRAMES = this.NUM_FRAMES();
        _o.FRAME_RATE = this.FRAME_RATE();
        _o.INTEGRATION_TIME = this.INTEGRATION_TIME();
        _o.NUM_TRACKS = this.NUM_TRACKS();
        _o.NUM_OBS = this.NUM_OBS();
        _o.DURATION = this.DURATION();
        _o.SRCH_PATTERN = this.SRCH_PATTERN();
        _o.SCENARIO = this.SCENARIO();
        _o.ID_ELSET = this.ID_ELSET();
        _o.ID_MANIFOLD = this.ID_MANIFOLD();
        _o.ID_STATE_VECTOR = this.ID_STATE_VECTOR();
        _o.ES_ID = this.ES_ID();
        _o.EPOCH = this.EPOCH();
        _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
        _o.ECCENTRICITY = this.ECCENTRICITY();
        _o.INCLINATION = this.INCLINATION();
        _o.RAAN = this.RAAN();
        _o.ARG_OF_PERIGEE = this.ARG_OF_PERIGEE();
        _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
        _o.RA = this.RA();
        _o.DEC = this.DEC();
        _o.AZ = this.AZ();
        _o.EL = this.EL();
        _o.RANGE = this.RANGE();
        _o.EXTENT_AZ = this.EXTENT_AZ();
        _o.EXTENT_EL = this.EXTENT_EL();
        _o.EXTENT_RANGE = this.EXTENT_RANGE();
        _o.LAT = this.LAT();
        _o.LON = this.LON();
        _o.ALT = this.ALT();
        _o.STOP_LAT = this.STOP_LAT();
        _o.STOP_LON = this.STOP_LON();
        _o.STOP_ALT = this.STOP_ALT();
        _o.SRCH_INC = this.SRCH_INC();
        _o.X_ANGLE = this.X_ANGLE();
        _o.Y_ANGLE = this.Y_ANGLE();
        _o.ORIENT_ANGLE = this.ORIENT_ANGLE();
        _o.CUSTOMER = this.CUSTOMER();
        _o.NOTES = this.NOTES();
        _o.SOURCE = this.SOURCE();
        _o.ORIGIN = this.ORIGIN();
        _o.DATA_MODE = this.DATA_MODE();
    }
}
export class CRMT {
    constructor(ID = null, CLASSIFICATION = null, TYPE = null, ID_PLAN = null, PLAN_INDEX = 0, TASK_ID = null, DWELL_ID = null, EXTERNAL_ID = null, ID_SENSOR = null, ORIG_SENSOR_ID = null, OB_TYPE = null, PRIORITY = null, TASK_CATEGORY = 0, SUFFIX = null, UCT_FOLLOW_UP = false, START_TIME = null, END_TIME = null, NORAD_CAT_ID = 0, ORIG_OBJECT_ID = null, TASK_GROUP = null, IRON = 0, ORBIT_REGIME = null, TARGET_SIZE = 0.0, RCS_MIN = 0.0, RCS = 0.0, RCS_MAX = 0.0, FREQ_MIN = 0.0, FREQ = 0.0, FREQ_MAX = 0.0, POLARIZATION = null, VIS_MAG_MIN = 0.0, VIS_MAG = 0.0, VIS_MAG_MAX = 0.0, SPECTRAL_MODEL = null, REFLECTANCE = 0.0, IRRADIANCE = 0.0, NUM_FRAMES = 0, FRAME_RATE = 0.0, INTEGRATION_TIME = 0.0, NUM_TRACKS = 0, NUM_OBS = 0, DURATION = 0, SRCH_PATTERN = null, SCENARIO = null, ID_ELSET = null, ID_MANIFOLD = null, ID_STATE_VECTOR = null, ES_ID = null, EPOCH = null, SEMI_MAJOR_AXIS = 0.0, ECCENTRICITY = 0.0, INCLINATION = 0.0, RAAN = 0.0, ARG_OF_PERIGEE = 0.0, MEAN_ANOMALY = 0.0, RA = 0.0, DEC = 0.0, AZ = 0.0, EL = 0.0, RANGE = 0.0, EXTENT_AZ = 0.0, EXTENT_EL = 0.0, EXTENT_RANGE = 0.0, LAT = 0.0, LON = 0.0, ALT = 0.0, STOP_LAT = 0.0, STOP_LON = 0.0, STOP_ALT = 0.0, SRCH_INC = 0.0, X_ANGLE = 0.0, Y_ANGLE = 0.0, ORIENT_ANGLE = 0.0, CUSTOMER = null, NOTES = null, SOURCE = null, ORIGIN = null, DATA_MODE = null) {
        this.ID = ID;
        this.CLASSIFICATION = CLASSIFICATION;
        this.TYPE = TYPE;
        this.ID_PLAN = ID_PLAN;
        this.PLAN_INDEX = PLAN_INDEX;
        this.TASK_ID = TASK_ID;
        this.DWELL_ID = DWELL_ID;
        this.EXTERNAL_ID = EXTERNAL_ID;
        this.ID_SENSOR = ID_SENSOR;
        this.ORIG_SENSOR_ID = ORIG_SENSOR_ID;
        this.OB_TYPE = OB_TYPE;
        this.PRIORITY = PRIORITY;
        this.TASK_CATEGORY = TASK_CATEGORY;
        this.SUFFIX = SUFFIX;
        this.UCT_FOLLOW_UP = UCT_FOLLOW_UP;
        this.START_TIME = START_TIME;
        this.END_TIME = END_TIME;
        this.NORAD_CAT_ID = NORAD_CAT_ID;
        this.ORIG_OBJECT_ID = ORIG_OBJECT_ID;
        this.TASK_GROUP = TASK_GROUP;
        this.IRON = IRON;
        this.ORBIT_REGIME = ORBIT_REGIME;
        this.TARGET_SIZE = TARGET_SIZE;
        this.RCS_MIN = RCS_MIN;
        this.RCS = RCS;
        this.RCS_MAX = RCS_MAX;
        this.FREQ_MIN = FREQ_MIN;
        this.FREQ = FREQ;
        this.FREQ_MAX = FREQ_MAX;
        this.POLARIZATION = POLARIZATION;
        this.VIS_MAG_MIN = VIS_MAG_MIN;
        this.VIS_MAG = VIS_MAG;
        this.VIS_MAG_MAX = VIS_MAG_MAX;
        this.SPECTRAL_MODEL = SPECTRAL_MODEL;
        this.REFLECTANCE = REFLECTANCE;
        this.IRRADIANCE = IRRADIANCE;
        this.NUM_FRAMES = NUM_FRAMES;
        this.FRAME_RATE = FRAME_RATE;
        this.INTEGRATION_TIME = INTEGRATION_TIME;
        this.NUM_TRACKS = NUM_TRACKS;
        this.NUM_OBS = NUM_OBS;
        this.DURATION = DURATION;
        this.SRCH_PATTERN = SRCH_PATTERN;
        this.SCENARIO = SCENARIO;
        this.ID_ELSET = ID_ELSET;
        this.ID_MANIFOLD = ID_MANIFOLD;
        this.ID_STATE_VECTOR = ID_STATE_VECTOR;
        this.ES_ID = ES_ID;
        this.EPOCH = EPOCH;
        this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
        this.ECCENTRICITY = ECCENTRICITY;
        this.INCLINATION = INCLINATION;
        this.RAAN = RAAN;
        this.ARG_OF_PERIGEE = ARG_OF_PERIGEE;
        this.MEAN_ANOMALY = MEAN_ANOMALY;
        this.RA = RA;
        this.DEC = DEC;
        this.AZ = AZ;
        this.EL = EL;
        this.RANGE = RANGE;
        this.EXTENT_AZ = EXTENT_AZ;
        this.EXTENT_EL = EXTENT_EL;
        this.EXTENT_RANGE = EXTENT_RANGE;
        this.LAT = LAT;
        this.LON = LON;
        this.ALT = ALT;
        this.STOP_LAT = STOP_LAT;
        this.STOP_LON = STOP_LON;
        this.STOP_ALT = STOP_ALT;
        this.SRCH_INC = SRCH_INC;
        this.X_ANGLE = X_ANGLE;
        this.Y_ANGLE = Y_ANGLE;
        this.ORIENT_ANGLE = ORIENT_ANGLE;
        this.CUSTOMER = CUSTOMER;
        this.NOTES = NOTES;
        this.SOURCE = SOURCE;
        this.ORIGIN = ORIGIN;
        this.DATA_MODE = DATA_MODE;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION) : 0);
        const TYPE = (this.TYPE !== null ? builder.createString(this.TYPE) : 0);
        const ID_PLAN = (this.ID_PLAN !== null ? builder.createString(this.ID_PLAN) : 0);
        const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID) : 0);
        const DWELL_ID = (this.DWELL_ID !== null ? builder.createString(this.DWELL_ID) : 0);
        const EXTERNAL_ID = (this.EXTERNAL_ID !== null ? builder.createString(this.EXTERNAL_ID) : 0);
        const ID_SENSOR = (this.ID_SENSOR !== null ? builder.createString(this.ID_SENSOR) : 0);
        const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID) : 0);
        const OB_TYPE = (this.OB_TYPE !== null ? builder.createString(this.OB_TYPE) : 0);
        const PRIORITY = (this.PRIORITY !== null ? builder.createString(this.PRIORITY) : 0);
        const SUFFIX = (this.SUFFIX !== null ? builder.createString(this.SUFFIX) : 0);
        const START_TIME = (this.START_TIME !== null ? builder.createString(this.START_TIME) : 0);
        const END_TIME = (this.END_TIME !== null ? builder.createString(this.END_TIME) : 0);
        const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID) : 0);
        const TASK_GROUP = (this.TASK_GROUP !== null ? builder.createString(this.TASK_GROUP) : 0);
        const ORBIT_REGIME = (this.ORBIT_REGIME !== null ? builder.createString(this.ORBIT_REGIME) : 0);
        const POLARIZATION = (this.POLARIZATION !== null ? builder.createString(this.POLARIZATION) : 0);
        const SPECTRAL_MODEL = (this.SPECTRAL_MODEL !== null ? builder.createString(this.SPECTRAL_MODEL) : 0);
        const SRCH_PATTERN = (this.SRCH_PATTERN !== null ? builder.createString(this.SRCH_PATTERN) : 0);
        const SCENARIO = (this.SCENARIO !== null ? builder.createString(this.SCENARIO) : 0);
        const ID_ELSET = (this.ID_ELSET !== null ? builder.createString(this.ID_ELSET) : 0);
        const ID_MANIFOLD = (this.ID_MANIFOLD !== null ? builder.createString(this.ID_MANIFOLD) : 0);
        const ID_STATE_VECTOR = (this.ID_STATE_VECTOR !== null ? builder.createString(this.ID_STATE_VECTOR) : 0);
        const ES_ID = (this.ES_ID !== null ? builder.createString(this.ES_ID) : 0);
        const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH) : 0);
        const CUSTOMER = (this.CUSTOMER !== null ? builder.createString(this.CUSTOMER) : 0);
        const NOTES = (this.NOTES !== null ? builder.createString(this.NOTES) : 0);
        const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE) : 0);
        const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN) : 0);
        const DATA_MODE = (this.DATA_MODE !== null ? builder.createString(this.DATA_MODE) : 0);
        return CRM.createCRM(builder, ID, CLASSIFICATION, TYPE, ID_PLAN, this.PLAN_INDEX, TASK_ID, DWELL_ID, EXTERNAL_ID, ID_SENSOR, ORIG_SENSOR_ID, OB_TYPE, PRIORITY, this.TASK_CATEGORY, SUFFIX, this.UCT_FOLLOW_UP, START_TIME, END_TIME, this.NORAD_CAT_ID, ORIG_OBJECT_ID, TASK_GROUP, this.IRON, ORBIT_REGIME, this.TARGET_SIZE, this.RCS_MIN, this.RCS, this.RCS_MAX, this.FREQ_MIN, this.FREQ, this.FREQ_MAX, POLARIZATION, this.VIS_MAG_MIN, this.VIS_MAG, this.VIS_MAG_MAX, SPECTRAL_MODEL, this.REFLECTANCE, this.IRRADIANCE, this.NUM_FRAMES, this.FRAME_RATE, this.INTEGRATION_TIME, this.NUM_TRACKS, this.NUM_OBS, this.DURATION, SRCH_PATTERN, SCENARIO, ID_ELSET, ID_MANIFOLD, ID_STATE_VECTOR, ES_ID, EPOCH, this.SEMI_MAJOR_AXIS, this.ECCENTRICITY, this.INCLINATION, this.RAAN, this.ARG_OF_PERIGEE, this.MEAN_ANOMALY, this.RA, this.DEC, this.AZ, this.EL, this.RANGE, this.EXTENT_AZ, this.EXTENT_EL, this.EXTENT_RANGE, this.LAT, this.LON, this.ALT, this.STOP_LAT, this.STOP_LON, this.STOP_ALT, this.SRCH_INC, this.X_ANGLE, this.Y_ANGLE, this.ORIENT_ANGLE, CUSTOMER, NOTES, SOURCE, ORIGIN, DATA_MODE);
    }
}
