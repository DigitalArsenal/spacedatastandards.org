// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Sensor contribution to an orbit determination solution
 */
export class odSensorContribution {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsodSensorContribution(bb, obj) {
        return (obj || new odSensorContribution()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsodSensorContribution(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new odSensorContribution()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Number of accepted observations from this sensor
     */
    NUM_ACCEPTED() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of rejected observations from this sensor
     */
    NUM_REJECTED() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * Weighted RMS for this sensor's observations
     */
    WRMS() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    OB_TYPES(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    obTypesLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startodSensorContribution(builder) {
        builder.startObject(6);
    }
    static addSensorId(builder, SENSOR_IDOffset) {
        builder.addFieldOffset(0, SENSOR_IDOffset, 0);
    }
    static addOrigSensorId(builder, ORIG_SENSOR_IDOffset) {
        builder.addFieldOffset(1, ORIG_SENSOR_IDOffset, 0);
    }
    static addNumAccepted(builder, NUM_ACCEPTED) {
        builder.addFieldInt32(2, NUM_ACCEPTED, 0);
    }
    static addNumRejected(builder, NUM_REJECTED) {
        builder.addFieldInt32(3, NUM_REJECTED, 0);
    }
    static addWrms(builder, WRMS) {
        builder.addFieldFloat64(4, WRMS, 0.0);
    }
    static addObTypes(builder, OB_TYPESOffset) {
        builder.addFieldOffset(5, OB_TYPESOffset, 0);
    }
    static createObTypesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startObTypesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endodSensorContribution(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createodSensorContribution(builder, SENSOR_IDOffset, ORIG_SENSOR_IDOffset, NUM_ACCEPTED, NUM_REJECTED, WRMS, OB_TYPESOffset) {
        odSensorContribution.startodSensorContribution(builder);
        odSensorContribution.addSensorId(builder, SENSOR_IDOffset);
        odSensorContribution.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
        odSensorContribution.addNumAccepted(builder, NUM_ACCEPTED);
        odSensorContribution.addNumRejected(builder, NUM_REJECTED);
        odSensorContribution.addWrms(builder, WRMS);
        odSensorContribution.addObTypes(builder, OB_TYPESOffset);
        return odSensorContribution.endodSensorContribution(builder);
    }
    unpack() {
        return new odSensorContributionT(this.SENSOR_ID(), this.ORIG_SENSOR_ID(), this.NUM_ACCEPTED(), this.NUM_REJECTED(), this.WRMS(), this.bb.createScalarList(this.OB_TYPES.bind(this), this.obTypesLength()));
    }
    unpackTo(_o) {
        _o.SENSOR_ID = this.SENSOR_ID();
        _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
        _o.NUM_ACCEPTED = this.NUM_ACCEPTED();
        _o.NUM_REJECTED = this.NUM_REJECTED();
        _o.WRMS = this.WRMS();
        _o.OB_TYPES = this.bb.createScalarList(this.OB_TYPES.bind(this), this.obTypesLength());
    }
}
export class odSensorContributionT {
    constructor(SENSOR_ID = null, ORIG_SENSOR_ID = null, NUM_ACCEPTED = 0, NUM_REJECTED = 0, WRMS = 0.0, OB_TYPES = []) {
        this.SENSOR_ID = SENSOR_ID;
        this.ORIG_SENSOR_ID = ORIG_SENSOR_ID;
        this.NUM_ACCEPTED = NUM_ACCEPTED;
        this.NUM_REJECTED = NUM_REJECTED;
        this.WRMS = WRMS;
        this.OB_TYPES = OB_TYPES;
    }
    pack(builder) {
        const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID) : 0);
        const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID) : 0);
        const OB_TYPES = odSensorContribution.createObTypesVector(builder, builder.createObjectOffsetList(this.OB_TYPES));
        return odSensorContribution.createodSensorContribution(builder, SENSOR_ID, ORIG_SENSOR_ID, this.NUM_ACCEPTED, this.NUM_REJECTED, this.WRMS, OB_TYPES);
    }
}
