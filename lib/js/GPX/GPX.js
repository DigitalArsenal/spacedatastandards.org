// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { GPXLink } from './GPXLink.js';
import { GPXRoute } from './GPXRoute.js';
import { GPXTrack } from './GPXTrack.js';
import { GPXWaypoint } from './GPXWaypoint.js';
/**
 * GPX Document
 */
export class GPX {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsGPX(bb, obj) {
        return (obj || new GPX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsGPX(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new GPX()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$GPX');
    }
    VERSION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CREATOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    DESCRIPTION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    AUTHOR_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    AUTHOR_EMAIL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Author link
     */
    AUTHOR_LINK(obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new GPXLink()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    COPYRIGHT_AUTHOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    COPYRIGHT_YEAR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    COPYRIGHT_LICENSE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Links to additional information
     */
    LINKS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? (obj || new GPXLink()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    linksLength() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    KEYWORDS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Minimum latitude of bounding box
     */
    BOUNDS_MIN_LAT() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Minimum longitude of bounding box
     */
    BOUNDS_MIN_LON() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Maximum latitude of bounding box
     */
    BOUNDS_MAX_LAT() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Maximum longitude of bounding box
     */
    BOUNDS_MAX_LON() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Waypoints
     */
    WAYPOINTS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? (obj || new GPXWaypoint()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    waypointsLength() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Routes
     */
    ROUTES(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? (obj || new GPXRoute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    routesLength() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Tracks
     */
    TRACKS(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? (obj || new GPXTrack()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    tracksLength() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startGPX(builder) {
        builder.startObject(20);
    }
    static addVersion(builder, VERSIONOffset) {
        builder.addFieldOffset(0, VERSIONOffset, 0);
    }
    static addCreator(builder, CREATOROffset) {
        builder.addFieldOffset(1, CREATOROffset, 0);
    }
    static addName(builder, NAMEOffset) {
        builder.addFieldOffset(2, NAMEOffset, 0);
    }
    static addDescription(builder, DESCRIPTIONOffset) {
        builder.addFieldOffset(3, DESCRIPTIONOffset, 0);
    }
    static addAuthorName(builder, AUTHOR_NAMEOffset) {
        builder.addFieldOffset(4, AUTHOR_NAMEOffset, 0);
    }
    static addAuthorEmail(builder, AUTHOR_EMAILOffset) {
        builder.addFieldOffset(5, AUTHOR_EMAILOffset, 0);
    }
    static addAuthorLink(builder, AUTHOR_LINKOffset) {
        builder.addFieldOffset(6, AUTHOR_LINKOffset, 0);
    }
    static addCopyrightAuthor(builder, COPYRIGHT_AUTHOROffset) {
        builder.addFieldOffset(7, COPYRIGHT_AUTHOROffset, 0);
    }
    static addCopyrightYear(builder, COPYRIGHT_YEAROffset) {
        builder.addFieldOffset(8, COPYRIGHT_YEAROffset, 0);
    }
    static addCopyrightLicense(builder, COPYRIGHT_LICENSEOffset) {
        builder.addFieldOffset(9, COPYRIGHT_LICENSEOffset, 0);
    }
    static addLinks(builder, LINKSOffset) {
        builder.addFieldOffset(10, LINKSOffset, 0);
    }
    static createLinksVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startLinksVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTime(builder, TIMEOffset) {
        builder.addFieldOffset(11, TIMEOffset, 0);
    }
    static addKeywords(builder, KEYWORDSOffset) {
        builder.addFieldOffset(12, KEYWORDSOffset, 0);
    }
    static addBoundsMinLat(builder, BOUNDS_MIN_LAT) {
        builder.addFieldFloat64(13, BOUNDS_MIN_LAT, 0.0);
    }
    static addBoundsMinLon(builder, BOUNDS_MIN_LON) {
        builder.addFieldFloat64(14, BOUNDS_MIN_LON, 0.0);
    }
    static addBoundsMaxLat(builder, BOUNDS_MAX_LAT) {
        builder.addFieldFloat64(15, BOUNDS_MAX_LAT, 0.0);
    }
    static addBoundsMaxLon(builder, BOUNDS_MAX_LON) {
        builder.addFieldFloat64(16, BOUNDS_MAX_LON, 0.0);
    }
    static addWaypoints(builder, WAYPOINTSOffset) {
        builder.addFieldOffset(17, WAYPOINTSOffset, 0);
    }
    static createWaypointsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startWaypointsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addRoutes(builder, ROUTESOffset) {
        builder.addFieldOffset(18, ROUTESOffset, 0);
    }
    static createRoutesVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startRoutesVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addTracks(builder, TRACKSOffset) {
        builder.addFieldOffset(19, TRACKSOffset, 0);
    }
    static createTracksVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startTracksVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static endGPX(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishGPXBuffer(builder, offset) {
        builder.finish(offset, '$GPX');
    }
    static finishSizePrefixedGPXBuffer(builder, offset) {
        builder.finish(offset, '$GPX', true);
    }
    unpack() {
        return new GPXT(this.VERSION(), this.CREATOR(), this.NAME(), this.DESCRIPTION(), this.AUTHOR_NAME(), this.AUTHOR_EMAIL(), (this.AUTHOR_LINK() !== null ? this.AUTHOR_LINK().unpack() : null), this.COPYRIGHT_AUTHOR(), this.COPYRIGHT_YEAR(), this.COPYRIGHT_LICENSE(), this.bb.createObjList(this.LINKS.bind(this), this.linksLength()), this.TIME(), this.KEYWORDS(), this.BOUNDS_MIN_LAT(), this.BOUNDS_MIN_LON(), this.BOUNDS_MAX_LAT(), this.BOUNDS_MAX_LON(), this.bb.createObjList(this.WAYPOINTS.bind(this), this.waypointsLength()), this.bb.createObjList(this.ROUTES.bind(this), this.routesLength()), this.bb.createObjList(this.TRACKS.bind(this), this.tracksLength()));
    }
    unpackTo(_o) {
        _o.VERSION = this.VERSION();
        _o.CREATOR = this.CREATOR();
        _o.NAME = this.NAME();
        _o.DESCRIPTION = this.DESCRIPTION();
        _o.AUTHOR_NAME = this.AUTHOR_NAME();
        _o.AUTHOR_EMAIL = this.AUTHOR_EMAIL();
        _o.AUTHOR_LINK = (this.AUTHOR_LINK() !== null ? this.AUTHOR_LINK().unpack() : null);
        _o.COPYRIGHT_AUTHOR = this.COPYRIGHT_AUTHOR();
        _o.COPYRIGHT_YEAR = this.COPYRIGHT_YEAR();
        _o.COPYRIGHT_LICENSE = this.COPYRIGHT_LICENSE();
        _o.LINKS = this.bb.createObjList(this.LINKS.bind(this), this.linksLength());
        _o.TIME = this.TIME();
        _o.KEYWORDS = this.KEYWORDS();
        _o.BOUNDS_MIN_LAT = this.BOUNDS_MIN_LAT();
        _o.BOUNDS_MIN_LON = this.BOUNDS_MIN_LON();
        _o.BOUNDS_MAX_LAT = this.BOUNDS_MAX_LAT();
        _o.BOUNDS_MAX_LON = this.BOUNDS_MAX_LON();
        _o.WAYPOINTS = this.bb.createObjList(this.WAYPOINTS.bind(this), this.waypointsLength());
        _o.ROUTES = this.bb.createObjList(this.ROUTES.bind(this), this.routesLength());
        _o.TRACKS = this.bb.createObjList(this.TRACKS.bind(this), this.tracksLength());
    }
}
export class GPXT {
    constructor(VERSION = null, CREATOR = null, NAME = null, DESCRIPTION = null, AUTHOR_NAME = null, AUTHOR_EMAIL = null, AUTHOR_LINK = null, COPYRIGHT_AUTHOR = null, COPYRIGHT_YEAR = null, COPYRIGHT_LICENSE = null, LINKS = [], TIME = null, KEYWORDS = null, BOUNDS_MIN_LAT = 0.0, BOUNDS_MIN_LON = 0.0, BOUNDS_MAX_LAT = 0.0, BOUNDS_MAX_LON = 0.0, WAYPOINTS = [], ROUTES = [], TRACKS = []) {
        this.VERSION = VERSION;
        this.CREATOR = CREATOR;
        this.NAME = NAME;
        this.DESCRIPTION = DESCRIPTION;
        this.AUTHOR_NAME = AUTHOR_NAME;
        this.AUTHOR_EMAIL = AUTHOR_EMAIL;
        this.AUTHOR_LINK = AUTHOR_LINK;
        this.COPYRIGHT_AUTHOR = COPYRIGHT_AUTHOR;
        this.COPYRIGHT_YEAR = COPYRIGHT_YEAR;
        this.COPYRIGHT_LICENSE = COPYRIGHT_LICENSE;
        this.LINKS = LINKS;
        this.TIME = TIME;
        this.KEYWORDS = KEYWORDS;
        this.BOUNDS_MIN_LAT = BOUNDS_MIN_LAT;
        this.BOUNDS_MIN_LON = BOUNDS_MIN_LON;
        this.BOUNDS_MAX_LAT = BOUNDS_MAX_LAT;
        this.BOUNDS_MAX_LON = BOUNDS_MAX_LON;
        this.WAYPOINTS = WAYPOINTS;
        this.ROUTES = ROUTES;
        this.TRACKS = TRACKS;
    }
    pack(builder) {
        const VERSION = (this.VERSION !== null ? builder.createString(this.VERSION) : 0);
        const CREATOR = (this.CREATOR !== null ? builder.createString(this.CREATOR) : 0);
        const NAME = (this.NAME !== null ? builder.createString(this.NAME) : 0);
        const DESCRIPTION = (this.DESCRIPTION !== null ? builder.createString(this.DESCRIPTION) : 0);
        const AUTHOR_NAME = (this.AUTHOR_NAME !== null ? builder.createString(this.AUTHOR_NAME) : 0);
        const AUTHOR_EMAIL = (this.AUTHOR_EMAIL !== null ? builder.createString(this.AUTHOR_EMAIL) : 0);
        const AUTHOR_LINK = (this.AUTHOR_LINK !== null ? this.AUTHOR_LINK.pack(builder) : 0);
        const COPYRIGHT_AUTHOR = (this.COPYRIGHT_AUTHOR !== null ? builder.createString(this.COPYRIGHT_AUTHOR) : 0);
        const COPYRIGHT_YEAR = (this.COPYRIGHT_YEAR !== null ? builder.createString(this.COPYRIGHT_YEAR) : 0);
        const COPYRIGHT_LICENSE = (this.COPYRIGHT_LICENSE !== null ? builder.createString(this.COPYRIGHT_LICENSE) : 0);
        const LINKS = GPX.createLinksVector(builder, builder.createObjectOffsetList(this.LINKS));
        const TIME = (this.TIME !== null ? builder.createString(this.TIME) : 0);
        const KEYWORDS = (this.KEYWORDS !== null ? builder.createString(this.KEYWORDS) : 0);
        const WAYPOINTS = GPX.createWaypointsVector(builder, builder.createObjectOffsetList(this.WAYPOINTS));
        const ROUTES = GPX.createRoutesVector(builder, builder.createObjectOffsetList(this.ROUTES));
        const TRACKS = GPX.createTracksVector(builder, builder.createObjectOffsetList(this.TRACKS));
        GPX.startGPX(builder);
        GPX.addVersion(builder, VERSION);
        GPX.addCreator(builder, CREATOR);
        GPX.addName(builder, NAME);
        GPX.addDescription(builder, DESCRIPTION);
        GPX.addAuthorName(builder, AUTHOR_NAME);
        GPX.addAuthorEmail(builder, AUTHOR_EMAIL);
        GPX.addAuthorLink(builder, AUTHOR_LINK);
        GPX.addCopyrightAuthor(builder, COPYRIGHT_AUTHOR);
        GPX.addCopyrightYear(builder, COPYRIGHT_YEAR);
        GPX.addCopyrightLicense(builder, COPYRIGHT_LICENSE);
        GPX.addLinks(builder, LINKS);
        GPX.addTime(builder, TIME);
        GPX.addKeywords(builder, KEYWORDS);
        GPX.addBoundsMinLat(builder, this.BOUNDS_MIN_LAT);
        GPX.addBoundsMinLon(builder, this.BOUNDS_MIN_LON);
        GPX.addBoundsMaxLat(builder, this.BOUNDS_MAX_LAT);
        GPX.addBoundsMaxLon(builder, this.BOUNDS_MAX_LON);
        GPX.addWaypoints(builder, WAYPOINTS);
        GPX.addRoutes(builder, ROUTES);
        GPX.addTracks(builder, TRACKS);
        return GPX.endGPX(builder);
    }
}
