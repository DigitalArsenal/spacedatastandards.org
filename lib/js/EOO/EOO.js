// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { CollectMethod } from './CollectMethod.js';
import { DataMode } from './DataMode.js';
import { DeviceType } from './DeviceType.js';
import { ObservationPosition } from './ObservationPosition.js';
import { refFrame } from './refFrame.js';
/**
 * Electro-Optical Observation
 */
export class EOO {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEOO(bb, obj) {
        return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$EOO');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CLASSIFICATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    OB_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Correlation score of the observation when compared to a known orbit state.
     */
    CORR_QUALITY() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ID_ON_ORBIT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Accepted Collection Method
     */
    COLLECT_METHOD() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : CollectMethod.SIDEREAL;
    }
    /**
     * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
     */
    NORAD_CAT_ID() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    TASK_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TRANSACTION_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    IMAGE_SET_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The number of images in an image set.
     */
    IMAGE_SET_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The sequence ID of an image within an image set.
     */
    SEQUENCE_ID() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
     */
    OB_POSITION() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : ObservationPosition.FENCE;
    }
    ORIG_OBJECT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Required if correlation is attempted. Indicates whether correlation succeeded.
     */
    UCT() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Line of sight azimuth angle in degrees and topocentric frame.
     */
    AZIMUTH() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight azimuth angle, in degrees.
     */
    AZIMUTH_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight azimuth angle bias in degrees.
     */
    AZIMUTH_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Rate of change of the line of sight azimuth in degrees per second.
     */
    AZIMUTH_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight elevation in degrees and topocentric frame.
     */
    ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight elevation angle, in degrees.
     */
    ELEVATION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight elevation bias in degrees.
     */
    ELEVATION_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Rate of change of the line of sight elevation in degrees per second.
     */
    ELEVATION_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight range in km. Reported value should include all applicable corrections.
     */
    RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight range, in km.
     */
    RANGE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight range bias in km.
     */
    RANGE_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Range rate in km/s. Reported value should include all applicable corrections.
     */
    RANGE_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight range rate, in km/sec.
     */
    RANGE_RATE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension in degrees. Required metric reporting field for EO observations.
     */
    RA() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight right ascension rate of change, in degrees/sec.
     */
    RA_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight right ascension angle, in degrees.
     */
    RA_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 68);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight right ascension bias in degrees.
     */
    RA_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Declination in degrees. Required metric reporting field for EO observations.
     */
    DECLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 72);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight declination rate of change, in degrees/sec.
     */
    DECLINATION_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 74);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight declination angle, in degrees.
     */
    DECLINATION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 76);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight declination angle bias in degrees.
     */
    DECLINATION_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 78);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSX() {
        const offset = this.bb.__offset(this.bb_pos, 80);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSY() {
        const offset = this.bb.__offset(this.bb_pos, 82);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSZ() {
        const offset = this.bb.__offset(this.bb_pos, 84);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line-of-sight direction vector components.
     */
    LOS_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 86);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * X-component of the velocity vector along the line of sight, in km/s.
     */
    LOSXVEL() {
        const offset = this.bb.__offset(this.bb_pos, 88);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Y-component of the velocity vector along the line of sight, in km/s.
     */
    LOSYVEL() {
        const offset = this.bb.__offset(this.bb_pos, 90);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Z-component of the velocity vector along the line of sight, in km/s.
     */
    LOSZVEL() {
        const offset = this.bb.__offset(this.bb_pos, 92);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 latitude in decimal degrees at the time of the observation.
     */
    SENLAT() {
        const offset = this.bb.__offset(this.bb_pos, 94);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 longitude in decimal degrees at the time of the observation.
     */
    SENLON() {
        const offset = this.bb.__offset(this.bb_pos, 96);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
     */
    SENALT() {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian X position in km at the time of the observation.
     */
    SENX() {
        const offset = this.bb.__offset(this.bb_pos, 100);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian Y position in km at the time of the observation.
     */
    SENY() {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian Z position in km at the time of the observation.
     */
    SENZ() {
        const offset = this.bb.__offset(this.bb_pos, 104);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Total number of satellites in the field of view.
     */
    FOV_COUNT() {
        const offset = this.bb.__offset(this.bb_pos, 106);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of uncorrelated satellites in the field of view (JCO).
     */
    FOV_COUNT_UCTS() {
        const offset = this.bb.__offset(this.bb_pos, 108);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods,
     * the exposure duration should be the total integration time. This field is highly recommended / required if the
     * observations are going to be used for photometric processing.
     */
    EXP_DURATION() {
        const offset = this.bb.__offset(this.bb_pos, 110);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
     */
    ZEROPTD() {
        const offset = this.bb.__offset(this.bb_pos, 112);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Net object signature = counts / EXP_DURATION.
     */
    NET_OBJ_SIG() {
        const offset = this.bb.__offset(this.bb_pos, 114);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
     */
    NET_OBJ_SIG_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 116);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Measure of observed brightness calibrated against the Gaia G-band.
     */
    MAG() {
        const offset = this.bb.__offset(this.bb_pos, 118);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Uncertainty of the observed brightness.
     */
    MAG_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 120);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * [Definition needed].
     */
    MAG_NORM_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 122);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range
     * and corresponding viewing geometry. It must NOT be computed from the orbit state.
     */
    GEOLAT() {
        const offset = this.bb.__offset(this.bb_pos, 124);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range
     * and viewing geometry. It must NOT be computed from the orbit state.
     */
    GEOLON() {
        const offset = this.bb.__offset(this.bb_pos, 126);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
     */
    GEOALT() {
        const offset = this.bb.__offset(this.bb_pos, 128);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
     */
    GEORANGE() {
        const offset = this.bb.__offset(this.bb_pos, 130);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently
     * empty part of the night sky.
     */
    SKY_BKGRND() {
        const offset = this.bb.__offset(this.bb_pos, 132);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass
     * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general,
     * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical
     * object and the observer.
     */
    PRIMARY_EXTINCTION() {
        const offset = this.bb.__offset(this.bb_pos, 134);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Primary Extinction Coefficient Uncertainty, in Magnitudes.
     */
    PRIMARY_EXTINCTION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 136);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the
     * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
     */
    SOLAR_PHASE_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 138);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector
     * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition)
     * and positive when opening (after the opposition).
     */
    SOLAR_EQ_PHASE_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 140);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angle from the sun to the equatorial plane.
     */
    SOLAR_DEC_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 142);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Shutter delay in seconds.
     */
    SHUTTER_DELAY() {
        const offset = this.bb.__offset(this.bb_pos, 144);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor timing bias in seconds.
     */
    TIMING_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 146);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RAW_FILE_URI(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 148);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Intensity of the target for IR observations, in kw/sr/em.
     */
    INTENSITY() {
        const offset = this.bb.__offset(this.bb_pos, 150);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Background intensity for IR observations, in kw/sr/um.
     */
    BG_INTENSITY() {
        const offset = this.bb.__offset(this.bb_pos, 152);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    DESCRIPTOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 154);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 156);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIGIN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 158);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
     */
    DATA_MODE() {
        const offset = this.bb.__offset(this.bb_pos, 160);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DataMode.EXERCISE;
    }
    CREATED_AT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 162);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CREATED_BY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 164);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
     */
    REFERENCE_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 166);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : refFrame.ECEF;
    }
    /**
     * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF),
     * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose).
     * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
     */
    SEN_REFERENCE_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 168);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : refFrame.ECEF;
    }
    /**
     * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
     */
    UMBRA() {
        const offset = this.bb.__offset(this.bb_pos, 170);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
     * This field is highly recommended if the observations will be used for photometric processing.
     */
    PENUMBRA() {
        const offset = this.bb.__offset(this.bb_pos, 172);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    ORIG_NETWORK(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 174);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE_DL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 176);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Device Type
     */
    TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 178);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
    }
    /**
     * True if measured, false if computed. Required if azimuth is reported.
     */
    AZIMUTH_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 180);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if elevation is reported.
     */
    ELEVATION_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 182);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if range is reported.
     */
    RANGE_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 184);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if range-rate is reported.
     */
    RANGERATE_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 186);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if right ascension is reported.
     */
    RA_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 188);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if declination is reported.
     */
    DECLINATION_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 190);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * National Imagery Interpretability Rating Scale (NIIRS). Ranging from 0 (lowest) to 9 (highest).
     */
    NIIRS() {
        const offset = this.bb.__offset(this.bb_pos, 192);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Ground sample distance in meters per pixel.
     */
    METERS_PER_PIXEL() {
        const offset = this.bb.__offset(this.bb_pos, 194);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Signal-to-noise ratio of the image. Higher values indicate cleaner imagery.
     */
    IMAGE_SNR() {
        const offset = this.bb.__offset(this.bb_pos, 196);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Bit depth of the image (e.g., 8, 12, 16).
     */
    IMAGE_BIT_DEPTH() {
        const offset = this.bb.__offset(this.bb_pos, 198);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Width of the image in pixels.
     */
    IMAGE_WIDTH() {
        const offset = this.bb.__offset(this.bb_pos, 200);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Height of the image in pixels.
     */
    IMAGE_HEIGHT() {
        const offset = this.bb.__offset(this.bb_pos, 202);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    IMAGE_COMPRESSION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 204);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Compression ratio used (original size / compressed size), if applicable.
     */
    IMAGE_COMPRESSION_RATIO() {
        const offset = this.bb.__offset(this.bb_pos, 206);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    PROCESSED_IMAGE_URI(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 208);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Flag indicating whether the image was auto-enhanced (e.g., contrast stretch, denoise).
     */
    IMAGE_AUTO_ENHANCED() {
        const offset = this.bb.__offset(this.bb_pos, 210);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if the observation was taken with multiple frames stacked into one image.
     */
    MULTI_FRAME_STACKED() {
        const offset = this.bb.__offset(this.bb_pos, 212);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if synthetic tracking was used to create the image.
     */
    SYNTHETIC_TRACKING_USED() {
        const offset = this.bb.__offset(this.bb_pos, 214);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Sharpness metric of the image based on the Tenengrad method or variance of Laplacian. Higher values indicate sharper images.
     */
    IMAGE_SHARPNESS() {
        const offset = this.bb.__offset(this.bb_pos, 216);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Noise level of the image, estimated via pixel intensity variance in background regions.
     */
    IMAGE_NOISE_STDDEV() {
        const offset = this.bb.__offset(this.bb_pos, 218);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Contrast metric of the image, such as Michelson contrast or RMS contrast.
     */
    IMAGE_CONTRAST() {
        const offset = this.bb.__offset(this.bb_pos, 220);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Dynamic range of the image (max pixel value / min pixel value), indicating tonal spread.
     */
    IMAGE_DYNAMIC_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 222);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Entropy of the image, representing the richness of information content. Higher entropy suggests higher texture detail.
     */
    IMAGE_ENTROPY() {
        const offset = this.bb.__offset(this.bb_pos, 224);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Background uniformity metric (e.g., mean gradient in background areas). Lower values indicate more uniform background.
     */
    BACKGROUND_UNIFORMITY() {
        const offset = this.bb.__offset(this.bb_pos, 226);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean background level, computed from non-object regions in pixel units.
     */
    BACKGROUND_MEAN_LEVEL() {
        const offset = this.bb.__offset(this.bb_pos, 228);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Percentage of saturated pixels in the image. Indicates overexposure when high.
     */
    SATURATED_PIXEL_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 230);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Percentage of dead or zero-value pixels in the image. Indicates sensor defects or underexposure.
     */
    DEAD_PIXEL_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 232);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated Point Spread Function (PSF) Full Width at Half Maximum (FWHM) in pixels. Indicates image blur or focus.
     */
    PSF_FWHM() {
        const offset = this.bb.__offset(this.bb_pos, 234);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated percentage of cloud cover in the image. Derived using cloud detection algorithms such as Fmask or machine learning classifiers.
     */
    CLOUD_COVER_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 236);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Confidence score of the cloud detection result, from 0 (low confidence) to 1 (high confidence).
     */
    CLOUD_DETECTION_CONFIDENCE() {
        const offset = this.bb.__offset(this.bb_pos, 238);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated percentage of the image obscured by haze or atmospheric scattering effects.
     */
    HAZE_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 240);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated aerosol optical thickness (AOT) at 550 nm, indicating particulate matter in the atmosphere affecting image clarity.
     */
    AEROSOL_OPTICAL_THICKNESS() {
        const offset = this.bb.__offset(this.bb_pos, 242);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated water vapor content (e.g., total column precipitable water) at the time of imaging, in mm.
     */
    WATER_VAPOR_CONTENT() {
        const offset = this.bb.__offset(this.bb_pos, 244);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sun elevation angle at the time of image capture, in degrees above the horizon.
     */
    SUN_ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 246);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sun azimuth angle at the time of image capture, in degrees from true north.
     */
    SUN_AZIMUTH() {
        const offset = this.bb.__offset(this.bb_pos, 248);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * View zenith angle (sensor line-of-sight angle from nadir), in degrees.
     */
    VIEW_ZENITH_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 250);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * View azimuth angle (direction of sensor relative to north), in degrees.
     */
    VIEW_AZIMUTH_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 252);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Off-nadir angle of the sensor at the time of image capture, in degrees.
     */
    OFF_NADIR_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 254);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Ground coverage width of the image swath in kilometers.
     */
    SWATH_WIDTH_KM() {
        const offset = this.bb.__offset(this.bb_pos, 256);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean terrain elevation in the image footprint, in meters above sea level.
     */
    MEAN_TERRAIN_ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 258);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Standard deviation of terrain elevation in the image footprint, in meters.
     */
    TERRAIN_ELEVATION_STDDEV() {
        const offset = this.bb.__offset(this.bb_pos, 260);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Percentage of the image affected by shadows, derived via topographic or object shadow detection.
     */
    SHADOW_COVER_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 262);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Flag indicating whether sunglint is present in the image (true if high reflectance from water surface due to sun geometry).
     */
    SUNGLINT_PRESENT() {
        const offset = this.bb.__offset(this.bb_pos, 264);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Percentage of image affected by sunglint.
     */
    SUNGLINT_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 266);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Estimated percentage of snow or ice coverage in the image footprint.
     */
    SNOW_ICE_COVER_PERCENT() {
        const offset = this.bb.__offset(this.bb_pos, 268);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Total area covered by valid data (non-masked, usable imagery) in square kilometers.
     */
    VALID_DATA_AREA_KM2() {
        const offset = this.bb.__offset(this.bb_pos, 270);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    static startEOO(builder) {
        builder.startObject(134);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addClassification(builder, CLASSIFICATIONOffset) {
        builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
    }
    static addObTime(builder, OB_TIMEOffset) {
        builder.addFieldOffset(2, OB_TIMEOffset, 0);
    }
    static addCorrQuality(builder, CORR_QUALITY) {
        builder.addFieldFloat32(3, CORR_QUALITY, 0.0);
    }
    static addIdOnOrbit(builder, ID_ON_ORBITOffset) {
        builder.addFieldOffset(4, ID_ON_ORBITOffset, 0);
    }
    static addSensorId(builder, SENSOR_IDOffset) {
        builder.addFieldOffset(5, SENSOR_IDOffset, 0);
    }
    static addCollectMethod(builder, COLLECT_METHOD) {
        builder.addFieldInt8(6, COLLECT_METHOD, CollectMethod.SIDEREAL);
    }
    static addNoradCatId(builder, NORAD_CAT_ID) {
        builder.addFieldInt32(7, NORAD_CAT_ID, 0);
    }
    static addTaskId(builder, TASK_IDOffset) {
        builder.addFieldOffset(8, TASK_IDOffset, 0);
    }
    static addTransactionId(builder, TRANSACTION_IDOffset) {
        builder.addFieldOffset(9, TRANSACTION_IDOffset, 0);
    }
    static addImageSetId(builder, IMAGE_SET_IDOffset) {
        builder.addFieldOffset(10, IMAGE_SET_IDOffset, 0);
    }
    static addImageSetLength(builder, IMAGE_SET_LENGTH) {
        builder.addFieldInt32(11, IMAGE_SET_LENGTH, 0);
    }
    static addSequenceId(builder, SEQUENCE_ID) {
        builder.addFieldInt32(12, SEQUENCE_ID, 0);
    }
    static addObPosition(builder, OB_POSITION) {
        builder.addFieldInt8(13, OB_POSITION, ObservationPosition.FENCE);
    }
    static addOrigObjectId(builder, ORIG_OBJECT_IDOffset) {
        builder.addFieldOffset(14, ORIG_OBJECT_IDOffset, 0);
    }
    static addOrigSensorId(builder, ORIG_SENSOR_IDOffset) {
        builder.addFieldOffset(15, ORIG_SENSOR_IDOffset, 0);
    }
    static addUct(builder, UCT) {
        builder.addFieldInt8(16, +UCT, +false);
    }
    static addAzimuth(builder, AZIMUTH) {
        builder.addFieldFloat32(17, AZIMUTH, 0.0);
    }
    static addAzimuthUnc(builder, AZIMUTH_UNC) {
        builder.addFieldFloat32(18, AZIMUTH_UNC, 0.0);
    }
    static addAzimuthBias(builder, AZIMUTH_BIAS) {
        builder.addFieldFloat32(19, AZIMUTH_BIAS, 0.0);
    }
    static addAzimuthRate(builder, AZIMUTH_RATE) {
        builder.addFieldFloat32(20, AZIMUTH_RATE, 0.0);
    }
    static addElevation(builder, ELEVATION) {
        builder.addFieldFloat32(21, ELEVATION, 0.0);
    }
    static addElevationUnc(builder, ELEVATION_UNC) {
        builder.addFieldFloat32(22, ELEVATION_UNC, 0.0);
    }
    static addElevationBias(builder, ELEVATION_BIAS) {
        builder.addFieldFloat32(23, ELEVATION_BIAS, 0.0);
    }
    static addElevationRate(builder, ELEVATION_RATE) {
        builder.addFieldFloat32(24, ELEVATION_RATE, 0.0);
    }
    static addRange(builder, RANGE) {
        builder.addFieldFloat32(25, RANGE, 0.0);
    }
    static addRangeUnc(builder, RANGE_UNC) {
        builder.addFieldFloat32(26, RANGE_UNC, 0.0);
    }
    static addRangeBias(builder, RANGE_BIAS) {
        builder.addFieldFloat32(27, RANGE_BIAS, 0.0);
    }
    static addRangeRate(builder, RANGE_RATE) {
        builder.addFieldFloat32(28, RANGE_RATE, 0.0);
    }
    static addRangeRateUnc(builder, RANGE_RATE_UNC) {
        builder.addFieldFloat32(29, RANGE_RATE_UNC, 0.0);
    }
    static addRa(builder, RA) {
        builder.addFieldFloat32(30, RA, 0.0);
    }
    static addRaRate(builder, RA_RATE) {
        builder.addFieldFloat32(31, RA_RATE, 0.0);
    }
    static addRaUnc(builder, RA_UNC) {
        builder.addFieldFloat32(32, RA_UNC, 0.0);
    }
    static addRaBias(builder, RA_BIAS) {
        builder.addFieldFloat32(33, RA_BIAS, 0.0);
    }
    static addDeclination(builder, DECLINATION) {
        builder.addFieldFloat32(34, DECLINATION, 0.0);
    }
    static addDeclinationRate(builder, DECLINATION_RATE) {
        builder.addFieldFloat32(35, DECLINATION_RATE, 0.0);
    }
    static addDeclinationUnc(builder, DECLINATION_UNC) {
        builder.addFieldFloat32(36, DECLINATION_UNC, 0.0);
    }
    static addDeclinationBias(builder, DECLINATION_BIAS) {
        builder.addFieldFloat32(37, DECLINATION_BIAS, 0.0);
    }
    static addLosx(builder, LOSX) {
        builder.addFieldFloat32(38, LOSX, 0.0);
    }
    static addLosy(builder, LOSY) {
        builder.addFieldFloat32(39, LOSY, 0.0);
    }
    static addLosz(builder, LOSZ) {
        builder.addFieldFloat32(40, LOSZ, 0.0);
    }
    static addLosUnc(builder, LOS_UNC) {
        builder.addFieldFloat32(41, LOS_UNC, 0.0);
    }
    static addLosxvel(builder, LOSXVEL) {
        builder.addFieldFloat32(42, LOSXVEL, 0.0);
    }
    static addLosyvel(builder, LOSYVEL) {
        builder.addFieldFloat32(43, LOSYVEL, 0.0);
    }
    static addLoszvel(builder, LOSZVEL) {
        builder.addFieldFloat32(44, LOSZVEL, 0.0);
    }
    static addSenlat(builder, SENLAT) {
        builder.addFieldFloat32(45, SENLAT, 0.0);
    }
    static addSenlon(builder, SENLON) {
        builder.addFieldFloat32(46, SENLON, 0.0);
    }
    static addSenalt(builder, SENALT) {
        builder.addFieldFloat32(47, SENALT, 0.0);
    }
    static addSenx(builder, SENX) {
        builder.addFieldFloat32(48, SENX, 0.0);
    }
    static addSeny(builder, SENY) {
        builder.addFieldFloat32(49, SENY, 0.0);
    }
    static addSenz(builder, SENZ) {
        builder.addFieldFloat32(50, SENZ, 0.0);
    }
    static addFovCount(builder, FOV_COUNT) {
        builder.addFieldInt32(51, FOV_COUNT, 0);
    }
    static addFovCountUcts(builder, FOV_COUNT_UCTS) {
        builder.addFieldInt32(52, FOV_COUNT_UCTS, 0);
    }
    static addExpDuration(builder, EXP_DURATION) {
        builder.addFieldFloat32(53, EXP_DURATION, 0.0);
    }
    static addZeroptd(builder, ZEROPTD) {
        builder.addFieldFloat32(54, ZEROPTD, 0.0);
    }
    static addNetObjSig(builder, NET_OBJ_SIG) {
        builder.addFieldFloat32(55, NET_OBJ_SIG, 0.0);
    }
    static addNetObjSigUnc(builder, NET_OBJ_SIG_UNC) {
        builder.addFieldFloat32(56, NET_OBJ_SIG_UNC, 0.0);
    }
    static addMag(builder, MAG) {
        builder.addFieldFloat32(57, MAG, 0.0);
    }
    static addMagUnc(builder, MAG_UNC) {
        builder.addFieldFloat32(58, MAG_UNC, 0.0);
    }
    static addMagNormRange(builder, MAG_NORM_RANGE) {
        builder.addFieldFloat32(59, MAG_NORM_RANGE, 0.0);
    }
    static addGeolat(builder, GEOLAT) {
        builder.addFieldFloat32(60, GEOLAT, 0.0);
    }
    static addGeolon(builder, GEOLON) {
        builder.addFieldFloat32(61, GEOLON, 0.0);
    }
    static addGeoalt(builder, GEOALT) {
        builder.addFieldFloat32(62, GEOALT, 0.0);
    }
    static addGeorange(builder, GEORANGE) {
        builder.addFieldFloat32(63, GEORANGE, 0.0);
    }
    static addSkyBkgrnd(builder, SKY_BKGRND) {
        builder.addFieldFloat32(64, SKY_BKGRND, 0.0);
    }
    static addPrimaryExtinction(builder, PRIMARY_EXTINCTION) {
        builder.addFieldFloat32(65, PRIMARY_EXTINCTION, 0.0);
    }
    static addPrimaryExtinctionUnc(builder, PRIMARY_EXTINCTION_UNC) {
        builder.addFieldFloat32(66, PRIMARY_EXTINCTION_UNC, 0.0);
    }
    static addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE) {
        builder.addFieldFloat32(67, SOLAR_PHASE_ANGLE, 0.0);
    }
    static addSolarEqPhaseAngle(builder, SOLAR_EQ_PHASE_ANGLE) {
        builder.addFieldFloat32(68, SOLAR_EQ_PHASE_ANGLE, 0.0);
    }
    static addSolarDecAngle(builder, SOLAR_DEC_ANGLE) {
        builder.addFieldFloat32(69, SOLAR_DEC_ANGLE, 0.0);
    }
    static addShutterDelay(builder, SHUTTER_DELAY) {
        builder.addFieldFloat32(70, SHUTTER_DELAY, 0.0);
    }
    static addTimingBias(builder, TIMING_BIAS) {
        builder.addFieldFloat32(71, TIMING_BIAS, 0.0);
    }
    static addRawFileUri(builder, RAW_FILE_URIOffset) {
        builder.addFieldOffset(72, RAW_FILE_URIOffset, 0);
    }
    static addIntensity(builder, INTENSITY) {
        builder.addFieldFloat32(73, INTENSITY, 0.0);
    }
    static addBgIntensity(builder, BG_INTENSITY) {
        builder.addFieldFloat32(74, BG_INTENSITY, 0.0);
    }
    static addDescriptor(builder, DESCRIPTOROffset) {
        builder.addFieldOffset(75, DESCRIPTOROffset, 0);
    }
    static addSource(builder, SOURCEOffset) {
        builder.addFieldOffset(76, SOURCEOffset, 0);
    }
    static addOrigin(builder, ORIGINOffset) {
        builder.addFieldOffset(77, ORIGINOffset, 0);
    }
    static addDataMode(builder, DATA_MODE) {
        builder.addFieldInt8(78, DATA_MODE, DataMode.EXERCISE);
    }
    static addCreatedAt(builder, CREATED_ATOffset) {
        builder.addFieldOffset(79, CREATED_ATOffset, 0);
    }
    static addCreatedBy(builder, CREATED_BYOffset) {
        builder.addFieldOffset(80, CREATED_BYOffset, 0);
    }
    static addReferenceFrame(builder, REFERENCE_FRAME) {
        builder.addFieldInt8(81, REFERENCE_FRAME, refFrame.ECEF);
    }
    static addSenReferenceFrame(builder, SEN_REFERENCE_FRAME) {
        builder.addFieldInt8(82, SEN_REFERENCE_FRAME, refFrame.ECEF);
    }
    static addUmbra(builder, UMBRA) {
        builder.addFieldInt8(83, +UMBRA, +false);
    }
    static addPenumbra(builder, PENUMBRA) {
        builder.addFieldInt8(84, +PENUMBRA, +false);
    }
    static addOrigNetwork(builder, ORIG_NETWORKOffset) {
        builder.addFieldOffset(85, ORIG_NETWORKOffset, 0);
    }
    static addSourceDl(builder, SOURCE_DLOffset) {
        builder.addFieldOffset(86, SOURCE_DLOffset, 0);
    }
    static addType(builder, TYPE) {
        builder.addFieldInt8(87, TYPE, DeviceType.UNKNOWN);
    }
    static addAzimuthMeasured(builder, AZIMUTH_MEASURED) {
        builder.addFieldInt8(88, +AZIMUTH_MEASURED, +false);
    }
    static addElevationMeasured(builder, ELEVATION_MEASURED) {
        builder.addFieldInt8(89, +ELEVATION_MEASURED, +false);
    }
    static addRangeMeasured(builder, RANGE_MEASURED) {
        builder.addFieldInt8(90, +RANGE_MEASURED, +false);
    }
    static addRangerateMeasured(builder, RANGERATE_MEASURED) {
        builder.addFieldInt8(91, +RANGERATE_MEASURED, +false);
    }
    static addRaMeasured(builder, RA_MEASURED) {
        builder.addFieldInt8(92, +RA_MEASURED, +false);
    }
    static addDeclinationMeasured(builder, DECLINATION_MEASURED) {
        builder.addFieldInt8(93, +DECLINATION_MEASURED, +false);
    }
    static addNiirs(builder, NIIRS) {
        builder.addFieldFloat32(94, NIIRS, 0.0);
    }
    static addMetersPerPixel(builder, METERS_PER_PIXEL) {
        builder.addFieldFloat32(95, METERS_PER_PIXEL, 0.0);
    }
    static addImageSnr(builder, IMAGE_SNR) {
        builder.addFieldFloat32(96, IMAGE_SNR, 0.0);
    }
    static addImageBitDepth(builder, IMAGE_BIT_DEPTH) {
        builder.addFieldInt32(97, IMAGE_BIT_DEPTH, 0);
    }
    static addImageWidth(builder, IMAGE_WIDTH) {
        builder.addFieldInt32(98, IMAGE_WIDTH, 0);
    }
    static addImageHeight(builder, IMAGE_HEIGHT) {
        builder.addFieldInt32(99, IMAGE_HEIGHT, 0);
    }
    static addImageCompression(builder, IMAGE_COMPRESSIONOffset) {
        builder.addFieldOffset(100, IMAGE_COMPRESSIONOffset, 0);
    }
    static addImageCompressionRatio(builder, IMAGE_COMPRESSION_RATIO) {
        builder.addFieldFloat32(101, IMAGE_COMPRESSION_RATIO, 0.0);
    }
    static addProcessedImageUri(builder, PROCESSED_IMAGE_URIOffset) {
        builder.addFieldOffset(102, PROCESSED_IMAGE_URIOffset, 0);
    }
    static addImageAutoEnhanced(builder, IMAGE_AUTO_ENHANCED) {
        builder.addFieldInt8(103, +IMAGE_AUTO_ENHANCED, +false);
    }
    static addMultiFrameStacked(builder, MULTI_FRAME_STACKED) {
        builder.addFieldInt8(104, +MULTI_FRAME_STACKED, +false);
    }
    static addSyntheticTrackingUsed(builder, SYNTHETIC_TRACKING_USED) {
        builder.addFieldInt8(105, +SYNTHETIC_TRACKING_USED, +false);
    }
    static addImageSharpness(builder, IMAGE_SHARPNESS) {
        builder.addFieldFloat32(106, IMAGE_SHARPNESS, 0.0);
    }
    static addImageNoiseStddev(builder, IMAGE_NOISE_STDDEV) {
        builder.addFieldFloat32(107, IMAGE_NOISE_STDDEV, 0.0);
    }
    static addImageContrast(builder, IMAGE_CONTRAST) {
        builder.addFieldFloat32(108, IMAGE_CONTRAST, 0.0);
    }
    static addImageDynamicRange(builder, IMAGE_DYNAMIC_RANGE) {
        builder.addFieldFloat32(109, IMAGE_DYNAMIC_RANGE, 0.0);
    }
    static addImageEntropy(builder, IMAGE_ENTROPY) {
        builder.addFieldFloat32(110, IMAGE_ENTROPY, 0.0);
    }
    static addBackgroundUniformity(builder, BACKGROUND_UNIFORMITY) {
        builder.addFieldFloat32(111, BACKGROUND_UNIFORMITY, 0.0);
    }
    static addBackgroundMeanLevel(builder, BACKGROUND_MEAN_LEVEL) {
        builder.addFieldFloat32(112, BACKGROUND_MEAN_LEVEL, 0.0);
    }
    static addSaturatedPixelPercent(builder, SATURATED_PIXEL_PERCENT) {
        builder.addFieldFloat32(113, SATURATED_PIXEL_PERCENT, 0.0);
    }
    static addDeadPixelPercent(builder, DEAD_PIXEL_PERCENT) {
        builder.addFieldFloat32(114, DEAD_PIXEL_PERCENT, 0.0);
    }
    static addPsfFwhm(builder, PSF_FWHM) {
        builder.addFieldFloat32(115, PSF_FWHM, 0.0);
    }
    static addCloudCoverPercent(builder, CLOUD_COVER_PERCENT) {
        builder.addFieldFloat32(116, CLOUD_COVER_PERCENT, 0.0);
    }
    static addCloudDetectionConfidence(builder, CLOUD_DETECTION_CONFIDENCE) {
        builder.addFieldFloat32(117, CLOUD_DETECTION_CONFIDENCE, 0.0);
    }
    static addHazePercent(builder, HAZE_PERCENT) {
        builder.addFieldFloat32(118, HAZE_PERCENT, 0.0);
    }
    static addAerosolOpticalThickness(builder, AEROSOL_OPTICAL_THICKNESS) {
        builder.addFieldFloat32(119, AEROSOL_OPTICAL_THICKNESS, 0.0);
    }
    static addWaterVaporContent(builder, WATER_VAPOR_CONTENT) {
        builder.addFieldFloat32(120, WATER_VAPOR_CONTENT, 0.0);
    }
    static addSunElevation(builder, SUN_ELEVATION) {
        builder.addFieldFloat32(121, SUN_ELEVATION, 0.0);
    }
    static addSunAzimuth(builder, SUN_AZIMUTH) {
        builder.addFieldFloat32(122, SUN_AZIMUTH, 0.0);
    }
    static addViewZenithAngle(builder, VIEW_ZENITH_ANGLE) {
        builder.addFieldFloat32(123, VIEW_ZENITH_ANGLE, 0.0);
    }
    static addViewAzimuthAngle(builder, VIEW_AZIMUTH_ANGLE) {
        builder.addFieldFloat32(124, VIEW_AZIMUTH_ANGLE, 0.0);
    }
    static addOffNadirAngle(builder, OFF_NADIR_ANGLE) {
        builder.addFieldFloat32(125, OFF_NADIR_ANGLE, 0.0);
    }
    static addSwathWidthKm(builder, SWATH_WIDTH_KM) {
        builder.addFieldFloat32(126, SWATH_WIDTH_KM, 0.0);
    }
    static addMeanTerrainElevation(builder, MEAN_TERRAIN_ELEVATION) {
        builder.addFieldFloat32(127, MEAN_TERRAIN_ELEVATION, 0.0);
    }
    static addTerrainElevationStddev(builder, TERRAIN_ELEVATION_STDDEV) {
        builder.addFieldFloat32(128, TERRAIN_ELEVATION_STDDEV, 0.0);
    }
    static addShadowCoverPercent(builder, SHADOW_COVER_PERCENT) {
        builder.addFieldFloat32(129, SHADOW_COVER_PERCENT, 0.0);
    }
    static addSunglintPresent(builder, SUNGLINT_PRESENT) {
        builder.addFieldInt8(130, +SUNGLINT_PRESENT, +false);
    }
    static addSunglintPercent(builder, SUNGLINT_PERCENT) {
        builder.addFieldFloat32(131, SUNGLINT_PERCENT, 0.0);
    }
    static addSnowIceCoverPercent(builder, SNOW_ICE_COVER_PERCENT) {
        builder.addFieldFloat32(132, SNOW_ICE_COVER_PERCENT, 0.0);
    }
    static addValidDataAreaKm2(builder, VALID_DATA_AREA_KM2) {
        builder.addFieldFloat32(133, VALID_DATA_AREA_KM2, 0.0);
    }
    static endEOO(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishEOOBuffer(builder, offset) {
        builder.finish(offset, '$EOO');
    }
    static finishSizePrefixedEOOBuffer(builder, offset) {
        builder.finish(offset, '$EOO', true);
    }
    static createEOO(builder, IDOffset, CLASSIFICATIONOffset, OB_TIMEOffset, CORR_QUALITY, ID_ON_ORBITOffset, SENSOR_IDOffset, COLLECT_METHOD, NORAD_CAT_ID, TASK_IDOffset, TRANSACTION_IDOffset, IMAGE_SET_IDOffset, IMAGE_SET_LENGTH, SEQUENCE_ID, OB_POSITION, ORIG_OBJECT_IDOffset, ORIG_SENSOR_IDOffset, UCT, AZIMUTH, AZIMUTH_UNC, AZIMUTH_BIAS, AZIMUTH_RATE, ELEVATION, ELEVATION_UNC, ELEVATION_BIAS, ELEVATION_RATE, RANGE, RANGE_UNC, RANGE_BIAS, RANGE_RATE, RANGE_RATE_UNC, RA, RA_RATE, RA_UNC, RA_BIAS, DECLINATION, DECLINATION_RATE, DECLINATION_UNC, DECLINATION_BIAS, LOSX, LOSY, LOSZ, LOS_UNC, LOSXVEL, LOSYVEL, LOSZVEL, SENLAT, SENLON, SENALT, SENX, SENY, SENZ, FOV_COUNT, FOV_COUNT_UCTS, EXP_DURATION, ZEROPTD, NET_OBJ_SIG, NET_OBJ_SIG_UNC, MAG, MAG_UNC, MAG_NORM_RANGE, GEOLAT, GEOLON, GEOALT, GEORANGE, SKY_BKGRND, PRIMARY_EXTINCTION, PRIMARY_EXTINCTION_UNC, SOLAR_PHASE_ANGLE, SOLAR_EQ_PHASE_ANGLE, SOLAR_DEC_ANGLE, SHUTTER_DELAY, TIMING_BIAS, RAW_FILE_URIOffset, INTENSITY, BG_INTENSITY, DESCRIPTOROffset, SOURCEOffset, ORIGINOffset, DATA_MODE, CREATED_ATOffset, CREATED_BYOffset, REFERENCE_FRAME, SEN_REFERENCE_FRAME, UMBRA, PENUMBRA, ORIG_NETWORKOffset, SOURCE_DLOffset, TYPE, AZIMUTH_MEASURED, ELEVATION_MEASURED, RANGE_MEASURED, RANGERATE_MEASURED, RA_MEASURED, DECLINATION_MEASURED, NIIRS, METERS_PER_PIXEL, IMAGE_SNR, IMAGE_BIT_DEPTH, IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_COMPRESSIONOffset, IMAGE_COMPRESSION_RATIO, PROCESSED_IMAGE_URIOffset, IMAGE_AUTO_ENHANCED, MULTI_FRAME_STACKED, SYNTHETIC_TRACKING_USED, IMAGE_SHARPNESS, IMAGE_NOISE_STDDEV, IMAGE_CONTRAST, IMAGE_DYNAMIC_RANGE, IMAGE_ENTROPY, BACKGROUND_UNIFORMITY, BACKGROUND_MEAN_LEVEL, SATURATED_PIXEL_PERCENT, DEAD_PIXEL_PERCENT, PSF_FWHM, CLOUD_COVER_PERCENT, CLOUD_DETECTION_CONFIDENCE, HAZE_PERCENT, AEROSOL_OPTICAL_THICKNESS, WATER_VAPOR_CONTENT, SUN_ELEVATION, SUN_AZIMUTH, VIEW_ZENITH_ANGLE, VIEW_AZIMUTH_ANGLE, OFF_NADIR_ANGLE, SWATH_WIDTH_KM, MEAN_TERRAIN_ELEVATION, TERRAIN_ELEVATION_STDDEV, SHADOW_COVER_PERCENT, SUNGLINT_PRESENT, SUNGLINT_PERCENT, SNOW_ICE_COVER_PERCENT, VALID_DATA_AREA_KM2) {
        EOO.startEOO(builder);
        EOO.addId(builder, IDOffset);
        EOO.addClassification(builder, CLASSIFICATIONOffset);
        EOO.addObTime(builder, OB_TIMEOffset);
        EOO.addCorrQuality(builder, CORR_QUALITY);
        EOO.addIdOnOrbit(builder, ID_ON_ORBITOffset);
        EOO.addSensorId(builder, SENSOR_IDOffset);
        EOO.addCollectMethod(builder, COLLECT_METHOD);
        EOO.addNoradCatId(builder, NORAD_CAT_ID);
        EOO.addTaskId(builder, TASK_IDOffset);
        EOO.addTransactionId(builder, TRANSACTION_IDOffset);
        EOO.addImageSetId(builder, IMAGE_SET_IDOffset);
        EOO.addImageSetLength(builder, IMAGE_SET_LENGTH);
        EOO.addSequenceId(builder, SEQUENCE_ID);
        EOO.addObPosition(builder, OB_POSITION);
        EOO.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
        EOO.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
        EOO.addUct(builder, UCT);
        EOO.addAzimuth(builder, AZIMUTH);
        EOO.addAzimuthUnc(builder, AZIMUTH_UNC);
        EOO.addAzimuthBias(builder, AZIMUTH_BIAS);
        EOO.addAzimuthRate(builder, AZIMUTH_RATE);
        EOO.addElevation(builder, ELEVATION);
        EOO.addElevationUnc(builder, ELEVATION_UNC);
        EOO.addElevationBias(builder, ELEVATION_BIAS);
        EOO.addElevationRate(builder, ELEVATION_RATE);
        EOO.addRange(builder, RANGE);
        EOO.addRangeUnc(builder, RANGE_UNC);
        EOO.addRangeBias(builder, RANGE_BIAS);
        EOO.addRangeRate(builder, RANGE_RATE);
        EOO.addRangeRateUnc(builder, RANGE_RATE_UNC);
        EOO.addRa(builder, RA);
        EOO.addRaRate(builder, RA_RATE);
        EOO.addRaUnc(builder, RA_UNC);
        EOO.addRaBias(builder, RA_BIAS);
        EOO.addDeclination(builder, DECLINATION);
        EOO.addDeclinationRate(builder, DECLINATION_RATE);
        EOO.addDeclinationUnc(builder, DECLINATION_UNC);
        EOO.addDeclinationBias(builder, DECLINATION_BIAS);
        EOO.addLosx(builder, LOSX);
        EOO.addLosy(builder, LOSY);
        EOO.addLosz(builder, LOSZ);
        EOO.addLosUnc(builder, LOS_UNC);
        EOO.addLosxvel(builder, LOSXVEL);
        EOO.addLosyvel(builder, LOSYVEL);
        EOO.addLoszvel(builder, LOSZVEL);
        EOO.addSenlat(builder, SENLAT);
        EOO.addSenlon(builder, SENLON);
        EOO.addSenalt(builder, SENALT);
        EOO.addSenx(builder, SENX);
        EOO.addSeny(builder, SENY);
        EOO.addSenz(builder, SENZ);
        EOO.addFovCount(builder, FOV_COUNT);
        EOO.addFovCountUcts(builder, FOV_COUNT_UCTS);
        EOO.addExpDuration(builder, EXP_DURATION);
        EOO.addZeroptd(builder, ZEROPTD);
        EOO.addNetObjSig(builder, NET_OBJ_SIG);
        EOO.addNetObjSigUnc(builder, NET_OBJ_SIG_UNC);
        EOO.addMag(builder, MAG);
        EOO.addMagUnc(builder, MAG_UNC);
        EOO.addMagNormRange(builder, MAG_NORM_RANGE);
        EOO.addGeolat(builder, GEOLAT);
        EOO.addGeolon(builder, GEOLON);
        EOO.addGeoalt(builder, GEOALT);
        EOO.addGeorange(builder, GEORANGE);
        EOO.addSkyBkgrnd(builder, SKY_BKGRND);
        EOO.addPrimaryExtinction(builder, PRIMARY_EXTINCTION);
        EOO.addPrimaryExtinctionUnc(builder, PRIMARY_EXTINCTION_UNC);
        EOO.addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE);
        EOO.addSolarEqPhaseAngle(builder, SOLAR_EQ_PHASE_ANGLE);
        EOO.addSolarDecAngle(builder, SOLAR_DEC_ANGLE);
        EOO.addShutterDelay(builder, SHUTTER_DELAY);
        EOO.addTimingBias(builder, TIMING_BIAS);
        EOO.addRawFileUri(builder, RAW_FILE_URIOffset);
        EOO.addIntensity(builder, INTENSITY);
        EOO.addBgIntensity(builder, BG_INTENSITY);
        EOO.addDescriptor(builder, DESCRIPTOROffset);
        EOO.addSource(builder, SOURCEOffset);
        EOO.addOrigin(builder, ORIGINOffset);
        EOO.addDataMode(builder, DATA_MODE);
        EOO.addCreatedAt(builder, CREATED_ATOffset);
        EOO.addCreatedBy(builder, CREATED_BYOffset);
        EOO.addReferenceFrame(builder, REFERENCE_FRAME);
        EOO.addSenReferenceFrame(builder, SEN_REFERENCE_FRAME);
        EOO.addUmbra(builder, UMBRA);
        EOO.addPenumbra(builder, PENUMBRA);
        EOO.addOrigNetwork(builder, ORIG_NETWORKOffset);
        EOO.addSourceDl(builder, SOURCE_DLOffset);
        EOO.addType(builder, TYPE);
        EOO.addAzimuthMeasured(builder, AZIMUTH_MEASURED);
        EOO.addElevationMeasured(builder, ELEVATION_MEASURED);
        EOO.addRangeMeasured(builder, RANGE_MEASURED);
        EOO.addRangerateMeasured(builder, RANGERATE_MEASURED);
        EOO.addRaMeasured(builder, RA_MEASURED);
        EOO.addDeclinationMeasured(builder, DECLINATION_MEASURED);
        EOO.addNiirs(builder, NIIRS);
        EOO.addMetersPerPixel(builder, METERS_PER_PIXEL);
        EOO.addImageSnr(builder, IMAGE_SNR);
        EOO.addImageBitDepth(builder, IMAGE_BIT_DEPTH);
        EOO.addImageWidth(builder, IMAGE_WIDTH);
        EOO.addImageHeight(builder, IMAGE_HEIGHT);
        EOO.addImageCompression(builder, IMAGE_COMPRESSIONOffset);
        EOO.addImageCompressionRatio(builder, IMAGE_COMPRESSION_RATIO);
        EOO.addProcessedImageUri(builder, PROCESSED_IMAGE_URIOffset);
        EOO.addImageAutoEnhanced(builder, IMAGE_AUTO_ENHANCED);
        EOO.addMultiFrameStacked(builder, MULTI_FRAME_STACKED);
        EOO.addSyntheticTrackingUsed(builder, SYNTHETIC_TRACKING_USED);
        EOO.addImageSharpness(builder, IMAGE_SHARPNESS);
        EOO.addImageNoiseStddev(builder, IMAGE_NOISE_STDDEV);
        EOO.addImageContrast(builder, IMAGE_CONTRAST);
        EOO.addImageDynamicRange(builder, IMAGE_DYNAMIC_RANGE);
        EOO.addImageEntropy(builder, IMAGE_ENTROPY);
        EOO.addBackgroundUniformity(builder, BACKGROUND_UNIFORMITY);
        EOO.addBackgroundMeanLevel(builder, BACKGROUND_MEAN_LEVEL);
        EOO.addSaturatedPixelPercent(builder, SATURATED_PIXEL_PERCENT);
        EOO.addDeadPixelPercent(builder, DEAD_PIXEL_PERCENT);
        EOO.addPsfFwhm(builder, PSF_FWHM);
        EOO.addCloudCoverPercent(builder, CLOUD_COVER_PERCENT);
        EOO.addCloudDetectionConfidence(builder, CLOUD_DETECTION_CONFIDENCE);
        EOO.addHazePercent(builder, HAZE_PERCENT);
        EOO.addAerosolOpticalThickness(builder, AEROSOL_OPTICAL_THICKNESS);
        EOO.addWaterVaporContent(builder, WATER_VAPOR_CONTENT);
        EOO.addSunElevation(builder, SUN_ELEVATION);
        EOO.addSunAzimuth(builder, SUN_AZIMUTH);
        EOO.addViewZenithAngle(builder, VIEW_ZENITH_ANGLE);
        EOO.addViewAzimuthAngle(builder, VIEW_AZIMUTH_ANGLE);
        EOO.addOffNadirAngle(builder, OFF_NADIR_ANGLE);
        EOO.addSwathWidthKm(builder, SWATH_WIDTH_KM);
        EOO.addMeanTerrainElevation(builder, MEAN_TERRAIN_ELEVATION);
        EOO.addTerrainElevationStddev(builder, TERRAIN_ELEVATION_STDDEV);
        EOO.addShadowCoverPercent(builder, SHADOW_COVER_PERCENT);
        EOO.addSunglintPresent(builder, SUNGLINT_PRESENT);
        EOO.addSunglintPercent(builder, SUNGLINT_PERCENT);
        EOO.addSnowIceCoverPercent(builder, SNOW_ICE_COVER_PERCENT);
        EOO.addValidDataAreaKm2(builder, VALID_DATA_AREA_KM2);
        return EOO.endEOO(builder);
    }
    unpack() {
        return new EOOT(this.ID(), this.CLASSIFICATION(), this.OB_TIME(), this.CORR_QUALITY(), this.ID_ON_ORBIT(), this.SENSOR_ID(), this.COLLECT_METHOD(), this.NORAD_CAT_ID(), this.TASK_ID(), this.TRANSACTION_ID(), this.IMAGE_SET_ID(), this.IMAGE_SET_LENGTH(), this.SEQUENCE_ID(), this.OB_POSITION(), this.ORIG_OBJECT_ID(), this.ORIG_SENSOR_ID(), this.UCT(), this.AZIMUTH(), this.AZIMUTH_UNC(), this.AZIMUTH_BIAS(), this.AZIMUTH_RATE(), this.ELEVATION(), this.ELEVATION_UNC(), this.ELEVATION_BIAS(), this.ELEVATION_RATE(), this.RANGE(), this.RANGE_UNC(), this.RANGE_BIAS(), this.RANGE_RATE(), this.RANGE_RATE_UNC(), this.RA(), this.RA_RATE(), this.RA_UNC(), this.RA_BIAS(), this.DECLINATION(), this.DECLINATION_RATE(), this.DECLINATION_UNC(), this.DECLINATION_BIAS(), this.LOSX(), this.LOSY(), this.LOSZ(), this.LOS_UNC(), this.LOSXVEL(), this.LOSYVEL(), this.LOSZVEL(), this.SENLAT(), this.SENLON(), this.SENALT(), this.SENX(), this.SENY(), this.SENZ(), this.FOV_COUNT(), this.FOV_COUNT_UCTS(), this.EXP_DURATION(), this.ZEROPTD(), this.NET_OBJ_SIG(), this.NET_OBJ_SIG_UNC(), this.MAG(), this.MAG_UNC(), this.MAG_NORM_RANGE(), this.GEOLAT(), this.GEOLON(), this.GEOALT(), this.GEORANGE(), this.SKY_BKGRND(), this.PRIMARY_EXTINCTION(), this.PRIMARY_EXTINCTION_UNC(), this.SOLAR_PHASE_ANGLE(), this.SOLAR_EQ_PHASE_ANGLE(), this.SOLAR_DEC_ANGLE(), this.SHUTTER_DELAY(), this.TIMING_BIAS(), this.RAW_FILE_URI(), this.INTENSITY(), this.BG_INTENSITY(), this.DESCRIPTOR(), this.SOURCE(), this.ORIGIN(), this.DATA_MODE(), this.CREATED_AT(), this.CREATED_BY(), this.REFERENCE_FRAME(), this.SEN_REFERENCE_FRAME(), this.UMBRA(), this.PENUMBRA(), this.ORIG_NETWORK(), this.SOURCE_DL(), this.TYPE(), this.AZIMUTH_MEASURED(), this.ELEVATION_MEASURED(), this.RANGE_MEASURED(), this.RANGERATE_MEASURED(), this.RA_MEASURED(), this.DECLINATION_MEASURED(), this.NIIRS(), this.METERS_PER_PIXEL(), this.IMAGE_SNR(), this.IMAGE_BIT_DEPTH(), this.IMAGE_WIDTH(), this.IMAGE_HEIGHT(), this.IMAGE_COMPRESSION(), this.IMAGE_COMPRESSION_RATIO(), this.PROCESSED_IMAGE_URI(), this.IMAGE_AUTO_ENHANCED(), this.MULTI_FRAME_STACKED(), this.SYNTHETIC_TRACKING_USED(), this.IMAGE_SHARPNESS(), this.IMAGE_NOISE_STDDEV(), this.IMAGE_CONTRAST(), this.IMAGE_DYNAMIC_RANGE(), this.IMAGE_ENTROPY(), this.BACKGROUND_UNIFORMITY(), this.BACKGROUND_MEAN_LEVEL(), this.SATURATED_PIXEL_PERCENT(), this.DEAD_PIXEL_PERCENT(), this.PSF_FWHM(), this.CLOUD_COVER_PERCENT(), this.CLOUD_DETECTION_CONFIDENCE(), this.HAZE_PERCENT(), this.AEROSOL_OPTICAL_THICKNESS(), this.WATER_VAPOR_CONTENT(), this.SUN_ELEVATION(), this.SUN_AZIMUTH(), this.VIEW_ZENITH_ANGLE(), this.VIEW_AZIMUTH_ANGLE(), this.OFF_NADIR_ANGLE(), this.SWATH_WIDTH_KM(), this.MEAN_TERRAIN_ELEVATION(), this.TERRAIN_ELEVATION_STDDEV(), this.SHADOW_COVER_PERCENT(), this.SUNGLINT_PRESENT(), this.SUNGLINT_PERCENT(), this.SNOW_ICE_COVER_PERCENT(), this.VALID_DATA_AREA_KM2());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.CLASSIFICATION = this.CLASSIFICATION();
        _o.OB_TIME = this.OB_TIME();
        _o.CORR_QUALITY = this.CORR_QUALITY();
        _o.ID_ON_ORBIT = this.ID_ON_ORBIT();
        _o.SENSOR_ID = this.SENSOR_ID();
        _o.COLLECT_METHOD = this.COLLECT_METHOD();
        _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
        _o.TASK_ID = this.TASK_ID();
        _o.TRANSACTION_ID = this.TRANSACTION_ID();
        _o.IMAGE_SET_ID = this.IMAGE_SET_ID();
        _o.IMAGE_SET_LENGTH = this.IMAGE_SET_LENGTH();
        _o.SEQUENCE_ID = this.SEQUENCE_ID();
        _o.OB_POSITION = this.OB_POSITION();
        _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
        _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
        _o.UCT = this.UCT();
        _o.AZIMUTH = this.AZIMUTH();
        _o.AZIMUTH_UNC = this.AZIMUTH_UNC();
        _o.AZIMUTH_BIAS = this.AZIMUTH_BIAS();
        _o.AZIMUTH_RATE = this.AZIMUTH_RATE();
        _o.ELEVATION = this.ELEVATION();
        _o.ELEVATION_UNC = this.ELEVATION_UNC();
        _o.ELEVATION_BIAS = this.ELEVATION_BIAS();
        _o.ELEVATION_RATE = this.ELEVATION_RATE();
        _o.RANGE = this.RANGE();
        _o.RANGE_UNC = this.RANGE_UNC();
        _o.RANGE_BIAS = this.RANGE_BIAS();
        _o.RANGE_RATE = this.RANGE_RATE();
        _o.RANGE_RATE_UNC = this.RANGE_RATE_UNC();
        _o.RA = this.RA();
        _o.RA_RATE = this.RA_RATE();
        _o.RA_UNC = this.RA_UNC();
        _o.RA_BIAS = this.RA_BIAS();
        _o.DECLINATION = this.DECLINATION();
        _o.DECLINATION_RATE = this.DECLINATION_RATE();
        _o.DECLINATION_UNC = this.DECLINATION_UNC();
        _o.DECLINATION_BIAS = this.DECLINATION_BIAS();
        _o.LOSX = this.LOSX();
        _o.LOSY = this.LOSY();
        _o.LOSZ = this.LOSZ();
        _o.LOS_UNC = this.LOS_UNC();
        _o.LOSXVEL = this.LOSXVEL();
        _o.LOSYVEL = this.LOSYVEL();
        _o.LOSZVEL = this.LOSZVEL();
        _o.SENLAT = this.SENLAT();
        _o.SENLON = this.SENLON();
        _o.SENALT = this.SENALT();
        _o.SENX = this.SENX();
        _o.SENY = this.SENY();
        _o.SENZ = this.SENZ();
        _o.FOV_COUNT = this.FOV_COUNT();
        _o.FOV_COUNT_UCTS = this.FOV_COUNT_UCTS();
        _o.EXP_DURATION = this.EXP_DURATION();
        _o.ZEROPTD = this.ZEROPTD();
        _o.NET_OBJ_SIG = this.NET_OBJ_SIG();
        _o.NET_OBJ_SIG_UNC = this.NET_OBJ_SIG_UNC();
        _o.MAG = this.MAG();
        _o.MAG_UNC = this.MAG_UNC();
        _o.MAG_NORM_RANGE = this.MAG_NORM_RANGE();
        _o.GEOLAT = this.GEOLAT();
        _o.GEOLON = this.GEOLON();
        _o.GEOALT = this.GEOALT();
        _o.GEORANGE = this.GEORANGE();
        _o.SKY_BKGRND = this.SKY_BKGRND();
        _o.PRIMARY_EXTINCTION = this.PRIMARY_EXTINCTION();
        _o.PRIMARY_EXTINCTION_UNC = this.PRIMARY_EXTINCTION_UNC();
        _o.SOLAR_PHASE_ANGLE = this.SOLAR_PHASE_ANGLE();
        _o.SOLAR_EQ_PHASE_ANGLE = this.SOLAR_EQ_PHASE_ANGLE();
        _o.SOLAR_DEC_ANGLE = this.SOLAR_DEC_ANGLE();
        _o.SHUTTER_DELAY = this.SHUTTER_DELAY();
        _o.TIMING_BIAS = this.TIMING_BIAS();
        _o.RAW_FILE_URI = this.RAW_FILE_URI();
        _o.INTENSITY = this.INTENSITY();
        _o.BG_INTENSITY = this.BG_INTENSITY();
        _o.DESCRIPTOR = this.DESCRIPTOR();
        _o.SOURCE = this.SOURCE();
        _o.ORIGIN = this.ORIGIN();
        _o.DATA_MODE = this.DATA_MODE();
        _o.CREATED_AT = this.CREATED_AT();
        _o.CREATED_BY = this.CREATED_BY();
        _o.REFERENCE_FRAME = this.REFERENCE_FRAME();
        _o.SEN_REFERENCE_FRAME = this.SEN_REFERENCE_FRAME();
        _o.UMBRA = this.UMBRA();
        _o.PENUMBRA = this.PENUMBRA();
        _o.ORIG_NETWORK = this.ORIG_NETWORK();
        _o.SOURCE_DL = this.SOURCE_DL();
        _o.TYPE = this.TYPE();
        _o.AZIMUTH_MEASURED = this.AZIMUTH_MEASURED();
        _o.ELEVATION_MEASURED = this.ELEVATION_MEASURED();
        _o.RANGE_MEASURED = this.RANGE_MEASURED();
        _o.RANGERATE_MEASURED = this.RANGERATE_MEASURED();
        _o.RA_MEASURED = this.RA_MEASURED();
        _o.DECLINATION_MEASURED = this.DECLINATION_MEASURED();
        _o.NIIRS = this.NIIRS();
        _o.METERS_PER_PIXEL = this.METERS_PER_PIXEL();
        _o.IMAGE_SNR = this.IMAGE_SNR();
        _o.IMAGE_BIT_DEPTH = this.IMAGE_BIT_DEPTH();
        _o.IMAGE_WIDTH = this.IMAGE_WIDTH();
        _o.IMAGE_HEIGHT = this.IMAGE_HEIGHT();
        _o.IMAGE_COMPRESSION = this.IMAGE_COMPRESSION();
        _o.IMAGE_COMPRESSION_RATIO = this.IMAGE_COMPRESSION_RATIO();
        _o.PROCESSED_IMAGE_URI = this.PROCESSED_IMAGE_URI();
        _o.IMAGE_AUTO_ENHANCED = this.IMAGE_AUTO_ENHANCED();
        _o.MULTI_FRAME_STACKED = this.MULTI_FRAME_STACKED();
        _o.SYNTHETIC_TRACKING_USED = this.SYNTHETIC_TRACKING_USED();
        _o.IMAGE_SHARPNESS = this.IMAGE_SHARPNESS();
        _o.IMAGE_NOISE_STDDEV = this.IMAGE_NOISE_STDDEV();
        _o.IMAGE_CONTRAST = this.IMAGE_CONTRAST();
        _o.IMAGE_DYNAMIC_RANGE = this.IMAGE_DYNAMIC_RANGE();
        _o.IMAGE_ENTROPY = this.IMAGE_ENTROPY();
        _o.BACKGROUND_UNIFORMITY = this.BACKGROUND_UNIFORMITY();
        _o.BACKGROUND_MEAN_LEVEL = this.BACKGROUND_MEAN_LEVEL();
        _o.SATURATED_PIXEL_PERCENT = this.SATURATED_PIXEL_PERCENT();
        _o.DEAD_PIXEL_PERCENT = this.DEAD_PIXEL_PERCENT();
        _o.PSF_FWHM = this.PSF_FWHM();
        _o.CLOUD_COVER_PERCENT = this.CLOUD_COVER_PERCENT();
        _o.CLOUD_DETECTION_CONFIDENCE = this.CLOUD_DETECTION_CONFIDENCE();
        _o.HAZE_PERCENT = this.HAZE_PERCENT();
        _o.AEROSOL_OPTICAL_THICKNESS = this.AEROSOL_OPTICAL_THICKNESS();
        _o.WATER_VAPOR_CONTENT = this.WATER_VAPOR_CONTENT();
        _o.SUN_ELEVATION = this.SUN_ELEVATION();
        _o.SUN_AZIMUTH = this.SUN_AZIMUTH();
        _o.VIEW_ZENITH_ANGLE = this.VIEW_ZENITH_ANGLE();
        _o.VIEW_AZIMUTH_ANGLE = this.VIEW_AZIMUTH_ANGLE();
        _o.OFF_NADIR_ANGLE = this.OFF_NADIR_ANGLE();
        _o.SWATH_WIDTH_KM = this.SWATH_WIDTH_KM();
        _o.MEAN_TERRAIN_ELEVATION = this.MEAN_TERRAIN_ELEVATION();
        _o.TERRAIN_ELEVATION_STDDEV = this.TERRAIN_ELEVATION_STDDEV();
        _o.SHADOW_COVER_PERCENT = this.SHADOW_COVER_PERCENT();
        _o.SUNGLINT_PRESENT = this.SUNGLINT_PRESENT();
        _o.SUNGLINT_PERCENT = this.SUNGLINT_PERCENT();
        _o.SNOW_ICE_COVER_PERCENT = this.SNOW_ICE_COVER_PERCENT();
        _o.VALID_DATA_AREA_KM2 = this.VALID_DATA_AREA_KM2();
    }
}
export class EOOT {
    constructor(ID = null, CLASSIFICATION = null, OB_TIME = null, CORR_QUALITY = 0.0, ID_ON_ORBIT = null, SENSOR_ID = null, COLLECT_METHOD = CollectMethod.SIDEREAL, NORAD_CAT_ID = 0, TASK_ID = null, TRANSACTION_ID = null, IMAGE_SET_ID = null, IMAGE_SET_LENGTH = 0, SEQUENCE_ID = 0, OB_POSITION = ObservationPosition.FENCE, ORIG_OBJECT_ID = null, ORIG_SENSOR_ID = null, UCT = false, AZIMUTH = 0.0, AZIMUTH_UNC = 0.0, AZIMUTH_BIAS = 0.0, AZIMUTH_RATE = 0.0, ELEVATION = 0.0, ELEVATION_UNC = 0.0, ELEVATION_BIAS = 0.0, ELEVATION_RATE = 0.0, RANGE = 0.0, RANGE_UNC = 0.0, RANGE_BIAS = 0.0, RANGE_RATE = 0.0, RANGE_RATE_UNC = 0.0, RA = 0.0, RA_RATE = 0.0, RA_UNC = 0.0, RA_BIAS = 0.0, DECLINATION = 0.0, DECLINATION_RATE = 0.0, DECLINATION_UNC = 0.0, DECLINATION_BIAS = 0.0, LOSX = 0.0, LOSY = 0.0, LOSZ = 0.0, LOS_UNC = 0.0, LOSXVEL = 0.0, LOSYVEL = 0.0, LOSZVEL = 0.0, SENLAT = 0.0, SENLON = 0.0, SENALT = 0.0, SENX = 0.0, SENY = 0.0, SENZ = 0.0, FOV_COUNT = 0, FOV_COUNT_UCTS = 0, EXP_DURATION = 0.0, ZEROPTD = 0.0, NET_OBJ_SIG = 0.0, NET_OBJ_SIG_UNC = 0.0, MAG = 0.0, MAG_UNC = 0.0, MAG_NORM_RANGE = 0.0, GEOLAT = 0.0, GEOLON = 0.0, GEOALT = 0.0, GEORANGE = 0.0, SKY_BKGRND = 0.0, PRIMARY_EXTINCTION = 0.0, PRIMARY_EXTINCTION_UNC = 0.0, SOLAR_PHASE_ANGLE = 0.0, SOLAR_EQ_PHASE_ANGLE = 0.0, SOLAR_DEC_ANGLE = 0.0, SHUTTER_DELAY = 0.0, TIMING_BIAS = 0.0, RAW_FILE_URI = null, INTENSITY = 0.0, BG_INTENSITY = 0.0, DESCRIPTOR = null, SOURCE = null, ORIGIN = null, DATA_MODE = DataMode.EXERCISE, CREATED_AT = null, CREATED_BY = null, REFERENCE_FRAME = refFrame.ECEF, SEN_REFERENCE_FRAME = refFrame.ECEF, UMBRA = false, PENUMBRA = false, ORIG_NETWORK = null, SOURCE_DL = null, TYPE = DeviceType.UNKNOWN, AZIMUTH_MEASURED = false, ELEVATION_MEASURED = false, RANGE_MEASURED = false, RANGERATE_MEASURED = false, RA_MEASURED = false, DECLINATION_MEASURED = false, NIIRS = 0.0, METERS_PER_PIXEL = 0.0, IMAGE_SNR = 0.0, IMAGE_BIT_DEPTH = 0, IMAGE_WIDTH = 0, IMAGE_HEIGHT = 0, IMAGE_COMPRESSION = null, IMAGE_COMPRESSION_RATIO = 0.0, PROCESSED_IMAGE_URI = null, IMAGE_AUTO_ENHANCED = false, MULTI_FRAME_STACKED = false, SYNTHETIC_TRACKING_USED = false, IMAGE_SHARPNESS = 0.0, IMAGE_NOISE_STDDEV = 0.0, IMAGE_CONTRAST = 0.0, IMAGE_DYNAMIC_RANGE = 0.0, IMAGE_ENTROPY = 0.0, BACKGROUND_UNIFORMITY = 0.0, BACKGROUND_MEAN_LEVEL = 0.0, SATURATED_PIXEL_PERCENT = 0.0, DEAD_PIXEL_PERCENT = 0.0, PSF_FWHM = 0.0, CLOUD_COVER_PERCENT = 0.0, CLOUD_DETECTION_CONFIDENCE = 0.0, HAZE_PERCENT = 0.0, AEROSOL_OPTICAL_THICKNESS = 0.0, WATER_VAPOR_CONTENT = 0.0, SUN_ELEVATION = 0.0, SUN_AZIMUTH = 0.0, VIEW_ZENITH_ANGLE = 0.0, VIEW_AZIMUTH_ANGLE = 0.0, OFF_NADIR_ANGLE = 0.0, SWATH_WIDTH_KM = 0.0, MEAN_TERRAIN_ELEVATION = 0.0, TERRAIN_ELEVATION_STDDEV = 0.0, SHADOW_COVER_PERCENT = 0.0, SUNGLINT_PRESENT = false, SUNGLINT_PERCENT = 0.0, SNOW_ICE_COVER_PERCENT = 0.0, VALID_DATA_AREA_KM2 = 0.0) {
        this.ID = ID;
        this.CLASSIFICATION = CLASSIFICATION;
        this.OB_TIME = OB_TIME;
        this.CORR_QUALITY = CORR_QUALITY;
        this.ID_ON_ORBIT = ID_ON_ORBIT;
        this.SENSOR_ID = SENSOR_ID;
        this.COLLECT_METHOD = COLLECT_METHOD;
        this.NORAD_CAT_ID = NORAD_CAT_ID;
        this.TASK_ID = TASK_ID;
        this.TRANSACTION_ID = TRANSACTION_ID;
        this.IMAGE_SET_ID = IMAGE_SET_ID;
        this.IMAGE_SET_LENGTH = IMAGE_SET_LENGTH;
        this.SEQUENCE_ID = SEQUENCE_ID;
        this.OB_POSITION = OB_POSITION;
        this.ORIG_OBJECT_ID = ORIG_OBJECT_ID;
        this.ORIG_SENSOR_ID = ORIG_SENSOR_ID;
        this.UCT = UCT;
        this.AZIMUTH = AZIMUTH;
        this.AZIMUTH_UNC = AZIMUTH_UNC;
        this.AZIMUTH_BIAS = AZIMUTH_BIAS;
        this.AZIMUTH_RATE = AZIMUTH_RATE;
        this.ELEVATION = ELEVATION;
        this.ELEVATION_UNC = ELEVATION_UNC;
        this.ELEVATION_BIAS = ELEVATION_BIAS;
        this.ELEVATION_RATE = ELEVATION_RATE;
        this.RANGE = RANGE;
        this.RANGE_UNC = RANGE_UNC;
        this.RANGE_BIAS = RANGE_BIAS;
        this.RANGE_RATE = RANGE_RATE;
        this.RANGE_RATE_UNC = RANGE_RATE_UNC;
        this.RA = RA;
        this.RA_RATE = RA_RATE;
        this.RA_UNC = RA_UNC;
        this.RA_BIAS = RA_BIAS;
        this.DECLINATION = DECLINATION;
        this.DECLINATION_RATE = DECLINATION_RATE;
        this.DECLINATION_UNC = DECLINATION_UNC;
        this.DECLINATION_BIAS = DECLINATION_BIAS;
        this.LOSX = LOSX;
        this.LOSY = LOSY;
        this.LOSZ = LOSZ;
        this.LOS_UNC = LOS_UNC;
        this.LOSXVEL = LOSXVEL;
        this.LOSYVEL = LOSYVEL;
        this.LOSZVEL = LOSZVEL;
        this.SENLAT = SENLAT;
        this.SENLON = SENLON;
        this.SENALT = SENALT;
        this.SENX = SENX;
        this.SENY = SENY;
        this.SENZ = SENZ;
        this.FOV_COUNT = FOV_COUNT;
        this.FOV_COUNT_UCTS = FOV_COUNT_UCTS;
        this.EXP_DURATION = EXP_DURATION;
        this.ZEROPTD = ZEROPTD;
        this.NET_OBJ_SIG = NET_OBJ_SIG;
        this.NET_OBJ_SIG_UNC = NET_OBJ_SIG_UNC;
        this.MAG = MAG;
        this.MAG_UNC = MAG_UNC;
        this.MAG_NORM_RANGE = MAG_NORM_RANGE;
        this.GEOLAT = GEOLAT;
        this.GEOLON = GEOLON;
        this.GEOALT = GEOALT;
        this.GEORANGE = GEORANGE;
        this.SKY_BKGRND = SKY_BKGRND;
        this.PRIMARY_EXTINCTION = PRIMARY_EXTINCTION;
        this.PRIMARY_EXTINCTION_UNC = PRIMARY_EXTINCTION_UNC;
        this.SOLAR_PHASE_ANGLE = SOLAR_PHASE_ANGLE;
        this.SOLAR_EQ_PHASE_ANGLE = SOLAR_EQ_PHASE_ANGLE;
        this.SOLAR_DEC_ANGLE = SOLAR_DEC_ANGLE;
        this.SHUTTER_DELAY = SHUTTER_DELAY;
        this.TIMING_BIAS = TIMING_BIAS;
        this.RAW_FILE_URI = RAW_FILE_URI;
        this.INTENSITY = INTENSITY;
        this.BG_INTENSITY = BG_INTENSITY;
        this.DESCRIPTOR = DESCRIPTOR;
        this.SOURCE = SOURCE;
        this.ORIGIN = ORIGIN;
        this.DATA_MODE = DATA_MODE;
        this.CREATED_AT = CREATED_AT;
        this.CREATED_BY = CREATED_BY;
        this.REFERENCE_FRAME = REFERENCE_FRAME;
        this.SEN_REFERENCE_FRAME = SEN_REFERENCE_FRAME;
        this.UMBRA = UMBRA;
        this.PENUMBRA = PENUMBRA;
        this.ORIG_NETWORK = ORIG_NETWORK;
        this.SOURCE_DL = SOURCE_DL;
        this.TYPE = TYPE;
        this.AZIMUTH_MEASURED = AZIMUTH_MEASURED;
        this.ELEVATION_MEASURED = ELEVATION_MEASURED;
        this.RANGE_MEASURED = RANGE_MEASURED;
        this.RANGERATE_MEASURED = RANGERATE_MEASURED;
        this.RA_MEASURED = RA_MEASURED;
        this.DECLINATION_MEASURED = DECLINATION_MEASURED;
        this.NIIRS = NIIRS;
        this.METERS_PER_PIXEL = METERS_PER_PIXEL;
        this.IMAGE_SNR = IMAGE_SNR;
        this.IMAGE_BIT_DEPTH = IMAGE_BIT_DEPTH;
        this.IMAGE_WIDTH = IMAGE_WIDTH;
        this.IMAGE_HEIGHT = IMAGE_HEIGHT;
        this.IMAGE_COMPRESSION = IMAGE_COMPRESSION;
        this.IMAGE_COMPRESSION_RATIO = IMAGE_COMPRESSION_RATIO;
        this.PROCESSED_IMAGE_URI = PROCESSED_IMAGE_URI;
        this.IMAGE_AUTO_ENHANCED = IMAGE_AUTO_ENHANCED;
        this.MULTI_FRAME_STACKED = MULTI_FRAME_STACKED;
        this.SYNTHETIC_TRACKING_USED = SYNTHETIC_TRACKING_USED;
        this.IMAGE_SHARPNESS = IMAGE_SHARPNESS;
        this.IMAGE_NOISE_STDDEV = IMAGE_NOISE_STDDEV;
        this.IMAGE_CONTRAST = IMAGE_CONTRAST;
        this.IMAGE_DYNAMIC_RANGE = IMAGE_DYNAMIC_RANGE;
        this.IMAGE_ENTROPY = IMAGE_ENTROPY;
        this.BACKGROUND_UNIFORMITY = BACKGROUND_UNIFORMITY;
        this.BACKGROUND_MEAN_LEVEL = BACKGROUND_MEAN_LEVEL;
        this.SATURATED_PIXEL_PERCENT = SATURATED_PIXEL_PERCENT;
        this.DEAD_PIXEL_PERCENT = DEAD_PIXEL_PERCENT;
        this.PSF_FWHM = PSF_FWHM;
        this.CLOUD_COVER_PERCENT = CLOUD_COVER_PERCENT;
        this.CLOUD_DETECTION_CONFIDENCE = CLOUD_DETECTION_CONFIDENCE;
        this.HAZE_PERCENT = HAZE_PERCENT;
        this.AEROSOL_OPTICAL_THICKNESS = AEROSOL_OPTICAL_THICKNESS;
        this.WATER_VAPOR_CONTENT = WATER_VAPOR_CONTENT;
        this.SUN_ELEVATION = SUN_ELEVATION;
        this.SUN_AZIMUTH = SUN_AZIMUTH;
        this.VIEW_ZENITH_ANGLE = VIEW_ZENITH_ANGLE;
        this.VIEW_AZIMUTH_ANGLE = VIEW_AZIMUTH_ANGLE;
        this.OFF_NADIR_ANGLE = OFF_NADIR_ANGLE;
        this.SWATH_WIDTH_KM = SWATH_WIDTH_KM;
        this.MEAN_TERRAIN_ELEVATION = MEAN_TERRAIN_ELEVATION;
        this.TERRAIN_ELEVATION_STDDEV = TERRAIN_ELEVATION_STDDEV;
        this.SHADOW_COVER_PERCENT = SHADOW_COVER_PERCENT;
        this.SUNGLINT_PRESENT = SUNGLINT_PRESENT;
        this.SUNGLINT_PERCENT = SUNGLINT_PERCENT;
        this.SNOW_ICE_COVER_PERCENT = SNOW_ICE_COVER_PERCENT;
        this.VALID_DATA_AREA_KM2 = VALID_DATA_AREA_KM2;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION) : 0);
        const OB_TIME = (this.OB_TIME !== null ? builder.createString(this.OB_TIME) : 0);
        const ID_ON_ORBIT = (this.ID_ON_ORBIT !== null ? builder.createString(this.ID_ON_ORBIT) : 0);
        const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID) : 0);
        const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID) : 0);
        const TRANSACTION_ID = (this.TRANSACTION_ID !== null ? builder.createString(this.TRANSACTION_ID) : 0);
        const IMAGE_SET_ID = (this.IMAGE_SET_ID !== null ? builder.createString(this.IMAGE_SET_ID) : 0);
        const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID) : 0);
        const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID) : 0);
        const RAW_FILE_URI = (this.RAW_FILE_URI !== null ? builder.createString(this.RAW_FILE_URI) : 0);
        const DESCRIPTOR = (this.DESCRIPTOR !== null ? builder.createString(this.DESCRIPTOR) : 0);
        const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE) : 0);
        const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN) : 0);
        const CREATED_AT = (this.CREATED_AT !== null ? builder.createString(this.CREATED_AT) : 0);
        const CREATED_BY = (this.CREATED_BY !== null ? builder.createString(this.CREATED_BY) : 0);
        const ORIG_NETWORK = (this.ORIG_NETWORK !== null ? builder.createString(this.ORIG_NETWORK) : 0);
        const SOURCE_DL = (this.SOURCE_DL !== null ? builder.createString(this.SOURCE_DL) : 0);
        const IMAGE_COMPRESSION = (this.IMAGE_COMPRESSION !== null ? builder.createString(this.IMAGE_COMPRESSION) : 0);
        const PROCESSED_IMAGE_URI = (this.PROCESSED_IMAGE_URI !== null ? builder.createString(this.PROCESSED_IMAGE_URI) : 0);
        return EOO.createEOO(builder, ID, CLASSIFICATION, OB_TIME, this.CORR_QUALITY, ID_ON_ORBIT, SENSOR_ID, this.COLLECT_METHOD, this.NORAD_CAT_ID, TASK_ID, TRANSACTION_ID, IMAGE_SET_ID, this.IMAGE_SET_LENGTH, this.SEQUENCE_ID, this.OB_POSITION, ORIG_OBJECT_ID, ORIG_SENSOR_ID, this.UCT, this.AZIMUTH, this.AZIMUTH_UNC, this.AZIMUTH_BIAS, this.AZIMUTH_RATE, this.ELEVATION, this.ELEVATION_UNC, this.ELEVATION_BIAS, this.ELEVATION_RATE, this.RANGE, this.RANGE_UNC, this.RANGE_BIAS, this.RANGE_RATE, this.RANGE_RATE_UNC, this.RA, this.RA_RATE, this.RA_UNC, this.RA_BIAS, this.DECLINATION, this.DECLINATION_RATE, this.DECLINATION_UNC, this.DECLINATION_BIAS, this.LOSX, this.LOSY, this.LOSZ, this.LOS_UNC, this.LOSXVEL, this.LOSYVEL, this.LOSZVEL, this.SENLAT, this.SENLON, this.SENALT, this.SENX, this.SENY, this.SENZ, this.FOV_COUNT, this.FOV_COUNT_UCTS, this.EXP_DURATION, this.ZEROPTD, this.NET_OBJ_SIG, this.NET_OBJ_SIG_UNC, this.MAG, this.MAG_UNC, this.MAG_NORM_RANGE, this.GEOLAT, this.GEOLON, this.GEOALT, this.GEORANGE, this.SKY_BKGRND, this.PRIMARY_EXTINCTION, this.PRIMARY_EXTINCTION_UNC, this.SOLAR_PHASE_ANGLE, this.SOLAR_EQ_PHASE_ANGLE, this.SOLAR_DEC_ANGLE, this.SHUTTER_DELAY, this.TIMING_BIAS, RAW_FILE_URI, this.INTENSITY, this.BG_INTENSITY, DESCRIPTOR, SOURCE, ORIGIN, this.DATA_MODE, CREATED_AT, CREATED_BY, this.REFERENCE_FRAME, this.SEN_REFERENCE_FRAME, this.UMBRA, this.PENUMBRA, ORIG_NETWORK, SOURCE_DL, this.TYPE, this.AZIMUTH_MEASURED, this.ELEVATION_MEASURED, this.RANGE_MEASURED, this.RANGERATE_MEASURED, this.RA_MEASURED, this.DECLINATION_MEASURED, this.NIIRS, this.METERS_PER_PIXEL, this.IMAGE_SNR, this.IMAGE_BIT_DEPTH, this.IMAGE_WIDTH, this.IMAGE_HEIGHT, IMAGE_COMPRESSION, this.IMAGE_COMPRESSION_RATIO, PROCESSED_IMAGE_URI, this.IMAGE_AUTO_ENHANCED, this.MULTI_FRAME_STACKED, this.SYNTHETIC_TRACKING_USED, this.IMAGE_SHARPNESS, this.IMAGE_NOISE_STDDEV, this.IMAGE_CONTRAST, this.IMAGE_DYNAMIC_RANGE, this.IMAGE_ENTROPY, this.BACKGROUND_UNIFORMITY, this.BACKGROUND_MEAN_LEVEL, this.SATURATED_PIXEL_PERCENT, this.DEAD_PIXEL_PERCENT, this.PSF_FWHM, this.CLOUD_COVER_PERCENT, this.CLOUD_DETECTION_CONFIDENCE, this.HAZE_PERCENT, this.AEROSOL_OPTICAL_THICKNESS, this.WATER_VAPOR_CONTENT, this.SUN_ELEVATION, this.SUN_AZIMUTH, this.VIEW_ZENITH_ANGLE, this.VIEW_AZIMUTH_ANGLE, this.OFF_NADIR_ANGLE, this.SWATH_WIDTH_KM, this.MEAN_TERRAIN_ELEVATION, this.TERRAIN_ELEVATION_STDDEV, this.SHADOW_COVER_PERCENT, this.SUNGLINT_PRESENT, this.SUNGLINT_PERCENT, this.SNOW_ICE_COVER_PERCENT, this.VALID_DATA_AREA_KM2);
    }
}
