// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { CollectMethod } from './CollectMethod.js';
import { DataMode } from './DataMode.js';
import { DeviceType } from './DeviceType.js';
import { ObservationPosition } from './ObservationPosition.js';
import { refFrame } from './refFrame.js';
/**
 * Electro-Optical Observation
 */
export class EOO {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEOO(bb, obj) {
        return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEOO(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$EOO');
    }
    ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CLASSIFICATION(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    OB_TIME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Correlation score of the observation when compared to a known orbit state.
     */
    CORR_QUALITY() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    ID_ON_ORBIT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Accepted Collection Method
     */
    COLLECT_METHOD() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : CollectMethod.SIDEREAL;
    }
    /**
     * 18SDS satellite number. Only list if correlated against the 18SDS catalog.
     */
    NORAD_CAT_ID() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    TASK_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TRANSACTION_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    IMAGE_SET_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * The number of images in an image set.
     */
    IMAGE_SET_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The sequence ID of an image within an image set.
     */
    SEQUENCE_ID() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
     */
    OB_POSITION() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : ObservationPosition.FENCE;
    }
    ORIG_OBJECT_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIG_SENSOR_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Required if correlation is attempted. Indicates whether correlation succeeded.
     */
    UCT() {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Line of sight azimuth angle in degrees and topocentric frame.
     */
    AZIMUTH() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight azimuth angle, in degrees.
     */
    AZIMUTH_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight azimuth angle bias in degrees.
     */
    AZIMUTH_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Rate of change of the line of sight azimuth in degrees per second.
     */
    AZIMUTH_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight elevation in degrees and topocentric frame.
     */
    ELEVATION() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight elevation angle, in degrees.
     */
    ELEVATION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight elevation bias in degrees.
     */
    ELEVATION_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Rate of change of the line of sight elevation in degrees per second.
     */
    ELEVATION_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight range in km. Reported value should include all applicable corrections.
     */
    RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight range, in km.
     */
    RANGE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight range bias in km.
     */
    RANGE_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Range rate in km/s. Reported value should include all applicable corrections.
     */
    RANGE_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight range rate, in km/sec.
     */
    RANGE_RATE_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 62);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension in degrees. Required metric reporting field for EO observations.
     */
    RA() {
        const offset = this.bb.__offset(this.bb_pos, 64);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight right ascension rate of change, in degrees/sec.
     */
    RA_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 66);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight right ascension angle, in degrees.
     */
    RA_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 68);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight right ascension bias in degrees.
     */
    RA_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 70);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Declination in degrees. Required metric reporting field for EO observations.
     */
    DECLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 72);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Line of sight declination rate of change, in degrees/sec.
     */
    DECLINATION_RATE() {
        const offset = this.bb.__offset(this.bb_pos, 74);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line of sight declination angle, in degrees.
     */
    DECLINATION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 76);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor line of sight declination angle bias in degrees.
     */
    DECLINATION_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 78);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSX() {
        const offset = this.bb.__offset(this.bb_pos, 80);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSY() {
        const offset = this.bb.__offset(this.bb_pos, 82);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
     */
    LOSZ() {
        const offset = this.bb.__offset(this.bb_pos, 84);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * One sigma uncertainty in the line-of-sight direction vector components.
     */
    LOS_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 86);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * X-component of the velocity vector along the line of sight, in km/s.
     */
    LOSXVEL() {
        const offset = this.bb.__offset(this.bb_pos, 88);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Y-component of the velocity vector along the line of sight, in km/s.
     */
    LOSYVEL() {
        const offset = this.bb.__offset(this.bb_pos, 90);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Z-component of the velocity vector along the line of sight, in km/s.
     */
    LOSZVEL() {
        const offset = this.bb.__offset(this.bb_pos, 92);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 latitude in decimal degrees at the time of the observation.
     */
    SENLAT() {
        const offset = this.bb.__offset(this.bb_pos, 94);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * WGS-84 longitude in decimal degrees at the time of the observation.
     */
    SENLON() {
        const offset = this.bb.__offset(this.bb_pos, 96);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
     */
    SENALT() {
        const offset = this.bb.__offset(this.bb_pos, 98);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian X position in km at the time of the observation.
     */
    SENX() {
        const offset = this.bb.__offset(this.bb_pos, 100);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian Y position in km at the time of the observation.
     */
    SENY() {
        const offset = this.bb.__offset(this.bb_pos, 102);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Cartesian Z position in km at the time of the observation.
     */
    SENZ() {
        const offset = this.bb.__offset(this.bb_pos, 104);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Total number of satellites in the field of view.
     */
    FOV_COUNT() {
        const offset = this.bb.__offset(this.bb_pos, 106);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of uncorrelated satellites in the field of view (JCO).
     */
    FOV_COUNT_UCTS() {
        const offset = this.bb.__offset(this.bb_pos, 108);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods,
     * the exposure duration should be the total integration time. This field is highly recommended / required if the
     * observations are going to be used for photometric processing.
     */
    EXP_DURATION() {
        const offset = this.bb.__offset(this.bb_pos, 110);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
     */
    ZEROPTD() {
        const offset = this.bb.__offset(this.bb_pos, 112);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Net object signature = counts / EXP_DURATION.
     */
    NET_OBJ_SIG() {
        const offset = this.bb.__offset(this.bb_pos, 114);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Net object signature uncertainty = counts uncertainty / EXP_DURATION.
     */
    NET_OBJ_SIG_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 116);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Measure of observed brightness calibrated against the Gaia G-band.
     */
    MAG() {
        const offset = this.bb.__offset(this.bb_pos, 118);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Uncertainty of the observed brightness.
     */
    MAG_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 120);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * [Definition needed].
     */
    MAG_NORM_RANGE() {
        const offset = this.bb.__offset(this.bb_pos, 122);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range
     * and corresponding viewing geometry. It must NOT be computed from the orbit state.
     */
    GEOLAT() {
        const offset = this.bb.__offset(this.bb_pos, 124);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range
     * and viewing geometry. It must NOT be computed from the orbit state.
     */
    GEOLON() {
        const offset = this.bb.__offset(this.bb_pos, 126);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
     */
    GEOALT() {
        const offset = this.bb.__offset(this.bb_pos, 128);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
     */
    GEORANGE() {
        const offset = this.bb.__offset(this.bb_pos, 130);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently
     * empty part of the night sky.
     */
    SKY_BKGRND() {
        const offset = this.bb.__offset(this.bb_pos, 132);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass
     * to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general,
     * describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical
     * object and the observer.
     */
    PRIMARY_EXTINCTION() {
        const offset = this.bb.__offset(this.bb_pos, 134);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Primary Extinction Coefficient Uncertainty, in Magnitudes.
     */
    PRIMARY_EXTINCTION_UNC() {
        const offset = this.bb.__offset(this.bb_pos, 136);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the
     * calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
     */
    SOLAR_PHASE_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 138);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector
     * onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition)
     * and positive when opening (after the opposition).
     */
    SOLAR_EQ_PHASE_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 140);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Angle from the sun to the equatorial plane.
     */
    SOLAR_DEC_ANGLE() {
        const offset = this.bb.__offset(this.bb_pos, 142);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Shutter delay in seconds.
     */
    SHUTTER_DELAY() {
        const offset = this.bb.__offset(this.bb_pos, 144);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Sensor timing bias in seconds.
     */
    TIMING_BIAS() {
        const offset = this.bb.__offset(this.bb_pos, 146);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    RAW_FILE_URI(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 148);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Intensity of the target for IR observations, in kw/sr/em.
     */
    INTENSITY() {
        const offset = this.bb.__offset(this.bb_pos, 150);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Background intensity for IR observations, in kw/sr/um.
     */
    BG_INTENSITY() {
        const offset = this.bb.__offset(this.bb_pos, 152);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    DESCRIPTOR(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 154);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 156);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    ORIGIN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 158);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
     */
    DATA_MODE() {
        const offset = this.bb.__offset(this.bb_pos, 160);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DataMode.EXERCISE;
    }
    CREATED_AT(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 162);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    CREATED_BY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 164);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
     */
    REFERENCE_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 166);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : refFrame.ECEF;
    }
    /**
     * The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF),
     * unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose).
     * Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
     */
    SEN_REFERENCE_FRAME() {
        const offset = this.bb.__offset(this.bb_pos, 168);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : refFrame.ECEF;
    }
    /**
     * Boolean indicating that the target object was in umbral eclipse at the time of this observation.
     */
    UMBRA() {
        const offset = this.bb.__offset(this.bb_pos, 170);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
     * This field is highly recommended if the observations will be used for photometric processing.
     */
    PENUMBRA() {
        const offset = this.bb.__offset(this.bb_pos, 172);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    ORIG_NETWORK(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 174);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    SOURCE_DL(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 176);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Device Type
     */
    TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 178);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
    }
    /**
     * True if measured, false if computed. Required if azimuth is reported.
     */
    AZIMUTH_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 180);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if elevation is reported.
     */
    ELEVATION_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 182);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if range is reported.
     */
    RANGE_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 184);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if range-rate is reported.
     */
    RANGERATE_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 186);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if right ascension is reported.
     */
    RA_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 188);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * True if measured, false if computed. Required if declination is reported.
     */
    DECLINATION_MEASURED() {
        const offset = this.bb.__offset(this.bb_pos, 190);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startEOO(builder) {
        builder.startObject(94);
    }
    static addId(builder, IDOffset) {
        builder.addFieldOffset(0, IDOffset, 0);
    }
    static addClassification(builder, CLASSIFICATIONOffset) {
        builder.addFieldOffset(1, CLASSIFICATIONOffset, 0);
    }
    static addObTime(builder, OB_TIMEOffset) {
        builder.addFieldOffset(2, OB_TIMEOffset, 0);
    }
    static addCorrQuality(builder, CORR_QUALITY) {
        builder.addFieldFloat32(3, CORR_QUALITY, 0.0);
    }
    static addIdOnOrbit(builder, ID_ON_ORBITOffset) {
        builder.addFieldOffset(4, ID_ON_ORBITOffset, 0);
    }
    static addSensorId(builder, SENSOR_IDOffset) {
        builder.addFieldOffset(5, SENSOR_IDOffset, 0);
    }
    static addCollectMethod(builder, COLLECT_METHOD) {
        builder.addFieldInt8(6, COLLECT_METHOD, CollectMethod.SIDEREAL);
    }
    static addNoradCatId(builder, NORAD_CAT_ID) {
        builder.addFieldInt32(7, NORAD_CAT_ID, 0);
    }
    static addTaskId(builder, TASK_IDOffset) {
        builder.addFieldOffset(8, TASK_IDOffset, 0);
    }
    static addTransactionId(builder, TRANSACTION_IDOffset) {
        builder.addFieldOffset(9, TRANSACTION_IDOffset, 0);
    }
    static addImageSetId(builder, IMAGE_SET_IDOffset) {
        builder.addFieldOffset(10, IMAGE_SET_IDOffset, 0);
    }
    static addImageSetLength(builder, IMAGE_SET_LENGTH) {
        builder.addFieldInt32(11, IMAGE_SET_LENGTH, 0);
    }
    static addSequenceId(builder, SEQUENCE_ID) {
        builder.addFieldInt32(12, SEQUENCE_ID, 0);
    }
    static addObPosition(builder, OB_POSITION) {
        builder.addFieldInt8(13, OB_POSITION, ObservationPosition.FENCE);
    }
    static addOrigObjectId(builder, ORIG_OBJECT_IDOffset) {
        builder.addFieldOffset(14, ORIG_OBJECT_IDOffset, 0);
    }
    static addOrigSensorId(builder, ORIG_SENSOR_IDOffset) {
        builder.addFieldOffset(15, ORIG_SENSOR_IDOffset, 0);
    }
    static addUct(builder, UCT) {
        builder.addFieldInt8(16, +UCT, +false);
    }
    static addAzimuth(builder, AZIMUTH) {
        builder.addFieldFloat32(17, AZIMUTH, 0.0);
    }
    static addAzimuthUnc(builder, AZIMUTH_UNC) {
        builder.addFieldFloat32(18, AZIMUTH_UNC, 0.0);
    }
    static addAzimuthBias(builder, AZIMUTH_BIAS) {
        builder.addFieldFloat32(19, AZIMUTH_BIAS, 0.0);
    }
    static addAzimuthRate(builder, AZIMUTH_RATE) {
        builder.addFieldFloat32(20, AZIMUTH_RATE, 0.0);
    }
    static addElevation(builder, ELEVATION) {
        builder.addFieldFloat32(21, ELEVATION, 0.0);
    }
    static addElevationUnc(builder, ELEVATION_UNC) {
        builder.addFieldFloat32(22, ELEVATION_UNC, 0.0);
    }
    static addElevationBias(builder, ELEVATION_BIAS) {
        builder.addFieldFloat32(23, ELEVATION_BIAS, 0.0);
    }
    static addElevationRate(builder, ELEVATION_RATE) {
        builder.addFieldFloat32(24, ELEVATION_RATE, 0.0);
    }
    static addRange(builder, RANGE) {
        builder.addFieldFloat32(25, RANGE, 0.0);
    }
    static addRangeUnc(builder, RANGE_UNC) {
        builder.addFieldFloat32(26, RANGE_UNC, 0.0);
    }
    static addRangeBias(builder, RANGE_BIAS) {
        builder.addFieldFloat32(27, RANGE_BIAS, 0.0);
    }
    static addRangeRate(builder, RANGE_RATE) {
        builder.addFieldFloat32(28, RANGE_RATE, 0.0);
    }
    static addRangeRateUnc(builder, RANGE_RATE_UNC) {
        builder.addFieldFloat32(29, RANGE_RATE_UNC, 0.0);
    }
    static addRa(builder, RA) {
        builder.addFieldFloat32(30, RA, 0.0);
    }
    static addRaRate(builder, RA_RATE) {
        builder.addFieldFloat32(31, RA_RATE, 0.0);
    }
    static addRaUnc(builder, RA_UNC) {
        builder.addFieldFloat32(32, RA_UNC, 0.0);
    }
    static addRaBias(builder, RA_BIAS) {
        builder.addFieldFloat32(33, RA_BIAS, 0.0);
    }
    static addDeclination(builder, DECLINATION) {
        builder.addFieldFloat32(34, DECLINATION, 0.0);
    }
    static addDeclinationRate(builder, DECLINATION_RATE) {
        builder.addFieldFloat32(35, DECLINATION_RATE, 0.0);
    }
    static addDeclinationUnc(builder, DECLINATION_UNC) {
        builder.addFieldFloat32(36, DECLINATION_UNC, 0.0);
    }
    static addDeclinationBias(builder, DECLINATION_BIAS) {
        builder.addFieldFloat32(37, DECLINATION_BIAS, 0.0);
    }
    static addLosx(builder, LOSX) {
        builder.addFieldFloat32(38, LOSX, 0.0);
    }
    static addLosy(builder, LOSY) {
        builder.addFieldFloat32(39, LOSY, 0.0);
    }
    static addLosz(builder, LOSZ) {
        builder.addFieldFloat32(40, LOSZ, 0.0);
    }
    static addLosUnc(builder, LOS_UNC) {
        builder.addFieldFloat32(41, LOS_UNC, 0.0);
    }
    static addLosxvel(builder, LOSXVEL) {
        builder.addFieldFloat32(42, LOSXVEL, 0.0);
    }
    static addLosyvel(builder, LOSYVEL) {
        builder.addFieldFloat32(43, LOSYVEL, 0.0);
    }
    static addLoszvel(builder, LOSZVEL) {
        builder.addFieldFloat32(44, LOSZVEL, 0.0);
    }
    static addSenlat(builder, SENLAT) {
        builder.addFieldFloat32(45, SENLAT, 0.0);
    }
    static addSenlon(builder, SENLON) {
        builder.addFieldFloat32(46, SENLON, 0.0);
    }
    static addSenalt(builder, SENALT) {
        builder.addFieldFloat32(47, SENALT, 0.0);
    }
    static addSenx(builder, SENX) {
        builder.addFieldFloat32(48, SENX, 0.0);
    }
    static addSeny(builder, SENY) {
        builder.addFieldFloat32(49, SENY, 0.0);
    }
    static addSenz(builder, SENZ) {
        builder.addFieldFloat32(50, SENZ, 0.0);
    }
    static addFovCount(builder, FOV_COUNT) {
        builder.addFieldInt32(51, FOV_COUNT, 0);
    }
    static addFovCountUcts(builder, FOV_COUNT_UCTS) {
        builder.addFieldInt32(52, FOV_COUNT_UCTS, 0);
    }
    static addExpDuration(builder, EXP_DURATION) {
        builder.addFieldFloat32(53, EXP_DURATION, 0.0);
    }
    static addZeroptd(builder, ZEROPTD) {
        builder.addFieldFloat32(54, ZEROPTD, 0.0);
    }
    static addNetObjSig(builder, NET_OBJ_SIG) {
        builder.addFieldFloat32(55, NET_OBJ_SIG, 0.0);
    }
    static addNetObjSigUnc(builder, NET_OBJ_SIG_UNC) {
        builder.addFieldFloat32(56, NET_OBJ_SIG_UNC, 0.0);
    }
    static addMag(builder, MAG) {
        builder.addFieldFloat32(57, MAG, 0.0);
    }
    static addMagUnc(builder, MAG_UNC) {
        builder.addFieldFloat32(58, MAG_UNC, 0.0);
    }
    static addMagNormRange(builder, MAG_NORM_RANGE) {
        builder.addFieldFloat32(59, MAG_NORM_RANGE, 0.0);
    }
    static addGeolat(builder, GEOLAT) {
        builder.addFieldFloat32(60, GEOLAT, 0.0);
    }
    static addGeolon(builder, GEOLON) {
        builder.addFieldFloat32(61, GEOLON, 0.0);
    }
    static addGeoalt(builder, GEOALT) {
        builder.addFieldFloat32(62, GEOALT, 0.0);
    }
    static addGeorange(builder, GEORANGE) {
        builder.addFieldFloat32(63, GEORANGE, 0.0);
    }
    static addSkyBkgrnd(builder, SKY_BKGRND) {
        builder.addFieldFloat32(64, SKY_BKGRND, 0.0);
    }
    static addPrimaryExtinction(builder, PRIMARY_EXTINCTION) {
        builder.addFieldFloat32(65, PRIMARY_EXTINCTION, 0.0);
    }
    static addPrimaryExtinctionUnc(builder, PRIMARY_EXTINCTION_UNC) {
        builder.addFieldFloat32(66, PRIMARY_EXTINCTION_UNC, 0.0);
    }
    static addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE) {
        builder.addFieldFloat32(67, SOLAR_PHASE_ANGLE, 0.0);
    }
    static addSolarEqPhaseAngle(builder, SOLAR_EQ_PHASE_ANGLE) {
        builder.addFieldFloat32(68, SOLAR_EQ_PHASE_ANGLE, 0.0);
    }
    static addSolarDecAngle(builder, SOLAR_DEC_ANGLE) {
        builder.addFieldFloat32(69, SOLAR_DEC_ANGLE, 0.0);
    }
    static addShutterDelay(builder, SHUTTER_DELAY) {
        builder.addFieldFloat32(70, SHUTTER_DELAY, 0.0);
    }
    static addTimingBias(builder, TIMING_BIAS) {
        builder.addFieldFloat32(71, TIMING_BIAS, 0.0);
    }
    static addRawFileUri(builder, RAW_FILE_URIOffset) {
        builder.addFieldOffset(72, RAW_FILE_URIOffset, 0);
    }
    static addIntensity(builder, INTENSITY) {
        builder.addFieldFloat32(73, INTENSITY, 0.0);
    }
    static addBgIntensity(builder, BG_INTENSITY) {
        builder.addFieldFloat32(74, BG_INTENSITY, 0.0);
    }
    static addDescriptor(builder, DESCRIPTOROffset) {
        builder.addFieldOffset(75, DESCRIPTOROffset, 0);
    }
    static addSource(builder, SOURCEOffset) {
        builder.addFieldOffset(76, SOURCEOffset, 0);
    }
    static addOrigin(builder, ORIGINOffset) {
        builder.addFieldOffset(77, ORIGINOffset, 0);
    }
    static addDataMode(builder, DATA_MODE) {
        builder.addFieldInt8(78, DATA_MODE, DataMode.EXERCISE);
    }
    static addCreatedAt(builder, CREATED_ATOffset) {
        builder.addFieldOffset(79, CREATED_ATOffset, 0);
    }
    static addCreatedBy(builder, CREATED_BYOffset) {
        builder.addFieldOffset(80, CREATED_BYOffset, 0);
    }
    static addReferenceFrame(builder, REFERENCE_FRAME) {
        builder.addFieldInt8(81, REFERENCE_FRAME, refFrame.ECEF);
    }
    static addSenReferenceFrame(builder, SEN_REFERENCE_FRAME) {
        builder.addFieldInt8(82, SEN_REFERENCE_FRAME, refFrame.ECEF);
    }
    static addUmbra(builder, UMBRA) {
        builder.addFieldInt8(83, +UMBRA, +false);
    }
    static addPenumbra(builder, PENUMBRA) {
        builder.addFieldInt8(84, +PENUMBRA, +false);
    }
    static addOrigNetwork(builder, ORIG_NETWORKOffset) {
        builder.addFieldOffset(85, ORIG_NETWORKOffset, 0);
    }
    static addSourceDl(builder, SOURCE_DLOffset) {
        builder.addFieldOffset(86, SOURCE_DLOffset, 0);
    }
    static addType(builder, TYPE) {
        builder.addFieldInt8(87, TYPE, DeviceType.UNKNOWN);
    }
    static addAzimuthMeasured(builder, AZIMUTH_MEASURED) {
        builder.addFieldInt8(88, +AZIMUTH_MEASURED, +false);
    }
    static addElevationMeasured(builder, ELEVATION_MEASURED) {
        builder.addFieldInt8(89, +ELEVATION_MEASURED, +false);
    }
    static addRangeMeasured(builder, RANGE_MEASURED) {
        builder.addFieldInt8(90, +RANGE_MEASURED, +false);
    }
    static addRangerateMeasured(builder, RANGERATE_MEASURED) {
        builder.addFieldInt8(91, +RANGERATE_MEASURED, +false);
    }
    static addRaMeasured(builder, RA_MEASURED) {
        builder.addFieldInt8(92, +RA_MEASURED, +false);
    }
    static addDeclinationMeasured(builder, DECLINATION_MEASURED) {
        builder.addFieldInt8(93, +DECLINATION_MEASURED, +false);
    }
    static endEOO(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishEOOBuffer(builder, offset) {
        builder.finish(offset, '$EOO');
    }
    static finishSizePrefixedEOOBuffer(builder, offset) {
        builder.finish(offset, '$EOO', true);
    }
    static createEOO(builder, IDOffset, CLASSIFICATIONOffset, OB_TIMEOffset, CORR_QUALITY, ID_ON_ORBITOffset, SENSOR_IDOffset, COLLECT_METHOD, NORAD_CAT_ID, TASK_IDOffset, TRANSACTION_IDOffset, IMAGE_SET_IDOffset, IMAGE_SET_LENGTH, SEQUENCE_ID, OB_POSITION, ORIG_OBJECT_IDOffset, ORIG_SENSOR_IDOffset, UCT, AZIMUTH, AZIMUTH_UNC, AZIMUTH_BIAS, AZIMUTH_RATE, ELEVATION, ELEVATION_UNC, ELEVATION_BIAS, ELEVATION_RATE, RANGE, RANGE_UNC, RANGE_BIAS, RANGE_RATE, RANGE_RATE_UNC, RA, RA_RATE, RA_UNC, RA_BIAS, DECLINATION, DECLINATION_RATE, DECLINATION_UNC, DECLINATION_BIAS, LOSX, LOSY, LOSZ, LOS_UNC, LOSXVEL, LOSYVEL, LOSZVEL, SENLAT, SENLON, SENALT, SENX, SENY, SENZ, FOV_COUNT, FOV_COUNT_UCTS, EXP_DURATION, ZEROPTD, NET_OBJ_SIG, NET_OBJ_SIG_UNC, MAG, MAG_UNC, MAG_NORM_RANGE, GEOLAT, GEOLON, GEOALT, GEORANGE, SKY_BKGRND, PRIMARY_EXTINCTION, PRIMARY_EXTINCTION_UNC, SOLAR_PHASE_ANGLE, SOLAR_EQ_PHASE_ANGLE, SOLAR_DEC_ANGLE, SHUTTER_DELAY, TIMING_BIAS, RAW_FILE_URIOffset, INTENSITY, BG_INTENSITY, DESCRIPTOROffset, SOURCEOffset, ORIGINOffset, DATA_MODE, CREATED_ATOffset, CREATED_BYOffset, REFERENCE_FRAME, SEN_REFERENCE_FRAME, UMBRA, PENUMBRA, ORIG_NETWORKOffset, SOURCE_DLOffset, TYPE, AZIMUTH_MEASURED, ELEVATION_MEASURED, RANGE_MEASURED, RANGERATE_MEASURED, RA_MEASURED, DECLINATION_MEASURED) {
        EOO.startEOO(builder);
        EOO.addId(builder, IDOffset);
        EOO.addClassification(builder, CLASSIFICATIONOffset);
        EOO.addObTime(builder, OB_TIMEOffset);
        EOO.addCorrQuality(builder, CORR_QUALITY);
        EOO.addIdOnOrbit(builder, ID_ON_ORBITOffset);
        EOO.addSensorId(builder, SENSOR_IDOffset);
        EOO.addCollectMethod(builder, COLLECT_METHOD);
        EOO.addNoradCatId(builder, NORAD_CAT_ID);
        EOO.addTaskId(builder, TASK_IDOffset);
        EOO.addTransactionId(builder, TRANSACTION_IDOffset);
        EOO.addImageSetId(builder, IMAGE_SET_IDOffset);
        EOO.addImageSetLength(builder, IMAGE_SET_LENGTH);
        EOO.addSequenceId(builder, SEQUENCE_ID);
        EOO.addObPosition(builder, OB_POSITION);
        EOO.addOrigObjectId(builder, ORIG_OBJECT_IDOffset);
        EOO.addOrigSensorId(builder, ORIG_SENSOR_IDOffset);
        EOO.addUct(builder, UCT);
        EOO.addAzimuth(builder, AZIMUTH);
        EOO.addAzimuthUnc(builder, AZIMUTH_UNC);
        EOO.addAzimuthBias(builder, AZIMUTH_BIAS);
        EOO.addAzimuthRate(builder, AZIMUTH_RATE);
        EOO.addElevation(builder, ELEVATION);
        EOO.addElevationUnc(builder, ELEVATION_UNC);
        EOO.addElevationBias(builder, ELEVATION_BIAS);
        EOO.addElevationRate(builder, ELEVATION_RATE);
        EOO.addRange(builder, RANGE);
        EOO.addRangeUnc(builder, RANGE_UNC);
        EOO.addRangeBias(builder, RANGE_BIAS);
        EOO.addRangeRate(builder, RANGE_RATE);
        EOO.addRangeRateUnc(builder, RANGE_RATE_UNC);
        EOO.addRa(builder, RA);
        EOO.addRaRate(builder, RA_RATE);
        EOO.addRaUnc(builder, RA_UNC);
        EOO.addRaBias(builder, RA_BIAS);
        EOO.addDeclination(builder, DECLINATION);
        EOO.addDeclinationRate(builder, DECLINATION_RATE);
        EOO.addDeclinationUnc(builder, DECLINATION_UNC);
        EOO.addDeclinationBias(builder, DECLINATION_BIAS);
        EOO.addLosx(builder, LOSX);
        EOO.addLosy(builder, LOSY);
        EOO.addLosz(builder, LOSZ);
        EOO.addLosUnc(builder, LOS_UNC);
        EOO.addLosxvel(builder, LOSXVEL);
        EOO.addLosyvel(builder, LOSYVEL);
        EOO.addLoszvel(builder, LOSZVEL);
        EOO.addSenlat(builder, SENLAT);
        EOO.addSenlon(builder, SENLON);
        EOO.addSenalt(builder, SENALT);
        EOO.addSenx(builder, SENX);
        EOO.addSeny(builder, SENY);
        EOO.addSenz(builder, SENZ);
        EOO.addFovCount(builder, FOV_COUNT);
        EOO.addFovCountUcts(builder, FOV_COUNT_UCTS);
        EOO.addExpDuration(builder, EXP_DURATION);
        EOO.addZeroptd(builder, ZEROPTD);
        EOO.addNetObjSig(builder, NET_OBJ_SIG);
        EOO.addNetObjSigUnc(builder, NET_OBJ_SIG_UNC);
        EOO.addMag(builder, MAG);
        EOO.addMagUnc(builder, MAG_UNC);
        EOO.addMagNormRange(builder, MAG_NORM_RANGE);
        EOO.addGeolat(builder, GEOLAT);
        EOO.addGeolon(builder, GEOLON);
        EOO.addGeoalt(builder, GEOALT);
        EOO.addGeorange(builder, GEORANGE);
        EOO.addSkyBkgrnd(builder, SKY_BKGRND);
        EOO.addPrimaryExtinction(builder, PRIMARY_EXTINCTION);
        EOO.addPrimaryExtinctionUnc(builder, PRIMARY_EXTINCTION_UNC);
        EOO.addSolarPhaseAngle(builder, SOLAR_PHASE_ANGLE);
        EOO.addSolarEqPhaseAngle(builder, SOLAR_EQ_PHASE_ANGLE);
        EOO.addSolarDecAngle(builder, SOLAR_DEC_ANGLE);
        EOO.addShutterDelay(builder, SHUTTER_DELAY);
        EOO.addTimingBias(builder, TIMING_BIAS);
        EOO.addRawFileUri(builder, RAW_FILE_URIOffset);
        EOO.addIntensity(builder, INTENSITY);
        EOO.addBgIntensity(builder, BG_INTENSITY);
        EOO.addDescriptor(builder, DESCRIPTOROffset);
        EOO.addSource(builder, SOURCEOffset);
        EOO.addOrigin(builder, ORIGINOffset);
        EOO.addDataMode(builder, DATA_MODE);
        EOO.addCreatedAt(builder, CREATED_ATOffset);
        EOO.addCreatedBy(builder, CREATED_BYOffset);
        EOO.addReferenceFrame(builder, REFERENCE_FRAME);
        EOO.addSenReferenceFrame(builder, SEN_REFERENCE_FRAME);
        EOO.addUmbra(builder, UMBRA);
        EOO.addPenumbra(builder, PENUMBRA);
        EOO.addOrigNetwork(builder, ORIG_NETWORKOffset);
        EOO.addSourceDl(builder, SOURCE_DLOffset);
        EOO.addType(builder, TYPE);
        EOO.addAzimuthMeasured(builder, AZIMUTH_MEASURED);
        EOO.addElevationMeasured(builder, ELEVATION_MEASURED);
        EOO.addRangeMeasured(builder, RANGE_MEASURED);
        EOO.addRangerateMeasured(builder, RANGERATE_MEASURED);
        EOO.addRaMeasured(builder, RA_MEASURED);
        EOO.addDeclinationMeasured(builder, DECLINATION_MEASURED);
        return EOO.endEOO(builder);
    }
    unpack() {
        return new EOOT(this.ID(), this.CLASSIFICATION(), this.OB_TIME(), this.CORR_QUALITY(), this.ID_ON_ORBIT(), this.SENSOR_ID(), this.COLLECT_METHOD(), this.NORAD_CAT_ID(), this.TASK_ID(), this.TRANSACTION_ID(), this.IMAGE_SET_ID(), this.IMAGE_SET_LENGTH(), this.SEQUENCE_ID(), this.OB_POSITION(), this.ORIG_OBJECT_ID(), this.ORIG_SENSOR_ID(), this.UCT(), this.AZIMUTH(), this.AZIMUTH_UNC(), this.AZIMUTH_BIAS(), this.AZIMUTH_RATE(), this.ELEVATION(), this.ELEVATION_UNC(), this.ELEVATION_BIAS(), this.ELEVATION_RATE(), this.RANGE(), this.RANGE_UNC(), this.RANGE_BIAS(), this.RANGE_RATE(), this.RANGE_RATE_UNC(), this.RA(), this.RA_RATE(), this.RA_UNC(), this.RA_BIAS(), this.DECLINATION(), this.DECLINATION_RATE(), this.DECLINATION_UNC(), this.DECLINATION_BIAS(), this.LOSX(), this.LOSY(), this.LOSZ(), this.LOS_UNC(), this.LOSXVEL(), this.LOSYVEL(), this.LOSZVEL(), this.SENLAT(), this.SENLON(), this.SENALT(), this.SENX(), this.SENY(), this.SENZ(), this.FOV_COUNT(), this.FOV_COUNT_UCTS(), this.EXP_DURATION(), this.ZEROPTD(), this.NET_OBJ_SIG(), this.NET_OBJ_SIG_UNC(), this.MAG(), this.MAG_UNC(), this.MAG_NORM_RANGE(), this.GEOLAT(), this.GEOLON(), this.GEOALT(), this.GEORANGE(), this.SKY_BKGRND(), this.PRIMARY_EXTINCTION(), this.PRIMARY_EXTINCTION_UNC(), this.SOLAR_PHASE_ANGLE(), this.SOLAR_EQ_PHASE_ANGLE(), this.SOLAR_DEC_ANGLE(), this.SHUTTER_DELAY(), this.TIMING_BIAS(), this.RAW_FILE_URI(), this.INTENSITY(), this.BG_INTENSITY(), this.DESCRIPTOR(), this.SOURCE(), this.ORIGIN(), this.DATA_MODE(), this.CREATED_AT(), this.CREATED_BY(), this.REFERENCE_FRAME(), this.SEN_REFERENCE_FRAME(), this.UMBRA(), this.PENUMBRA(), this.ORIG_NETWORK(), this.SOURCE_DL(), this.TYPE(), this.AZIMUTH_MEASURED(), this.ELEVATION_MEASURED(), this.RANGE_MEASURED(), this.RANGERATE_MEASURED(), this.RA_MEASURED(), this.DECLINATION_MEASURED());
    }
    unpackTo(_o) {
        _o.ID = this.ID();
        _o.CLASSIFICATION = this.CLASSIFICATION();
        _o.OB_TIME = this.OB_TIME();
        _o.CORR_QUALITY = this.CORR_QUALITY();
        _o.ID_ON_ORBIT = this.ID_ON_ORBIT();
        _o.SENSOR_ID = this.SENSOR_ID();
        _o.COLLECT_METHOD = this.COLLECT_METHOD();
        _o.NORAD_CAT_ID = this.NORAD_CAT_ID();
        _o.TASK_ID = this.TASK_ID();
        _o.TRANSACTION_ID = this.TRANSACTION_ID();
        _o.IMAGE_SET_ID = this.IMAGE_SET_ID();
        _o.IMAGE_SET_LENGTH = this.IMAGE_SET_LENGTH();
        _o.SEQUENCE_ID = this.SEQUENCE_ID();
        _o.OB_POSITION = this.OB_POSITION();
        _o.ORIG_OBJECT_ID = this.ORIG_OBJECT_ID();
        _o.ORIG_SENSOR_ID = this.ORIG_SENSOR_ID();
        _o.UCT = this.UCT();
        _o.AZIMUTH = this.AZIMUTH();
        _o.AZIMUTH_UNC = this.AZIMUTH_UNC();
        _o.AZIMUTH_BIAS = this.AZIMUTH_BIAS();
        _o.AZIMUTH_RATE = this.AZIMUTH_RATE();
        _o.ELEVATION = this.ELEVATION();
        _o.ELEVATION_UNC = this.ELEVATION_UNC();
        _o.ELEVATION_BIAS = this.ELEVATION_BIAS();
        _o.ELEVATION_RATE = this.ELEVATION_RATE();
        _o.RANGE = this.RANGE();
        _o.RANGE_UNC = this.RANGE_UNC();
        _o.RANGE_BIAS = this.RANGE_BIAS();
        _o.RANGE_RATE = this.RANGE_RATE();
        _o.RANGE_RATE_UNC = this.RANGE_RATE_UNC();
        _o.RA = this.RA();
        _o.RA_RATE = this.RA_RATE();
        _o.RA_UNC = this.RA_UNC();
        _o.RA_BIAS = this.RA_BIAS();
        _o.DECLINATION = this.DECLINATION();
        _o.DECLINATION_RATE = this.DECLINATION_RATE();
        _o.DECLINATION_UNC = this.DECLINATION_UNC();
        _o.DECLINATION_BIAS = this.DECLINATION_BIAS();
        _o.LOSX = this.LOSX();
        _o.LOSY = this.LOSY();
        _o.LOSZ = this.LOSZ();
        _o.LOS_UNC = this.LOS_UNC();
        _o.LOSXVEL = this.LOSXVEL();
        _o.LOSYVEL = this.LOSYVEL();
        _o.LOSZVEL = this.LOSZVEL();
        _o.SENLAT = this.SENLAT();
        _o.SENLON = this.SENLON();
        _o.SENALT = this.SENALT();
        _o.SENX = this.SENX();
        _o.SENY = this.SENY();
        _o.SENZ = this.SENZ();
        _o.FOV_COUNT = this.FOV_COUNT();
        _o.FOV_COUNT_UCTS = this.FOV_COUNT_UCTS();
        _o.EXP_DURATION = this.EXP_DURATION();
        _o.ZEROPTD = this.ZEROPTD();
        _o.NET_OBJ_SIG = this.NET_OBJ_SIG();
        _o.NET_OBJ_SIG_UNC = this.NET_OBJ_SIG_UNC();
        _o.MAG = this.MAG();
        _o.MAG_UNC = this.MAG_UNC();
        _o.MAG_NORM_RANGE = this.MAG_NORM_RANGE();
        _o.GEOLAT = this.GEOLAT();
        _o.GEOLON = this.GEOLON();
        _o.GEOALT = this.GEOALT();
        _o.GEORANGE = this.GEORANGE();
        _o.SKY_BKGRND = this.SKY_BKGRND();
        _o.PRIMARY_EXTINCTION = this.PRIMARY_EXTINCTION();
        _o.PRIMARY_EXTINCTION_UNC = this.PRIMARY_EXTINCTION_UNC();
        _o.SOLAR_PHASE_ANGLE = this.SOLAR_PHASE_ANGLE();
        _o.SOLAR_EQ_PHASE_ANGLE = this.SOLAR_EQ_PHASE_ANGLE();
        _o.SOLAR_DEC_ANGLE = this.SOLAR_DEC_ANGLE();
        _o.SHUTTER_DELAY = this.SHUTTER_DELAY();
        _o.TIMING_BIAS = this.TIMING_BIAS();
        _o.RAW_FILE_URI = this.RAW_FILE_URI();
        _o.INTENSITY = this.INTENSITY();
        _o.BG_INTENSITY = this.BG_INTENSITY();
        _o.DESCRIPTOR = this.DESCRIPTOR();
        _o.SOURCE = this.SOURCE();
        _o.ORIGIN = this.ORIGIN();
        _o.DATA_MODE = this.DATA_MODE();
        _o.CREATED_AT = this.CREATED_AT();
        _o.CREATED_BY = this.CREATED_BY();
        _o.REFERENCE_FRAME = this.REFERENCE_FRAME();
        _o.SEN_REFERENCE_FRAME = this.SEN_REFERENCE_FRAME();
        _o.UMBRA = this.UMBRA();
        _o.PENUMBRA = this.PENUMBRA();
        _o.ORIG_NETWORK = this.ORIG_NETWORK();
        _o.SOURCE_DL = this.SOURCE_DL();
        _o.TYPE = this.TYPE();
        _o.AZIMUTH_MEASURED = this.AZIMUTH_MEASURED();
        _o.ELEVATION_MEASURED = this.ELEVATION_MEASURED();
        _o.RANGE_MEASURED = this.RANGE_MEASURED();
        _o.RANGERATE_MEASURED = this.RANGERATE_MEASURED();
        _o.RA_MEASURED = this.RA_MEASURED();
        _o.DECLINATION_MEASURED = this.DECLINATION_MEASURED();
    }
}
export class EOOT {
    constructor(ID = null, CLASSIFICATION = null, OB_TIME = null, CORR_QUALITY = 0.0, ID_ON_ORBIT = null, SENSOR_ID = null, COLLECT_METHOD = CollectMethod.SIDEREAL, NORAD_CAT_ID = 0, TASK_ID = null, TRANSACTION_ID = null, IMAGE_SET_ID = null, IMAGE_SET_LENGTH = 0, SEQUENCE_ID = 0, OB_POSITION = ObservationPosition.FENCE, ORIG_OBJECT_ID = null, ORIG_SENSOR_ID = null, UCT = false, AZIMUTH = 0.0, AZIMUTH_UNC = 0.0, AZIMUTH_BIAS = 0.0, AZIMUTH_RATE = 0.0, ELEVATION = 0.0, ELEVATION_UNC = 0.0, ELEVATION_BIAS = 0.0, ELEVATION_RATE = 0.0, RANGE = 0.0, RANGE_UNC = 0.0, RANGE_BIAS = 0.0, RANGE_RATE = 0.0, RANGE_RATE_UNC = 0.0, RA = 0.0, RA_RATE = 0.0, RA_UNC = 0.0, RA_BIAS = 0.0, DECLINATION = 0.0, DECLINATION_RATE = 0.0, DECLINATION_UNC = 0.0, DECLINATION_BIAS = 0.0, LOSX = 0.0, LOSY = 0.0, LOSZ = 0.0, LOS_UNC = 0.0, LOSXVEL = 0.0, LOSYVEL = 0.0, LOSZVEL = 0.0, SENLAT = 0.0, SENLON = 0.0, SENALT = 0.0, SENX = 0.0, SENY = 0.0, SENZ = 0.0, FOV_COUNT = 0, FOV_COUNT_UCTS = 0, EXP_DURATION = 0.0, ZEROPTD = 0.0, NET_OBJ_SIG = 0.0, NET_OBJ_SIG_UNC = 0.0, MAG = 0.0, MAG_UNC = 0.0, MAG_NORM_RANGE = 0.0, GEOLAT = 0.0, GEOLON = 0.0, GEOALT = 0.0, GEORANGE = 0.0, SKY_BKGRND = 0.0, PRIMARY_EXTINCTION = 0.0, PRIMARY_EXTINCTION_UNC = 0.0, SOLAR_PHASE_ANGLE = 0.0, SOLAR_EQ_PHASE_ANGLE = 0.0, SOLAR_DEC_ANGLE = 0.0, SHUTTER_DELAY = 0.0, TIMING_BIAS = 0.0, RAW_FILE_URI = null, INTENSITY = 0.0, BG_INTENSITY = 0.0, DESCRIPTOR = null, SOURCE = null, ORIGIN = null, DATA_MODE = DataMode.EXERCISE, CREATED_AT = null, CREATED_BY = null, REFERENCE_FRAME = refFrame.ECEF, SEN_REFERENCE_FRAME = refFrame.ECEF, UMBRA = false, PENUMBRA = false, ORIG_NETWORK = null, SOURCE_DL = null, TYPE = DeviceType.UNKNOWN, AZIMUTH_MEASURED = false, ELEVATION_MEASURED = false, RANGE_MEASURED = false, RANGERATE_MEASURED = false, RA_MEASURED = false, DECLINATION_MEASURED = false) {
        this.ID = ID;
        this.CLASSIFICATION = CLASSIFICATION;
        this.OB_TIME = OB_TIME;
        this.CORR_QUALITY = CORR_QUALITY;
        this.ID_ON_ORBIT = ID_ON_ORBIT;
        this.SENSOR_ID = SENSOR_ID;
        this.COLLECT_METHOD = COLLECT_METHOD;
        this.NORAD_CAT_ID = NORAD_CAT_ID;
        this.TASK_ID = TASK_ID;
        this.TRANSACTION_ID = TRANSACTION_ID;
        this.IMAGE_SET_ID = IMAGE_SET_ID;
        this.IMAGE_SET_LENGTH = IMAGE_SET_LENGTH;
        this.SEQUENCE_ID = SEQUENCE_ID;
        this.OB_POSITION = OB_POSITION;
        this.ORIG_OBJECT_ID = ORIG_OBJECT_ID;
        this.ORIG_SENSOR_ID = ORIG_SENSOR_ID;
        this.UCT = UCT;
        this.AZIMUTH = AZIMUTH;
        this.AZIMUTH_UNC = AZIMUTH_UNC;
        this.AZIMUTH_BIAS = AZIMUTH_BIAS;
        this.AZIMUTH_RATE = AZIMUTH_RATE;
        this.ELEVATION = ELEVATION;
        this.ELEVATION_UNC = ELEVATION_UNC;
        this.ELEVATION_BIAS = ELEVATION_BIAS;
        this.ELEVATION_RATE = ELEVATION_RATE;
        this.RANGE = RANGE;
        this.RANGE_UNC = RANGE_UNC;
        this.RANGE_BIAS = RANGE_BIAS;
        this.RANGE_RATE = RANGE_RATE;
        this.RANGE_RATE_UNC = RANGE_RATE_UNC;
        this.RA = RA;
        this.RA_RATE = RA_RATE;
        this.RA_UNC = RA_UNC;
        this.RA_BIAS = RA_BIAS;
        this.DECLINATION = DECLINATION;
        this.DECLINATION_RATE = DECLINATION_RATE;
        this.DECLINATION_UNC = DECLINATION_UNC;
        this.DECLINATION_BIAS = DECLINATION_BIAS;
        this.LOSX = LOSX;
        this.LOSY = LOSY;
        this.LOSZ = LOSZ;
        this.LOS_UNC = LOS_UNC;
        this.LOSXVEL = LOSXVEL;
        this.LOSYVEL = LOSYVEL;
        this.LOSZVEL = LOSZVEL;
        this.SENLAT = SENLAT;
        this.SENLON = SENLON;
        this.SENALT = SENALT;
        this.SENX = SENX;
        this.SENY = SENY;
        this.SENZ = SENZ;
        this.FOV_COUNT = FOV_COUNT;
        this.FOV_COUNT_UCTS = FOV_COUNT_UCTS;
        this.EXP_DURATION = EXP_DURATION;
        this.ZEROPTD = ZEROPTD;
        this.NET_OBJ_SIG = NET_OBJ_SIG;
        this.NET_OBJ_SIG_UNC = NET_OBJ_SIG_UNC;
        this.MAG = MAG;
        this.MAG_UNC = MAG_UNC;
        this.MAG_NORM_RANGE = MAG_NORM_RANGE;
        this.GEOLAT = GEOLAT;
        this.GEOLON = GEOLON;
        this.GEOALT = GEOALT;
        this.GEORANGE = GEORANGE;
        this.SKY_BKGRND = SKY_BKGRND;
        this.PRIMARY_EXTINCTION = PRIMARY_EXTINCTION;
        this.PRIMARY_EXTINCTION_UNC = PRIMARY_EXTINCTION_UNC;
        this.SOLAR_PHASE_ANGLE = SOLAR_PHASE_ANGLE;
        this.SOLAR_EQ_PHASE_ANGLE = SOLAR_EQ_PHASE_ANGLE;
        this.SOLAR_DEC_ANGLE = SOLAR_DEC_ANGLE;
        this.SHUTTER_DELAY = SHUTTER_DELAY;
        this.TIMING_BIAS = TIMING_BIAS;
        this.RAW_FILE_URI = RAW_FILE_URI;
        this.INTENSITY = INTENSITY;
        this.BG_INTENSITY = BG_INTENSITY;
        this.DESCRIPTOR = DESCRIPTOR;
        this.SOURCE = SOURCE;
        this.ORIGIN = ORIGIN;
        this.DATA_MODE = DATA_MODE;
        this.CREATED_AT = CREATED_AT;
        this.CREATED_BY = CREATED_BY;
        this.REFERENCE_FRAME = REFERENCE_FRAME;
        this.SEN_REFERENCE_FRAME = SEN_REFERENCE_FRAME;
        this.UMBRA = UMBRA;
        this.PENUMBRA = PENUMBRA;
        this.ORIG_NETWORK = ORIG_NETWORK;
        this.SOURCE_DL = SOURCE_DL;
        this.TYPE = TYPE;
        this.AZIMUTH_MEASURED = AZIMUTH_MEASURED;
        this.ELEVATION_MEASURED = ELEVATION_MEASURED;
        this.RANGE_MEASURED = RANGE_MEASURED;
        this.RANGERATE_MEASURED = RANGERATE_MEASURED;
        this.RA_MEASURED = RA_MEASURED;
        this.DECLINATION_MEASURED = DECLINATION_MEASURED;
    }
    pack(builder) {
        const ID = (this.ID !== null ? builder.createString(this.ID) : 0);
        const CLASSIFICATION = (this.CLASSIFICATION !== null ? builder.createString(this.CLASSIFICATION) : 0);
        const OB_TIME = (this.OB_TIME !== null ? builder.createString(this.OB_TIME) : 0);
        const ID_ON_ORBIT = (this.ID_ON_ORBIT !== null ? builder.createString(this.ID_ON_ORBIT) : 0);
        const SENSOR_ID = (this.SENSOR_ID !== null ? builder.createString(this.SENSOR_ID) : 0);
        const TASK_ID = (this.TASK_ID !== null ? builder.createString(this.TASK_ID) : 0);
        const TRANSACTION_ID = (this.TRANSACTION_ID !== null ? builder.createString(this.TRANSACTION_ID) : 0);
        const IMAGE_SET_ID = (this.IMAGE_SET_ID !== null ? builder.createString(this.IMAGE_SET_ID) : 0);
        const ORIG_OBJECT_ID = (this.ORIG_OBJECT_ID !== null ? builder.createString(this.ORIG_OBJECT_ID) : 0);
        const ORIG_SENSOR_ID = (this.ORIG_SENSOR_ID !== null ? builder.createString(this.ORIG_SENSOR_ID) : 0);
        const RAW_FILE_URI = (this.RAW_FILE_URI !== null ? builder.createString(this.RAW_FILE_URI) : 0);
        const DESCRIPTOR = (this.DESCRIPTOR !== null ? builder.createString(this.DESCRIPTOR) : 0);
        const SOURCE = (this.SOURCE !== null ? builder.createString(this.SOURCE) : 0);
        const ORIGIN = (this.ORIGIN !== null ? builder.createString(this.ORIGIN) : 0);
        const CREATED_AT = (this.CREATED_AT !== null ? builder.createString(this.CREATED_AT) : 0);
        const CREATED_BY = (this.CREATED_BY !== null ? builder.createString(this.CREATED_BY) : 0);
        const ORIG_NETWORK = (this.ORIG_NETWORK !== null ? builder.createString(this.ORIG_NETWORK) : 0);
        const SOURCE_DL = (this.SOURCE_DL !== null ? builder.createString(this.SOURCE_DL) : 0);
        return EOO.createEOO(builder, ID, CLASSIFICATION, OB_TIME, this.CORR_QUALITY, ID_ON_ORBIT, SENSOR_ID, this.COLLECT_METHOD, this.NORAD_CAT_ID, TASK_ID, TRANSACTION_ID, IMAGE_SET_ID, this.IMAGE_SET_LENGTH, this.SEQUENCE_ID, this.OB_POSITION, ORIG_OBJECT_ID, ORIG_SENSOR_ID, this.UCT, this.AZIMUTH, this.AZIMUTH_UNC, this.AZIMUTH_BIAS, this.AZIMUTH_RATE, this.ELEVATION, this.ELEVATION_UNC, this.ELEVATION_BIAS, this.ELEVATION_RATE, this.RANGE, this.RANGE_UNC, this.RANGE_BIAS, this.RANGE_RATE, this.RANGE_RATE_UNC, this.RA, this.RA_RATE, this.RA_UNC, this.RA_BIAS, this.DECLINATION, this.DECLINATION_RATE, this.DECLINATION_UNC, this.DECLINATION_BIAS, this.LOSX, this.LOSY, this.LOSZ, this.LOS_UNC, this.LOSXVEL, this.LOSYVEL, this.LOSZVEL, this.SENLAT, this.SENLON, this.SENALT, this.SENX, this.SENY, this.SENZ, this.FOV_COUNT, this.FOV_COUNT_UCTS, this.EXP_DURATION, this.ZEROPTD, this.NET_OBJ_SIG, this.NET_OBJ_SIG_UNC, this.MAG, this.MAG_UNC, this.MAG_NORM_RANGE, this.GEOLAT, this.GEOLON, this.GEOALT, this.GEORANGE, this.SKY_BKGRND, this.PRIMARY_EXTINCTION, this.PRIMARY_EXTINCTION_UNC, this.SOLAR_PHASE_ANGLE, this.SOLAR_EQ_PHASE_ANGLE, this.SOLAR_DEC_ANGLE, this.SHUTTER_DELAY, this.TIMING_BIAS, RAW_FILE_URI, this.INTENSITY, this.BG_INTENSITY, DESCRIPTOR, SOURCE, ORIGIN, this.DATA_MODE, CREATED_AT, CREATED_BY, this.REFERENCE_FRAME, this.SEN_REFERENCE_FRAME, this.UMBRA, this.PENUMBRA, ORIG_NETWORK, SOURCE_DL, this.TYPE, this.AZIMUTH_MEASURED, this.ELEVATION_MEASURED, this.RANGE_MEASURED, this.RANGERATE_MEASURED, this.RA_MEASURED, this.DECLINATION_MEASURED);
    }
}
