// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
/**
 * Publish Notification Message
 */
export class PNM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPNM(bb, obj) {
        return (obj || new PNM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPNM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PNM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$PNM');
    }
    IPFS_CID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    KEY_ADDRESS(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    FILE_IDENTIFIER(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startPNM(builder) {
        builder.startObject(3);
    }
    static addIpfsCid(builder, IPFS_CIDOffset) {
        builder.addFieldOffset(0, IPFS_CIDOffset, 0);
    }
    static addKeyAddress(builder, KEY_ADDRESSOffset) {
        builder.addFieldOffset(1, KEY_ADDRESSOffset, 0);
    }
    static addFileIdentifier(builder, FILE_IDENTIFIEROffset) {
        builder.addFieldOffset(2, FILE_IDENTIFIEROffset, 0);
    }
    static endPNM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishPNMBuffer(builder, offset) {
        builder.finish(offset, '$PNM');
    }
    static finishSizePrefixedPNMBuffer(builder, offset) {
        builder.finish(offset, '$PNM', true);
    }
    static createPNM(builder, IPFS_CIDOffset, KEY_ADDRESSOffset, FILE_IDENTIFIEROffset) {
        PNM.startPNM(builder);
        PNM.addIpfsCid(builder, IPFS_CIDOffset);
        PNM.addKeyAddress(builder, KEY_ADDRESSOffset);
        PNM.addFileIdentifier(builder, FILE_IDENTIFIEROffset);
        return PNM.endPNM(builder);
    }
    unpack() {
        return new PNMT(this.IPFS_CID(), this.KEY_ADDRESS(), this.FILE_IDENTIFIER());
    }
    unpackTo(_o) {
        _o.IPFS_CID = this.IPFS_CID();
        _o.KEY_ADDRESS = this.KEY_ADDRESS();
        _o.FILE_IDENTIFIER = this.FILE_IDENTIFIER();
    }
}
export class PNMT {
    constructor(IPFS_CID = null, KEY_ADDRESS = null, FILE_IDENTIFIER = null) {
        this.IPFS_CID = IPFS_CID;
        this.KEY_ADDRESS = KEY_ADDRESS;
        this.FILE_IDENTIFIER = FILE_IDENTIFIER;
    }
    pack(builder) {
        const IPFS_CID = (this.IPFS_CID !== null ? builder.createString(this.IPFS_CID) : 0);
        const KEY_ADDRESS = (this.KEY_ADDRESS !== null ? builder.createString(this.KEY_ADDRESS) : 0);
        const FILE_IDENTIFIER = (this.FILE_IDENTIFIER !== null ? builder.createString(this.FILE_IDENTIFIER) : 0);
        return PNM.createPNM(builder, IPFS_CID, KEY_ADDRESS, FILE_IDENTIFIER);
    }
}
