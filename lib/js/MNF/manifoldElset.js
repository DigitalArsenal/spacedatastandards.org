// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Manifold Element Set
 */
export class manifoldElset {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsmanifoldElset(bb, obj) {
        return (obj || new manifoldElset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsmanifoldElset(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new manifoldElset()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    EPOCH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Semi-major axis in km
     */
    SEMI_MAJOR_AXIS() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Eccentricity
     */
    ECCENTRICITY() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Inclination in degrees
     */
    INCLINATION() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension of ascending node in degrees
     */
    RA_OF_ASC_NODE() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Argument of pericenter in degrees
     */
    ARG_OF_PERICENTER() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean anomaly in degrees
     */
    MEAN_ANOMALY() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Applied delta-V in m/s
     */
    DELTA_V() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Applied delta-T in seconds
     */
    DELTA_T() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Delta-V direction X (unit vector)
     */
    DV_X() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Delta-V direction Y (unit vector)
     */
    DV_Y() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Delta-V direction Z (unit vector)
     */
    DV_Z() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Probability weight (0.0-1.0)
     */
    WEIGHT() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Apogee altitude in km
     */
    APOGEE() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Perigee altitude in km
     */
    PERIGEE() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Period in minutes
     */
    PERIOD() {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    static startmanifoldElset(builder) {
        builder.startObject(16);
    }
    static addEpoch(builder, EPOCHOffset) {
        builder.addFieldOffset(0, EPOCHOffset, 0);
    }
    static addSemiMajorAxis(builder, SEMI_MAJOR_AXIS) {
        builder.addFieldFloat64(1, SEMI_MAJOR_AXIS, 0.0);
    }
    static addEccentricity(builder, ECCENTRICITY) {
        builder.addFieldFloat64(2, ECCENTRICITY, 0.0);
    }
    static addInclination(builder, INCLINATION) {
        builder.addFieldFloat64(3, INCLINATION, 0.0);
    }
    static addRaOfAscNode(builder, RA_OF_ASC_NODE) {
        builder.addFieldFloat64(4, RA_OF_ASC_NODE, 0.0);
    }
    static addArgOfPericenter(builder, ARG_OF_PERICENTER) {
        builder.addFieldFloat64(5, ARG_OF_PERICENTER, 0.0);
    }
    static addMeanAnomaly(builder, MEAN_ANOMALY) {
        builder.addFieldFloat64(6, MEAN_ANOMALY, 0.0);
    }
    static addDeltaV(builder, DELTA_V) {
        builder.addFieldFloat64(7, DELTA_V, 0.0);
    }
    static addDeltaT(builder, DELTA_T) {
        builder.addFieldFloat64(8, DELTA_T, 0.0);
    }
    static addDvX(builder, DV_X) {
        builder.addFieldFloat64(9, DV_X, 0.0);
    }
    static addDvY(builder, DV_Y) {
        builder.addFieldFloat64(10, DV_Y, 0.0);
    }
    static addDvZ(builder, DV_Z) {
        builder.addFieldFloat64(11, DV_Z, 0.0);
    }
    static addWeight(builder, WEIGHT) {
        builder.addFieldFloat64(12, WEIGHT, 0.0);
    }
    static addApogee(builder, APOGEE) {
        builder.addFieldFloat64(13, APOGEE, 0.0);
    }
    static addPerigee(builder, PERIGEE) {
        builder.addFieldFloat64(14, PERIGEE, 0.0);
    }
    static addPeriod(builder, PERIOD) {
        builder.addFieldFloat64(15, PERIOD, 0.0);
    }
    static endmanifoldElset(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createmanifoldElset(builder, EPOCHOffset, SEMI_MAJOR_AXIS, ECCENTRICITY, INCLINATION, RA_OF_ASC_NODE, ARG_OF_PERICENTER, MEAN_ANOMALY, DELTA_V, DELTA_T, DV_X, DV_Y, DV_Z, WEIGHT, APOGEE, PERIGEE, PERIOD) {
        manifoldElset.startmanifoldElset(builder);
        manifoldElset.addEpoch(builder, EPOCHOffset);
        manifoldElset.addSemiMajorAxis(builder, SEMI_MAJOR_AXIS);
        manifoldElset.addEccentricity(builder, ECCENTRICITY);
        manifoldElset.addInclination(builder, INCLINATION);
        manifoldElset.addRaOfAscNode(builder, RA_OF_ASC_NODE);
        manifoldElset.addArgOfPericenter(builder, ARG_OF_PERICENTER);
        manifoldElset.addMeanAnomaly(builder, MEAN_ANOMALY);
        manifoldElset.addDeltaV(builder, DELTA_V);
        manifoldElset.addDeltaT(builder, DELTA_T);
        manifoldElset.addDvX(builder, DV_X);
        manifoldElset.addDvY(builder, DV_Y);
        manifoldElset.addDvZ(builder, DV_Z);
        manifoldElset.addWeight(builder, WEIGHT);
        manifoldElset.addApogee(builder, APOGEE);
        manifoldElset.addPerigee(builder, PERIGEE);
        manifoldElset.addPeriod(builder, PERIOD);
        return manifoldElset.endmanifoldElset(builder);
    }
    unpack() {
        return new manifoldElsetT(this.EPOCH(), this.SEMI_MAJOR_AXIS(), this.ECCENTRICITY(), this.INCLINATION(), this.RA_OF_ASC_NODE(), this.ARG_OF_PERICENTER(), this.MEAN_ANOMALY(), this.DELTA_V(), this.DELTA_T(), this.DV_X(), this.DV_Y(), this.DV_Z(), this.WEIGHT(), this.APOGEE(), this.PERIGEE(), this.PERIOD());
    }
    unpackTo(_o) {
        _o.EPOCH = this.EPOCH();
        _o.SEMI_MAJOR_AXIS = this.SEMI_MAJOR_AXIS();
        _o.ECCENTRICITY = this.ECCENTRICITY();
        _o.INCLINATION = this.INCLINATION();
        _o.RA_OF_ASC_NODE = this.RA_OF_ASC_NODE();
        _o.ARG_OF_PERICENTER = this.ARG_OF_PERICENTER();
        _o.MEAN_ANOMALY = this.MEAN_ANOMALY();
        _o.DELTA_V = this.DELTA_V();
        _o.DELTA_T = this.DELTA_T();
        _o.DV_X = this.DV_X();
        _o.DV_Y = this.DV_Y();
        _o.DV_Z = this.DV_Z();
        _o.WEIGHT = this.WEIGHT();
        _o.APOGEE = this.APOGEE();
        _o.PERIGEE = this.PERIGEE();
        _o.PERIOD = this.PERIOD();
    }
}
export class manifoldElsetT {
    constructor(EPOCH = null, SEMI_MAJOR_AXIS = 0.0, ECCENTRICITY = 0.0, INCLINATION = 0.0, RA_OF_ASC_NODE = 0.0, ARG_OF_PERICENTER = 0.0, MEAN_ANOMALY = 0.0, DELTA_V = 0.0, DELTA_T = 0.0, DV_X = 0.0, DV_Y = 0.0, DV_Z = 0.0, WEIGHT = 0.0, APOGEE = 0.0, PERIGEE = 0.0, PERIOD = 0.0) {
        this.EPOCH = EPOCH;
        this.SEMI_MAJOR_AXIS = SEMI_MAJOR_AXIS;
        this.ECCENTRICITY = ECCENTRICITY;
        this.INCLINATION = INCLINATION;
        this.RA_OF_ASC_NODE = RA_OF_ASC_NODE;
        this.ARG_OF_PERICENTER = ARG_OF_PERICENTER;
        this.MEAN_ANOMALY = MEAN_ANOMALY;
        this.DELTA_V = DELTA_V;
        this.DELTA_T = DELTA_T;
        this.DV_X = DV_X;
        this.DV_Y = DV_Y;
        this.DV_Z = DV_Z;
        this.WEIGHT = WEIGHT;
        this.APOGEE = APOGEE;
        this.PERIGEE = PERIGEE;
        this.PERIOD = PERIOD;
    }
    pack(builder) {
        const EPOCH = (this.EPOCH !== null ? builder.createString(this.EPOCH) : 0);
        return manifoldElset.createmanifoldElset(builder, EPOCH, this.SEMI_MAJOR_AXIS, this.ECCENTRICITY, this.INCLINATION, this.RA_OF_ASC_NODE, this.ARG_OF_PERICENTER, this.MEAN_ANOMALY, this.DELTA_V, this.DELTA_T, this.DV_X, this.DV_Y, this.DV_Z, this.WEIGHT, this.APOGEE, this.PERIGEE, this.PERIOD);
    }
}
