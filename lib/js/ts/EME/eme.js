// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Encrypted Message Envelope
 */
export class EME {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEME(bb, obj) {
        return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEME(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EME()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$EME');
    }
    /**
     * Encrypted data blob, containing the ciphertext of the original plaintext message.
     */
    encryptedBlob(index) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    encryptedBlobLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    encryptedBlobArray() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    ephemeralPublicKey(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    mac(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    nonce(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    tag(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    iv(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    publicKeyIdentifier(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    cipherSuite(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    kdfParameters(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    encryptionAlgorithmParameters(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startEME(builder) {
        builder.startObject(10);
    }
    static addEncryptedBlob(builder, encryptedBlobOffset) {
        builder.addFieldOffset(0, encryptedBlobOffset, 0);
    }
    static createEncryptedBlobVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startEncryptedBlobVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addEphemeralPublicKey(builder, ephemeralPublicKeyOffset) {
        builder.addFieldOffset(1, ephemeralPublicKeyOffset, 0);
    }
    static addMac(builder, macOffset) {
        builder.addFieldOffset(2, macOffset, 0);
    }
    static addNonce(builder, nonceOffset) {
        builder.addFieldOffset(3, nonceOffset, 0);
    }
    static addTag(builder, tagOffset) {
        builder.addFieldOffset(4, tagOffset, 0);
    }
    static addIv(builder, ivOffset) {
        builder.addFieldOffset(5, ivOffset, 0);
    }
    static addPublicKeyIdentifier(builder, publicKeyIdentifierOffset) {
        builder.addFieldOffset(6, publicKeyIdentifierOffset, 0);
    }
    static addCipherSuite(builder, cipherSuiteOffset) {
        builder.addFieldOffset(7, cipherSuiteOffset, 0);
    }
    static addKdfParameters(builder, kdfParametersOffset) {
        builder.addFieldOffset(8, kdfParametersOffset, 0);
    }
    static addEncryptionAlgorithmParameters(builder, encryptionAlgorithmParametersOffset) {
        builder.addFieldOffset(9, encryptionAlgorithmParametersOffset, 0);
    }
    static endEME(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishEMEBuffer(builder, offset) {
        builder.finish(offset, '$EME');
    }
    static finishSizePrefixedEMEBuffer(builder, offset) {
        builder.finish(offset, '$EME', true);
    }
    static createEME(builder, encryptedBlobOffset, ephemeralPublicKeyOffset, macOffset, nonceOffset, tagOffset, ivOffset, publicKeyIdentifierOffset, cipherSuiteOffset, kdfParametersOffset, encryptionAlgorithmParametersOffset) {
        EME.startEME(builder);
        EME.addEncryptedBlob(builder, encryptedBlobOffset);
        EME.addEphemeralPublicKey(builder, ephemeralPublicKeyOffset);
        EME.addMac(builder, macOffset);
        EME.addNonce(builder, nonceOffset);
        EME.addTag(builder, tagOffset);
        EME.addIv(builder, ivOffset);
        EME.addPublicKeyIdentifier(builder, publicKeyIdentifierOffset);
        EME.addCipherSuite(builder, cipherSuiteOffset);
        EME.addKdfParameters(builder, kdfParametersOffset);
        EME.addEncryptionAlgorithmParameters(builder, encryptionAlgorithmParametersOffset);
        return EME.endEME(builder);
    }
    unpack() {
        return new EMET(this.bb.createScalarList(this.encryptedBlob.bind(this), this.encryptedBlobLength()), this.ephemeralPublicKey(), this.mac(), this.nonce(), this.tag(), this.iv(), this.publicKeyIdentifier(), this.cipherSuite(), this.kdfParameters(), this.encryptionAlgorithmParameters());
    }
    unpackTo(_o) {
        _o.encryptedBlob = this.bb.createScalarList(this.encryptedBlob.bind(this), this.encryptedBlobLength());
        _o.ephemeralPublicKey = this.ephemeralPublicKey();
        _o.mac = this.mac();
        _o.nonce = this.nonce();
        _o.tag = this.tag();
        _o.iv = this.iv();
        _o.publicKeyIdentifier = this.publicKeyIdentifier();
        _o.cipherSuite = this.cipherSuite();
        _o.kdfParameters = this.kdfParameters();
        _o.encryptionAlgorithmParameters = this.encryptionAlgorithmParameters();
    }
}
export class EMET {
    constructor(encryptedBlob = [], ephemeralPublicKey = null, mac = null, nonce = null, tag = null, iv = null, publicKeyIdentifier = null, cipherSuite = null, kdfParameters = null, encryptionAlgorithmParameters = null) {
        this.encryptedBlob = encryptedBlob;
        this.ephemeralPublicKey = ephemeralPublicKey;
        this.mac = mac;
        this.nonce = nonce;
        this.tag = tag;
        this.iv = iv;
        this.publicKeyIdentifier = publicKeyIdentifier;
        this.cipherSuite = cipherSuite;
        this.kdfParameters = kdfParameters;
        this.encryptionAlgorithmParameters = encryptionAlgorithmParameters;
    }
    pack(builder) {
        const encryptedBlob = EME.createEncryptedBlobVector(builder, this.encryptedBlob);
        const ephemeralPublicKey = (this.ephemeralPublicKey !== null ? builder.createString(this.ephemeralPublicKey) : 0);
        const mac = (this.mac !== null ? builder.createString(this.mac) : 0);
        const nonce = (this.nonce !== null ? builder.createString(this.nonce) : 0);
        const tag = (this.tag !== null ? builder.createString(this.tag) : 0);
        const iv = (this.iv !== null ? builder.createString(this.iv) : 0);
        const publicKeyIdentifier = (this.publicKeyIdentifier !== null ? builder.createString(this.publicKeyIdentifier) : 0);
        const cipherSuite = (this.cipherSuite !== null ? builder.createString(this.cipherSuite) : 0);
        const kdfParameters = (this.kdfParameters !== null ? builder.createString(this.kdfParameters) : 0);
        const encryptionAlgorithmParameters = (this.encryptionAlgorithmParameters !== null ? builder.createString(this.encryptionAlgorithmParameters) : 0);
        return EME.createEME(builder, encryptedBlob, ephemeralPublicKey, mac, nonce, tag, iv, publicKeyIdentifier, cipherSuite, kdfParameters, encryptionAlgorithmParameters);
    }
}
