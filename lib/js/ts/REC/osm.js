// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
/**
 * Observation Stability Message
 */
export class OSM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsOSM(bb, obj) {
        return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsOSM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new OSM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$OSM');
    }
    /**
     * Indicates whether the observation is stable or not
     */
    isStable() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * The number of observations
     */
    numObs() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    objectId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    idSensor(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    passStart(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Duration of the observation pass in seconds
     */
    passDuration() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startOSM(builder) {
        builder.startObject(6);
    }
    static addIsStable(builder, isStable) {
        builder.addFieldInt8(0, +isStable, +false);
    }
    static addNumObs(builder, numObs) {
        builder.addFieldInt32(1, numObs, 0);
    }
    static addObjectId(builder, objectIdOffset) {
        builder.addFieldOffset(2, objectIdOffset, 0);
    }
    static addIdSensor(builder, idSensorOffset) {
        builder.addFieldOffset(3, idSensorOffset, 0);
    }
    static addPassStart(builder, passStartOffset) {
        builder.addFieldOffset(4, passStartOffset, 0);
    }
    static addPassDuration(builder, passDuration) {
        builder.addFieldInt32(5, passDuration, 0);
    }
    static endOSM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishOSMBuffer(builder, offset) {
        builder.finish(offset, '$OSM');
    }
    static finishSizePrefixedOSMBuffer(builder, offset) {
        builder.finish(offset, '$OSM', true);
    }
    static createOSM(builder, isStable, numObs, objectIdOffset, idSensorOffset, passStartOffset, passDuration) {
        OSM.startOSM(builder);
        OSM.addIsStable(builder, isStable);
        OSM.addNumObs(builder, numObs);
        OSM.addObjectId(builder, objectIdOffset);
        OSM.addIdSensor(builder, idSensorOffset);
        OSM.addPassStart(builder, passStartOffset);
        OSM.addPassDuration(builder, passDuration);
        return OSM.endOSM(builder);
    }
    unpack() {
        return new OSMT(this.isStable(), this.numObs(), this.objectId(), this.idSensor(), this.passStart(), this.passDuration());
    }
    unpackTo(_o) {
        _o.isStable = this.isStable();
        _o.numObs = this.numObs();
        _o.objectId = this.objectId();
        _o.idSensor = this.idSensor();
        _o.passStart = this.passStart();
        _o.passDuration = this.passDuration();
    }
}
export class OSMT {
    constructor(isStable = false, numObs = 0, objectId = null, idSensor = null, passStart = null, passDuration = 0) {
        this.isStable = isStable;
        this.numObs = numObs;
        this.objectId = objectId;
        this.idSensor = idSensor;
        this.passStart = passStart;
        this.passDuration = passDuration;
    }
    pack(builder) {
        const objectId = (this.objectId !== null ? builder.createString(this.objectId) : 0);
        const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor) : 0);
        const passStart = (this.passStart !== null ? builder.createString(this.passStart) : 0);
        return OSM.createOSM(builder, this.isStable, this.numObs, objectId, idSensor, passStart, this.passDuration);
    }
}
