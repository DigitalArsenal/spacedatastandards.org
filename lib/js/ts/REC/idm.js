// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { Band } from './band.js';
import { DataMode } from './data-mode.js';
import { DeviceType } from './device-type.js';
import { FrequencyRange } from './frequency-range.js';
import { PolarizationType } from './polarization-type.js';
import { SimplePolarization } from './simple-polarization.js';
import { StokesParameters } from './stokes-parameters.js';
/**
 * Integrated Device Message
 */
export class IDM {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsIDM(bb, obj) {
        return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsIDM(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new IDM()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$IDM');
    }
    id(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    name(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Mode of the data (real, simulated, synthetic)
     */
    dataMode() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DataMode.REAL;
    }
    /**
     * Uplink frequency range
     */
    uplink(obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new FrequencyRange()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Downlink frequency range
     */
    downlink(obj) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new FrequencyRange()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Beacon frequency range
     */
    beacon(obj) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new FrequencyRange()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Bands associated with the EMT
     */
    band(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new Band()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    bandLength() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Type of polarization used
     */
    polarizationType() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : PolarizationType.linear;
    }
    /**
     * Simple polarization configuration
     */
    simplePolarization() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : SimplePolarization.vertical;
    }
    /**
     * Stokes parameters for polarization characterization
     */
    stokesParameters(obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new StokesParameters()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * Power required in Watts
     */
    powerRequired() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    powerType(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Indicates if the EMT can transmit
     */
    transmit() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Indicates if the EMT can receive
     */
    receive() {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Type of the sensor
     */
    sensorType() {
        const offset = this.bb.__offset(this.bb_pos, 32);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DeviceType.UNKNOWN;
    }
    source(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 34);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    lastObTime(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 36);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Lower left elevation limit
     */
    lowerLeftElevationLimit() {
        const offset = this.bb.__offset(this.bb_pos, 38);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Upper left azimuth limit
     */
    upperLeftAzimuthLimit() {
        const offset = this.bb.__offset(this.bb_pos, 40);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Lower right elevation limit
     */
    lowerRightElevationLimit() {
        const offset = this.bb.__offset(this.bb_pos, 42);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Lower left azimuth limit
     */
    lowerLeftAzimuthLimit() {
        const offset = this.bb.__offset(this.bb_pos, 44);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Upper right elevation limit
     */
    upperRightElevationLimit() {
        const offset = this.bb.__offset(this.bb_pos, 46);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Upper right azimuth limit
     */
    upperRightAzimuthLimit() {
        const offset = this.bb.__offset(this.bb_pos, 48);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Lower right azimuth limit
     */
    lowerRightAzimuthLimit() {
        const offset = this.bb.__offset(this.bb_pos, 50);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Upper left elevation limit
     */
    upperLeftElevationLimit() {
        const offset = this.bb.__offset(this.bb_pos, 52);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right geostationary belt limit
     */
    rightGeoBeltLimit() {
        const offset = this.bb.__offset(this.bb_pos, 54);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Left geostationary belt limit
     */
    leftGeoBeltLimit() {
        const offset = this.bb.__offset(this.bb_pos, 56);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Magnitude limit of the sensor
     */
    magnitudeLimit() {
        const offset = this.bb.__offset(this.bb_pos, 58);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Indicates if the site is taskable
     */
    taskable() {
        const offset = this.bb.__offset(this.bb_pos, 60);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startIDM(builder) {
        builder.startObject(29);
    }
    static addId(builder, idOffset) {
        builder.addFieldOffset(0, idOffset, 0);
    }
    static addName(builder, nameOffset) {
        builder.addFieldOffset(1, nameOffset, 0);
    }
    static addDataMode(builder, dataMode) {
        builder.addFieldInt8(2, dataMode, DataMode.REAL);
    }
    static addUplink(builder, uplinkOffset) {
        builder.addFieldOffset(3, uplinkOffset, 0);
    }
    static addDownlink(builder, downlinkOffset) {
        builder.addFieldOffset(4, downlinkOffset, 0);
    }
    static addBeacon(builder, beaconOffset) {
        builder.addFieldOffset(5, beaconOffset, 0);
    }
    static addBand(builder, bandOffset) {
        builder.addFieldOffset(6, bandOffset, 0);
    }
    static createBandVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startBandVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addPolarizationType(builder, polarizationType) {
        builder.addFieldInt8(7, polarizationType, PolarizationType.linear);
    }
    static addSimplePolarization(builder, simplePolarization) {
        builder.addFieldInt8(8, simplePolarization, SimplePolarization.vertical);
    }
    static addStokesParameters(builder, stokesParametersOffset) {
        builder.addFieldOffset(9, stokesParametersOffset, 0);
    }
    static addPowerRequired(builder, powerRequired) {
        builder.addFieldFloat64(10, powerRequired, 0.0);
    }
    static addPowerType(builder, powerTypeOffset) {
        builder.addFieldOffset(11, powerTypeOffset, 0);
    }
    static addTransmit(builder, transmit) {
        builder.addFieldInt8(12, +transmit, +false);
    }
    static addReceive(builder, receive) {
        builder.addFieldInt8(13, +receive, +false);
    }
    static addSensorType(builder, sensorType) {
        builder.addFieldInt8(14, sensorType, DeviceType.UNKNOWN);
    }
    static addSource(builder, sourceOffset) {
        builder.addFieldOffset(15, sourceOffset, 0);
    }
    static addLastObTime(builder, lastObTimeOffset) {
        builder.addFieldOffset(16, lastObTimeOffset, 0);
    }
    static addLowerLeftElevationLimit(builder, lowerLeftElevationLimit) {
        builder.addFieldFloat64(17, lowerLeftElevationLimit, 0.0);
    }
    static addUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit) {
        builder.addFieldFloat64(18, upperLeftAzimuthLimit, 0.0);
    }
    static addLowerRightElevationLimit(builder, lowerRightElevationLimit) {
        builder.addFieldFloat64(19, lowerRightElevationLimit, 0.0);
    }
    static addLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit) {
        builder.addFieldFloat64(20, lowerLeftAzimuthLimit, 0.0);
    }
    static addUpperRightElevationLimit(builder, upperRightElevationLimit) {
        builder.addFieldFloat64(21, upperRightElevationLimit, 0.0);
    }
    static addUpperRightAzimuthLimit(builder, upperRightAzimuthLimit) {
        builder.addFieldFloat64(22, upperRightAzimuthLimit, 0.0);
    }
    static addLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit) {
        builder.addFieldFloat64(23, lowerRightAzimuthLimit, 0.0);
    }
    static addUpperLeftElevationLimit(builder, upperLeftElevationLimit) {
        builder.addFieldFloat64(24, upperLeftElevationLimit, 0.0);
    }
    static addRightGeoBeltLimit(builder, rightGeoBeltLimit) {
        builder.addFieldFloat64(25, rightGeoBeltLimit, 0.0);
    }
    static addLeftGeoBeltLimit(builder, leftGeoBeltLimit) {
        builder.addFieldFloat64(26, leftGeoBeltLimit, 0.0);
    }
    static addMagnitudeLimit(builder, magnitudeLimit) {
        builder.addFieldFloat64(27, magnitudeLimit, 0.0);
    }
    static addTaskable(builder, taskable) {
        builder.addFieldInt8(28, +taskable, +false);
    }
    static endIDM(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishIDMBuffer(builder, offset) {
        builder.finish(offset, '$IDM');
    }
    static finishSizePrefixedIDMBuffer(builder, offset) {
        builder.finish(offset, '$IDM', true);
    }
    unpack() {
        return new IDMT(this.id(), this.name(), this.dataMode(), (this.uplink() !== null ? this.uplink().unpack() : null), (this.downlink() !== null ? this.downlink().unpack() : null), (this.beacon() !== null ? this.beacon().unpack() : null), this.bb.createObjList(this.band.bind(this), this.bandLength()), this.polarizationType(), this.simplePolarization(), (this.stokesParameters() !== null ? this.stokesParameters().unpack() : null), this.powerRequired(), this.powerType(), this.transmit(), this.receive(), this.sensorType(), this.source(), this.lastObTime(), this.lowerLeftElevationLimit(), this.upperLeftAzimuthLimit(), this.lowerRightElevationLimit(), this.lowerLeftAzimuthLimit(), this.upperRightElevationLimit(), this.upperRightAzimuthLimit(), this.lowerRightAzimuthLimit(), this.upperLeftElevationLimit(), this.rightGeoBeltLimit(), this.leftGeoBeltLimit(), this.magnitudeLimit(), this.taskable());
    }
    unpackTo(_o) {
        _o.id = this.id();
        _o.name = this.name();
        _o.dataMode = this.dataMode();
        _o.uplink = (this.uplink() !== null ? this.uplink().unpack() : null);
        _o.downlink = (this.downlink() !== null ? this.downlink().unpack() : null);
        _o.beacon = (this.beacon() !== null ? this.beacon().unpack() : null);
        _o.band = this.bb.createObjList(this.band.bind(this), this.bandLength());
        _o.polarizationType = this.polarizationType();
        _o.simplePolarization = this.simplePolarization();
        _o.stokesParameters = (this.stokesParameters() !== null ? this.stokesParameters().unpack() : null);
        _o.powerRequired = this.powerRequired();
        _o.powerType = this.powerType();
        _o.transmit = this.transmit();
        _o.receive = this.receive();
        _o.sensorType = this.sensorType();
        _o.source = this.source();
        _o.lastObTime = this.lastObTime();
        _o.lowerLeftElevationLimit = this.lowerLeftElevationLimit();
        _o.upperLeftAzimuthLimit = this.upperLeftAzimuthLimit();
        _o.lowerRightElevationLimit = this.lowerRightElevationLimit();
        _o.lowerLeftAzimuthLimit = this.lowerLeftAzimuthLimit();
        _o.upperRightElevationLimit = this.upperRightElevationLimit();
        _o.upperRightAzimuthLimit = this.upperRightAzimuthLimit();
        _o.lowerRightAzimuthLimit = this.lowerRightAzimuthLimit();
        _o.upperLeftElevationLimit = this.upperLeftElevationLimit();
        _o.rightGeoBeltLimit = this.rightGeoBeltLimit();
        _o.leftGeoBeltLimit = this.leftGeoBeltLimit();
        _o.magnitudeLimit = this.magnitudeLimit();
        _o.taskable = this.taskable();
    }
}
export class IDMT {
    constructor(id = null, name = null, dataMode = DataMode.REAL, uplink = null, downlink = null, beacon = null, band = [], polarizationType = PolarizationType.linear, simplePolarization = SimplePolarization.vertical, stokesParameters = null, powerRequired = 0.0, powerType = null, transmit = false, receive = false, sensorType = DeviceType.UNKNOWN, source = null, lastObTime = null, lowerLeftElevationLimit = 0.0, upperLeftAzimuthLimit = 0.0, lowerRightElevationLimit = 0.0, lowerLeftAzimuthLimit = 0.0, upperRightElevationLimit = 0.0, upperRightAzimuthLimit = 0.0, lowerRightAzimuthLimit = 0.0, upperLeftElevationLimit = 0.0, rightGeoBeltLimit = 0.0, leftGeoBeltLimit = 0.0, magnitudeLimit = 0.0, taskable = false) {
        this.id = id;
        this.name = name;
        this.dataMode = dataMode;
        this.uplink = uplink;
        this.downlink = downlink;
        this.beacon = beacon;
        this.band = band;
        this.polarizationType = polarizationType;
        this.simplePolarization = simplePolarization;
        this.stokesParameters = stokesParameters;
        this.powerRequired = powerRequired;
        this.powerType = powerType;
        this.transmit = transmit;
        this.receive = receive;
        this.sensorType = sensorType;
        this.source = source;
        this.lastObTime = lastObTime;
        this.lowerLeftElevationLimit = lowerLeftElevationLimit;
        this.upperLeftAzimuthLimit = upperLeftAzimuthLimit;
        this.lowerRightElevationLimit = lowerRightElevationLimit;
        this.lowerLeftAzimuthLimit = lowerLeftAzimuthLimit;
        this.upperRightElevationLimit = upperRightElevationLimit;
        this.upperRightAzimuthLimit = upperRightAzimuthLimit;
        this.lowerRightAzimuthLimit = lowerRightAzimuthLimit;
        this.upperLeftElevationLimit = upperLeftElevationLimit;
        this.rightGeoBeltLimit = rightGeoBeltLimit;
        this.leftGeoBeltLimit = leftGeoBeltLimit;
        this.magnitudeLimit = magnitudeLimit;
        this.taskable = taskable;
    }
    pack(builder) {
        const id = (this.id !== null ? builder.createString(this.id) : 0);
        const name = (this.name !== null ? builder.createString(this.name) : 0);
        const uplink = (this.uplink !== null ? this.uplink.pack(builder) : 0);
        const downlink = (this.downlink !== null ? this.downlink.pack(builder) : 0);
        const beacon = (this.beacon !== null ? this.beacon.pack(builder) : 0);
        const band = IDM.createBandVector(builder, builder.createObjectOffsetList(this.band));
        const stokesParameters = (this.stokesParameters !== null ? this.stokesParameters.pack(builder) : 0);
        const powerType = (this.powerType !== null ? builder.createString(this.powerType) : 0);
        const source = (this.source !== null ? builder.createString(this.source) : 0);
        const lastObTime = (this.lastObTime !== null ? builder.createString(this.lastObTime) : 0);
        IDM.startIDM(builder);
        IDM.addId(builder, id);
        IDM.addName(builder, name);
        IDM.addDataMode(builder, this.dataMode);
        IDM.addUplink(builder, uplink);
        IDM.addDownlink(builder, downlink);
        IDM.addBeacon(builder, beacon);
        IDM.addBand(builder, band);
        IDM.addPolarizationType(builder, this.polarizationType);
        IDM.addSimplePolarization(builder, this.simplePolarization);
        IDM.addStokesParameters(builder, stokesParameters);
        IDM.addPowerRequired(builder, this.powerRequired);
        IDM.addPowerType(builder, powerType);
        IDM.addTransmit(builder, this.transmit);
        IDM.addReceive(builder, this.receive);
        IDM.addSensorType(builder, this.sensorType);
        IDM.addSource(builder, source);
        IDM.addLastObTime(builder, lastObTime);
        IDM.addLowerLeftElevationLimit(builder, this.lowerLeftElevationLimit);
        IDM.addUpperLeftAzimuthLimit(builder, this.upperLeftAzimuthLimit);
        IDM.addLowerRightElevationLimit(builder, this.lowerRightElevationLimit);
        IDM.addLowerLeftAzimuthLimit(builder, this.lowerLeftAzimuthLimit);
        IDM.addUpperRightElevationLimit(builder, this.upperRightElevationLimit);
        IDM.addUpperRightAzimuthLimit(builder, this.upperRightAzimuthLimit);
        IDM.addLowerRightAzimuthLimit(builder, this.lowerRightAzimuthLimit);
        IDM.addUpperLeftElevationLimit(builder, this.upperLeftElevationLimit);
        IDM.addRightGeoBeltLimit(builder, this.rightGeoBeltLimit);
        IDM.addLeftGeoBeltLimit(builder, this.leftGeoBeltLimit);
        IDM.addMagnitudeLimit(builder, this.magnitudeLimit);
        IDM.addTaskable(builder, this.taskable);
        return IDM.endIDM(builder);
    }
}
