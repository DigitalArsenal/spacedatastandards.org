// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { meanElementTheory } from './mean-element-theory.js';
/**
 * Minimum Propagatable Element Set
 */
export class MPE {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsMPE(bb, obj) {
        return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMPE(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new MPE()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$MPE');
    }
    entityId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Epoch of Mean Keplerian elements (UNIX timestamp) [numeric seconds since 1970-01-01T00:00:00 UTC]
     */
    epoch() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean motion in rev/day [M if chosen to represent orbit size for SGP/SGP4 elements]
     */
    meanMotion() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Eccentricity (unitless)
     */
    eccentricity() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Inclination in degrees
     */
    inclination() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Right ascension of ascending node in degrees
     */
    raOfAscNode() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Argument of pericenter in degrees
     */
    argOfPericenter() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Mean anomaly in degrees
     */
    meanAnomaly() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * SGP/SGP4 drag-like coefficient (BSTAR) in units of 1/[Earth radii]
     */
    bstar() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    /**
     * Description of the Mean Element Theory (SGP4, DSST, USM)
     */
    meanElementTheory() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : meanElementTheory.SGP4;
    }
    static startMPE(builder) {
        builder.startObject(10);
    }
    static addEntityId(builder, entityIdOffset) {
        builder.addFieldOffset(0, entityIdOffset, 0);
    }
    static addEpoch(builder, epoch) {
        builder.addFieldFloat64(1, epoch, 0.0);
    }
    static addMeanMotion(builder, meanMotion) {
        builder.addFieldFloat64(2, meanMotion, 0.0);
    }
    static addEccentricity(builder, eccentricity) {
        builder.addFieldFloat64(3, eccentricity, 0.0);
    }
    static addInclination(builder, inclination) {
        builder.addFieldFloat64(4, inclination, 0.0);
    }
    static addRaOfAscNode(builder, raOfAscNode) {
        builder.addFieldFloat64(5, raOfAscNode, 0.0);
    }
    static addArgOfPericenter(builder, argOfPericenter) {
        builder.addFieldFloat64(6, argOfPericenter, 0.0);
    }
    static addMeanAnomaly(builder, meanAnomaly) {
        builder.addFieldFloat64(7, meanAnomaly, 0.0);
    }
    static addBstar(builder, bstar) {
        builder.addFieldFloat64(8, bstar, 0.0);
    }
    static addMeanElementTheory(builder, meanElementTheory) {
        builder.addFieldInt8(9, meanElementTheory, meanElementTheory.SGP4);
    }
    static endMPE(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishMPEBuffer(builder, offset) {
        builder.finish(offset, '$MPE');
    }
    static finishSizePrefixedMPEBuffer(builder, offset) {
        builder.finish(offset, '$MPE', true);
    }
    static createMPE(builder, entityIdOffset, epoch, meanMotion, eccentricity, inclination, raOfAscNode, argOfPericenter, meanAnomaly, bstar, meanElementTheory) {
        MPE.startMPE(builder);
        MPE.addEntityId(builder, entityIdOffset);
        MPE.addEpoch(builder, epoch);
        MPE.addMeanMotion(builder, meanMotion);
        MPE.addEccentricity(builder, eccentricity);
        MPE.addInclination(builder, inclination);
        MPE.addRaOfAscNode(builder, raOfAscNode);
        MPE.addArgOfPericenter(builder, argOfPericenter);
        MPE.addMeanAnomaly(builder, meanAnomaly);
        MPE.addBstar(builder, bstar);
        MPE.addMeanElementTheory(builder, meanElementTheory);
        return MPE.endMPE(builder);
    }
    unpack() {
        return new MPET(this.entityId(), this.epoch(), this.meanMotion(), this.eccentricity(), this.inclination(), this.raOfAscNode(), this.argOfPericenter(), this.meanAnomaly(), this.bstar(), this.meanElementTheory());
    }
    unpackTo(_o) {
        _o.entityId = this.entityId();
        _o.epoch = this.epoch();
        _o.meanMotion = this.meanMotion();
        _o.eccentricity = this.eccentricity();
        _o.inclination = this.inclination();
        _o.raOfAscNode = this.raOfAscNode();
        _o.argOfPericenter = this.argOfPericenter();
        _o.meanAnomaly = this.meanAnomaly();
        _o.bstar = this.bstar();
        _o.meanElementTheory = this.meanElementTheory();
    }
}
export class MPET {
    constructor(entityId = null, epoch = 0.0, meanMotion = 0.0, eccentricity = 0.0, inclination = 0.0, raOfAscNode = 0.0, argOfPericenter = 0.0, meanAnomaly = 0.0, bstar = 0.0, meanElementTheory = meanElementTheory.SGP4) {
        this.entityId = entityId;
        this.epoch = epoch;
        this.meanMotion = meanMotion;
        this.eccentricity = eccentricity;
        this.inclination = inclination;
        this.raOfAscNode = raOfAscNode;
        this.argOfPericenter = argOfPericenter;
        this.meanAnomaly = meanAnomaly;
        this.bstar = bstar;
        this.meanElementTheory = meanElementTheory;
    }
    pack(builder) {
        const entityId = (this.entityId !== null ? builder.createString(this.entityId) : 0);
        return MPE.createMPE(builder, entityId, this.epoch, this.meanMotion, this.eccentricity, this.inclination, this.raOfAscNode, this.argOfPericenter, this.meanAnomaly, this.bstar, this.meanElementTheory);
    }
}
