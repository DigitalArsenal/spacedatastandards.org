// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { propagatorType } from './propagator-type.js';
/**
 * Propagator configuration structure to describe propagation settings
 */
export class propagatorConfig {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAspropagatorConfig(bb, obj) {
        return (obj || new propagatorConfig()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAspropagatorConfig(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new propagatorConfig()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    propagatorName(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    propagatorType() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : propagatorType.NONE;
    }
    forceModels(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    forceModelsLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    epoch(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    timeStep() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat64(this.bb_pos + offset) : 0.0;
    }
    zonalHarmonicTerms(index) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    zonalHarmonicTermsLength() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    zonalHarmonicTermsArray() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? new Int8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startpropagatorConfig(builder) {
        builder.startObject(6);
    }
    static addPropagatorName(builder, propagatorNameOffset) {
        builder.addFieldOffset(0, propagatorNameOffset, 0);
    }
    static addPropagatorType(builder, propagatorType) {
        builder.addFieldInt8(1, propagatorType, propagatorType.NONE);
    }
    static addForceModels(builder, forceModelsOffset) {
        builder.addFieldOffset(2, forceModelsOffset, 0);
    }
    static createForceModelsVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startForceModelsVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addEpoch(builder, epochOffset) {
        builder.addFieldOffset(3, epochOffset, 0);
    }
    static addTimeStep(builder, timeStep) {
        builder.addFieldFloat64(4, timeStep, 0.0);
    }
    static addZonalHarmonicTerms(builder, zonalHarmonicTermsOffset) {
        builder.addFieldOffset(5, zonalHarmonicTermsOffset, 0);
    }
    static createZonalHarmonicTermsVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startZonalHarmonicTermsVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endpropagatorConfig(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createpropagatorConfig(builder, propagatorNameOffset, propagatorType, forceModelsOffset, epochOffset, timeStep, zonalHarmonicTermsOffset) {
        propagatorConfig.startpropagatorConfig(builder);
        propagatorConfig.addPropagatorName(builder, propagatorNameOffset);
        propagatorConfig.addPropagatorType(builder, propagatorType);
        propagatorConfig.addForceModels(builder, forceModelsOffset);
        propagatorConfig.addEpoch(builder, epochOffset);
        propagatorConfig.addTimeStep(builder, timeStep);
        propagatorConfig.addZonalHarmonicTerms(builder, zonalHarmonicTermsOffset);
        return propagatorConfig.endpropagatorConfig(builder);
    }
    unpack() {
        return new propagatorConfigT(this.propagatorName(), this.propagatorType(), this.bb.createScalarList(this.forceModels.bind(this), this.forceModelsLength()), this.epoch(), this.timeStep(), this.bb.createScalarList(this.zonalHarmonicTerms.bind(this), this.zonalHarmonicTermsLength()));
    }
    unpackTo(_o) {
        _o.propagatorName = this.propagatorName();
        _o.propagatorType = this.propagatorType();
        _o.forceModels = this.bb.createScalarList(this.forceModels.bind(this), this.forceModelsLength());
        _o.epoch = this.epoch();
        _o.timeStep = this.timeStep();
        _o.zonalHarmonicTerms = this.bb.createScalarList(this.zonalHarmonicTerms.bind(this), this.zonalHarmonicTermsLength());
    }
}
export class propagatorConfigT {
    constructor(propagatorName = null, propagatorType = propagatorType.NONE, forceModels = [], epoch = null, timeStep = 0.0, zonalHarmonicTerms = []) {
        this.propagatorName = propagatorName;
        this.propagatorType = propagatorType;
        this.forceModels = forceModels;
        this.epoch = epoch;
        this.timeStep = timeStep;
        this.zonalHarmonicTerms = zonalHarmonicTerms;
    }
    pack(builder) {
        const propagatorName = (this.propagatorName !== null ? builder.createString(this.propagatorName) : 0);
        const forceModels = propagatorConfig.createForceModelsVector(builder, builder.createObjectOffsetList(this.forceModels));
        const epoch = (this.epoch !== null ? builder.createString(this.epoch) : 0);
        const zonalHarmonicTerms = propagatorConfig.createZonalHarmonicTermsVector(builder, this.zonalHarmonicTerms);
        return propagatorConfig.createpropagatorConfig(builder, propagatorName, this.propagatorType, forceModels, epoch, this.timeStep, zonalHarmonicTerms);
    }
}
