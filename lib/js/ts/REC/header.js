// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
export class Header {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsHeader(bb, obj) {
        return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsHeader(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ccsdsOcmVers(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    comment(index, optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
    }
    commentLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    classification(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    creationDate(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    originator(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    messageId(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startHeader(builder) {
        builder.startObject(6);
    }
    static addCcsdsOcmVers(builder, ccsdsOcmVersOffset) {
        builder.addFieldOffset(0, ccsdsOcmVersOffset, 0);
    }
    static addComment(builder, commentOffset) {
        builder.addFieldOffset(1, commentOffset, 0);
    }
    static createCommentVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startCommentVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addClassification(builder, classificationOffset) {
        builder.addFieldOffset(2, classificationOffset, 0);
    }
    static addCreationDate(builder, creationDateOffset) {
        builder.addFieldOffset(3, creationDateOffset, 0);
    }
    static addOriginator(builder, originatorOffset) {
        builder.addFieldOffset(4, originatorOffset, 0);
    }
    static addMessageId(builder, messageIdOffset) {
        builder.addFieldOffset(5, messageIdOffset, 0);
    }
    static endHeader(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createHeader(builder, ccsdsOcmVersOffset, commentOffset, classificationOffset, creationDateOffset, originatorOffset, messageIdOffset) {
        Header.startHeader(builder);
        Header.addCcsdsOcmVers(builder, ccsdsOcmVersOffset);
        Header.addComment(builder, commentOffset);
        Header.addClassification(builder, classificationOffset);
        Header.addCreationDate(builder, creationDateOffset);
        Header.addOriginator(builder, originatorOffset);
        Header.addMessageId(builder, messageIdOffset);
        return Header.endHeader(builder);
    }
    unpack() {
        return new HeaderT(this.ccsdsOcmVers(), this.bb.createScalarList(this.comment.bind(this), this.commentLength()), this.classification(), this.creationDate(), this.originator(), this.messageId());
    }
    unpackTo(_o) {
        _o.ccsdsOcmVers = this.ccsdsOcmVers();
        _o.comment = this.bb.createScalarList(this.comment.bind(this), this.commentLength());
        _o.classification = this.classification();
        _o.creationDate = this.creationDate();
        _o.originator = this.originator();
        _o.messageId = this.messageId();
    }
}
export class HeaderT {
    constructor(ccsdsOcmVers = null, comment = [], classification = null, creationDate = null, originator = null, messageId = null) {
        this.ccsdsOcmVers = ccsdsOcmVers;
        this.comment = comment;
        this.classification = classification;
        this.creationDate = creationDate;
        this.originator = originator;
        this.messageId = messageId;
    }
    pack(builder) {
        const ccsdsOcmVers = (this.ccsdsOcmVers !== null ? builder.createString(this.ccsdsOcmVers) : 0);
        const comment = Header.createCommentVector(builder, builder.createObjectOffsetList(this.comment));
        const classification = (this.classification !== null ? builder.createString(this.classification) : 0);
        const creationDate = (this.creationDate !== null ? builder.createString(this.creationDate) : 0);
        const originator = (this.originator !== null ? builder.createString(this.originator) : 0);
        const messageId = (this.messageId !== null ? builder.createString(this.messageId) : 0);
        return Header.createHeader(builder, ccsdsOcmVers, comment, classification, creationDate, originator, messageId);
    }
}
