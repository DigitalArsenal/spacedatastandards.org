// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { packetType } from './packetType.js';
/**
 * Space Packet Protocol (CCSDS 133.0-B-1)
 */
export class SPP {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSPP(bb, obj) {
        return (obj || new SPP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSPP(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SPP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$SPP');
    }
    /**
     * Packet version number
     */
    VERSION() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Packet type (TM or TC)
     */
    PACKET_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : packetType.TM;
    }
    /**
     * Secondary header flag
     */
    SEC_HDR_FLAG() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    /**
     * Application Process Identifier
     */
    APID() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Sequence flags (00=continuation, 01=first, 10=last, 11=standalone)
     */
    SEQUENCE_FLAGS() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : 0;
    }
    /**
     * Sequence count
     */
    SEQUENCE_COUNT() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Data length minus 1
     */
    DATA_LENGTH() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Packet data zone
     */
    DATA(index) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    dataLength() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    dataArray() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startSPP(builder) {
        builder.startObject(8);
    }
    static addVersion(builder, VERSION) {
        builder.addFieldInt8(0, VERSION, 0);
    }
    static addPacketType(builder, PACKET_TYPE) {
        builder.addFieldInt8(1, PACKET_TYPE, packetType.TM);
    }
    static addSecHdrFlag(builder, SEC_HDR_FLAG) {
        builder.addFieldInt8(2, +SEC_HDR_FLAG, +false);
    }
    static addApid(builder, APID) {
        builder.addFieldInt16(3, APID, 0);
    }
    static addSequenceFlags(builder, SEQUENCE_FLAGS) {
        builder.addFieldInt8(4, SEQUENCE_FLAGS, 0);
    }
    static addSequenceCount(builder, SEQUENCE_COUNT) {
        builder.addFieldInt16(5, SEQUENCE_COUNT, 0);
    }
    static addDataLength(builder, DATA_LENGTH) {
        builder.addFieldInt16(6, DATA_LENGTH, 0);
    }
    static addData(builder, DATAOffset) {
        builder.addFieldOffset(7, DATAOffset, 0);
    }
    static createDataVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startDataVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static endSPP(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishSPPBuffer(builder, offset) {
        builder.finish(offset, '$SPP');
    }
    static finishSizePrefixedSPPBuffer(builder, offset) {
        builder.finish(offset, '$SPP', true);
    }
    static createSPP(builder, VERSION, PACKET_TYPE, SEC_HDR_FLAG, APID, SEQUENCE_FLAGS, SEQUENCE_COUNT, DATA_LENGTH, DATAOffset) {
        SPP.startSPP(builder);
        SPP.addVersion(builder, VERSION);
        SPP.addPacketType(builder, PACKET_TYPE);
        SPP.addSecHdrFlag(builder, SEC_HDR_FLAG);
        SPP.addApid(builder, APID);
        SPP.addSequenceFlags(builder, SEQUENCE_FLAGS);
        SPP.addSequenceCount(builder, SEQUENCE_COUNT);
        SPP.addDataLength(builder, DATA_LENGTH);
        SPP.addData(builder, DATAOffset);
        return SPP.endSPP(builder);
    }
    unpack() {
        return new SPPT(this.VERSION(), this.PACKET_TYPE(), this.SEC_HDR_FLAG(), this.APID(), this.SEQUENCE_FLAGS(), this.SEQUENCE_COUNT(), this.DATA_LENGTH(), this.bb.createScalarList(this.DATA.bind(this), this.dataLength()));
    }
    unpackTo(_o) {
        _o.VERSION = this.VERSION();
        _o.PACKET_TYPE = this.PACKET_TYPE();
        _o.SEC_HDR_FLAG = this.SEC_HDR_FLAG();
        _o.APID = this.APID();
        _o.SEQUENCE_FLAGS = this.SEQUENCE_FLAGS();
        _o.SEQUENCE_COUNT = this.SEQUENCE_COUNT();
        _o.DATA_LENGTH = this.DATA_LENGTH();
        _o.DATA = this.bb.createScalarList(this.DATA.bind(this), this.dataLength());
    }
}
export class SPPT {
    constructor(VERSION = 0, PACKET_TYPE = packetType.TM, SEC_HDR_FLAG = false, APID = 0, SEQUENCE_FLAGS = 0, SEQUENCE_COUNT = 0, DATA_LENGTH = 0, DATA = []) {
        this.VERSION = VERSION;
        this.PACKET_TYPE = PACKET_TYPE;
        this.SEC_HDR_FLAG = SEC_HDR_FLAG;
        this.APID = APID;
        this.SEQUENCE_FLAGS = SEQUENCE_FLAGS;
        this.SEQUENCE_COUNT = SEQUENCE_COUNT;
        this.DATA_LENGTH = DATA_LENGTH;
        this.DATA = DATA;
    }
    pack(builder) {
        const DATA = SPP.createDataVector(builder, this.DATA);
        return SPP.createSPP(builder, this.VERSION, this.PACKET_TYPE, this.SEC_HDR_FLAG, this.APID, this.SEQUENCE_FLAGS, this.SEQUENCE_COUNT, this.DATA_LENGTH, DATA);
    }
}
