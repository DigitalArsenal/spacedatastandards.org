// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { paymentMethod } from './paymentMethod.js';
/**
 * Purchase Request - Request to purchase data from a storefront listing
 */
export class PUR {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsPUR(bb, obj) {
        return (obj || new PUR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsPUR(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new PUR()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$PUR');
    }
    REQUEST_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    LISTING_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    TIER_NAME(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    BUYER_PEER_ID(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Buyer's encryption public key for encrypted delivery
     */
    BUYER_ENCRYPTION_PUBKEY(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    buyerEncryptionPubkeyLength() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buyerEncryptionPubkeyArray() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Payment method used
     */
    PAYMENT_METHOD() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : paymentMethod.Crypto_ETH;
    }
    /**
     * Payment amount in smallest unit
     */
    PAYMENT_AMOUNT() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    PAYMENT_CURRENCY(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PAYMENT_TX_HASH(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PAYMENT_CHAIN(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    PAYMENT_REFERENCE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Ed25519 signature from buyer
     */
    BUYER_SIGNATURE(index) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
    buyerSignatureLength() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buyerSignatureArray() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    /**
     * Unix timestamp of the request
     */
    TIMESTAMP() {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
    static startPUR(builder) {
        builder.startObject(13);
    }
    static addRequestId(builder, REQUEST_IDOffset) {
        builder.addFieldOffset(0, REQUEST_IDOffset, 0);
    }
    static addListingId(builder, LISTING_IDOffset) {
        builder.addFieldOffset(1, LISTING_IDOffset, 0);
    }
    static addTierName(builder, TIER_NAMEOffset) {
        builder.addFieldOffset(2, TIER_NAMEOffset, 0);
    }
    static addBuyerPeerId(builder, BUYER_PEER_IDOffset) {
        builder.addFieldOffset(3, BUYER_PEER_IDOffset, 0);
    }
    static addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset) {
        builder.addFieldOffset(4, BUYER_ENCRYPTION_PUBKEYOffset, 0);
    }
    static createBuyerEncryptionPubkeyVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startBuyerEncryptionPubkeyVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addPaymentMethod(builder, PAYMENT_METHOD) {
        builder.addFieldInt8(5, PAYMENT_METHOD, paymentMethod.Crypto_ETH);
    }
    static addPaymentAmount(builder, PAYMENT_AMOUNT) {
        builder.addFieldInt64(6, PAYMENT_AMOUNT, BigInt('0'));
    }
    static addPaymentCurrency(builder, PAYMENT_CURRENCYOffset) {
        builder.addFieldOffset(7, PAYMENT_CURRENCYOffset, 0);
    }
    static addPaymentTxHash(builder, PAYMENT_TX_HASHOffset) {
        builder.addFieldOffset(8, PAYMENT_TX_HASHOffset, 0);
    }
    static addPaymentChain(builder, PAYMENT_CHAINOffset) {
        builder.addFieldOffset(9, PAYMENT_CHAINOffset, 0);
    }
    static addPaymentReference(builder, PAYMENT_REFERENCEOffset) {
        builder.addFieldOffset(10, PAYMENT_REFERENCEOffset, 0);
    }
    static addBuyerSignature(builder, BUYER_SIGNATUREOffset) {
        builder.addFieldOffset(11, BUYER_SIGNATUREOffset, 0);
    }
    static createBuyerSignatureVector(builder, data) {
        builder.startVector(1, data.length, 1);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addInt8(data[i]);
        }
        return builder.endVector();
    }
    static startBuyerSignatureVector(builder, numElems) {
        builder.startVector(1, numElems, 1);
    }
    static addTimestamp(builder, TIMESTAMP) {
        builder.addFieldInt64(12, TIMESTAMP, BigInt('0'));
    }
    static endPUR(builder) {
        const offset = builder.endObject();
        builder.requiredField(offset, 4); // REQUEST_ID
        builder.requiredField(offset, 6); // LISTING_ID
        builder.requiredField(offset, 8); // TIER_NAME
        builder.requiredField(offset, 10); // BUYER_PEER_ID
        return offset;
    }
    static finishPURBuffer(builder, offset) {
        builder.finish(offset, '$PUR');
    }
    static finishSizePrefixedPURBuffer(builder, offset) {
        builder.finish(offset, '$PUR', true);
    }
    static createPUR(builder, REQUEST_IDOffset, LISTING_IDOffset, TIER_NAMEOffset, BUYER_PEER_IDOffset, BUYER_ENCRYPTION_PUBKEYOffset, PAYMENT_METHOD, PAYMENT_AMOUNT, PAYMENT_CURRENCYOffset, PAYMENT_TX_HASHOffset, PAYMENT_CHAINOffset, PAYMENT_REFERENCEOffset, BUYER_SIGNATUREOffset, TIMESTAMP) {
        PUR.startPUR(builder);
        PUR.addRequestId(builder, REQUEST_IDOffset);
        PUR.addListingId(builder, LISTING_IDOffset);
        PUR.addTierName(builder, TIER_NAMEOffset);
        PUR.addBuyerPeerId(builder, BUYER_PEER_IDOffset);
        PUR.addBuyerEncryptionPubkey(builder, BUYER_ENCRYPTION_PUBKEYOffset);
        PUR.addPaymentMethod(builder, PAYMENT_METHOD);
        PUR.addPaymentAmount(builder, PAYMENT_AMOUNT);
        PUR.addPaymentCurrency(builder, PAYMENT_CURRENCYOffset);
        PUR.addPaymentTxHash(builder, PAYMENT_TX_HASHOffset);
        PUR.addPaymentChain(builder, PAYMENT_CHAINOffset);
        PUR.addPaymentReference(builder, PAYMENT_REFERENCEOffset);
        PUR.addBuyerSignature(builder, BUYER_SIGNATUREOffset);
        PUR.addTimestamp(builder, TIMESTAMP);
        return PUR.endPUR(builder);
    }
    unpack() {
        return new PURT(this.REQUEST_ID(), this.LISTING_ID(), this.TIER_NAME(), this.BUYER_PEER_ID(), this.bb.createScalarList(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength()), this.PAYMENT_METHOD(), this.PAYMENT_AMOUNT(), this.PAYMENT_CURRENCY(), this.PAYMENT_TX_HASH(), this.PAYMENT_CHAIN(), this.PAYMENT_REFERENCE(), this.bb.createScalarList(this.BUYER_SIGNATURE.bind(this), this.buyerSignatureLength()), this.TIMESTAMP());
    }
    unpackTo(_o) {
        _o.REQUEST_ID = this.REQUEST_ID();
        _o.LISTING_ID = this.LISTING_ID();
        _o.TIER_NAME = this.TIER_NAME();
        _o.BUYER_PEER_ID = this.BUYER_PEER_ID();
        _o.BUYER_ENCRYPTION_PUBKEY = this.bb.createScalarList(this.BUYER_ENCRYPTION_PUBKEY.bind(this), this.buyerEncryptionPubkeyLength());
        _o.PAYMENT_METHOD = this.PAYMENT_METHOD();
        _o.PAYMENT_AMOUNT = this.PAYMENT_AMOUNT();
        _o.PAYMENT_CURRENCY = this.PAYMENT_CURRENCY();
        _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH();
        _o.PAYMENT_CHAIN = this.PAYMENT_CHAIN();
        _o.PAYMENT_REFERENCE = this.PAYMENT_REFERENCE();
        _o.BUYER_SIGNATURE = this.bb.createScalarList(this.BUYER_SIGNATURE.bind(this), this.buyerSignatureLength());
        _o.TIMESTAMP = this.TIMESTAMP();
    }
}
export class PURT {
    constructor(REQUEST_ID = null, LISTING_ID = null, TIER_NAME = null, BUYER_PEER_ID = null, BUYER_ENCRYPTION_PUBKEY = [], PAYMENT_METHOD = paymentMethod.Crypto_ETH, PAYMENT_AMOUNT = BigInt('0'), PAYMENT_CURRENCY = null, PAYMENT_TX_HASH = null, PAYMENT_CHAIN = null, PAYMENT_REFERENCE = null, BUYER_SIGNATURE = [], TIMESTAMP = BigInt('0')) {
        this.REQUEST_ID = REQUEST_ID;
        this.LISTING_ID = LISTING_ID;
        this.TIER_NAME = TIER_NAME;
        this.BUYER_PEER_ID = BUYER_PEER_ID;
        this.BUYER_ENCRYPTION_PUBKEY = BUYER_ENCRYPTION_PUBKEY;
        this.PAYMENT_METHOD = PAYMENT_METHOD;
        this.PAYMENT_AMOUNT = PAYMENT_AMOUNT;
        this.PAYMENT_CURRENCY = PAYMENT_CURRENCY;
        this.PAYMENT_TX_HASH = PAYMENT_TX_HASH;
        this.PAYMENT_CHAIN = PAYMENT_CHAIN;
        this.PAYMENT_REFERENCE = PAYMENT_REFERENCE;
        this.BUYER_SIGNATURE = BUYER_SIGNATURE;
        this.TIMESTAMP = TIMESTAMP;
    }
    pack(builder) {
        const REQUEST_ID = (this.REQUEST_ID !== null ? builder.createString(this.REQUEST_ID) : 0);
        const LISTING_ID = (this.LISTING_ID !== null ? builder.createString(this.LISTING_ID) : 0);
        const TIER_NAME = (this.TIER_NAME !== null ? builder.createString(this.TIER_NAME) : 0);
        const BUYER_PEER_ID = (this.BUYER_PEER_ID !== null ? builder.createString(this.BUYER_PEER_ID) : 0);
        const BUYER_ENCRYPTION_PUBKEY = PUR.createBuyerEncryptionPubkeyVector(builder, this.BUYER_ENCRYPTION_PUBKEY);
        const PAYMENT_CURRENCY = (this.PAYMENT_CURRENCY !== null ? builder.createString(this.PAYMENT_CURRENCY) : 0);
        const PAYMENT_TX_HASH = (this.PAYMENT_TX_HASH !== null ? builder.createString(this.PAYMENT_TX_HASH) : 0);
        const PAYMENT_CHAIN = (this.PAYMENT_CHAIN !== null ? builder.createString(this.PAYMENT_CHAIN) : 0);
        const PAYMENT_REFERENCE = (this.PAYMENT_REFERENCE !== null ? builder.createString(this.PAYMENT_REFERENCE) : 0);
        const BUYER_SIGNATURE = PUR.createBuyerSignatureVector(builder, this.BUYER_SIGNATURE);
        return PUR.createPUR(builder, REQUEST_ID, LISTING_ID, TIER_NAME, BUYER_PEER_ID, BUYER_ENCRYPTION_PUBKEY, this.PAYMENT_METHOD, this.PAYMENT_AMOUNT, PAYMENT_CURRENCY, PAYMENT_TX_HASH, PAYMENT_CHAIN, PAYMENT_REFERENCE, BUYER_SIGNATURE, this.TIMESTAMP);
    }
}
