// automatically generated by the FlatBuffers compiler, do not modify
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
import * as flatbuffers from 'flatbuffers';
import { DataType } from './DataType.js';
/**
 * Earth Orientation Parameters
 */
export class EOP {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsEOP(bb, obj) {
        return (obj || new EOP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsEOP(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new EOP()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static bufferHasIdentifier(bb) {
        return bb.__has_identifier('$EOP');
    }
    DATE(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Modified Julian Date
     */
    MJD() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
    }
    /**
     * x pole coordinate in arcseconds
     */
    X() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * y pole coordinate in arcseconds
     */
    Y() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * UT1-UTC in seconds
     */
    UT1_MINUS_UTC() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Length of Day correction in seconds
     */
    LOD() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Nutation correction in longitude (δΔψ) in arcseconds
     */
    DPSI() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Nutation correction in obliquity (δΔε) in arcseconds
     */
    DEPS() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Celestial pole offset in x (δX) in arcseconds
     */
    DX() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Celestial pole offset in y (δY) in arcseconds
     */
    DY() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    /**
     * Delta Atomic Time (TAI-UTC) in seconds
     */
    DAT() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readUint16(this.bb_pos + offset) : 0;
    }
    /**
     * Data type (O = Observed, P = Predicted)
     */
    DATA_TYPE() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readInt8(this.bb_pos + offset) : DataType.OBSERVED;
    }
    static startEOP(builder) {
        builder.startObject(12);
    }
    static addDate(builder, DATEOffset) {
        builder.addFieldOffset(0, DATEOffset, 0);
    }
    static addMjd(builder, MJD) {
        builder.addFieldInt32(1, MJD, 0);
    }
    static addX(builder, X) {
        builder.addFieldFloat32(2, X, 0.0);
    }
    static addY(builder, Y) {
        builder.addFieldFloat32(3, Y, 0.0);
    }
    static addUt1MinusUtc(builder, UT1_MINUS_UTC) {
        builder.addFieldFloat32(4, UT1_MINUS_UTC, 0.0);
    }
    static addLod(builder, LOD) {
        builder.addFieldFloat32(5, LOD, 0.0);
    }
    static addDpsi(builder, DPSI) {
        builder.addFieldFloat32(6, DPSI, 0.0);
    }
    static addDeps(builder, DEPS) {
        builder.addFieldFloat32(7, DEPS, 0.0);
    }
    static addDx(builder, DX) {
        builder.addFieldFloat32(8, DX, 0.0);
    }
    static addDy(builder, DY) {
        builder.addFieldFloat32(9, DY, 0.0);
    }
    static addDat(builder, DAT) {
        builder.addFieldInt16(10, DAT, 0);
    }
    static addDataType(builder, DATA_TYPE) {
        builder.addFieldInt8(11, DATA_TYPE, DataType.OBSERVED);
    }
    static endEOP(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static finishEOPBuffer(builder, offset) {
        builder.finish(offset, '$EOP');
    }
    static finishSizePrefixedEOPBuffer(builder, offset) {
        builder.finish(offset, '$EOP', true);
    }
    static createEOP(builder, DATEOffset, MJD, X, Y, UT1_MINUS_UTC, LOD, DPSI, DEPS, DX, DY, DAT, DATA_TYPE) {
        EOP.startEOP(builder);
        EOP.addDate(builder, DATEOffset);
        EOP.addMjd(builder, MJD);
        EOP.addX(builder, X);
        EOP.addY(builder, Y);
        EOP.addUt1MinusUtc(builder, UT1_MINUS_UTC);
        EOP.addLod(builder, LOD);
        EOP.addDpsi(builder, DPSI);
        EOP.addDeps(builder, DEPS);
        EOP.addDx(builder, DX);
        EOP.addDy(builder, DY);
        EOP.addDat(builder, DAT);
        EOP.addDataType(builder, DATA_TYPE);
        return EOP.endEOP(builder);
    }
    unpack() {
        return new EOPT(this.DATE(), this.MJD(), this.X(), this.Y(), this.UT1_MINUS_UTC(), this.LOD(), this.DPSI(), this.DEPS(), this.DX(), this.DY(), this.DAT(), this.DATA_TYPE());
    }
    unpackTo(_o) {
        _o.DATE = this.DATE();
        _o.MJD = this.MJD();
        _o.X = this.X();
        _o.Y = this.Y();
        _o.UT1_MINUS_UTC = this.UT1_MINUS_UTC();
        _o.LOD = this.LOD();
        _o.DPSI = this.DPSI();
        _o.DEPS = this.DEPS();
        _o.DX = this.DX();
        _o.DY = this.DY();
        _o.DAT = this.DAT();
        _o.DATA_TYPE = this.DATA_TYPE();
    }
}
export class EOPT {
    constructor(DATE = null, MJD = 0, X = 0.0, Y = 0.0, UT1_MINUS_UTC = 0.0, LOD = 0.0, DPSI = 0.0, DEPS = 0.0, DX = 0.0, DY = 0.0, DAT = 0, DATA_TYPE = DataType.OBSERVED) {
        this.DATE = DATE;
        this.MJD = MJD;
        this.X = X;
        this.Y = Y;
        this.UT1_MINUS_UTC = UT1_MINUS_UTC;
        this.LOD = LOD;
        this.DPSI = DPSI;
        this.DEPS = DEPS;
        this.DX = DX;
        this.DY = DY;
        this.DAT = DAT;
        this.DATA_TYPE = DATA_TYPE;
    }
    pack(builder) {
        const DATE = (this.DATE !== null ? builder.createString(this.DATE) : 0);
        return EOP.createEOP(builder, DATE, this.MJD, this.X, this.Y, this.UT1_MINUS_UTC, this.LOD, this.DPSI, this.DEPS, this.DX, this.DY, this.DAT, this.DATA_TYPE);
    }
}
