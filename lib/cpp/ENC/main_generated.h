// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ENC;
struct ENCBuilder;

/// Encryption Header for FlatBuffers field-level encryption
/// Key exchange algorithm used to derive the shared secret
enum KeyExchange : int8_t {
  KeyExchange_X25519 = 0,
  KeyExchange_Secp256k1 = 1,
  KeyExchange_P256 = 2,
  KeyExchange_MIN = KeyExchange_X25519,
  KeyExchange_MAX = KeyExchange_P256
};

inline const KeyExchange (&EnumValuesKeyExchange())[3] {
  static const KeyExchange values[] = {
    KeyExchange_X25519,
    KeyExchange_Secp256k1,
    KeyExchange_P256
  };
  return values;
}

inline const char * const *EnumNamesKeyExchange() {
  static const char * const names[4] = {
    "X25519",
    "Secp256k1",
    "P256",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyExchange(KeyExchange e) {
  if (::flatbuffers::IsOutRange(e, KeyExchange_X25519, KeyExchange_P256)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyExchange()[index];
}

/// Symmetric encryption algorithm
enum SymmetricAlgo : int8_t {
  SymmetricAlgo_AES_256_CTR = 0,
  SymmetricAlgo_MIN = SymmetricAlgo_AES_256_CTR,
  SymmetricAlgo_MAX = SymmetricAlgo_AES_256_CTR
};

inline const SymmetricAlgo (&EnumValuesSymmetricAlgo())[1] {
  static const SymmetricAlgo values[] = {
    SymmetricAlgo_AES_256_CTR
  };
  return values;
}

inline const char * const *EnumNamesSymmetricAlgo() {
  static const char * const names[2] = {
    "AES_256_CTR",
    nullptr
  };
  return names;
}

inline const char *EnumNameSymmetricAlgo(SymmetricAlgo e) {
  if (::flatbuffers::IsOutRange(e, SymmetricAlgo_AES_256_CTR, SymmetricAlgo_AES_256_CTR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSymmetricAlgo()[index];
}

/// Key derivation function
enum KDF : int8_t {
  KDF_HKDF_SHA256 = 0,
  KDF_MIN = KDF_HKDF_SHA256,
  KDF_MAX = KDF_HKDF_SHA256
};

inline const KDF (&EnumValuesKDF())[1] {
  static const KDF values[] = {
    KDF_HKDF_SHA256
  };
  return values;
}

inline const char * const *EnumNamesKDF() {
  static const char * const names[2] = {
    "HKDF_SHA256",
    nullptr
  };
  return names;
}

inline const char *EnumNameKDF(KDF e) {
  if (::flatbuffers::IsOutRange(e, KDF_HKDF_SHA256, KDF_HKDF_SHA256)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKDF()[index];
}

/// Encryption Header containing all parameters needed for decryption
struct ENC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ENCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_KEY_EXCHANGE = 6,
    VT_SYMMETRIC = 8,
    VT_KEY_DERIVATION = 10,
    VT_EPHEMERAL_PUBLIC_KEY = 12,
    VT_NONCE_START = 14,
    VT_RECIPIENT_KEY_ID = 16,
    VT_CONTEXT = 18,
    VT_SCHEMA_HASH = 20,
    VT_ROOT_TYPE = 22,
    VT_TIMESTAMP = 24
  };
  /// Schema version for forward compatibility
  uint8_t VERSION() const {
    return GetField<uint8_t>(VT_VERSION, 1);
  }
  /// Key exchange algorithm used
  KeyExchange KEY_EXCHANGE() const {
    return static_cast<KeyExchange>(GetField<int8_t>(VT_KEY_EXCHANGE, 0));
  }
  /// Symmetric encryption algorithm used
  SymmetricAlgo SYMMETRIC() const {
    return static_cast<SymmetricAlgo>(GetField<int8_t>(VT_SYMMETRIC, 0));
  }
  /// Key derivation function used
  KDF KEY_DERIVATION() const {
    return static_cast<KDF>(GetField<int8_t>(VT_KEY_DERIVATION, 0));
  }
  /// Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
  const ::flatbuffers::Vector<uint8_t> *EPHEMERAL_PUBLIC_KEY() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_EPHEMERAL_PUBLIC_KEY);
  }
  /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  const ::flatbuffers::Vector<uint8_t> *NONCE_START() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_NONCE_START);
  }
  /// Optional identifier for the recipient's public key (up to 32 bytes)
  const ::flatbuffers::Vector<uint8_t> *RECIPIENT_KEY_ID() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RECIPIENT_KEY_ID);
  }
  /// Optional domain separation context string
  const ::flatbuffers::String *CONTEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTEXT);
  }
  /// Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
  const ::flatbuffers::Vector<uint8_t> *SCHEMA_HASH() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SCHEMA_HASH);
  }
  /// Optional root type name from the schema
  const ::flatbuffers::String *ROOT_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROOT_TYPE);
  }
  /// Optional Unix timestamp (milliseconds) when encryption was performed
  uint64_t TIMESTAMP() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION, 1) &&
           VerifyField<int8_t>(verifier, VT_KEY_EXCHANGE, 1) &&
           VerifyField<int8_t>(verifier, VT_SYMMETRIC, 1) &&
           VerifyField<int8_t>(verifier, VT_KEY_DERIVATION, 1) &&
           VerifyOffsetRequired(verifier, VT_EPHEMERAL_PUBLIC_KEY) &&
           verifier.VerifyVector(EPHEMERAL_PUBLIC_KEY()) &&
           VerifyOffsetRequired(verifier, VT_NONCE_START) &&
           verifier.VerifyVector(NONCE_START()) &&
           VerifyOffset(verifier, VT_RECIPIENT_KEY_ID) &&
           verifier.VerifyVector(RECIPIENT_KEY_ID()) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyString(CONTEXT()) &&
           VerifyOffset(verifier, VT_SCHEMA_HASH) &&
           verifier.VerifyVector(SCHEMA_HASH()) &&
           VerifyOffset(verifier, VT_ROOT_TYPE) &&
           verifier.VerifyString(ROOT_TYPE()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct ENCBuilder {
  typedef ENC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(uint8_t VERSION) {
    fbb_.AddElement<uint8_t>(ENC::VT_VERSION, VERSION, 1);
  }
  void add_KEY_EXCHANGE(KeyExchange KEY_EXCHANGE) {
    fbb_.AddElement<int8_t>(ENC::VT_KEY_EXCHANGE, static_cast<int8_t>(KEY_EXCHANGE), 0);
  }
  void add_SYMMETRIC(SymmetricAlgo SYMMETRIC) {
    fbb_.AddElement<int8_t>(ENC::VT_SYMMETRIC, static_cast<int8_t>(SYMMETRIC), 0);
  }
  void add_KEY_DERIVATION(KDF KEY_DERIVATION) {
    fbb_.AddElement<int8_t>(ENC::VT_KEY_DERIVATION, static_cast<int8_t>(KEY_DERIVATION), 0);
  }
  void add_EPHEMERAL_PUBLIC_KEY(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> EPHEMERAL_PUBLIC_KEY) {
    fbb_.AddOffset(ENC::VT_EPHEMERAL_PUBLIC_KEY, EPHEMERAL_PUBLIC_KEY);
  }
  void add_NONCE_START(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> NONCE_START) {
    fbb_.AddOffset(ENC::VT_NONCE_START, NONCE_START);
  }
  void add_RECIPIENT_KEY_ID(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RECIPIENT_KEY_ID) {
    fbb_.AddOffset(ENC::VT_RECIPIENT_KEY_ID, RECIPIENT_KEY_ID);
  }
  void add_CONTEXT(::flatbuffers::Offset<::flatbuffers::String> CONTEXT) {
    fbb_.AddOffset(ENC::VT_CONTEXT, CONTEXT);
  }
  void add_SCHEMA_HASH(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SCHEMA_HASH) {
    fbb_.AddOffset(ENC::VT_SCHEMA_HASH, SCHEMA_HASH);
  }
  void add_ROOT_TYPE(::flatbuffers::Offset<::flatbuffers::String> ROOT_TYPE) {
    fbb_.AddOffset(ENC::VT_ROOT_TYPE, ROOT_TYPE);
  }
  void add_TIMESTAMP(uint64_t TIMESTAMP) {
    fbb_.AddElement<uint64_t>(ENC::VT_TIMESTAMP, TIMESTAMP, 0);
  }
  explicit ENCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ENC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ENC>(end);
    fbb_.Required(o, ENC::VT_EPHEMERAL_PUBLIC_KEY);
    fbb_.Required(o, ENC::VT_NONCE_START);
    return o;
  }
};

inline ::flatbuffers::Offset<ENC> CreateENC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 1,
    KeyExchange KEY_EXCHANGE = KeyExchange_X25519,
    SymmetricAlgo SYMMETRIC = SymmetricAlgo_AES_256_CTR,
    KDF KEY_DERIVATION = KDF_HKDF_SHA256,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> EPHEMERAL_PUBLIC_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> NONCE_START = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RECIPIENT_KEY_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONTEXT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SCHEMA_HASH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ROOT_TYPE = 0,
    uint64_t TIMESTAMP = 0) {
  ENCBuilder builder_(_fbb);
  builder_.add_TIMESTAMP(TIMESTAMP);
  builder_.add_ROOT_TYPE(ROOT_TYPE);
  builder_.add_SCHEMA_HASH(SCHEMA_HASH);
  builder_.add_CONTEXT(CONTEXT);
  builder_.add_RECIPIENT_KEY_ID(RECIPIENT_KEY_ID);
  builder_.add_NONCE_START(NONCE_START);
  builder_.add_EPHEMERAL_PUBLIC_KEY(EPHEMERAL_PUBLIC_KEY);
  builder_.add_KEY_DERIVATION(KEY_DERIVATION);
  builder_.add_SYMMETRIC(SYMMETRIC);
  builder_.add_KEY_EXCHANGE(KEY_EXCHANGE);
  builder_.add_VERSION(VERSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ENC> CreateENCDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 1,
    KeyExchange KEY_EXCHANGE = KeyExchange_X25519,
    SymmetricAlgo SYMMETRIC = SymmetricAlgo_AES_256_CTR,
    KDF KEY_DERIVATION = KDF_HKDF_SHA256,
    const std::vector<uint8_t> *EPHEMERAL_PUBLIC_KEY = nullptr,
    const std::vector<uint8_t> *NONCE_START = nullptr,
    const std::vector<uint8_t> *RECIPIENT_KEY_ID = nullptr,
    const char *CONTEXT = nullptr,
    const std::vector<uint8_t> *SCHEMA_HASH = nullptr,
    const char *ROOT_TYPE = nullptr,
    uint64_t TIMESTAMP = 0) {
  auto EPHEMERAL_PUBLIC_KEY__ = EPHEMERAL_PUBLIC_KEY ? _fbb.CreateVector<uint8_t>(*EPHEMERAL_PUBLIC_KEY) : 0;
  auto NONCE_START__ = NONCE_START ? _fbb.CreateVector<uint8_t>(*NONCE_START) : 0;
  auto RECIPIENT_KEY_ID__ = RECIPIENT_KEY_ID ? _fbb.CreateVector<uint8_t>(*RECIPIENT_KEY_ID) : 0;
  auto CONTEXT__ = CONTEXT ? _fbb.CreateString(CONTEXT) : 0;
  auto SCHEMA_HASH__ = SCHEMA_HASH ? _fbb.CreateVector<uint8_t>(*SCHEMA_HASH) : 0;
  auto ROOT_TYPE__ = ROOT_TYPE ? _fbb.CreateString(ROOT_TYPE) : 0;
  return CreateENC(
      _fbb,
      VERSION,
      KEY_EXCHANGE,
      SYMMETRIC,
      KEY_DERIVATION,
      EPHEMERAL_PUBLIC_KEY__,
      NONCE_START__,
      RECIPIENT_KEY_ID__,
      CONTEXT__,
      SCHEMA_HASH__,
      ROOT_TYPE__,
      TIMESTAMP);
}

inline const ENC *GetENC(const void *buf) {
  return ::flatbuffers::GetRoot<ENC>(buf);
}

inline const ENC *GetSizePrefixedENC(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ENC>(buf);
}

inline const char *ENCIdentifier() {
  return "$ENC";
}

inline bool ENCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ENCIdentifier());
}

inline bool SizePrefixedENCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ENCIdentifier(), true);
}

inline bool VerifyENCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ENC>(ENCIdentifier());
}

inline bool VerifySizePrefixedENCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ENC>(ENCIdentifier());
}

inline void FinishENCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ENC> root) {
  fbb.Finish(root, ENCIdentifier());
}

inline void FinishSizePrefixedENCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ENC> root) {
  fbb.FinishSizePrefixed(root, ENCIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
