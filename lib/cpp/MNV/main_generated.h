// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct mnvOrbitalState;
struct mnvOrbitalStateBuilder;

struct MNV;
struct MNVBuilder;

enum maneuverStatus : int8_t {
  maneuverStatus_DETECTED = 0,
  maneuverStatus_CONFIRMED = 1,
  maneuverStatus_PREDICTED = 2,
  maneuverStatus_PLANNED = 3,
  maneuverStatus_EXECUTED = 4,
  maneuverStatus_CANCELLED = 5,
  maneuverStatus_UNKNOWN = 6,
  maneuverStatus_MIN = maneuverStatus_DETECTED,
  maneuverStatus_MAX = maneuverStatus_UNKNOWN
};

inline const maneuverStatus (&EnumValuesmaneuverStatus())[7] {
  static const maneuverStatus values[] = {
    maneuverStatus_DETECTED,
    maneuverStatus_CONFIRMED,
    maneuverStatus_PREDICTED,
    maneuverStatus_PLANNED,
    maneuverStatus_EXECUTED,
    maneuverStatus_CANCELLED,
    maneuverStatus_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesmaneuverStatus() {
  static const char * const names[8] = {
    "DETECTED",
    "CONFIRMED",
    "PREDICTED",
    "PLANNED",
    "EXECUTED",
    "CANCELLED",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNamemaneuverStatus(maneuverStatus e) {
  if (::flatbuffers::IsOutRange(e, maneuverStatus_DETECTED, maneuverStatus_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmaneuverStatus()[index];
}

enum maneuverCharacterization : int8_t {
  maneuverCharacterization_IN_PLANE = 0,
  maneuverCharacterization_OUT_OF_PLANE = 1,
  maneuverCharacterization_COMBINED = 2,
  maneuverCharacterization_STATION_KEEPING = 3,
  maneuverCharacterization_ORBIT_RAISING = 4,
  maneuverCharacterization_ORBIT_LOWERING = 5,
  maneuverCharacterization_PHASING = 6,
  maneuverCharacterization_DEORBIT = 7,
  maneuverCharacterization_COLLISION_AVOIDANCE = 8,
  maneuverCharacterization_UNKNOWN = 9,
  maneuverCharacterization_MIN = maneuverCharacterization_IN_PLANE,
  maneuverCharacterization_MAX = maneuverCharacterization_UNKNOWN
};

inline const maneuverCharacterization (&EnumValuesmaneuverCharacterization())[10] {
  static const maneuverCharacterization values[] = {
    maneuverCharacterization_IN_PLANE,
    maneuverCharacterization_OUT_OF_PLANE,
    maneuverCharacterization_COMBINED,
    maneuverCharacterization_STATION_KEEPING,
    maneuverCharacterization_ORBIT_RAISING,
    maneuverCharacterization_ORBIT_LOWERING,
    maneuverCharacterization_PHASING,
    maneuverCharacterization_DEORBIT,
    maneuverCharacterization_COLLISION_AVOIDANCE,
    maneuverCharacterization_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesmaneuverCharacterization() {
  static const char * const names[11] = {
    "IN_PLANE",
    "OUT_OF_PLANE",
    "COMBINED",
    "STATION_KEEPING",
    "ORBIT_RAISING",
    "ORBIT_LOWERING",
    "PHASING",
    "DEORBIT",
    "COLLISION_AVOIDANCE",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNamemaneuverCharacterization(maneuverCharacterization e) {
  if (::flatbuffers::IsOutRange(e, maneuverCharacterization_IN_PLANE, maneuverCharacterization_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmaneuverCharacterization()[index];
}

/// Pre/post-maneuver orbital state
struct mnvOrbitalState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef mnvOrbitalStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID_ELSET = 4,
    VT_ELSET = 6,
    VT_ID_STATE_VECTOR = 8,
    VT_STATE_VECTOR = 10,
    VT_POS_X = 12,
    VT_POS_Y = 14,
    VT_POS_Z = 16,
    VT_VEL_X = 18,
    VT_VEL_Y = 20,
    VT_VEL_Z = 22,
    VT_RADIATION_PRESS_COEFF = 24,
    VT_BALLISTIC_COEFF = 26,
    VT_APOGEE = 28,
    VT_PERIGEE = 30,
    VT_INCLINATION = 32,
    VT_ECCENTRICITY = 34,
    VT_PERIOD = 36,
    VT_RAAN = 38,
    VT_SMA = 40,
    VT_GEO_LONGITUDE = 42,
    VT_DRIFT_RATE = 44,
    VT_SIGMA_U = 46,
    VT_SIGMA_V = 48,
    VT_SIGMA_W = 50
  };
  /// Element set identifier
  const ::flatbuffers::String *ID_ELSET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ELSET);
  }
  /// Element set data reference
  const ::flatbuffers::String *ELSET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELSET);
  }
  /// State vector identifier
  const ::flatbuffers::String *ID_STATE_VECTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_STATE_VECTOR);
  }
  /// State vector data reference
  const ::flatbuffers::String *STATE_VECTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE_VECTOR);
  }
  /// Position X (km)
  double POS_X() const {
    return GetField<double>(VT_POS_X, 0.0);
  }
  /// Position Y (km)
  double POS_Y() const {
    return GetField<double>(VT_POS_Y, 0.0);
  }
  /// Position Z (km)
  double POS_Z() const {
    return GetField<double>(VT_POS_Z, 0.0);
  }
  /// Velocity X (km/s)
  double VEL_X() const {
    return GetField<double>(VT_VEL_X, 0.0);
  }
  /// Velocity Y (km/s)
  double VEL_Y() const {
    return GetField<double>(VT_VEL_Y, 0.0);
  }
  /// Velocity Z (km/s)
  double VEL_Z() const {
    return GetField<double>(VT_VEL_Z, 0.0);
  }
  /// Radiation pressure coefficient (Cr)
  double RADIATION_PRESS_COEFF() const {
    return GetField<double>(VT_RADIATION_PRESS_COEFF, 0.0);
  }
  /// Ballistic coefficient (m^2/kg)
  double BALLISTIC_COEFF() const {
    return GetField<double>(VT_BALLISTIC_COEFF, 0.0);
  }
  /// Apogee altitude (km)
  double APOGEE() const {
    return GetField<double>(VT_APOGEE, 0.0);
  }
  /// Perigee altitude (km)
  double PERIGEE() const {
    return GetField<double>(VT_PERIGEE, 0.0);
  }
  /// Inclination (degrees)
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Eccentricity
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  /// Orbital period (minutes)
  double PERIOD() const {
    return GetField<double>(VT_PERIOD, 0.0);
  }
  /// Right ascension of ascending node (degrees)
  double RAAN() const {
    return GetField<double>(VT_RAAN, 0.0);
  }
  /// Semi-major axis (km)
  double SMA() const {
    return GetField<double>(VT_SMA, 0.0);
  }
  /// GEO longitude (degrees east)
  double GEO_LONGITUDE() const {
    return GetField<double>(VT_GEO_LONGITUDE, 0.0);
  }
  /// Longitude drift rate (degrees/day)
  double DRIFT_RATE() const {
    return GetField<double>(VT_DRIFT_RATE, 0.0);
  }
  /// Position uncertainty U (km, 1-sigma)
  double SIGMA_U() const {
    return GetField<double>(VT_SIGMA_U, 0.0);
  }
  /// Position uncertainty V (km, 1-sigma)
  double SIGMA_V() const {
    return GetField<double>(VT_SIGMA_V, 0.0);
  }
  /// Position uncertainty W (km, 1-sigma)
  double SIGMA_W() const {
    return GetField<double>(VT_SIGMA_W, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID_ELSET) &&
           verifier.VerifyString(ID_ELSET()) &&
           VerifyOffset(verifier, VT_ELSET) &&
           verifier.VerifyString(ELSET()) &&
           VerifyOffset(verifier, VT_ID_STATE_VECTOR) &&
           verifier.VerifyString(ID_STATE_VECTOR()) &&
           VerifyOffset(verifier, VT_STATE_VECTOR) &&
           verifier.VerifyString(STATE_VECTOR()) &&
           VerifyField<double>(verifier, VT_POS_X, 8) &&
           VerifyField<double>(verifier, VT_POS_Y, 8) &&
           VerifyField<double>(verifier, VT_POS_Z, 8) &&
           VerifyField<double>(verifier, VT_VEL_X, 8) &&
           VerifyField<double>(verifier, VT_VEL_Y, 8) &&
           VerifyField<double>(verifier, VT_VEL_Z, 8) &&
           VerifyField<double>(verifier, VT_RADIATION_PRESS_COEFF, 8) &&
           VerifyField<double>(verifier, VT_BALLISTIC_COEFF, 8) &&
           VerifyField<double>(verifier, VT_APOGEE, 8) &&
           VerifyField<double>(verifier, VT_PERIGEE, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY, 8) &&
           VerifyField<double>(verifier, VT_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_RAAN, 8) &&
           VerifyField<double>(verifier, VT_SMA, 8) &&
           VerifyField<double>(verifier, VT_GEO_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_DRIFT_RATE, 8) &&
           VerifyField<double>(verifier, VT_SIGMA_U, 8) &&
           VerifyField<double>(verifier, VT_SIGMA_V, 8) &&
           VerifyField<double>(verifier, VT_SIGMA_W, 8) &&
           verifier.EndTable();
  }
};

struct mnvOrbitalStateBuilder {
  typedef mnvOrbitalState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID_ELSET(::flatbuffers::Offset<::flatbuffers::String> ID_ELSET) {
    fbb_.AddOffset(mnvOrbitalState::VT_ID_ELSET, ID_ELSET);
  }
  void add_ELSET(::flatbuffers::Offset<::flatbuffers::String> ELSET) {
    fbb_.AddOffset(mnvOrbitalState::VT_ELSET, ELSET);
  }
  void add_ID_STATE_VECTOR(::flatbuffers::Offset<::flatbuffers::String> ID_STATE_VECTOR) {
    fbb_.AddOffset(mnvOrbitalState::VT_ID_STATE_VECTOR, ID_STATE_VECTOR);
  }
  void add_STATE_VECTOR(::flatbuffers::Offset<::flatbuffers::String> STATE_VECTOR) {
    fbb_.AddOffset(mnvOrbitalState::VT_STATE_VECTOR, STATE_VECTOR);
  }
  void add_POS_X(double POS_X) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_POS_X, POS_X, 0.0);
  }
  void add_POS_Y(double POS_Y) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_POS_Y, POS_Y, 0.0);
  }
  void add_POS_Z(double POS_Z) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_POS_Z, POS_Z, 0.0);
  }
  void add_VEL_X(double VEL_X) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_VEL_X, VEL_X, 0.0);
  }
  void add_VEL_Y(double VEL_Y) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_VEL_Y, VEL_Y, 0.0);
  }
  void add_VEL_Z(double VEL_Z) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_VEL_Z, VEL_Z, 0.0);
  }
  void add_RADIATION_PRESS_COEFF(double RADIATION_PRESS_COEFF) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_RADIATION_PRESS_COEFF, RADIATION_PRESS_COEFF, 0.0);
  }
  void add_BALLISTIC_COEFF(double BALLISTIC_COEFF) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_BALLISTIC_COEFF, BALLISTIC_COEFF, 0.0);
  }
  void add_APOGEE(double APOGEE) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_APOGEE, APOGEE, 0.0);
  }
  void add_PERIGEE(double PERIGEE) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_PERIGEE, PERIGEE, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_PERIOD(double PERIOD) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_PERIOD, PERIOD, 0.0);
  }
  void add_RAAN(double RAAN) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_RAAN, RAAN, 0.0);
  }
  void add_SMA(double SMA) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_SMA, SMA, 0.0);
  }
  void add_GEO_LONGITUDE(double GEO_LONGITUDE) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_GEO_LONGITUDE, GEO_LONGITUDE, 0.0);
  }
  void add_DRIFT_RATE(double DRIFT_RATE) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_DRIFT_RATE, DRIFT_RATE, 0.0);
  }
  void add_SIGMA_U(double SIGMA_U) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_SIGMA_U, SIGMA_U, 0.0);
  }
  void add_SIGMA_V(double SIGMA_V) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_SIGMA_V, SIGMA_V, 0.0);
  }
  void add_SIGMA_W(double SIGMA_W) {
    fbb_.AddElement<double>(mnvOrbitalState::VT_SIGMA_W, SIGMA_W, 0.0);
  }
  explicit mnvOrbitalStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<mnvOrbitalState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<mnvOrbitalState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<mnvOrbitalState> CreatemnvOrbitalState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ELSET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ELSET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_STATE_VECTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STATE_VECTOR = 0,
    double POS_X = 0.0,
    double POS_Y = 0.0,
    double POS_Z = 0.0,
    double VEL_X = 0.0,
    double VEL_Y = 0.0,
    double VEL_Z = 0.0,
    double RADIATION_PRESS_COEFF = 0.0,
    double BALLISTIC_COEFF = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double INCLINATION = 0.0,
    double ECCENTRICITY = 0.0,
    double PERIOD = 0.0,
    double RAAN = 0.0,
    double SMA = 0.0,
    double GEO_LONGITUDE = 0.0,
    double DRIFT_RATE = 0.0,
    double SIGMA_U = 0.0,
    double SIGMA_V = 0.0,
    double SIGMA_W = 0.0) {
  mnvOrbitalStateBuilder builder_(_fbb);
  builder_.add_SIGMA_W(SIGMA_W);
  builder_.add_SIGMA_V(SIGMA_V);
  builder_.add_SIGMA_U(SIGMA_U);
  builder_.add_DRIFT_RATE(DRIFT_RATE);
  builder_.add_GEO_LONGITUDE(GEO_LONGITUDE);
  builder_.add_SMA(SMA);
  builder_.add_RAAN(RAAN);
  builder_.add_PERIOD(PERIOD);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_PERIGEE(PERIGEE);
  builder_.add_APOGEE(APOGEE);
  builder_.add_BALLISTIC_COEFF(BALLISTIC_COEFF);
  builder_.add_RADIATION_PRESS_COEFF(RADIATION_PRESS_COEFF);
  builder_.add_VEL_Z(VEL_Z);
  builder_.add_VEL_Y(VEL_Y);
  builder_.add_VEL_X(VEL_X);
  builder_.add_POS_Z(POS_Z);
  builder_.add_POS_Y(POS_Y);
  builder_.add_POS_X(POS_X);
  builder_.add_STATE_VECTOR(STATE_VECTOR);
  builder_.add_ID_STATE_VECTOR(ID_STATE_VECTOR);
  builder_.add_ELSET(ELSET);
  builder_.add_ID_ELSET(ID_ELSET);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<mnvOrbitalState> CreatemnvOrbitalStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID_ELSET = nullptr,
    const char *ELSET = nullptr,
    const char *ID_STATE_VECTOR = nullptr,
    const char *STATE_VECTOR = nullptr,
    double POS_X = 0.0,
    double POS_Y = 0.0,
    double POS_Z = 0.0,
    double VEL_X = 0.0,
    double VEL_Y = 0.0,
    double VEL_Z = 0.0,
    double RADIATION_PRESS_COEFF = 0.0,
    double BALLISTIC_COEFF = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double INCLINATION = 0.0,
    double ECCENTRICITY = 0.0,
    double PERIOD = 0.0,
    double RAAN = 0.0,
    double SMA = 0.0,
    double GEO_LONGITUDE = 0.0,
    double DRIFT_RATE = 0.0,
    double SIGMA_U = 0.0,
    double SIGMA_V = 0.0,
    double SIGMA_W = 0.0) {
  auto ID_ELSET__ = ID_ELSET ? _fbb.CreateString(ID_ELSET) : 0;
  auto ELSET__ = ELSET ? _fbb.CreateString(ELSET) : 0;
  auto ID_STATE_VECTOR__ = ID_STATE_VECTOR ? _fbb.CreateString(ID_STATE_VECTOR) : 0;
  auto STATE_VECTOR__ = STATE_VECTOR ? _fbb.CreateString(STATE_VECTOR) : 0;
  return CreatemnvOrbitalState(
      _fbb,
      ID_ELSET__,
      ELSET__,
      ID_STATE_VECTOR__,
      STATE_VECTOR__,
      POS_X,
      POS_Y,
      POS_Z,
      VEL_X,
      VEL_Y,
      VEL_Z,
      RADIATION_PRESS_COEFF,
      BALLISTIC_COEFF,
      APOGEE,
      PERIGEE,
      INCLINATION,
      ECCENTRICITY,
      PERIOD,
      RAAN,
      SMA,
      GEO_LONGITUDE,
      DRIFT_RATE,
      SIGMA_U,
      SIGMA_V,
      SIGMA_W);
}

/// Spacecraft Maneuver
struct MNV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MNVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SAT_NO = 6,
    VT_ORIG_OBJECT_ID = 8,
    VT_ON_ORBIT = 10,
    VT_STATUS = 12,
    VT_CHARACTERIZATION = 14,
    VT_CHARACTERIZATION_UNC = 16,
    VT_REPORT_TIME = 18,
    VT_EVENT_START_TIME = 20,
    VT_EVENT_END_TIME = 22,
    VT_TOTAL_BURN_TIME = 24,
    VT_OD_FIT_END_TIME = 26,
    VT_ID_SENSOR = 28,
    VT_ORIG_SENSOR_ID = 30,
    VT_EVENT_ID = 32,
    VT_UCT = 34,
    VT_MANEUVER_UNC = 36,
    VT_DELTA_VEL = 38,
    VT_DELTA_VEL_U = 40,
    VT_DELTA_VEL_V = 42,
    VT_DELTA_VEL_W = 44,
    VT_DELTA_POS = 46,
    VT_DELTA_POS_U = 48,
    VT_DELTA_POS_V = 50,
    VT_DELTA_POS_W = 52,
    VT_DELTA_MASS = 54,
    VT_PRE_EVENT = 56,
    VT_POST_EVENT = 58,
    VT_POST_MASS = 60,
    VT_POST_AREA = 62,
    VT_COV = 64,
    VT_NUM_OBS = 66,
    VT_STATE_MODEL = 68,
    VT_STATE_MODEL_VERSION = 70,
    VT_NUM_ACCEL_POINTS = 72,
    VT_MNVR_ACCEL_TIMES = 74,
    VT_MNVR_ACCELS = 76,
    VT_MNVR_ACCEL_UNCS = 78,
    VT_DESCRIPTION = 80,
    VT_DESCRIPTOR = 82,
    VT_ALGORITHM = 84,
    VT_TAGS = 86,
    VT_SOURCED_DATA = 88,
    VT_SOURCED_DATA_TYPES = 90,
    VT_TRANSACTION_ID = 92
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Satellite catalog number
  uint32_t SAT_NO() const {
    return GetField<uint32_t>(VT_SAT_NO, 0);
  }
  /// International designator
  const ::flatbuffers::String *ORIG_OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_OBJECT_ID);
  }
  /// On-orbit reference
  const ::flatbuffers::String *ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ON_ORBIT);
  }
  /// Maneuver status
  maneuverStatus STATUS() const {
    return static_cast<maneuverStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  /// Maneuver characterization
  maneuverCharacterization CHARACTERIZATION() const {
    return static_cast<maneuverCharacterization>(GetField<int8_t>(VT_CHARACTERIZATION, 0));
  }
  /// Characterization uncertainty (0-1)
  double CHARACTERIZATION_UNC() const {
    return GetField<double>(VT_CHARACTERIZATION_UNC, 0.0);
  }
  /// Detection report time (ISO 8601)
  const ::flatbuffers::String *REPORT_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REPORT_TIME);
  }
  /// Maneuver start time (ISO 8601)
  const ::flatbuffers::String *EVENT_START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_START_TIME);
  }
  /// Maneuver end time (ISO 8601)
  const ::flatbuffers::String *EVENT_END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_END_TIME);
  }
  /// Total burn time (seconds)
  double TOTAL_BURN_TIME() const {
    return GetField<double>(VT_TOTAL_BURN_TIME, 0.0);
  }
  /// OD fit end time (ISO 8601)
  const ::flatbuffers::String *OD_FIT_END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_FIT_END_TIME);
  }
  /// Detecting sensor identifier
  const ::flatbuffers::String *ID_SENSOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_SENSOR);
  }
  /// Original sensor identifier
  const ::flatbuffers::String *ORIG_SENSOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_SENSOR_ID);
  }
  /// Maneuver event identifier
  const ::flatbuffers::String *EVENT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_ID);
  }
  /// True if object is uncorrelated
  bool UCT() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// Maneuver detection uncertainty (km)
  double MANEUVER_UNC() const {
    return GetField<double>(VT_MANEUVER_UNC, 0.0);
  }
  /// Total delta-V magnitude (km/s)
  double DELTA_VEL() const {
    return GetField<double>(VT_DELTA_VEL, 0.0);
  }
  /// Delta-V along-track/U component (km/s)
  double DELTA_VEL_U() const {
    return GetField<double>(VT_DELTA_VEL_U, 0.0);
  }
  /// Delta-V cross-track/V component (km/s)
  double DELTA_VEL_V() const {
    return GetField<double>(VT_DELTA_VEL_V, 0.0);
  }
  /// Delta-V radial/W component (km/s)
  double DELTA_VEL_W() const {
    return GetField<double>(VT_DELTA_VEL_W, 0.0);
  }
  /// Total delta position (km)
  double DELTA_POS() const {
    return GetField<double>(VT_DELTA_POS, 0.0);
  }
  /// Delta position U component (km)
  double DELTA_POS_U() const {
    return GetField<double>(VT_DELTA_POS_U, 0.0);
  }
  /// Delta position V component (km)
  double DELTA_POS_V() const {
    return GetField<double>(VT_DELTA_POS_V, 0.0);
  }
  /// Delta position W component (km)
  double DELTA_POS_W() const {
    return GetField<double>(VT_DELTA_POS_W, 0.0);
  }
  /// Propellant mass consumed (kg)
  double DELTA_MASS() const {
    return GetField<double>(VT_DELTA_MASS, 0.0);
  }
  /// Pre-maneuver orbital state
  const mnvOrbitalState *PRE_EVENT() const {
    return GetPointer<const mnvOrbitalState *>(VT_PRE_EVENT);
  }
  /// Post-maneuver orbital state
  const mnvOrbitalState *POST_EVENT() const {
    return GetPointer<const mnvOrbitalState *>(VT_POST_EVENT);
  }
  /// Post-maneuver mass (kg)
  double POST_MASS() const {
    return GetField<double>(VT_POST_MASS, 0.0);
  }
  /// Post-maneuver cross-sectional area (m^2)
  double POST_AREA() const {
    return GetField<double>(VT_POST_AREA, 0.0);
  }
  /// 6x6 covariance matrix (upper triangle, row-major)
  const ::flatbuffers::Vector<double> *COV() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COV);
  }
  /// Number of observations used
  uint32_t NUM_OBS() const {
    return GetField<uint32_t>(VT_NUM_OBS, 0);
  }
  /// State model used
  const ::flatbuffers::String *STATE_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATE_MODEL);
  }
  /// State model version
  double STATE_MODEL_VERSION() const {
    return GetField<double>(VT_STATE_MODEL_VERSION, 0.0);
  }
  /// Number of acceleration profile points
  uint16_t NUM_ACCEL_POINTS() const {
    return GetField<uint16_t>(VT_NUM_ACCEL_POINTS, 0);
  }
  /// Acceleration profile times (ISO 8601)
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MNVR_ACCEL_TIMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MNVR_ACCEL_TIMES);
  }
  /// Acceleration values (km/s^2, 3 components per point)
  const ::flatbuffers::Vector<double> *MNVR_ACCELS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_MNVR_ACCELS);
  }
  /// Acceleration uncertainties (km/s^2)
  const ::flatbuffers::Vector<double> *MNVR_ACCEL_UNCS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_MNVR_ACCEL_UNCS);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Event descriptor
  const ::flatbuffers::String *DESCRIPTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Algorithm used for detection
  const ::flatbuffers::String *ALGORITHM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM);
  }
  /// Associated tags
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *TAGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Sourced data references
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *SOURCED_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SOURCED_DATA);
  }
  /// Sourced data types
  const ::flatbuffers::String *SOURCED_DATA_TYPES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCED_DATA_TYPES);
  }
  /// Transaction identifier
  const ::flatbuffers::String *TRANSACTION_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTION_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyField<uint32_t>(verifier, VT_SAT_NO, 4) &&
           VerifyOffset(verifier, VT_ORIG_OBJECT_ID) &&
           verifier.VerifyString(ORIG_OBJECT_ID()) &&
           VerifyOffset(verifier, VT_ON_ORBIT) &&
           verifier.VerifyString(ON_ORBIT()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyField<int8_t>(verifier, VT_CHARACTERIZATION, 1) &&
           VerifyField<double>(verifier, VT_CHARACTERIZATION_UNC, 8) &&
           VerifyOffset(verifier, VT_REPORT_TIME) &&
           verifier.VerifyString(REPORT_TIME()) &&
           VerifyOffset(verifier, VT_EVENT_START_TIME) &&
           verifier.VerifyString(EVENT_START_TIME()) &&
           VerifyOffset(verifier, VT_EVENT_END_TIME) &&
           verifier.VerifyString(EVENT_END_TIME()) &&
           VerifyField<double>(verifier, VT_TOTAL_BURN_TIME, 8) &&
           VerifyOffset(verifier, VT_OD_FIT_END_TIME) &&
           verifier.VerifyString(OD_FIT_END_TIME()) &&
           VerifyOffset(verifier, VT_ID_SENSOR) &&
           verifier.VerifyString(ID_SENSOR()) &&
           VerifyOffset(verifier, VT_ORIG_SENSOR_ID) &&
           verifier.VerifyString(ORIG_SENSOR_ID()) &&
           VerifyOffset(verifier, VT_EVENT_ID) &&
           verifier.VerifyString(EVENT_ID()) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyField<double>(verifier, VT_MANEUVER_UNC, 8) &&
           VerifyField<double>(verifier, VT_DELTA_VEL, 8) &&
           VerifyField<double>(verifier, VT_DELTA_VEL_U, 8) &&
           VerifyField<double>(verifier, VT_DELTA_VEL_V, 8) &&
           VerifyField<double>(verifier, VT_DELTA_VEL_W, 8) &&
           VerifyField<double>(verifier, VT_DELTA_POS, 8) &&
           VerifyField<double>(verifier, VT_DELTA_POS_U, 8) &&
           VerifyField<double>(verifier, VT_DELTA_POS_V, 8) &&
           VerifyField<double>(verifier, VT_DELTA_POS_W, 8) &&
           VerifyField<double>(verifier, VT_DELTA_MASS, 8) &&
           VerifyOffset(verifier, VT_PRE_EVENT) &&
           verifier.VerifyTable(PRE_EVENT()) &&
           VerifyOffset(verifier, VT_POST_EVENT) &&
           verifier.VerifyTable(POST_EVENT()) &&
           VerifyField<double>(verifier, VT_POST_MASS, 8) &&
           VerifyField<double>(verifier, VT_POST_AREA, 8) &&
           VerifyOffset(verifier, VT_COV) &&
           verifier.VerifyVector(COV()) &&
           VerifyField<uint32_t>(verifier, VT_NUM_OBS, 4) &&
           VerifyOffset(verifier, VT_STATE_MODEL) &&
           verifier.VerifyString(STATE_MODEL()) &&
           VerifyField<double>(verifier, VT_STATE_MODEL_VERSION, 8) &&
           VerifyField<uint16_t>(verifier, VT_NUM_ACCEL_POINTS, 2) &&
           VerifyOffset(verifier, VT_MNVR_ACCEL_TIMES) &&
           verifier.VerifyVector(MNVR_ACCEL_TIMES()) &&
           verifier.VerifyVectorOfStrings(MNVR_ACCEL_TIMES()) &&
           VerifyOffset(verifier, VT_MNVR_ACCELS) &&
           verifier.VerifyVector(MNVR_ACCELS()) &&
           VerifyOffset(verifier, VT_MNVR_ACCEL_UNCS) &&
           verifier.VerifyVector(MNVR_ACCEL_UNCS()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(DESCRIPTOR()) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           verifier.VerifyString(ALGORITHM()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(TAGS()) &&
           verifier.VerifyVectorOfStrings(TAGS()) &&
           VerifyOffset(verifier, VT_SOURCED_DATA) &&
           verifier.VerifyVector(SOURCED_DATA()) &&
           verifier.VerifyVectorOfStrings(SOURCED_DATA()) &&
           VerifyOffset(verifier, VT_SOURCED_DATA_TYPES) &&
           verifier.VerifyString(SOURCED_DATA_TYPES()) &&
           VerifyOffset(verifier, VT_TRANSACTION_ID) &&
           verifier.VerifyString(TRANSACTION_ID()) &&
           verifier.EndTable();
  }
};

struct MNVBuilder {
  typedef MNV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(MNV::VT_ID, ID);
  }
  void add_SAT_NO(uint32_t SAT_NO) {
    fbb_.AddElement<uint32_t>(MNV::VT_SAT_NO, SAT_NO, 0);
  }
  void add_ORIG_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID) {
    fbb_.AddOffset(MNV::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  void add_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ON_ORBIT) {
    fbb_.AddOffset(MNV::VT_ON_ORBIT, ON_ORBIT);
  }
  void add_STATUS(maneuverStatus STATUS) {
    fbb_.AddElement<int8_t>(MNV::VT_STATUS, static_cast<int8_t>(STATUS), 0);
  }
  void add_CHARACTERIZATION(maneuverCharacterization CHARACTERIZATION) {
    fbb_.AddElement<int8_t>(MNV::VT_CHARACTERIZATION, static_cast<int8_t>(CHARACTERIZATION), 0);
  }
  void add_CHARACTERIZATION_UNC(double CHARACTERIZATION_UNC) {
    fbb_.AddElement<double>(MNV::VT_CHARACTERIZATION_UNC, CHARACTERIZATION_UNC, 0.0);
  }
  void add_REPORT_TIME(::flatbuffers::Offset<::flatbuffers::String> REPORT_TIME) {
    fbb_.AddOffset(MNV::VT_REPORT_TIME, REPORT_TIME);
  }
  void add_EVENT_START_TIME(::flatbuffers::Offset<::flatbuffers::String> EVENT_START_TIME) {
    fbb_.AddOffset(MNV::VT_EVENT_START_TIME, EVENT_START_TIME);
  }
  void add_EVENT_END_TIME(::flatbuffers::Offset<::flatbuffers::String> EVENT_END_TIME) {
    fbb_.AddOffset(MNV::VT_EVENT_END_TIME, EVENT_END_TIME);
  }
  void add_TOTAL_BURN_TIME(double TOTAL_BURN_TIME) {
    fbb_.AddElement<double>(MNV::VT_TOTAL_BURN_TIME, TOTAL_BURN_TIME, 0.0);
  }
  void add_OD_FIT_END_TIME(::flatbuffers::Offset<::flatbuffers::String> OD_FIT_END_TIME) {
    fbb_.AddOffset(MNV::VT_OD_FIT_END_TIME, OD_FIT_END_TIME);
  }
  void add_ID_SENSOR(::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR) {
    fbb_.AddOffset(MNV::VT_ID_SENSOR, ID_SENSOR);
  }
  void add_ORIG_SENSOR_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID) {
    fbb_.AddOffset(MNV::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  void add_EVENT_ID(::flatbuffers::Offset<::flatbuffers::String> EVENT_ID) {
    fbb_.AddOffset(MNV::VT_EVENT_ID, EVENT_ID);
  }
  void add_UCT(bool UCT) {
    fbb_.AddElement<uint8_t>(MNV::VT_UCT, static_cast<uint8_t>(UCT), 0);
  }
  void add_MANEUVER_UNC(double MANEUVER_UNC) {
    fbb_.AddElement<double>(MNV::VT_MANEUVER_UNC, MANEUVER_UNC, 0.0);
  }
  void add_DELTA_VEL(double DELTA_VEL) {
    fbb_.AddElement<double>(MNV::VT_DELTA_VEL, DELTA_VEL, 0.0);
  }
  void add_DELTA_VEL_U(double DELTA_VEL_U) {
    fbb_.AddElement<double>(MNV::VT_DELTA_VEL_U, DELTA_VEL_U, 0.0);
  }
  void add_DELTA_VEL_V(double DELTA_VEL_V) {
    fbb_.AddElement<double>(MNV::VT_DELTA_VEL_V, DELTA_VEL_V, 0.0);
  }
  void add_DELTA_VEL_W(double DELTA_VEL_W) {
    fbb_.AddElement<double>(MNV::VT_DELTA_VEL_W, DELTA_VEL_W, 0.0);
  }
  void add_DELTA_POS(double DELTA_POS) {
    fbb_.AddElement<double>(MNV::VT_DELTA_POS, DELTA_POS, 0.0);
  }
  void add_DELTA_POS_U(double DELTA_POS_U) {
    fbb_.AddElement<double>(MNV::VT_DELTA_POS_U, DELTA_POS_U, 0.0);
  }
  void add_DELTA_POS_V(double DELTA_POS_V) {
    fbb_.AddElement<double>(MNV::VT_DELTA_POS_V, DELTA_POS_V, 0.0);
  }
  void add_DELTA_POS_W(double DELTA_POS_W) {
    fbb_.AddElement<double>(MNV::VT_DELTA_POS_W, DELTA_POS_W, 0.0);
  }
  void add_DELTA_MASS(double DELTA_MASS) {
    fbb_.AddElement<double>(MNV::VT_DELTA_MASS, DELTA_MASS, 0.0);
  }
  void add_PRE_EVENT(::flatbuffers::Offset<mnvOrbitalState> PRE_EVENT) {
    fbb_.AddOffset(MNV::VT_PRE_EVENT, PRE_EVENT);
  }
  void add_POST_EVENT(::flatbuffers::Offset<mnvOrbitalState> POST_EVENT) {
    fbb_.AddOffset(MNV::VT_POST_EVENT, POST_EVENT);
  }
  void add_POST_MASS(double POST_MASS) {
    fbb_.AddElement<double>(MNV::VT_POST_MASS, POST_MASS, 0.0);
  }
  void add_POST_AREA(double POST_AREA) {
    fbb_.AddElement<double>(MNV::VT_POST_AREA, POST_AREA, 0.0);
  }
  void add_COV(::flatbuffers::Offset<::flatbuffers::Vector<double>> COV) {
    fbb_.AddOffset(MNV::VT_COV, COV);
  }
  void add_NUM_OBS(uint32_t NUM_OBS) {
    fbb_.AddElement<uint32_t>(MNV::VT_NUM_OBS, NUM_OBS, 0);
  }
  void add_STATE_MODEL(::flatbuffers::Offset<::flatbuffers::String> STATE_MODEL) {
    fbb_.AddOffset(MNV::VT_STATE_MODEL, STATE_MODEL);
  }
  void add_STATE_MODEL_VERSION(double STATE_MODEL_VERSION) {
    fbb_.AddElement<double>(MNV::VT_STATE_MODEL_VERSION, STATE_MODEL_VERSION, 0.0);
  }
  void add_NUM_ACCEL_POINTS(uint16_t NUM_ACCEL_POINTS) {
    fbb_.AddElement<uint16_t>(MNV::VT_NUM_ACCEL_POINTS, NUM_ACCEL_POINTS, 0);
  }
  void add_MNVR_ACCEL_TIMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MNVR_ACCEL_TIMES) {
    fbb_.AddOffset(MNV::VT_MNVR_ACCEL_TIMES, MNVR_ACCEL_TIMES);
  }
  void add_MNVR_ACCELS(::flatbuffers::Offset<::flatbuffers::Vector<double>> MNVR_ACCELS) {
    fbb_.AddOffset(MNV::VT_MNVR_ACCELS, MNVR_ACCELS);
  }
  void add_MNVR_ACCEL_UNCS(::flatbuffers::Offset<::flatbuffers::Vector<double>> MNVR_ACCEL_UNCS) {
    fbb_.AddOffset(MNV::VT_MNVR_ACCEL_UNCS, MNVR_ACCEL_UNCS);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(MNV::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_DESCRIPTOR(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTOR) {
    fbb_.AddOffset(MNV::VT_DESCRIPTOR, DESCRIPTOR);
  }
  void add_ALGORITHM(::flatbuffers::Offset<::flatbuffers::String> ALGORITHM) {
    fbb_.AddOffset(MNV::VT_ALGORITHM, ALGORITHM);
  }
  void add_TAGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TAGS) {
    fbb_.AddOffset(MNV::VT_TAGS, TAGS);
  }
  void add_SOURCED_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> SOURCED_DATA) {
    fbb_.AddOffset(MNV::VT_SOURCED_DATA, SOURCED_DATA);
  }
  void add_SOURCED_DATA_TYPES(::flatbuffers::Offset<::flatbuffers::String> SOURCED_DATA_TYPES) {
    fbb_.AddOffset(MNV::VT_SOURCED_DATA_TYPES, SOURCED_DATA_TYPES);
  }
  void add_TRANSACTION_ID(::flatbuffers::Offset<::flatbuffers::String> TRANSACTION_ID) {
    fbb_.AddOffset(MNV::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  explicit MNVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MNV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MNV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MNV> CreateMNV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    uint32_t SAT_NO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ON_ORBIT = 0,
    maneuverStatus STATUS = maneuverStatus_DETECTED,
    maneuverCharacterization CHARACTERIZATION = maneuverCharacterization_IN_PLANE,
    double CHARACTERIZATION_UNC = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> REPORT_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EVENT_START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EVENT_END_TIME = 0,
    double TOTAL_BURN_TIME = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_FIT_END_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EVENT_ID = 0,
    bool UCT = false,
    double MANEUVER_UNC = 0.0,
    double DELTA_VEL = 0.0,
    double DELTA_VEL_U = 0.0,
    double DELTA_VEL_V = 0.0,
    double DELTA_VEL_W = 0.0,
    double DELTA_POS = 0.0,
    double DELTA_POS_U = 0.0,
    double DELTA_POS_V = 0.0,
    double DELTA_POS_W = 0.0,
    double DELTA_MASS = 0.0,
    ::flatbuffers::Offset<mnvOrbitalState> PRE_EVENT = 0,
    ::flatbuffers::Offset<mnvOrbitalState> POST_EVENT = 0,
    double POST_MASS = 0.0,
    double POST_AREA = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> COV = 0,
    uint32_t NUM_OBS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STATE_MODEL = 0,
    double STATE_MODEL_VERSION = 0.0,
    uint16_t NUM_ACCEL_POINTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MNVR_ACCEL_TIMES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> MNVR_ACCELS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> MNVR_ACCEL_UNCS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALGORITHM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TAGS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> SOURCED_DATA = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCED_DATA_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRANSACTION_ID = 0) {
  MNVBuilder builder_(_fbb);
  builder_.add_STATE_MODEL_VERSION(STATE_MODEL_VERSION);
  builder_.add_POST_AREA(POST_AREA);
  builder_.add_POST_MASS(POST_MASS);
  builder_.add_DELTA_MASS(DELTA_MASS);
  builder_.add_DELTA_POS_W(DELTA_POS_W);
  builder_.add_DELTA_POS_V(DELTA_POS_V);
  builder_.add_DELTA_POS_U(DELTA_POS_U);
  builder_.add_DELTA_POS(DELTA_POS);
  builder_.add_DELTA_VEL_W(DELTA_VEL_W);
  builder_.add_DELTA_VEL_V(DELTA_VEL_V);
  builder_.add_DELTA_VEL_U(DELTA_VEL_U);
  builder_.add_DELTA_VEL(DELTA_VEL);
  builder_.add_MANEUVER_UNC(MANEUVER_UNC);
  builder_.add_TOTAL_BURN_TIME(TOTAL_BURN_TIME);
  builder_.add_CHARACTERIZATION_UNC(CHARACTERIZATION_UNC);
  builder_.add_TRANSACTION_ID(TRANSACTION_ID);
  builder_.add_SOURCED_DATA_TYPES(SOURCED_DATA_TYPES);
  builder_.add_SOURCED_DATA(SOURCED_DATA);
  builder_.add_TAGS(TAGS);
  builder_.add_ALGORITHM(ALGORITHM);
  builder_.add_DESCRIPTOR(DESCRIPTOR);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_MNVR_ACCEL_UNCS(MNVR_ACCEL_UNCS);
  builder_.add_MNVR_ACCELS(MNVR_ACCELS);
  builder_.add_MNVR_ACCEL_TIMES(MNVR_ACCEL_TIMES);
  builder_.add_STATE_MODEL(STATE_MODEL);
  builder_.add_NUM_OBS(NUM_OBS);
  builder_.add_COV(COV);
  builder_.add_POST_EVENT(POST_EVENT);
  builder_.add_PRE_EVENT(PRE_EVENT);
  builder_.add_EVENT_ID(EVENT_ID);
  builder_.add_ORIG_SENSOR_ID(ORIG_SENSOR_ID);
  builder_.add_ID_SENSOR(ID_SENSOR);
  builder_.add_OD_FIT_END_TIME(OD_FIT_END_TIME);
  builder_.add_EVENT_END_TIME(EVENT_END_TIME);
  builder_.add_EVENT_START_TIME(EVENT_START_TIME);
  builder_.add_REPORT_TIME(REPORT_TIME);
  builder_.add_ON_ORBIT(ON_ORBIT);
  builder_.add_ORIG_OBJECT_ID(ORIG_OBJECT_ID);
  builder_.add_SAT_NO(SAT_NO);
  builder_.add_ID(ID);
  builder_.add_NUM_ACCEL_POINTS(NUM_ACCEL_POINTS);
  builder_.add_UCT(UCT);
  builder_.add_CHARACTERIZATION(CHARACTERIZATION);
  builder_.add_STATUS(STATUS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MNV> CreateMNVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    uint32_t SAT_NO = 0,
    const char *ORIG_OBJECT_ID = nullptr,
    const char *ON_ORBIT = nullptr,
    maneuverStatus STATUS = maneuverStatus_DETECTED,
    maneuverCharacterization CHARACTERIZATION = maneuverCharacterization_IN_PLANE,
    double CHARACTERIZATION_UNC = 0.0,
    const char *REPORT_TIME = nullptr,
    const char *EVENT_START_TIME = nullptr,
    const char *EVENT_END_TIME = nullptr,
    double TOTAL_BURN_TIME = 0.0,
    const char *OD_FIT_END_TIME = nullptr,
    const char *ID_SENSOR = nullptr,
    const char *ORIG_SENSOR_ID = nullptr,
    const char *EVENT_ID = nullptr,
    bool UCT = false,
    double MANEUVER_UNC = 0.0,
    double DELTA_VEL = 0.0,
    double DELTA_VEL_U = 0.0,
    double DELTA_VEL_V = 0.0,
    double DELTA_VEL_W = 0.0,
    double DELTA_POS = 0.0,
    double DELTA_POS_U = 0.0,
    double DELTA_POS_V = 0.0,
    double DELTA_POS_W = 0.0,
    double DELTA_MASS = 0.0,
    ::flatbuffers::Offset<mnvOrbitalState> PRE_EVENT = 0,
    ::flatbuffers::Offset<mnvOrbitalState> POST_EVENT = 0,
    double POST_MASS = 0.0,
    double POST_AREA = 0.0,
    const std::vector<double> *COV = nullptr,
    uint32_t NUM_OBS = 0,
    const char *STATE_MODEL = nullptr,
    double STATE_MODEL_VERSION = 0.0,
    uint16_t NUM_ACCEL_POINTS = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MNVR_ACCEL_TIMES = nullptr,
    const std::vector<double> *MNVR_ACCELS = nullptr,
    const std::vector<double> *MNVR_ACCEL_UNCS = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *DESCRIPTOR = nullptr,
    const char *ALGORITHM = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *TAGS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *SOURCED_DATA = nullptr,
    const char *SOURCED_DATA_TYPES = nullptr,
    const char *TRANSACTION_ID = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto ORIG_OBJECT_ID__ = ORIG_OBJECT_ID ? _fbb.CreateString(ORIG_OBJECT_ID) : 0;
  auto ON_ORBIT__ = ON_ORBIT ? _fbb.CreateString(ON_ORBIT) : 0;
  auto REPORT_TIME__ = REPORT_TIME ? _fbb.CreateString(REPORT_TIME) : 0;
  auto EVENT_START_TIME__ = EVENT_START_TIME ? _fbb.CreateString(EVENT_START_TIME) : 0;
  auto EVENT_END_TIME__ = EVENT_END_TIME ? _fbb.CreateString(EVENT_END_TIME) : 0;
  auto OD_FIT_END_TIME__ = OD_FIT_END_TIME ? _fbb.CreateString(OD_FIT_END_TIME) : 0;
  auto ID_SENSOR__ = ID_SENSOR ? _fbb.CreateString(ID_SENSOR) : 0;
  auto ORIG_SENSOR_ID__ = ORIG_SENSOR_ID ? _fbb.CreateString(ORIG_SENSOR_ID) : 0;
  auto EVENT_ID__ = EVENT_ID ? _fbb.CreateString(EVENT_ID) : 0;
  auto COV__ = COV ? _fbb.CreateVector<double>(*COV) : 0;
  auto STATE_MODEL__ = STATE_MODEL ? _fbb.CreateString(STATE_MODEL) : 0;
  auto MNVR_ACCEL_TIMES__ = MNVR_ACCEL_TIMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MNVR_ACCEL_TIMES) : 0;
  auto MNVR_ACCELS__ = MNVR_ACCELS ? _fbb.CreateVector<double>(*MNVR_ACCELS) : 0;
  auto MNVR_ACCEL_UNCS__ = MNVR_ACCEL_UNCS ? _fbb.CreateVector<double>(*MNVR_ACCEL_UNCS) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto DESCRIPTOR__ = DESCRIPTOR ? _fbb.CreateString(DESCRIPTOR) : 0;
  auto ALGORITHM__ = ALGORITHM ? _fbb.CreateString(ALGORITHM) : 0;
  auto TAGS__ = TAGS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*TAGS) : 0;
  auto SOURCED_DATA__ = SOURCED_DATA ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*SOURCED_DATA) : 0;
  auto SOURCED_DATA_TYPES__ = SOURCED_DATA_TYPES ? _fbb.CreateString(SOURCED_DATA_TYPES) : 0;
  auto TRANSACTION_ID__ = TRANSACTION_ID ? _fbb.CreateString(TRANSACTION_ID) : 0;
  return CreateMNV(
      _fbb,
      ID__,
      SAT_NO,
      ORIG_OBJECT_ID__,
      ON_ORBIT__,
      STATUS,
      CHARACTERIZATION,
      CHARACTERIZATION_UNC,
      REPORT_TIME__,
      EVENT_START_TIME__,
      EVENT_END_TIME__,
      TOTAL_BURN_TIME,
      OD_FIT_END_TIME__,
      ID_SENSOR__,
      ORIG_SENSOR_ID__,
      EVENT_ID__,
      UCT,
      MANEUVER_UNC,
      DELTA_VEL,
      DELTA_VEL_U,
      DELTA_VEL_V,
      DELTA_VEL_W,
      DELTA_POS,
      DELTA_POS_U,
      DELTA_POS_V,
      DELTA_POS_W,
      DELTA_MASS,
      PRE_EVENT,
      POST_EVENT,
      POST_MASS,
      POST_AREA,
      COV__,
      NUM_OBS,
      STATE_MODEL__,
      STATE_MODEL_VERSION,
      NUM_ACCEL_POINTS,
      MNVR_ACCEL_TIMES__,
      MNVR_ACCELS__,
      MNVR_ACCEL_UNCS__,
      DESCRIPTION__,
      DESCRIPTOR__,
      ALGORITHM__,
      TAGS__,
      SOURCED_DATA__,
      SOURCED_DATA_TYPES__,
      TRANSACTION_ID__);
}

inline const MNV *GetMNV(const void *buf) {
  return ::flatbuffers::GetRoot<MNV>(buf);
}

inline const MNV *GetSizePrefixedMNV(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MNV>(buf);
}

inline const char *MNVIdentifier() {
  return "$MNV";
}

inline bool MNVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MNVIdentifier());
}

inline bool SizePrefixedMNVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MNVIdentifier(), true);
}

inline bool VerifyMNVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MNV>(MNVIdentifier());
}

inline bool VerifySizePrefixedMNVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MNV>(MNVIdentifier());
}

inline void FinishMNVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MNV> root) {
  fbb.Finish(root, MNVIdentifier());
}

inline void FinishSizePrefixedMNVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MNV> root) {
  fbb.FinishSizePrefixed(root, MNVIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
