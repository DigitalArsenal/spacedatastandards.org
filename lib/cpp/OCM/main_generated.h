// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct Header;
struct HeaderBuilder;

struct Metadata;
struct MetadataBuilder;

struct StateVector;
struct StateVectorBuilder;

struct PhysicalProperties;
struct PhysicalPropertiesBuilder;

struct Perturbations;
struct PerturbationsBuilder;

struct Maneuver;
struct ManeuverBuilder;

struct OrbitDetermination;
struct OrbitDeterminationBuilder;

struct UserDefinedParameters;
struct UserDefinedParametersBuilder;

struct OCM;
struct OCMBuilder;

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CCSDS_OCM_VERS = 4,
    VT_COMMENT = 6,
    VT_CLASSIFICATION = 8,
    VT_CREATION_DATE = 10,
    VT_ORIGINATOR = 12,
    VT_MESSAGE_ID = 14
  };
  /// Format version in the form of 'x.y', where 'y' is incremented for minor changes, and 'x' for major changes.
  const ::flatbuffers::String *CCSDS_OCM_VERS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CCSDS_OCM_VERS);
  }
  /// Comments (a contiguous set of one or more comment lines may be provided immediately after the version number).
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMENT);
  }
  /// User-defined free-text message classification/caveats of this OCM.
  const ::flatbuffers::String *CLASSIFICATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION);
  }
  /// File creation date/time in UTC.
  const ::flatbuffers::String *CREATION_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATION_DATE);
  }
  /// Creating agency or operator.
  const ::flatbuffers::String *ORIGINATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  /// Free-text field containing an ID that uniquely identifies a message from this originator.
  const ::flatbuffers::String *MESSAGE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CCSDS_OCM_VERS) &&
           verifier.VerifyString(CCSDS_OCM_VERS()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyVector(COMMENT()) &&
           verifier.VerifyVectorOfStrings(COMMENT()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyString(CLASSIFICATION()) &&
           VerifyOffset(verifier, VT_CREATION_DATE) &&
           verifier.VerifyString(CREATION_DATE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(ORIGINATOR()) &&
           VerifyOffset(verifier, VT_MESSAGE_ID) &&
           verifier.VerifyString(MESSAGE_ID()) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CCSDS_OCM_VERS(::flatbuffers::Offset<::flatbuffers::String> CCSDS_OCM_VERS) {
    fbb_.AddOffset(Header::VT_CCSDS_OCM_VERS, CCSDS_OCM_VERS);
  }
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT) {
    fbb_.AddOffset(Header::VT_COMMENT, COMMENT);
  }
  void add_CLASSIFICATION(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION) {
    fbb_.AddOffset(Header::VT_CLASSIFICATION, CLASSIFICATION);
  }
  void add_CREATION_DATE(::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE) {
    fbb_.AddOffset(Header::VT_CREATION_DATE, CREATION_DATE);
  }
  void add_ORIGINATOR(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR) {
    fbb_.AddOffset(Header::VT_ORIGINATOR, ORIGINATOR);
  }
  void add_MESSAGE_ID(::flatbuffers::Offset<::flatbuffers::String> MESSAGE_ID) {
    fbb_.AddOffset(Header::VT_MESSAGE_ID, MESSAGE_ID);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CCSDS_OCM_VERS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MESSAGE_ID = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_MESSAGE_ID(MESSAGE_ID);
  builder_.add_ORIGINATOR(ORIGINATOR);
  builder_.add_CREATION_DATE(CREATION_DATE);
  builder_.add_CLASSIFICATION(CLASSIFICATION);
  builder_.add_COMMENT(COMMENT);
  builder_.add_CCSDS_OCM_VERS(CCSDS_OCM_VERS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Header> CreateHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CCSDS_OCM_VERS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT = nullptr,
    const char *CLASSIFICATION = nullptr,
    const char *CREATION_DATE = nullptr,
    const char *ORIGINATOR = nullptr,
    const char *MESSAGE_ID = nullptr) {
  auto CCSDS_OCM_VERS__ = CCSDS_OCM_VERS ? _fbb.CreateString(CCSDS_OCM_VERS) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMMENT) : 0;
  auto CLASSIFICATION__ = CLASSIFICATION ? _fbb.CreateString(CLASSIFICATION) : 0;
  auto CREATION_DATE__ = CREATION_DATE ? _fbb.CreateString(CREATION_DATE) : 0;
  auto ORIGINATOR__ = ORIGINATOR ? _fbb.CreateString(ORIGINATOR) : 0;
  auto MESSAGE_ID__ = MESSAGE_ID ? _fbb.CreateString(MESSAGE_ID) : 0;
  return CreateHeader(
      _fbb,
      CCSDS_OCM_VERS__,
      COMMENT__,
      CLASSIFICATION__,
      CREATION_DATE__,
      ORIGINATOR__,
      MESSAGE_ID__);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMENT = 4,
    VT_OBJECT_NAME = 6,
    VT_INTERNATIONAL_DESIGNATOR = 8,
    VT_CATALOG_NAME = 10,
    VT_OBJECT_DESIGNATOR = 12,
    VT_ALTERNATE_NAMES = 14,
    VT_ORIGINATOR_POC = 16,
    VT_ORIGINATOR_POSITION = 18,
    VT_ORIGINATOR_PHONE = 20,
    VT_ORIGINATOR_EMAIL = 22,
    VT_ORIGINATOR_ADDRESS = 24,
    VT_TECH_ORG = 26,
    VT_TECH_POC = 28,
    VT_TECH_POSITION = 30,
    VT_TECH_PHONE = 32,
    VT_TECH_EMAIL = 34,
    VT_TECH_ADDRESS = 36,
    VT_PREVIOUS_MESSAGE_ID = 38,
    VT_NEXT_MESSAGE_ID = 40,
    VT_ADM_MSG_LINK = 42,
    VT_CDM_MSG_LINK = 44,
    VT_PRM_MSG_LINK = 46,
    VT_RDM_MSG_LINK = 48,
    VT_TDM_MSG_LINK = 50,
    VT_OPERATOR = 52,
    VT_OWNER = 54,
    VT_COUNTRY = 56,
    VT_CONSTELLATION = 58,
    VT_OBJECT_TYPE = 60,
    VT_TIME_SYSTEM = 62,
    VT_EPOCH_TZERO = 64,
    VT_OPS_STATUS = 66,
    VT_ORBIT_CATEGORY = 68,
    VT_OCM_DATA_ELEMENTS = 70,
    VT_SCLK_OFFSET_AT_EPOCH = 72,
    VT_SCLK_SEC_PER_SI_SEC = 74,
    VT_PREVIOUS_MESSAGE_EPOCH = 76,
    VT_NEXT_MESSAGE_EPOCH = 78,
    VT_START_TIME = 80,
    VT_STOP_TIME = 82,
    VT_TIME_SPAN = 84,
    VT_TAIMUTC_AT_TZERO = 86,
    VT_NEXT_LEAP_EPOCH = 88,
    VT_NEXT_LEAP_TAIMUTC = 90,
    VT_UT1MUTC_AT_TZERO = 92,
    VT_EOP_SOURCE = 94,
    VT_INTERP_METHOD_EOP = 96,
    VT_CELESTIAL_SOURCE = 98
  };
  /// Comments in the Metadata section.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMENT);
  }
  /// Free-text field containing the name of the object.
  const ::flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  /// International designator for the object as assigned by COSPAR.
  const ::flatbuffers::String *INTERNATIONAL_DESIGNATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERNATIONAL_DESIGNATOR);
  }
  /// Satellite catalog source from which 'OBJECT_DESIGNATOR' was obtained.
  const ::flatbuffers::String *CATALOG_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATALOG_NAME);
  }
  /// Unique satellite identification designator from the catalog.
  const ::flatbuffers::String *OBJECT_DESIGNATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_DESIGNATOR);
  }
  /// Alternate names of this space object.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALTERNATE_NAMES);
  }
  /// Originator or programmatic Point-of-Contact (PoC) for OCM.
  const ::flatbuffers::String *ORIGINATOR_POC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR_POC);
  }
  /// Contact position of the originator PoC.
  const ::flatbuffers::String *ORIGINATOR_POSITION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR_POSITION);
  }
  /// Originator PoC phone number.
  const ::flatbuffers::String *ORIGINATOR_PHONE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR_PHONE);
  }
  /// Originator PoC email address.
  const ::flatbuffers::String *ORIGINATOR_EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR_EMAIL);
  }
  /// Originator's physical address information.
  const ::flatbuffers::String *ORIGINATOR_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR_ADDRESS);
  }
  /// Creating agency or operator for technical contact.
  const ::flatbuffers::String *TECH_ORG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_ORG);
  }
  /// Technical Point-of-Contact (PoC) for OCM.
  const ::flatbuffers::String *TECH_POC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_POC);
  }
  /// Contact position of the technical PoC.
  const ::flatbuffers::String *TECH_POSITION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_POSITION);
  }
  /// Technical PoC phone number.
  const ::flatbuffers::String *TECH_PHONE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_PHONE);
  }
  /// Technical PoC email address.
  const ::flatbuffers::String *TECH_EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_EMAIL);
  }
  /// Technical PoC physical address information.
  const ::flatbuffers::String *TECH_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECH_ADDRESS);
  }
  /// ID that uniquely identifies the previous message from this originator.
  const ::flatbuffers::String *PREVIOUS_MESSAGE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREVIOUS_MESSAGE_ID);
  }
  /// ID that uniquely identifies the next message from this originator.
  const ::flatbuffers::String *NEXT_MESSAGE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXT_MESSAGE_ID);
  }
  /// Unique identifier of Attitude Data Messages linked to this OCM.
  const ::flatbuffers::String *ADM_MSG_LINK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADM_MSG_LINK);
  }
  /// Unique identifier of Conjunction Data Messages linked to this OCM.
  const ::flatbuffers::String *CDM_MSG_LINK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CDM_MSG_LINK);
  }
  /// Unique identifier of Pointing Request Messages linked to this OCM.
  const ::flatbuffers::String *PRM_MSG_LINK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRM_MSG_LINK);
  }
  /// Unique identifier of Reentry Data Messages linked to this OCM.
  const ::flatbuffers::String *RDM_MSG_LINK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RDM_MSG_LINK);
  }
  /// List of Tracking Data Messages upon which this orbit determination is based.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *TDM_MSG_LINK() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TDM_MSG_LINK);
  }
  /// Operator of the space object.
  const ::flatbuffers::String *OPERATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATOR);
  }
  /// Owner of the space object.
  const ::flatbuffers::String *OWNER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OWNER);
  }
  /// Country where the space object owner is based.
  const ::flatbuffers::String *COUNTRY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRY);
  }
  /// Name of the constellation to which this space object belongs.
  const ::flatbuffers::String *CONSTELLATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSTELLATION);
  }
  /// Specification of the type of object (e.g., PAYLOAD, ROCKET BODY, DEBRIS).
  const ::flatbuffers::String *OBJECT_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_TYPE);
  }
  /// Time system for all absolute time stamps in this OCM, including EPOCH_TZERO.
  const ::flatbuffers::String *TIME_SYSTEM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_SYSTEM);
  }
  /// Default epoch to which all relative times are referenced in data blocks.
  const ::flatbuffers::String *EPOCH_TZERO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH_TZERO);
  }
  /// Specification of the operational status of the space object.
  const ::flatbuffers::String *OPS_STATUS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPS_STATUS);
  }
  /// Specification of the type of orbit (e.g., GEO, LEO).
  const ::flatbuffers::String *ORBIT_CATEGORY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBIT_CATEGORY);
  }
  /// List of elements of information data blocks included in this message.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *OCM_DATA_ELEMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OCM_DATA_ELEMENTS);
  }
  /// Number of spacecraft clock counts at EPOCH_TZERO (used if TIME_SYSTEM is SCLK).
  double SCLK_OFFSET_AT_EPOCH() const {
    return GetField<double>(VT_SCLK_OFFSET_AT_EPOCH, 0.0);
  }
  /// Number of clock seconds occurring during one SI second (used if TIME_SYSTEM is SCLK).
  double SCLK_SEC_PER_SI_SEC() const {
    return GetField<double>(VT_SCLK_SEC_PER_SI_SEC, 0.0);
  }
  /// Creation epoch of the previous message from this originator.
  const ::flatbuffers::String *PREVIOUS_MESSAGE_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREVIOUS_MESSAGE_EPOCH);
  }
  /// Anticipated (or actual) epoch of the next message from this originator.
  const ::flatbuffers::String *NEXT_MESSAGE_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXT_MESSAGE_EPOCH);
  }
  /// Time of the earliest data contained in the OCM.
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  /// Time of the latest data contained in the OCM.
  const ::flatbuffers::String *STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOP_TIME);
  }
  /// Span of time that the OCM covers, measured in days.
  double TIME_SPAN() const {
    return GetField<double>(VT_TIME_SPAN, 0.0);
  }
  /// Difference (TAI - UTC) in seconds at EPOCH_TZERO.
  double TAIMUTC_AT_TZERO() const {
    return GetField<double>(VT_TAIMUTC_AT_TZERO, 0.0);
  }
  /// Epoch of next leap second.
  const ::flatbuffers::String *NEXT_LEAP_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXT_LEAP_EPOCH);
  }
  /// Difference (TAI - UTC) in seconds at NEXT_LEAP_EPOCH.
  double NEXT_LEAP_TAIMUTC() const {
    return GetField<double>(VT_NEXT_LEAP_TAIMUTC, 0.0);
  }
  /// Difference (UT1 - UTC) in seconds at EPOCH_TZERO.
  double UT1MUTC_AT_TZERO() const {
    return GetField<double>(VT_UT1MUTC_AT_TZERO, 0.0);
  }
  /// Source and version of Earth Orientation Parameters used.
  const ::flatbuffers::String *EOP_SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EOP_SOURCE);
  }
  /// Method used to select or interpolate sequential EOP data.
  const ::flatbuffers::String *INTERP_METHOD_EOP() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERP_METHOD_EOP);
  }
  /// Source and version of celestial body ephemeris data used.
  const ::flatbuffers::String *CELESTIAL_SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CELESTIAL_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyVector(COMMENT()) &&
           verifier.VerifyVectorOfStrings(COMMENT()) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_INTERNATIONAL_DESIGNATOR) &&
           verifier.VerifyString(INTERNATIONAL_DESIGNATOR()) &&
           VerifyOffset(verifier, VT_CATALOG_NAME) &&
           verifier.VerifyString(CATALOG_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_DESIGNATOR) &&
           verifier.VerifyString(OBJECT_DESIGNATOR()) &&
           VerifyOffset(verifier, VT_ALTERNATE_NAMES) &&
           verifier.VerifyVector(ALTERNATE_NAMES()) &&
           verifier.VerifyVectorOfStrings(ALTERNATE_NAMES()) &&
           VerifyOffset(verifier, VT_ORIGINATOR_POC) &&
           verifier.VerifyString(ORIGINATOR_POC()) &&
           VerifyOffset(verifier, VT_ORIGINATOR_POSITION) &&
           verifier.VerifyString(ORIGINATOR_POSITION()) &&
           VerifyOffset(verifier, VT_ORIGINATOR_PHONE) &&
           verifier.VerifyString(ORIGINATOR_PHONE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR_EMAIL) &&
           verifier.VerifyString(ORIGINATOR_EMAIL()) &&
           VerifyOffset(verifier, VT_ORIGINATOR_ADDRESS) &&
           verifier.VerifyString(ORIGINATOR_ADDRESS()) &&
           VerifyOffset(verifier, VT_TECH_ORG) &&
           verifier.VerifyString(TECH_ORG()) &&
           VerifyOffset(verifier, VT_TECH_POC) &&
           verifier.VerifyString(TECH_POC()) &&
           VerifyOffset(verifier, VT_TECH_POSITION) &&
           verifier.VerifyString(TECH_POSITION()) &&
           VerifyOffset(verifier, VT_TECH_PHONE) &&
           verifier.VerifyString(TECH_PHONE()) &&
           VerifyOffset(verifier, VT_TECH_EMAIL) &&
           verifier.VerifyString(TECH_EMAIL()) &&
           VerifyOffset(verifier, VT_TECH_ADDRESS) &&
           verifier.VerifyString(TECH_ADDRESS()) &&
           VerifyOffset(verifier, VT_PREVIOUS_MESSAGE_ID) &&
           verifier.VerifyString(PREVIOUS_MESSAGE_ID()) &&
           VerifyOffset(verifier, VT_NEXT_MESSAGE_ID) &&
           verifier.VerifyString(NEXT_MESSAGE_ID()) &&
           VerifyOffset(verifier, VT_ADM_MSG_LINK) &&
           verifier.VerifyString(ADM_MSG_LINK()) &&
           VerifyOffset(verifier, VT_CDM_MSG_LINK) &&
           verifier.VerifyString(CDM_MSG_LINK()) &&
           VerifyOffset(verifier, VT_PRM_MSG_LINK) &&
           verifier.VerifyString(PRM_MSG_LINK()) &&
           VerifyOffset(verifier, VT_RDM_MSG_LINK) &&
           verifier.VerifyString(RDM_MSG_LINK()) &&
           VerifyOffset(verifier, VT_TDM_MSG_LINK) &&
           verifier.VerifyVector(TDM_MSG_LINK()) &&
           verifier.VerifyVectorOfStrings(TDM_MSG_LINK()) &&
           VerifyOffset(verifier, VT_OPERATOR) &&
           verifier.VerifyString(OPERATOR()) &&
           VerifyOffset(verifier, VT_OWNER) &&
           verifier.VerifyString(OWNER()) &&
           VerifyOffset(verifier, VT_COUNTRY) &&
           verifier.VerifyString(COUNTRY()) &&
           VerifyOffset(verifier, VT_CONSTELLATION) &&
           verifier.VerifyString(CONSTELLATION()) &&
           VerifyOffset(verifier, VT_OBJECT_TYPE) &&
           verifier.VerifyString(OBJECT_TYPE()) &&
           VerifyOffset(verifier, VT_TIME_SYSTEM) &&
           verifier.VerifyString(TIME_SYSTEM()) &&
           VerifyOffset(verifier, VT_EPOCH_TZERO) &&
           verifier.VerifyString(EPOCH_TZERO()) &&
           VerifyOffset(verifier, VT_OPS_STATUS) &&
           verifier.VerifyString(OPS_STATUS()) &&
           VerifyOffset(verifier, VT_ORBIT_CATEGORY) &&
           verifier.VerifyString(ORBIT_CATEGORY()) &&
           VerifyOffset(verifier, VT_OCM_DATA_ELEMENTS) &&
           verifier.VerifyVector(OCM_DATA_ELEMENTS()) &&
           verifier.VerifyVectorOfStrings(OCM_DATA_ELEMENTS()) &&
           VerifyField<double>(verifier, VT_SCLK_OFFSET_AT_EPOCH, 8) &&
           VerifyField<double>(verifier, VT_SCLK_SEC_PER_SI_SEC, 8) &&
           VerifyOffset(verifier, VT_PREVIOUS_MESSAGE_EPOCH) &&
           verifier.VerifyString(PREVIOUS_MESSAGE_EPOCH()) &&
           VerifyOffset(verifier, VT_NEXT_MESSAGE_EPOCH) &&
           verifier.VerifyString(NEXT_MESSAGE_EPOCH()) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_STOP_TIME) &&
           verifier.VerifyString(STOP_TIME()) &&
           VerifyField<double>(verifier, VT_TIME_SPAN, 8) &&
           VerifyField<double>(verifier, VT_TAIMUTC_AT_TZERO, 8) &&
           VerifyOffset(verifier, VT_NEXT_LEAP_EPOCH) &&
           verifier.VerifyString(NEXT_LEAP_EPOCH()) &&
           VerifyField<double>(verifier, VT_NEXT_LEAP_TAIMUTC, 8) &&
           VerifyField<double>(verifier, VT_UT1MUTC_AT_TZERO, 8) &&
           VerifyOffset(verifier, VT_EOP_SOURCE) &&
           verifier.VerifyString(EOP_SOURCE()) &&
           VerifyOffset(verifier, VT_INTERP_METHOD_EOP) &&
           verifier.VerifyString(INTERP_METHOD_EOP()) &&
           VerifyOffset(verifier, VT_CELESTIAL_SOURCE) &&
           verifier.VerifyString(CELESTIAL_SOURCE()) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT) {
    fbb_.AddOffset(Metadata::VT_COMMENT, COMMENT);
  }
  void add_OBJECT_NAME(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(Metadata::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_INTERNATIONAL_DESIGNATOR(::flatbuffers::Offset<::flatbuffers::String> INTERNATIONAL_DESIGNATOR) {
    fbb_.AddOffset(Metadata::VT_INTERNATIONAL_DESIGNATOR, INTERNATIONAL_DESIGNATOR);
  }
  void add_CATALOG_NAME(::flatbuffers::Offset<::flatbuffers::String> CATALOG_NAME) {
    fbb_.AddOffset(Metadata::VT_CATALOG_NAME, CATALOG_NAME);
  }
  void add_OBJECT_DESIGNATOR(::flatbuffers::Offset<::flatbuffers::String> OBJECT_DESIGNATOR) {
    fbb_.AddOffset(Metadata::VT_OBJECT_DESIGNATOR, OBJECT_DESIGNATOR);
  }
  void add_ALTERNATE_NAMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES) {
    fbb_.AddOffset(Metadata::VT_ALTERNATE_NAMES, ALTERNATE_NAMES);
  }
  void add_ORIGINATOR_POC(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_POC) {
    fbb_.AddOffset(Metadata::VT_ORIGINATOR_POC, ORIGINATOR_POC);
  }
  void add_ORIGINATOR_POSITION(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_POSITION) {
    fbb_.AddOffset(Metadata::VT_ORIGINATOR_POSITION, ORIGINATOR_POSITION);
  }
  void add_ORIGINATOR_PHONE(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_PHONE) {
    fbb_.AddOffset(Metadata::VT_ORIGINATOR_PHONE, ORIGINATOR_PHONE);
  }
  void add_ORIGINATOR_EMAIL(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_EMAIL) {
    fbb_.AddOffset(Metadata::VT_ORIGINATOR_EMAIL, ORIGINATOR_EMAIL);
  }
  void add_ORIGINATOR_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_ADDRESS) {
    fbb_.AddOffset(Metadata::VT_ORIGINATOR_ADDRESS, ORIGINATOR_ADDRESS);
  }
  void add_TECH_ORG(::flatbuffers::Offset<::flatbuffers::String> TECH_ORG) {
    fbb_.AddOffset(Metadata::VT_TECH_ORG, TECH_ORG);
  }
  void add_TECH_POC(::flatbuffers::Offset<::flatbuffers::String> TECH_POC) {
    fbb_.AddOffset(Metadata::VT_TECH_POC, TECH_POC);
  }
  void add_TECH_POSITION(::flatbuffers::Offset<::flatbuffers::String> TECH_POSITION) {
    fbb_.AddOffset(Metadata::VT_TECH_POSITION, TECH_POSITION);
  }
  void add_TECH_PHONE(::flatbuffers::Offset<::flatbuffers::String> TECH_PHONE) {
    fbb_.AddOffset(Metadata::VT_TECH_PHONE, TECH_PHONE);
  }
  void add_TECH_EMAIL(::flatbuffers::Offset<::flatbuffers::String> TECH_EMAIL) {
    fbb_.AddOffset(Metadata::VT_TECH_EMAIL, TECH_EMAIL);
  }
  void add_TECH_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> TECH_ADDRESS) {
    fbb_.AddOffset(Metadata::VT_TECH_ADDRESS, TECH_ADDRESS);
  }
  void add_PREVIOUS_MESSAGE_ID(::flatbuffers::Offset<::flatbuffers::String> PREVIOUS_MESSAGE_ID) {
    fbb_.AddOffset(Metadata::VT_PREVIOUS_MESSAGE_ID, PREVIOUS_MESSAGE_ID);
  }
  void add_NEXT_MESSAGE_ID(::flatbuffers::Offset<::flatbuffers::String> NEXT_MESSAGE_ID) {
    fbb_.AddOffset(Metadata::VT_NEXT_MESSAGE_ID, NEXT_MESSAGE_ID);
  }
  void add_ADM_MSG_LINK(::flatbuffers::Offset<::flatbuffers::String> ADM_MSG_LINK) {
    fbb_.AddOffset(Metadata::VT_ADM_MSG_LINK, ADM_MSG_LINK);
  }
  void add_CDM_MSG_LINK(::flatbuffers::Offset<::flatbuffers::String> CDM_MSG_LINK) {
    fbb_.AddOffset(Metadata::VT_CDM_MSG_LINK, CDM_MSG_LINK);
  }
  void add_PRM_MSG_LINK(::flatbuffers::Offset<::flatbuffers::String> PRM_MSG_LINK) {
    fbb_.AddOffset(Metadata::VT_PRM_MSG_LINK, PRM_MSG_LINK);
  }
  void add_RDM_MSG_LINK(::flatbuffers::Offset<::flatbuffers::String> RDM_MSG_LINK) {
    fbb_.AddOffset(Metadata::VT_RDM_MSG_LINK, RDM_MSG_LINK);
  }
  void add_TDM_MSG_LINK(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TDM_MSG_LINK) {
    fbb_.AddOffset(Metadata::VT_TDM_MSG_LINK, TDM_MSG_LINK);
  }
  void add_OPERATOR(::flatbuffers::Offset<::flatbuffers::String> OPERATOR) {
    fbb_.AddOffset(Metadata::VT_OPERATOR, OPERATOR);
  }
  void add_OWNER(::flatbuffers::Offset<::flatbuffers::String> OWNER) {
    fbb_.AddOffset(Metadata::VT_OWNER, OWNER);
  }
  void add_COUNTRY(::flatbuffers::Offset<::flatbuffers::String> COUNTRY) {
    fbb_.AddOffset(Metadata::VT_COUNTRY, COUNTRY);
  }
  void add_CONSTELLATION(::flatbuffers::Offset<::flatbuffers::String> CONSTELLATION) {
    fbb_.AddOffset(Metadata::VT_CONSTELLATION, CONSTELLATION);
  }
  void add_OBJECT_TYPE(::flatbuffers::Offset<::flatbuffers::String> OBJECT_TYPE) {
    fbb_.AddOffset(Metadata::VT_OBJECT_TYPE, OBJECT_TYPE);
  }
  void add_TIME_SYSTEM(::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM) {
    fbb_.AddOffset(Metadata::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  void add_EPOCH_TZERO(::flatbuffers::Offset<::flatbuffers::String> EPOCH_TZERO) {
    fbb_.AddOffset(Metadata::VT_EPOCH_TZERO, EPOCH_TZERO);
  }
  void add_OPS_STATUS(::flatbuffers::Offset<::flatbuffers::String> OPS_STATUS) {
    fbb_.AddOffset(Metadata::VT_OPS_STATUS, OPS_STATUS);
  }
  void add_ORBIT_CATEGORY(::flatbuffers::Offset<::flatbuffers::String> ORBIT_CATEGORY) {
    fbb_.AddOffset(Metadata::VT_ORBIT_CATEGORY, ORBIT_CATEGORY);
  }
  void add_OCM_DATA_ELEMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OCM_DATA_ELEMENTS) {
    fbb_.AddOffset(Metadata::VT_OCM_DATA_ELEMENTS, OCM_DATA_ELEMENTS);
  }
  void add_SCLK_OFFSET_AT_EPOCH(double SCLK_OFFSET_AT_EPOCH) {
    fbb_.AddElement<double>(Metadata::VT_SCLK_OFFSET_AT_EPOCH, SCLK_OFFSET_AT_EPOCH, 0.0);
  }
  void add_SCLK_SEC_PER_SI_SEC(double SCLK_SEC_PER_SI_SEC) {
    fbb_.AddElement<double>(Metadata::VT_SCLK_SEC_PER_SI_SEC, SCLK_SEC_PER_SI_SEC, 0.0);
  }
  void add_PREVIOUS_MESSAGE_EPOCH(::flatbuffers::Offset<::flatbuffers::String> PREVIOUS_MESSAGE_EPOCH) {
    fbb_.AddOffset(Metadata::VT_PREVIOUS_MESSAGE_EPOCH, PREVIOUS_MESSAGE_EPOCH);
  }
  void add_NEXT_MESSAGE_EPOCH(::flatbuffers::Offset<::flatbuffers::String> NEXT_MESSAGE_EPOCH) {
    fbb_.AddOffset(Metadata::VT_NEXT_MESSAGE_EPOCH, NEXT_MESSAGE_EPOCH);
  }
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(Metadata::VT_START_TIME, START_TIME);
  }
  void add_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> STOP_TIME) {
    fbb_.AddOffset(Metadata::VT_STOP_TIME, STOP_TIME);
  }
  void add_TIME_SPAN(double TIME_SPAN) {
    fbb_.AddElement<double>(Metadata::VT_TIME_SPAN, TIME_SPAN, 0.0);
  }
  void add_TAIMUTC_AT_TZERO(double TAIMUTC_AT_TZERO) {
    fbb_.AddElement<double>(Metadata::VT_TAIMUTC_AT_TZERO, TAIMUTC_AT_TZERO, 0.0);
  }
  void add_NEXT_LEAP_EPOCH(::flatbuffers::Offset<::flatbuffers::String> NEXT_LEAP_EPOCH) {
    fbb_.AddOffset(Metadata::VT_NEXT_LEAP_EPOCH, NEXT_LEAP_EPOCH);
  }
  void add_NEXT_LEAP_TAIMUTC(double NEXT_LEAP_TAIMUTC) {
    fbb_.AddElement<double>(Metadata::VT_NEXT_LEAP_TAIMUTC, NEXT_LEAP_TAIMUTC, 0.0);
  }
  void add_UT1MUTC_AT_TZERO(double UT1MUTC_AT_TZERO) {
    fbb_.AddElement<double>(Metadata::VT_UT1MUTC_AT_TZERO, UT1MUTC_AT_TZERO, 0.0);
  }
  void add_EOP_SOURCE(::flatbuffers::Offset<::flatbuffers::String> EOP_SOURCE) {
    fbb_.AddOffset(Metadata::VT_EOP_SOURCE, EOP_SOURCE);
  }
  void add_INTERP_METHOD_EOP(::flatbuffers::Offset<::flatbuffers::String> INTERP_METHOD_EOP) {
    fbb_.AddOffset(Metadata::VT_INTERP_METHOD_EOP, INTERP_METHOD_EOP);
  }
  void add_CELESTIAL_SOURCE(::flatbuffers::Offset<::flatbuffers::String> CELESTIAL_SOURCE) {
    fbb_.AddOffset(Metadata::VT_CELESTIAL_SOURCE, CELESTIAL_SOURCE);
  }
  explicit MetadataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Metadata> CreateMetadata(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INTERNATIONAL_DESIGNATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CATALOG_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_DESIGNATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_POC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_POSITION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_PHONE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_EMAIL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_ORG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_POC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_POSITION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_PHONE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_EMAIL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TECH_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PREVIOUS_MESSAGE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NEXT_MESSAGE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADM_MSG_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CDM_MSG_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PRM_MSG_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RDM_MSG_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TDM_MSG_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OPERATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OWNER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COUNTRY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONSTELLATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH_TZERO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OPS_STATUS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORBIT_CATEGORY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OCM_DATA_ELEMENTS = 0,
    double SCLK_OFFSET_AT_EPOCH = 0.0,
    double SCLK_SEC_PER_SI_SEC = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> PREVIOUS_MESSAGE_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NEXT_MESSAGE_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STOP_TIME = 0,
    double TIME_SPAN = 0.0,
    double TAIMUTC_AT_TZERO = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> NEXT_LEAP_EPOCH = 0,
    double NEXT_LEAP_TAIMUTC = 0.0,
    double UT1MUTC_AT_TZERO = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> EOP_SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INTERP_METHOD_EOP = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CELESTIAL_SOURCE = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_UT1MUTC_AT_TZERO(UT1MUTC_AT_TZERO);
  builder_.add_NEXT_LEAP_TAIMUTC(NEXT_LEAP_TAIMUTC);
  builder_.add_TAIMUTC_AT_TZERO(TAIMUTC_AT_TZERO);
  builder_.add_TIME_SPAN(TIME_SPAN);
  builder_.add_SCLK_SEC_PER_SI_SEC(SCLK_SEC_PER_SI_SEC);
  builder_.add_SCLK_OFFSET_AT_EPOCH(SCLK_OFFSET_AT_EPOCH);
  builder_.add_CELESTIAL_SOURCE(CELESTIAL_SOURCE);
  builder_.add_INTERP_METHOD_EOP(INTERP_METHOD_EOP);
  builder_.add_EOP_SOURCE(EOP_SOURCE);
  builder_.add_NEXT_LEAP_EPOCH(NEXT_LEAP_EPOCH);
  builder_.add_STOP_TIME(STOP_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_NEXT_MESSAGE_EPOCH(NEXT_MESSAGE_EPOCH);
  builder_.add_PREVIOUS_MESSAGE_EPOCH(PREVIOUS_MESSAGE_EPOCH);
  builder_.add_OCM_DATA_ELEMENTS(OCM_DATA_ELEMENTS);
  builder_.add_ORBIT_CATEGORY(ORBIT_CATEGORY);
  builder_.add_OPS_STATUS(OPS_STATUS);
  builder_.add_EPOCH_TZERO(EPOCH_TZERO);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  builder_.add_OBJECT_TYPE(OBJECT_TYPE);
  builder_.add_CONSTELLATION(CONSTELLATION);
  builder_.add_COUNTRY(COUNTRY);
  builder_.add_OWNER(OWNER);
  builder_.add_OPERATOR(OPERATOR);
  builder_.add_TDM_MSG_LINK(TDM_MSG_LINK);
  builder_.add_RDM_MSG_LINK(RDM_MSG_LINK);
  builder_.add_PRM_MSG_LINK(PRM_MSG_LINK);
  builder_.add_CDM_MSG_LINK(CDM_MSG_LINK);
  builder_.add_ADM_MSG_LINK(ADM_MSG_LINK);
  builder_.add_NEXT_MESSAGE_ID(NEXT_MESSAGE_ID);
  builder_.add_PREVIOUS_MESSAGE_ID(PREVIOUS_MESSAGE_ID);
  builder_.add_TECH_ADDRESS(TECH_ADDRESS);
  builder_.add_TECH_EMAIL(TECH_EMAIL);
  builder_.add_TECH_PHONE(TECH_PHONE);
  builder_.add_TECH_POSITION(TECH_POSITION);
  builder_.add_TECH_POC(TECH_POC);
  builder_.add_TECH_ORG(TECH_ORG);
  builder_.add_ORIGINATOR_ADDRESS(ORIGINATOR_ADDRESS);
  builder_.add_ORIGINATOR_EMAIL(ORIGINATOR_EMAIL);
  builder_.add_ORIGINATOR_PHONE(ORIGINATOR_PHONE);
  builder_.add_ORIGINATOR_POSITION(ORIGINATOR_POSITION);
  builder_.add_ORIGINATOR_POC(ORIGINATOR_POC);
  builder_.add_ALTERNATE_NAMES(ALTERNATE_NAMES);
  builder_.add_OBJECT_DESIGNATOR(OBJECT_DESIGNATOR);
  builder_.add_CATALOG_NAME(CATALOG_NAME);
  builder_.add_INTERNATIONAL_DESIGNATOR(INTERNATIONAL_DESIGNATOR);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  builder_.add_COMMENT(COMMENT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Metadata> CreateMetadataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT = nullptr,
    const char *OBJECT_NAME = nullptr,
    const char *INTERNATIONAL_DESIGNATOR = nullptr,
    const char *CATALOG_NAME = nullptr,
    const char *OBJECT_DESIGNATOR = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES = nullptr,
    const char *ORIGINATOR_POC = nullptr,
    const char *ORIGINATOR_POSITION = nullptr,
    const char *ORIGINATOR_PHONE = nullptr,
    const char *ORIGINATOR_EMAIL = nullptr,
    const char *ORIGINATOR_ADDRESS = nullptr,
    const char *TECH_ORG = nullptr,
    const char *TECH_POC = nullptr,
    const char *TECH_POSITION = nullptr,
    const char *TECH_PHONE = nullptr,
    const char *TECH_EMAIL = nullptr,
    const char *TECH_ADDRESS = nullptr,
    const char *PREVIOUS_MESSAGE_ID = nullptr,
    const char *NEXT_MESSAGE_ID = nullptr,
    const char *ADM_MSG_LINK = nullptr,
    const char *CDM_MSG_LINK = nullptr,
    const char *PRM_MSG_LINK = nullptr,
    const char *RDM_MSG_LINK = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *TDM_MSG_LINK = nullptr,
    const char *OPERATOR = nullptr,
    const char *OWNER = nullptr,
    const char *COUNTRY = nullptr,
    const char *CONSTELLATION = nullptr,
    const char *OBJECT_TYPE = nullptr,
    const char *TIME_SYSTEM = nullptr,
    const char *EPOCH_TZERO = nullptr,
    const char *OPS_STATUS = nullptr,
    const char *ORBIT_CATEGORY = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *OCM_DATA_ELEMENTS = nullptr,
    double SCLK_OFFSET_AT_EPOCH = 0.0,
    double SCLK_SEC_PER_SI_SEC = 0.0,
    const char *PREVIOUS_MESSAGE_EPOCH = nullptr,
    const char *NEXT_MESSAGE_EPOCH = nullptr,
    const char *START_TIME = nullptr,
    const char *STOP_TIME = nullptr,
    double TIME_SPAN = 0.0,
    double TAIMUTC_AT_TZERO = 0.0,
    const char *NEXT_LEAP_EPOCH = nullptr,
    double NEXT_LEAP_TAIMUTC = 0.0,
    double UT1MUTC_AT_TZERO = 0.0,
    const char *EOP_SOURCE = nullptr,
    const char *INTERP_METHOD_EOP = nullptr,
    const char *CELESTIAL_SOURCE = nullptr) {
  auto COMMENT__ = COMMENT ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMMENT) : 0;
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto INTERNATIONAL_DESIGNATOR__ = INTERNATIONAL_DESIGNATOR ? _fbb.CreateString(INTERNATIONAL_DESIGNATOR) : 0;
  auto CATALOG_NAME__ = CATALOG_NAME ? _fbb.CreateString(CATALOG_NAME) : 0;
  auto OBJECT_DESIGNATOR__ = OBJECT_DESIGNATOR ? _fbb.CreateString(OBJECT_DESIGNATOR) : 0;
  auto ALTERNATE_NAMES__ = ALTERNATE_NAMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ALTERNATE_NAMES) : 0;
  auto ORIGINATOR_POC__ = ORIGINATOR_POC ? _fbb.CreateString(ORIGINATOR_POC) : 0;
  auto ORIGINATOR_POSITION__ = ORIGINATOR_POSITION ? _fbb.CreateString(ORIGINATOR_POSITION) : 0;
  auto ORIGINATOR_PHONE__ = ORIGINATOR_PHONE ? _fbb.CreateString(ORIGINATOR_PHONE) : 0;
  auto ORIGINATOR_EMAIL__ = ORIGINATOR_EMAIL ? _fbb.CreateString(ORIGINATOR_EMAIL) : 0;
  auto ORIGINATOR_ADDRESS__ = ORIGINATOR_ADDRESS ? _fbb.CreateString(ORIGINATOR_ADDRESS) : 0;
  auto TECH_ORG__ = TECH_ORG ? _fbb.CreateString(TECH_ORG) : 0;
  auto TECH_POC__ = TECH_POC ? _fbb.CreateString(TECH_POC) : 0;
  auto TECH_POSITION__ = TECH_POSITION ? _fbb.CreateString(TECH_POSITION) : 0;
  auto TECH_PHONE__ = TECH_PHONE ? _fbb.CreateString(TECH_PHONE) : 0;
  auto TECH_EMAIL__ = TECH_EMAIL ? _fbb.CreateString(TECH_EMAIL) : 0;
  auto TECH_ADDRESS__ = TECH_ADDRESS ? _fbb.CreateString(TECH_ADDRESS) : 0;
  auto PREVIOUS_MESSAGE_ID__ = PREVIOUS_MESSAGE_ID ? _fbb.CreateString(PREVIOUS_MESSAGE_ID) : 0;
  auto NEXT_MESSAGE_ID__ = NEXT_MESSAGE_ID ? _fbb.CreateString(NEXT_MESSAGE_ID) : 0;
  auto ADM_MSG_LINK__ = ADM_MSG_LINK ? _fbb.CreateString(ADM_MSG_LINK) : 0;
  auto CDM_MSG_LINK__ = CDM_MSG_LINK ? _fbb.CreateString(CDM_MSG_LINK) : 0;
  auto PRM_MSG_LINK__ = PRM_MSG_LINK ? _fbb.CreateString(PRM_MSG_LINK) : 0;
  auto RDM_MSG_LINK__ = RDM_MSG_LINK ? _fbb.CreateString(RDM_MSG_LINK) : 0;
  auto TDM_MSG_LINK__ = TDM_MSG_LINK ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*TDM_MSG_LINK) : 0;
  auto OPERATOR__ = OPERATOR ? _fbb.CreateString(OPERATOR) : 0;
  auto OWNER__ = OWNER ? _fbb.CreateString(OWNER) : 0;
  auto COUNTRY__ = COUNTRY ? _fbb.CreateString(COUNTRY) : 0;
  auto CONSTELLATION__ = CONSTELLATION ? _fbb.CreateString(CONSTELLATION) : 0;
  auto OBJECT_TYPE__ = OBJECT_TYPE ? _fbb.CreateString(OBJECT_TYPE) : 0;
  auto TIME_SYSTEM__ = TIME_SYSTEM ? _fbb.CreateString(TIME_SYSTEM) : 0;
  auto EPOCH_TZERO__ = EPOCH_TZERO ? _fbb.CreateString(EPOCH_TZERO) : 0;
  auto OPS_STATUS__ = OPS_STATUS ? _fbb.CreateString(OPS_STATUS) : 0;
  auto ORBIT_CATEGORY__ = ORBIT_CATEGORY ? _fbb.CreateString(ORBIT_CATEGORY) : 0;
  auto OCM_DATA_ELEMENTS__ = OCM_DATA_ELEMENTS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*OCM_DATA_ELEMENTS) : 0;
  auto PREVIOUS_MESSAGE_EPOCH__ = PREVIOUS_MESSAGE_EPOCH ? _fbb.CreateString(PREVIOUS_MESSAGE_EPOCH) : 0;
  auto NEXT_MESSAGE_EPOCH__ = NEXT_MESSAGE_EPOCH ? _fbb.CreateString(NEXT_MESSAGE_EPOCH) : 0;
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto STOP_TIME__ = STOP_TIME ? _fbb.CreateString(STOP_TIME) : 0;
  auto NEXT_LEAP_EPOCH__ = NEXT_LEAP_EPOCH ? _fbb.CreateString(NEXT_LEAP_EPOCH) : 0;
  auto EOP_SOURCE__ = EOP_SOURCE ? _fbb.CreateString(EOP_SOURCE) : 0;
  auto INTERP_METHOD_EOP__ = INTERP_METHOD_EOP ? _fbb.CreateString(INTERP_METHOD_EOP) : 0;
  auto CELESTIAL_SOURCE__ = CELESTIAL_SOURCE ? _fbb.CreateString(CELESTIAL_SOURCE) : 0;
  return CreateMetadata(
      _fbb,
      COMMENT__,
      OBJECT_NAME__,
      INTERNATIONAL_DESIGNATOR__,
      CATALOG_NAME__,
      OBJECT_DESIGNATOR__,
      ALTERNATE_NAMES__,
      ORIGINATOR_POC__,
      ORIGINATOR_POSITION__,
      ORIGINATOR_PHONE__,
      ORIGINATOR_EMAIL__,
      ORIGINATOR_ADDRESS__,
      TECH_ORG__,
      TECH_POC__,
      TECH_POSITION__,
      TECH_PHONE__,
      TECH_EMAIL__,
      TECH_ADDRESS__,
      PREVIOUS_MESSAGE_ID__,
      NEXT_MESSAGE_ID__,
      ADM_MSG_LINK__,
      CDM_MSG_LINK__,
      PRM_MSG_LINK__,
      RDM_MSG_LINK__,
      TDM_MSG_LINK__,
      OPERATOR__,
      OWNER__,
      COUNTRY__,
      CONSTELLATION__,
      OBJECT_TYPE__,
      TIME_SYSTEM__,
      EPOCH_TZERO__,
      OPS_STATUS__,
      ORBIT_CATEGORY__,
      OCM_DATA_ELEMENTS__,
      SCLK_OFFSET_AT_EPOCH,
      SCLK_SEC_PER_SI_SEC,
      PREVIOUS_MESSAGE_EPOCH__,
      NEXT_MESSAGE_EPOCH__,
      START_TIME__,
      STOP_TIME__,
      TIME_SPAN,
      TAIMUTC_AT_TZERO,
      NEXT_LEAP_EPOCH__,
      NEXT_LEAP_TAIMUTC,
      UT1MUTC_AT_TZERO,
      EOP_SOURCE__,
      INTERP_METHOD_EOP__,
      CELESTIAL_SOURCE__);
}

struct StateVector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateVectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_DOT = 12,
    VT_Y_DOT = 14,
    VT_Z_DOT = 16,
    VT_X_DDOT = 18,
    VT_Y_DDOT = 20,
    VT_Z_DDOT = 22
  };
  /// Epoch of the state vector.
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// X component of position in the specified reference frame.
  double X() const {
    return GetField<double>(VT_X, 0.0);
  }
  /// Y component of position.
  double Y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  /// Z component of position.
  double Z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  /// X component of velocity.
  double X_DOT() const {
    return GetField<double>(VT_X_DOT, 0.0);
  }
  /// Y component of velocity.
  double Y_DOT() const {
    return GetField<double>(VT_Y_DOT, 0.0);
  }
  /// Z component of velocity.
  double Z_DOT() const {
    return GetField<double>(VT_Z_DOT, 0.0);
  }
  /// X component of acceleration.
  double X_DDOT() const {
    return GetField<double>(VT_X_DDOT, 0.0);
  }
  /// Y component of acceleration.
  double Y_DDOT() const {
    return GetField<double>(VT_Y_DDOT, 0.0);
  }
  /// Z component of acceleration.
  double Z_DDOT() const {
    return GetField<double>(VT_Z_DDOT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_X_DOT, 8) &&
           VerifyField<double>(verifier, VT_Y_DOT, 8) &&
           VerifyField<double>(verifier, VT_Z_DOT, 8) &&
           VerifyField<double>(verifier, VT_X_DDOT, 8) &&
           VerifyField<double>(verifier, VT_Y_DDOT, 8) &&
           VerifyField<double>(verifier, VT_Z_DDOT, 8) &&
           verifier.EndTable();
  }
};

struct StateVectorBuilder {
  typedef StateVector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(StateVector::VT_EPOCH, EPOCH);
  }
  void add_X(double X) {
    fbb_.AddElement<double>(StateVector::VT_X, X, 0.0);
  }
  void add_Y(double Y) {
    fbb_.AddElement<double>(StateVector::VT_Y, Y, 0.0);
  }
  void add_Z(double Z) {
    fbb_.AddElement<double>(StateVector::VT_Z, Z, 0.0);
  }
  void add_X_DOT(double X_DOT) {
    fbb_.AddElement<double>(StateVector::VT_X_DOT, X_DOT, 0.0);
  }
  void add_Y_DOT(double Y_DOT) {
    fbb_.AddElement<double>(StateVector::VT_Y_DOT, Y_DOT, 0.0);
  }
  void add_Z_DOT(double Z_DOT) {
    fbb_.AddElement<double>(StateVector::VT_Z_DOT, Z_DOT, 0.0);
  }
  void add_X_DDOT(double X_DDOT) {
    fbb_.AddElement<double>(StateVector::VT_X_DDOT, X_DDOT, 0.0);
  }
  void add_Y_DDOT(double Y_DDOT) {
    fbb_.AddElement<double>(StateVector::VT_Y_DDOT, Y_DDOT, 0.0);
  }
  void add_Z_DDOT(double Z_DDOT) {
    fbb_.AddElement<double>(StateVector::VT_Z_DDOT, Z_DDOT, 0.0);
  }
  explicit StateVectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateVector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateVector> CreateStateVector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double X_DOT = 0.0,
    double Y_DOT = 0.0,
    double Z_DOT = 0.0,
    double X_DDOT = 0.0,
    double Y_DDOT = 0.0,
    double Z_DDOT = 0.0) {
  StateVectorBuilder builder_(_fbb);
  builder_.add_Z_DDOT(Z_DDOT);
  builder_.add_Y_DDOT(Y_DDOT);
  builder_.add_X_DDOT(X_DDOT);
  builder_.add_Z_DOT(Z_DOT);
  builder_.add_Y_DOT(Y_DOT);
  builder_.add_X_DOT(X_DOT);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_EPOCH(EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StateVector> CreateStateVectorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *EPOCH = nullptr,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double X_DOT = 0.0,
    double Y_DOT = 0.0,
    double Z_DOT = 0.0,
    double X_DDOT = 0.0,
    double Y_DDOT = 0.0,
    double Z_DDOT = 0.0) {
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  return CreateStateVector(
      _fbb,
      EPOCH__,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT);
}

struct PhysicalProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhysicalPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMENT = 4,
    VT_WET_MASS = 6,
    VT_DRY_MASS = 8,
    VT_MASS_UNITS = 10,
    VT_OEB_Q1 = 12,
    VT_OEB_Q2 = 14,
    VT_OEB_Q3 = 16,
    VT_OEB_QC = 18,
    VT_OEB_MAX = 20,
    VT_OEB_INT = 22,
    VT_OEB_MIN = 24,
    VT_AREA_ALONG_OEB_MAX = 26,
    VT_AREA_ALONG_OEB_INT = 28,
    VT_AREA_ALONG_OEB_MIN = 30,
    VT_AREA_UNITS = 32,
    VT_DRAG_CONST_AREA = 34,
    VT_DRAG_COEFF_NOM = 36,
    VT_DRAG_UNCERTAINTY = 38,
    VT_SRP_CONST_AREA = 40,
    VT_SOLAR_RAD_COEFF = 42,
    VT_SRP_UNCERTAINTY = 44
  };
  /// Comments in the Physical Properties section.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMENT);
  }
  /// Wet mass of the space object.
  double WET_MASS() const {
    return GetField<double>(VT_WET_MASS, 0.0);
  }
  /// Dry mass of the space object.
  double DRY_MASS() const {
    return GetField<double>(VT_DRY_MASS, 0.0);
  }
  /// Units for mass values.
  const ::flatbuffers::String *MASS_UNITS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MASS_UNITS);
  }
  /// Quaternion component q1 of orientation from OEB to EME2000.
  double OEB_Q1() const {
    return GetField<double>(VT_OEB_Q1, 0.0);
  }
  /// Quaternion component q2.
  double OEB_Q2() const {
    return GetField<double>(VT_OEB_Q2, 0.0);
  }
  /// Quaternion component q3.
  double OEB_Q3() const {
    return GetField<double>(VT_OEB_Q3, 0.0);
  }
  /// Quaternion scalar component qc.
  double OEB_QC() const {
    return GetField<double>(VT_OEB_QC, 0.0);
  }
  /// Maximum dimension of the object along OEB frame axes.
  double OEB_MAX() const {
    return GetField<double>(VT_OEB_MAX, 0.0);
  }
  /// Intermediate dimension along OEB frame axes.
  double OEB_INT() const {
    return GetField<double>(VT_OEB_INT, 0.0);
  }
  /// Minimum dimension of the object along OEB frame axes.
  double OEB_MIN() const {
    return GetField<double>(VT_OEB_MIN, 0.0);
  }
  /// Area along OEB_MAX axis.
  double AREA_ALONG_OEB_MAX() const {
    return GetField<double>(VT_AREA_ALONG_OEB_MAX, 0.0);
  }
  /// Area along OEB_INT axis.
  double AREA_ALONG_OEB_INT() const {
    return GetField<double>(VT_AREA_ALONG_OEB_INT, 0.0);
  }
  /// Area along OEB_MIN axis.
  double AREA_ALONG_OEB_MIN() const {
    return GetField<double>(VT_AREA_ALONG_OEB_MIN, 0.0);
  }
  /// Units for area values.
  const ::flatbuffers::String *AREA_UNITS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AREA_UNITS);
  }
  /// Constant area for drag computations.
  double DRAG_CONST_AREA() const {
    return GetField<double>(VT_DRAG_CONST_AREA, 0.0);
  }
  /// Nominal drag coefficient.
  double DRAG_COEFF_NOM() const {
    return GetField<double>(VT_DRAG_COEFF_NOM, 0.0);
  }
  /// Uncertainty in the drag coefficient.
  double DRAG_UNCERTAINTY() const {
    return GetField<double>(VT_DRAG_UNCERTAINTY, 0.0);
  }
  /// Constant area for solar radiation pressure computations.
  double SRP_CONST_AREA() const {
    return GetField<double>(VT_SRP_CONST_AREA, 0.0);
  }
  /// Nominal solar radiation pressure coefficient.
  double SOLAR_RAD_COEFF() const {
    return GetField<double>(VT_SOLAR_RAD_COEFF, 0.0);
  }
  /// Uncertainty in the solar radiation pressure coefficient.
  double SRP_UNCERTAINTY() const {
    return GetField<double>(VT_SRP_UNCERTAINTY, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyVector(COMMENT()) &&
           verifier.VerifyVectorOfStrings(COMMENT()) &&
           VerifyField<double>(verifier, VT_WET_MASS, 8) &&
           VerifyField<double>(verifier, VT_DRY_MASS, 8) &&
           VerifyOffset(verifier, VT_MASS_UNITS) &&
           verifier.VerifyString(MASS_UNITS()) &&
           VerifyField<double>(verifier, VT_OEB_Q1, 8) &&
           VerifyField<double>(verifier, VT_OEB_Q2, 8) &&
           VerifyField<double>(verifier, VT_OEB_Q3, 8) &&
           VerifyField<double>(verifier, VT_OEB_QC, 8) &&
           VerifyField<double>(verifier, VT_OEB_MAX, 8) &&
           VerifyField<double>(verifier, VT_OEB_INT, 8) &&
           VerifyField<double>(verifier, VT_OEB_MIN, 8) &&
           VerifyField<double>(verifier, VT_AREA_ALONG_OEB_MAX, 8) &&
           VerifyField<double>(verifier, VT_AREA_ALONG_OEB_INT, 8) &&
           VerifyField<double>(verifier, VT_AREA_ALONG_OEB_MIN, 8) &&
           VerifyOffset(verifier, VT_AREA_UNITS) &&
           verifier.VerifyString(AREA_UNITS()) &&
           VerifyField<double>(verifier, VT_DRAG_CONST_AREA, 8) &&
           VerifyField<double>(verifier, VT_DRAG_COEFF_NOM, 8) &&
           VerifyField<double>(verifier, VT_DRAG_UNCERTAINTY, 8) &&
           VerifyField<double>(verifier, VT_SRP_CONST_AREA, 8) &&
           VerifyField<double>(verifier, VT_SOLAR_RAD_COEFF, 8) &&
           VerifyField<double>(verifier, VT_SRP_UNCERTAINTY, 8) &&
           verifier.EndTable();
  }
};

struct PhysicalPropertiesBuilder {
  typedef PhysicalProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT) {
    fbb_.AddOffset(PhysicalProperties::VT_COMMENT, COMMENT);
  }
  void add_WET_MASS(double WET_MASS) {
    fbb_.AddElement<double>(PhysicalProperties::VT_WET_MASS, WET_MASS, 0.0);
  }
  void add_DRY_MASS(double DRY_MASS) {
    fbb_.AddElement<double>(PhysicalProperties::VT_DRY_MASS, DRY_MASS, 0.0);
  }
  void add_MASS_UNITS(::flatbuffers::Offset<::flatbuffers::String> MASS_UNITS) {
    fbb_.AddOffset(PhysicalProperties::VT_MASS_UNITS, MASS_UNITS);
  }
  void add_OEB_Q1(double OEB_Q1) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_Q1, OEB_Q1, 0.0);
  }
  void add_OEB_Q2(double OEB_Q2) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_Q2, OEB_Q2, 0.0);
  }
  void add_OEB_Q3(double OEB_Q3) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_Q3, OEB_Q3, 0.0);
  }
  void add_OEB_QC(double OEB_QC) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_QC, OEB_QC, 0.0);
  }
  void add_OEB_MAX(double OEB_MAX) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_MAX, OEB_MAX, 0.0);
  }
  void add_OEB_INT(double OEB_INT) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_INT, OEB_INT, 0.0);
  }
  void add_OEB_MIN(double OEB_MIN) {
    fbb_.AddElement<double>(PhysicalProperties::VT_OEB_MIN, OEB_MIN, 0.0);
  }
  void add_AREA_ALONG_OEB_MAX(double AREA_ALONG_OEB_MAX) {
    fbb_.AddElement<double>(PhysicalProperties::VT_AREA_ALONG_OEB_MAX, AREA_ALONG_OEB_MAX, 0.0);
  }
  void add_AREA_ALONG_OEB_INT(double AREA_ALONG_OEB_INT) {
    fbb_.AddElement<double>(PhysicalProperties::VT_AREA_ALONG_OEB_INT, AREA_ALONG_OEB_INT, 0.0);
  }
  void add_AREA_ALONG_OEB_MIN(double AREA_ALONG_OEB_MIN) {
    fbb_.AddElement<double>(PhysicalProperties::VT_AREA_ALONG_OEB_MIN, AREA_ALONG_OEB_MIN, 0.0);
  }
  void add_AREA_UNITS(::flatbuffers::Offset<::flatbuffers::String> AREA_UNITS) {
    fbb_.AddOffset(PhysicalProperties::VT_AREA_UNITS, AREA_UNITS);
  }
  void add_DRAG_CONST_AREA(double DRAG_CONST_AREA) {
    fbb_.AddElement<double>(PhysicalProperties::VT_DRAG_CONST_AREA, DRAG_CONST_AREA, 0.0);
  }
  void add_DRAG_COEFF_NOM(double DRAG_COEFF_NOM) {
    fbb_.AddElement<double>(PhysicalProperties::VT_DRAG_COEFF_NOM, DRAG_COEFF_NOM, 0.0);
  }
  void add_DRAG_UNCERTAINTY(double DRAG_UNCERTAINTY) {
    fbb_.AddElement<double>(PhysicalProperties::VT_DRAG_UNCERTAINTY, DRAG_UNCERTAINTY, 0.0);
  }
  void add_SRP_CONST_AREA(double SRP_CONST_AREA) {
    fbb_.AddElement<double>(PhysicalProperties::VT_SRP_CONST_AREA, SRP_CONST_AREA, 0.0);
  }
  void add_SOLAR_RAD_COEFF(double SOLAR_RAD_COEFF) {
    fbb_.AddElement<double>(PhysicalProperties::VT_SOLAR_RAD_COEFF, SOLAR_RAD_COEFF, 0.0);
  }
  void add_SRP_UNCERTAINTY(double SRP_UNCERTAINTY) {
    fbb_.AddElement<double>(PhysicalProperties::VT_SRP_UNCERTAINTY, SRP_UNCERTAINTY, 0.0);
  }
  explicit PhysicalPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhysicalProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhysicalProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhysicalProperties> CreatePhysicalProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT = 0,
    double WET_MASS = 0.0,
    double DRY_MASS = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> MASS_UNITS = 0,
    double OEB_Q1 = 0.0,
    double OEB_Q2 = 0.0,
    double OEB_Q3 = 0.0,
    double OEB_QC = 0.0,
    double OEB_MAX = 0.0,
    double OEB_INT = 0.0,
    double OEB_MIN = 0.0,
    double AREA_ALONG_OEB_MAX = 0.0,
    double AREA_ALONG_OEB_INT = 0.0,
    double AREA_ALONG_OEB_MIN = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> AREA_UNITS = 0,
    double DRAG_CONST_AREA = 0.0,
    double DRAG_COEFF_NOM = 0.0,
    double DRAG_UNCERTAINTY = 0.0,
    double SRP_CONST_AREA = 0.0,
    double SOLAR_RAD_COEFF = 0.0,
    double SRP_UNCERTAINTY = 0.0) {
  PhysicalPropertiesBuilder builder_(_fbb);
  builder_.add_SRP_UNCERTAINTY(SRP_UNCERTAINTY);
  builder_.add_SOLAR_RAD_COEFF(SOLAR_RAD_COEFF);
  builder_.add_SRP_CONST_AREA(SRP_CONST_AREA);
  builder_.add_DRAG_UNCERTAINTY(DRAG_UNCERTAINTY);
  builder_.add_DRAG_COEFF_NOM(DRAG_COEFF_NOM);
  builder_.add_DRAG_CONST_AREA(DRAG_CONST_AREA);
  builder_.add_AREA_ALONG_OEB_MIN(AREA_ALONG_OEB_MIN);
  builder_.add_AREA_ALONG_OEB_INT(AREA_ALONG_OEB_INT);
  builder_.add_AREA_ALONG_OEB_MAX(AREA_ALONG_OEB_MAX);
  builder_.add_OEB_MIN(OEB_MIN);
  builder_.add_OEB_INT(OEB_INT);
  builder_.add_OEB_MAX(OEB_MAX);
  builder_.add_OEB_QC(OEB_QC);
  builder_.add_OEB_Q3(OEB_Q3);
  builder_.add_OEB_Q2(OEB_Q2);
  builder_.add_OEB_Q1(OEB_Q1);
  builder_.add_DRY_MASS(DRY_MASS);
  builder_.add_WET_MASS(WET_MASS);
  builder_.add_AREA_UNITS(AREA_UNITS);
  builder_.add_MASS_UNITS(MASS_UNITS);
  builder_.add_COMMENT(COMMENT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhysicalProperties> CreatePhysicalPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT = nullptr,
    double WET_MASS = 0.0,
    double DRY_MASS = 0.0,
    const char *MASS_UNITS = nullptr,
    double OEB_Q1 = 0.0,
    double OEB_Q2 = 0.0,
    double OEB_Q3 = 0.0,
    double OEB_QC = 0.0,
    double OEB_MAX = 0.0,
    double OEB_INT = 0.0,
    double OEB_MIN = 0.0,
    double AREA_ALONG_OEB_MAX = 0.0,
    double AREA_ALONG_OEB_INT = 0.0,
    double AREA_ALONG_OEB_MIN = 0.0,
    const char *AREA_UNITS = nullptr,
    double DRAG_CONST_AREA = 0.0,
    double DRAG_COEFF_NOM = 0.0,
    double DRAG_UNCERTAINTY = 0.0,
    double SRP_CONST_AREA = 0.0,
    double SOLAR_RAD_COEFF = 0.0,
    double SRP_UNCERTAINTY = 0.0) {
  auto COMMENT__ = COMMENT ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMMENT) : 0;
  auto MASS_UNITS__ = MASS_UNITS ? _fbb.CreateString(MASS_UNITS) : 0;
  auto AREA_UNITS__ = AREA_UNITS ? _fbb.CreateString(AREA_UNITS) : 0;
  return CreatePhysicalProperties(
      _fbb,
      COMMENT__,
      WET_MASS,
      DRY_MASS,
      MASS_UNITS__,
      OEB_Q1,
      OEB_Q2,
      OEB_Q3,
      OEB_QC,
      OEB_MAX,
      OEB_INT,
      OEB_MIN,
      AREA_ALONG_OEB_MAX,
      AREA_ALONG_OEB_INT,
      AREA_ALONG_OEB_MIN,
      AREA_UNITS__,
      DRAG_CONST_AREA,
      DRAG_COEFF_NOM,
      DRAG_UNCERTAINTY,
      SRP_CONST_AREA,
      SOLAR_RAD_COEFF,
      SRP_UNCERTAINTY);
}

struct Perturbations FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PerturbationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMENT = 4,
    VT_ATMOSPHERIC_MODEL = 6,
    VT_GRAVITY_MODEL = 8,
    VT_GRAVITY_DEGREE = 10,
    VT_GRAVITY_ORDER = 12,
    VT_GM = 14,
    VT_N_BODY_PERTURBATIONS = 16,
    VT_OCEAN_TIDES_MODEL = 18,
    VT_SOLID_TIDES_MODEL = 20,
    VT_ATMOSPHERIC_TIDES_MODEL = 22,
    VT_GEOPOTENTIAL_MODEL = 24,
    VT_SOLAR_RAD_PRESSURE = 26,
    VT_ALBEDO = 28,
    VT_THERMAL = 30,
    VT_RELATIVITY = 32,
    VT_ATMOSPHERIC_DRAG = 34,
    VT_FIXED_GEOMAG_KP = 36,
    VT_FIXED_F10P7 = 38,
    VT_FIXED_F10P7_MEAN = 40
  };
  /// Comments in the Perturbations section.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMENT);
  }
  /// Atmospheric model used.
  const ATM *ATMOSPHERIC_MODEL() const {
    return GetPointer<const ATM *>(VT_ATMOSPHERIC_MODEL);
  }
  /// Gravity model used.
  const ::flatbuffers::String *GRAVITY_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GRAVITY_MODEL);
  }
  /// Degree of the gravity model.
  int32_t GRAVITY_DEGREE() const {
    return GetField<int32_t>(VT_GRAVITY_DEGREE, 0);
  }
  /// Order of the gravity model.
  int32_t GRAVITY_ORDER() const {
    return GetField<int32_t>(VT_GRAVITY_ORDER, 0);
  }
  /// Gravitational constant times the mass of the central body.
  double GM() const {
    return GetField<double>(VT_GM, 0.0);
  }
  /// List of celestial bodies included in n-body perturbations.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *N_BODY_PERTURBATIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_N_BODY_PERTURBATIONS);
  }
  /// Ocean tides model used.
  const ::flatbuffers::String *OCEAN_TIDES_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OCEAN_TIDES_MODEL);
  }
  /// Solid tides model used.
  const ::flatbuffers::String *SOLID_TIDES_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOLID_TIDES_MODEL);
  }
  /// Atmospheric tides model used.
  const ::flatbuffers::String *ATMOSPHERIC_TIDES_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATMOSPHERIC_TIDES_MODEL);
  }
  /// Geopotential model used.
  const ::flatbuffers::String *GEOPOTENTIAL_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOPOTENTIAL_MODEL);
  }
  /// Solar radiation pressure model used.
  const ::flatbuffers::String *SOLAR_RAD_PRESSURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOLAR_RAD_PRESSURE);
  }
  /// Albedo model used.
  const ::flatbuffers::String *ALBEDO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALBEDO);
  }
  /// Thermal model used.
  const ::flatbuffers::String *THERMAL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THERMAL);
  }
  /// Relativity model used.
  const ::flatbuffers::String *RELATIVITY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RELATIVITY);
  }
  /// Atmospheric drag model used.
  const ::flatbuffers::String *ATMOSPHERIC_DRAG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATMOSPHERIC_DRAG);
  }
  /// Fixed geomagnetic Kp index used.
  double FIXED_GEOMAG_KP() const {
    return GetField<double>(VT_FIXED_GEOMAG_KP, 0.0);
  }
  /// Fixed F10.7 solar flux value used.
  double FIXED_F10P7() const {
    return GetField<double>(VT_FIXED_F10P7, 0.0);
  }
  /// Fixed mean F10.7 solar flux value used.
  double FIXED_F10P7_MEAN() const {
    return GetField<double>(VT_FIXED_F10P7_MEAN, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyVector(COMMENT()) &&
           verifier.VerifyVectorOfStrings(COMMENT()) &&
           VerifyOffset(verifier, VT_ATMOSPHERIC_MODEL) &&
           verifier.VerifyTable(ATMOSPHERIC_MODEL()) &&
           VerifyOffset(verifier, VT_GRAVITY_MODEL) &&
           verifier.VerifyString(GRAVITY_MODEL()) &&
           VerifyField<int32_t>(verifier, VT_GRAVITY_DEGREE, 4) &&
           VerifyField<int32_t>(verifier, VT_GRAVITY_ORDER, 4) &&
           VerifyField<double>(verifier, VT_GM, 8) &&
           VerifyOffset(verifier, VT_N_BODY_PERTURBATIONS) &&
           verifier.VerifyVector(N_BODY_PERTURBATIONS()) &&
           verifier.VerifyVectorOfStrings(N_BODY_PERTURBATIONS()) &&
           VerifyOffset(verifier, VT_OCEAN_TIDES_MODEL) &&
           verifier.VerifyString(OCEAN_TIDES_MODEL()) &&
           VerifyOffset(verifier, VT_SOLID_TIDES_MODEL) &&
           verifier.VerifyString(SOLID_TIDES_MODEL()) &&
           VerifyOffset(verifier, VT_ATMOSPHERIC_TIDES_MODEL) &&
           verifier.VerifyString(ATMOSPHERIC_TIDES_MODEL()) &&
           VerifyOffset(verifier, VT_GEOPOTENTIAL_MODEL) &&
           verifier.VerifyString(GEOPOTENTIAL_MODEL()) &&
           VerifyOffset(verifier, VT_SOLAR_RAD_PRESSURE) &&
           verifier.VerifyString(SOLAR_RAD_PRESSURE()) &&
           VerifyOffset(verifier, VT_ALBEDO) &&
           verifier.VerifyString(ALBEDO()) &&
           VerifyOffset(verifier, VT_THERMAL) &&
           verifier.VerifyString(THERMAL()) &&
           VerifyOffset(verifier, VT_RELATIVITY) &&
           verifier.VerifyString(RELATIVITY()) &&
           VerifyOffset(verifier, VT_ATMOSPHERIC_DRAG) &&
           verifier.VerifyString(ATMOSPHERIC_DRAG()) &&
           VerifyField<double>(verifier, VT_FIXED_GEOMAG_KP, 8) &&
           VerifyField<double>(verifier, VT_FIXED_F10P7, 8) &&
           VerifyField<double>(verifier, VT_FIXED_F10P7_MEAN, 8) &&
           verifier.EndTable();
  }
};

struct PerturbationsBuilder {
  typedef Perturbations Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT) {
    fbb_.AddOffset(Perturbations::VT_COMMENT, COMMENT);
  }
  void add_ATMOSPHERIC_MODEL(::flatbuffers::Offset<ATM> ATMOSPHERIC_MODEL) {
    fbb_.AddOffset(Perturbations::VT_ATMOSPHERIC_MODEL, ATMOSPHERIC_MODEL);
  }
  void add_GRAVITY_MODEL(::flatbuffers::Offset<::flatbuffers::String> GRAVITY_MODEL) {
    fbb_.AddOffset(Perturbations::VT_GRAVITY_MODEL, GRAVITY_MODEL);
  }
  void add_GRAVITY_DEGREE(int32_t GRAVITY_DEGREE) {
    fbb_.AddElement<int32_t>(Perturbations::VT_GRAVITY_DEGREE, GRAVITY_DEGREE, 0);
  }
  void add_GRAVITY_ORDER(int32_t GRAVITY_ORDER) {
    fbb_.AddElement<int32_t>(Perturbations::VT_GRAVITY_ORDER, GRAVITY_ORDER, 0);
  }
  void add_GM(double GM) {
    fbb_.AddElement<double>(Perturbations::VT_GM, GM, 0.0);
  }
  void add_N_BODY_PERTURBATIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> N_BODY_PERTURBATIONS) {
    fbb_.AddOffset(Perturbations::VT_N_BODY_PERTURBATIONS, N_BODY_PERTURBATIONS);
  }
  void add_OCEAN_TIDES_MODEL(::flatbuffers::Offset<::flatbuffers::String> OCEAN_TIDES_MODEL) {
    fbb_.AddOffset(Perturbations::VT_OCEAN_TIDES_MODEL, OCEAN_TIDES_MODEL);
  }
  void add_SOLID_TIDES_MODEL(::flatbuffers::Offset<::flatbuffers::String> SOLID_TIDES_MODEL) {
    fbb_.AddOffset(Perturbations::VT_SOLID_TIDES_MODEL, SOLID_TIDES_MODEL);
  }
  void add_ATMOSPHERIC_TIDES_MODEL(::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERIC_TIDES_MODEL) {
    fbb_.AddOffset(Perturbations::VT_ATMOSPHERIC_TIDES_MODEL, ATMOSPHERIC_TIDES_MODEL);
  }
  void add_GEOPOTENTIAL_MODEL(::flatbuffers::Offset<::flatbuffers::String> GEOPOTENTIAL_MODEL) {
    fbb_.AddOffset(Perturbations::VT_GEOPOTENTIAL_MODEL, GEOPOTENTIAL_MODEL);
  }
  void add_SOLAR_RAD_PRESSURE(::flatbuffers::Offset<::flatbuffers::String> SOLAR_RAD_PRESSURE) {
    fbb_.AddOffset(Perturbations::VT_SOLAR_RAD_PRESSURE, SOLAR_RAD_PRESSURE);
  }
  void add_ALBEDO(::flatbuffers::Offset<::flatbuffers::String> ALBEDO) {
    fbb_.AddOffset(Perturbations::VT_ALBEDO, ALBEDO);
  }
  void add_THERMAL(::flatbuffers::Offset<::flatbuffers::String> THERMAL) {
    fbb_.AddOffset(Perturbations::VT_THERMAL, THERMAL);
  }
  void add_RELATIVITY(::flatbuffers::Offset<::flatbuffers::String> RELATIVITY) {
    fbb_.AddOffset(Perturbations::VT_RELATIVITY, RELATIVITY);
  }
  void add_ATMOSPHERIC_DRAG(::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERIC_DRAG) {
    fbb_.AddOffset(Perturbations::VT_ATMOSPHERIC_DRAG, ATMOSPHERIC_DRAG);
  }
  void add_FIXED_GEOMAG_KP(double FIXED_GEOMAG_KP) {
    fbb_.AddElement<double>(Perturbations::VT_FIXED_GEOMAG_KP, FIXED_GEOMAG_KP, 0.0);
  }
  void add_FIXED_F10P7(double FIXED_F10P7) {
    fbb_.AddElement<double>(Perturbations::VT_FIXED_F10P7, FIXED_F10P7, 0.0);
  }
  void add_FIXED_F10P7_MEAN(double FIXED_F10P7_MEAN) {
    fbb_.AddElement<double>(Perturbations::VT_FIXED_F10P7_MEAN, FIXED_F10P7_MEAN, 0.0);
  }
  explicit PerturbationsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Perturbations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Perturbations>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Perturbations> CreatePerturbations(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMENT = 0,
    ::flatbuffers::Offset<ATM> ATMOSPHERIC_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GRAVITY_MODEL = 0,
    int32_t GRAVITY_DEGREE = 0,
    int32_t GRAVITY_ORDER = 0,
    double GM = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> N_BODY_PERTURBATIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OCEAN_TIDES_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOLID_TIDES_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERIC_TIDES_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GEOPOTENTIAL_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOLAR_RAD_PRESSURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALBEDO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> THERMAL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RELATIVITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERIC_DRAG = 0,
    double FIXED_GEOMAG_KP = 0.0,
    double FIXED_F10P7 = 0.0,
    double FIXED_F10P7_MEAN = 0.0) {
  PerturbationsBuilder builder_(_fbb);
  builder_.add_FIXED_F10P7_MEAN(FIXED_F10P7_MEAN);
  builder_.add_FIXED_F10P7(FIXED_F10P7);
  builder_.add_FIXED_GEOMAG_KP(FIXED_GEOMAG_KP);
  builder_.add_GM(GM);
  builder_.add_ATMOSPHERIC_DRAG(ATMOSPHERIC_DRAG);
  builder_.add_RELATIVITY(RELATIVITY);
  builder_.add_THERMAL(THERMAL);
  builder_.add_ALBEDO(ALBEDO);
  builder_.add_SOLAR_RAD_PRESSURE(SOLAR_RAD_PRESSURE);
  builder_.add_GEOPOTENTIAL_MODEL(GEOPOTENTIAL_MODEL);
  builder_.add_ATMOSPHERIC_TIDES_MODEL(ATMOSPHERIC_TIDES_MODEL);
  builder_.add_SOLID_TIDES_MODEL(SOLID_TIDES_MODEL);
  builder_.add_OCEAN_TIDES_MODEL(OCEAN_TIDES_MODEL);
  builder_.add_N_BODY_PERTURBATIONS(N_BODY_PERTURBATIONS);
  builder_.add_GRAVITY_ORDER(GRAVITY_ORDER);
  builder_.add_GRAVITY_DEGREE(GRAVITY_DEGREE);
  builder_.add_GRAVITY_MODEL(GRAVITY_MODEL);
  builder_.add_ATMOSPHERIC_MODEL(ATMOSPHERIC_MODEL);
  builder_.add_COMMENT(COMMENT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Perturbations> CreatePerturbationsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMENT = nullptr,
    ::flatbuffers::Offset<ATM> ATMOSPHERIC_MODEL = 0,
    const char *GRAVITY_MODEL = nullptr,
    int32_t GRAVITY_DEGREE = 0,
    int32_t GRAVITY_ORDER = 0,
    double GM = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *N_BODY_PERTURBATIONS = nullptr,
    const char *OCEAN_TIDES_MODEL = nullptr,
    const char *SOLID_TIDES_MODEL = nullptr,
    const char *ATMOSPHERIC_TIDES_MODEL = nullptr,
    const char *GEOPOTENTIAL_MODEL = nullptr,
    const char *SOLAR_RAD_PRESSURE = nullptr,
    const char *ALBEDO = nullptr,
    const char *THERMAL = nullptr,
    const char *RELATIVITY = nullptr,
    const char *ATMOSPHERIC_DRAG = nullptr,
    double FIXED_GEOMAG_KP = 0.0,
    double FIXED_F10P7 = 0.0,
    double FIXED_F10P7_MEAN = 0.0) {
  auto COMMENT__ = COMMENT ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMMENT) : 0;
  auto GRAVITY_MODEL__ = GRAVITY_MODEL ? _fbb.CreateString(GRAVITY_MODEL) : 0;
  auto N_BODY_PERTURBATIONS__ = N_BODY_PERTURBATIONS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*N_BODY_PERTURBATIONS) : 0;
  auto OCEAN_TIDES_MODEL__ = OCEAN_TIDES_MODEL ? _fbb.CreateString(OCEAN_TIDES_MODEL) : 0;
  auto SOLID_TIDES_MODEL__ = SOLID_TIDES_MODEL ? _fbb.CreateString(SOLID_TIDES_MODEL) : 0;
  auto ATMOSPHERIC_TIDES_MODEL__ = ATMOSPHERIC_TIDES_MODEL ? _fbb.CreateString(ATMOSPHERIC_TIDES_MODEL) : 0;
  auto GEOPOTENTIAL_MODEL__ = GEOPOTENTIAL_MODEL ? _fbb.CreateString(GEOPOTENTIAL_MODEL) : 0;
  auto SOLAR_RAD_PRESSURE__ = SOLAR_RAD_PRESSURE ? _fbb.CreateString(SOLAR_RAD_PRESSURE) : 0;
  auto ALBEDO__ = ALBEDO ? _fbb.CreateString(ALBEDO) : 0;
  auto THERMAL__ = THERMAL ? _fbb.CreateString(THERMAL) : 0;
  auto RELATIVITY__ = RELATIVITY ? _fbb.CreateString(RELATIVITY) : 0;
  auto ATMOSPHERIC_DRAG__ = ATMOSPHERIC_DRAG ? _fbb.CreateString(ATMOSPHERIC_DRAG) : 0;
  return CreatePerturbations(
      _fbb,
      COMMENT__,
      ATMOSPHERIC_MODEL,
      GRAVITY_MODEL__,
      GRAVITY_DEGREE,
      GRAVITY_ORDER,
      GM,
      N_BODY_PERTURBATIONS__,
      OCEAN_TIDES_MODEL__,
      SOLID_TIDES_MODEL__,
      ATMOSPHERIC_TIDES_MODEL__,
      GEOPOTENTIAL_MODEL__,
      SOLAR_RAD_PRESSURE__,
      ALBEDO__,
      THERMAL__,
      RELATIVITY__,
      ATMOSPHERIC_DRAG__,
      FIXED_GEOMAG_KP,
      FIXED_F10P7,
      FIXED_F10P7_MEAN);
}

struct Maneuver FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ManeuverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAN_ID = 4,
    VT_MAN_BASIS = 6,
    VT_MAN_DEVICE_ID = 8,
    VT_MAN_PREV_ID = 10,
    VT_MAN_PURPOSE = 12,
    VT_MAN_REF_FRAME = 14,
    VT_MAN_FRAME_EPOCH = 16,
    VT_MAN_TYPE = 18,
    VT_MAN_EPOCH_START = 20,
    VT_MAN_DURATION = 22,
    VT_MAN_UNITS = 24,
    VT_DATA = 26,
    VT_MAN_COMMENT = 28
  };
  /// Unique identifier for the maneuver.
  const ::flatbuffers::String *MAN_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_ID);
  }
  /// Basis of the maneuver plan (e.g., planned, predicted, estimated).
  const ::flatbuffers::String *MAN_BASIS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_BASIS);
  }
  /// Identifier of the maneuver device.
  const ::flatbuffers::String *MAN_DEVICE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_DEVICE_ID);
  }
  /// Identifier of the previous maneuver.
  const ::flatbuffers::String *MAN_PREV_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_PREV_ID);
  }
  /// Purpose of the maneuver.
  const ::flatbuffers::String *MAN_PURPOSE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_PURPOSE);
  }
  /// Reference frame for the maneuver data.
  const ::flatbuffers::String *MAN_REF_FRAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_REF_FRAME);
  }
  /// Epoch of the maneuver reference frame.
  const ::flatbuffers::String *MAN_FRAME_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_FRAME_EPOCH);
  }
  /// Type of maneuver (e.g., IMPULSIVE, FINITE).
  const ::flatbuffers::String *MAN_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_TYPE);
  }
  /// Start epoch of the maneuver.
  const ::flatbuffers::String *MAN_EPOCH_START() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAN_EPOCH_START);
  }
  /// Duration of the maneuver.
  double MAN_DURATION() const {
    return GetField<double>(VT_MAN_DURATION, 0.0);
  }
  /// Units for the maneuver data values.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MAN_UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MAN_UNITS);
  }
  /// Data associated with the maneuver.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATA);
  }
  /// Comments related to the maneuver.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MAN_COMMENT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MAN_COMMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAN_ID) &&
           verifier.VerifyString(MAN_ID()) &&
           VerifyOffset(verifier, VT_MAN_BASIS) &&
           verifier.VerifyString(MAN_BASIS()) &&
           VerifyOffset(verifier, VT_MAN_DEVICE_ID) &&
           verifier.VerifyString(MAN_DEVICE_ID()) &&
           VerifyOffset(verifier, VT_MAN_PREV_ID) &&
           verifier.VerifyString(MAN_PREV_ID()) &&
           VerifyOffset(verifier, VT_MAN_PURPOSE) &&
           verifier.VerifyString(MAN_PURPOSE()) &&
           VerifyOffset(verifier, VT_MAN_REF_FRAME) &&
           verifier.VerifyString(MAN_REF_FRAME()) &&
           VerifyOffset(verifier, VT_MAN_FRAME_EPOCH) &&
           verifier.VerifyString(MAN_FRAME_EPOCH()) &&
           VerifyOffset(verifier, VT_MAN_TYPE) &&
           verifier.VerifyString(MAN_TYPE()) &&
           VerifyOffset(verifier, VT_MAN_EPOCH_START) &&
           verifier.VerifyString(MAN_EPOCH_START()) &&
           VerifyField<double>(verifier, VT_MAN_DURATION, 8) &&
           VerifyOffset(verifier, VT_MAN_UNITS) &&
           verifier.VerifyVector(MAN_UNITS()) &&
           verifier.VerifyVectorOfStrings(MAN_UNITS()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           verifier.VerifyVectorOfStrings(DATA()) &&
           VerifyOffset(verifier, VT_MAN_COMMENT) &&
           verifier.VerifyVector(MAN_COMMENT()) &&
           verifier.VerifyVectorOfStrings(MAN_COMMENT()) &&
           verifier.EndTable();
  }
};

struct ManeuverBuilder {
  typedef Maneuver Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MAN_ID(::flatbuffers::Offset<::flatbuffers::String> MAN_ID) {
    fbb_.AddOffset(Maneuver::VT_MAN_ID, MAN_ID);
  }
  void add_MAN_BASIS(::flatbuffers::Offset<::flatbuffers::String> MAN_BASIS) {
    fbb_.AddOffset(Maneuver::VT_MAN_BASIS, MAN_BASIS);
  }
  void add_MAN_DEVICE_ID(::flatbuffers::Offset<::flatbuffers::String> MAN_DEVICE_ID) {
    fbb_.AddOffset(Maneuver::VT_MAN_DEVICE_ID, MAN_DEVICE_ID);
  }
  void add_MAN_PREV_ID(::flatbuffers::Offset<::flatbuffers::String> MAN_PREV_ID) {
    fbb_.AddOffset(Maneuver::VT_MAN_PREV_ID, MAN_PREV_ID);
  }
  void add_MAN_PURPOSE(::flatbuffers::Offset<::flatbuffers::String> MAN_PURPOSE) {
    fbb_.AddOffset(Maneuver::VT_MAN_PURPOSE, MAN_PURPOSE);
  }
  void add_MAN_REF_FRAME(::flatbuffers::Offset<::flatbuffers::String> MAN_REF_FRAME) {
    fbb_.AddOffset(Maneuver::VT_MAN_REF_FRAME, MAN_REF_FRAME);
  }
  void add_MAN_FRAME_EPOCH(::flatbuffers::Offset<::flatbuffers::String> MAN_FRAME_EPOCH) {
    fbb_.AddOffset(Maneuver::VT_MAN_FRAME_EPOCH, MAN_FRAME_EPOCH);
  }
  void add_MAN_TYPE(::flatbuffers::Offset<::flatbuffers::String> MAN_TYPE) {
    fbb_.AddOffset(Maneuver::VT_MAN_TYPE, MAN_TYPE);
  }
  void add_MAN_EPOCH_START(::flatbuffers::Offset<::flatbuffers::String> MAN_EPOCH_START) {
    fbb_.AddOffset(Maneuver::VT_MAN_EPOCH_START, MAN_EPOCH_START);
  }
  void add_MAN_DURATION(double MAN_DURATION) {
    fbb_.AddElement<double>(Maneuver::VT_MAN_DURATION, MAN_DURATION, 0.0);
  }
  void add_MAN_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MAN_UNITS) {
    fbb_.AddOffset(Maneuver::VT_MAN_UNITS, MAN_UNITS);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> DATA) {
    fbb_.AddOffset(Maneuver::VT_DATA, DATA);
  }
  void add_MAN_COMMENT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MAN_COMMENT) {
    fbb_.AddOffset(Maneuver::VT_MAN_COMMENT, MAN_COMMENT);
  }
  explicit ManeuverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Maneuver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Maneuver>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Maneuver> CreateManeuver(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_BASIS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_DEVICE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_PREV_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_PURPOSE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_REF_FRAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_FRAME_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAN_EPOCH_START = 0,
    double MAN_DURATION = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MAN_UNITS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> DATA = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MAN_COMMENT = 0) {
  ManeuverBuilder builder_(_fbb);
  builder_.add_MAN_DURATION(MAN_DURATION);
  builder_.add_MAN_COMMENT(MAN_COMMENT);
  builder_.add_DATA(DATA);
  builder_.add_MAN_UNITS(MAN_UNITS);
  builder_.add_MAN_EPOCH_START(MAN_EPOCH_START);
  builder_.add_MAN_TYPE(MAN_TYPE);
  builder_.add_MAN_FRAME_EPOCH(MAN_FRAME_EPOCH);
  builder_.add_MAN_REF_FRAME(MAN_REF_FRAME);
  builder_.add_MAN_PURPOSE(MAN_PURPOSE);
  builder_.add_MAN_PREV_ID(MAN_PREV_ID);
  builder_.add_MAN_DEVICE_ID(MAN_DEVICE_ID);
  builder_.add_MAN_BASIS(MAN_BASIS);
  builder_.add_MAN_ID(MAN_ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Maneuver> CreateManeuverDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *MAN_ID = nullptr,
    const char *MAN_BASIS = nullptr,
    const char *MAN_DEVICE_ID = nullptr,
    const char *MAN_PREV_ID = nullptr,
    const char *MAN_PURPOSE = nullptr,
    const char *MAN_REF_FRAME = nullptr,
    const char *MAN_FRAME_EPOCH = nullptr,
    const char *MAN_TYPE = nullptr,
    const char *MAN_EPOCH_START = nullptr,
    double MAN_DURATION = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MAN_UNITS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *DATA = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MAN_COMMENT = nullptr) {
  auto MAN_ID__ = MAN_ID ? _fbb.CreateString(MAN_ID) : 0;
  auto MAN_BASIS__ = MAN_BASIS ? _fbb.CreateString(MAN_BASIS) : 0;
  auto MAN_DEVICE_ID__ = MAN_DEVICE_ID ? _fbb.CreateString(MAN_DEVICE_ID) : 0;
  auto MAN_PREV_ID__ = MAN_PREV_ID ? _fbb.CreateString(MAN_PREV_ID) : 0;
  auto MAN_PURPOSE__ = MAN_PURPOSE ? _fbb.CreateString(MAN_PURPOSE) : 0;
  auto MAN_REF_FRAME__ = MAN_REF_FRAME ? _fbb.CreateString(MAN_REF_FRAME) : 0;
  auto MAN_FRAME_EPOCH__ = MAN_FRAME_EPOCH ? _fbb.CreateString(MAN_FRAME_EPOCH) : 0;
  auto MAN_TYPE__ = MAN_TYPE ? _fbb.CreateString(MAN_TYPE) : 0;
  auto MAN_EPOCH_START__ = MAN_EPOCH_START ? _fbb.CreateString(MAN_EPOCH_START) : 0;
  auto MAN_UNITS__ = MAN_UNITS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MAN_UNITS) : 0;
  auto DATA__ = DATA ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*DATA) : 0;
  auto MAN_COMMENT__ = MAN_COMMENT ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MAN_COMMENT) : 0;
  return CreateManeuver(
      _fbb,
      MAN_ID__,
      MAN_BASIS__,
      MAN_DEVICE_ID__,
      MAN_PREV_ID__,
      MAN_PURPOSE__,
      MAN_REF_FRAME__,
      MAN_FRAME_EPOCH__,
      MAN_TYPE__,
      MAN_EPOCH_START__,
      MAN_DURATION,
      MAN_UNITS__,
      DATA__,
      MAN_COMMENT__);
}

struct OrbitDetermination FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrbitDeterminationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OD_ID = 4,
    VT_OD_PREV_ID = 6,
    VT_OD_ALGORITHM = 8,
    VT_OD_METHOD = 10,
    VT_OD_EPOCH = 12,
    VT_OD_TIME_TAG = 14,
    VT_OD_PROCESS_NOISE = 16,
    VT_OD_COV_REDUCTION = 18,
    VT_OD_NOISE_MODELS = 20,
    VT_OD_OBSERVATIONS_TYPE = 22,
    VT_OD_OBSERVATIONS_USED = 24,
    VT_OD_TRACKS_USED = 26,
    VT_OD_DATA_WEIGHTING = 28,
    VT_OD_CONVERGENCE_CRITERIA = 30,
    VT_OD_EST_PARAMETERS = 32,
    VT_OD_APRIORI_DATA = 34,
    VT_OD_RESIDUALS = 36
  };
  /// Unique identifier for the orbit determination.
  const ::flatbuffers::String *OD_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_ID);
  }
  /// Identifier of the previous orbit determination.
  const ::flatbuffers::String *OD_PREV_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_PREV_ID);
  }
  /// Algorithm used for orbit determination.
  const ::flatbuffers::String *OD_ALGORITHM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_ALGORITHM);
  }
  /// Method used for orbit determination.
  const ::flatbuffers::String *OD_METHOD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_METHOD);
  }
  /// Epoch of the orbit determination.
  const ::flatbuffers::String *OD_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_EPOCH);
  }
  /// Time tag of the orbit determination.
  const ::flatbuffers::String *OD_TIME_TAG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_TIME_TAG);
  }
  /// Process noise model used.
  const ::flatbuffers::String *OD_PROCESS_NOISE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_PROCESS_NOISE);
  }
  /// Covariance reduction techniques used.
  const ::flatbuffers::String *OD_COV_REDUCTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_COV_REDUCTION);
  }
  /// Noise models used.
  const ::flatbuffers::String *OD_NOISE_MODELS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_NOISE_MODELS);
  }
  /// Types of observations used (e.g., RANGE, DOPPLER).
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *OD_OBSERVATIONS_TYPE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OD_OBSERVATIONS_TYPE);
  }
  /// Number of observations used.
  int32_t OD_OBSERVATIONS_USED() const {
    return GetField<int32_t>(VT_OD_OBSERVATIONS_USED, 0);
  }
  /// Number of tracks used.
  int32_t OD_TRACKS_USED() const {
    return GetField<int32_t>(VT_OD_TRACKS_USED, 0);
  }
  /// Data weighting scheme used.
  const ::flatbuffers::String *OD_DATA_WEIGHTING() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_DATA_WEIGHTING);
  }
  /// Convergence criteria used.
  const ::flatbuffers::String *OD_CONVERGENCE_CRITERIA() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_CONVERGENCE_CRITERIA);
  }
  /// Parameters estimated during orbit determination.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *OD_EST_PARAMETERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OD_EST_PARAMETERS);
  }
  /// A priori data used for orbit determination.
  const ::flatbuffers::String *OD_APRIORI_DATA() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_APRIORI_DATA);
  }
  /// Residuals from the orbit determination.
  const ::flatbuffers::String *OD_RESIDUALS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_RESIDUALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OD_ID) &&
           verifier.VerifyString(OD_ID()) &&
           VerifyOffset(verifier, VT_OD_PREV_ID) &&
           verifier.VerifyString(OD_PREV_ID()) &&
           VerifyOffset(verifier, VT_OD_ALGORITHM) &&
           verifier.VerifyString(OD_ALGORITHM()) &&
           VerifyOffset(verifier, VT_OD_METHOD) &&
           verifier.VerifyString(OD_METHOD()) &&
           VerifyOffset(verifier, VT_OD_EPOCH) &&
           verifier.VerifyString(OD_EPOCH()) &&
           VerifyOffset(verifier, VT_OD_TIME_TAG) &&
           verifier.VerifyString(OD_TIME_TAG()) &&
           VerifyOffset(verifier, VT_OD_PROCESS_NOISE) &&
           verifier.VerifyString(OD_PROCESS_NOISE()) &&
           VerifyOffset(verifier, VT_OD_COV_REDUCTION) &&
           verifier.VerifyString(OD_COV_REDUCTION()) &&
           VerifyOffset(verifier, VT_OD_NOISE_MODELS) &&
           verifier.VerifyString(OD_NOISE_MODELS()) &&
           VerifyOffset(verifier, VT_OD_OBSERVATIONS_TYPE) &&
           verifier.VerifyVector(OD_OBSERVATIONS_TYPE()) &&
           verifier.VerifyVectorOfStrings(OD_OBSERVATIONS_TYPE()) &&
           VerifyField<int32_t>(verifier, VT_OD_OBSERVATIONS_USED, 4) &&
           VerifyField<int32_t>(verifier, VT_OD_TRACKS_USED, 4) &&
           VerifyOffset(verifier, VT_OD_DATA_WEIGHTING) &&
           verifier.VerifyString(OD_DATA_WEIGHTING()) &&
           VerifyOffset(verifier, VT_OD_CONVERGENCE_CRITERIA) &&
           verifier.VerifyString(OD_CONVERGENCE_CRITERIA()) &&
           VerifyOffset(verifier, VT_OD_EST_PARAMETERS) &&
           verifier.VerifyVector(OD_EST_PARAMETERS()) &&
           verifier.VerifyVectorOfStrings(OD_EST_PARAMETERS()) &&
           VerifyOffset(verifier, VT_OD_APRIORI_DATA) &&
           verifier.VerifyString(OD_APRIORI_DATA()) &&
           VerifyOffset(verifier, VT_OD_RESIDUALS) &&
           verifier.VerifyString(OD_RESIDUALS()) &&
           verifier.EndTable();
  }
};

struct OrbitDeterminationBuilder {
  typedef OrbitDetermination Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OD_ID(::flatbuffers::Offset<::flatbuffers::String> OD_ID) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_ID, OD_ID);
  }
  void add_OD_PREV_ID(::flatbuffers::Offset<::flatbuffers::String> OD_PREV_ID) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_PREV_ID, OD_PREV_ID);
  }
  void add_OD_ALGORITHM(::flatbuffers::Offset<::flatbuffers::String> OD_ALGORITHM) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_ALGORITHM, OD_ALGORITHM);
  }
  void add_OD_METHOD(::flatbuffers::Offset<::flatbuffers::String> OD_METHOD) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_METHOD, OD_METHOD);
  }
  void add_OD_EPOCH(::flatbuffers::Offset<::flatbuffers::String> OD_EPOCH) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_EPOCH, OD_EPOCH);
  }
  void add_OD_TIME_TAG(::flatbuffers::Offset<::flatbuffers::String> OD_TIME_TAG) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_TIME_TAG, OD_TIME_TAG);
  }
  void add_OD_PROCESS_NOISE(::flatbuffers::Offset<::flatbuffers::String> OD_PROCESS_NOISE) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_PROCESS_NOISE, OD_PROCESS_NOISE);
  }
  void add_OD_COV_REDUCTION(::flatbuffers::Offset<::flatbuffers::String> OD_COV_REDUCTION) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_COV_REDUCTION, OD_COV_REDUCTION);
  }
  void add_OD_NOISE_MODELS(::flatbuffers::Offset<::flatbuffers::String> OD_NOISE_MODELS) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_NOISE_MODELS, OD_NOISE_MODELS);
  }
  void add_OD_OBSERVATIONS_TYPE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OD_OBSERVATIONS_TYPE) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_OBSERVATIONS_TYPE, OD_OBSERVATIONS_TYPE);
  }
  void add_OD_OBSERVATIONS_USED(int32_t OD_OBSERVATIONS_USED) {
    fbb_.AddElement<int32_t>(OrbitDetermination::VT_OD_OBSERVATIONS_USED, OD_OBSERVATIONS_USED, 0);
  }
  void add_OD_TRACKS_USED(int32_t OD_TRACKS_USED) {
    fbb_.AddElement<int32_t>(OrbitDetermination::VT_OD_TRACKS_USED, OD_TRACKS_USED, 0);
  }
  void add_OD_DATA_WEIGHTING(::flatbuffers::Offset<::flatbuffers::String> OD_DATA_WEIGHTING) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_DATA_WEIGHTING, OD_DATA_WEIGHTING);
  }
  void add_OD_CONVERGENCE_CRITERIA(::flatbuffers::Offset<::flatbuffers::String> OD_CONVERGENCE_CRITERIA) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_CONVERGENCE_CRITERIA, OD_CONVERGENCE_CRITERIA);
  }
  void add_OD_EST_PARAMETERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OD_EST_PARAMETERS) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_EST_PARAMETERS, OD_EST_PARAMETERS);
  }
  void add_OD_APRIORI_DATA(::flatbuffers::Offset<::flatbuffers::String> OD_APRIORI_DATA) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_APRIORI_DATA, OD_APRIORI_DATA);
  }
  void add_OD_RESIDUALS(::flatbuffers::Offset<::flatbuffers::String> OD_RESIDUALS) {
    fbb_.AddOffset(OrbitDetermination::VT_OD_RESIDUALS, OD_RESIDUALS);
  }
  explicit OrbitDeterminationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrbitDetermination> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrbitDetermination>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrbitDetermination> CreateOrbitDetermination(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> OD_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_PREV_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_ALGORITHM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_METHOD = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_TIME_TAG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_PROCESS_NOISE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_COV_REDUCTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_NOISE_MODELS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OD_OBSERVATIONS_TYPE = 0,
    int32_t OD_OBSERVATIONS_USED = 0,
    int32_t OD_TRACKS_USED = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_DATA_WEIGHTING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_CONVERGENCE_CRITERIA = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OD_EST_PARAMETERS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_APRIORI_DATA = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_RESIDUALS = 0) {
  OrbitDeterminationBuilder builder_(_fbb);
  builder_.add_OD_RESIDUALS(OD_RESIDUALS);
  builder_.add_OD_APRIORI_DATA(OD_APRIORI_DATA);
  builder_.add_OD_EST_PARAMETERS(OD_EST_PARAMETERS);
  builder_.add_OD_CONVERGENCE_CRITERIA(OD_CONVERGENCE_CRITERIA);
  builder_.add_OD_DATA_WEIGHTING(OD_DATA_WEIGHTING);
  builder_.add_OD_TRACKS_USED(OD_TRACKS_USED);
  builder_.add_OD_OBSERVATIONS_USED(OD_OBSERVATIONS_USED);
  builder_.add_OD_OBSERVATIONS_TYPE(OD_OBSERVATIONS_TYPE);
  builder_.add_OD_NOISE_MODELS(OD_NOISE_MODELS);
  builder_.add_OD_COV_REDUCTION(OD_COV_REDUCTION);
  builder_.add_OD_PROCESS_NOISE(OD_PROCESS_NOISE);
  builder_.add_OD_TIME_TAG(OD_TIME_TAG);
  builder_.add_OD_EPOCH(OD_EPOCH);
  builder_.add_OD_METHOD(OD_METHOD);
  builder_.add_OD_ALGORITHM(OD_ALGORITHM);
  builder_.add_OD_PREV_ID(OD_PREV_ID);
  builder_.add_OD_ID(OD_ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrbitDetermination> CreateOrbitDeterminationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *OD_ID = nullptr,
    const char *OD_PREV_ID = nullptr,
    const char *OD_ALGORITHM = nullptr,
    const char *OD_METHOD = nullptr,
    const char *OD_EPOCH = nullptr,
    const char *OD_TIME_TAG = nullptr,
    const char *OD_PROCESS_NOISE = nullptr,
    const char *OD_COV_REDUCTION = nullptr,
    const char *OD_NOISE_MODELS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *OD_OBSERVATIONS_TYPE = nullptr,
    int32_t OD_OBSERVATIONS_USED = 0,
    int32_t OD_TRACKS_USED = 0,
    const char *OD_DATA_WEIGHTING = nullptr,
    const char *OD_CONVERGENCE_CRITERIA = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *OD_EST_PARAMETERS = nullptr,
    const char *OD_APRIORI_DATA = nullptr,
    const char *OD_RESIDUALS = nullptr) {
  auto OD_ID__ = OD_ID ? _fbb.CreateString(OD_ID) : 0;
  auto OD_PREV_ID__ = OD_PREV_ID ? _fbb.CreateString(OD_PREV_ID) : 0;
  auto OD_ALGORITHM__ = OD_ALGORITHM ? _fbb.CreateString(OD_ALGORITHM) : 0;
  auto OD_METHOD__ = OD_METHOD ? _fbb.CreateString(OD_METHOD) : 0;
  auto OD_EPOCH__ = OD_EPOCH ? _fbb.CreateString(OD_EPOCH) : 0;
  auto OD_TIME_TAG__ = OD_TIME_TAG ? _fbb.CreateString(OD_TIME_TAG) : 0;
  auto OD_PROCESS_NOISE__ = OD_PROCESS_NOISE ? _fbb.CreateString(OD_PROCESS_NOISE) : 0;
  auto OD_COV_REDUCTION__ = OD_COV_REDUCTION ? _fbb.CreateString(OD_COV_REDUCTION) : 0;
  auto OD_NOISE_MODELS__ = OD_NOISE_MODELS ? _fbb.CreateString(OD_NOISE_MODELS) : 0;
  auto OD_OBSERVATIONS_TYPE__ = OD_OBSERVATIONS_TYPE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*OD_OBSERVATIONS_TYPE) : 0;
  auto OD_DATA_WEIGHTING__ = OD_DATA_WEIGHTING ? _fbb.CreateString(OD_DATA_WEIGHTING) : 0;
  auto OD_CONVERGENCE_CRITERIA__ = OD_CONVERGENCE_CRITERIA ? _fbb.CreateString(OD_CONVERGENCE_CRITERIA) : 0;
  auto OD_EST_PARAMETERS__ = OD_EST_PARAMETERS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*OD_EST_PARAMETERS) : 0;
  auto OD_APRIORI_DATA__ = OD_APRIORI_DATA ? _fbb.CreateString(OD_APRIORI_DATA) : 0;
  auto OD_RESIDUALS__ = OD_RESIDUALS ? _fbb.CreateString(OD_RESIDUALS) : 0;
  return CreateOrbitDetermination(
      _fbb,
      OD_ID__,
      OD_PREV_ID__,
      OD_ALGORITHM__,
      OD_METHOD__,
      OD_EPOCH__,
      OD_TIME_TAG__,
      OD_PROCESS_NOISE__,
      OD_COV_REDUCTION__,
      OD_NOISE_MODELS__,
      OD_OBSERVATIONS_TYPE__,
      OD_OBSERVATIONS_USED,
      OD_TRACKS_USED,
      OD_DATA_WEIGHTING__,
      OD_CONVERGENCE_CRITERIA__,
      OD_EST_PARAMETERS__,
      OD_APRIORI_DATA__,
      OD_RESIDUALS__);
}

struct UserDefinedParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserDefinedParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAM_NAME = 4,
    VT_PARAM_VALUE = 6
  };
  /// Name of the user-defined parameter.
  const ::flatbuffers::String *PARAM_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAM_NAME);
  }
  /// Value of the user-defined parameter.
  const ::flatbuffers::String *PARAM_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAM_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAM_NAME) &&
           verifier.VerifyString(PARAM_NAME()) &&
           VerifyOffset(verifier, VT_PARAM_VALUE) &&
           verifier.VerifyString(PARAM_VALUE()) &&
           verifier.EndTable();
  }
};

struct UserDefinedParametersBuilder {
  typedef UserDefinedParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAM_NAME(::flatbuffers::Offset<::flatbuffers::String> PARAM_NAME) {
    fbb_.AddOffset(UserDefinedParameters::VT_PARAM_NAME, PARAM_NAME);
  }
  void add_PARAM_VALUE(::flatbuffers::Offset<::flatbuffers::String> PARAM_VALUE) {
    fbb_.AddOffset(UserDefinedParameters::VT_PARAM_VALUE, PARAM_VALUE);
  }
  explicit UserDefinedParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserDefinedParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserDefinedParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserDefinedParameters> CreateUserDefinedParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAM_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PARAM_VALUE = 0) {
  UserDefinedParametersBuilder builder_(_fbb);
  builder_.add_PARAM_VALUE(PARAM_VALUE);
  builder_.add_PARAM_NAME(PARAM_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserDefinedParameters> CreateUserDefinedParametersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAM_NAME = nullptr,
    const char *PARAM_VALUE = nullptr) {
  auto PARAM_NAME__ = PARAM_NAME ? _fbb.CreateString(PARAM_NAME) : 0;
  auto PARAM_VALUE__ = PARAM_VALUE ? _fbb.CreateString(PARAM_VALUE) : 0;
  return CreateUserDefinedParameters(
      _fbb,
      PARAM_NAME__,
      PARAM_VALUE__);
}

/// Orbit Comprehensive Message
struct OCM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OCMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADER = 4,
    VT_METADATA = 6,
    VT_TRAJ_TYPE = 8,
    VT_STATE_DATA = 10,
    VT_PHYSICAL_PROPERTIES = 12,
    VT_COVARIANCE_DATA = 14,
    VT_MANEUVER_DATA = 16,
    VT_PERTURBATIONS = 18,
    VT_ORBIT_DETERMINATION = 20,
    VT_USER_DEFINED_PARAMETERS = 22
  };
  /// Header section of the OCM.
  const Header *HEADER() const {
    return GetPointer<const Header *>(VT_HEADER);
  }
  /// Metadata section of the OCM.
  const Metadata *METADATA() const {
    return GetPointer<const Metadata *>(VT_METADATA);
  }
  /// Trajectory type (e.g., PROPAGATED, ESTIMATED).
  const ::flatbuffers::String *TRAJ_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRAJ_TYPE);
  }
  /// State vector data.
  const ::flatbuffers::Vector<::flatbuffers::Offset<StateVector>> *STATE_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StateVector>> *>(VT_STATE_DATA);
  }
  /// Physical properties of the space object.
  const PhysicalProperties *PHYSICAL_PROPERTIES() const {
    return GetPointer<const PhysicalProperties *>(VT_PHYSICAL_PROPERTIES);
  }
  /// Covariance data associated with the state vectors.
  const ::flatbuffers::Vector<::flatbuffers::Offset<StateVector>> *COVARIANCE_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StateVector>> *>(VT_COVARIANCE_DATA);
  }
  /// Maneuver data.
  const ::flatbuffers::Vector<::flatbuffers::Offset<Maneuver>> *MANEUVER_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Maneuver>> *>(VT_MANEUVER_DATA);
  }
  /// Perturbations parameters used.
  const Perturbations *PERTURBATIONS() const {
    return GetPointer<const Perturbations *>(VT_PERTURBATIONS);
  }
  /// Orbit determination data.
  const OrbitDetermination *ORBIT_DETERMINATION() const {
    return GetPointer<const OrbitDetermination *>(VT_ORBIT_DETERMINATION);
  }
  /// User-defined parameters and supplemental comments.
  const ::flatbuffers::Vector<::flatbuffers::Offset<UserDefinedParameters>> *USER_DEFINED_PARAMETERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<UserDefinedParameters>> *>(VT_USER_DEFINED_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(HEADER()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(METADATA()) &&
           VerifyOffset(verifier, VT_TRAJ_TYPE) &&
           verifier.VerifyString(TRAJ_TYPE()) &&
           VerifyOffset(verifier, VT_STATE_DATA) &&
           verifier.VerifyVector(STATE_DATA()) &&
           verifier.VerifyVectorOfTables(STATE_DATA()) &&
           VerifyOffset(verifier, VT_PHYSICAL_PROPERTIES) &&
           verifier.VerifyTable(PHYSICAL_PROPERTIES()) &&
           VerifyOffset(verifier, VT_COVARIANCE_DATA) &&
           verifier.VerifyVector(COVARIANCE_DATA()) &&
           verifier.VerifyVectorOfTables(COVARIANCE_DATA()) &&
           VerifyOffset(verifier, VT_MANEUVER_DATA) &&
           verifier.VerifyVector(MANEUVER_DATA()) &&
           verifier.VerifyVectorOfTables(MANEUVER_DATA()) &&
           VerifyOffset(verifier, VT_PERTURBATIONS) &&
           verifier.VerifyTable(PERTURBATIONS()) &&
           VerifyOffset(verifier, VT_ORBIT_DETERMINATION) &&
           verifier.VerifyTable(ORBIT_DETERMINATION()) &&
           VerifyOffset(verifier, VT_USER_DEFINED_PARAMETERS) &&
           verifier.VerifyVector(USER_DEFINED_PARAMETERS()) &&
           verifier.VerifyVectorOfTables(USER_DEFINED_PARAMETERS()) &&
           verifier.EndTable();
  }
};

struct OCMBuilder {
  typedef OCM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_HEADER(::flatbuffers::Offset<Header> HEADER) {
    fbb_.AddOffset(OCM::VT_HEADER, HEADER);
  }
  void add_METADATA(::flatbuffers::Offset<Metadata> METADATA) {
    fbb_.AddOffset(OCM::VT_METADATA, METADATA);
  }
  void add_TRAJ_TYPE(::flatbuffers::Offset<::flatbuffers::String> TRAJ_TYPE) {
    fbb_.AddOffset(OCM::VT_TRAJ_TYPE, TRAJ_TYPE);
  }
  void add_STATE_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StateVector>>> STATE_DATA) {
    fbb_.AddOffset(OCM::VT_STATE_DATA, STATE_DATA);
  }
  void add_PHYSICAL_PROPERTIES(::flatbuffers::Offset<PhysicalProperties> PHYSICAL_PROPERTIES) {
    fbb_.AddOffset(OCM::VT_PHYSICAL_PROPERTIES, PHYSICAL_PROPERTIES);
  }
  void add_COVARIANCE_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StateVector>>> COVARIANCE_DATA) {
    fbb_.AddOffset(OCM::VT_COVARIANCE_DATA, COVARIANCE_DATA);
  }
  void add_MANEUVER_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Maneuver>>> MANEUVER_DATA) {
    fbb_.AddOffset(OCM::VT_MANEUVER_DATA, MANEUVER_DATA);
  }
  void add_PERTURBATIONS(::flatbuffers::Offset<Perturbations> PERTURBATIONS) {
    fbb_.AddOffset(OCM::VT_PERTURBATIONS, PERTURBATIONS);
  }
  void add_ORBIT_DETERMINATION(::flatbuffers::Offset<OrbitDetermination> ORBIT_DETERMINATION) {
    fbb_.AddOffset(OCM::VT_ORBIT_DETERMINATION, ORBIT_DETERMINATION);
  }
  void add_USER_DEFINED_PARAMETERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserDefinedParameters>>> USER_DEFINED_PARAMETERS) {
    fbb_.AddOffset(OCM::VT_USER_DEFINED_PARAMETERS, USER_DEFINED_PARAMETERS);
  }
  explicit OCMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OCM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OCM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OCM> CreateOCM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Header> HEADER = 0,
    ::flatbuffers::Offset<Metadata> METADATA = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRAJ_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StateVector>>> STATE_DATA = 0,
    ::flatbuffers::Offset<PhysicalProperties> PHYSICAL_PROPERTIES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StateVector>>> COVARIANCE_DATA = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Maneuver>>> MANEUVER_DATA = 0,
    ::flatbuffers::Offset<Perturbations> PERTURBATIONS = 0,
    ::flatbuffers::Offset<OrbitDetermination> ORBIT_DETERMINATION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<UserDefinedParameters>>> USER_DEFINED_PARAMETERS = 0) {
  OCMBuilder builder_(_fbb);
  builder_.add_USER_DEFINED_PARAMETERS(USER_DEFINED_PARAMETERS);
  builder_.add_ORBIT_DETERMINATION(ORBIT_DETERMINATION);
  builder_.add_PERTURBATIONS(PERTURBATIONS);
  builder_.add_MANEUVER_DATA(MANEUVER_DATA);
  builder_.add_COVARIANCE_DATA(COVARIANCE_DATA);
  builder_.add_PHYSICAL_PROPERTIES(PHYSICAL_PROPERTIES);
  builder_.add_STATE_DATA(STATE_DATA);
  builder_.add_TRAJ_TYPE(TRAJ_TYPE);
  builder_.add_METADATA(METADATA);
  builder_.add_HEADER(HEADER);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OCM> CreateOCMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Header> HEADER = 0,
    ::flatbuffers::Offset<Metadata> METADATA = 0,
    const char *TRAJ_TYPE = nullptr,
    const std::vector<::flatbuffers::Offset<StateVector>> *STATE_DATA = nullptr,
    ::flatbuffers::Offset<PhysicalProperties> PHYSICAL_PROPERTIES = 0,
    const std::vector<::flatbuffers::Offset<StateVector>> *COVARIANCE_DATA = nullptr,
    const std::vector<::flatbuffers::Offset<Maneuver>> *MANEUVER_DATA = nullptr,
    ::flatbuffers::Offset<Perturbations> PERTURBATIONS = 0,
    ::flatbuffers::Offset<OrbitDetermination> ORBIT_DETERMINATION = 0,
    const std::vector<::flatbuffers::Offset<UserDefinedParameters>> *USER_DEFINED_PARAMETERS = nullptr) {
  auto TRAJ_TYPE__ = TRAJ_TYPE ? _fbb.CreateString(TRAJ_TYPE) : 0;
  auto STATE_DATA__ = STATE_DATA ? _fbb.CreateVector<::flatbuffers::Offset<StateVector>>(*STATE_DATA) : 0;
  auto COVARIANCE_DATA__ = COVARIANCE_DATA ? _fbb.CreateVector<::flatbuffers::Offset<StateVector>>(*COVARIANCE_DATA) : 0;
  auto MANEUVER_DATA__ = MANEUVER_DATA ? _fbb.CreateVector<::flatbuffers::Offset<Maneuver>>(*MANEUVER_DATA) : 0;
  auto USER_DEFINED_PARAMETERS__ = USER_DEFINED_PARAMETERS ? _fbb.CreateVector<::flatbuffers::Offset<UserDefinedParameters>>(*USER_DEFINED_PARAMETERS) : 0;
  return CreateOCM(
      _fbb,
      HEADER,
      METADATA,
      TRAJ_TYPE__,
      STATE_DATA__,
      PHYSICAL_PROPERTIES,
      COVARIANCE_DATA__,
      MANEUVER_DATA__,
      PERTURBATIONS,
      ORBIT_DETERMINATION,
      USER_DEFINED_PARAMETERS__);
}

inline const OCM *GetOCM(const void *buf) {
  return ::flatbuffers::GetRoot<OCM>(buf);
}

inline const OCM *GetSizePrefixedOCM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OCM>(buf);
}

inline const char *OCMIdentifier() {
  return "$OCM";
}

inline bool OCMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OCMIdentifier());
}

inline bool SizePrefixedOCMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OCMIdentifier(), true);
}

inline bool VerifyOCMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OCM>(OCMIdentifier());
}

inline bool VerifySizePrefixedOCMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OCM>(OCMIdentifier());
}

inline void FinishOCMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OCM> root) {
  fbb.Finish(root, OCMIdentifier());
}

inline void FinishSizePrefixedOCMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OCM> root) {
  fbb.FinishSizePrefixed(root, OCMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
