// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct PLK;
struct PLKBuilder;

/// License type for plugin access
enum licenseType : int8_t {
  /// Evaluation/trial license
  licenseType_Trial = 0,
  /// Standard commercial license
  licenseType_Commercial = 1,
  /// Enterprise site license
  licenseType_Enterprise = 2,
  /// Educational/academic license
  licenseType_Educational = 3,
  /// Open source project license
  licenseType_OpenSource = 4,
  /// Internal OrbPro default plugins
  licenseType_Internal = 5,
  licenseType_MIN = licenseType_Trial,
  licenseType_MAX = licenseType_Internal
};

inline const licenseType (&EnumValueslicenseType())[6] {
  static const licenseType values[] = {
    licenseType_Trial,
    licenseType_Commercial,
    licenseType_Enterprise,
    licenseType_Educational,
    licenseType_OpenSource,
    licenseType_Internal
  };
  return values;
}

inline const char * const *EnumNameslicenseType() {
  static const char * const names[7] = {
    "Trial",
    "Commercial",
    "Enterprise",
    "Educational",
    "OpenSource",
    "Internal",
    nullptr
  };
  return names;
}

inline const char *EnumNamelicenseType(licenseType e) {
  if (::flatbuffers::IsOutRange(e, licenseType_Trial, licenseType_Internal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNameslicenseType()[index];
}

/// Plugin License Key - Issued license for plugin access
/// Uses ECIES: both parties derive symmetric key via X25519 ECDH
/// Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
struct PLK FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PLKBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LICENSE_ID = 4,
    VT_PLUGIN_ID = 6,
    VT_PLUGIN_VERSION = 8,
    VT_LICENSEE_ORG = 10,
    VT_LICENSEE_EMAIL = 12,
    VT_LICENSEE_PEER_ID = 14,
    VT_LICENSEE_PUBKEY = 16,
    VT_ISSUER_PUBKEY = 18,
    VT_ALLOWED_DOMAINS = 20,
    VT_ALLOWED_TLDS = 22,
    VT_LICENSE_TYPE = 24,
    VT_MAX_ACTIVATIONS = 26,
    VT_ISSUED_AT = 28,
    VT_VALID_FROM = 30,
    VT_EXPIRES_AT = 32,
    VT_ISSUER_PEER_ID = 34,
    VT_SIGNATURE = 36
  };
  /// Unique license key identifier
  const ::flatbuffers::String *LICENSE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSE_ID);
  }
  /// Plugin ID this license is for
  const ::flatbuffers::String *PLUGIN_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLUGIN_ID);
  }
  /// Plugin version or version range (semver)
  const ::flatbuffers::String *PLUGIN_VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLUGIN_VERSION);
  }
  /// Licensee organization name
  const ::flatbuffers::String *LICENSEE_ORG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSEE_ORG);
  }
  /// Licensee contact email
  const ::flatbuffers::String *LICENSEE_EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSEE_EMAIL);
  }
  /// Licensee's SDN Peer ID
  const ::flatbuffers::String *LICENSEE_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSEE_PEER_ID);
  }
  /// Licensee's X25519 public key (32 bytes)
  const ::flatbuffers::Vector<uint8_t> *LICENSEE_PUBKEY() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_LICENSEE_PUBKEY);
  }
  /// Issuer's X25519 public key (32 bytes)
  /// Used with licensee's private key to derive shared secret via ECDH
  const ::flatbuffers::Vector<uint8_t> *ISSUER_PUBKEY() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ISSUER_PUBKEY);
  }
  /// Domain restrictions (empty = any domain allowed)
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ALLOWED_DOMAINS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALLOWED_DOMAINS);
  }
  /// TLD restrictions (e.g., ".gov", ".mil", ".edu")
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ALLOWED_TLDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALLOWED_TLDS);
  }
  /// Type of license
  licenseType LICENSE_TYPE() const {
    return static_cast<licenseType>(GetField<int8_t>(VT_LICENSE_TYPE, 0));
  }
  /// Maximum concurrent activations (0 = unlimited)
  uint32_t MAX_ACTIVATIONS() const {
    return GetField<uint32_t>(VT_MAX_ACTIVATIONS, 0);
  }
  /// Unix timestamp when license was issued
  uint64_t ISSUED_AT() const {
    return GetField<uint64_t>(VT_ISSUED_AT, 0);
  }
  /// Unix timestamp when license becomes valid
  uint64_t VALID_FROM() const {
    return GetField<uint64_t>(VT_VALID_FROM, 0);
  }
  /// Unix timestamp when license expires (0 = never expires)
  uint64_t EXPIRES_AT() const {
    return GetField<uint64_t>(VT_EXPIRES_AT, 0);
  }
  /// Peer ID of the license issuer (OrbPro)
  const ::flatbuffers::String *ISSUER_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ISSUER_PEER_ID);
  }
  /// Ed25519 signature from issuer over all fields (except SIGNATURE)
  const ::flatbuffers::Vector<uint8_t> *SIGNATURE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LICENSE_ID) &&
           verifier.VerifyString(LICENSE_ID()) &&
           VerifyOffsetRequired(verifier, VT_PLUGIN_ID) &&
           verifier.VerifyString(PLUGIN_ID()) &&
           VerifyOffset(verifier, VT_PLUGIN_VERSION) &&
           verifier.VerifyString(PLUGIN_VERSION()) &&
           VerifyOffsetRequired(verifier, VT_LICENSEE_ORG) &&
           verifier.VerifyString(LICENSEE_ORG()) &&
           VerifyOffset(verifier, VT_LICENSEE_EMAIL) &&
           verifier.VerifyString(LICENSEE_EMAIL()) &&
           VerifyOffset(verifier, VT_LICENSEE_PEER_ID) &&
           verifier.VerifyString(LICENSEE_PEER_ID()) &&
           VerifyOffset(verifier, VT_LICENSEE_PUBKEY) &&
           verifier.VerifyVector(LICENSEE_PUBKEY()) &&
           VerifyOffset(verifier, VT_ISSUER_PUBKEY) &&
           verifier.VerifyVector(ISSUER_PUBKEY()) &&
           VerifyOffset(verifier, VT_ALLOWED_DOMAINS) &&
           verifier.VerifyVector(ALLOWED_DOMAINS()) &&
           verifier.VerifyVectorOfStrings(ALLOWED_DOMAINS()) &&
           VerifyOffset(verifier, VT_ALLOWED_TLDS) &&
           verifier.VerifyVector(ALLOWED_TLDS()) &&
           verifier.VerifyVectorOfStrings(ALLOWED_TLDS()) &&
           VerifyField<int8_t>(verifier, VT_LICENSE_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_MAX_ACTIVATIONS, 4) &&
           VerifyField<uint64_t>(verifier, VT_ISSUED_AT, 8) &&
           VerifyField<uint64_t>(verifier, VT_VALID_FROM, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXPIRES_AT, 8) &&
           VerifyOffset(verifier, VT_ISSUER_PEER_ID) &&
           verifier.VerifyString(ISSUER_PEER_ID()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(SIGNATURE()) &&
           verifier.EndTable();
  }
};

struct PLKBuilder {
  typedef PLK Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LICENSE_ID(::flatbuffers::Offset<::flatbuffers::String> LICENSE_ID) {
    fbb_.AddOffset(PLK::VT_LICENSE_ID, LICENSE_ID);
  }
  void add_PLUGIN_ID(::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID) {
    fbb_.AddOffset(PLK::VT_PLUGIN_ID, PLUGIN_ID);
  }
  void add_PLUGIN_VERSION(::flatbuffers::Offset<::flatbuffers::String> PLUGIN_VERSION) {
    fbb_.AddOffset(PLK::VT_PLUGIN_VERSION, PLUGIN_VERSION);
  }
  void add_LICENSEE_ORG(::flatbuffers::Offset<::flatbuffers::String> LICENSEE_ORG) {
    fbb_.AddOffset(PLK::VT_LICENSEE_ORG, LICENSEE_ORG);
  }
  void add_LICENSEE_EMAIL(::flatbuffers::Offset<::flatbuffers::String> LICENSEE_EMAIL) {
    fbb_.AddOffset(PLK::VT_LICENSEE_EMAIL, LICENSEE_EMAIL);
  }
  void add_LICENSEE_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> LICENSEE_PEER_ID) {
    fbb_.AddOffset(PLK::VT_LICENSEE_PEER_ID, LICENSEE_PEER_ID);
  }
  void add_LICENSEE_PUBKEY(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> LICENSEE_PUBKEY) {
    fbb_.AddOffset(PLK::VT_LICENSEE_PUBKEY, LICENSEE_PUBKEY);
  }
  void add_ISSUER_PUBKEY(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ISSUER_PUBKEY) {
    fbb_.AddOffset(PLK::VT_ISSUER_PUBKEY, ISSUER_PUBKEY);
  }
  void add_ALLOWED_DOMAINS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALLOWED_DOMAINS) {
    fbb_.AddOffset(PLK::VT_ALLOWED_DOMAINS, ALLOWED_DOMAINS);
  }
  void add_ALLOWED_TLDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALLOWED_TLDS) {
    fbb_.AddOffset(PLK::VT_ALLOWED_TLDS, ALLOWED_TLDS);
  }
  void add_LICENSE_TYPE(licenseType LICENSE_TYPE) {
    fbb_.AddElement<int8_t>(PLK::VT_LICENSE_TYPE, static_cast<int8_t>(LICENSE_TYPE), 0);
  }
  void add_MAX_ACTIVATIONS(uint32_t MAX_ACTIVATIONS) {
    fbb_.AddElement<uint32_t>(PLK::VT_MAX_ACTIVATIONS, MAX_ACTIVATIONS, 0);
  }
  void add_ISSUED_AT(uint64_t ISSUED_AT) {
    fbb_.AddElement<uint64_t>(PLK::VT_ISSUED_AT, ISSUED_AT, 0);
  }
  void add_VALID_FROM(uint64_t VALID_FROM) {
    fbb_.AddElement<uint64_t>(PLK::VT_VALID_FROM, VALID_FROM, 0);
  }
  void add_EXPIRES_AT(uint64_t EXPIRES_AT) {
    fbb_.AddElement<uint64_t>(PLK::VT_EXPIRES_AT, EXPIRES_AT, 0);
  }
  void add_ISSUER_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> ISSUER_PEER_ID) {
    fbb_.AddOffset(PLK::VT_ISSUER_PEER_ID, ISSUER_PEER_ID);
  }
  void add_SIGNATURE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE) {
    fbb_.AddOffset(PLK::VT_SIGNATURE, SIGNATURE);
  }
  explicit PLKBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PLK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PLK>(end);
    fbb_.Required(o, PLK::VT_LICENSE_ID);
    fbb_.Required(o, PLK::VT_PLUGIN_ID);
    fbb_.Required(o, PLK::VT_LICENSEE_ORG);
    return o;
  }
};

inline ::flatbuffers::Offset<PLK> CreatePLK(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> LICENSE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PLUGIN_VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LICENSEE_ORG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LICENSEE_EMAIL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LICENSEE_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> LICENSEE_PUBKEY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ISSUER_PUBKEY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALLOWED_DOMAINS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALLOWED_TLDS = 0,
    licenseType LICENSE_TYPE = licenseType_Trial,
    uint32_t MAX_ACTIVATIONS = 0,
    uint64_t ISSUED_AT = 0,
    uint64_t VALID_FROM = 0,
    uint64_t EXPIRES_AT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ISSUER_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE = 0) {
  PLKBuilder builder_(_fbb);
  builder_.add_EXPIRES_AT(EXPIRES_AT);
  builder_.add_VALID_FROM(VALID_FROM);
  builder_.add_ISSUED_AT(ISSUED_AT);
  builder_.add_SIGNATURE(SIGNATURE);
  builder_.add_ISSUER_PEER_ID(ISSUER_PEER_ID);
  builder_.add_MAX_ACTIVATIONS(MAX_ACTIVATIONS);
  builder_.add_ALLOWED_TLDS(ALLOWED_TLDS);
  builder_.add_ALLOWED_DOMAINS(ALLOWED_DOMAINS);
  builder_.add_ISSUER_PUBKEY(ISSUER_PUBKEY);
  builder_.add_LICENSEE_PUBKEY(LICENSEE_PUBKEY);
  builder_.add_LICENSEE_PEER_ID(LICENSEE_PEER_ID);
  builder_.add_LICENSEE_EMAIL(LICENSEE_EMAIL);
  builder_.add_LICENSEE_ORG(LICENSEE_ORG);
  builder_.add_PLUGIN_VERSION(PLUGIN_VERSION);
  builder_.add_PLUGIN_ID(PLUGIN_ID);
  builder_.add_LICENSE_ID(LICENSE_ID);
  builder_.add_LICENSE_TYPE(LICENSE_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PLK> CreatePLKDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *LICENSE_ID = nullptr,
    const char *PLUGIN_ID = nullptr,
    const char *PLUGIN_VERSION = nullptr,
    const char *LICENSEE_ORG = nullptr,
    const char *LICENSEE_EMAIL = nullptr,
    const char *LICENSEE_PEER_ID = nullptr,
    const std::vector<uint8_t> *LICENSEE_PUBKEY = nullptr,
    const std::vector<uint8_t> *ISSUER_PUBKEY = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ALLOWED_DOMAINS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ALLOWED_TLDS = nullptr,
    licenseType LICENSE_TYPE = licenseType_Trial,
    uint32_t MAX_ACTIVATIONS = 0,
    uint64_t ISSUED_AT = 0,
    uint64_t VALID_FROM = 0,
    uint64_t EXPIRES_AT = 0,
    const char *ISSUER_PEER_ID = nullptr,
    const std::vector<uint8_t> *SIGNATURE = nullptr) {
  auto LICENSE_ID__ = LICENSE_ID ? _fbb.CreateString(LICENSE_ID) : 0;
  auto PLUGIN_ID__ = PLUGIN_ID ? _fbb.CreateString(PLUGIN_ID) : 0;
  auto PLUGIN_VERSION__ = PLUGIN_VERSION ? _fbb.CreateString(PLUGIN_VERSION) : 0;
  auto LICENSEE_ORG__ = LICENSEE_ORG ? _fbb.CreateString(LICENSEE_ORG) : 0;
  auto LICENSEE_EMAIL__ = LICENSEE_EMAIL ? _fbb.CreateString(LICENSEE_EMAIL) : 0;
  auto LICENSEE_PEER_ID__ = LICENSEE_PEER_ID ? _fbb.CreateString(LICENSEE_PEER_ID) : 0;
  auto LICENSEE_PUBKEY__ = LICENSEE_PUBKEY ? _fbb.CreateVector<uint8_t>(*LICENSEE_PUBKEY) : 0;
  auto ISSUER_PUBKEY__ = ISSUER_PUBKEY ? _fbb.CreateVector<uint8_t>(*ISSUER_PUBKEY) : 0;
  auto ALLOWED_DOMAINS__ = ALLOWED_DOMAINS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ALLOWED_DOMAINS) : 0;
  auto ALLOWED_TLDS__ = ALLOWED_TLDS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ALLOWED_TLDS) : 0;
  auto ISSUER_PEER_ID__ = ISSUER_PEER_ID ? _fbb.CreateString(ISSUER_PEER_ID) : 0;
  auto SIGNATURE__ = SIGNATURE ? _fbb.CreateVector<uint8_t>(*SIGNATURE) : 0;
  return CreatePLK(
      _fbb,
      LICENSE_ID__,
      PLUGIN_ID__,
      PLUGIN_VERSION__,
      LICENSEE_ORG__,
      LICENSEE_EMAIL__,
      LICENSEE_PEER_ID__,
      LICENSEE_PUBKEY__,
      ISSUER_PUBKEY__,
      ALLOWED_DOMAINS__,
      ALLOWED_TLDS__,
      LICENSE_TYPE,
      MAX_ACTIVATIONS,
      ISSUED_AT,
      VALID_FROM,
      EXPIRES_AT,
      ISSUER_PEER_ID__,
      SIGNATURE__);
}

inline const PLK *GetPLK(const void *buf) {
  return ::flatbuffers::GetRoot<PLK>(buf);
}

inline const PLK *GetSizePrefixedPLK(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PLK>(buf);
}

inline const char *PLKIdentifier() {
  return "$PLK";
}

inline bool PLKBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLKIdentifier());
}

inline bool SizePrefixedPLKBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLKIdentifier(), true);
}

inline bool VerifyPLKBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PLK>(PLKIdentifier());
}

inline bool VerifySizePrefixedPLKBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PLK>(PLKIdentifier());
}

inline void FinishPLKBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLK> root) {
  fbb.Finish(root, PLKIdentifier());
}

inline void FinishSizePrefixedPLKBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLK> root) {
  fbb.FinishSizePrefixed(root, PLKIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
