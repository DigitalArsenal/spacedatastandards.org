// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"
#include "main_generated.h"

struct EOO;
struct EOOBuilder;

struct EOOCOLLECTION;
struct EOOCOLLECTIONBuilder;

/// Enumeration for data collection methods
enum CollectMethod : int8_t {
  CollectMethod_SIDEREAL = 0,
  CollectMethod_RATE_TRACK = 1,
  CollectMethod_FIXED_STARE = 2,
  CollectMethod_OTHER = 3,
  CollectMethod_MIN = CollectMethod_SIDEREAL,
  CollectMethod_MAX = CollectMethod_OTHER
};

inline const CollectMethod (&EnumValuesCollectMethod())[4] {
  static const CollectMethod values[] = {
    CollectMethod_SIDEREAL,
    CollectMethod_RATE_TRACK,
    CollectMethod_FIXED_STARE,
    CollectMethod_OTHER
  };
  return values;
}

inline const char * const *EnumNamesCollectMethod() {
  static const char * const names[5] = {
    "SIDEREAL",
    "RATE_TRACK",
    "FIXED_STARE",
    "OTHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameCollectMethod(CollectMethod e) {
  if (::flatbuffers::IsOutRange(e, CollectMethod_SIDEREAL, CollectMethod_OTHER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCollectMethod()[index];
}

enum ObservationPosition : int8_t {
  ObservationPosition_FENCE = 0,
  ObservationPosition_FIRST = 1,
  ObservationPosition_IN = 2,
  ObservationPosition_LAST = 3,
  ObservationPosition_SINGLE = 4,
  ObservationPosition_MIN = ObservationPosition_FENCE,
  ObservationPosition_MAX = ObservationPosition_SINGLE
};

inline const ObservationPosition (&EnumValuesObservationPosition())[5] {
  static const ObservationPosition values[] = {
    ObservationPosition_FENCE,
    ObservationPosition_FIRST,
    ObservationPosition_IN,
    ObservationPosition_LAST,
    ObservationPosition_SINGLE
  };
  return values;
}

inline const char * const *EnumNamesObservationPosition() {
  static const char * const names[6] = {
    "FENCE",
    "FIRST",
    "IN",
    "LAST",
    "SINGLE",
    nullptr
  };
  return names;
}

inline const char *EnumNameObservationPosition(ObservationPosition e) {
  if (::flatbuffers::IsOutRange(e, ObservationPosition_FENCE, ObservationPosition_SINGLE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObservationPosition()[index];
}

/// Electro-Optical Observation
struct EOO FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATION = 6,
    VT_OB_TIME = 8,
    VT_CORR_QUALITY = 10,
    VT_ID_ON_ORBIT = 12,
    VT_SENSOR_ID = 14,
    VT_COLLECT_METHOD = 16,
    VT_NORAD_CAT_ID = 18,
    VT_TASK_ID = 20,
    VT_TRANSACTION_ID = 22,
    VT_TRACK_ID = 24,
    VT_OB_POSITION = 26,
    VT_ORIG_OBJECT_ID = 28,
    VT_ORIG_SENSOR_ID = 30,
    VT_UCT = 32,
    VT_AZIMUTH = 34,
    VT_AZIMUTH_UNC = 36,
    VT_AZIMUTH_BIAS = 38,
    VT_AZIMUTH_RATE = 40,
    VT_ELEVATION = 42,
    VT_ELEVATION_UNC = 44,
    VT_ELEVATION_BIAS = 46,
    VT_ELEVATION_RATE = 48,
    VT_RANGE = 50,
    VT_RANGE_UNC = 52,
    VT_RANGE_BIAS = 54,
    VT_RANGE_RATE = 56,
    VT_RANGE_RATE_UNC = 58,
    VT_RA = 60,
    VT_RA_RATE = 62,
    VT_RA_UNC = 64,
    VT_RA_BIAS = 66,
    VT_DECLINATION = 68,
    VT_DECLINATION_RATE = 70,
    VT_DECLINATION_UNC = 72,
    VT_DECLINATION_BIAS = 74,
    VT_LOSX = 76,
    VT_LOSY = 78,
    VT_LOSZ = 80,
    VT_LOS_UNC = 82,
    VT_LOSXVEL = 84,
    VT_LOSYVEL = 86,
    VT_LOSZVEL = 88,
    VT_SENLAT = 90,
    VT_SENLON = 92,
    VT_SENALT = 94,
    VT_SENX = 96,
    VT_SENY = 98,
    VT_SENZ = 100,
    VT_FOV_COUNT = 102,
    VT_FOV_COUNT_UCTS = 104,
    VT_EXP_DURATION = 106,
    VT_ZEROPTD = 108,
    VT_NET_OBJ_SIG = 110,
    VT_NET_OBJ_SIG_UNC = 112,
    VT_MAG = 114,
    VT_MAG_UNC = 116,
    VT_MAG_NORM_RANGE = 118,
    VT_GEOLAT = 120,
    VT_GEOLON = 122,
    VT_GEOALT = 124,
    VT_GEORANGE = 126,
    VT_SKY_BKGRND = 128,
    VT_PRIMARY_EXTINCTION = 130,
    VT_PRIMARY_EXTINCTION_UNC = 132,
    VT_SOLAR_PHASE_ANGLE = 134,
    VT_SOLAR_EQ_PHASE_ANGLE = 136,
    VT_SOLAR_DEC_ANGLE = 138,
    VT_SHUTTER_DELAY = 140,
    VT_TIMING_BIAS = 142,
    VT_RAW_FILE_URI = 144,
    VT_INTENSITY = 146,
    VT_BG_INTENSITY = 148,
    VT_DESCRIPTOR = 150,
    VT_SOURCE = 152,
    VT_ORIGIN = 154,
    VT_DATA_MODE = 156,
    VT_CREATED_AT = 158,
    VT_CREATED_BY = 160,
    VT_REFERENCE_FRAME = 162,
    VT_SEN_REFERENCE_FRAME = 164,
    VT_UMBRA = 166,
    VT_PENUMBRA = 168,
    VT_ORIG_NETWORK = 170,
    VT_SOURCE_DL = 172,
    VT_TYPE = 174,
    VT_AZIMUTH_MEASURED = 176,
    VT_ELEVATION_MEASURED = 178,
    VT_RANGE_MEASURED = 180,
    VT_RANGERATE_MEASURED = 182,
    VT_RA_MEASURED = 184,
    VT_DECLINATION_MEASURED = 186
  };
  /// Unique identifier of the record.
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  const ::flatbuffers::String *CLASSIFICATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION);
  }
  /// Ob detection time in ISO 8601 UTC (YYYY-MM-DDTHH:MM:SS.ssssssZ), up to microsecond precision.
  const ::flatbuffers::String *OB_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OB_TIME);
  }
  /// Correlation score of the observation when compared to a known orbit state.
  float CORR_QUALITY() const {
    return GetField<float>(VT_CORR_QUALITY, 0.0f);
  }
  /// Server will auto-populate with SAT_NO if available.
  const ::flatbuffers::String *ID_ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ON_ORBIT);
  }
  /// Unique ID of the sensor. Must have a corresponding sensor record on the server.
  const ::flatbuffers::String *SENSOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_ID);
  }
  /// Accepted Collection Method
  CollectMethod COLLECT_METHOD() const {
    return static_cast<CollectMethod>(GetField<int8_t>(VT_COLLECT_METHOD, 0));
  }
  /// 18SDS satellite number. Only list if correlated against the 18SDS catalog.
  int32_t NORAD_CAT_ID() const {
    return GetField<int32_t>(VT_NORAD_CAT_ID, 0);
  }
  /// Identifier for the collectRequest message if the collection was in response to tasking.
  const ::flatbuffers::String *TASK_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  /// Optional identifier to track a transaction.
  const ::flatbuffers::String *TRANSACTION_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTION_ID);
  }
  /// Identifier of the track to which this observation belongs, if applicable.
  const ::flatbuffers::String *TRACK_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACK_ID);
  }
  /// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).
  ObservationPosition OB_POSITION() const {
    return static_cast<ObservationPosition>(GetField<int8_t>(VT_OB_POSITION, 0));
  }
  /// Provider maintained ID. May not be consistent with 18SDS SAT_NO.
  const ::flatbuffers::String *ORIG_OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_OBJECT_ID);
  }
  /// Sensor ID.
  const ::flatbuffers::String *ORIG_SENSOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_SENSOR_ID);
  }
  /// Required if correlation is attempted. Indicates whether correlation succeeded.
  bool UCT() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// Line of sight azimuth angle in degrees and topocentric frame.
  float AZIMUTH() const {
    return GetField<float>(VT_AZIMUTH, 0.0f);
  }
  /// One sigma uncertainty in the line of sight azimuth angle, in degrees.
  float AZIMUTH_UNC() const {
    return GetField<float>(VT_AZIMUTH_UNC, 0.0f);
  }
  /// Sensor line of sight azimuth angle bias in degrees.
  float AZIMUTH_BIAS() const {
    return GetField<float>(VT_AZIMUTH_BIAS, 0.0f);
  }
  /// Rate of change of the line of sight azimuth in degrees per second.
  float AZIMUTH_RATE() const {
    return GetField<float>(VT_AZIMUTH_RATE, 0.0f);
  }
  /// Line of sight elevation in degrees and topocentric frame.
  float ELEVATION() const {
    return GetField<float>(VT_ELEVATION, 0.0f);
  }
  /// One sigma uncertainty in the line of sight elevation angle, in degrees.
  float ELEVATION_UNC() const {
    return GetField<float>(VT_ELEVATION_UNC, 0.0f);
  }
  /// Sensor line of sight elevation bias in degrees.
  float ELEVATION_BIAS() const {
    return GetField<float>(VT_ELEVATION_BIAS, 0.0f);
  }
  /// Rate of change of the line of sight elevation in degrees per second.
  float ELEVATION_RATE() const {
    return GetField<float>(VT_ELEVATION_RATE, 0.0f);
  }
  /// Line of sight range in km. Reported value should include all applicable corrections.
  float RANGE() const {
    return GetField<float>(VT_RANGE, 0.0f);
  }
  /// One sigma uncertainty in the line of sight range, in km.
  float RANGE_UNC() const {
    return GetField<float>(VT_RANGE_UNC, 0.0f);
  }
  /// Sensor line of sight range bias in km.
  float RANGE_BIAS() const {
    return GetField<float>(VT_RANGE_BIAS, 0.0f);
  }
  /// Range rate in km/s. Reported value should include all applicable corrections.
  float RANGE_RATE() const {
    return GetField<float>(VT_RANGE_RATE, 0.0f);
  }
  /// One sigma uncertainty in the line of sight range rate, in km/sec.
  float RANGE_RATE_UNC() const {
    return GetField<float>(VT_RANGE_RATE_UNC, 0.0f);
  }
  /// Right ascension in degrees. Required metric reporting field for EO observations.
  float RA() const {
    return GetField<float>(VT_RA, 0.0f);
  }
  /// Line of sight right ascension rate of change, in degrees/sec.
  float RA_RATE() const {
    return GetField<float>(VT_RA_RATE, 0.0f);
  }
  /// One sigma uncertainty in the line of sight right ascension angle, in degrees.
  float RA_UNC() const {
    return GetField<float>(VT_RA_UNC, 0.0f);
  }
  /// Sensor line of sight right ascension bias in degrees.
  float RA_BIAS() const {
    return GetField<float>(VT_RA_BIAS, 0.0f);
  }
  /// Declination in degrees. Required metric reporting field for EO observations.
  float DECLINATION() const {
    return GetField<float>(VT_DECLINATION, 0.0f);
  }
  /// Line of sight declination rate of change, in degrees/sec.
  float DECLINATION_RATE() const {
    return GetField<float>(VT_DECLINATION_RATE, 0.0f);
  }
  /// One sigma uncertainty in the line of sight declination angle, in degrees.
  float DECLINATION_UNC() const {
    return GetField<float>(VT_DECLINATION_UNC, 0.0f);
  }
  /// Sensor line of sight declination angle bias in degrees.
  float DECLINATION_BIAS() const {
    return GetField<float>(VT_DECLINATION_BIAS, 0.0f);
  }
  /// X-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
  float LOSX() const {
    return GetField<float>(VT_LOSX, 0.0f);
  }
  /// Y-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
  float LOSY() const {
    return GetField<float>(VT_LOSY, 0.0f);
  }
  /// Z-component of the unit vector representing the line-of-sight direction in the observer's reference frame.
  float LOSZ() const {
    return GetField<float>(VT_LOSZ, 0.0f);
  }
  /// One sigma uncertainty in the line-of-sight direction vector components.
  float LOS_UNC() const {
    return GetField<float>(VT_LOS_UNC, 0.0f);
  }
  /// X-component of the velocity vector along the line of sight, in km/s.
  float LOSXVEL() const {
    return GetField<float>(VT_LOSXVEL, 0.0f);
  }
  /// Y-component of the velocity vector along the line of sight, in km/s.
  float LOSYVEL() const {
    return GetField<float>(VT_LOSYVEL, 0.0f);
  }
  /// Z-component of the velocity vector along the line of sight, in km/s.
  float LOSZVEL() const {
    return GetField<float>(VT_LOSZVEL, 0.0f);
  }
  /// WGS-84 latitude in decimal degrees at the time of the observation.
  float SENLAT() const {
    return GetField<float>(VT_SENLAT, 0.0f);
  }
  /// WGS-84 longitude in decimal degrees at the time of the observation.
  float SENLON() const {
    return GetField<float>(VT_SENLON, 0.0f);
  }
  /// Sensor height in km relative to the WGS-84 ellipsoid at the time of the observation.
  float SENALT() const {
    return GetField<float>(VT_SENALT, 0.0f);
  }
  /// Cartesian X position in km at the time of the observation.
  float SENX() const {
    return GetField<float>(VT_SENX, 0.0f);
  }
  /// Cartesian Y position in km at the time of the observation.
  float SENY() const {
    return GetField<float>(VT_SENY, 0.0f);
  }
  /// Cartesian Z position in km at the time of the observation.
  float SENZ() const {
    return GetField<float>(VT_SENZ, 0.0f);
  }
  /// Total number of satellites in the field of view.
  int32_t FOV_COUNT() const {
    return GetField<int32_t>(VT_FOV_COUNT, 0);
  }
  /// Number of uncorrelated satellites in the field of view (JCO).
  int32_t FOV_COUNT_UCTS() const {
    return GetField<int32_t>(VT_FOV_COUNT_UCTS, 0);
  }
  /// Image exposure duration in seconds. For observations performed using frame stacking or synthetic tracking methods, 
  /// the exposure duration should be the total integration time. This field is highly recommended / required if the 
  /// observations are going to be used for photometric processing.
  float EXP_DURATION() const {
    return GetField<float>(VT_EXP_DURATION, 0.0f);
  }
  /// Formula: 2.5 * log_10 (zero_mag_counts / EXP_DURATION).
  float ZEROPTD() const {
    return GetField<float>(VT_ZEROPTD, 0.0f);
  }
  /// Net object signature = counts / EXP_DURATION.
  float NET_OBJ_SIG() const {
    return GetField<float>(VT_NET_OBJ_SIG, 0.0f);
  }
  /// Net object signature uncertainty = counts uncertainty / EXP_DURATION.
  float NET_OBJ_SIG_UNC() const {
    return GetField<float>(VT_NET_OBJ_SIG_UNC, 0.0f);
  }
  /// Measure of observed brightness calibrated against the Gaia G-band.
  float MAG() const {
    return GetField<float>(VT_MAG, 0.0f);
  }
  /// Uncertainty of the observed brightness.
  float MAG_UNC() const {
    return GetField<float>(VT_MAG_UNC, 0.0f);
  }
  /// [Definition needed].
  float MAG_NORM_RANGE() const {
    return GetField<float>(VT_MAG_NORM_RANGE, 0.0f);
  }
  /// Computed estimate of the latitude, positive degrees north. It should be computed based on the assumed slant range 
  /// and corresponding viewing geometry. It must NOT be computed from the orbit state.
  float GEOLAT() const {
    return GetField<float>(VT_GEOLAT, 0.0f);
  }
  /// Computed estimate of the longitude as +/- 180 degrees east. It should be computed based on the assumed slant range 
  /// and viewing geometry. It must NOT be computed from the orbit state.
  float GEOLON() const {
    return GetField<float>(VT_GEOLON, 0.0f);
  }
  /// Computed estimate of satellite altitude in km at the reported location. It must NOT be computed from the orbit state.
  float GEOALT() const {
    return GetField<float>(VT_GEOALT, 0.0f);
  }
  /// Computed estimate of the slant range in km. It must NOT be computed from the orbit state.
  float GEORANGE() const {
    return GetField<float>(VT_GEORANGE, 0.0f);
  }
  /// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently 
  /// empty part of the night sky.
  float SKY_BKGRND() const {
    return GetField<float>(VT_SKY_BKGRND, 0.0f);
  }
  /// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass 
  /// to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, 
  /// describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical 
  /// object and the observer.
  float PRIMARY_EXTINCTION() const {
    return GetField<float>(VT_PRIMARY_EXTINCTION, 0.0f);
  }
  /// Primary Extinction Coefficient Uncertainty, in Magnitudes.
  float PRIMARY_EXTINCTION_UNC() const {
    return GetField<float>(VT_PRIMARY_EXTINCTION_UNC, 0.0f);
  }
  /// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector. Recommend using the 
  /// calculation listed in the EOSSA documentation, pg 106 of the EOSSA spec.
  float SOLAR_PHASE_ANGLE() const {
    return GetField<float>(VT_SOLAR_PHASE_ANGLE, 0.0f);
  }
  /// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector 
  /// onto the equatorial plane. The convention used is negative when closing (i.e., before the opposition) 
  /// and positive when opening (after the opposition).
  float SOLAR_EQ_PHASE_ANGLE() const {
    return GetField<float>(VT_SOLAR_EQ_PHASE_ANGLE, 0.0f);
  }
  /// Angle from the sun to the equatorial plane.
  float SOLAR_DEC_ANGLE() const {
    return GetField<float>(VT_SOLAR_DEC_ANGLE, 0.0f);
  }
  /// Shutter delay in seconds.
  float SHUTTER_DELAY() const {
    return GetField<float>(VT_SHUTTER_DELAY, 0.0f);
  }
  /// Sensor timing bias in seconds.
  float TIMING_BIAS() const {
    return GetField<float>(VT_TIMING_BIAS, 0.0f);
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. 
  const ::flatbuffers::String *RAW_FILE_URI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAW_FILE_URI);
  }
  /// Intensity of the target for IR observations, in kw/sr/em.
  float INTENSITY() const {
    return GetField<float>(VT_INTENSITY, 0.0f);
  }
  /// Background intensity for IR observations, in kw/sr/um.
  float BG_INTENSITY() const {
    return GetField<float>(VT_BG_INTENSITY, 0.0f);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  const ::flatbuffers::String *DESCRIPTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Source of the data.
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source.
  /// The origin may be different than the source if the source was a mediating system which forwarded 
  /// the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  const ::flatbuffers::String *ORIGIN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST.
  DataMode DATA_MODE() const {
    return static_cast<DataMode>(GetField<int8_t>(VT_DATA_MODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  const ::flatbuffers::String *CREATED_AT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATED_AT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  const ::flatbuffers::String *CREATED_BY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATED_BY);
  }
  /// EO observations are assumed to be topocentric J2000 coordinates ('J2000') as defined by the IAU, unless otherwise specified.
  refFrame REFERENCE_FRAME() const {
    return static_cast<refFrame>(GetField<int8_t>(VT_REFERENCE_FRAME, 0));
  }
  /// The sensor reference frame is assumed to be the International Terrestrial Reference Frame (ITRF), 
  /// unless otherwise specified. (ITRF is equivalent to Earth-Centered Earth-Fixed (ECEF) for this purpose). 
  /// Lat / long / height values should be reported using the WGS-84 ellipsoid, where applicable.
  const ::flatbuffers::String *SEN_REFERENCE_FRAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEN_REFERENCE_FRAME);
  }
  /// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
  bool UMBRA() const {
    return GetField<uint8_t>(VT_UMBRA, 0) != 0;
  }
  /// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
  /// This field is highly recommended if the observations will be used for photometric processing.
  bool PENUMBRA() const {
    return GetField<uint8_t>(VT_PENUMBRA, 0) != 0;
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  const ::flatbuffers::String *ORIG_NETWORK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_NETWORK);
  }
  /// The source from which this record was received.
  const ::flatbuffers::String *SOURCE_DL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_DL);
  }
  /// Device Type
  DeviceType TYPE() const {
    return static_cast<DeviceType>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// True if measured, false if computed. Required if azimuth is reported.
  bool AZIMUTH_MEASURED() const {
    return GetField<uint8_t>(VT_AZIMUTH_MEASURED, 0) != 0;
  }
  /// True if measured, false if computed. Required if elevation is reported.
  bool ELEVATION_MEASURED() const {
    return GetField<uint8_t>(VT_ELEVATION_MEASURED, 0) != 0;
  }
  /// True if measured, false if computed. Required if range is reported.
  bool RANGE_MEASURED() const {
    return GetField<uint8_t>(VT_RANGE_MEASURED, 0) != 0;
  }
  /// True if measured, false if computed. Required if range-rate is reported.
  bool RANGERATE_MEASURED() const {
    return GetField<uint8_t>(VT_RANGERATE_MEASURED, 0) != 0;
  }
  /// True if measured, false if computed. Required if right ascension is reported.
  bool RA_MEASURED() const {
    return GetField<uint8_t>(VT_RA_MEASURED, 0) != 0;
  }
  /// True if measured, false if computed. Required if declination is reported.
  bool DECLINATION_MEASURED() const {
    return GetField<uint8_t>(VT_DECLINATION_MEASURED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyString(CLASSIFICATION()) &&
           VerifyOffset(verifier, VT_OB_TIME) &&
           verifier.VerifyString(OB_TIME()) &&
           VerifyField<float>(verifier, VT_CORR_QUALITY, 4) &&
           VerifyOffset(verifier, VT_ID_ON_ORBIT) &&
           verifier.VerifyString(ID_ON_ORBIT()) &&
           VerifyOffset(verifier, VT_SENSOR_ID) &&
           verifier.VerifyString(SENSOR_ID()) &&
           VerifyField<int8_t>(verifier, VT_COLLECT_METHOD, 1) &&
           VerifyField<int32_t>(verifier, VT_NORAD_CAT_ID, 4) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(TASK_ID()) &&
           VerifyOffset(verifier, VT_TRANSACTION_ID) &&
           verifier.VerifyString(TRANSACTION_ID()) &&
           VerifyOffset(verifier, VT_TRACK_ID) &&
           verifier.VerifyString(TRACK_ID()) &&
           VerifyField<int8_t>(verifier, VT_OB_POSITION, 1) &&
           VerifyOffset(verifier, VT_ORIG_OBJECT_ID) &&
           verifier.VerifyString(ORIG_OBJECT_ID()) &&
           VerifyOffset(verifier, VT_ORIG_SENSOR_ID) &&
           verifier.VerifyString(ORIG_SENSOR_ID()) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyField<float>(verifier, VT_AZIMUTH, 4) &&
           VerifyField<float>(verifier, VT_AZIMUTH_UNC, 4) &&
           VerifyField<float>(verifier, VT_AZIMUTH_BIAS, 4) &&
           VerifyField<float>(verifier, VT_AZIMUTH_RATE, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_UNC, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_BIAS, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_RATE, 4) &&
           VerifyField<float>(verifier, VT_RANGE, 4) &&
           VerifyField<float>(verifier, VT_RANGE_UNC, 4) &&
           VerifyField<float>(verifier, VT_RANGE_BIAS, 4) &&
           VerifyField<float>(verifier, VT_RANGE_RATE, 4) &&
           VerifyField<float>(verifier, VT_RANGE_RATE_UNC, 4) &&
           VerifyField<float>(verifier, VT_RA, 4) &&
           VerifyField<float>(verifier, VT_RA_RATE, 4) &&
           VerifyField<float>(verifier, VT_RA_UNC, 4) &&
           VerifyField<float>(verifier, VT_RA_BIAS, 4) &&
           VerifyField<float>(verifier, VT_DECLINATION, 4) &&
           VerifyField<float>(verifier, VT_DECLINATION_RATE, 4) &&
           VerifyField<float>(verifier, VT_DECLINATION_UNC, 4) &&
           VerifyField<float>(verifier, VT_DECLINATION_BIAS, 4) &&
           VerifyField<float>(verifier, VT_LOSX, 4) &&
           VerifyField<float>(verifier, VT_LOSY, 4) &&
           VerifyField<float>(verifier, VT_LOSZ, 4) &&
           VerifyField<float>(verifier, VT_LOS_UNC, 4) &&
           VerifyField<float>(verifier, VT_LOSXVEL, 4) &&
           VerifyField<float>(verifier, VT_LOSYVEL, 4) &&
           VerifyField<float>(verifier, VT_LOSZVEL, 4) &&
           VerifyField<float>(verifier, VT_SENLAT, 4) &&
           VerifyField<float>(verifier, VT_SENLON, 4) &&
           VerifyField<float>(verifier, VT_SENALT, 4) &&
           VerifyField<float>(verifier, VT_SENX, 4) &&
           VerifyField<float>(verifier, VT_SENY, 4) &&
           VerifyField<float>(verifier, VT_SENZ, 4) &&
           VerifyField<int32_t>(verifier, VT_FOV_COUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_FOV_COUNT_UCTS, 4) &&
           VerifyField<float>(verifier, VT_EXP_DURATION, 4) &&
           VerifyField<float>(verifier, VT_ZEROPTD, 4) &&
           VerifyField<float>(verifier, VT_NET_OBJ_SIG, 4) &&
           VerifyField<float>(verifier, VT_NET_OBJ_SIG_UNC, 4) &&
           VerifyField<float>(verifier, VT_MAG, 4) &&
           VerifyField<float>(verifier, VT_MAG_UNC, 4) &&
           VerifyField<float>(verifier, VT_MAG_NORM_RANGE, 4) &&
           VerifyField<float>(verifier, VT_GEOLAT, 4) &&
           VerifyField<float>(verifier, VT_GEOLON, 4) &&
           VerifyField<float>(verifier, VT_GEOALT, 4) &&
           VerifyField<float>(verifier, VT_GEORANGE, 4) &&
           VerifyField<float>(verifier, VT_SKY_BKGRND, 4) &&
           VerifyField<float>(verifier, VT_PRIMARY_EXTINCTION, 4) &&
           VerifyField<float>(verifier, VT_PRIMARY_EXTINCTION_UNC, 4) &&
           VerifyField<float>(verifier, VT_SOLAR_PHASE_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_SOLAR_EQ_PHASE_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_SOLAR_DEC_ANGLE, 4) &&
           VerifyField<float>(verifier, VT_SHUTTER_DELAY, 4) &&
           VerifyField<float>(verifier, VT_TIMING_BIAS, 4) &&
           VerifyOffset(verifier, VT_RAW_FILE_URI) &&
           verifier.VerifyString(RAW_FILE_URI()) &&
           VerifyField<float>(verifier, VT_INTENSITY, 4) &&
           VerifyField<float>(verifier, VT_BG_INTENSITY, 4) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(DESCRIPTOR()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(ORIGIN()) &&
           VerifyField<int8_t>(verifier, VT_DATA_MODE, 1) &&
           VerifyOffset(verifier, VT_CREATED_AT) &&
           verifier.VerifyString(CREATED_AT()) &&
           VerifyOffset(verifier, VT_CREATED_BY) &&
           verifier.VerifyString(CREATED_BY()) &&
           VerifyField<int8_t>(verifier, VT_REFERENCE_FRAME, 1) &&
           VerifyOffset(verifier, VT_SEN_REFERENCE_FRAME) &&
           verifier.VerifyString(SEN_REFERENCE_FRAME()) &&
           VerifyField<uint8_t>(verifier, VT_UMBRA, 1) &&
           VerifyField<uint8_t>(verifier, VT_PENUMBRA, 1) &&
           VerifyOffset(verifier, VT_ORIG_NETWORK) &&
           verifier.VerifyString(ORIG_NETWORK()) &&
           VerifyOffset(verifier, VT_SOURCE_DL) &&
           verifier.VerifyString(SOURCE_DL()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AZIMUTH_MEASURED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ELEVATION_MEASURED, 1) &&
           VerifyField<uint8_t>(verifier, VT_RANGE_MEASURED, 1) &&
           VerifyField<uint8_t>(verifier, VT_RANGERATE_MEASURED, 1) &&
           VerifyField<uint8_t>(verifier, VT_RA_MEASURED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DECLINATION_MEASURED, 1) &&
           verifier.EndTable();
  }
};

struct EOOBuilder {
  typedef EOO Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(EOO::VT_ID, ID);
  }
  void add_CLASSIFICATION(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION) {
    fbb_.AddOffset(EOO::VT_CLASSIFICATION, CLASSIFICATION);
  }
  void add_OB_TIME(::flatbuffers::Offset<::flatbuffers::String> OB_TIME) {
    fbb_.AddOffset(EOO::VT_OB_TIME, OB_TIME);
  }
  void add_CORR_QUALITY(float CORR_QUALITY) {
    fbb_.AddElement<float>(EOO::VT_CORR_QUALITY, CORR_QUALITY, 0.0f);
  }
  void add_ID_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT) {
    fbb_.AddOffset(EOO::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  void add_SENSOR_ID(::flatbuffers::Offset<::flatbuffers::String> SENSOR_ID) {
    fbb_.AddOffset(EOO::VT_SENSOR_ID, SENSOR_ID);
  }
  void add_COLLECT_METHOD(CollectMethod COLLECT_METHOD) {
    fbb_.AddElement<int8_t>(EOO::VT_COLLECT_METHOD, static_cast<int8_t>(COLLECT_METHOD), 0);
  }
  void add_NORAD_CAT_ID(int32_t NORAD_CAT_ID) {
    fbb_.AddElement<int32_t>(EOO::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_TASK_ID(::flatbuffers::Offset<::flatbuffers::String> TASK_ID) {
    fbb_.AddOffset(EOO::VT_TASK_ID, TASK_ID);
  }
  void add_TRANSACTION_ID(::flatbuffers::Offset<::flatbuffers::String> TRANSACTION_ID) {
    fbb_.AddOffset(EOO::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  void add_TRACK_ID(::flatbuffers::Offset<::flatbuffers::String> TRACK_ID) {
    fbb_.AddOffset(EOO::VT_TRACK_ID, TRACK_ID);
  }
  void add_OB_POSITION(ObservationPosition OB_POSITION) {
    fbb_.AddElement<int8_t>(EOO::VT_OB_POSITION, static_cast<int8_t>(OB_POSITION), 0);
  }
  void add_ORIG_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID) {
    fbb_.AddOffset(EOO::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  void add_ORIG_SENSOR_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID) {
    fbb_.AddOffset(EOO::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  void add_UCT(bool UCT) {
    fbb_.AddElement<uint8_t>(EOO::VT_UCT, static_cast<uint8_t>(UCT), 0);
  }
  void add_AZIMUTH(float AZIMUTH) {
    fbb_.AddElement<float>(EOO::VT_AZIMUTH, AZIMUTH, 0.0f);
  }
  void add_AZIMUTH_UNC(float AZIMUTH_UNC) {
    fbb_.AddElement<float>(EOO::VT_AZIMUTH_UNC, AZIMUTH_UNC, 0.0f);
  }
  void add_AZIMUTH_BIAS(float AZIMUTH_BIAS) {
    fbb_.AddElement<float>(EOO::VT_AZIMUTH_BIAS, AZIMUTH_BIAS, 0.0f);
  }
  void add_AZIMUTH_RATE(float AZIMUTH_RATE) {
    fbb_.AddElement<float>(EOO::VT_AZIMUTH_RATE, AZIMUTH_RATE, 0.0f);
  }
  void add_ELEVATION(float ELEVATION) {
    fbb_.AddElement<float>(EOO::VT_ELEVATION, ELEVATION, 0.0f);
  }
  void add_ELEVATION_UNC(float ELEVATION_UNC) {
    fbb_.AddElement<float>(EOO::VT_ELEVATION_UNC, ELEVATION_UNC, 0.0f);
  }
  void add_ELEVATION_BIAS(float ELEVATION_BIAS) {
    fbb_.AddElement<float>(EOO::VT_ELEVATION_BIAS, ELEVATION_BIAS, 0.0f);
  }
  void add_ELEVATION_RATE(float ELEVATION_RATE) {
    fbb_.AddElement<float>(EOO::VT_ELEVATION_RATE, ELEVATION_RATE, 0.0f);
  }
  void add_RANGE(float RANGE) {
    fbb_.AddElement<float>(EOO::VT_RANGE, RANGE, 0.0f);
  }
  void add_RANGE_UNC(float RANGE_UNC) {
    fbb_.AddElement<float>(EOO::VT_RANGE_UNC, RANGE_UNC, 0.0f);
  }
  void add_RANGE_BIAS(float RANGE_BIAS) {
    fbb_.AddElement<float>(EOO::VT_RANGE_BIAS, RANGE_BIAS, 0.0f);
  }
  void add_RANGE_RATE(float RANGE_RATE) {
    fbb_.AddElement<float>(EOO::VT_RANGE_RATE, RANGE_RATE, 0.0f);
  }
  void add_RANGE_RATE_UNC(float RANGE_RATE_UNC) {
    fbb_.AddElement<float>(EOO::VT_RANGE_RATE_UNC, RANGE_RATE_UNC, 0.0f);
  }
  void add_RA(float RA) {
    fbb_.AddElement<float>(EOO::VT_RA, RA, 0.0f);
  }
  void add_RA_RATE(float RA_RATE) {
    fbb_.AddElement<float>(EOO::VT_RA_RATE, RA_RATE, 0.0f);
  }
  void add_RA_UNC(float RA_UNC) {
    fbb_.AddElement<float>(EOO::VT_RA_UNC, RA_UNC, 0.0f);
  }
  void add_RA_BIAS(float RA_BIAS) {
    fbb_.AddElement<float>(EOO::VT_RA_BIAS, RA_BIAS, 0.0f);
  }
  void add_DECLINATION(float DECLINATION) {
    fbb_.AddElement<float>(EOO::VT_DECLINATION, DECLINATION, 0.0f);
  }
  void add_DECLINATION_RATE(float DECLINATION_RATE) {
    fbb_.AddElement<float>(EOO::VT_DECLINATION_RATE, DECLINATION_RATE, 0.0f);
  }
  void add_DECLINATION_UNC(float DECLINATION_UNC) {
    fbb_.AddElement<float>(EOO::VT_DECLINATION_UNC, DECLINATION_UNC, 0.0f);
  }
  void add_DECLINATION_BIAS(float DECLINATION_BIAS) {
    fbb_.AddElement<float>(EOO::VT_DECLINATION_BIAS, DECLINATION_BIAS, 0.0f);
  }
  void add_LOSX(float LOSX) {
    fbb_.AddElement<float>(EOO::VT_LOSX, LOSX, 0.0f);
  }
  void add_LOSY(float LOSY) {
    fbb_.AddElement<float>(EOO::VT_LOSY, LOSY, 0.0f);
  }
  void add_LOSZ(float LOSZ) {
    fbb_.AddElement<float>(EOO::VT_LOSZ, LOSZ, 0.0f);
  }
  void add_LOS_UNC(float LOS_UNC) {
    fbb_.AddElement<float>(EOO::VT_LOS_UNC, LOS_UNC, 0.0f);
  }
  void add_LOSXVEL(float LOSXVEL) {
    fbb_.AddElement<float>(EOO::VT_LOSXVEL, LOSXVEL, 0.0f);
  }
  void add_LOSYVEL(float LOSYVEL) {
    fbb_.AddElement<float>(EOO::VT_LOSYVEL, LOSYVEL, 0.0f);
  }
  void add_LOSZVEL(float LOSZVEL) {
    fbb_.AddElement<float>(EOO::VT_LOSZVEL, LOSZVEL, 0.0f);
  }
  void add_SENLAT(float SENLAT) {
    fbb_.AddElement<float>(EOO::VT_SENLAT, SENLAT, 0.0f);
  }
  void add_SENLON(float SENLON) {
    fbb_.AddElement<float>(EOO::VT_SENLON, SENLON, 0.0f);
  }
  void add_SENALT(float SENALT) {
    fbb_.AddElement<float>(EOO::VT_SENALT, SENALT, 0.0f);
  }
  void add_SENX(float SENX) {
    fbb_.AddElement<float>(EOO::VT_SENX, SENX, 0.0f);
  }
  void add_SENY(float SENY) {
    fbb_.AddElement<float>(EOO::VT_SENY, SENY, 0.0f);
  }
  void add_SENZ(float SENZ) {
    fbb_.AddElement<float>(EOO::VT_SENZ, SENZ, 0.0f);
  }
  void add_FOV_COUNT(int32_t FOV_COUNT) {
    fbb_.AddElement<int32_t>(EOO::VT_FOV_COUNT, FOV_COUNT, 0);
  }
  void add_FOV_COUNT_UCTS(int32_t FOV_COUNT_UCTS) {
    fbb_.AddElement<int32_t>(EOO::VT_FOV_COUNT_UCTS, FOV_COUNT_UCTS, 0);
  }
  void add_EXP_DURATION(float EXP_DURATION) {
    fbb_.AddElement<float>(EOO::VT_EXP_DURATION, EXP_DURATION, 0.0f);
  }
  void add_ZEROPTD(float ZEROPTD) {
    fbb_.AddElement<float>(EOO::VT_ZEROPTD, ZEROPTD, 0.0f);
  }
  void add_NET_OBJ_SIG(float NET_OBJ_SIG) {
    fbb_.AddElement<float>(EOO::VT_NET_OBJ_SIG, NET_OBJ_SIG, 0.0f);
  }
  void add_NET_OBJ_SIG_UNC(float NET_OBJ_SIG_UNC) {
    fbb_.AddElement<float>(EOO::VT_NET_OBJ_SIG_UNC, NET_OBJ_SIG_UNC, 0.0f);
  }
  void add_MAG(float MAG) {
    fbb_.AddElement<float>(EOO::VT_MAG, MAG, 0.0f);
  }
  void add_MAG_UNC(float MAG_UNC) {
    fbb_.AddElement<float>(EOO::VT_MAG_UNC, MAG_UNC, 0.0f);
  }
  void add_MAG_NORM_RANGE(float MAG_NORM_RANGE) {
    fbb_.AddElement<float>(EOO::VT_MAG_NORM_RANGE, MAG_NORM_RANGE, 0.0f);
  }
  void add_GEOLAT(float GEOLAT) {
    fbb_.AddElement<float>(EOO::VT_GEOLAT, GEOLAT, 0.0f);
  }
  void add_GEOLON(float GEOLON) {
    fbb_.AddElement<float>(EOO::VT_GEOLON, GEOLON, 0.0f);
  }
  void add_GEOALT(float GEOALT) {
    fbb_.AddElement<float>(EOO::VT_GEOALT, GEOALT, 0.0f);
  }
  void add_GEORANGE(float GEORANGE) {
    fbb_.AddElement<float>(EOO::VT_GEORANGE, GEORANGE, 0.0f);
  }
  void add_SKY_BKGRND(float SKY_BKGRND) {
    fbb_.AddElement<float>(EOO::VT_SKY_BKGRND, SKY_BKGRND, 0.0f);
  }
  void add_PRIMARY_EXTINCTION(float PRIMARY_EXTINCTION) {
    fbb_.AddElement<float>(EOO::VT_PRIMARY_EXTINCTION, PRIMARY_EXTINCTION, 0.0f);
  }
  void add_PRIMARY_EXTINCTION_UNC(float PRIMARY_EXTINCTION_UNC) {
    fbb_.AddElement<float>(EOO::VT_PRIMARY_EXTINCTION_UNC, PRIMARY_EXTINCTION_UNC, 0.0f);
  }
  void add_SOLAR_PHASE_ANGLE(float SOLAR_PHASE_ANGLE) {
    fbb_.AddElement<float>(EOO::VT_SOLAR_PHASE_ANGLE, SOLAR_PHASE_ANGLE, 0.0f);
  }
  void add_SOLAR_EQ_PHASE_ANGLE(float SOLAR_EQ_PHASE_ANGLE) {
    fbb_.AddElement<float>(EOO::VT_SOLAR_EQ_PHASE_ANGLE, SOLAR_EQ_PHASE_ANGLE, 0.0f);
  }
  void add_SOLAR_DEC_ANGLE(float SOLAR_DEC_ANGLE) {
    fbb_.AddElement<float>(EOO::VT_SOLAR_DEC_ANGLE, SOLAR_DEC_ANGLE, 0.0f);
  }
  void add_SHUTTER_DELAY(float SHUTTER_DELAY) {
    fbb_.AddElement<float>(EOO::VT_SHUTTER_DELAY, SHUTTER_DELAY, 0.0f);
  }
  void add_TIMING_BIAS(float TIMING_BIAS) {
    fbb_.AddElement<float>(EOO::VT_TIMING_BIAS, TIMING_BIAS, 0.0f);
  }
  void add_RAW_FILE_URI(::flatbuffers::Offset<::flatbuffers::String> RAW_FILE_URI) {
    fbb_.AddOffset(EOO::VT_RAW_FILE_URI, RAW_FILE_URI);
  }
  void add_INTENSITY(float INTENSITY) {
    fbb_.AddElement<float>(EOO::VT_INTENSITY, INTENSITY, 0.0f);
  }
  void add_BG_INTENSITY(float BG_INTENSITY) {
    fbb_.AddElement<float>(EOO::VT_BG_INTENSITY, BG_INTENSITY, 0.0f);
  }
  void add_DESCRIPTOR(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTOR) {
    fbb_.AddOffset(EOO::VT_DESCRIPTOR, DESCRIPTOR);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(EOO::VT_SOURCE, SOURCE);
  }
  void add_ORIGIN(::flatbuffers::Offset<::flatbuffers::String> ORIGIN) {
    fbb_.AddOffset(EOO::VT_ORIGIN, ORIGIN);
  }
  void add_DATA_MODE(DataMode DATA_MODE) {
    fbb_.AddElement<int8_t>(EOO::VT_DATA_MODE, static_cast<int8_t>(DATA_MODE), 0);
  }
  void add_CREATED_AT(::flatbuffers::Offset<::flatbuffers::String> CREATED_AT) {
    fbb_.AddOffset(EOO::VT_CREATED_AT, CREATED_AT);
  }
  void add_CREATED_BY(::flatbuffers::Offset<::flatbuffers::String> CREATED_BY) {
    fbb_.AddOffset(EOO::VT_CREATED_BY, CREATED_BY);
  }
  void add_REFERENCE_FRAME(refFrame REFERENCE_FRAME) {
    fbb_.AddElement<int8_t>(EOO::VT_REFERENCE_FRAME, static_cast<int8_t>(REFERENCE_FRAME), 0);
  }
  void add_SEN_REFERENCE_FRAME(::flatbuffers::Offset<::flatbuffers::String> SEN_REFERENCE_FRAME) {
    fbb_.AddOffset(EOO::VT_SEN_REFERENCE_FRAME, SEN_REFERENCE_FRAME);
  }
  void add_UMBRA(bool UMBRA) {
    fbb_.AddElement<uint8_t>(EOO::VT_UMBRA, static_cast<uint8_t>(UMBRA), 0);
  }
  void add_PENUMBRA(bool PENUMBRA) {
    fbb_.AddElement<uint8_t>(EOO::VT_PENUMBRA, static_cast<uint8_t>(PENUMBRA), 0);
  }
  void add_ORIG_NETWORK(::flatbuffers::Offset<::flatbuffers::String> ORIG_NETWORK) {
    fbb_.AddOffset(EOO::VT_ORIG_NETWORK, ORIG_NETWORK);
  }
  void add_SOURCE_DL(::flatbuffers::Offset<::flatbuffers::String> SOURCE_DL) {
    fbb_.AddOffset(EOO::VT_SOURCE_DL, SOURCE_DL);
  }
  void add_TYPE(DeviceType TYPE) {
    fbb_.AddElement<int8_t>(EOO::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_AZIMUTH_MEASURED(bool AZIMUTH_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_AZIMUTH_MEASURED, static_cast<uint8_t>(AZIMUTH_MEASURED), 0);
  }
  void add_ELEVATION_MEASURED(bool ELEVATION_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_ELEVATION_MEASURED, static_cast<uint8_t>(ELEVATION_MEASURED), 0);
  }
  void add_RANGE_MEASURED(bool RANGE_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_RANGE_MEASURED, static_cast<uint8_t>(RANGE_MEASURED), 0);
  }
  void add_RANGERATE_MEASURED(bool RANGERATE_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_RANGERATE_MEASURED, static_cast<uint8_t>(RANGERATE_MEASURED), 0);
  }
  void add_RA_MEASURED(bool RA_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_RA_MEASURED, static_cast<uint8_t>(RA_MEASURED), 0);
  }
  void add_DECLINATION_MEASURED(bool DECLINATION_MEASURED) {
    fbb_.AddElement<uint8_t>(EOO::VT_DECLINATION_MEASURED, static_cast<uint8_t>(DECLINATION_MEASURED), 0);
  }
  explicit EOOBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOO>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOO> CreateEOO(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OB_TIME = 0,
    float CORR_QUALITY = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SENSOR_ID = 0,
    CollectMethod COLLECT_METHOD = CollectMethod_SIDEREAL,
    int32_t NORAD_CAT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TASK_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRANSACTION_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRACK_ID = 0,
    ObservationPosition OB_POSITION = ObservationPosition_FENCE,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID = 0,
    bool UCT = false,
    float AZIMUTH = 0.0f,
    float AZIMUTH_UNC = 0.0f,
    float AZIMUTH_BIAS = 0.0f,
    float AZIMUTH_RATE = 0.0f,
    float ELEVATION = 0.0f,
    float ELEVATION_UNC = 0.0f,
    float ELEVATION_BIAS = 0.0f,
    float ELEVATION_RATE = 0.0f,
    float RANGE = 0.0f,
    float RANGE_UNC = 0.0f,
    float RANGE_BIAS = 0.0f,
    float RANGE_RATE = 0.0f,
    float RANGE_RATE_UNC = 0.0f,
    float RA = 0.0f,
    float RA_RATE = 0.0f,
    float RA_UNC = 0.0f,
    float RA_BIAS = 0.0f,
    float DECLINATION = 0.0f,
    float DECLINATION_RATE = 0.0f,
    float DECLINATION_UNC = 0.0f,
    float DECLINATION_BIAS = 0.0f,
    float LOSX = 0.0f,
    float LOSY = 0.0f,
    float LOSZ = 0.0f,
    float LOS_UNC = 0.0f,
    float LOSXVEL = 0.0f,
    float LOSYVEL = 0.0f,
    float LOSZVEL = 0.0f,
    float SENLAT = 0.0f,
    float SENLON = 0.0f,
    float SENALT = 0.0f,
    float SENX = 0.0f,
    float SENY = 0.0f,
    float SENZ = 0.0f,
    int32_t FOV_COUNT = 0,
    int32_t FOV_COUNT_UCTS = 0,
    float EXP_DURATION = 0.0f,
    float ZEROPTD = 0.0f,
    float NET_OBJ_SIG = 0.0f,
    float NET_OBJ_SIG_UNC = 0.0f,
    float MAG = 0.0f,
    float MAG_UNC = 0.0f,
    float MAG_NORM_RANGE = 0.0f,
    float GEOLAT = 0.0f,
    float GEOLON = 0.0f,
    float GEOALT = 0.0f,
    float GEORANGE = 0.0f,
    float SKY_BKGRND = 0.0f,
    float PRIMARY_EXTINCTION = 0.0f,
    float PRIMARY_EXTINCTION_UNC = 0.0f,
    float SOLAR_PHASE_ANGLE = 0.0f,
    float SOLAR_EQ_PHASE_ANGLE = 0.0f,
    float SOLAR_DEC_ANGLE = 0.0f,
    float SHUTTER_DELAY = 0.0f,
    float TIMING_BIAS = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> RAW_FILE_URI = 0,
    float INTENSITY = 0.0f,
    float BG_INTENSITY = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGIN = 0,
    DataMode DATA_MODE = DataMode_EXERCISE,
    ::flatbuffers::Offset<::flatbuffers::String> CREATED_AT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATED_BY = 0,
    refFrame REFERENCE_FRAME = refFrame_ECEF,
    ::flatbuffers::Offset<::flatbuffers::String> SEN_REFERENCE_FRAME = 0,
    bool UMBRA = false,
    bool PENUMBRA = false,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_NETWORK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE_DL = 0,
    DeviceType TYPE = DeviceType_UNKNOWN,
    bool AZIMUTH_MEASURED = false,
    bool ELEVATION_MEASURED = false,
    bool RANGE_MEASURED = false,
    bool RANGERATE_MEASURED = false,
    bool RA_MEASURED = false,
    bool DECLINATION_MEASURED = false) {
  EOOBuilder builder_(_fbb);
  builder_.add_SOURCE_DL(SOURCE_DL);
  builder_.add_ORIG_NETWORK(ORIG_NETWORK);
  builder_.add_SEN_REFERENCE_FRAME(SEN_REFERENCE_FRAME);
  builder_.add_CREATED_BY(CREATED_BY);
  builder_.add_CREATED_AT(CREATED_AT);
  builder_.add_ORIGIN(ORIGIN);
  builder_.add_SOURCE(SOURCE);
  builder_.add_DESCRIPTOR(DESCRIPTOR);
  builder_.add_BG_INTENSITY(BG_INTENSITY);
  builder_.add_INTENSITY(INTENSITY);
  builder_.add_RAW_FILE_URI(RAW_FILE_URI);
  builder_.add_TIMING_BIAS(TIMING_BIAS);
  builder_.add_SHUTTER_DELAY(SHUTTER_DELAY);
  builder_.add_SOLAR_DEC_ANGLE(SOLAR_DEC_ANGLE);
  builder_.add_SOLAR_EQ_PHASE_ANGLE(SOLAR_EQ_PHASE_ANGLE);
  builder_.add_SOLAR_PHASE_ANGLE(SOLAR_PHASE_ANGLE);
  builder_.add_PRIMARY_EXTINCTION_UNC(PRIMARY_EXTINCTION_UNC);
  builder_.add_PRIMARY_EXTINCTION(PRIMARY_EXTINCTION);
  builder_.add_SKY_BKGRND(SKY_BKGRND);
  builder_.add_GEORANGE(GEORANGE);
  builder_.add_GEOALT(GEOALT);
  builder_.add_GEOLON(GEOLON);
  builder_.add_GEOLAT(GEOLAT);
  builder_.add_MAG_NORM_RANGE(MAG_NORM_RANGE);
  builder_.add_MAG_UNC(MAG_UNC);
  builder_.add_MAG(MAG);
  builder_.add_NET_OBJ_SIG_UNC(NET_OBJ_SIG_UNC);
  builder_.add_NET_OBJ_SIG(NET_OBJ_SIG);
  builder_.add_ZEROPTD(ZEROPTD);
  builder_.add_EXP_DURATION(EXP_DURATION);
  builder_.add_FOV_COUNT_UCTS(FOV_COUNT_UCTS);
  builder_.add_FOV_COUNT(FOV_COUNT);
  builder_.add_SENZ(SENZ);
  builder_.add_SENY(SENY);
  builder_.add_SENX(SENX);
  builder_.add_SENALT(SENALT);
  builder_.add_SENLON(SENLON);
  builder_.add_SENLAT(SENLAT);
  builder_.add_LOSZVEL(LOSZVEL);
  builder_.add_LOSYVEL(LOSYVEL);
  builder_.add_LOSXVEL(LOSXVEL);
  builder_.add_LOS_UNC(LOS_UNC);
  builder_.add_LOSZ(LOSZ);
  builder_.add_LOSY(LOSY);
  builder_.add_LOSX(LOSX);
  builder_.add_DECLINATION_BIAS(DECLINATION_BIAS);
  builder_.add_DECLINATION_UNC(DECLINATION_UNC);
  builder_.add_DECLINATION_RATE(DECLINATION_RATE);
  builder_.add_DECLINATION(DECLINATION);
  builder_.add_RA_BIAS(RA_BIAS);
  builder_.add_RA_UNC(RA_UNC);
  builder_.add_RA_RATE(RA_RATE);
  builder_.add_RA(RA);
  builder_.add_RANGE_RATE_UNC(RANGE_RATE_UNC);
  builder_.add_RANGE_RATE(RANGE_RATE);
  builder_.add_RANGE_BIAS(RANGE_BIAS);
  builder_.add_RANGE_UNC(RANGE_UNC);
  builder_.add_RANGE(RANGE);
  builder_.add_ELEVATION_RATE(ELEVATION_RATE);
  builder_.add_ELEVATION_BIAS(ELEVATION_BIAS);
  builder_.add_ELEVATION_UNC(ELEVATION_UNC);
  builder_.add_ELEVATION(ELEVATION);
  builder_.add_AZIMUTH_RATE(AZIMUTH_RATE);
  builder_.add_AZIMUTH_BIAS(AZIMUTH_BIAS);
  builder_.add_AZIMUTH_UNC(AZIMUTH_UNC);
  builder_.add_AZIMUTH(AZIMUTH);
  builder_.add_ORIG_SENSOR_ID(ORIG_SENSOR_ID);
  builder_.add_ORIG_OBJECT_ID(ORIG_OBJECT_ID);
  builder_.add_TRACK_ID(TRACK_ID);
  builder_.add_TRANSACTION_ID(TRANSACTION_ID);
  builder_.add_TASK_ID(TASK_ID);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_SENSOR_ID(SENSOR_ID);
  builder_.add_ID_ON_ORBIT(ID_ON_ORBIT);
  builder_.add_CORR_QUALITY(CORR_QUALITY);
  builder_.add_OB_TIME(OB_TIME);
  builder_.add_CLASSIFICATION(CLASSIFICATION);
  builder_.add_ID(ID);
  builder_.add_DECLINATION_MEASURED(DECLINATION_MEASURED);
  builder_.add_RA_MEASURED(RA_MEASURED);
  builder_.add_RANGERATE_MEASURED(RANGERATE_MEASURED);
  builder_.add_RANGE_MEASURED(RANGE_MEASURED);
  builder_.add_ELEVATION_MEASURED(ELEVATION_MEASURED);
  builder_.add_AZIMUTH_MEASURED(AZIMUTH_MEASURED);
  builder_.add_TYPE(TYPE);
  builder_.add_PENUMBRA(PENUMBRA);
  builder_.add_UMBRA(UMBRA);
  builder_.add_REFERENCE_FRAME(REFERENCE_FRAME);
  builder_.add_DATA_MODE(DATA_MODE);
  builder_.add_UCT(UCT);
  builder_.add_OB_POSITION(OB_POSITION);
  builder_.add_COLLECT_METHOD(COLLECT_METHOD);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOO> CreateEOODirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *CLASSIFICATION = nullptr,
    const char *OB_TIME = nullptr,
    float CORR_QUALITY = 0.0f,
    const char *ID_ON_ORBIT = nullptr,
    const char *SENSOR_ID = nullptr,
    CollectMethod COLLECT_METHOD = CollectMethod_SIDEREAL,
    int32_t NORAD_CAT_ID = 0,
    const char *TASK_ID = nullptr,
    const char *TRANSACTION_ID = nullptr,
    const char *TRACK_ID = nullptr,
    ObservationPosition OB_POSITION = ObservationPosition_FENCE,
    const char *ORIG_OBJECT_ID = nullptr,
    const char *ORIG_SENSOR_ID = nullptr,
    bool UCT = false,
    float AZIMUTH = 0.0f,
    float AZIMUTH_UNC = 0.0f,
    float AZIMUTH_BIAS = 0.0f,
    float AZIMUTH_RATE = 0.0f,
    float ELEVATION = 0.0f,
    float ELEVATION_UNC = 0.0f,
    float ELEVATION_BIAS = 0.0f,
    float ELEVATION_RATE = 0.0f,
    float RANGE = 0.0f,
    float RANGE_UNC = 0.0f,
    float RANGE_BIAS = 0.0f,
    float RANGE_RATE = 0.0f,
    float RANGE_RATE_UNC = 0.0f,
    float RA = 0.0f,
    float RA_RATE = 0.0f,
    float RA_UNC = 0.0f,
    float RA_BIAS = 0.0f,
    float DECLINATION = 0.0f,
    float DECLINATION_RATE = 0.0f,
    float DECLINATION_UNC = 0.0f,
    float DECLINATION_BIAS = 0.0f,
    float LOSX = 0.0f,
    float LOSY = 0.0f,
    float LOSZ = 0.0f,
    float LOS_UNC = 0.0f,
    float LOSXVEL = 0.0f,
    float LOSYVEL = 0.0f,
    float LOSZVEL = 0.0f,
    float SENLAT = 0.0f,
    float SENLON = 0.0f,
    float SENALT = 0.0f,
    float SENX = 0.0f,
    float SENY = 0.0f,
    float SENZ = 0.0f,
    int32_t FOV_COUNT = 0,
    int32_t FOV_COUNT_UCTS = 0,
    float EXP_DURATION = 0.0f,
    float ZEROPTD = 0.0f,
    float NET_OBJ_SIG = 0.0f,
    float NET_OBJ_SIG_UNC = 0.0f,
    float MAG = 0.0f,
    float MAG_UNC = 0.0f,
    float MAG_NORM_RANGE = 0.0f,
    float GEOLAT = 0.0f,
    float GEOLON = 0.0f,
    float GEOALT = 0.0f,
    float GEORANGE = 0.0f,
    float SKY_BKGRND = 0.0f,
    float PRIMARY_EXTINCTION = 0.0f,
    float PRIMARY_EXTINCTION_UNC = 0.0f,
    float SOLAR_PHASE_ANGLE = 0.0f,
    float SOLAR_EQ_PHASE_ANGLE = 0.0f,
    float SOLAR_DEC_ANGLE = 0.0f,
    float SHUTTER_DELAY = 0.0f,
    float TIMING_BIAS = 0.0f,
    const char *RAW_FILE_URI = nullptr,
    float INTENSITY = 0.0f,
    float BG_INTENSITY = 0.0f,
    const char *DESCRIPTOR = nullptr,
    const char *SOURCE = nullptr,
    const char *ORIGIN = nullptr,
    DataMode DATA_MODE = DataMode_EXERCISE,
    const char *CREATED_AT = nullptr,
    const char *CREATED_BY = nullptr,
    refFrame REFERENCE_FRAME = refFrame_ECEF,
    const char *SEN_REFERENCE_FRAME = nullptr,
    bool UMBRA = false,
    bool PENUMBRA = false,
    const char *ORIG_NETWORK = nullptr,
    const char *SOURCE_DL = nullptr,
    DeviceType TYPE = DeviceType_UNKNOWN,
    bool AZIMUTH_MEASURED = false,
    bool ELEVATION_MEASURED = false,
    bool RANGE_MEASURED = false,
    bool RANGERATE_MEASURED = false,
    bool RA_MEASURED = false,
    bool DECLINATION_MEASURED = false) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto CLASSIFICATION__ = CLASSIFICATION ? _fbb.CreateString(CLASSIFICATION) : 0;
  auto OB_TIME__ = OB_TIME ? _fbb.CreateString(OB_TIME) : 0;
  auto ID_ON_ORBIT__ = ID_ON_ORBIT ? _fbb.CreateString(ID_ON_ORBIT) : 0;
  auto SENSOR_ID__ = SENSOR_ID ? _fbb.CreateString(SENSOR_ID) : 0;
  auto TASK_ID__ = TASK_ID ? _fbb.CreateString(TASK_ID) : 0;
  auto TRANSACTION_ID__ = TRANSACTION_ID ? _fbb.CreateString(TRANSACTION_ID) : 0;
  auto TRACK_ID__ = TRACK_ID ? _fbb.CreateString(TRACK_ID) : 0;
  auto ORIG_OBJECT_ID__ = ORIG_OBJECT_ID ? _fbb.CreateString(ORIG_OBJECT_ID) : 0;
  auto ORIG_SENSOR_ID__ = ORIG_SENSOR_ID ? _fbb.CreateString(ORIG_SENSOR_ID) : 0;
  auto RAW_FILE_URI__ = RAW_FILE_URI ? _fbb.CreateString(RAW_FILE_URI) : 0;
  auto DESCRIPTOR__ = DESCRIPTOR ? _fbb.CreateString(DESCRIPTOR) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto ORIGIN__ = ORIGIN ? _fbb.CreateString(ORIGIN) : 0;
  auto CREATED_AT__ = CREATED_AT ? _fbb.CreateString(CREATED_AT) : 0;
  auto CREATED_BY__ = CREATED_BY ? _fbb.CreateString(CREATED_BY) : 0;
  auto SEN_REFERENCE_FRAME__ = SEN_REFERENCE_FRAME ? _fbb.CreateString(SEN_REFERENCE_FRAME) : 0;
  auto ORIG_NETWORK__ = ORIG_NETWORK ? _fbb.CreateString(ORIG_NETWORK) : 0;
  auto SOURCE_DL__ = SOURCE_DL ? _fbb.CreateString(SOURCE_DL) : 0;
  return CreateEOO(
      _fbb,
      ID__,
      CLASSIFICATION__,
      OB_TIME__,
      CORR_QUALITY,
      ID_ON_ORBIT__,
      SENSOR_ID__,
      COLLECT_METHOD,
      NORAD_CAT_ID,
      TASK_ID__,
      TRANSACTION_ID__,
      TRACK_ID__,
      OB_POSITION,
      ORIG_OBJECT_ID__,
      ORIG_SENSOR_ID__,
      UCT,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_BIAS,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_BIAS,
      ELEVATION_RATE,
      RANGE,
      RANGE_UNC,
      RANGE_BIAS,
      RANGE_RATE,
      RANGE_RATE_UNC,
      RA,
      RA_RATE,
      RA_UNC,
      RA_BIAS,
      DECLINATION,
      DECLINATION_RATE,
      DECLINATION_UNC,
      DECLINATION_BIAS,
      LOSX,
      LOSY,
      LOSZ,
      LOS_UNC,
      LOSXVEL,
      LOSYVEL,
      LOSZVEL,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      FOV_COUNT,
      FOV_COUNT_UCTS,
      EXP_DURATION,
      ZEROPTD,
      NET_OBJ_SIG,
      NET_OBJ_SIG_UNC,
      MAG,
      MAG_UNC,
      MAG_NORM_RANGE,
      GEOLAT,
      GEOLON,
      GEOALT,
      GEORANGE,
      SKY_BKGRND,
      PRIMARY_EXTINCTION,
      PRIMARY_EXTINCTION_UNC,
      SOLAR_PHASE_ANGLE,
      SOLAR_EQ_PHASE_ANGLE,
      SOLAR_DEC_ANGLE,
      SHUTTER_DELAY,
      TIMING_BIAS,
      RAW_FILE_URI__,
      INTENSITY,
      BG_INTENSITY,
      DESCRIPTOR__,
      SOURCE__,
      ORIGIN__,
      DATA_MODE,
      CREATED_AT__,
      CREATED_BY__,
      REFERENCE_FRAME,
      SEN_REFERENCE_FRAME__,
      UMBRA,
      PENUMBRA,
      ORIG_NETWORK__,
      SOURCE_DL__,
      TYPE,
      AZIMUTH_MEASURED,
      ELEVATION_MEASURED,
      RANGE_MEASURED,
      RANGERATE_MEASURED,
      RA_MEASURED,
      DECLINATION_MEASURED);
}

struct EOOCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOOCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<EOO>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EOO>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct EOOCOLLECTIONBuilder {
  typedef EOOCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EOO>>> RECORDS) {
    fbb_.AddOffset(EOOCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit EOOCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOOCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOOCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOOCOLLECTION> CreateEOOCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EOO>>> RECORDS = 0) {
  EOOCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOOCOLLECTION> CreateEOOCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EOO>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<EOO>>(*RECORDS) : 0;
  return CreateEOOCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const EOO *GetEOO(const void *buf) {
  return ::flatbuffers::GetRoot<EOO>(buf);
}

inline const EOO *GetSizePrefixedEOO(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EOO>(buf);
}

inline const char *EOOIdentifier() {
  return "$EOO";
}

inline bool EOOBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOOIdentifier());
}

inline bool SizePrefixedEOOBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOOIdentifier(), true);
}

inline bool VerifyEOOBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EOO>(EOOIdentifier());
}

inline bool VerifySizePrefixedEOOBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EOO>(EOOIdentifier());
}

inline void FinishEOOBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOO> root) {
  fbb.Finish(root, EOOIdentifier());
}

inline void FinishSizePrefixedEOOBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOO> root) {
  fbb.FinishSizePrefixed(root, EOOIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
