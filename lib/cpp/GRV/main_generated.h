// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct GRV;
struct GRVBuilder;

enum GravityModelType : int8_t {
  GravityModelType_POINT_MASS = 0,
  GravityModelType_J2_ONLY = 1,
  GravityModelType_J2_J4 = 2,
  GravityModelType_J2_J6 = 3,
  GravityModelType_SPHERICAL_HARMONICS = 4,
  GravityModelType_CUSTOM = 5,
  GravityModelType_MIN = GravityModelType_POINT_MASS,
  GravityModelType_MAX = GravityModelType_CUSTOM
};

inline const GravityModelType (&EnumValuesGravityModelType())[6] {
  static const GravityModelType values[] = {
    GravityModelType_POINT_MASS,
    GravityModelType_J2_ONLY,
    GravityModelType_J2_J4,
    GravityModelType_J2_J6,
    GravityModelType_SPHERICAL_HARMONICS,
    GravityModelType_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesGravityModelType() {
  static const char * const names[7] = {
    "POINT_MASS",
    "J2_ONLY",
    "J2_J4",
    "J2_J6",
    "SPHERICAL_HARMONICS",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameGravityModelType(GravityModelType e) {
  if (::flatbuffers::IsOutRange(e, GravityModelType_POINT_MASS, GravityModelType_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGravityModelType()[index];
}

enum GravityModelName : int8_t {
  GravityModelName_WGS84 = 0,
  GravityModelName_EGM96 = 1,
  GravityModelName_EGM2008 = 2,
  GravityModelName_GGM05C = 3,
  GravityModelName_JGM3 = 4,
  GravityModelName_EIGEN_6C4 = 5,
  GravityModelName_GOCO06S = 6,
  GravityModelName_XGM2019E = 7,
  GravityModelName_CUSTOM_MODEL = 8,
  GravityModelName_MIN = GravityModelName_WGS84,
  GravityModelName_MAX = GravityModelName_CUSTOM_MODEL
};

inline const GravityModelName (&EnumValuesGravityModelName())[9] {
  static const GravityModelName values[] = {
    GravityModelName_WGS84,
    GravityModelName_EGM96,
    GravityModelName_EGM2008,
    GravityModelName_GGM05C,
    GravityModelName_JGM3,
    GravityModelName_EIGEN_6C4,
    GravityModelName_GOCO06S,
    GravityModelName_XGM2019E,
    GravityModelName_CUSTOM_MODEL
  };
  return values;
}

inline const char * const *EnumNamesGravityModelName() {
  static const char * const names[10] = {
    "WGS84",
    "EGM96",
    "EGM2008",
    "GGM05C",
    "JGM3",
    "EIGEN_6C4",
    "GOCO06S",
    "XGM2019E",
    "CUSTOM_MODEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameGravityModelName(GravityModelName e) {
  if (::flatbuffers::IsOutRange(e, GravityModelName_WGS84, GravityModelName_CUSTOM_MODEL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGravityModelName()[index];
}

enum CentralBody : int8_t {
  CentralBody_EARTH = 0,
  CentralBody_MOON = 1,
  CentralBody_SUN = 2,
  CentralBody_MARS = 3,
  CentralBody_JUPITER = 4,
  CentralBody_SATURN = 5,
  CentralBody_VENUS = 6,
  CentralBody_MERCURY = 7,
  CentralBody_CUSTOM_BODY = 8,
  CentralBody_MIN = CentralBody_EARTH,
  CentralBody_MAX = CentralBody_CUSTOM_BODY
};

inline const CentralBody (&EnumValuesCentralBody())[9] {
  static const CentralBody values[] = {
    CentralBody_EARTH,
    CentralBody_MOON,
    CentralBody_SUN,
    CentralBody_MARS,
    CentralBody_JUPITER,
    CentralBody_SATURN,
    CentralBody_VENUS,
    CentralBody_MERCURY,
    CentralBody_CUSTOM_BODY
  };
  return values;
}

inline const char * const *EnumNamesCentralBody() {
  static const char * const names[10] = {
    "EARTH",
    "MOON",
    "SUN",
    "MARS",
    "JUPITER",
    "SATURN",
    "VENUS",
    "MERCURY",
    "CUSTOM_BODY",
    nullptr
  };
  return names;
}

inline const char *EnumNameCentralBody(CentralBody e) {
  if (::flatbuffers::IsOutRange(e, CentralBody_EARTH, CentralBody_CUSTOM_BODY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCentralBody()[index];
}

/// Gravity Models
struct GRV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GRVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODEL_TYPE = 4,
    VT_MODEL_NAME = 6,
    VT_CENTRAL_BODY = 8,
    VT_MAX_DEGREE = 10,
    VT_MAX_ORDER = 12,
    VT_INCLUDE_SUN = 14,
    VT_INCLUDE_MOON = 16,
    VT_INCLUDE_PLANETS = 18,
    VT_SOLID_TIDES = 20,
    VT_OCEAN_TIDES = 22,
    VT_POLE_TIDES = 24
  };
  GravityModelType MODEL_TYPE() const {
    return static_cast<GravityModelType>(GetField<int8_t>(VT_MODEL_TYPE, 2));
  }
  GravityModelName MODEL_NAME() const {
    return static_cast<GravityModelName>(GetField<int8_t>(VT_MODEL_NAME, 2));
  }
  CentralBody CENTRAL_BODY() const {
    return static_cast<CentralBody>(GetField<int8_t>(VT_CENTRAL_BODY, 0));
  }
  uint16_t MAX_DEGREE() const {
    return GetField<uint16_t>(VT_MAX_DEGREE, 70);
  }
  uint16_t MAX_ORDER() const {
    return GetField<uint16_t>(VT_MAX_ORDER, 70);
  }
  bool INCLUDE_SUN() const {
    return GetField<uint8_t>(VT_INCLUDE_SUN, 1) != 0;
  }
  bool INCLUDE_MOON() const {
    return GetField<uint8_t>(VT_INCLUDE_MOON, 1) != 0;
  }
  bool INCLUDE_PLANETS() const {
    return GetField<uint8_t>(VT_INCLUDE_PLANETS, 0) != 0;
  }
  bool SOLID_TIDES() const {
    return GetField<uint8_t>(VT_SOLID_TIDES, 0) != 0;
  }
  bool OCEAN_TIDES() const {
    return GetField<uint8_t>(VT_OCEAN_TIDES, 0) != 0;
  }
  bool POLE_TIDES() const {
    return GetField<uint8_t>(VT_POLE_TIDES, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODEL_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_MODEL_NAME, 1) &&
           VerifyField<int8_t>(verifier, VT_CENTRAL_BODY, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_DEGREE, 2) &&
           VerifyField<uint16_t>(verifier, VT_MAX_ORDER, 2) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_SUN, 1) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_MOON, 1) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_PLANETS, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLID_TIDES, 1) &&
           VerifyField<uint8_t>(verifier, VT_OCEAN_TIDES, 1) &&
           VerifyField<uint8_t>(verifier, VT_POLE_TIDES, 1) &&
           verifier.EndTable();
  }
};

struct GRVBuilder {
  typedef GRV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MODEL_TYPE(GravityModelType MODEL_TYPE) {
    fbb_.AddElement<int8_t>(GRV::VT_MODEL_TYPE, static_cast<int8_t>(MODEL_TYPE), 2);
  }
  void add_MODEL_NAME(GravityModelName MODEL_NAME) {
    fbb_.AddElement<int8_t>(GRV::VT_MODEL_NAME, static_cast<int8_t>(MODEL_NAME), 2);
  }
  void add_CENTRAL_BODY(CentralBody CENTRAL_BODY) {
    fbb_.AddElement<int8_t>(GRV::VT_CENTRAL_BODY, static_cast<int8_t>(CENTRAL_BODY), 0);
  }
  void add_MAX_DEGREE(uint16_t MAX_DEGREE) {
    fbb_.AddElement<uint16_t>(GRV::VT_MAX_DEGREE, MAX_DEGREE, 70);
  }
  void add_MAX_ORDER(uint16_t MAX_ORDER) {
    fbb_.AddElement<uint16_t>(GRV::VT_MAX_ORDER, MAX_ORDER, 70);
  }
  void add_INCLUDE_SUN(bool INCLUDE_SUN) {
    fbb_.AddElement<uint8_t>(GRV::VT_INCLUDE_SUN, static_cast<uint8_t>(INCLUDE_SUN), 1);
  }
  void add_INCLUDE_MOON(bool INCLUDE_MOON) {
    fbb_.AddElement<uint8_t>(GRV::VT_INCLUDE_MOON, static_cast<uint8_t>(INCLUDE_MOON), 1);
  }
  void add_INCLUDE_PLANETS(bool INCLUDE_PLANETS) {
    fbb_.AddElement<uint8_t>(GRV::VT_INCLUDE_PLANETS, static_cast<uint8_t>(INCLUDE_PLANETS), 0);
  }
  void add_SOLID_TIDES(bool SOLID_TIDES) {
    fbb_.AddElement<uint8_t>(GRV::VT_SOLID_TIDES, static_cast<uint8_t>(SOLID_TIDES), 0);
  }
  void add_OCEAN_TIDES(bool OCEAN_TIDES) {
    fbb_.AddElement<uint8_t>(GRV::VT_OCEAN_TIDES, static_cast<uint8_t>(OCEAN_TIDES), 0);
  }
  void add_POLE_TIDES(bool POLE_TIDES) {
    fbb_.AddElement<uint8_t>(GRV::VT_POLE_TIDES, static_cast<uint8_t>(POLE_TIDES), 0);
  }
  explicit GRVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GRV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GRV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GRV> CreateGRV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GravityModelType MODEL_TYPE = GravityModelType_J2_J4,
    GravityModelName MODEL_NAME = GravityModelName_EGM2008,
    CentralBody CENTRAL_BODY = CentralBody_EARTH,
    uint16_t MAX_DEGREE = 70,
    uint16_t MAX_ORDER = 70,
    bool INCLUDE_SUN = true,
    bool INCLUDE_MOON = true,
    bool INCLUDE_PLANETS = false,
    bool SOLID_TIDES = false,
    bool OCEAN_TIDES = false,
    bool POLE_TIDES = false) {
  GRVBuilder builder_(_fbb);
  builder_.add_MAX_ORDER(MAX_ORDER);
  builder_.add_MAX_DEGREE(MAX_DEGREE);
  builder_.add_POLE_TIDES(POLE_TIDES);
  builder_.add_OCEAN_TIDES(OCEAN_TIDES);
  builder_.add_SOLID_TIDES(SOLID_TIDES);
  builder_.add_INCLUDE_PLANETS(INCLUDE_PLANETS);
  builder_.add_INCLUDE_MOON(INCLUDE_MOON);
  builder_.add_INCLUDE_SUN(INCLUDE_SUN);
  builder_.add_CENTRAL_BODY(CENTRAL_BODY);
  builder_.add_MODEL_NAME(MODEL_NAME);
  builder_.add_MODEL_TYPE(MODEL_TYPE);
  return builder_.Finish();
}

inline const GRV *GetGRV(const void *buf) {
  return ::flatbuffers::GetRoot<GRV>(buf);
}

inline const GRV *GetSizePrefixedGRV(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GRV>(buf);
}

inline const char *GRVIdentifier() {
  return "$GRV";
}

inline bool GRVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GRVIdentifier());
}

inline bool SizePrefixedGRVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GRVIdentifier(), true);
}

inline bool VerifyGRVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GRV>(GRVIdentifier());
}

inline bool VerifySizePrefixedGRVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GRV>(GRVIdentifier());
}

inline void FinishGRVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GRV> root) {
  fbb.Finish(root, GRVIdentifier());
}

inline void FinishSizePrefixedGRVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GRV> root) {
  fbb.FinishSizePrefixed(root, GRVIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
