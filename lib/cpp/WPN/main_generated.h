// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct WPN;
struct WPNBuilder;

enum WeaponType : int8_t {
  WeaponType_MG_SMALL = 0,
  WeaponType_MG_HEAVY = 1,
  WeaponType_AUTOCANNON = 2,
  WeaponType_CANNON = 3,
  WeaponType_TANK_GUN = 4,
  WeaponType_ARTILLERY = 5,
  WeaponType_MORTAR = 6,
  WeaponType_ROCKET_UNGUIDED = 7,
  WeaponType_BOMB_DUMB = 8,
  WeaponType_BOMB_GUIDED = 9,
  WeaponType_TORPEDO = 10,
  WeaponType_DEPTH_CHARGE = 11,
  WeaponType_MINE = 12,
  WeaponType_GRENADE = 13,
  WeaponType_MIN = WeaponType_MG_SMALL,
  WeaponType_MAX = WeaponType_GRENADE
};

inline const WeaponType (&EnumValuesWeaponType())[14] {
  static const WeaponType values[] = {
    WeaponType_MG_SMALL,
    WeaponType_MG_HEAVY,
    WeaponType_AUTOCANNON,
    WeaponType_CANNON,
    WeaponType_TANK_GUN,
    WeaponType_ARTILLERY,
    WeaponType_MORTAR,
    WeaponType_ROCKET_UNGUIDED,
    WeaponType_BOMB_DUMB,
    WeaponType_BOMB_GUIDED,
    WeaponType_TORPEDO,
    WeaponType_DEPTH_CHARGE,
    WeaponType_MINE,
    WeaponType_GRENADE
  };
  return values;
}

inline const char * const *EnumNamesWeaponType() {
  static const char * const names[15] = {
    "MG_SMALL",
    "MG_HEAVY",
    "AUTOCANNON",
    "CANNON",
    "TANK_GUN",
    "ARTILLERY",
    "MORTAR",
    "ROCKET_UNGUIDED",
    "BOMB_DUMB",
    "BOMB_GUIDED",
    "TORPEDO",
    "DEPTH_CHARGE",
    "MINE",
    "GRENADE",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeaponType(WeaponType e) {
  if (::flatbuffers::IsOutRange(e, WeaponType_MG_SMALL, WeaponType_GRENADE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeaponType()[index];
}

enum FuzeType : int8_t {
  FuzeType_CONTACT = 0,
  FuzeType_DELAY = 1,
  FuzeType_TIMED = 2,
  FuzeType_PROXIMITY = 3,
  FuzeType_AIRBURST = 4,
  FuzeType_MAGNETIC = 5,
  FuzeType_PRESSURE = 6,
  FuzeType_SEISMIC = 7,
  FuzeType_MIN = FuzeType_CONTACT,
  FuzeType_MAX = FuzeType_SEISMIC
};

inline const FuzeType (&EnumValuesFuzeType())[8] {
  static const FuzeType values[] = {
    FuzeType_CONTACT,
    FuzeType_DELAY,
    FuzeType_TIMED,
    FuzeType_PROXIMITY,
    FuzeType_AIRBURST,
    FuzeType_MAGNETIC,
    FuzeType_PRESSURE,
    FuzeType_SEISMIC
  };
  return values;
}

inline const char * const *EnumNamesFuzeType() {
  static const char * const names[9] = {
    "CONTACT",
    "DELAY",
    "TIMED",
    "PROXIMITY",
    "AIRBURST",
    "MAGNETIC",
    "PRESSURE",
    "SEISMIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameFuzeType(FuzeType e) {
  if (::flatbuffers::IsOutRange(e, FuzeType_CONTACT, FuzeType_SEISMIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFuzeType()[index];
}

enum ProjectilePhase : int8_t {
  ProjectilePhase_LOADED = 0,
  ProjectilePhase_IN_FLIGHT = 1,
  ProjectilePhase_DETONATED = 2,
  ProjectilePhase_DUD = 3,
  ProjectilePhase_IMPACT = 4,
  ProjectilePhase_MIN = ProjectilePhase_LOADED,
  ProjectilePhase_MAX = ProjectilePhase_IMPACT
};

inline const ProjectilePhase (&EnumValuesProjectilePhase())[5] {
  static const ProjectilePhase values[] = {
    ProjectilePhase_LOADED,
    ProjectilePhase_IN_FLIGHT,
    ProjectilePhase_DETONATED,
    ProjectilePhase_DUD,
    ProjectilePhase_IMPACT
  };
  return values;
}

inline const char * const *EnumNamesProjectilePhase() {
  static const char * const names[6] = {
    "LOADED",
    "IN_FLIGHT",
    "DETONATED",
    "DUD",
    "IMPACT",
    nullptr
  };
  return names;
}

inline const char *EnumNameProjectilePhase(ProjectilePhase e) {
  if (::flatbuffers::IsOutRange(e, ProjectilePhase_LOADED, ProjectilePhase_IMPACT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProjectilePhase()[index];
}

/// Weapons and Munitions
struct WPN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WPNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALIBER = 4,
    VT_MUZZLE_VELOCITY = 6,
    VT_RATE_OF_FIRE = 8,
    VT_DISPERSION = 10,
    VT_AMMO_CAPACITY = 12,
    VT_BURST_LENGTH = 14,
    VT_RELOAD_TIME = 16,
    VT_OVERHEAT_ROUNDS = 18,
    VT_COOLDOWN_RATE = 20,
    VT_ELEVATION_MIN = 22,
    VT_ELEVATION_MAX = 24,
    VT_TRAVERSE_MIN = 26,
    VT_TRAVERSE_MAX = 28,
    VT_SLEW_RATE = 30,
    VT_WEAPON_TYPE = 32,
    VT_FUZE_TYPE = 34,
    VT_RESERVED = 36
  };
  float CALIBER() const {
    return GetField<float>(VT_CALIBER, 0.0f);
  }
  float MUZZLE_VELOCITY() const {
    return GetField<float>(VT_MUZZLE_VELOCITY, 0.0f);
  }
  float RATE_OF_FIRE() const {
    return GetField<float>(VT_RATE_OF_FIRE, 0.0f);
  }
  float DISPERSION() const {
    return GetField<float>(VT_DISPERSION, 0.0f);
  }
  uint16_t AMMO_CAPACITY() const {
    return GetField<uint16_t>(VT_AMMO_CAPACITY, 0);
  }
  uint16_t BURST_LENGTH() const {
    return GetField<uint16_t>(VT_BURST_LENGTH, 0);
  }
  float RELOAD_TIME() const {
    return GetField<float>(VT_RELOAD_TIME, 0.0f);
  }
  uint16_t OVERHEAT_ROUNDS() const {
    return GetField<uint16_t>(VT_OVERHEAT_ROUNDS, 0);
  }
  float COOLDOWN_RATE() const {
    return GetField<float>(VT_COOLDOWN_RATE, 0.0f);
  }
  float ELEVATION_MIN() const {
    return GetField<float>(VT_ELEVATION_MIN, 0.0f);
  }
  float ELEVATION_MAX() const {
    return GetField<float>(VT_ELEVATION_MAX, 0.0f);
  }
  float TRAVERSE_MIN() const {
    return GetField<float>(VT_TRAVERSE_MIN, 0.0f);
  }
  float TRAVERSE_MAX() const {
    return GetField<float>(VT_TRAVERSE_MAX, 0.0f);
  }
  float SLEW_RATE() const {
    return GetField<float>(VT_SLEW_RATE, 0.0f);
  }
  uint8_t WEAPON_TYPE() const {
    return GetField<uint8_t>(VT_WEAPON_TYPE, 0);
  }
  uint8_t FUZE_TYPE() const {
    return GetField<uint8_t>(VT_FUZE_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CALIBER, 4) &&
           VerifyField<float>(verifier, VT_MUZZLE_VELOCITY, 4) &&
           VerifyField<float>(verifier, VT_RATE_OF_FIRE, 4) &&
           VerifyField<float>(verifier, VT_DISPERSION, 4) &&
           VerifyField<uint16_t>(verifier, VT_AMMO_CAPACITY, 2) &&
           VerifyField<uint16_t>(verifier, VT_BURST_LENGTH, 2) &&
           VerifyField<float>(verifier, VT_RELOAD_TIME, 4) &&
           VerifyField<uint16_t>(verifier, VT_OVERHEAT_ROUNDS, 2) &&
           VerifyField<float>(verifier, VT_COOLDOWN_RATE, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_MIN, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_MAX, 4) &&
           VerifyField<float>(verifier, VT_TRAVERSE_MIN, 4) &&
           VerifyField<float>(verifier, VT_TRAVERSE_MAX, 4) &&
           VerifyField<float>(verifier, VT_SLEW_RATE, 4) &&
           VerifyField<uint8_t>(verifier, VT_WEAPON_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FUZE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct WPNBuilder {
  typedef WPN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CALIBER(float CALIBER) {
    fbb_.AddElement<float>(WPN::VT_CALIBER, CALIBER, 0.0f);
  }
  void add_MUZZLE_VELOCITY(float MUZZLE_VELOCITY) {
    fbb_.AddElement<float>(WPN::VT_MUZZLE_VELOCITY, MUZZLE_VELOCITY, 0.0f);
  }
  void add_RATE_OF_FIRE(float RATE_OF_FIRE) {
    fbb_.AddElement<float>(WPN::VT_RATE_OF_FIRE, RATE_OF_FIRE, 0.0f);
  }
  void add_DISPERSION(float DISPERSION) {
    fbb_.AddElement<float>(WPN::VT_DISPERSION, DISPERSION, 0.0f);
  }
  void add_AMMO_CAPACITY(uint16_t AMMO_CAPACITY) {
    fbb_.AddElement<uint16_t>(WPN::VT_AMMO_CAPACITY, AMMO_CAPACITY, 0);
  }
  void add_BURST_LENGTH(uint16_t BURST_LENGTH) {
    fbb_.AddElement<uint16_t>(WPN::VT_BURST_LENGTH, BURST_LENGTH, 0);
  }
  void add_RELOAD_TIME(float RELOAD_TIME) {
    fbb_.AddElement<float>(WPN::VT_RELOAD_TIME, RELOAD_TIME, 0.0f);
  }
  void add_OVERHEAT_ROUNDS(uint16_t OVERHEAT_ROUNDS) {
    fbb_.AddElement<uint16_t>(WPN::VT_OVERHEAT_ROUNDS, OVERHEAT_ROUNDS, 0);
  }
  void add_COOLDOWN_RATE(float COOLDOWN_RATE) {
    fbb_.AddElement<float>(WPN::VT_COOLDOWN_RATE, COOLDOWN_RATE, 0.0f);
  }
  void add_ELEVATION_MIN(float ELEVATION_MIN) {
    fbb_.AddElement<float>(WPN::VT_ELEVATION_MIN, ELEVATION_MIN, 0.0f);
  }
  void add_ELEVATION_MAX(float ELEVATION_MAX) {
    fbb_.AddElement<float>(WPN::VT_ELEVATION_MAX, ELEVATION_MAX, 0.0f);
  }
  void add_TRAVERSE_MIN(float TRAVERSE_MIN) {
    fbb_.AddElement<float>(WPN::VT_TRAVERSE_MIN, TRAVERSE_MIN, 0.0f);
  }
  void add_TRAVERSE_MAX(float TRAVERSE_MAX) {
    fbb_.AddElement<float>(WPN::VT_TRAVERSE_MAX, TRAVERSE_MAX, 0.0f);
  }
  void add_SLEW_RATE(float SLEW_RATE) {
    fbb_.AddElement<float>(WPN::VT_SLEW_RATE, SLEW_RATE, 0.0f);
  }
  void add_WEAPON_TYPE(uint8_t WEAPON_TYPE) {
    fbb_.AddElement<uint8_t>(WPN::VT_WEAPON_TYPE, WEAPON_TYPE, 0);
  }
  void add_FUZE_TYPE(uint8_t FUZE_TYPE) {
    fbb_.AddElement<uint8_t>(WPN::VT_FUZE_TYPE, FUZE_TYPE, 0);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(WPN::VT_RESERVED, RESERVED);
  }
  explicit WPNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WPN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WPN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WPN> CreateWPN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float CALIBER = 0.0f,
    float MUZZLE_VELOCITY = 0.0f,
    float RATE_OF_FIRE = 0.0f,
    float DISPERSION = 0.0f,
    uint16_t AMMO_CAPACITY = 0,
    uint16_t BURST_LENGTH = 0,
    float RELOAD_TIME = 0.0f,
    uint16_t OVERHEAT_ROUNDS = 0,
    float COOLDOWN_RATE = 0.0f,
    float ELEVATION_MIN = 0.0f,
    float ELEVATION_MAX = 0.0f,
    float TRAVERSE_MIN = 0.0f,
    float TRAVERSE_MAX = 0.0f,
    float SLEW_RATE = 0.0f,
    uint8_t WEAPON_TYPE = 0,
    uint8_t FUZE_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  WPNBuilder builder_(_fbb);
  builder_.add_RESERVED(RESERVED);
  builder_.add_SLEW_RATE(SLEW_RATE);
  builder_.add_TRAVERSE_MAX(TRAVERSE_MAX);
  builder_.add_TRAVERSE_MIN(TRAVERSE_MIN);
  builder_.add_ELEVATION_MAX(ELEVATION_MAX);
  builder_.add_ELEVATION_MIN(ELEVATION_MIN);
  builder_.add_COOLDOWN_RATE(COOLDOWN_RATE);
  builder_.add_RELOAD_TIME(RELOAD_TIME);
  builder_.add_DISPERSION(DISPERSION);
  builder_.add_RATE_OF_FIRE(RATE_OF_FIRE);
  builder_.add_MUZZLE_VELOCITY(MUZZLE_VELOCITY);
  builder_.add_CALIBER(CALIBER);
  builder_.add_OVERHEAT_ROUNDS(OVERHEAT_ROUNDS);
  builder_.add_BURST_LENGTH(BURST_LENGTH);
  builder_.add_AMMO_CAPACITY(AMMO_CAPACITY);
  builder_.add_FUZE_TYPE(FUZE_TYPE);
  builder_.add_WEAPON_TYPE(WEAPON_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WPN> CreateWPNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float CALIBER = 0.0f,
    float MUZZLE_VELOCITY = 0.0f,
    float RATE_OF_FIRE = 0.0f,
    float DISPERSION = 0.0f,
    uint16_t AMMO_CAPACITY = 0,
    uint16_t BURST_LENGTH = 0,
    float RELOAD_TIME = 0.0f,
    uint16_t OVERHEAT_ROUNDS = 0,
    float COOLDOWN_RATE = 0.0f,
    float ELEVATION_MIN = 0.0f,
    float ELEVATION_MAX = 0.0f,
    float TRAVERSE_MIN = 0.0f,
    float TRAVERSE_MAX = 0.0f,
    float SLEW_RATE = 0.0f,
    uint8_t WEAPON_TYPE = 0,
    uint8_t FUZE_TYPE = 0,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateWPN(
      _fbb,
      CALIBER,
      MUZZLE_VELOCITY,
      RATE_OF_FIRE,
      DISPERSION,
      AMMO_CAPACITY,
      BURST_LENGTH,
      RELOAD_TIME,
      OVERHEAT_ROUNDS,
      COOLDOWN_RATE,
      ELEVATION_MIN,
      ELEVATION_MAX,
      TRAVERSE_MIN,
      TRAVERSE_MAX,
      SLEW_RATE,
      WEAPON_TYPE,
      FUZE_TYPE,
      RESERVED__);
}

inline const WPN *GetWPN(const void *buf) {
  return ::flatbuffers::GetRoot<WPN>(buf);
}

inline const WPN *GetSizePrefixedWPN(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<WPN>(buf);
}

inline const char *WPNIdentifier() {
  return "$WPN";
}

inline bool WPNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, WPNIdentifier());
}

inline bool SizePrefixedWPNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, WPNIdentifier(), true);
}

inline bool VerifyWPNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WPN>(WPNIdentifier());
}

inline bool VerifySizePrefixedWPNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WPN>(WPNIdentifier());
}

inline void FinishWPNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WPN> root) {
  fbb.Finish(root, WPNIdentifier());
}

inline void FinishSizePrefixedWPNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<WPN> root) {
  fbb.FinishSizePrefixed(root, WPNIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
