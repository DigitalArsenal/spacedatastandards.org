// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OOS;
struct OOSBuilder;

/// On-Orbit Solar Array
struct OOS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OOSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ID_ON_ORBIT = 6,
    VT_ID_SOLAR_ARRAY = 8,
    VT_NAME = 10,
    VT_CELL_TYPE = 12,
    VT_QUANTITY = 14,
    VT_AREA = 16,
    VT_POWER_BOL = 18,
    VT_POWER_EOL = 20,
    VT_EFFICIENCY = 22,
    VT_DEGRADATION_RATE = 24,
    VT_NUM_PANELS = 26,
    VT_DEPLOYABLE = 28,
    VT_TRACKING = 30,
    VT_MASS = 32,
    VT_NOTES = 34
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Reference to parent on-orbit object
  const ::flatbuffers::String *ID_ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ON_ORBIT);
  }
  /// Reference to solar array specification
  const ::flatbuffers::String *ID_SOLAR_ARRAY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_SOLAR_ARRAY);
  }
  /// Solar array name or designation
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Solar cell type (e.g., SILICON, GAAS, MULTI_JUNCTION, THIN_FILM, PEROVSKITE)
  const ::flatbuffers::String *CELL_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CELL_TYPE);
  }
  /// Number of solar arrays of this type
  uint32_t QUANTITY() const {
    return GetField<uint32_t>(VT_QUANTITY, 0);
  }
  /// Total array area in square meters
  double AREA() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  /// Beginning of life power output in Watts
  double POWER_BOL() const {
    return GetField<double>(VT_POWER_BOL, 0.0);
  }
  /// End of life power output in Watts
  double POWER_EOL() const {
    return GetField<double>(VT_POWER_EOL, 0.0);
  }
  /// Conversion efficiency as fraction (0.0-1.0)
  double EFFICIENCY() const {
    return GetField<double>(VT_EFFICIENCY, 0.0);
  }
  /// Degradation rate per year as fraction
  double DEGRADATION_RATE() const {
    return GetField<double>(VT_DEGRADATION_RATE, 0.0);
  }
  /// Number of panels per array
  uint32_t NUM_PANELS() const {
    return GetField<uint32_t>(VT_NUM_PANELS, 0);
  }
  /// Whether the array is deployable
  bool DEPLOYABLE() const {
    return GetField<uint8_t>(VT_DEPLOYABLE, 0) != 0;
  }
  /// Whether the array is articulable/tracking
  bool TRACKING() const {
    return GetField<uint8_t>(VT_TRACKING, 0) != 0;
  }
  /// Array mass in kg
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_ID_ON_ORBIT) &&
           verifier.VerifyString(ID_ON_ORBIT()) &&
           VerifyOffset(verifier, VT_ID_SOLAR_ARRAY) &&
           verifier.VerifyString(ID_SOLAR_ARRAY()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_CELL_TYPE) &&
           verifier.VerifyString(CELL_TYPE()) &&
           VerifyField<uint32_t>(verifier, VT_QUANTITY, 4) &&
           VerifyField<double>(verifier, VT_AREA, 8) &&
           VerifyField<double>(verifier, VT_POWER_BOL, 8) &&
           VerifyField<double>(verifier, VT_POWER_EOL, 8) &&
           VerifyField<double>(verifier, VT_EFFICIENCY, 8) &&
           VerifyField<double>(verifier, VT_DEGRADATION_RATE, 8) &&
           VerifyField<uint32_t>(verifier, VT_NUM_PANELS, 4) &&
           VerifyField<uint8_t>(verifier, VT_DEPLOYABLE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRACKING, 1) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct OOSBuilder {
  typedef OOS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(OOS::VT_ID, ID);
  }
  void add_ID_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT) {
    fbb_.AddOffset(OOS::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  void add_ID_SOLAR_ARRAY(::flatbuffers::Offset<::flatbuffers::String> ID_SOLAR_ARRAY) {
    fbb_.AddOffset(OOS::VT_ID_SOLAR_ARRAY, ID_SOLAR_ARRAY);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(OOS::VT_NAME, NAME);
  }
  void add_CELL_TYPE(::flatbuffers::Offset<::flatbuffers::String> CELL_TYPE) {
    fbb_.AddOffset(OOS::VT_CELL_TYPE, CELL_TYPE);
  }
  void add_QUANTITY(uint32_t QUANTITY) {
    fbb_.AddElement<uint32_t>(OOS::VT_QUANTITY, QUANTITY, 0);
  }
  void add_AREA(double AREA) {
    fbb_.AddElement<double>(OOS::VT_AREA, AREA, 0.0);
  }
  void add_POWER_BOL(double POWER_BOL) {
    fbb_.AddElement<double>(OOS::VT_POWER_BOL, POWER_BOL, 0.0);
  }
  void add_POWER_EOL(double POWER_EOL) {
    fbb_.AddElement<double>(OOS::VT_POWER_EOL, POWER_EOL, 0.0);
  }
  void add_EFFICIENCY(double EFFICIENCY) {
    fbb_.AddElement<double>(OOS::VT_EFFICIENCY, EFFICIENCY, 0.0);
  }
  void add_DEGRADATION_RATE(double DEGRADATION_RATE) {
    fbb_.AddElement<double>(OOS::VT_DEGRADATION_RATE, DEGRADATION_RATE, 0.0);
  }
  void add_NUM_PANELS(uint32_t NUM_PANELS) {
    fbb_.AddElement<uint32_t>(OOS::VT_NUM_PANELS, NUM_PANELS, 0);
  }
  void add_DEPLOYABLE(bool DEPLOYABLE) {
    fbb_.AddElement<uint8_t>(OOS::VT_DEPLOYABLE, static_cast<uint8_t>(DEPLOYABLE), 0);
  }
  void add_TRACKING(bool TRACKING) {
    fbb_.AddElement<uint8_t>(OOS::VT_TRACKING, static_cast<uint8_t>(TRACKING), 0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(OOS::VT_MASS, MASS, 0.0);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(OOS::VT_NOTES, NOTES);
  }
  explicit OOSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OOS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OOS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OOS> CreateOOS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_SOLAR_ARRAY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CELL_TYPE = 0,
    uint32_t QUANTITY = 0,
    double AREA = 0.0,
    double POWER_BOL = 0.0,
    double POWER_EOL = 0.0,
    double EFFICIENCY = 0.0,
    double DEGRADATION_RATE = 0.0,
    uint32_t NUM_PANELS = 0,
    bool DEPLOYABLE = false,
    bool TRACKING = false,
    double MASS = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  OOSBuilder builder_(_fbb);
  builder_.add_MASS(MASS);
  builder_.add_DEGRADATION_RATE(DEGRADATION_RATE);
  builder_.add_EFFICIENCY(EFFICIENCY);
  builder_.add_POWER_EOL(POWER_EOL);
  builder_.add_POWER_BOL(POWER_BOL);
  builder_.add_AREA(AREA);
  builder_.add_NOTES(NOTES);
  builder_.add_NUM_PANELS(NUM_PANELS);
  builder_.add_QUANTITY(QUANTITY);
  builder_.add_CELL_TYPE(CELL_TYPE);
  builder_.add_NAME(NAME);
  builder_.add_ID_SOLAR_ARRAY(ID_SOLAR_ARRAY);
  builder_.add_ID_ON_ORBIT(ID_ON_ORBIT);
  builder_.add_ID(ID);
  builder_.add_TRACKING(TRACKING);
  builder_.add_DEPLOYABLE(DEPLOYABLE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OOS> CreateOOSDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *ID_ON_ORBIT = nullptr,
    const char *ID_SOLAR_ARRAY = nullptr,
    const char *NAME = nullptr,
    const char *CELL_TYPE = nullptr,
    uint32_t QUANTITY = 0,
    double AREA = 0.0,
    double POWER_BOL = 0.0,
    double POWER_EOL = 0.0,
    double EFFICIENCY = 0.0,
    double DEGRADATION_RATE = 0.0,
    uint32_t NUM_PANELS = 0,
    bool DEPLOYABLE = false,
    bool TRACKING = false,
    double MASS = 0.0,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto ID_ON_ORBIT__ = ID_ON_ORBIT ? _fbb.CreateString(ID_ON_ORBIT) : 0;
  auto ID_SOLAR_ARRAY__ = ID_SOLAR_ARRAY ? _fbb.CreateString(ID_SOLAR_ARRAY) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto CELL_TYPE__ = CELL_TYPE ? _fbb.CreateString(CELL_TYPE) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateOOS(
      _fbb,
      ID__,
      ID_ON_ORBIT__,
      ID_SOLAR_ARRAY__,
      NAME__,
      CELL_TYPE__,
      QUANTITY,
      AREA,
      POWER_BOL,
      POWER_EOL,
      EFFICIENCY,
      DEGRADATION_RATE,
      NUM_PANELS,
      DEPLOYABLE,
      TRACKING,
      MASS,
      NOTES__);
}

inline const OOS *GetOOS(const void *buf) {
  return ::flatbuffers::GetRoot<OOS>(buf);
}

inline const OOS *GetSizePrefixedOOS(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OOS>(buf);
}

inline const char *OOSIdentifier() {
  return "$OOS";
}

inline bool OOSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOSIdentifier());
}

inline bool SizePrefixedOOSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOSIdentifier(), true);
}

inline bool VerifyOOSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OOS>(OOSIdentifier());
}

inline bool VerifySizePrefixedOOSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OOS>(OOSIdentifier());
}

inline void FinishOOSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOS> root) {
  fbb.Finish(root, OOSIdentifier());
}

inline void FinishSizePrefixedOOSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOS> root) {
  fbb.FinishSizePrefixed(root, OOSIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
