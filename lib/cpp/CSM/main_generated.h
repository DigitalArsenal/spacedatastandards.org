// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct CSM;
struct CSMBuilder;

struct CSMCOLLECTION;
struct CSMCOLLECTIONBuilder;

/// Conjunction Summary Message
struct CSM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CSMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_1 = 4,
    VT_DSE_1 = 6,
    VT_OBJECT_2 = 8,
    VT_DSE_2 = 10,
    VT_TCA = 12,
    VT_TCA_RANGE = 14,
    VT_TCA_RELATIVE_SPEED = 16,
    VT_MAX_PROB = 18,
    VT_DILUTION = 20
  };
  /// Satellite name for the first object
  const CAT *OBJECT_1() const {
    return GetPointer<const CAT *>(VT_OBJECT_1);
  }
  /// Days since epoch for the first object
  double DSE_1() const {
    return GetField<double>(VT_DSE_1, 0.0);
  }
  /// Satellite name for the second object
  const CAT *OBJECT_2() const {
    return GetPointer<const CAT *>(VT_OBJECT_2);
  }
  /// Days since epoch for the second object
  double DSE_2() const {
    return GetField<double>(VT_DSE_2, 0.0);
  }
  /// Time of closest approach as a Unix timestamp
  double TCA() const {
    return GetField<double>(VT_TCA, 0.0);
  }
  /// The distance or range between the two objects at TCA
  double TCA_RANGE() const {
    return GetField<double>(VT_TCA_RANGE, 0.0);
  }
  /// The magnitude of the relative velocity at TCA
  double TCA_RELATIVE_SPEED() const {
    return GetField<double>(VT_TCA_RELATIVE_SPEED, 0.0);
  }
  /// Maximum probability
  double MAX_PROB() const {
    return GetField<double>(VT_MAX_PROB, 0.0);
  }
  /// Standard deviation that produces the maximum probability
  double DILUTION() const {
    return GetField<double>(VT_DILUTION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_1) &&
           verifier.VerifyTable(OBJECT_1()) &&
           VerifyField<double>(verifier, VT_DSE_1, 8) &&
           VerifyOffset(verifier, VT_OBJECT_2) &&
           verifier.VerifyTable(OBJECT_2()) &&
           VerifyField<double>(verifier, VT_DSE_2, 8) &&
           VerifyField<double>(verifier, VT_TCA, 8) &&
           VerifyField<double>(verifier, VT_TCA_RANGE, 8) &&
           VerifyField<double>(verifier, VT_TCA_RELATIVE_SPEED, 8) &&
           VerifyField<double>(verifier, VT_MAX_PROB, 8) &&
           VerifyField<double>(verifier, VT_DILUTION, 8) &&
           verifier.EndTable();
  }
};

struct CSMBuilder {
  typedef CSM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OBJECT_1(::flatbuffers::Offset<CAT> OBJECT_1) {
    fbb_.AddOffset(CSM::VT_OBJECT_1, OBJECT_1);
  }
  void add_DSE_1(double DSE_1) {
    fbb_.AddElement<double>(CSM::VT_DSE_1, DSE_1, 0.0);
  }
  void add_OBJECT_2(::flatbuffers::Offset<CAT> OBJECT_2) {
    fbb_.AddOffset(CSM::VT_OBJECT_2, OBJECT_2);
  }
  void add_DSE_2(double DSE_2) {
    fbb_.AddElement<double>(CSM::VT_DSE_2, DSE_2, 0.0);
  }
  void add_TCA(double TCA) {
    fbb_.AddElement<double>(CSM::VT_TCA, TCA, 0.0);
  }
  void add_TCA_RANGE(double TCA_RANGE) {
    fbb_.AddElement<double>(CSM::VT_TCA_RANGE, TCA_RANGE, 0.0);
  }
  void add_TCA_RELATIVE_SPEED(double TCA_RELATIVE_SPEED) {
    fbb_.AddElement<double>(CSM::VT_TCA_RELATIVE_SPEED, TCA_RELATIVE_SPEED, 0.0);
  }
  void add_MAX_PROB(double MAX_PROB) {
    fbb_.AddElement<double>(CSM::VT_MAX_PROB, MAX_PROB, 0.0);
  }
  void add_DILUTION(double DILUTION) {
    fbb_.AddElement<double>(CSM::VT_DILUTION, DILUTION, 0.0);
  }
  explicit CSMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CSM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CSM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CSM> CreateCSM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<CAT> OBJECT_1 = 0,
    double DSE_1 = 0.0,
    ::flatbuffers::Offset<CAT> OBJECT_2 = 0,
    double DSE_2 = 0.0,
    double TCA = 0.0,
    double TCA_RANGE = 0.0,
    double TCA_RELATIVE_SPEED = 0.0,
    double MAX_PROB = 0.0,
    double DILUTION = 0.0) {
  CSMBuilder builder_(_fbb);
  builder_.add_DILUTION(DILUTION);
  builder_.add_MAX_PROB(MAX_PROB);
  builder_.add_TCA_RELATIVE_SPEED(TCA_RELATIVE_SPEED);
  builder_.add_TCA_RANGE(TCA_RANGE);
  builder_.add_TCA(TCA);
  builder_.add_DSE_2(DSE_2);
  builder_.add_DSE_1(DSE_1);
  builder_.add_OBJECT_2(OBJECT_2);
  builder_.add_OBJECT_1(OBJECT_1);
  return builder_.Finish();
}

struct CSMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CSMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CSM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CSM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct CSMCOLLECTIONBuilder {
  typedef CSMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CSM>>> RECORDS) {
    fbb_.AddOffset(CSMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit CSMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CSMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CSMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CSMCOLLECTION> CreateCSMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CSM>>> RECORDS = 0) {
  CSMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CSMCOLLECTION> CreateCSMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CSM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<CSM>>(*RECORDS) : 0;
  return CreateCSMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const CSM *GetCSM(const void *buf) {
  return ::flatbuffers::GetRoot<CSM>(buf);
}

inline const CSM *GetSizePrefixedCSM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CSM>(buf);
}

inline const char *CSMIdentifier() {
  return "$CSM";
}

inline bool CSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CSMIdentifier());
}

inline bool SizePrefixedCSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CSMIdentifier(), true);
}

inline bool VerifyCSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CSM>(CSMIdentifier());
}

inline bool VerifySizePrefixedCSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CSM>(CSMIdentifier());
}

inline void FinishCSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CSM> root) {
  fbb.Finish(root, CSMIdentifier());
}

inline void FinishSizePrefixedCSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CSM> root) {
  fbb.FinishSizePrefixed(root, CSMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
