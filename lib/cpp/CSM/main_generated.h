// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct CSM;
struct CSMBuilder;

/// Conjunction Summary Message
struct CSM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CSMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORAD_CAT_ID_1 = 4,
    VT_OBJECT_NAME_1 = 6,
    VT_DSE_1 = 8,
    VT_NORAD_CAT_ID_2 = 10,
    VT_OBJECT_NAME_2 = 12,
    VT_DSE_2 = 14,
    VT_TCA = 16,
    VT_TCA_RANGE = 18,
    VT_TCA_RELATIVE_SPEED = 20,
    VT_MAX_PROB = 22,
    VT_DILUTION = 24
  };
  /// NORAD Catalog Number for the first object
  uint32_t NORAD_CAT_ID_1() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID_1, 0);
  }
  /// Satellite name for the first object
  const ::flatbuffers::String *OBJECT_NAME_1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME_1);
  }
  /// Days since epoch for the first object
  double DSE_1() const {
    return GetField<double>(VT_DSE_1, 0.0);
  }
  /// NORAD Catalog Number for the second object
  uint32_t NORAD_CAT_ID_2() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID_2, 0);
  }
  /// Satellite name for the second object
  const ::flatbuffers::String *OBJECT_NAME_2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME_2);
  }
  /// Days since epoch for the second object
  double DSE_2() const {
    return GetField<double>(VT_DSE_2, 0.0);
  }
  /// Time of closest approach as a Unix timestamp
  double TCA() const {
    return GetField<double>(VT_TCA, 0.0);
  }
  /// The distance or range between the two objects at TCA
  double TCA_RANGE() const {
    return GetField<double>(VT_TCA_RANGE, 0.0);
  }
  /// The magnitude of the relative velocity at TCA
  double TCA_RELATIVE_SPEED() const {
    return GetField<double>(VT_TCA_RELATIVE_SPEED, 0.0);
  }
  /// Maximum probability
  double MAX_PROB() const {
    return GetField<double>(VT_MAX_PROB, 0.0);
  }
  /// Standard deviation that produces the maximum probability
  double DILUTION() const {
    return GetField<double>(VT_DILUTION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID_1, 4) &&
           VerifyOffset(verifier, VT_OBJECT_NAME_1) &&
           verifier.VerifyString(OBJECT_NAME_1()) &&
           VerifyField<double>(verifier, VT_DSE_1, 8) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID_2, 4) &&
           VerifyOffset(verifier, VT_OBJECT_NAME_2) &&
           verifier.VerifyString(OBJECT_NAME_2()) &&
           VerifyField<double>(verifier, VT_DSE_2, 8) &&
           VerifyField<double>(verifier, VT_TCA, 8) &&
           VerifyField<double>(verifier, VT_TCA_RANGE, 8) &&
           VerifyField<double>(verifier, VT_TCA_RELATIVE_SPEED, 8) &&
           VerifyField<double>(verifier, VT_MAX_PROB, 8) &&
           VerifyField<double>(verifier, VT_DILUTION, 8) &&
           verifier.EndTable();
  }
};

struct CSMBuilder {
  typedef CSM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NORAD_CAT_ID_1(uint32_t NORAD_CAT_ID_1) {
    fbb_.AddElement<uint32_t>(CSM::VT_NORAD_CAT_ID_1, NORAD_CAT_ID_1, 0);
  }
  void add_OBJECT_NAME_1(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME_1) {
    fbb_.AddOffset(CSM::VT_OBJECT_NAME_1, OBJECT_NAME_1);
  }
  void add_DSE_1(double DSE_1) {
    fbb_.AddElement<double>(CSM::VT_DSE_1, DSE_1, 0.0);
  }
  void add_NORAD_CAT_ID_2(uint32_t NORAD_CAT_ID_2) {
    fbb_.AddElement<uint32_t>(CSM::VT_NORAD_CAT_ID_2, NORAD_CAT_ID_2, 0);
  }
  void add_OBJECT_NAME_2(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME_2) {
    fbb_.AddOffset(CSM::VT_OBJECT_NAME_2, OBJECT_NAME_2);
  }
  void add_DSE_2(double DSE_2) {
    fbb_.AddElement<double>(CSM::VT_DSE_2, DSE_2, 0.0);
  }
  void add_TCA(double TCA) {
    fbb_.AddElement<double>(CSM::VT_TCA, TCA, 0.0);
  }
  void add_TCA_RANGE(double TCA_RANGE) {
    fbb_.AddElement<double>(CSM::VT_TCA_RANGE, TCA_RANGE, 0.0);
  }
  void add_TCA_RELATIVE_SPEED(double TCA_RELATIVE_SPEED) {
    fbb_.AddElement<double>(CSM::VT_TCA_RELATIVE_SPEED, TCA_RELATIVE_SPEED, 0.0);
  }
  void add_MAX_PROB(double MAX_PROB) {
    fbb_.AddElement<double>(CSM::VT_MAX_PROB, MAX_PROB, 0.0);
  }
  void add_DILUTION(double DILUTION) {
    fbb_.AddElement<double>(CSM::VT_DILUTION, DILUTION, 0.0);
  }
  explicit CSMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CSM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CSM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CSM> CreateCSM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NORAD_CAT_ID_1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME_1 = 0,
    double DSE_1 = 0.0,
    uint32_t NORAD_CAT_ID_2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME_2 = 0,
    double DSE_2 = 0.0,
    double TCA = 0.0,
    double TCA_RANGE = 0.0,
    double TCA_RELATIVE_SPEED = 0.0,
    double MAX_PROB = 0.0,
    double DILUTION = 0.0) {
  CSMBuilder builder_(_fbb);
  builder_.add_DILUTION(DILUTION);
  builder_.add_MAX_PROB(MAX_PROB);
  builder_.add_TCA_RELATIVE_SPEED(TCA_RELATIVE_SPEED);
  builder_.add_TCA_RANGE(TCA_RANGE);
  builder_.add_TCA(TCA);
  builder_.add_DSE_2(DSE_2);
  builder_.add_DSE_1(DSE_1);
  builder_.add_OBJECT_NAME_2(OBJECT_NAME_2);
  builder_.add_NORAD_CAT_ID_2(NORAD_CAT_ID_2);
  builder_.add_OBJECT_NAME_1(OBJECT_NAME_1);
  builder_.add_NORAD_CAT_ID_1(NORAD_CAT_ID_1);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CSM> CreateCSMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t NORAD_CAT_ID_1 = 0,
    const char *OBJECT_NAME_1 = nullptr,
    double DSE_1 = 0.0,
    uint32_t NORAD_CAT_ID_2 = 0,
    const char *OBJECT_NAME_2 = nullptr,
    double DSE_2 = 0.0,
    double TCA = 0.0,
    double TCA_RANGE = 0.0,
    double TCA_RELATIVE_SPEED = 0.0,
    double MAX_PROB = 0.0,
    double DILUTION = 0.0) {
  auto OBJECT_NAME_1__ = OBJECT_NAME_1 ? _fbb.CreateString(OBJECT_NAME_1) : 0;
  auto OBJECT_NAME_2__ = OBJECT_NAME_2 ? _fbb.CreateString(OBJECT_NAME_2) : 0;
  return CreateCSM(
      _fbb,
      NORAD_CAT_ID_1,
      OBJECT_NAME_1__,
      DSE_1,
      NORAD_CAT_ID_2,
      OBJECT_NAME_2__,
      DSE_2,
      TCA,
      TCA_RANGE,
      TCA_RELATIVE_SPEED,
      MAX_PROB,
      DILUTION);
}

inline const CSM *GetCSM(const void *buf) {
  return ::flatbuffers::GetRoot<CSM>(buf);
}

inline const CSM *GetSizePrefixedCSM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CSM>(buf);
}

inline const char *CSMIdentifier() {
  return "$CSM";
}

inline bool CSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CSMIdentifier());
}

inline bool SizePrefixedCSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CSMIdentifier(), true);
}

inline bool VerifyCSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CSM>(CSMIdentifier());
}

inline bool VerifySizePrefixedCSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CSM>(CSMIdentifier());
}

inline void FinishCSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CSM> root) {
  fbb.Finish(root, CSMIdentifier());
}

inline void FinishSizePrefixedCSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CSM> root) {
  fbb.FinishSizePrefixed(root, CSMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
