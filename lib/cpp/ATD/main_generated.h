// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ATD;
struct ATDBuilder;

/// Attitude Data Point
struct ATD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ATDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_AS_ID = 6,
    VT_SAT_NO = 8,
    VT_ORIG_OBJECT_ID = 10,
    VT_TS = 12,
    VT_MOTION_TYPE = 14,
    VT_Q1 = 16,
    VT_Q2 = 18,
    VT_Q3 = 20,
    VT_QC = 22,
    VT_Q1_DOT = 24,
    VT_Q2_DOT = 26,
    VT_Q3_DOT = 28,
    VT_QC_DOT = 30,
    VT_X_ANGLE = 32,
    VT_Y_ANGLE = 34,
    VT_Z_ANGLE = 36,
    VT_X_RATE = 38,
    VT_Y_RATE = 40,
    VT_Z_RATE = 42,
    VT_RA = 44,
    VT_DECLINATION = 46,
    VT_CONING_ANGLE = 48,
    VT_PREC_PERIOD = 50,
    VT_SPIN_PERIOD = 52
  };
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *AS_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AS_ID);
  }
  int32_t SAT_NO() const {
    return GetField<int32_t>(VT_SAT_NO, 0);
  }
  const ::flatbuffers::String *ORIG_OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_OBJECT_ID);
  }
  const ::flatbuffers::String *TS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  const ::flatbuffers::String *MOTION_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTION_TYPE);
  }
  double Q1() const {
    return GetField<double>(VT_Q1, 0.0);
  }
  double Q2() const {
    return GetField<double>(VT_Q2, 0.0);
  }
  double Q3() const {
    return GetField<double>(VT_Q3, 0.0);
  }
  double QC() const {
    return GetField<double>(VT_QC, 0.0);
  }
  double Q1_DOT() const {
    return GetField<double>(VT_Q1_DOT, 0.0);
  }
  double Q2_DOT() const {
    return GetField<double>(VT_Q2_DOT, 0.0);
  }
  double Q3_DOT() const {
    return GetField<double>(VT_Q3_DOT, 0.0);
  }
  double QC_DOT() const {
    return GetField<double>(VT_QC_DOT, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *X_ANGLE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_X_ANGLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *Y_ANGLE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_Y_ANGLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *Z_ANGLE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_Z_ANGLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *X_RATE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_X_RATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *Y_RATE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_Y_RATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *Z_RATE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_Z_RATE);
  }
  double RA() const {
    return GetField<double>(VT_RA, 0.0);
  }
  double DECLINATION() const {
    return GetField<double>(VT_DECLINATION, 0.0);
  }
  double CONING_ANGLE() const {
    return GetField<double>(VT_CONING_ANGLE, 0.0);
  }
  double PREC_PERIOD() const {
    return GetField<double>(VT_PREC_PERIOD, 0.0);
  }
  double SPIN_PERIOD() const {
    return GetField<double>(VT_SPIN_PERIOD, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_AS_ID) &&
           verifier.VerifyString(AS_ID()) &&
           VerifyField<int32_t>(verifier, VT_SAT_NO, 4) &&
           VerifyOffset(verifier, VT_ORIG_OBJECT_ID) &&
           verifier.VerifyString(ORIG_OBJECT_ID()) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(TS()) &&
           VerifyOffset(verifier, VT_MOTION_TYPE) &&
           verifier.VerifyString(MOTION_TYPE()) &&
           VerifyField<double>(verifier, VT_Q1, 8) &&
           VerifyField<double>(verifier, VT_Q2, 8) &&
           VerifyField<double>(verifier, VT_Q3, 8) &&
           VerifyField<double>(verifier, VT_QC, 8) &&
           VerifyField<double>(verifier, VT_Q1_DOT, 8) &&
           VerifyField<double>(verifier, VT_Q2_DOT, 8) &&
           VerifyField<double>(verifier, VT_Q3_DOT, 8) &&
           VerifyField<double>(verifier, VT_QC_DOT, 8) &&
           VerifyOffset(verifier, VT_X_ANGLE) &&
           verifier.VerifyVector(X_ANGLE()) &&
           verifier.VerifyVectorOfStrings(X_ANGLE()) &&
           VerifyOffset(verifier, VT_Y_ANGLE) &&
           verifier.VerifyVector(Y_ANGLE()) &&
           verifier.VerifyVectorOfStrings(Y_ANGLE()) &&
           VerifyOffset(verifier, VT_Z_ANGLE) &&
           verifier.VerifyVector(Z_ANGLE()) &&
           verifier.VerifyVectorOfStrings(Z_ANGLE()) &&
           VerifyOffset(verifier, VT_X_RATE) &&
           verifier.VerifyVector(X_RATE()) &&
           verifier.VerifyVectorOfStrings(X_RATE()) &&
           VerifyOffset(verifier, VT_Y_RATE) &&
           verifier.VerifyVector(Y_RATE()) &&
           verifier.VerifyVectorOfStrings(Y_RATE()) &&
           VerifyOffset(verifier, VT_Z_RATE) &&
           verifier.VerifyVector(Z_RATE()) &&
           verifier.VerifyVectorOfStrings(Z_RATE()) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_DECLINATION, 8) &&
           VerifyField<double>(verifier, VT_CONING_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_PREC_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_SPIN_PERIOD, 8) &&
           verifier.EndTable();
  }
};

struct ATDBuilder {
  typedef ATD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(ATD::VT_ID, ID);
  }
  void add_AS_ID(::flatbuffers::Offset<::flatbuffers::String> AS_ID) {
    fbb_.AddOffset(ATD::VT_AS_ID, AS_ID);
  }
  void add_SAT_NO(int32_t SAT_NO) {
    fbb_.AddElement<int32_t>(ATD::VT_SAT_NO, SAT_NO, 0);
  }
  void add_ORIG_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID) {
    fbb_.AddOffset(ATD::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  void add_TS(::flatbuffers::Offset<::flatbuffers::String> TS) {
    fbb_.AddOffset(ATD::VT_TS, TS);
  }
  void add_MOTION_TYPE(::flatbuffers::Offset<::flatbuffers::String> MOTION_TYPE) {
    fbb_.AddOffset(ATD::VT_MOTION_TYPE, MOTION_TYPE);
  }
  void add_Q1(double Q1) {
    fbb_.AddElement<double>(ATD::VT_Q1, Q1, 0.0);
  }
  void add_Q2(double Q2) {
    fbb_.AddElement<double>(ATD::VT_Q2, Q2, 0.0);
  }
  void add_Q3(double Q3) {
    fbb_.AddElement<double>(ATD::VT_Q3, Q3, 0.0);
  }
  void add_QC(double QC) {
    fbb_.AddElement<double>(ATD::VT_QC, QC, 0.0);
  }
  void add_Q1_DOT(double Q1_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q1_DOT, Q1_DOT, 0.0);
  }
  void add_Q2_DOT(double Q2_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q2_DOT, Q2_DOT, 0.0);
  }
  void add_Q3_DOT(double Q3_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q3_DOT, Q3_DOT, 0.0);
  }
  void add_QC_DOT(double QC_DOT) {
    fbb_.AddElement<double>(ATD::VT_QC_DOT, QC_DOT, 0.0);
  }
  void add_X_ANGLE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> X_ANGLE) {
    fbb_.AddOffset(ATD::VT_X_ANGLE, X_ANGLE);
  }
  void add_Y_ANGLE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Y_ANGLE) {
    fbb_.AddOffset(ATD::VT_Y_ANGLE, Y_ANGLE);
  }
  void add_Z_ANGLE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Z_ANGLE) {
    fbb_.AddOffset(ATD::VT_Z_ANGLE, Z_ANGLE);
  }
  void add_X_RATE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> X_RATE) {
    fbb_.AddOffset(ATD::VT_X_RATE, X_RATE);
  }
  void add_Y_RATE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Y_RATE) {
    fbb_.AddOffset(ATD::VT_Y_RATE, Y_RATE);
  }
  void add_Z_RATE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Z_RATE) {
    fbb_.AddOffset(ATD::VT_Z_RATE, Z_RATE);
  }
  void add_RA(double RA) {
    fbb_.AddElement<double>(ATD::VT_RA, RA, 0.0);
  }
  void add_DECLINATION(double DECLINATION) {
    fbb_.AddElement<double>(ATD::VT_DECLINATION, DECLINATION, 0.0);
  }
  void add_CONING_ANGLE(double CONING_ANGLE) {
    fbb_.AddElement<double>(ATD::VT_CONING_ANGLE, CONING_ANGLE, 0.0);
  }
  void add_PREC_PERIOD(double PREC_PERIOD) {
    fbb_.AddElement<double>(ATD::VT_PREC_PERIOD, PREC_PERIOD, 0.0);
  }
  void add_SPIN_PERIOD(double SPIN_PERIOD) {
    fbb_.AddElement<double>(ATD::VT_SPIN_PERIOD, SPIN_PERIOD, 0.0);
  }
  explicit ATDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATD> CreateATD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AS_ID = 0,
    int32_t SAT_NO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MOTION_TYPE = 0,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC = 0.0,
    double Q1_DOT = 0.0,
    double Q2_DOT = 0.0,
    double Q3_DOT = 0.0,
    double QC_DOT = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> X_ANGLE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Y_ANGLE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Z_ANGLE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> X_RATE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Y_RATE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> Z_RATE = 0,
    double RA = 0.0,
    double DECLINATION = 0.0,
    double CONING_ANGLE = 0.0,
    double PREC_PERIOD = 0.0,
    double SPIN_PERIOD = 0.0) {
  ATDBuilder builder_(_fbb);
  builder_.add_SPIN_PERIOD(SPIN_PERIOD);
  builder_.add_PREC_PERIOD(PREC_PERIOD);
  builder_.add_CONING_ANGLE(CONING_ANGLE);
  builder_.add_DECLINATION(DECLINATION);
  builder_.add_RA(RA);
  builder_.add_QC_DOT(QC_DOT);
  builder_.add_Q3_DOT(Q3_DOT);
  builder_.add_Q2_DOT(Q2_DOT);
  builder_.add_Q1_DOT(Q1_DOT);
  builder_.add_QC(QC);
  builder_.add_Q3(Q3);
  builder_.add_Q2(Q2);
  builder_.add_Q1(Q1);
  builder_.add_Z_RATE(Z_RATE);
  builder_.add_Y_RATE(Y_RATE);
  builder_.add_X_RATE(X_RATE);
  builder_.add_Z_ANGLE(Z_ANGLE);
  builder_.add_Y_ANGLE(Y_ANGLE);
  builder_.add_X_ANGLE(X_ANGLE);
  builder_.add_MOTION_TYPE(MOTION_TYPE);
  builder_.add_TS(TS);
  builder_.add_ORIG_OBJECT_ID(ORIG_OBJECT_ID);
  builder_.add_SAT_NO(SAT_NO);
  builder_.add_AS_ID(AS_ID);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ATD> CreateATDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *AS_ID = nullptr,
    int32_t SAT_NO = 0,
    const char *ORIG_OBJECT_ID = nullptr,
    const char *TS = nullptr,
    const char *MOTION_TYPE = nullptr,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC = 0.0,
    double Q1_DOT = 0.0,
    double Q2_DOT = 0.0,
    double Q3_DOT = 0.0,
    double QC_DOT = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *X_ANGLE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *Y_ANGLE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *Z_ANGLE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *X_RATE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *Y_RATE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *Z_RATE = nullptr,
    double RA = 0.0,
    double DECLINATION = 0.0,
    double CONING_ANGLE = 0.0,
    double PREC_PERIOD = 0.0,
    double SPIN_PERIOD = 0.0) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto AS_ID__ = AS_ID ? _fbb.CreateString(AS_ID) : 0;
  auto ORIG_OBJECT_ID__ = ORIG_OBJECT_ID ? _fbb.CreateString(ORIG_OBJECT_ID) : 0;
  auto TS__ = TS ? _fbb.CreateString(TS) : 0;
  auto MOTION_TYPE__ = MOTION_TYPE ? _fbb.CreateString(MOTION_TYPE) : 0;
  auto X_ANGLE__ = X_ANGLE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*X_ANGLE) : 0;
  auto Y_ANGLE__ = Y_ANGLE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*Y_ANGLE) : 0;
  auto Z_ANGLE__ = Z_ANGLE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*Z_ANGLE) : 0;
  auto X_RATE__ = X_RATE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*X_RATE) : 0;
  auto Y_RATE__ = Y_RATE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*Y_RATE) : 0;
  auto Z_RATE__ = Z_RATE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*Z_RATE) : 0;
  return CreateATD(
      _fbb,
      ID__,
      AS_ID__,
      SAT_NO,
      ORIG_OBJECT_ID__,
      TS__,
      MOTION_TYPE__,
      Q1,
      Q2,
      Q3,
      QC,
      Q1_DOT,
      Q2_DOT,
      Q3_DOT,
      QC_DOT,
      X_ANGLE__,
      Y_ANGLE__,
      Z_ANGLE__,
      X_RATE__,
      Y_RATE__,
      Z_RATE__,
      RA,
      DECLINATION,
      CONING_ANGLE,
      PREC_PERIOD,
      SPIN_PERIOD);
}

inline const ATD *GetATD(const void *buf) {
  return ::flatbuffers::GetRoot<ATD>(buf);
}

inline const ATD *GetSizePrefixedATD(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ATD>(buf);
}

inline const char *ATDIdentifier() {
  return "$ATD";
}

inline bool ATDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ATDIdentifier());
}

inline bool SizePrefixedATDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ATDIdentifier(), true);
}

inline bool VerifyATDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ATD>(ATDIdentifier());
}

inline bool VerifySizePrefixedATDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ATD>(ATDIdentifier());
}

inline void FinishATDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ATD> root) {
  fbb.Finish(root, ATDIdentifier());
}

inline void FinishSizePrefixedATDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ATD> root) {
  fbb.FinishSizePrefixed(root, ATDIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
