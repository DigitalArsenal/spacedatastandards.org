// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ATD;
struct ATDBuilder;

enum attMotionType : int8_t {
  attMotionType_STABILIZED = 0,
  attMotionType_SPINNING = 1,
  attMotionType_TUMBLING = 2,
  attMotionType_PRECESSING = 3,
  attMotionType_UNKNOWN = 4,
  attMotionType_MIN = attMotionType_STABILIZED,
  attMotionType_MAX = attMotionType_UNKNOWN
};

inline const attMotionType (&EnumValuesattMotionType())[5] {
  static const attMotionType values[] = {
    attMotionType_STABILIZED,
    attMotionType_SPINNING,
    attMotionType_TUMBLING,
    attMotionType_PRECESSING,
    attMotionType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesattMotionType() {
  static const char * const names[6] = {
    "STABILIZED",
    "SPINNING",
    "TUMBLING",
    "PRECESSING",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameattMotionType(attMotionType e) {
  if (::flatbuffers::IsOutRange(e, attMotionType_STABILIZED, attMotionType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesattMotionType()[index];
}

enum attRepresentation : int8_t {
  attRepresentation_QUATERNION = 0,
  attRepresentation_EULER = 1,
  attRepresentation_SPIN = 2,
  attRepresentation_DIRECTION_COSINE = 3,
  attRepresentation_MIN = attRepresentation_QUATERNION,
  attRepresentation_MAX = attRepresentation_DIRECTION_COSINE
};

inline const attRepresentation (&EnumValuesattRepresentation())[4] {
  static const attRepresentation values[] = {
    attRepresentation_QUATERNION,
    attRepresentation_EULER,
    attRepresentation_SPIN,
    attRepresentation_DIRECTION_COSINE
  };
  return values;
}

inline const char * const *EnumNamesattRepresentation() {
  static const char * const names[5] = {
    "QUATERNION",
    "EULER",
    "SPIN",
    "DIRECTION_COSINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameattRepresentation(attRepresentation e) {
  if (::flatbuffers::IsOutRange(e, attRepresentation_QUATERNION, attRepresentation_DIRECTION_COSINE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesattRepresentation()[index];
}

/// Attitude Data Point
struct ATD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ATDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_AS_ID = 6,
    VT_SAT_NO = 8,
    VT_ORIG_OBJECT_ID = 10,
    VT_EPOCH = 12,
    VT_REPRESENTATION = 14,
    VT_MOTION_TYPE = 16,
    VT_QC = 18,
    VT_Q1 = 20,
    VT_Q2 = 22,
    VT_Q3 = 24,
    VT_QC_DOT = 26,
    VT_Q1_DOT = 28,
    VT_Q2_DOT = 30,
    VT_Q3_DOT = 32,
    VT_X_ANGLE = 34,
    VT_Y_ANGLE = 36,
    VT_Z_ANGLE = 38,
    VT_X_RATE = 40,
    VT_Y_RATE = 42,
    VT_Z_RATE = 44,
    VT_RA = 46,
    VT_DECLINATION = 48,
    VT_CONING_ANGLE = 50,
    VT_PREC_PERIOD = 52,
    VT_SPIN_PERIOD = 54,
    VT_ATTITUDE_UNC = 56,
    VT_RATE_UNC = 58,
    VT_QUALITY = 60,
    VT_REF_FRAME = 62,
    VT_SENSOR_ID = 64
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Attitude set identifier (groups time-series points)
  const ::flatbuffers::String *AS_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AS_ID);
  }
  /// Satellite catalog number
  uint32_t SAT_NO() const {
    return GetField<uint32_t>(VT_SAT_NO, 0);
  }
  /// International designator
  const ::flatbuffers::String *ORIG_OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_OBJECT_ID);
  }
  /// Observation epoch (ISO 8601)
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// Attitude representation used
  attRepresentation REPRESENTATION() const {
    return static_cast<attRepresentation>(GetField<int8_t>(VT_REPRESENTATION, 0));
  }
  /// Motion characterization
  attMotionType MOTION_TYPE() const {
    return static_cast<attMotionType>(GetField<int8_t>(VT_MOTION_TYPE, 0));
  }
  /// Quaternion scalar component (q0 or qc)
  double QC() const {
    return GetField<double>(VT_QC, 0.0);
  }
  /// Quaternion vector component 1
  double Q1() const {
    return GetField<double>(VT_Q1, 0.0);
  }
  /// Quaternion vector component 2
  double Q2() const {
    return GetField<double>(VT_Q2, 0.0);
  }
  /// Quaternion vector component 3
  double Q3() const {
    return GetField<double>(VT_Q3, 0.0);
  }
  /// Quaternion scalar rate (rad/s)
  double QC_DOT() const {
    return GetField<double>(VT_QC_DOT, 0.0);
  }
  /// Quaternion vector rate 1 (rad/s)
  double Q1_DOT() const {
    return GetField<double>(VT_Q1_DOT, 0.0);
  }
  /// Quaternion vector rate 2 (rad/s)
  double Q2_DOT() const {
    return GetField<double>(VT_Q2_DOT, 0.0);
  }
  /// Quaternion vector rate 3 (rad/s)
  double Q3_DOT() const {
    return GetField<double>(VT_Q3_DOT, 0.0);
  }
  /// Euler angle X (degrees)
  double X_ANGLE() const {
    return GetField<double>(VT_X_ANGLE, 0.0);
  }
  /// Euler angle Y (degrees)
  double Y_ANGLE() const {
    return GetField<double>(VT_Y_ANGLE, 0.0);
  }
  /// Euler angle Z (degrees)
  double Z_ANGLE() const {
    return GetField<double>(VT_Z_ANGLE, 0.0);
  }
  /// Angular rate about X (deg/s)
  double X_RATE() const {
    return GetField<double>(VT_X_RATE, 0.0);
  }
  /// Angular rate about Y (deg/s)
  double Y_RATE() const {
    return GetField<double>(VT_Y_RATE, 0.0);
  }
  /// Angular rate about Z (deg/s)
  double Z_RATE() const {
    return GetField<double>(VT_Z_RATE, 0.0);
  }
  /// Right ascension of spin axis (degrees)
  double RA() const {
    return GetField<double>(VT_RA, 0.0);
  }
  /// Declination of spin axis (degrees)
  double DECLINATION() const {
    return GetField<double>(VT_DECLINATION, 0.0);
  }
  /// Coning half-angle (degrees)
  double CONING_ANGLE() const {
    return GetField<double>(VT_CONING_ANGLE, 0.0);
  }
  /// Precession period (seconds)
  double PREC_PERIOD() const {
    return GetField<double>(VT_PREC_PERIOD, 0.0);
  }
  /// Spin period (seconds)
  double SPIN_PERIOD() const {
    return GetField<double>(VT_SPIN_PERIOD, 0.0);
  }
  /// Attitude uncertainty (degrees, 1-sigma)
  double ATTITUDE_UNC() const {
    return GetField<double>(VT_ATTITUDE_UNC, 0.0);
  }
  /// Rate uncertainty (deg/s, 1-sigma)
  double RATE_UNC() const {
    return GetField<double>(VT_RATE_UNC, 0.0);
  }
  /// Data quality (0-9, 9=best)
  uint8_t QUALITY() const {
    return GetField<uint8_t>(VT_QUALITY, 0);
  }
  /// Reference frame for attitude
  const ::flatbuffers::String *REF_FRAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_FRAME);
  }
  /// Sensor identifier providing the observation
  const ::flatbuffers::String *SENSOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_AS_ID) &&
           verifier.VerifyString(AS_ID()) &&
           VerifyField<uint32_t>(verifier, VT_SAT_NO, 4) &&
           VerifyOffset(verifier, VT_ORIG_OBJECT_ID) &&
           verifier.VerifyString(ORIG_OBJECT_ID()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<int8_t>(verifier, VT_REPRESENTATION, 1) &&
           VerifyField<int8_t>(verifier, VT_MOTION_TYPE, 1) &&
           VerifyField<double>(verifier, VT_QC, 8) &&
           VerifyField<double>(verifier, VT_Q1, 8) &&
           VerifyField<double>(verifier, VT_Q2, 8) &&
           VerifyField<double>(verifier, VT_Q3, 8) &&
           VerifyField<double>(verifier, VT_QC_DOT, 8) &&
           VerifyField<double>(verifier, VT_Q1_DOT, 8) &&
           VerifyField<double>(verifier, VT_Q2_DOT, 8) &&
           VerifyField<double>(verifier, VT_Q3_DOT, 8) &&
           VerifyField<double>(verifier, VT_X_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_Y_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_Z_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_X_RATE, 8) &&
           VerifyField<double>(verifier, VT_Y_RATE, 8) &&
           VerifyField<double>(verifier, VT_Z_RATE, 8) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_DECLINATION, 8) &&
           VerifyField<double>(verifier, VT_CONING_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_PREC_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_SPIN_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_UNC, 8) &&
           VerifyField<double>(verifier, VT_RATE_UNC, 8) &&
           VerifyField<uint8_t>(verifier, VT_QUALITY, 1) &&
           VerifyOffset(verifier, VT_REF_FRAME) &&
           verifier.VerifyString(REF_FRAME()) &&
           VerifyOffset(verifier, VT_SENSOR_ID) &&
           verifier.VerifyString(SENSOR_ID()) &&
           verifier.EndTable();
  }
};

struct ATDBuilder {
  typedef ATD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(ATD::VT_ID, ID);
  }
  void add_AS_ID(::flatbuffers::Offset<::flatbuffers::String> AS_ID) {
    fbb_.AddOffset(ATD::VT_AS_ID, AS_ID);
  }
  void add_SAT_NO(uint32_t SAT_NO) {
    fbb_.AddElement<uint32_t>(ATD::VT_SAT_NO, SAT_NO, 0);
  }
  void add_ORIG_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID) {
    fbb_.AddOffset(ATD::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(ATD::VT_EPOCH, EPOCH);
  }
  void add_REPRESENTATION(attRepresentation REPRESENTATION) {
    fbb_.AddElement<int8_t>(ATD::VT_REPRESENTATION, static_cast<int8_t>(REPRESENTATION), 0);
  }
  void add_MOTION_TYPE(attMotionType MOTION_TYPE) {
    fbb_.AddElement<int8_t>(ATD::VT_MOTION_TYPE, static_cast<int8_t>(MOTION_TYPE), 0);
  }
  void add_QC(double QC) {
    fbb_.AddElement<double>(ATD::VT_QC, QC, 0.0);
  }
  void add_Q1(double Q1) {
    fbb_.AddElement<double>(ATD::VT_Q1, Q1, 0.0);
  }
  void add_Q2(double Q2) {
    fbb_.AddElement<double>(ATD::VT_Q2, Q2, 0.0);
  }
  void add_Q3(double Q3) {
    fbb_.AddElement<double>(ATD::VT_Q3, Q3, 0.0);
  }
  void add_QC_DOT(double QC_DOT) {
    fbb_.AddElement<double>(ATD::VT_QC_DOT, QC_DOT, 0.0);
  }
  void add_Q1_DOT(double Q1_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q1_DOT, Q1_DOT, 0.0);
  }
  void add_Q2_DOT(double Q2_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q2_DOT, Q2_DOT, 0.0);
  }
  void add_Q3_DOT(double Q3_DOT) {
    fbb_.AddElement<double>(ATD::VT_Q3_DOT, Q3_DOT, 0.0);
  }
  void add_X_ANGLE(double X_ANGLE) {
    fbb_.AddElement<double>(ATD::VT_X_ANGLE, X_ANGLE, 0.0);
  }
  void add_Y_ANGLE(double Y_ANGLE) {
    fbb_.AddElement<double>(ATD::VT_Y_ANGLE, Y_ANGLE, 0.0);
  }
  void add_Z_ANGLE(double Z_ANGLE) {
    fbb_.AddElement<double>(ATD::VT_Z_ANGLE, Z_ANGLE, 0.0);
  }
  void add_X_RATE(double X_RATE) {
    fbb_.AddElement<double>(ATD::VT_X_RATE, X_RATE, 0.0);
  }
  void add_Y_RATE(double Y_RATE) {
    fbb_.AddElement<double>(ATD::VT_Y_RATE, Y_RATE, 0.0);
  }
  void add_Z_RATE(double Z_RATE) {
    fbb_.AddElement<double>(ATD::VT_Z_RATE, Z_RATE, 0.0);
  }
  void add_RA(double RA) {
    fbb_.AddElement<double>(ATD::VT_RA, RA, 0.0);
  }
  void add_DECLINATION(double DECLINATION) {
    fbb_.AddElement<double>(ATD::VT_DECLINATION, DECLINATION, 0.0);
  }
  void add_CONING_ANGLE(double CONING_ANGLE) {
    fbb_.AddElement<double>(ATD::VT_CONING_ANGLE, CONING_ANGLE, 0.0);
  }
  void add_PREC_PERIOD(double PREC_PERIOD) {
    fbb_.AddElement<double>(ATD::VT_PREC_PERIOD, PREC_PERIOD, 0.0);
  }
  void add_SPIN_PERIOD(double SPIN_PERIOD) {
    fbb_.AddElement<double>(ATD::VT_SPIN_PERIOD, SPIN_PERIOD, 0.0);
  }
  void add_ATTITUDE_UNC(double ATTITUDE_UNC) {
    fbb_.AddElement<double>(ATD::VT_ATTITUDE_UNC, ATTITUDE_UNC, 0.0);
  }
  void add_RATE_UNC(double RATE_UNC) {
    fbb_.AddElement<double>(ATD::VT_RATE_UNC, RATE_UNC, 0.0);
  }
  void add_QUALITY(uint8_t QUALITY) {
    fbb_.AddElement<uint8_t>(ATD::VT_QUALITY, QUALITY, 0);
  }
  void add_REF_FRAME(::flatbuffers::Offset<::flatbuffers::String> REF_FRAME) {
    fbb_.AddOffset(ATD::VT_REF_FRAME, REF_FRAME);
  }
  void add_SENSOR_ID(::flatbuffers::Offset<::flatbuffers::String> SENSOR_ID) {
    fbb_.AddOffset(ATD::VT_SENSOR_ID, SENSOR_ID);
  }
  explicit ATDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ATD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ATD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ATD> CreateATD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AS_ID = 0,
    uint32_t SAT_NO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    attRepresentation REPRESENTATION = attRepresentation_QUATERNION,
    attMotionType MOTION_TYPE = attMotionType_STABILIZED,
    double QC = 0.0,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC_DOT = 0.0,
    double Q1_DOT = 0.0,
    double Q2_DOT = 0.0,
    double Q3_DOT = 0.0,
    double X_ANGLE = 0.0,
    double Y_ANGLE = 0.0,
    double Z_ANGLE = 0.0,
    double X_RATE = 0.0,
    double Y_RATE = 0.0,
    double Z_RATE = 0.0,
    double RA = 0.0,
    double DECLINATION = 0.0,
    double CONING_ANGLE = 0.0,
    double PREC_PERIOD = 0.0,
    double SPIN_PERIOD = 0.0,
    double ATTITUDE_UNC = 0.0,
    double RATE_UNC = 0.0,
    uint8_t QUALITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REF_FRAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SENSOR_ID = 0) {
  ATDBuilder builder_(_fbb);
  builder_.add_RATE_UNC(RATE_UNC);
  builder_.add_ATTITUDE_UNC(ATTITUDE_UNC);
  builder_.add_SPIN_PERIOD(SPIN_PERIOD);
  builder_.add_PREC_PERIOD(PREC_PERIOD);
  builder_.add_CONING_ANGLE(CONING_ANGLE);
  builder_.add_DECLINATION(DECLINATION);
  builder_.add_RA(RA);
  builder_.add_Z_RATE(Z_RATE);
  builder_.add_Y_RATE(Y_RATE);
  builder_.add_X_RATE(X_RATE);
  builder_.add_Z_ANGLE(Z_ANGLE);
  builder_.add_Y_ANGLE(Y_ANGLE);
  builder_.add_X_ANGLE(X_ANGLE);
  builder_.add_Q3_DOT(Q3_DOT);
  builder_.add_Q2_DOT(Q2_DOT);
  builder_.add_Q1_DOT(Q1_DOT);
  builder_.add_QC_DOT(QC_DOT);
  builder_.add_Q3(Q3);
  builder_.add_Q2(Q2);
  builder_.add_Q1(Q1);
  builder_.add_QC(QC);
  builder_.add_SENSOR_ID(SENSOR_ID);
  builder_.add_REF_FRAME(REF_FRAME);
  builder_.add_EPOCH(EPOCH);
  builder_.add_ORIG_OBJECT_ID(ORIG_OBJECT_ID);
  builder_.add_SAT_NO(SAT_NO);
  builder_.add_AS_ID(AS_ID);
  builder_.add_ID(ID);
  builder_.add_QUALITY(QUALITY);
  builder_.add_MOTION_TYPE(MOTION_TYPE);
  builder_.add_REPRESENTATION(REPRESENTATION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ATD> CreateATDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *AS_ID = nullptr,
    uint32_t SAT_NO = 0,
    const char *ORIG_OBJECT_ID = nullptr,
    const char *EPOCH = nullptr,
    attRepresentation REPRESENTATION = attRepresentation_QUATERNION,
    attMotionType MOTION_TYPE = attMotionType_STABILIZED,
    double QC = 0.0,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC_DOT = 0.0,
    double Q1_DOT = 0.0,
    double Q2_DOT = 0.0,
    double Q3_DOT = 0.0,
    double X_ANGLE = 0.0,
    double Y_ANGLE = 0.0,
    double Z_ANGLE = 0.0,
    double X_RATE = 0.0,
    double Y_RATE = 0.0,
    double Z_RATE = 0.0,
    double RA = 0.0,
    double DECLINATION = 0.0,
    double CONING_ANGLE = 0.0,
    double PREC_PERIOD = 0.0,
    double SPIN_PERIOD = 0.0,
    double ATTITUDE_UNC = 0.0,
    double RATE_UNC = 0.0,
    uint8_t QUALITY = 0,
    const char *REF_FRAME = nullptr,
    const char *SENSOR_ID = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto AS_ID__ = AS_ID ? _fbb.CreateString(AS_ID) : 0;
  auto ORIG_OBJECT_ID__ = ORIG_OBJECT_ID ? _fbb.CreateString(ORIG_OBJECT_ID) : 0;
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  auto REF_FRAME__ = REF_FRAME ? _fbb.CreateString(REF_FRAME) : 0;
  auto SENSOR_ID__ = SENSOR_ID ? _fbb.CreateString(SENSOR_ID) : 0;
  return CreateATD(
      _fbb,
      ID__,
      AS_ID__,
      SAT_NO,
      ORIG_OBJECT_ID__,
      EPOCH__,
      REPRESENTATION,
      MOTION_TYPE,
      QC,
      Q1,
      Q2,
      Q3,
      QC_DOT,
      Q1_DOT,
      Q2_DOT,
      Q3_DOT,
      X_ANGLE,
      Y_ANGLE,
      Z_ANGLE,
      X_RATE,
      Y_RATE,
      Z_RATE,
      RA,
      DECLINATION,
      CONING_ANGLE,
      PREC_PERIOD,
      SPIN_PERIOD,
      ATTITUDE_UNC,
      RATE_UNC,
      QUALITY,
      REF_FRAME__,
      SENSOR_ID__);
}

inline const ATD *GetATD(const void *buf) {
  return ::flatbuffers::GetRoot<ATD>(buf);
}

inline const ATD *GetSizePrefixedATD(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ATD>(buf);
}

inline const char *ATDIdentifier() {
  return "$ATD";
}

inline bool ATDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ATDIdentifier());
}

inline bool SizePrefixedATDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ATDIdentifier(), true);
}

inline bool VerifyATDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ATD>(ATDIdentifier());
}

inline bool VerifySizePrefixedATDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ATD>(ATDIdentifier());
}

inline void FinishATDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ATD> root) {
  fbb.Finish(root, ATDIdentifier());
}

inline void FinishSizePrefixedATDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ATD> root) {
  fbb.FinishSizePrefixed(root, ATDIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
