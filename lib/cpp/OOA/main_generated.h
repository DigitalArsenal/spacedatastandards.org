// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OOA;
struct OOABuilder;

/// On-Orbit Antenna
struct OOA FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OOABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ID_ON_ORBIT = 6,
    VT_ID_ANTENNA = 8,
    VT_NAME = 10,
    VT_ANTENNA_TYPE = 12,
    VT_QUANTITY = 14,
    VT_BAND = 16,
    VT_FREQ_MIN = 18,
    VT_FREQ_MAX = 20,
    VT_GAIN = 22,
    VT_APERTURE = 24,
    VT_BEAMWIDTH = 26,
    VT_POLARIZATION = 28,
    VT_STEERABLE = 30,
    VT_SLEW_RATE = 32,
    VT_PURPOSE = 34,
    VT_NOTES = 36
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Reference to parent on-orbit object
  const ::flatbuffers::String *ID_ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ON_ORBIT);
  }
  /// Reference to antenna specification
  const ::flatbuffers::String *ID_ANTENNA() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ANTENNA);
  }
  /// Antenna name or designation
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Antenna type (e.g., PARABOLIC, PHASED_ARRAY, HORN, HELICAL, DIPOLE, PATCH, YAGI)
  const ::flatbuffers::String *ANTENNA_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANTENNA_TYPE);
  }
  /// Number of antennas of this type
  uint32_t QUANTITY() const {
    return GetField<uint32_t>(VT_QUANTITY, 0);
  }
  /// Operating frequency band (e.g., UHF, L, S, C, X, Ku, Ka, V, W)
  const ::flatbuffers::String *BAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BAND);
  }
  /// Minimum operating frequency in MHz
  double FREQ_MIN() const {
    return GetField<double>(VT_FREQ_MIN, 0.0);
  }
  /// Maximum operating frequency in MHz
  double FREQ_MAX() const {
    return GetField<double>(VT_FREQ_MAX, 0.0);
  }
  /// Antenna gain in dBi
  double GAIN() const {
    return GetField<double>(VT_GAIN, 0.0);
  }
  /// Antenna diameter or aperture in meters
  double APERTURE() const {
    return GetField<double>(VT_APERTURE, 0.0);
  }
  /// Beamwidth in degrees
  double BEAMWIDTH() const {
    return GetField<double>(VT_BEAMWIDTH, 0.0);
  }
  /// Polarization type (e.g., LINEAR, CIRCULAR, DUAL, RHCP, LHCP)
  const ::flatbuffers::String *POLARIZATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POLARIZATION);
  }
  /// Whether the antenna is steerable
  bool STEERABLE() const {
    return GetField<uint8_t>(VT_STEERABLE, 0) != 0;
  }
  /// Maximum slew rate in degrees per second
  double SLEW_RATE() const {
    return GetField<double>(VT_SLEW_RATE, 0.0);
  }
  /// Purpose or function (e.g., TT_C, PAYLOAD, CROSSLINK, GPS)
  const ::flatbuffers::String *PURPOSE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PURPOSE);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_ID_ON_ORBIT) &&
           verifier.VerifyString(ID_ON_ORBIT()) &&
           VerifyOffset(verifier, VT_ID_ANTENNA) &&
           verifier.VerifyString(ID_ANTENNA()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_ANTENNA_TYPE) &&
           verifier.VerifyString(ANTENNA_TYPE()) &&
           VerifyField<uint32_t>(verifier, VT_QUANTITY, 4) &&
           VerifyOffset(verifier, VT_BAND) &&
           verifier.VerifyString(BAND()) &&
           VerifyField<double>(verifier, VT_FREQ_MIN, 8) &&
           VerifyField<double>(verifier, VT_FREQ_MAX, 8) &&
           VerifyField<double>(verifier, VT_GAIN, 8) &&
           VerifyField<double>(verifier, VT_APERTURE, 8) &&
           VerifyField<double>(verifier, VT_BEAMWIDTH, 8) &&
           VerifyOffset(verifier, VT_POLARIZATION) &&
           verifier.VerifyString(POLARIZATION()) &&
           VerifyField<uint8_t>(verifier, VT_STEERABLE, 1) &&
           VerifyField<double>(verifier, VT_SLEW_RATE, 8) &&
           VerifyOffset(verifier, VT_PURPOSE) &&
           verifier.VerifyString(PURPOSE()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct OOABuilder {
  typedef OOA Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(OOA::VT_ID, ID);
  }
  void add_ID_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT) {
    fbb_.AddOffset(OOA::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  void add_ID_ANTENNA(::flatbuffers::Offset<::flatbuffers::String> ID_ANTENNA) {
    fbb_.AddOffset(OOA::VT_ID_ANTENNA, ID_ANTENNA);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(OOA::VT_NAME, NAME);
  }
  void add_ANTENNA_TYPE(::flatbuffers::Offset<::flatbuffers::String> ANTENNA_TYPE) {
    fbb_.AddOffset(OOA::VT_ANTENNA_TYPE, ANTENNA_TYPE);
  }
  void add_QUANTITY(uint32_t QUANTITY) {
    fbb_.AddElement<uint32_t>(OOA::VT_QUANTITY, QUANTITY, 0);
  }
  void add_BAND(::flatbuffers::Offset<::flatbuffers::String> BAND) {
    fbb_.AddOffset(OOA::VT_BAND, BAND);
  }
  void add_FREQ_MIN(double FREQ_MIN) {
    fbb_.AddElement<double>(OOA::VT_FREQ_MIN, FREQ_MIN, 0.0);
  }
  void add_FREQ_MAX(double FREQ_MAX) {
    fbb_.AddElement<double>(OOA::VT_FREQ_MAX, FREQ_MAX, 0.0);
  }
  void add_GAIN(double GAIN) {
    fbb_.AddElement<double>(OOA::VT_GAIN, GAIN, 0.0);
  }
  void add_APERTURE(double APERTURE) {
    fbb_.AddElement<double>(OOA::VT_APERTURE, APERTURE, 0.0);
  }
  void add_BEAMWIDTH(double BEAMWIDTH) {
    fbb_.AddElement<double>(OOA::VT_BEAMWIDTH, BEAMWIDTH, 0.0);
  }
  void add_POLARIZATION(::flatbuffers::Offset<::flatbuffers::String> POLARIZATION) {
    fbb_.AddOffset(OOA::VT_POLARIZATION, POLARIZATION);
  }
  void add_STEERABLE(bool STEERABLE) {
    fbb_.AddElement<uint8_t>(OOA::VT_STEERABLE, static_cast<uint8_t>(STEERABLE), 0);
  }
  void add_SLEW_RATE(double SLEW_RATE) {
    fbb_.AddElement<double>(OOA::VT_SLEW_RATE, SLEW_RATE, 0.0);
  }
  void add_PURPOSE(::flatbuffers::Offset<::flatbuffers::String> PURPOSE) {
    fbb_.AddOffset(OOA::VT_PURPOSE, PURPOSE);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(OOA::VT_NOTES, NOTES);
  }
  explicit OOABuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OOA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OOA>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OOA> CreateOOA(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ANTENNA = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ANTENNA_TYPE = 0,
    uint32_t QUANTITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> BAND = 0,
    double FREQ_MIN = 0.0,
    double FREQ_MAX = 0.0,
    double GAIN = 0.0,
    double APERTURE = 0.0,
    double BEAMWIDTH = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> POLARIZATION = 0,
    bool STEERABLE = false,
    double SLEW_RATE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> PURPOSE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  OOABuilder builder_(_fbb);
  builder_.add_SLEW_RATE(SLEW_RATE);
  builder_.add_BEAMWIDTH(BEAMWIDTH);
  builder_.add_APERTURE(APERTURE);
  builder_.add_GAIN(GAIN);
  builder_.add_FREQ_MAX(FREQ_MAX);
  builder_.add_FREQ_MIN(FREQ_MIN);
  builder_.add_NOTES(NOTES);
  builder_.add_PURPOSE(PURPOSE);
  builder_.add_POLARIZATION(POLARIZATION);
  builder_.add_BAND(BAND);
  builder_.add_QUANTITY(QUANTITY);
  builder_.add_ANTENNA_TYPE(ANTENNA_TYPE);
  builder_.add_NAME(NAME);
  builder_.add_ID_ANTENNA(ID_ANTENNA);
  builder_.add_ID_ON_ORBIT(ID_ON_ORBIT);
  builder_.add_ID(ID);
  builder_.add_STEERABLE(STEERABLE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OOA> CreateOOADirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *ID_ON_ORBIT = nullptr,
    const char *ID_ANTENNA = nullptr,
    const char *NAME = nullptr,
    const char *ANTENNA_TYPE = nullptr,
    uint32_t QUANTITY = 0,
    const char *BAND = nullptr,
    double FREQ_MIN = 0.0,
    double FREQ_MAX = 0.0,
    double GAIN = 0.0,
    double APERTURE = 0.0,
    double BEAMWIDTH = 0.0,
    const char *POLARIZATION = nullptr,
    bool STEERABLE = false,
    double SLEW_RATE = 0.0,
    const char *PURPOSE = nullptr,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto ID_ON_ORBIT__ = ID_ON_ORBIT ? _fbb.CreateString(ID_ON_ORBIT) : 0;
  auto ID_ANTENNA__ = ID_ANTENNA ? _fbb.CreateString(ID_ANTENNA) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto ANTENNA_TYPE__ = ANTENNA_TYPE ? _fbb.CreateString(ANTENNA_TYPE) : 0;
  auto BAND__ = BAND ? _fbb.CreateString(BAND) : 0;
  auto POLARIZATION__ = POLARIZATION ? _fbb.CreateString(POLARIZATION) : 0;
  auto PURPOSE__ = PURPOSE ? _fbb.CreateString(PURPOSE) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateOOA(
      _fbb,
      ID__,
      ID_ON_ORBIT__,
      ID_ANTENNA__,
      NAME__,
      ANTENNA_TYPE__,
      QUANTITY,
      BAND__,
      FREQ_MIN,
      FREQ_MAX,
      GAIN,
      APERTURE,
      BEAMWIDTH,
      POLARIZATION__,
      STEERABLE,
      SLEW_RATE,
      PURPOSE__,
      NOTES__);
}

inline const OOA *GetOOA(const void *buf) {
  return ::flatbuffers::GetRoot<OOA>(buf);
}

inline const OOA *GetSizePrefixedOOA(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OOA>(buf);
}

inline const char *OOAIdentifier() {
  return "$OOA";
}

inline bool OOABufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOAIdentifier());
}

inline bool SizePrefixedOOABufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOAIdentifier(), true);
}

inline bool VerifyOOABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OOA>(OOAIdentifier());
}

inline bool VerifySizePrefixedOOABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OOA>(OOAIdentifier());
}

inline void FinishOOABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOA> root) {
  fbb.Finish(root, OOAIdentifier());
}

inline void FinishSizePrefixedOOABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOA> root) {
  fbb.FinishSizePrefixed(root, OOAIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
