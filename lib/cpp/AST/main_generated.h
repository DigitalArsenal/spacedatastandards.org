// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AST;
struct ASTBuilder;

enum PropagatorMethod : int8_t {
  PropagatorMethod_KEPLER = 0,
  PropagatorMethod_SGP4 = 1,
  PropagatorMethod_SDP4 = 2,
  PropagatorMethod_HPOP = 3,
  PropagatorMethod_COWELL = 4,
  PropagatorMethod_ENCKE = 5,
  PropagatorMethod_GAUSS_JACKSON = 6,
  PropagatorMethod_RK78 = 7,
  PropagatorMethod_BROUWER = 8,
  PropagatorMethod_KOZAI = 9,
  PropagatorMethod_DSST = 10,
  PropagatorMethod_MIN = PropagatorMethod_KEPLER,
  PropagatorMethod_MAX = PropagatorMethod_DSST
};

inline const PropagatorMethod (&EnumValuesPropagatorMethod())[11] {
  static const PropagatorMethod values[] = {
    PropagatorMethod_KEPLER,
    PropagatorMethod_SGP4,
    PropagatorMethod_SDP4,
    PropagatorMethod_HPOP,
    PropagatorMethod_COWELL,
    PropagatorMethod_ENCKE,
    PropagatorMethod_GAUSS_JACKSON,
    PropagatorMethod_RK78,
    PropagatorMethod_BROUWER,
    PropagatorMethod_KOZAI,
    PropagatorMethod_DSST
  };
  return values;
}

inline const char * const *EnumNamesPropagatorMethod() {
  static const char * const names[12] = {
    "KEPLER",
    "SGP4",
    "SDP4",
    "HPOP",
    "COWELL",
    "ENCKE",
    "GAUSS_JACKSON",
    "RK78",
    "BROUWER",
    "KOZAI",
    "DSST",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropagatorMethod(PropagatorMethod e) {
  if (::flatbuffers::IsOutRange(e, PropagatorMethod_KEPLER, PropagatorMethod_DSST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropagatorMethod()[index];
}

enum ForceModel : int8_t {
  ForceModel_POINT_MASS = 0,
  ForceModel_J2 = 1,
  ForceModel_J2_J4 = 2,
  ForceModel_SPHERICAL_HARMONICS = 3,
  ForceModel_THIRD_BODY_SUN = 4,
  ForceModel_THIRD_BODY_MOON = 5,
  ForceModel_ATMOSPHERIC_DRAG = 6,
  ForceModel_SOLAR_RADIATION_PRESSURE = 7,
  ForceModel_RELATIVISTIC = 8,
  ForceModel_SOLID_TIDES = 9,
  ForceModel_OCEAN_TIDES = 10,
  ForceModel_MANEUVER = 11,
  ForceModel_MIN = ForceModel_POINT_MASS,
  ForceModel_MAX = ForceModel_MANEUVER
};

inline const ForceModel (&EnumValuesForceModel())[12] {
  static const ForceModel values[] = {
    ForceModel_POINT_MASS,
    ForceModel_J2,
    ForceModel_J2_J4,
    ForceModel_SPHERICAL_HARMONICS,
    ForceModel_THIRD_BODY_SUN,
    ForceModel_THIRD_BODY_MOON,
    ForceModel_ATMOSPHERIC_DRAG,
    ForceModel_SOLAR_RADIATION_PRESSURE,
    ForceModel_RELATIVISTIC,
    ForceModel_SOLID_TIDES,
    ForceModel_OCEAN_TIDES,
    ForceModel_MANEUVER
  };
  return values;
}

inline const char * const *EnumNamesForceModel() {
  static const char * const names[13] = {
    "POINT_MASS",
    "J2",
    "J2_J4",
    "SPHERICAL_HARMONICS",
    "THIRD_BODY_SUN",
    "THIRD_BODY_MOON",
    "ATMOSPHERIC_DRAG",
    "SOLAR_RADIATION_PRESSURE",
    "RELATIVISTIC",
    "SOLID_TIDES",
    "OCEAN_TIDES",
    "MANEUVER",
    nullptr
  };
  return names;
}

inline const char *EnumNameForceModel(ForceModel e) {
  if (::flatbuffers::IsOutRange(e, ForceModel_POINT_MASS, ForceModel_MANEUVER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForceModel()[index];
}

enum OrbitalRegime : int8_t {
  OrbitalRegime_LEO = 0,
  OrbitalRegime_MEO = 1,
  OrbitalRegime_GEO = 2,
  OrbitalRegime_HEO = 3,
  OrbitalRegime_SSO = 4,
  OrbitalRegime_MOLNIYA = 5,
  OrbitalRegime_TUNDRA = 6,
  OrbitalRegime_POLAR = 7,
  OrbitalRegime_EQUATORIAL = 8,
  OrbitalRegime_HYPERBOLIC = 9,
  OrbitalRegime_PARABOLIC = 10,
  OrbitalRegime_MIN = OrbitalRegime_LEO,
  OrbitalRegime_MAX = OrbitalRegime_PARABOLIC
};

inline const OrbitalRegime (&EnumValuesOrbitalRegime())[11] {
  static const OrbitalRegime values[] = {
    OrbitalRegime_LEO,
    OrbitalRegime_MEO,
    OrbitalRegime_GEO,
    OrbitalRegime_HEO,
    OrbitalRegime_SSO,
    OrbitalRegime_MOLNIYA,
    OrbitalRegime_TUNDRA,
    OrbitalRegime_POLAR,
    OrbitalRegime_EQUATORIAL,
    OrbitalRegime_HYPERBOLIC,
    OrbitalRegime_PARABOLIC
  };
  return values;
}

inline const char * const *EnumNamesOrbitalRegime() {
  static const char * const names[12] = {
    "LEO",
    "MEO",
    "GEO",
    "HEO",
    "SSO",
    "MOLNIYA",
    "TUNDRA",
    "POLAR",
    "EQUATORIAL",
    "HYPERBOLIC",
    "PARABOLIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrbitalRegime(OrbitalRegime e) {
  if (::flatbuffers::IsOutRange(e, OrbitalRegime_LEO, OrbitalRegime_PARABOLIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrbitalRegime()[index];
}

enum TimeReference : int8_t {
  TimeReference_UTC = 0,
  TimeReference_TAI = 1,
  TimeReference_TT = 2,
  TimeReference_TDB = 3,
  TimeReference_GPS_TIME = 4,
  TimeReference_JULIAN_DATE = 5,
  TimeReference_MODIFIED_JULIAN_DATE = 6,
  TimeReference_MIN = TimeReference_UTC,
  TimeReference_MAX = TimeReference_MODIFIED_JULIAN_DATE
};

inline const TimeReference (&EnumValuesTimeReference())[7] {
  static const TimeReference values[] = {
    TimeReference_UTC,
    TimeReference_TAI,
    TimeReference_TT,
    TimeReference_TDB,
    TimeReference_GPS_TIME,
    TimeReference_JULIAN_DATE,
    TimeReference_MODIFIED_JULIAN_DATE
  };
  return values;
}

inline const char * const *EnumNamesTimeReference() {
  static const char * const names[8] = {
    "UTC",
    "TAI",
    "TT",
    "TDB",
    "GPS_TIME",
    "JULIAN_DATE",
    "MODIFIED_JULIAN_DATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeReference(TimeReference e) {
  if (::flatbuffers::IsOutRange(e, TimeReference_UTC, TimeReference_MODIFIED_JULIAN_DATE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeReference()[index];
}

enum ReferenceFrame : int8_t {
  ReferenceFrame_ECI_J2000 = 0,
  ReferenceFrame_ECEF = 1,
  ReferenceFrame_TEME = 2,
  ReferenceFrame_GCRF = 3,
  ReferenceFrame_ITRF = 4,
  ReferenceFrame_RIC = 5,
  ReferenceFrame_VNC = 6,
  ReferenceFrame_NTW = 7,
  ReferenceFrame_SEZ = 8,
  ReferenceFrame_LVLH = 9,
  ReferenceFrame_MIN = ReferenceFrame_ECI_J2000,
  ReferenceFrame_MAX = ReferenceFrame_LVLH
};

inline const ReferenceFrame (&EnumValuesReferenceFrame())[10] {
  static const ReferenceFrame values[] = {
    ReferenceFrame_ECI_J2000,
    ReferenceFrame_ECEF,
    ReferenceFrame_TEME,
    ReferenceFrame_GCRF,
    ReferenceFrame_ITRF,
    ReferenceFrame_RIC,
    ReferenceFrame_VNC,
    ReferenceFrame_NTW,
    ReferenceFrame_SEZ,
    ReferenceFrame_LVLH
  };
  return values;
}

inline const char * const *EnumNamesReferenceFrame() {
  static const char * const names[11] = {
    "ECI_J2000",
    "ECEF",
    "TEME",
    "GCRF",
    "ITRF",
    "RIC",
    "VNC",
    "NTW",
    "SEZ",
    "LVLH",
    nullptr
  };
  return names;
}

inline const char *EnumNameReferenceFrame(ReferenceFrame e) {
  if (::flatbuffers::IsOutRange(e, ReferenceFrame_ECI_J2000, ReferenceFrame_LVLH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReferenceFrame()[index];
}

/// Astrodynamics
struct AST FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ASTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_PROPAGATION_REQUEST = 6,
    VT_TLE = 8,
    VT_INITIAL_ELEMENTS = 10,
    VT_INITIAL_STATE = 12,
    VT_EPOCH_MS = 14,
    VT_MANEUVER_PLAN = 16,
    VT_CONJUNCTION_PRIMARY = 18,
    VT_CONJUNCTION_SECONDARY = 20,
    VT_OBSERVATIONS = 22,
    VT_OD_CONFIG = 24,
    VT_GROUND_STATION = 26,
    VT_FORMATION_CONFIG = 28,
    VT_TARGET_ELEMENTS = 30
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *PROPAGATION_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROPAGATION_REQUEST);
  }
  const ::flatbuffers::String *TLE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TLE);
  }
  const ::flatbuffers::String *INITIAL_ELEMENTS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_ELEMENTS);
  }
  const ::flatbuffers::String *INITIAL_STATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_STATE);
  }
  int64_t EPOCH_MS() const {
    return GetField<int64_t>(VT_EPOCH_MS, 0);
  }
  const ::flatbuffers::String *MANEUVER_PLAN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANEUVER_PLAN);
  }
  const ::flatbuffers::String *CONJUNCTION_PRIMARY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONJUNCTION_PRIMARY);
  }
  const ::flatbuffers::String *CONJUNCTION_SECONDARY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONJUNCTION_SECONDARY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *OBSERVATIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OBSERVATIONS);
  }
  const ::flatbuffers::String *OD_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OD_CONFIG);
  }
  const ::flatbuffers::String *GROUND_STATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUND_STATION);
  }
  const ::flatbuffers::String *FORMATION_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FORMATION_CONFIG);
  }
  const ::flatbuffers::String *TARGET_ELEMENTS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_PROPAGATION_REQUEST) &&
           verifier.VerifyString(PROPAGATION_REQUEST()) &&
           VerifyOffset(verifier, VT_TLE) &&
           verifier.VerifyString(TLE()) &&
           VerifyOffset(verifier, VT_INITIAL_ELEMENTS) &&
           verifier.VerifyString(INITIAL_ELEMENTS()) &&
           VerifyOffset(verifier, VT_INITIAL_STATE) &&
           verifier.VerifyString(INITIAL_STATE()) &&
           VerifyField<int64_t>(verifier, VT_EPOCH_MS, 8) &&
           VerifyOffset(verifier, VT_MANEUVER_PLAN) &&
           verifier.VerifyString(MANEUVER_PLAN()) &&
           VerifyOffset(verifier, VT_CONJUNCTION_PRIMARY) &&
           verifier.VerifyString(CONJUNCTION_PRIMARY()) &&
           VerifyOffset(verifier, VT_CONJUNCTION_SECONDARY) &&
           verifier.VerifyString(CONJUNCTION_SECONDARY()) &&
           VerifyOffset(verifier, VT_OBSERVATIONS) &&
           verifier.VerifyVector(OBSERVATIONS()) &&
           verifier.VerifyVectorOfStrings(OBSERVATIONS()) &&
           VerifyOffset(verifier, VT_OD_CONFIG) &&
           verifier.VerifyString(OD_CONFIG()) &&
           VerifyOffset(verifier, VT_GROUND_STATION) &&
           verifier.VerifyString(GROUND_STATION()) &&
           VerifyOffset(verifier, VT_FORMATION_CONFIG) &&
           verifier.VerifyString(FORMATION_CONFIG()) &&
           VerifyOffset(verifier, VT_TARGET_ELEMENTS) &&
           verifier.VerifyString(TARGET_ELEMENTS()) &&
           verifier.EndTable();
  }
};

struct ASTBuilder {
  typedef AST Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(AST::VT_COMMAND, COMMAND);
  }
  void add_PROPAGATION_REQUEST(::flatbuffers::Offset<::flatbuffers::String> PROPAGATION_REQUEST) {
    fbb_.AddOffset(AST::VT_PROPAGATION_REQUEST, PROPAGATION_REQUEST);
  }
  void add_TLE(::flatbuffers::Offset<::flatbuffers::String> TLE) {
    fbb_.AddOffset(AST::VT_TLE, TLE);
  }
  void add_INITIAL_ELEMENTS(::flatbuffers::Offset<::flatbuffers::String> INITIAL_ELEMENTS) {
    fbb_.AddOffset(AST::VT_INITIAL_ELEMENTS, INITIAL_ELEMENTS);
  }
  void add_INITIAL_STATE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_STATE) {
    fbb_.AddOffset(AST::VT_INITIAL_STATE, INITIAL_STATE);
  }
  void add_EPOCH_MS(int64_t EPOCH_MS) {
    fbb_.AddElement<int64_t>(AST::VT_EPOCH_MS, EPOCH_MS, 0);
  }
  void add_MANEUVER_PLAN(::flatbuffers::Offset<::flatbuffers::String> MANEUVER_PLAN) {
    fbb_.AddOffset(AST::VT_MANEUVER_PLAN, MANEUVER_PLAN);
  }
  void add_CONJUNCTION_PRIMARY(::flatbuffers::Offset<::flatbuffers::String> CONJUNCTION_PRIMARY) {
    fbb_.AddOffset(AST::VT_CONJUNCTION_PRIMARY, CONJUNCTION_PRIMARY);
  }
  void add_CONJUNCTION_SECONDARY(::flatbuffers::Offset<::flatbuffers::String> CONJUNCTION_SECONDARY) {
    fbb_.AddOffset(AST::VT_CONJUNCTION_SECONDARY, CONJUNCTION_SECONDARY);
  }
  void add_OBSERVATIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OBSERVATIONS) {
    fbb_.AddOffset(AST::VT_OBSERVATIONS, OBSERVATIONS);
  }
  void add_OD_CONFIG(::flatbuffers::Offset<::flatbuffers::String> OD_CONFIG) {
    fbb_.AddOffset(AST::VT_OD_CONFIG, OD_CONFIG);
  }
  void add_GROUND_STATION(::flatbuffers::Offset<::flatbuffers::String> GROUND_STATION) {
    fbb_.AddOffset(AST::VT_GROUND_STATION, GROUND_STATION);
  }
  void add_FORMATION_CONFIG(::flatbuffers::Offset<::flatbuffers::String> FORMATION_CONFIG) {
    fbb_.AddOffset(AST::VT_FORMATION_CONFIG, FORMATION_CONFIG);
  }
  void add_TARGET_ELEMENTS(::flatbuffers::Offset<::flatbuffers::String> TARGET_ELEMENTS) {
    fbb_.AddOffset(AST::VT_TARGET_ELEMENTS, TARGET_ELEMENTS);
  }
  explicit ASTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AST>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AST> CreateAST(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROPAGATION_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TLE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_ELEMENTS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_STATE = 0,
    int64_t EPOCH_MS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MANEUVER_PLAN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONJUNCTION_PRIMARY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONJUNCTION_SECONDARY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OBSERVATIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OD_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GROUND_STATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FORMATION_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TARGET_ELEMENTS = 0) {
  ASTBuilder builder_(_fbb);
  builder_.add_EPOCH_MS(EPOCH_MS);
  builder_.add_TARGET_ELEMENTS(TARGET_ELEMENTS);
  builder_.add_FORMATION_CONFIG(FORMATION_CONFIG);
  builder_.add_GROUND_STATION(GROUND_STATION);
  builder_.add_OD_CONFIG(OD_CONFIG);
  builder_.add_OBSERVATIONS(OBSERVATIONS);
  builder_.add_CONJUNCTION_SECONDARY(CONJUNCTION_SECONDARY);
  builder_.add_CONJUNCTION_PRIMARY(CONJUNCTION_PRIMARY);
  builder_.add_MANEUVER_PLAN(MANEUVER_PLAN);
  builder_.add_INITIAL_STATE(INITIAL_STATE);
  builder_.add_INITIAL_ELEMENTS(INITIAL_ELEMENTS);
  builder_.add_TLE(TLE);
  builder_.add_PROPAGATION_REQUEST(PROPAGATION_REQUEST);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AST> CreateASTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *PROPAGATION_REQUEST = nullptr,
    const char *TLE = nullptr,
    const char *INITIAL_ELEMENTS = nullptr,
    const char *INITIAL_STATE = nullptr,
    int64_t EPOCH_MS = 0,
    const char *MANEUVER_PLAN = nullptr,
    const char *CONJUNCTION_PRIMARY = nullptr,
    const char *CONJUNCTION_SECONDARY = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *OBSERVATIONS = nullptr,
    const char *OD_CONFIG = nullptr,
    const char *GROUND_STATION = nullptr,
    const char *FORMATION_CONFIG = nullptr,
    const char *TARGET_ELEMENTS = nullptr) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto PROPAGATION_REQUEST__ = PROPAGATION_REQUEST ? _fbb.CreateString(PROPAGATION_REQUEST) : 0;
  auto TLE__ = TLE ? _fbb.CreateString(TLE) : 0;
  auto INITIAL_ELEMENTS__ = INITIAL_ELEMENTS ? _fbb.CreateString(INITIAL_ELEMENTS) : 0;
  auto INITIAL_STATE__ = INITIAL_STATE ? _fbb.CreateString(INITIAL_STATE) : 0;
  auto MANEUVER_PLAN__ = MANEUVER_PLAN ? _fbb.CreateString(MANEUVER_PLAN) : 0;
  auto CONJUNCTION_PRIMARY__ = CONJUNCTION_PRIMARY ? _fbb.CreateString(CONJUNCTION_PRIMARY) : 0;
  auto CONJUNCTION_SECONDARY__ = CONJUNCTION_SECONDARY ? _fbb.CreateString(CONJUNCTION_SECONDARY) : 0;
  auto OBSERVATIONS__ = OBSERVATIONS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*OBSERVATIONS) : 0;
  auto OD_CONFIG__ = OD_CONFIG ? _fbb.CreateString(OD_CONFIG) : 0;
  auto GROUND_STATION__ = GROUND_STATION ? _fbb.CreateString(GROUND_STATION) : 0;
  auto FORMATION_CONFIG__ = FORMATION_CONFIG ? _fbb.CreateString(FORMATION_CONFIG) : 0;
  auto TARGET_ELEMENTS__ = TARGET_ELEMENTS ? _fbb.CreateString(TARGET_ELEMENTS) : 0;
  return CreateAST(
      _fbb,
      COMMAND__,
      PROPAGATION_REQUEST__,
      TLE__,
      INITIAL_ELEMENTS__,
      INITIAL_STATE__,
      EPOCH_MS,
      MANEUVER_PLAN__,
      CONJUNCTION_PRIMARY__,
      CONJUNCTION_SECONDARY__,
      OBSERVATIONS__,
      OD_CONFIG__,
      GROUND_STATION__,
      FORMATION_CONFIG__,
      TARGET_ELEMENTS__);
}

inline const AST *GetAST(const void *buf) {
  return ::flatbuffers::GetRoot<AST>(buf);
}

inline const AST *GetSizePrefixedAST(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AST>(buf);
}

inline const char *ASTIdentifier() {
  return "$AST";
}

inline bool ASTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ASTIdentifier());
}

inline bool SizePrefixedASTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ASTIdentifier(), true);
}

inline bool VerifyASTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AST>(ASTIdentifier());
}

inline bool VerifySizePrefixedASTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AST>(ASTIdentifier());
}

inline void FinishASTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AST> root) {
  fbb.Finish(root, ASTIdentifier());
}

inline void FinishSizePrefixedASTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AST> root) {
  fbb.FinishSizePrefixed(root, ASTIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
