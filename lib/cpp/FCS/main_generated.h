// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct FCS;
struct FCSBuilder;

enum FCSMode : int8_t {
  FCSMode_OFF = 0,
  FCSMode_STANDBY = 1,
  FCSMode_RANGING = 2,
  FCSMode_TRACKING = 3,
  FCSMode_SOLUTION = 4,
  FCSMode_CCIP = 5,
  FCSMode_CCRP = 6,
  FCSMode_MANUAL = 7,
  FCSMode_MIN = FCSMode_OFF,
  FCSMode_MAX = FCSMode_MANUAL
};

inline const FCSMode (&EnumValuesFCSMode())[8] {
  static const FCSMode values[] = {
    FCSMode_OFF,
    FCSMode_STANDBY,
    FCSMode_RANGING,
    FCSMode_TRACKING,
    FCSMode_SOLUTION,
    FCSMode_CCIP,
    FCSMode_CCRP,
    FCSMode_MANUAL
  };
  return values;
}

inline const char * const *EnumNamesFCSMode() {
  static const char * const names[9] = {
    "OFF",
    "STANDBY",
    "RANGING",
    "TRACKING",
    "SOLUTION",
    "CCIP",
    "CCRP",
    "MANUAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameFCSMode(FCSMode e) {
  if (::flatbuffers::IsOutRange(e, FCSMode_OFF, FCSMode_MANUAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFCSMode()[index];
}

enum LeadMethod : int8_t {
  LeadMethod_NONE = 0,
  LeadMethod_PREDICTIVE = 1,
  LeadMethod_COLLISION = 2,
  LeadMethod_CONSTANT_BEARING = 3,
  LeadMethod_PURSUIT = 4,
  LeadMethod_MIN = LeadMethod_NONE,
  LeadMethod_MAX = LeadMethod_PURSUIT
};

inline const LeadMethod (&EnumValuesLeadMethod())[5] {
  static const LeadMethod values[] = {
    LeadMethod_NONE,
    LeadMethod_PREDICTIVE,
    LeadMethod_COLLISION,
    LeadMethod_CONSTANT_BEARING,
    LeadMethod_PURSUIT
  };
  return values;
}

inline const char * const *EnumNamesLeadMethod() {
  static const char * const names[6] = {
    "NONE",
    "PREDICTIVE",
    "COLLISION",
    "CONSTANT_BEARING",
    "PURSUIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameLeadMethod(LeadMethod e) {
  if (::flatbuffers::IsOutRange(e, LeadMethod_NONE, LeadMethod_PURSUIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLeadMethod()[index];
}

enum RangefinderType : int8_t {
  RangefinderType_STADIAMETRIC = 0,
  RangefinderType_STEREOSCOPIC = 1,
  RangefinderType_COINCIDENCE = 2,
  RangefinderType_LASER = 3,
  RangefinderType_RADAR = 4,
  RangefinderType_MIN = RangefinderType_STADIAMETRIC,
  RangefinderType_MAX = RangefinderType_RADAR
};

inline const RangefinderType (&EnumValuesRangefinderType())[5] {
  static const RangefinderType values[] = {
    RangefinderType_STADIAMETRIC,
    RangefinderType_STEREOSCOPIC,
    RangefinderType_COINCIDENCE,
    RangefinderType_LASER,
    RangefinderType_RADAR
  };
  return values;
}

inline const char * const *EnumNamesRangefinderType() {
  static const char * const names[6] = {
    "STADIAMETRIC",
    "STEREOSCOPIC",
    "COINCIDENCE",
    "LASER",
    "RADAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameRangefinderType(RangefinderType e) {
  if (::flatbuffers::IsOutRange(e, RangefinderType_STADIAMETRIC, RangefinderType_RADAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRangefinderType()[index];
}

/// Fire Control Systems
struct FCS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FCSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_LEAD_METHOD = 6,
    VT_RANGEFINDER_TYPE = 8,
    VT_AMMO_SELECTED = 10,
    VT_TARGET = 12,
    VT_SOLUTION = 14,
    VT_LAST_RANGE = 16,
    VT_RANGE_RATE = 18,
    VT_ROUNDS_REMAINING = 20,
    VT_TEMPERATURE = 22,
    VT_RESERVED = 24
  };
  uint8_t MODE() const {
    return GetField<uint8_t>(VT_MODE, 0);
  }
  uint8_t LEAD_METHOD() const {
    return GetField<uint8_t>(VT_LEAD_METHOD, 0);
  }
  uint8_t RANGEFINDER_TYPE() const {
    return GetField<uint8_t>(VT_RANGEFINDER_TYPE, 0);
  }
  uint8_t AMMO_SELECTED() const {
    return GetField<uint8_t>(VT_AMMO_SELECTED, 0);
  }
  const ::flatbuffers::String *TARGET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET);
  }
  const ::flatbuffers::String *SOLUTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOLUTION);
  }
  double LAST_RANGE() const {
    return GetField<double>(VT_LAST_RANGE, 0.0);
  }
  double RANGE_RATE() const {
    return GetField<double>(VT_RANGE_RATE, 0.0);
  }
  uint16_t ROUNDS_REMAINING() const {
    return GetField<uint16_t>(VT_ROUNDS_REMAINING, 0);
  }
  float TEMPERATURE() const {
    return GetField<float>(VT_TEMPERATURE, 0.0f);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_LEAD_METHOD, 1) &&
           VerifyField<uint8_t>(verifier, VT_RANGEFINDER_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AMMO_SELECTED, 1) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyString(TARGET()) &&
           VerifyOffset(verifier, VT_SOLUTION) &&
           verifier.VerifyString(SOLUTION()) &&
           VerifyField<double>(verifier, VT_LAST_RANGE, 8) &&
           VerifyField<double>(verifier, VT_RANGE_RATE, 8) &&
           VerifyField<uint16_t>(verifier, VT_ROUNDS_REMAINING, 2) &&
           VerifyField<float>(verifier, VT_TEMPERATURE, 4) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct FCSBuilder {
  typedef FCS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MODE(uint8_t MODE) {
    fbb_.AddElement<uint8_t>(FCS::VT_MODE, MODE, 0);
  }
  void add_LEAD_METHOD(uint8_t LEAD_METHOD) {
    fbb_.AddElement<uint8_t>(FCS::VT_LEAD_METHOD, LEAD_METHOD, 0);
  }
  void add_RANGEFINDER_TYPE(uint8_t RANGEFINDER_TYPE) {
    fbb_.AddElement<uint8_t>(FCS::VT_RANGEFINDER_TYPE, RANGEFINDER_TYPE, 0);
  }
  void add_AMMO_SELECTED(uint8_t AMMO_SELECTED) {
    fbb_.AddElement<uint8_t>(FCS::VT_AMMO_SELECTED, AMMO_SELECTED, 0);
  }
  void add_TARGET(::flatbuffers::Offset<::flatbuffers::String> TARGET) {
    fbb_.AddOffset(FCS::VT_TARGET, TARGET);
  }
  void add_SOLUTION(::flatbuffers::Offset<::flatbuffers::String> SOLUTION) {
    fbb_.AddOffset(FCS::VT_SOLUTION, SOLUTION);
  }
  void add_LAST_RANGE(double LAST_RANGE) {
    fbb_.AddElement<double>(FCS::VT_LAST_RANGE, LAST_RANGE, 0.0);
  }
  void add_RANGE_RATE(double RANGE_RATE) {
    fbb_.AddElement<double>(FCS::VT_RANGE_RATE, RANGE_RATE, 0.0);
  }
  void add_ROUNDS_REMAINING(uint16_t ROUNDS_REMAINING) {
    fbb_.AddElement<uint16_t>(FCS::VT_ROUNDS_REMAINING, ROUNDS_REMAINING, 0);
  }
  void add_TEMPERATURE(float TEMPERATURE) {
    fbb_.AddElement<float>(FCS::VT_TEMPERATURE, TEMPERATURE, 0.0f);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(FCS::VT_RESERVED, RESERVED);
  }
  explicit FCSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FCS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FCS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FCS> CreateFCS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t MODE = 0,
    uint8_t LEAD_METHOD = 0,
    uint8_t RANGEFINDER_TYPE = 0,
    uint8_t AMMO_SELECTED = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TARGET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOLUTION = 0,
    double LAST_RANGE = 0.0,
    double RANGE_RATE = 0.0,
    uint16_t ROUNDS_REMAINING = 0,
    float TEMPERATURE = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  FCSBuilder builder_(_fbb);
  builder_.add_RANGE_RATE(RANGE_RATE);
  builder_.add_LAST_RANGE(LAST_RANGE);
  builder_.add_RESERVED(RESERVED);
  builder_.add_TEMPERATURE(TEMPERATURE);
  builder_.add_SOLUTION(SOLUTION);
  builder_.add_TARGET(TARGET);
  builder_.add_ROUNDS_REMAINING(ROUNDS_REMAINING);
  builder_.add_AMMO_SELECTED(AMMO_SELECTED);
  builder_.add_RANGEFINDER_TYPE(RANGEFINDER_TYPE);
  builder_.add_LEAD_METHOD(LEAD_METHOD);
  builder_.add_MODE(MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FCS> CreateFCSDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t MODE = 0,
    uint8_t LEAD_METHOD = 0,
    uint8_t RANGEFINDER_TYPE = 0,
    uint8_t AMMO_SELECTED = 0,
    const char *TARGET = nullptr,
    const char *SOLUTION = nullptr,
    double LAST_RANGE = 0.0,
    double RANGE_RATE = 0.0,
    uint16_t ROUNDS_REMAINING = 0,
    float TEMPERATURE = 0.0f,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto TARGET__ = TARGET ? _fbb.CreateString(TARGET) : 0;
  auto SOLUTION__ = SOLUTION ? _fbb.CreateString(SOLUTION) : 0;
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateFCS(
      _fbb,
      MODE,
      LEAD_METHOD,
      RANGEFINDER_TYPE,
      AMMO_SELECTED,
      TARGET__,
      SOLUTION__,
      LAST_RANGE,
      RANGE_RATE,
      ROUNDS_REMAINING,
      TEMPERATURE,
      RESERVED__);
}

inline const FCS *GetFCS(const void *buf) {
  return ::flatbuffers::GetRoot<FCS>(buf);
}

inline const FCS *GetSizePrefixedFCS(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<FCS>(buf);
}

inline const char *FCSIdentifier() {
  return "$FCS";
}

inline bool FCSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, FCSIdentifier());
}

inline bool SizePrefixedFCSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, FCSIdentifier(), true);
}

inline bool VerifyFCSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FCS>(FCSIdentifier());
}

inline bool VerifySizePrefixedFCSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FCS>(FCSIdentifier());
}

inline void FinishFCSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FCS> root) {
  fbb.Finish(root, FCSIdentifier());
}

inline void FinishSizePrefixedFCSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FCS> root) {
  fbb.FinishSizePrefixed(root, FCSIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
