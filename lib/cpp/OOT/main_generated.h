// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OOT;
struct OOTBuilder;

enum thrusterType : int8_t {
  thrusterType_CHEMICAL_MONO = 0,
  thrusterType_CHEMICAL_BI = 1,
  thrusterType_COLD_GAS = 2,
  thrusterType_ELECTRIC_HALL = 3,
  thrusterType_ELECTRIC_ION = 4,
  thrusterType_ELECTRIC_PPT = 5,
  thrusterType_ELECTRIC_ARCJET = 6,
  thrusterType_ELECTRIC_RESISTOJET = 7,
  thrusterType_ELECTRIC_COLLOID = 8,
  thrusterType_SOLID = 9,
  thrusterType_HYBRID = 10,
  thrusterType_NUCLEAR_THERMAL = 11,
  thrusterType_SOLAR_THERMAL = 12,
  thrusterType_MIN = thrusterType_CHEMICAL_MONO,
  thrusterType_MAX = thrusterType_SOLAR_THERMAL
};

inline const thrusterType (&EnumValuesthrusterType())[13] {
  static const thrusterType values[] = {
    thrusterType_CHEMICAL_MONO,
    thrusterType_CHEMICAL_BI,
    thrusterType_COLD_GAS,
    thrusterType_ELECTRIC_HALL,
    thrusterType_ELECTRIC_ION,
    thrusterType_ELECTRIC_PPT,
    thrusterType_ELECTRIC_ARCJET,
    thrusterType_ELECTRIC_RESISTOJET,
    thrusterType_ELECTRIC_COLLOID,
    thrusterType_SOLID,
    thrusterType_HYBRID,
    thrusterType_NUCLEAR_THERMAL,
    thrusterType_SOLAR_THERMAL
  };
  return values;
}

inline const char * const *EnumNamesthrusterType() {
  static const char * const names[14] = {
    "CHEMICAL_MONO",
    "CHEMICAL_BI",
    "COLD_GAS",
    "ELECTRIC_HALL",
    "ELECTRIC_ION",
    "ELECTRIC_PPT",
    "ELECTRIC_ARCJET",
    "ELECTRIC_RESISTOJET",
    "ELECTRIC_COLLOID",
    "SOLID",
    "HYBRID",
    "NUCLEAR_THERMAL",
    "SOLAR_THERMAL",
    nullptr
  };
  return names;
}

inline const char *EnumNamethrusterType(thrusterType e) {
  if (::flatbuffers::IsOutRange(e, thrusterType_CHEMICAL_MONO, thrusterType_SOLAR_THERMAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesthrusterType()[index];
}

/// On-Orbit Thruster
struct OOT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OOTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ID_ON_ORBIT = 6,
    VT_ID_THRUSTER = 8,
    VT_NAME = 10,
    VT_TYPE = 12,
    VT_QUANTITY = 14,
    VT_THRUST = 16,
    VT_ISP = 18,
    VT_PROPELLANT = 20,
    VT_PROPELLANT_MASS = 22,
    VT_PROPELLANT_REMAINING = 24,
    VT_DELTA_V_TOTAL = 26,
    VT_DELTA_V_REMAINING = 28,
    VT_TOTAL_IMPULSE = 30,
    VT_MASS = 32,
    VT_PURPOSE = 34,
    VT_NOTES = 36
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Reference to parent on-orbit object
  const ::flatbuffers::String *ID_ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ON_ORBIT);
  }
  /// Reference to thruster specification
  const ::flatbuffers::String *ID_THRUSTER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_THRUSTER);
  }
  /// Thruster name or designation
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Thruster type
  thrusterType TYPE() const {
    return static_cast<thrusterType>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Number of thrusters of this type
  uint32_t QUANTITY() const {
    return GetField<uint32_t>(VT_QUANTITY, 0);
  }
  /// Thrust output in Newtons
  double THRUST() const {
    return GetField<double>(VT_THRUST, 0.0);
  }
  /// Specific impulse in seconds
  double ISP() const {
    return GetField<double>(VT_ISP, 0.0);
  }
  /// Propellant type (e.g., HYDRAZINE, XENON, KRYPTON, MMH_NTO, N2, GN2)
  const ::flatbuffers::String *PROPELLANT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROPELLANT);
  }
  /// Total propellant mass in kg
  double PROPELLANT_MASS() const {
    return GetField<double>(VT_PROPELLANT_MASS, 0.0);
  }
  /// Remaining propellant mass in kg
  double PROPELLANT_REMAINING() const {
    return GetField<double>(VT_PROPELLANT_REMAINING, 0.0);
  }
  /// Total delta-V capability in m/s
  double DELTA_V_TOTAL() const {
    return GetField<double>(VT_DELTA_V_TOTAL, 0.0);
  }
  /// Remaining delta-V in m/s
  double DELTA_V_REMAINING() const {
    return GetField<double>(VT_DELTA_V_REMAINING, 0.0);
  }
  /// Total impulse in Newton-seconds
  double TOTAL_IMPULSE() const {
    return GetField<double>(VT_TOTAL_IMPULSE, 0.0);
  }
  /// Thruster dry mass in kg
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// Purpose (e.g., ORBIT_RAISING, STATION_KEEPING, ATTITUDE_CONTROL, DEORBIT)
  const ::flatbuffers::String *PURPOSE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PURPOSE);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_ID_ON_ORBIT) &&
           verifier.VerifyString(ID_ON_ORBIT()) &&
           VerifyOffset(verifier, VT_ID_THRUSTER) &&
           verifier.VerifyString(ID_THRUSTER()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_QUANTITY, 4) &&
           VerifyField<double>(verifier, VT_THRUST, 8) &&
           VerifyField<double>(verifier, VT_ISP, 8) &&
           VerifyOffset(verifier, VT_PROPELLANT) &&
           verifier.VerifyString(PROPELLANT()) &&
           VerifyField<double>(verifier, VT_PROPELLANT_MASS, 8) &&
           VerifyField<double>(verifier, VT_PROPELLANT_REMAINING, 8) &&
           VerifyField<double>(verifier, VT_DELTA_V_TOTAL, 8) &&
           VerifyField<double>(verifier, VT_DELTA_V_REMAINING, 8) &&
           VerifyField<double>(verifier, VT_TOTAL_IMPULSE, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyOffset(verifier, VT_PURPOSE) &&
           verifier.VerifyString(PURPOSE()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct OOTBuilder {
  typedef OOT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(OOT::VT_ID, ID);
  }
  void add_ID_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT) {
    fbb_.AddOffset(OOT::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  void add_ID_THRUSTER(::flatbuffers::Offset<::flatbuffers::String> ID_THRUSTER) {
    fbb_.AddOffset(OOT::VT_ID_THRUSTER, ID_THRUSTER);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(OOT::VT_NAME, NAME);
  }
  void add_TYPE(thrusterType TYPE) {
    fbb_.AddElement<int8_t>(OOT::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_QUANTITY(uint32_t QUANTITY) {
    fbb_.AddElement<uint32_t>(OOT::VT_QUANTITY, QUANTITY, 0);
  }
  void add_THRUST(double THRUST) {
    fbb_.AddElement<double>(OOT::VT_THRUST, THRUST, 0.0);
  }
  void add_ISP(double ISP) {
    fbb_.AddElement<double>(OOT::VT_ISP, ISP, 0.0);
  }
  void add_PROPELLANT(::flatbuffers::Offset<::flatbuffers::String> PROPELLANT) {
    fbb_.AddOffset(OOT::VT_PROPELLANT, PROPELLANT);
  }
  void add_PROPELLANT_MASS(double PROPELLANT_MASS) {
    fbb_.AddElement<double>(OOT::VT_PROPELLANT_MASS, PROPELLANT_MASS, 0.0);
  }
  void add_PROPELLANT_REMAINING(double PROPELLANT_REMAINING) {
    fbb_.AddElement<double>(OOT::VT_PROPELLANT_REMAINING, PROPELLANT_REMAINING, 0.0);
  }
  void add_DELTA_V_TOTAL(double DELTA_V_TOTAL) {
    fbb_.AddElement<double>(OOT::VT_DELTA_V_TOTAL, DELTA_V_TOTAL, 0.0);
  }
  void add_DELTA_V_REMAINING(double DELTA_V_REMAINING) {
    fbb_.AddElement<double>(OOT::VT_DELTA_V_REMAINING, DELTA_V_REMAINING, 0.0);
  }
  void add_TOTAL_IMPULSE(double TOTAL_IMPULSE) {
    fbb_.AddElement<double>(OOT::VT_TOTAL_IMPULSE, TOTAL_IMPULSE, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(OOT::VT_MASS, MASS, 0.0);
  }
  void add_PURPOSE(::flatbuffers::Offset<::flatbuffers::String> PURPOSE) {
    fbb_.AddOffset(OOT::VT_PURPOSE, PURPOSE);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(OOT::VT_NOTES, NOTES);
  }
  explicit OOTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OOT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OOT> CreateOOT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ON_ORBIT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_THRUSTER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    thrusterType TYPE = thrusterType_CHEMICAL_MONO,
    uint32_t QUANTITY = 0,
    double THRUST = 0.0,
    double ISP = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> PROPELLANT = 0,
    double PROPELLANT_MASS = 0.0,
    double PROPELLANT_REMAINING = 0.0,
    double DELTA_V_TOTAL = 0.0,
    double DELTA_V_REMAINING = 0.0,
    double TOTAL_IMPULSE = 0.0,
    double MASS = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> PURPOSE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  OOTBuilder builder_(_fbb);
  builder_.add_MASS(MASS);
  builder_.add_TOTAL_IMPULSE(TOTAL_IMPULSE);
  builder_.add_DELTA_V_REMAINING(DELTA_V_REMAINING);
  builder_.add_DELTA_V_TOTAL(DELTA_V_TOTAL);
  builder_.add_PROPELLANT_REMAINING(PROPELLANT_REMAINING);
  builder_.add_PROPELLANT_MASS(PROPELLANT_MASS);
  builder_.add_ISP(ISP);
  builder_.add_THRUST(THRUST);
  builder_.add_NOTES(NOTES);
  builder_.add_PURPOSE(PURPOSE);
  builder_.add_PROPELLANT(PROPELLANT);
  builder_.add_QUANTITY(QUANTITY);
  builder_.add_NAME(NAME);
  builder_.add_ID_THRUSTER(ID_THRUSTER);
  builder_.add_ID_ON_ORBIT(ID_ON_ORBIT);
  builder_.add_ID(ID);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OOT> CreateOOTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *ID_ON_ORBIT = nullptr,
    const char *ID_THRUSTER = nullptr,
    const char *NAME = nullptr,
    thrusterType TYPE = thrusterType_CHEMICAL_MONO,
    uint32_t QUANTITY = 0,
    double THRUST = 0.0,
    double ISP = 0.0,
    const char *PROPELLANT = nullptr,
    double PROPELLANT_MASS = 0.0,
    double PROPELLANT_REMAINING = 0.0,
    double DELTA_V_TOTAL = 0.0,
    double DELTA_V_REMAINING = 0.0,
    double TOTAL_IMPULSE = 0.0,
    double MASS = 0.0,
    const char *PURPOSE = nullptr,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto ID_ON_ORBIT__ = ID_ON_ORBIT ? _fbb.CreateString(ID_ON_ORBIT) : 0;
  auto ID_THRUSTER__ = ID_THRUSTER ? _fbb.CreateString(ID_THRUSTER) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto PROPELLANT__ = PROPELLANT ? _fbb.CreateString(PROPELLANT) : 0;
  auto PURPOSE__ = PURPOSE ? _fbb.CreateString(PURPOSE) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateOOT(
      _fbb,
      ID__,
      ID_ON_ORBIT__,
      ID_THRUSTER__,
      NAME__,
      TYPE,
      QUANTITY,
      THRUST,
      ISP,
      PROPELLANT__,
      PROPELLANT_MASS,
      PROPELLANT_REMAINING,
      DELTA_V_TOTAL,
      DELTA_V_REMAINING,
      TOTAL_IMPULSE,
      MASS,
      PURPOSE__,
      NOTES__);
}

inline const OOT *GetOOT(const void *buf) {
  return ::flatbuffers::GetRoot<OOT>(buf);
}

inline const OOT *GetSizePrefixedOOT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OOT>(buf);
}

inline const char *OOTIdentifier() {
  return "$OOT";
}

inline bool OOTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOTIdentifier());
}

inline bool SizePrefixedOOTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOTIdentifier(), true);
}

inline bool VerifyOOTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OOT>(OOTIdentifier());
}

inline bool VerifySizePrefixedOOTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OOT>(OOTIdentifier());
}

inline void FinishOOTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOT> root) {
  fbb.Finish(root, OOTIdentifier());
}

inline void FinishSizePrefixedOOTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOT> root) {
  fbb.FinishSizePrefixed(root, OOTIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
