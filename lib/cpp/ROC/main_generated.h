// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct ROC;
struct ROCBuilder;

struct STAGE;
struct STAGEBuilder;

struct SUSTAINER;
struct SUSTAINERBuilder;

struct ENGINE;
struct ENGINEBuilder;

/// Enumeration of Engine Types
enum ENGINE_TYPE : int8_t {
  ENGINE_TYPE_LIQUID = 0,
  ENGINE_TYPE_SOLID = 1,
  ENGINE_TYPE_HYBRID = 2,
  ENGINE_TYPE_ION = 3,
  ENGINE_TYPE_NUCLEAR_THERMAL = 4,
  ENGINE_TYPE_OTHER = 5,
  ENGINE_TYPE_MIN = ENGINE_TYPE_LIQUID,
  ENGINE_TYPE_MAX = ENGINE_TYPE_OTHER
};

inline const ENGINE_TYPE (&EnumValuesENGINE_TYPE())[6] {
  static const ENGINE_TYPE values[] = {
    ENGINE_TYPE_LIQUID,
    ENGINE_TYPE_SOLID,
    ENGINE_TYPE_HYBRID,
    ENGINE_TYPE_ION,
    ENGINE_TYPE_NUCLEAR_THERMAL,
    ENGINE_TYPE_OTHER
  };
  return values;
}

inline const char * const *EnumNamesENGINE_TYPE() {
  static const char * const names[7] = {
    "LIQUID",
    "SOLID",
    "HYBRID",
    "ION",
    "NUCLEAR_THERMAL",
    "OTHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameENGINE_TYPE(ENGINE_TYPE e) {
  if (::flatbuffers::IsOutRange(e, ENGINE_TYPE_LIQUID, ENGINE_TYPE_OTHER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesENGINE_TYPE()[index];
}

/// Rocket Configuration
struct ROC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ROCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FAMILY = 6,
    VT_VARIANT = 8,
    VT_STAGES = 10,
    VT_SUSTAINERS = 12
  };
  /// Rocket Name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Rocket Family
  const ::flatbuffers::String *FAMILY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FAMILY);
  }
  /// Rocket Variant
  const ::flatbuffers::String *VARIANT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VARIANT);
  }
  /// Stages in the Rocket
  const ::flatbuffers::Vector<::flatbuffers::Offset<STAGE>> *STAGES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<STAGE>> *>(VT_STAGES);
  }
  /// Sustainers in the Rocket
  const ::flatbuffers::Vector<::flatbuffers::Offset<SUSTAINER>> *SUSTAINERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SUSTAINER>> *>(VT_SUSTAINERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_FAMILY) &&
           verifier.VerifyString(FAMILY()) &&
           VerifyOffset(verifier, VT_VARIANT) &&
           verifier.VerifyString(VARIANT()) &&
           VerifyOffset(verifier, VT_STAGES) &&
           verifier.VerifyVector(STAGES()) &&
           verifier.VerifyVectorOfTables(STAGES()) &&
           VerifyOffset(verifier, VT_SUSTAINERS) &&
           verifier.VerifyVector(SUSTAINERS()) &&
           verifier.VerifyVectorOfTables(SUSTAINERS()) &&
           verifier.EndTable();
  }
};

struct ROCBuilder {
  typedef ROC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(ROC::VT_NAME, NAME);
  }
  void add_FAMILY(::flatbuffers::Offset<::flatbuffers::String> FAMILY) {
    fbb_.AddOffset(ROC::VT_FAMILY, FAMILY);
  }
  void add_VARIANT(::flatbuffers::Offset<::flatbuffers::String> VARIANT) {
    fbb_.AddOffset(ROC::VT_VARIANT, VARIANT);
  }
  void add_STAGES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<STAGE>>> STAGES) {
    fbb_.AddOffset(ROC::VT_STAGES, STAGES);
  }
  void add_SUSTAINERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SUSTAINER>>> SUSTAINERS) {
    fbb_.AddOffset(ROC::VT_SUSTAINERS, SUSTAINERS);
  }
  explicit ROCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ROC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ROC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ROC> CreateROC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FAMILY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VARIANT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<STAGE>>> STAGES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SUSTAINER>>> SUSTAINERS = 0) {
  ROCBuilder builder_(_fbb);
  builder_.add_SUSTAINERS(SUSTAINERS);
  builder_.add_STAGES(STAGES);
  builder_.add_VARIANT(VARIANT);
  builder_.add_FAMILY(FAMILY);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ROC> CreateROCDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *FAMILY = nullptr,
    const char *VARIANT = nullptr,
    const std::vector<::flatbuffers::Offset<STAGE>> *STAGES = nullptr,
    const std::vector<::flatbuffers::Offset<SUSTAINER>> *SUSTAINERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto FAMILY__ = FAMILY ? _fbb.CreateString(FAMILY) : 0;
  auto VARIANT__ = VARIANT ? _fbb.CreateString(VARIANT) : 0;
  auto STAGES__ = STAGES ? _fbb.CreateVector<::flatbuffers::Offset<STAGE>>(*STAGES) : 0;
  auto SUSTAINERS__ = SUSTAINERS ? _fbb.CreateVector<::flatbuffers::Offset<SUSTAINER>>(*SUSTAINERS) : 0;
  return CreateROC(
      _fbb,
      NAME__,
      FAMILY__,
      VARIANT__,
      STAGES__,
      SUSTAINERS__);
}

/// Stage Details
struct STAGE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef STAGEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STAGE_NUMBER = 4,
    VT_ENGINES = 6,
    VT_FUEL_TYPE = 8,
    VT_THRUST = 10,
    VT_BURN_DURATION = 12
  };
  /// Stage Number
  int32_t STAGE_NUMBER() const {
    return GetField<int32_t>(VT_STAGE_NUMBER, 0);
  }
  /// Engines Used in This Stage
  const ::flatbuffers::Vector<::flatbuffers::Offset<ENGINE>> *ENGINES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ENGINE>> *>(VT_ENGINES);
  }
  /// Fuel Type Used in This Stage
  const ::flatbuffers::String *FUEL_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUEL_TYPE);
  }
  /// Thrust Produced by This Stage (in Newtons)
  double THRUST() const {
    return GetField<double>(VT_THRUST, 0.0);
  }
  /// Duration of the Burn (in Seconds)
  double BURN_DURATION() const {
    return GetField<double>(VT_BURN_DURATION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STAGE_NUMBER, 4) &&
           VerifyOffset(verifier, VT_ENGINES) &&
           verifier.VerifyVector(ENGINES()) &&
           verifier.VerifyVectorOfTables(ENGINES()) &&
           VerifyOffset(verifier, VT_FUEL_TYPE) &&
           verifier.VerifyString(FUEL_TYPE()) &&
           VerifyField<double>(verifier, VT_THRUST, 8) &&
           VerifyField<double>(verifier, VT_BURN_DURATION, 8) &&
           verifier.EndTable();
  }
};

struct STAGEBuilder {
  typedef STAGE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_STAGE_NUMBER(int32_t STAGE_NUMBER) {
    fbb_.AddElement<int32_t>(STAGE::VT_STAGE_NUMBER, STAGE_NUMBER, 0);
  }
  void add_ENGINES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ENGINE>>> ENGINES) {
    fbb_.AddOffset(STAGE::VT_ENGINES, ENGINES);
  }
  void add_FUEL_TYPE(::flatbuffers::Offset<::flatbuffers::String> FUEL_TYPE) {
    fbb_.AddOffset(STAGE::VT_FUEL_TYPE, FUEL_TYPE);
  }
  void add_THRUST(double THRUST) {
    fbb_.AddElement<double>(STAGE::VT_THRUST, THRUST, 0.0);
  }
  void add_BURN_DURATION(double BURN_DURATION) {
    fbb_.AddElement<double>(STAGE::VT_BURN_DURATION, BURN_DURATION, 0.0);
  }
  explicit STAGEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<STAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<STAGE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<STAGE> CreateSTAGE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t STAGE_NUMBER = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ENGINE>>> ENGINES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FUEL_TYPE = 0,
    double THRUST = 0.0,
    double BURN_DURATION = 0.0) {
  STAGEBuilder builder_(_fbb);
  builder_.add_BURN_DURATION(BURN_DURATION);
  builder_.add_THRUST(THRUST);
  builder_.add_FUEL_TYPE(FUEL_TYPE);
  builder_.add_ENGINES(ENGINES);
  builder_.add_STAGE_NUMBER(STAGE_NUMBER);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<STAGE> CreateSTAGEDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t STAGE_NUMBER = 0,
    const std::vector<::flatbuffers::Offset<ENGINE>> *ENGINES = nullptr,
    const char *FUEL_TYPE = nullptr,
    double THRUST = 0.0,
    double BURN_DURATION = 0.0) {
  auto ENGINES__ = ENGINES ? _fbb.CreateVector<::flatbuffers::Offset<ENGINE>>(*ENGINES) : 0;
  auto FUEL_TYPE__ = FUEL_TYPE ? _fbb.CreateString(FUEL_TYPE) : 0;
  return CreateSTAGE(
      _fbb,
      STAGE_NUMBER,
      ENGINES__,
      FUEL_TYPE__,
      THRUST,
      BURN_DURATION);
}

/// Sustainer Details
struct SUSTAINER FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SUSTAINERBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUSTAINER_NAME = 4,
    VT_THRUST = 6,
    VT_BURN_DURATION = 8
  };
  /// Name of the Sustainer
  const ::flatbuffers::String *SUSTAINER_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUSTAINER_NAME);
  }
  /// Thrust Produced by the Sustainer (in Newtons)
  double THRUST() const {
    return GetField<double>(VT_THRUST, 0.0);
  }
  /// Duration of the Burn (in Seconds)
  double BURN_DURATION() const {
    return GetField<double>(VT_BURN_DURATION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUSTAINER_NAME) &&
           verifier.VerifyString(SUSTAINER_NAME()) &&
           VerifyField<double>(verifier, VT_THRUST, 8) &&
           VerifyField<double>(verifier, VT_BURN_DURATION, 8) &&
           verifier.EndTable();
  }
};

struct SUSTAINERBuilder {
  typedef SUSTAINER Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SUSTAINER_NAME(::flatbuffers::Offset<::flatbuffers::String> SUSTAINER_NAME) {
    fbb_.AddOffset(SUSTAINER::VT_SUSTAINER_NAME, SUSTAINER_NAME);
  }
  void add_THRUST(double THRUST) {
    fbb_.AddElement<double>(SUSTAINER::VT_THRUST, THRUST, 0.0);
  }
  void add_BURN_DURATION(double BURN_DURATION) {
    fbb_.AddElement<double>(SUSTAINER::VT_BURN_DURATION, BURN_DURATION, 0.0);
  }
  explicit SUSTAINERBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SUSTAINER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SUSTAINER>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SUSTAINER> CreateSUSTAINER(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> SUSTAINER_NAME = 0,
    double THRUST = 0.0,
    double BURN_DURATION = 0.0) {
  SUSTAINERBuilder builder_(_fbb);
  builder_.add_BURN_DURATION(BURN_DURATION);
  builder_.add_THRUST(THRUST);
  builder_.add_SUSTAINER_NAME(SUSTAINER_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SUSTAINER> CreateSUSTAINERDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *SUSTAINER_NAME = nullptr,
    double THRUST = 0.0,
    double BURN_DURATION = 0.0) {
  auto SUSTAINER_NAME__ = SUSTAINER_NAME ? _fbb.CreateString(SUSTAINER_NAME) : 0;
  return CreateSUSTAINER(
      _fbb,
      SUSTAINER_NAME__,
      THRUST,
      BURN_DURATION);
}

/// Engine Details
struct ENGINE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ENGINEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENGINE_NAME = 4,
    VT_TYPE = 6,
    VT_THRUST = 8
  };
  /// Engine Name
  const ::flatbuffers::String *ENGINE_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENGINE_NAME);
  }
  /// Type of Engine
  ENGINE_TYPE TYPE() const {
    return static_cast<ENGINE_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Thrust Produced by the Engine (in Newtons)
  double THRUST() const {
    return GetField<double>(VT_THRUST, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENGINE_NAME) &&
           verifier.VerifyString(ENGINE_NAME()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<double>(verifier, VT_THRUST, 8) &&
           verifier.EndTable();
  }
};

struct ENGINEBuilder {
  typedef ENGINE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ENGINE_NAME(::flatbuffers::Offset<::flatbuffers::String> ENGINE_NAME) {
    fbb_.AddOffset(ENGINE::VT_ENGINE_NAME, ENGINE_NAME);
  }
  void add_TYPE(ENGINE_TYPE TYPE) {
    fbb_.AddElement<int8_t>(ENGINE::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_THRUST(double THRUST) {
    fbb_.AddElement<double>(ENGINE::VT_THRUST, THRUST, 0.0);
  }
  explicit ENGINEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ENGINE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ENGINE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ENGINE> CreateENGINE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ENGINE_NAME = 0,
    ENGINE_TYPE TYPE = ENGINE_TYPE_LIQUID,
    double THRUST = 0.0) {
  ENGINEBuilder builder_(_fbb);
  builder_.add_THRUST(THRUST);
  builder_.add_ENGINE_NAME(ENGINE_NAME);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ENGINE> CreateENGINEDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ENGINE_NAME = nullptr,
    ENGINE_TYPE TYPE = ENGINE_TYPE_LIQUID,
    double THRUST = 0.0) {
  auto ENGINE_NAME__ = ENGINE_NAME ? _fbb.CreateString(ENGINE_NAME) : 0;
  return CreateENGINE(
      _fbb,
      ENGINE_NAME__,
      TYPE,
      THRUST);
}

inline const ROC *GetROC(const void *buf) {
  return ::flatbuffers::GetRoot<ROC>(buf);
}

inline const ROC *GetSizePrefixedROC(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ROC>(buf);
}

inline const char *ROCIdentifier() {
  return "$ROC";
}

inline bool ROCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ROCIdentifier());
}

inline bool SizePrefixedROCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ROCIdentifier(), true);
}

inline bool VerifyROCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ROC>(ROCIdentifier());
}

inline bool VerifySizePrefixedROCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ROC>(ROCIdentifier());
}

inline void FinishROCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ROC> root) {
  fbb.Finish(root, ROCIdentifier());
}

inline void FinishSizePrefixedROCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ROC> root) {
  fbb.FinishSizePrefixed(root, ROCIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
