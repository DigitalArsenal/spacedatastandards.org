// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct PRG;
struct PRGBuilder;

struct USR;
struct USRBuilder;

struct PRGCOLLECTION;
struct PRGCOLLECTIONBuilder;

/// Program Description Message
struct PRG FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PRGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HD_KEY_PATH = 6,
    VT_MESSAGE_TYPES = 8,
    VT_USERS = 10
  };
  /// The name of the program
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Hierarchical Deterministic (HD) derivation path for the program's key, used in cryptocurrency wallets
  const ::flatbuffers::String *HD_KEY_PATH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HD_KEY_PATH);
  }
  /// Vector of standard message types used by the program
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MESSAGE_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MESSAGE_TYPES);
  }
  /// Vector of users associated with the program, each user can have assigned message types
  const ::flatbuffers::Vector<::flatbuffers::Offset<USR>> *USERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<USR>> *>(VT_USERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_HD_KEY_PATH) &&
           verifier.VerifyString(HD_KEY_PATH()) &&
           VerifyOffset(verifier, VT_MESSAGE_TYPES) &&
           verifier.VerifyVector(MESSAGE_TYPES()) &&
           verifier.VerifyVectorOfStrings(MESSAGE_TYPES()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.VerifyVector(USERS()) &&
           verifier.VerifyVectorOfTables(USERS()) &&
           verifier.EndTable();
  }
};

struct PRGBuilder {
  typedef PRG Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(PRG::VT_NAME, NAME);
  }
  void add_HD_KEY_PATH(::flatbuffers::Offset<::flatbuffers::String> HD_KEY_PATH) {
    fbb_.AddOffset(PRG::VT_HD_KEY_PATH, HD_KEY_PATH);
  }
  void add_MESSAGE_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MESSAGE_TYPES) {
    fbb_.AddOffset(PRG::VT_MESSAGE_TYPES, MESSAGE_TYPES);
  }
  void add_USERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<USR>>> USERS) {
    fbb_.AddOffset(PRG::VT_USERS, USERS);
  }
  explicit PRGBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PRG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PRG>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PRG> CreatePRG(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> HD_KEY_PATH = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MESSAGE_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<USR>>> USERS = 0) {
  PRGBuilder builder_(_fbb);
  builder_.add_USERS(USERS);
  builder_.add_MESSAGE_TYPES(MESSAGE_TYPES);
  builder_.add_HD_KEY_PATH(HD_KEY_PATH);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PRG> CreatePRGDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *HD_KEY_PATH = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MESSAGE_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<USR>> *USERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto HD_KEY_PATH__ = HD_KEY_PATH ? _fbb.CreateString(HD_KEY_PATH) : 0;
  auto MESSAGE_TYPES__ = MESSAGE_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MESSAGE_TYPES) : 0;
  auto USERS__ = USERS ? _fbb.CreateVector<::flatbuffers::Offset<USR>>(*USERS) : 0;
  return CreatePRG(
      _fbb,
      NAME__,
      HD_KEY_PATH__,
      MESSAGE_TYPES__,
      USERS__);
}

struct USR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef USRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MESSAGE_TYPES = 6
  };
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MESSAGE_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MESSAGE_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_MESSAGE_TYPES) &&
           verifier.VerifyVector(MESSAGE_TYPES()) &&
           verifier.VerifyVectorOfStrings(MESSAGE_TYPES()) &&
           verifier.EndTable();
  }
};

struct USRBuilder {
  typedef USR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(USR::VT_ID, ID);
  }
  void add_MESSAGE_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MESSAGE_TYPES) {
    fbb_.AddOffset(USR::VT_MESSAGE_TYPES, MESSAGE_TYPES);
  }
  explicit USRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<USR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<USR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<USR> CreateUSR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MESSAGE_TYPES = 0) {
  USRBuilder builder_(_fbb);
  builder_.add_MESSAGE_TYPES(MESSAGE_TYPES);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<USR> CreateUSRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MESSAGE_TYPES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto MESSAGE_TYPES__ = MESSAGE_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MESSAGE_TYPES) : 0;
  return CreateUSR(
      _fbb,
      ID__,
      MESSAGE_TYPES__);
}

struct PRGCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PRGCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PRG>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PRG>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct PRGCOLLECTIONBuilder {
  typedef PRGCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PRG>>> RECORDS) {
    fbb_.AddOffset(PRGCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit PRGCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PRGCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PRGCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PRGCOLLECTION> CreatePRGCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PRG>>> RECORDS = 0) {
  PRGCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PRGCOLLECTION> CreatePRGCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PRG>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<PRG>>(*RECORDS) : 0;
  return CreatePRGCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const PRG *GetPRG(const void *buf) {
  return ::flatbuffers::GetRoot<PRG>(buf);
}

inline const PRG *GetSizePrefixedPRG(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PRG>(buf);
}

inline const char *PRGIdentifier() {
  return "$PRG";
}

inline bool PRGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PRGIdentifier());
}

inline bool SizePrefixedPRGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PRGIdentifier(), true);
}

inline bool VerifyPRGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PRG>(PRGIdentifier());
}

inline bool VerifySizePrefixedPRGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PRG>(PRGIdentifier());
}

inline void FinishPRGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PRG> root) {
  fbb.Finish(root, PRGIdentifier());
}

inline void FinishSizePrefixedPRGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PRG> root) {
  fbb.FinishSizePrefixed(root, PRGIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
