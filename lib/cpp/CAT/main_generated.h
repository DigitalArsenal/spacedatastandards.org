// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct CAT;
struct CATBuilder;

struct CATCOLLECTION;
struct CATCOLLECTIONBuilder;

enum objectType : int8_t {
  /// 0
  objectType_PAYLOAD = 0,
  /// 1
  objectType_ROCKET_BODY = 1,
  /// 2
  objectType_DEBRIS = 2,
  /// 3
  objectType_UNKNOWN = 3,
  objectType_MIN = objectType_PAYLOAD,
  objectType_MAX = objectType_UNKNOWN
};

inline const objectType (&EnumValuesobjectType())[4] {
  static const objectType values[] = {
    objectType_PAYLOAD,
    objectType_ROCKET_BODY,
    objectType_DEBRIS,
    objectType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesobjectType() {
  static const char * const names[5] = {
    "PAYLOAD",
    "ROCKET_BODY",
    "DEBRIS",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameobjectType(objectType e) {
  if (::flatbuffers::IsOutRange(e, objectType_PAYLOAD, objectType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesobjectType()[index];
}

enum opsStatusCode : int8_t {
  /// +
  opsStatusCode_OPERATIONAL = 0,
  /// -
  opsStatusCode_NONOPERATIONAL = 1,
  /// P
  opsStatusCode_PARTIALLY_OPERATIONAL = 2,
  /// B
  opsStatusCode_BACKUP_STANDBY = 3,
  /// S
  opsStatusCode_SPARE = 4,
  /// X
  opsStatusCode_EXTENDED_MISSION = 5,
  /// D
  opsStatusCode_DECAYED = 6,
  /// ?
  opsStatusCode_UNKNOWN = 7,
  opsStatusCode_MIN = opsStatusCode_OPERATIONAL,
  opsStatusCode_MAX = opsStatusCode_UNKNOWN
};

inline const opsStatusCode (&EnumValuesopsStatusCode())[8] {
  static const opsStatusCode values[] = {
    opsStatusCode_OPERATIONAL,
    opsStatusCode_NONOPERATIONAL,
    opsStatusCode_PARTIALLY_OPERATIONAL,
    opsStatusCode_BACKUP_STANDBY,
    opsStatusCode_SPARE,
    opsStatusCode_EXTENDED_MISSION,
    opsStatusCode_DECAYED,
    opsStatusCode_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesopsStatusCode() {
  static const char * const names[9] = {
    "OPERATIONAL",
    "NONOPERATIONAL",
    "PARTIALLY_OPERATIONAL",
    "BACKUP_STANDBY",
    "SPARE",
    "EXTENDED_MISSION",
    "DECAYED",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameopsStatusCode(opsStatusCode e) {
  if (::flatbuffers::IsOutRange(e, opsStatusCode_OPERATIONAL, opsStatusCode_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesopsStatusCode()[index];
}

enum dataStatusCode : int8_t {
  /// NCE
  dataStatusCode_NO_CURRENT_ELEMENTS = 0,
  /// NIE
  dataStatusCode_NO_INITIAL_ELEMENTS = 1,
  /// NEA
  dataStatusCode_NO_ELEMENTS_AVAILABLE = 2,
  /// OK
  dataStatusCode_OK = 3,
  dataStatusCode_MIN = dataStatusCode_NO_CURRENT_ELEMENTS,
  dataStatusCode_MAX = dataStatusCode_OK
};

inline const dataStatusCode (&EnumValuesdataStatusCode())[4] {
  static const dataStatusCode values[] = {
    dataStatusCode_NO_CURRENT_ELEMENTS,
    dataStatusCode_NO_INITIAL_ELEMENTS,
    dataStatusCode_NO_ELEMENTS_AVAILABLE,
    dataStatusCode_OK
  };
  return values;
}

inline const char * const *EnumNamesdataStatusCode() {
  static const char * const names[5] = {
    "NO_CURRENT_ELEMENTS",
    "NO_INITIAL_ELEMENTS",
    "NO_ELEMENTS_AVAILABLE",
    "OK",
    nullptr
  };
  return names;
}

inline const char *EnumNamedataStatusCode(dataStatusCode e) {
  if (::flatbuffers::IsOutRange(e, dataStatusCode_NO_CURRENT_ELEMENTS, dataStatusCode_OK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesdataStatusCode()[index];
}

enum orbitType : int8_t {
  /// 0
  orbitType_ORBIT = 0,
  /// 1
  orbitType_LANDING = 1,
  /// 2
  orbitType_IMPACT = 2,
  /// 3
  orbitType_DOCKED = 3,
  /// 4
  orbitType_ROUNDTRIP = 4,
  orbitType_MIN = orbitType_ORBIT,
  orbitType_MAX = orbitType_ROUNDTRIP
};

inline const orbitType (&EnumValuesorbitType())[5] {
  static const orbitType values[] = {
    orbitType_ORBIT,
    orbitType_LANDING,
    orbitType_IMPACT,
    orbitType_DOCKED,
    orbitType_ROUNDTRIP
  };
  return values;
}

inline const char * const *EnumNamesorbitType() {
  static const char * const names[6] = {
    "ORBIT",
    "LANDING",
    "IMPACT",
    "DOCKED",
    "ROUNDTRIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameorbitType(orbitType e) {
  if (::flatbuffers::IsOutRange(e, orbitType_ORBIT, orbitType_ROUNDTRIP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesorbitType()[index];
}

enum massType : int8_t {
  massType_DRY = 0,
  massType_WET = 1,
  massType_MIN = massType_DRY,
  massType_MAX = massType_WET
};

inline const massType (&EnumValuesmassType())[2] {
  static const massType values[] = {
    massType_DRY,
    massType_WET
  };
  return values;
}

inline const char * const *EnumNamesmassType() {
  static const char * const names[3] = {
    "DRY",
    "WET",
    nullptr
  };
  return names;
}

inline const char *EnumNamemassType(massType e) {
  if (::flatbuffers::IsOutRange(e, massType_DRY, massType_WET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmassType()[index];
}

/// Note: this is for legacy compatibility; all messages requiring use of CAT should have an associated EPM
enum ownerCode : int8_t {
  /// Arab Satellite Communications Organization
  ownerCode_AB = 0,
  /// Asia Broadcast Satellite
  ownerCode_ABS = 1,
  /// Asia Satellite Telecommunications Company (ASIASAT)
  ownerCode_AC = 2,
  /// Algeria
  ownerCode_ALG = 3,
  /// Angola
  ownerCode_ANG = 4,
  /// Argentina
  ownerCode_ARGN = 5,
  /// Republic of Armenia
  ownerCode_ARM = 6,
  /// Austria
  ownerCode_ASRA = 7,
  /// Australia
  ownerCode_AUS = 8,
  /// Azerbaijan
  ownerCode_AZER = 9,
  /// Belgium
  ownerCode_BEL = 10,
  /// Belarus
  ownerCode_BELA = 11,
  /// Bermuda
  ownerCode_BERM = 12,
  /// People's Republic of Bangladesh
  ownerCode_BGD = 13,
  /// Kingdom of Bhutan
  ownerCode_BHUT = 14,
  /// Bolivia
  ownerCode_BOL = 15,
  /// Brazil
  ownerCode_BRAZ = 16,
  /// Bulgaria
  ownerCode_BUL = 17,
  /// Canada
  ownerCode_CA = 18,
  /// China/Brazil
  ownerCode_CHBZ = 19,
  /// China/Turkey
  ownerCode_CHTU = 20,
  /// Chile
  ownerCode_CHLE = 21,
  /// Commonwealth of Independent States (former USSR)
  ownerCode_CIS = 22,
  /// Colombia
  ownerCode_COL = 23,
  /// Republic of Costa Rica
  ownerCode_CRI = 24,
  /// Czech Republic (former Czechoslovakia)
  ownerCode_CZCH = 25,
  /// Denmark
  ownerCode_DEN = 26,
  /// Republic of Djibouti
  ownerCode_DJI = 27,
  /// Ecuador
  ownerCode_ECU = 28,
  /// Egypt
  ownerCode_EGYP = 29,
  /// European Space Agency
  ownerCode_ESA = 30,
  /// European Space Research Organization
  ownerCode_ESRO = 31,
  /// Estonia
  ownerCode_EST = 32,
  /// Ethiopia
  ownerCode_ETH = 33,
  /// European Organization for the Exploitation of Meteorological Satellites (EUMETSAT)
  ownerCode_EUME = 34,
  /// European Telecommunications Satellite Organization (EUTELSAT)
  ownerCode_EUTE = 35,
  /// France/Germany
  ownerCode_FGER = 36,
  /// Finland
  ownerCode_FIN = 37,
  /// France
  ownerCode_FR = 38,
  /// France/Italy
  ownerCode_FRIT = 39,
  /// Germany
  ownerCode_GER = 40,
  /// Republic of Ghana
  ownerCode_GHA = 41,
  /// Globalstar
  ownerCode_GLOB = 42,
  /// Greece
  ownerCode_GREC = 43,
  /// Greece/Saudi Arabia
  ownerCode_GRSA = 44,
  /// Guatemala
  ownerCode_GUAT = 45,
  /// Hungary
  ownerCode_HUN = 46,
  /// International Mobile Satellite Organization (INMARSAT)
  ownerCode_IM = 47,
  /// India
  ownerCode_IND = 48,
  /// Indonesia
  ownerCode_INDO = 49,
  /// Iran
  ownerCode_IRAN = 50,
  /// Iraq
  ownerCode_IRAQ = 51,
  /// Iridium
  ownerCode_IRID = 52,
  /// Ireland
  ownerCode_IRL = 53,
  /// Israel
  ownerCode_ISRA = 54,
  /// Indian Space Research Organisation
  ownerCode_ISRO = 55,
  /// International Space Station
  ownerCode_ISS = 56,
  /// Italy
  ownerCode_IT = 57,
  /// International Telecommunications Satellite Organization (INTELSAT)
  ownerCode_ITSO = 58,
  /// Japan
  ownerCode_JPN = 59,
  /// Kazakhstan
  ownerCode_KAZ = 60,
  /// Republic of Kenya
  ownerCode_KEN = 61,
  /// Laos
  ownerCode_LAOS = 62,
  /// Democratic Socialist Republic of Sri Lanka
  ownerCode_LKA = 63,
  /// Lithuania
  ownerCode_LTU = 64,
  /// Luxembourg
  ownerCode_LUXE = 65,
  /// Morocco
  ownerCode_MA = 66,
  /// Malaysia
  ownerCode_MALA = 67,
  /// Principality of Monaco
  ownerCode_MCO = 68,
  /// Republic of Moldova
  ownerCode_MDA = 69,
  /// Mexico
  ownerCode_MEX = 70,
  /// Republic of the Union of Myanmar
  ownerCode_MMR = 71,
  /// Mongolia
  ownerCode_MNG = 72,
  /// Mauritius
  ownerCode_MUS = 73,
  /// North Atlantic Treaty Organization
  ownerCode_NATO = 74,
  /// Netherlands
  ownerCode_NETH = 75,
  /// New ICO
  ownerCode_NICO = 76,
  /// Nigeria
  ownerCode_NIG = 77,
  /// Democratic People's Republic of Korea
  ownerCode_NKOR = 78,
  /// Norway
  ownerCode_NOR = 79,
  /// Federal Democratic Republic of Nepal
  ownerCode_NPL = 80,
  /// New Zealand
  ownerCode_NZ = 81,
  /// O3b Networks
  ownerCode_O3B = 82,
  /// ORBCOMM
  ownerCode_ORB = 83,
  /// Pakistan
  ownerCode_PAKI = 84,
  /// Peru
  ownerCode_PERU = 85,
  /// Poland
  ownerCode_POL = 86,
  /// Portugal
  ownerCode_POR = 87,
  /// People's Republic of China
  ownerCode_PRC = 88,
  /// Republic of Paraguay
  ownerCode_PRY = 89,
  /// People's Republic of China/European Space Agency
  ownerCode_PRES = 90,
  /// State of Qatar
  ownerCode_QAT = 91,
  /// RascomStar-QAF
  ownerCode_RASC = 92,
  /// Taiwan (Republic of China)
  ownerCode_ROC = 93,
  /// Romania
  ownerCode_ROM = 94,
  /// Philippines (Republic of the Philippines)
  ownerCode_RP = 95,
  /// Republic of Rwanda
  ownerCode_RWA = 96,
  /// South Africa
  ownerCode_SAFR = 97,
  /// Saudi Arabia
  ownerCode_SAUD = 98,
  /// Republic of Sudan
  ownerCode_SDN = 99,
  /// Sea Launch
  ownerCode_SEAL = 100,
  /// SES
  ownerCode_SES = 101,
  /// Singapore/Japan
  ownerCode_SGJP = 102,
  /// Singapore
  ownerCode_SING = 103,
  /// Republic of Korea
  ownerCode_SKOR = 104,
  /// Spain
  ownerCode_SPN = 105,
  /// Singapore/Taiwan
  ownerCode_STCT = 106,
  /// Slovenia
  ownerCode_SVN = 107,
  /// Sweden
  ownerCode_SWED = 108,
  /// Switzerland
  ownerCode_SWTZ = 109,
  /// To Be Determined
  ownerCode_TBD = 110,
  /// Thailand
  ownerCode_THAI = 111,
  /// Turkmenistan/Monaco
  ownerCode_TMMC = 112,
  /// Republic of Tunisia
  ownerCode_TUN = 113,
  /// Turkey
  ownerCode_TURK = 114,
  /// United Arab Emirates
  ownerCode_UAE = 115,
  /// United Kingdom
  ownerCode_UK = 116,
  /// Ukraine
  ownerCode_UKR = 117,
  /// Unknown
  ownerCode_UNK = 118,
  /// Uruguay
  ownerCode_URY = 119,
  /// United States
  ownerCode_US = 120,
  /// United States/Brazil
  ownerCode_USBZ = 121,
  /// Vatican City State
  ownerCode_VAT = 122,
  /// Venezuela
  ownerCode_VENZ = 123,
  /// Vietnam
  ownerCode_VTNM = 124,
  /// Republic of Zimbabwe
  ownerCode_ZWE = 125,
  ownerCode_MIN = ownerCode_AB,
  ownerCode_MAX = ownerCode_ZWE
};

inline const ownerCode (&EnumValuesownerCode())[126] {
  static const ownerCode values[] = {
    ownerCode_AB,
    ownerCode_ABS,
    ownerCode_AC,
    ownerCode_ALG,
    ownerCode_ANG,
    ownerCode_ARGN,
    ownerCode_ARM,
    ownerCode_ASRA,
    ownerCode_AUS,
    ownerCode_AZER,
    ownerCode_BEL,
    ownerCode_BELA,
    ownerCode_BERM,
    ownerCode_BGD,
    ownerCode_BHUT,
    ownerCode_BOL,
    ownerCode_BRAZ,
    ownerCode_BUL,
    ownerCode_CA,
    ownerCode_CHBZ,
    ownerCode_CHTU,
    ownerCode_CHLE,
    ownerCode_CIS,
    ownerCode_COL,
    ownerCode_CRI,
    ownerCode_CZCH,
    ownerCode_DEN,
    ownerCode_DJI,
    ownerCode_ECU,
    ownerCode_EGYP,
    ownerCode_ESA,
    ownerCode_ESRO,
    ownerCode_EST,
    ownerCode_ETH,
    ownerCode_EUME,
    ownerCode_EUTE,
    ownerCode_FGER,
    ownerCode_FIN,
    ownerCode_FR,
    ownerCode_FRIT,
    ownerCode_GER,
    ownerCode_GHA,
    ownerCode_GLOB,
    ownerCode_GREC,
    ownerCode_GRSA,
    ownerCode_GUAT,
    ownerCode_HUN,
    ownerCode_IM,
    ownerCode_IND,
    ownerCode_INDO,
    ownerCode_IRAN,
    ownerCode_IRAQ,
    ownerCode_IRID,
    ownerCode_IRL,
    ownerCode_ISRA,
    ownerCode_ISRO,
    ownerCode_ISS,
    ownerCode_IT,
    ownerCode_ITSO,
    ownerCode_JPN,
    ownerCode_KAZ,
    ownerCode_KEN,
    ownerCode_LAOS,
    ownerCode_LKA,
    ownerCode_LTU,
    ownerCode_LUXE,
    ownerCode_MA,
    ownerCode_MALA,
    ownerCode_MCO,
    ownerCode_MDA,
    ownerCode_MEX,
    ownerCode_MMR,
    ownerCode_MNG,
    ownerCode_MUS,
    ownerCode_NATO,
    ownerCode_NETH,
    ownerCode_NICO,
    ownerCode_NIG,
    ownerCode_NKOR,
    ownerCode_NOR,
    ownerCode_NPL,
    ownerCode_NZ,
    ownerCode_O3B,
    ownerCode_ORB,
    ownerCode_PAKI,
    ownerCode_PERU,
    ownerCode_POL,
    ownerCode_POR,
    ownerCode_PRC,
    ownerCode_PRY,
    ownerCode_PRES,
    ownerCode_QAT,
    ownerCode_RASC,
    ownerCode_ROC,
    ownerCode_ROM,
    ownerCode_RP,
    ownerCode_RWA,
    ownerCode_SAFR,
    ownerCode_SAUD,
    ownerCode_SDN,
    ownerCode_SEAL,
    ownerCode_SES,
    ownerCode_SGJP,
    ownerCode_SING,
    ownerCode_SKOR,
    ownerCode_SPN,
    ownerCode_STCT,
    ownerCode_SVN,
    ownerCode_SWED,
    ownerCode_SWTZ,
    ownerCode_TBD,
    ownerCode_THAI,
    ownerCode_TMMC,
    ownerCode_TUN,
    ownerCode_TURK,
    ownerCode_UAE,
    ownerCode_UK,
    ownerCode_UKR,
    ownerCode_UNK,
    ownerCode_URY,
    ownerCode_US,
    ownerCode_USBZ,
    ownerCode_VAT,
    ownerCode_VENZ,
    ownerCode_VTNM,
    ownerCode_ZWE
  };
  return values;
}

inline const char * const *EnumNamesownerCode() {
  static const char * const names[127] = {
    "AB",
    "ABS",
    "AC",
    "ALG",
    "ANG",
    "ARGN",
    "ARM",
    "ASRA",
    "AUS",
    "AZER",
    "BEL",
    "BELA",
    "BERM",
    "BGD",
    "BHUT",
    "BOL",
    "BRAZ",
    "BUL",
    "CA",
    "CHBZ",
    "CHTU",
    "CHLE",
    "CIS",
    "COL",
    "CRI",
    "CZCH",
    "DEN",
    "DJI",
    "ECU",
    "EGYP",
    "ESA",
    "ESRO",
    "EST",
    "ETH",
    "EUME",
    "EUTE",
    "FGER",
    "FIN",
    "FR",
    "FRIT",
    "GER",
    "GHA",
    "GLOB",
    "GREC",
    "GRSA",
    "GUAT",
    "HUN",
    "IM",
    "IND",
    "INDO",
    "IRAN",
    "IRAQ",
    "IRID",
    "IRL",
    "ISRA",
    "ISRO",
    "ISS",
    "IT",
    "ITSO",
    "JPN",
    "KAZ",
    "KEN",
    "LAOS",
    "LKA",
    "LTU",
    "LUXE",
    "MA",
    "MALA",
    "MCO",
    "MDA",
    "MEX",
    "MMR",
    "MNG",
    "MUS",
    "NATO",
    "NETH",
    "NICO",
    "NIG",
    "NKOR",
    "NOR",
    "NPL",
    "NZ",
    "O3B",
    "ORB",
    "PAKI",
    "PERU",
    "POL",
    "POR",
    "PRC",
    "PRY",
    "PRES",
    "QAT",
    "RASC",
    "ROC",
    "ROM",
    "RP",
    "RWA",
    "SAFR",
    "SAUD",
    "SDN",
    "SEAL",
    "SES",
    "SGJP",
    "SING",
    "SKOR",
    "SPN",
    "STCT",
    "SVN",
    "SWED",
    "SWTZ",
    "TBD",
    "THAI",
    "TMMC",
    "TUN",
    "TURK",
    "UAE",
    "UK",
    "UKR",
    "UNK",
    "URY",
    "US",
    "USBZ",
    "VAT",
    "VENZ",
    "VTNM",
    "ZWE",
    nullptr
  };
  return names;
}

inline const char *EnumNameownerCode(ownerCode e) {
  if (::flatbuffers::IsOutRange(e, ownerCode_AB, ownerCode_ZWE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesownerCode()[index];
}

/// Catalog Entity Message
struct CAT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CATBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NAME = 4,
    VT_OBJECT_ID = 6,
    VT_NORAD_CAT_ID = 8,
    VT_OBJECT_TYPE = 10,
    VT_OPS_STATUS_CODE = 12,
    VT_OWNER = 14,
    VT_LAUNCH_DATE = 16,
    VT_LAUNCH_SITE = 18,
    VT_DECAY_DATE = 20,
    VT_PERIOD = 22,
    VT_INCLINATION = 24,
    VT_APOGEE = 26,
    VT_PERIGEE = 28,
    VT_RCS = 30,
    VT_DATA_STATUS_CODE = 32,
    VT_ORBIT_CENTER = 34,
    VT_ORBIT_TYPE = 36,
    VT_DEPLOYMENT_DATE = 38,
    VT_MANEUVERABLE = 40,
    VT_SIZE = 42,
    VT_MASS = 44,
    VT_MASS_TYPE = 46,
    VT_PAYLOADS = 48
  };
  /// Satellite Name(s)
  const ::flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  /// International Designator (YYYY-NNNAAA)
  const ::flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_ID);
  }
  /// NORAD Catalog Number
  uint32_t NORAD_CAT_ID() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID, 0);
  }
  /// Object type (Payload, Rocket body, Debris, Unknown)
  objectType OBJECT_TYPE() const {
    return static_cast<objectType>(GetField<int8_t>(VT_OBJECT_TYPE, 3));
  }
  /// Operational Status Code
  opsStatusCode OPS_STATUS_CODE() const {
    return static_cast<opsStatusCode>(GetField<int8_t>(VT_OPS_STATUS_CODE, 7));
  }
  /// Ownership, typically country or company
  ownerCode OWNER() const {
    return static_cast<ownerCode>(GetField<int8_t>(VT_OWNER, 0));
  }
  /// Launch Date [year-month-day] (ISO 8601)
  const ::flatbuffers::String *LAUNCH_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_DATE);
  }
  /// Launch Site
  const ::flatbuffers::String *LAUNCH_SITE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_SITE);
  }
  /// Decay Date, if applicable [year-month-day] (ISO 8601)
  const ::flatbuffers::String *DECAY_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECAY_DATE);
  }
  /// Orbital period [minutes]
  double PERIOD() const {
    return GetField<double>(VT_PERIOD, 0.0);
  }
  /// Inclination [degrees]
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Apogee Altitude [kilometers]
  double APOGEE() const {
    return GetField<double>(VT_APOGEE, 0.0);
  }
  /// Perigee Altitude [kilometers]
  double PERIGEE() const {
    return GetField<double>(VT_PERIGEE, 0.0);
  }
  /// Radar Cross Section [meters2]; blank if no data available
  double RCS() const {
    return GetField<double>(VT_RCS, 0.0);
  }
  /// Data status code; blank otherwise
  dataStatusCode DATA_STATUS_CODE() const {
    return static_cast<dataStatusCode>(GetField<int8_t>(VT_DATA_STATUS_CODE, 0));
  }
  /// Orbit center
  const ::flatbuffers::String *ORBIT_CENTER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBIT_CENTER);
  }
  /// Orbit type (Orbit, Landing, Impact, Docked to RSO, roundtrip)
  orbitType ORBIT_TYPE() const {
    return static_cast<orbitType>(GetField<int8_t>(VT_ORBIT_TYPE, 0));
  }
  /// Deployment Date [year-month-day] (ISO 8601)
  const ::flatbuffers::String *DEPLOYMENT_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPLOYMENT_DATE);
  }
  /// Indicates if the object is maneuverable
  bool MANEUVERABLE() const {
    return GetField<uint8_t>(VT_MANEUVERABLE, 0) != 0;
  }
  /// Size [meters]; blank if no data available
  double SIZE() const {
    return GetField<double>(VT_SIZE, 0.0);
  }
  /// Mass [kilograms]; blank if no data available
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// Mass type (Dry, Wet)
  massType MASS_TYPE() const {
    return static_cast<massType>(GetField<int8_t>(VT_MASS_TYPE, 0));
  }
  /// Vector of PAYLOADS
  const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *PAYLOADS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *>(VT_PAYLOADS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_OBJECT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OPS_STATUS_CODE, 1) &&
           VerifyField<int8_t>(verifier, VT_OWNER, 1) &&
           VerifyOffset(verifier, VT_LAUNCH_DATE) &&
           verifier.VerifyString(LAUNCH_DATE()) &&
           VerifyOffset(verifier, VT_LAUNCH_SITE) &&
           verifier.VerifyString(LAUNCH_SITE()) &&
           VerifyOffset(verifier, VT_DECAY_DATE) &&
           verifier.VerifyString(DECAY_DATE()) &&
           VerifyField<double>(verifier, VT_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_APOGEE, 8) &&
           VerifyField<double>(verifier, VT_PERIGEE, 8) &&
           VerifyField<double>(verifier, VT_RCS, 8) &&
           VerifyField<int8_t>(verifier, VT_DATA_STATUS_CODE, 1) &&
           VerifyOffset(verifier, VT_ORBIT_CENTER) &&
           verifier.VerifyString(ORBIT_CENTER()) &&
           VerifyField<int8_t>(verifier, VT_ORBIT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DEPLOYMENT_DATE) &&
           verifier.VerifyString(DEPLOYMENT_DATE()) &&
           VerifyField<uint8_t>(verifier, VT_MANEUVERABLE, 1) &&
           VerifyField<double>(verifier, VT_SIZE, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyField<int8_t>(verifier, VT_MASS_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOADS) &&
           verifier.VerifyVector(PAYLOADS()) &&
           verifier.VerifyVectorOfTables(PAYLOADS()) &&
           verifier.EndTable();
  }
};

struct CATBuilder {
  typedef CAT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OBJECT_NAME(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(CAT::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(CAT::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_NORAD_CAT_ID(uint32_t NORAD_CAT_ID) {
    fbb_.AddElement<uint32_t>(CAT::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_OBJECT_TYPE(objectType OBJECT_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_OBJECT_TYPE, static_cast<int8_t>(OBJECT_TYPE), 3);
  }
  void add_OPS_STATUS_CODE(opsStatusCode OPS_STATUS_CODE) {
    fbb_.AddElement<int8_t>(CAT::VT_OPS_STATUS_CODE, static_cast<int8_t>(OPS_STATUS_CODE), 7);
  }
  void add_OWNER(ownerCode OWNER) {
    fbb_.AddElement<int8_t>(CAT::VT_OWNER, static_cast<int8_t>(OWNER), 0);
  }
  void add_LAUNCH_DATE(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_DATE) {
    fbb_.AddOffset(CAT::VT_LAUNCH_DATE, LAUNCH_DATE);
  }
  void add_LAUNCH_SITE(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_SITE) {
    fbb_.AddOffset(CAT::VT_LAUNCH_SITE, LAUNCH_SITE);
  }
  void add_DECAY_DATE(::flatbuffers::Offset<::flatbuffers::String> DECAY_DATE) {
    fbb_.AddOffset(CAT::VT_DECAY_DATE, DECAY_DATE);
  }
  void add_PERIOD(double PERIOD) {
    fbb_.AddElement<double>(CAT::VT_PERIOD, PERIOD, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(CAT::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_APOGEE(double APOGEE) {
    fbb_.AddElement<double>(CAT::VT_APOGEE, APOGEE, 0.0);
  }
  void add_PERIGEE(double PERIGEE) {
    fbb_.AddElement<double>(CAT::VT_PERIGEE, PERIGEE, 0.0);
  }
  void add_RCS(double RCS) {
    fbb_.AddElement<double>(CAT::VT_RCS, RCS, 0.0);
  }
  void add_DATA_STATUS_CODE(dataStatusCode DATA_STATUS_CODE) {
    fbb_.AddElement<int8_t>(CAT::VT_DATA_STATUS_CODE, static_cast<int8_t>(DATA_STATUS_CODE), 0);
  }
  void add_ORBIT_CENTER(::flatbuffers::Offset<::flatbuffers::String> ORBIT_CENTER) {
    fbb_.AddOffset(CAT::VT_ORBIT_CENTER, ORBIT_CENTER);
  }
  void add_ORBIT_TYPE(orbitType ORBIT_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_ORBIT_TYPE, static_cast<int8_t>(ORBIT_TYPE), 0);
  }
  void add_DEPLOYMENT_DATE(::flatbuffers::Offset<::flatbuffers::String> DEPLOYMENT_DATE) {
    fbb_.AddOffset(CAT::VT_DEPLOYMENT_DATE, DEPLOYMENT_DATE);
  }
  void add_MANEUVERABLE(bool MANEUVERABLE) {
    fbb_.AddElement<uint8_t>(CAT::VT_MANEUVERABLE, static_cast<uint8_t>(MANEUVERABLE), 0);
  }
  void add_SIZE(double SIZE) {
    fbb_.AddElement<double>(CAT::VT_SIZE, SIZE, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(CAT::VT_MASS, MASS, 0.0);
  }
  void add_MASS_TYPE(massType MASS_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_MASS_TYPE, static_cast<int8_t>(MASS_TYPE), 0);
  }
  void add_PAYLOADS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> PAYLOADS) {
    fbb_.AddOffset(CAT::VT_PAYLOADS, PAYLOADS);
  }
  explicit CATBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CAT> CreateCAT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID = 0,
    uint32_t NORAD_CAT_ID = 0,
    objectType OBJECT_TYPE = objectType_UNKNOWN,
    opsStatusCode OPS_STATUS_CODE = opsStatusCode_UNKNOWN,
    ownerCode OWNER = ownerCode_AB,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_SITE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DECAY_DATE = 0,
    double PERIOD = 0.0,
    double INCLINATION = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double RCS = 0.0,
    dataStatusCode DATA_STATUS_CODE = dataStatusCode_NO_CURRENT_ELEMENTS,
    ::flatbuffers::Offset<::flatbuffers::String> ORBIT_CENTER = 0,
    orbitType ORBIT_TYPE = orbitType_ORBIT,
    ::flatbuffers::Offset<::flatbuffers::String> DEPLOYMENT_DATE = 0,
    bool MANEUVERABLE = false,
    double SIZE = 0.0,
    double MASS = 0.0,
    massType MASS_TYPE = massType_DRY,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> PAYLOADS = 0) {
  CATBuilder builder_(_fbb);
  builder_.add_MASS(MASS);
  builder_.add_SIZE(SIZE);
  builder_.add_RCS(RCS);
  builder_.add_PERIGEE(PERIGEE);
  builder_.add_APOGEE(APOGEE);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_PERIOD(PERIOD);
  builder_.add_PAYLOADS(PAYLOADS);
  builder_.add_DEPLOYMENT_DATE(DEPLOYMENT_DATE);
  builder_.add_ORBIT_CENTER(ORBIT_CENTER);
  builder_.add_DECAY_DATE(DECAY_DATE);
  builder_.add_LAUNCH_SITE(LAUNCH_SITE);
  builder_.add_LAUNCH_DATE(LAUNCH_DATE);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  builder_.add_MASS_TYPE(MASS_TYPE);
  builder_.add_MANEUVERABLE(MANEUVERABLE);
  builder_.add_ORBIT_TYPE(ORBIT_TYPE);
  builder_.add_DATA_STATUS_CODE(DATA_STATUS_CODE);
  builder_.add_OWNER(OWNER);
  builder_.add_OPS_STATUS_CODE(OPS_STATUS_CODE);
  builder_.add_OBJECT_TYPE(OBJECT_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CAT> CreateCATDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *OBJECT_NAME = nullptr,
    const char *OBJECT_ID = nullptr,
    uint32_t NORAD_CAT_ID = 0,
    objectType OBJECT_TYPE = objectType_UNKNOWN,
    opsStatusCode OPS_STATUS_CODE = opsStatusCode_UNKNOWN,
    ownerCode OWNER = ownerCode_AB,
    const char *LAUNCH_DATE = nullptr,
    const char *LAUNCH_SITE = nullptr,
    const char *DECAY_DATE = nullptr,
    double PERIOD = 0.0,
    double INCLINATION = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double RCS = 0.0,
    dataStatusCode DATA_STATUS_CODE = dataStatusCode_NO_CURRENT_ELEMENTS,
    const char *ORBIT_CENTER = nullptr,
    orbitType ORBIT_TYPE = orbitType_ORBIT,
    const char *DEPLOYMENT_DATE = nullptr,
    bool MANEUVERABLE = false,
    double SIZE = 0.0,
    double MASS = 0.0,
    massType MASS_TYPE = massType_DRY,
    const std::vector<::flatbuffers::Offset<PLD>> *PAYLOADS = nullptr) {
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto LAUNCH_DATE__ = LAUNCH_DATE ? _fbb.CreateString(LAUNCH_DATE) : 0;
  auto LAUNCH_SITE__ = LAUNCH_SITE ? _fbb.CreateString(LAUNCH_SITE) : 0;
  auto DECAY_DATE__ = DECAY_DATE ? _fbb.CreateString(DECAY_DATE) : 0;
  auto ORBIT_CENTER__ = ORBIT_CENTER ? _fbb.CreateString(ORBIT_CENTER) : 0;
  auto DEPLOYMENT_DATE__ = DEPLOYMENT_DATE ? _fbb.CreateString(DEPLOYMENT_DATE) : 0;
  auto PAYLOADS__ = PAYLOADS ? _fbb.CreateVector<::flatbuffers::Offset<PLD>>(*PAYLOADS) : 0;
  return CreateCAT(
      _fbb,
      OBJECT_NAME__,
      OBJECT_ID__,
      NORAD_CAT_ID,
      OBJECT_TYPE,
      OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE__,
      LAUNCH_SITE__,
      DECAY_DATE__,
      PERIOD,
      INCLINATION,
      APOGEE,
      PERIGEE,
      RCS,
      DATA_STATUS_CODE,
      ORBIT_CENTER__,
      ORBIT_TYPE,
      DEPLOYMENT_DATE__,
      MANEUVERABLE,
      SIZE,
      MASS,
      MASS_TYPE,
      PAYLOADS__);
}

struct CATCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CATCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct CATCOLLECTIONBuilder {
  typedef CATCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> RECORDS) {
    fbb_.AddOffset(CATCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit CATCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CATCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CATCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CATCOLLECTION> CreateCATCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> RECORDS = 0) {
  CATCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CATCOLLECTION> CreateCATCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CAT>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<CAT>>(*RECORDS) : 0;
  return CreateCATCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const CAT *GetCAT(const void *buf) {
  return ::flatbuffers::GetRoot<CAT>(buf);
}

inline const CAT *GetSizePrefixedCAT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CAT>(buf);
}

inline const char *CATIdentifier() {
  return "$CAT";
}

inline bool CATBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CATIdentifier());
}

inline bool SizePrefixedCATBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CATIdentifier(), true);
}

inline bool VerifyCATBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CAT>(CATIdentifier());
}

inline bool VerifySizePrefixedCATBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CAT>(CATIdentifier());
}

inline void FinishCATBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CAT> root) {
  fbb.Finish(root, CATIdentifier());
}

inline void FinishSizePrefixedCATBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CAT> root) {
  fbb.FinishSizePrefixed(root, CATIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
