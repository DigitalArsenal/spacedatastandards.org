// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct CAT;
struct CATBuilder;

struct CATCOLLECTION;
struct CATCOLLECTIONBuilder;

enum objectType : int8_t {
  ///0
  objectType_PAYLOAD = 0,
  ///1
  objectType_ROCKET_BODY = 1,
  ///2
  objectType_DEBRIS = 2,
  ///3
  objectType_UNKNOWN = 3,
  objectType_MIN = objectType_PAYLOAD,
  objectType_MAX = objectType_UNKNOWN
};

inline const objectType (&EnumValuesobjectType())[4] {
  static const objectType values[] = {
    objectType_PAYLOAD,
    objectType_ROCKET_BODY,
    objectType_DEBRIS,
    objectType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesobjectType() {
  static const char * const names[5] = {
    "PAYLOAD",
    "ROCKET_BODY",
    "DEBRIS",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameobjectType(objectType e) {
  if (::flatbuffers::IsOutRange(e, objectType_PAYLOAD, objectType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesobjectType()[index];
}

enum opsStatusCode : int8_t {
  ///+
  opsStatusCode_OPERATIONAL = 0,
  ///-
  opsStatusCode_NONOPERATIONAL = 1,
  ///P
  opsStatusCode_PARTIALLY_OPERATIONAL = 2,
  ///B
  opsStatusCode_BACKUP_STANDBY = 3,
  ///S
  opsStatusCode_SPARE = 4,
  ///X
  opsStatusCode_EXTENDED_MISSION = 5,
  ///D
  opsStatusCode_DECAYED = 6,
  ///?
  opsStatusCode_UNKNOWN = 7,
  opsStatusCode_MIN = opsStatusCode_OPERATIONAL,
  opsStatusCode_MAX = opsStatusCode_UNKNOWN
};

inline const opsStatusCode (&EnumValuesopsStatusCode())[8] {
  static const opsStatusCode values[] = {
    opsStatusCode_OPERATIONAL,
    opsStatusCode_NONOPERATIONAL,
    opsStatusCode_PARTIALLY_OPERATIONAL,
    opsStatusCode_BACKUP_STANDBY,
    opsStatusCode_SPARE,
    opsStatusCode_EXTENDED_MISSION,
    opsStatusCode_DECAYED,
    opsStatusCode_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesopsStatusCode() {
  static const char * const names[9] = {
    "OPERATIONAL",
    "NONOPERATIONAL",
    "PARTIALLY_OPERATIONAL",
    "BACKUP_STANDBY",
    "SPARE",
    "EXTENDED_MISSION",
    "DECAYED",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameopsStatusCode(opsStatusCode e) {
  if (::flatbuffers::IsOutRange(e, opsStatusCode_OPERATIONAL, opsStatusCode_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesopsStatusCode()[index];
}

enum dataStatusCode : int8_t {
  ///NCE
  dataStatusCode_NO_CURRENT_ELEMENTS = 0,
  ///NIE
  dataStatusCode_NO_INITIAL_ELEMENTS = 1,
  ///NEA
  dataStatusCode_NO_ELEMENTS_AVAILABLE = 2,
  ///OK
  dataStatusCode_OK = 3,
  dataStatusCode_MIN = dataStatusCode_NO_CURRENT_ELEMENTS,
  dataStatusCode_MAX = dataStatusCode_OK
};

inline const dataStatusCode (&EnumValuesdataStatusCode())[4] {
  static const dataStatusCode values[] = {
    dataStatusCode_NO_CURRENT_ELEMENTS,
    dataStatusCode_NO_INITIAL_ELEMENTS,
    dataStatusCode_NO_ELEMENTS_AVAILABLE,
    dataStatusCode_OK
  };
  return values;
}

inline const char * const *EnumNamesdataStatusCode() {
  static const char * const names[5] = {
    "NO_CURRENT_ELEMENTS",
    "NO_INITIAL_ELEMENTS",
    "NO_ELEMENTS_AVAILABLE",
    "OK",
    nullptr
  };
  return names;
}

inline const char *EnumNamedataStatusCode(dataStatusCode e) {
  if (::flatbuffers::IsOutRange(e, dataStatusCode_NO_CURRENT_ELEMENTS, dataStatusCode_OK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesdataStatusCode()[index];
}

enum orbitType : int8_t {
  ///0
  orbitType_ORBIT = 0,
  ///1
  orbitType_LANDING = 1,
  ///2
  orbitType_IMPACT = 2,
  ///3
  orbitType_DOCKED = 3,
  ///4
  orbitType_ROUNDTRIP = 4,
  orbitType_MIN = orbitType_ORBIT,
  orbitType_MAX = orbitType_ROUNDTRIP
};

inline const orbitType (&EnumValuesorbitType())[5] {
  static const orbitType values[] = {
    orbitType_ORBIT,
    orbitType_LANDING,
    orbitType_IMPACT,
    orbitType_DOCKED,
    orbitType_ROUNDTRIP
  };
  return values;
}

inline const char * const *EnumNamesorbitType() {
  static const char * const names[6] = {
    "ORBIT",
    "LANDING",
    "IMPACT",
    "DOCKED",
    "ROUNDTRIP",
    nullptr
  };
  return names;
}

inline const char *EnumNameorbitType(orbitType e) {
  if (::flatbuffers::IsOutRange(e, orbitType_ORBIT, orbitType_ROUNDTRIP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesorbitType()[index];
}

enum massType : int8_t {
  massType_DRY = 0,
  massType_WET = 1,
  massType_MIN = massType_DRY,
  massType_MAX = massType_WET
};

inline const massType (&EnumValuesmassType())[2] {
  static const massType values[] = {
    massType_DRY,
    massType_WET
  };
  return values;
}

inline const char * const *EnumNamesmassType() {
  static const char * const names[3] = {
    "DRY",
    "WET",
    nullptr
  };
  return names;
}

inline const char *EnumNamemassType(massType e) {
  if (::flatbuffers::IsOutRange(e, massType_DRY, massType_WET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmassType()[index];
}

/// Catalog Entity Message
struct CAT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CATBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NAME = 4,
    VT_OBJECT_ID = 6,
    VT_NORAD_CAT_ID = 8,
    VT_OBJECT_TYPE = 10,
    VT_OPS_STATUS_CODE = 12,
    VT_OWNER = 14,
    VT_LAUNCH_DATE = 16,
    VT_LAUNCH_SITE = 18,
    VT_DECAY_DATE = 20,
    VT_PERIOD = 22,
    VT_INCLINATION = 24,
    VT_APOGEE = 26,
    VT_PERIGEE = 28,
    VT_RCS = 30,
    VT_DATA_STATUS_CODE = 32,
    VT_ORBIT_CENTER = 34,
    VT_ORBIT_TYPE = 36,
    VT_DEPLOYMENT_DATE = 38,
    VT_MANEUVERABLE = 40,
    VT_SIZE = 42,
    VT_MASS = 44,
    VT_MASS_TYPE = 46,
    VT_PAYLOADS = 48
  };
  /// Satellite Name(s)
  const ::flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  /// International Designator (YYYY-NNNAAA)
  const ::flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_ID);
  }
  /// NORAD Catalog Number
  uint32_t NORAD_CAT_ID() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID, 0);
  }
  /// Object type (Payload, Rocket body, Debris, Unknown)
  objectType OBJECT_TYPE() const {
    return static_cast<objectType>(GetField<int8_t>(VT_OBJECT_TYPE, 3));
  }
  /// Operational Status Code
  opsStatusCode OPS_STATUS_CODE() const {
    return static_cast<opsStatusCode>(GetField<int8_t>(VT_OPS_STATUS_CODE, 7));
  }
  /// Ownership, typically country or company
  const ::flatbuffers::String *OWNER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OWNER);
  }
  /// Launch Date [year-month-day] (ISO 8601)
  const ::flatbuffers::String *LAUNCH_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_DATE);
  }
  /// Launch Site
  const ::flatbuffers::String *LAUNCH_SITE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_SITE);
  }
  /// Decay Date, if applicable [year-month-day] (ISO 8601)
  const ::flatbuffers::String *DECAY_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECAY_DATE);
  }
  /// Orbital period [minutes]
  double PERIOD() const {
    return GetField<double>(VT_PERIOD, 0.0);
  }
  /// Inclination [degrees]
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Apogee Altitude [kilometers]
  double APOGEE() const {
    return GetField<double>(VT_APOGEE, 0.0);
  }
  /// Perigee Altitude [kilometers]
  double PERIGEE() const {
    return GetField<double>(VT_PERIGEE, 0.0);
  }
  /// Radar Cross Section [meters2]; blank if no data available
  double RCS() const {
    return GetField<double>(VT_RCS, 0.0);
  }
  /// Data status code; blank otherwise
  dataStatusCode DATA_STATUS_CODE() const {
    return static_cast<dataStatusCode>(GetField<int8_t>(VT_DATA_STATUS_CODE, 0));
  }
  /// Orbit center
  const ::flatbuffers::String *ORBIT_CENTER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBIT_CENTER);
  }
  /// Orbit type (Orbit, Landing, Impact, Docked to RSO, roundtrip)
  orbitType ORBIT_TYPE() const {
    return static_cast<orbitType>(GetField<int8_t>(VT_ORBIT_TYPE, 0));
  }
  /// Deployment Date [year-month-day] (ISO 8601)
  const ::flatbuffers::String *DEPLOYMENT_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEPLOYMENT_DATE);
  }
  /// Indicates if the object is maneuverable
  bool MANEUVERABLE() const {
    return GetField<uint8_t>(VT_MANEUVERABLE, 0) != 0;
  }
  /// Size [meters]; blank if no data available
  double SIZE() const {
    return GetField<double>(VT_SIZE, 0.0);
  }
  /// Mass [kilograms]; blank if no data available
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  /// Mass type (Dry, Wet)
  massType MASS_TYPE() const {
    return static_cast<massType>(GetField<int8_t>(VT_MASS_TYPE, 0));
  }
  /// Vector of PAYLOADS
  const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *PAYLOADS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *>(VT_PAYLOADS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_OBJECT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_OPS_STATUS_CODE, 1) &&
           VerifyOffset(verifier, VT_OWNER) &&
           verifier.VerifyString(OWNER()) &&
           VerifyOffset(verifier, VT_LAUNCH_DATE) &&
           verifier.VerifyString(LAUNCH_DATE()) &&
           VerifyOffset(verifier, VT_LAUNCH_SITE) &&
           verifier.VerifyString(LAUNCH_SITE()) &&
           VerifyOffset(verifier, VT_DECAY_DATE) &&
           verifier.VerifyString(DECAY_DATE()) &&
           VerifyField<double>(verifier, VT_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_APOGEE, 8) &&
           VerifyField<double>(verifier, VT_PERIGEE, 8) &&
           VerifyField<double>(verifier, VT_RCS, 8) &&
           VerifyField<int8_t>(verifier, VT_DATA_STATUS_CODE, 1) &&
           VerifyOffset(verifier, VT_ORBIT_CENTER) &&
           verifier.VerifyString(ORBIT_CENTER()) &&
           VerifyField<int8_t>(verifier, VT_ORBIT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DEPLOYMENT_DATE) &&
           verifier.VerifyString(DEPLOYMENT_DATE()) &&
           VerifyField<uint8_t>(verifier, VT_MANEUVERABLE, 1) &&
           VerifyField<double>(verifier, VT_SIZE, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyField<int8_t>(verifier, VT_MASS_TYPE, 1) &&
           VerifyOffset(verifier, VT_PAYLOADS) &&
           verifier.VerifyVector(PAYLOADS()) &&
           verifier.VerifyVectorOfTables(PAYLOADS()) &&
           verifier.EndTable();
  }
};

struct CATBuilder {
  typedef CAT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OBJECT_NAME(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(CAT::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(CAT::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_NORAD_CAT_ID(uint32_t NORAD_CAT_ID) {
    fbb_.AddElement<uint32_t>(CAT::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_OBJECT_TYPE(objectType OBJECT_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_OBJECT_TYPE, static_cast<int8_t>(OBJECT_TYPE), 3);
  }
  void add_OPS_STATUS_CODE(opsStatusCode OPS_STATUS_CODE) {
    fbb_.AddElement<int8_t>(CAT::VT_OPS_STATUS_CODE, static_cast<int8_t>(OPS_STATUS_CODE), 7);
  }
  void add_OWNER(::flatbuffers::Offset<::flatbuffers::String> OWNER) {
    fbb_.AddOffset(CAT::VT_OWNER, OWNER);
  }
  void add_LAUNCH_DATE(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_DATE) {
    fbb_.AddOffset(CAT::VT_LAUNCH_DATE, LAUNCH_DATE);
  }
  void add_LAUNCH_SITE(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_SITE) {
    fbb_.AddOffset(CAT::VT_LAUNCH_SITE, LAUNCH_SITE);
  }
  void add_DECAY_DATE(::flatbuffers::Offset<::flatbuffers::String> DECAY_DATE) {
    fbb_.AddOffset(CAT::VT_DECAY_DATE, DECAY_DATE);
  }
  void add_PERIOD(double PERIOD) {
    fbb_.AddElement<double>(CAT::VT_PERIOD, PERIOD, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(CAT::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_APOGEE(double APOGEE) {
    fbb_.AddElement<double>(CAT::VT_APOGEE, APOGEE, 0.0);
  }
  void add_PERIGEE(double PERIGEE) {
    fbb_.AddElement<double>(CAT::VT_PERIGEE, PERIGEE, 0.0);
  }
  void add_RCS(double RCS) {
    fbb_.AddElement<double>(CAT::VT_RCS, RCS, 0.0);
  }
  void add_DATA_STATUS_CODE(dataStatusCode DATA_STATUS_CODE) {
    fbb_.AddElement<int8_t>(CAT::VT_DATA_STATUS_CODE, static_cast<int8_t>(DATA_STATUS_CODE), 0);
  }
  void add_ORBIT_CENTER(::flatbuffers::Offset<::flatbuffers::String> ORBIT_CENTER) {
    fbb_.AddOffset(CAT::VT_ORBIT_CENTER, ORBIT_CENTER);
  }
  void add_ORBIT_TYPE(orbitType ORBIT_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_ORBIT_TYPE, static_cast<int8_t>(ORBIT_TYPE), 0);
  }
  void add_DEPLOYMENT_DATE(::flatbuffers::Offset<::flatbuffers::String> DEPLOYMENT_DATE) {
    fbb_.AddOffset(CAT::VT_DEPLOYMENT_DATE, DEPLOYMENT_DATE);
  }
  void add_MANEUVERABLE(bool MANEUVERABLE) {
    fbb_.AddElement<uint8_t>(CAT::VT_MANEUVERABLE, static_cast<uint8_t>(MANEUVERABLE), 0);
  }
  void add_SIZE(double SIZE) {
    fbb_.AddElement<double>(CAT::VT_SIZE, SIZE, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(CAT::VT_MASS, MASS, 0.0);
  }
  void add_MASS_TYPE(massType MASS_TYPE) {
    fbb_.AddElement<int8_t>(CAT::VT_MASS_TYPE, static_cast<int8_t>(MASS_TYPE), 0);
  }
  void add_PAYLOADS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> PAYLOADS) {
    fbb_.AddOffset(CAT::VT_PAYLOADS, PAYLOADS);
  }
  explicit CATBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CAT> CreateCAT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID = 0,
    uint32_t NORAD_CAT_ID = 0,
    objectType OBJECT_TYPE = objectType_UNKNOWN,
    opsStatusCode OPS_STATUS_CODE = opsStatusCode_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> OWNER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_SITE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DECAY_DATE = 0,
    double PERIOD = 0.0,
    double INCLINATION = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double RCS = 0.0,
    dataStatusCode DATA_STATUS_CODE = dataStatusCode_NO_CURRENT_ELEMENTS,
    ::flatbuffers::Offset<::flatbuffers::String> ORBIT_CENTER = 0,
    orbitType ORBIT_TYPE = orbitType_ORBIT,
    ::flatbuffers::Offset<::flatbuffers::String> DEPLOYMENT_DATE = 0,
    bool MANEUVERABLE = false,
    double SIZE = 0.0,
    double MASS = 0.0,
    massType MASS_TYPE = massType_DRY,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> PAYLOADS = 0) {
  CATBuilder builder_(_fbb);
  builder_.add_MASS(MASS);
  builder_.add_SIZE(SIZE);
  builder_.add_RCS(RCS);
  builder_.add_PERIGEE(PERIGEE);
  builder_.add_APOGEE(APOGEE);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_PERIOD(PERIOD);
  builder_.add_PAYLOADS(PAYLOADS);
  builder_.add_DEPLOYMENT_DATE(DEPLOYMENT_DATE);
  builder_.add_ORBIT_CENTER(ORBIT_CENTER);
  builder_.add_DECAY_DATE(DECAY_DATE);
  builder_.add_LAUNCH_SITE(LAUNCH_SITE);
  builder_.add_LAUNCH_DATE(LAUNCH_DATE);
  builder_.add_OWNER(OWNER);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  builder_.add_MASS_TYPE(MASS_TYPE);
  builder_.add_MANEUVERABLE(MANEUVERABLE);
  builder_.add_ORBIT_TYPE(ORBIT_TYPE);
  builder_.add_DATA_STATUS_CODE(DATA_STATUS_CODE);
  builder_.add_OPS_STATUS_CODE(OPS_STATUS_CODE);
  builder_.add_OBJECT_TYPE(OBJECT_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CAT> CreateCATDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *OBJECT_NAME = nullptr,
    const char *OBJECT_ID = nullptr,
    uint32_t NORAD_CAT_ID = 0,
    objectType OBJECT_TYPE = objectType_UNKNOWN,
    opsStatusCode OPS_STATUS_CODE = opsStatusCode_UNKNOWN,
    const char *OWNER = nullptr,
    const char *LAUNCH_DATE = nullptr,
    const char *LAUNCH_SITE = nullptr,
    const char *DECAY_DATE = nullptr,
    double PERIOD = 0.0,
    double INCLINATION = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    double RCS = 0.0,
    dataStatusCode DATA_STATUS_CODE = dataStatusCode_NO_CURRENT_ELEMENTS,
    const char *ORBIT_CENTER = nullptr,
    orbitType ORBIT_TYPE = orbitType_ORBIT,
    const char *DEPLOYMENT_DATE = nullptr,
    bool MANEUVERABLE = false,
    double SIZE = 0.0,
    double MASS = 0.0,
    massType MASS_TYPE = massType_DRY,
    const std::vector<::flatbuffers::Offset<PLD>> *PAYLOADS = nullptr) {
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto OWNER__ = OWNER ? _fbb.CreateString(OWNER) : 0;
  auto LAUNCH_DATE__ = LAUNCH_DATE ? _fbb.CreateString(LAUNCH_DATE) : 0;
  auto LAUNCH_SITE__ = LAUNCH_SITE ? _fbb.CreateString(LAUNCH_SITE) : 0;
  auto DECAY_DATE__ = DECAY_DATE ? _fbb.CreateString(DECAY_DATE) : 0;
  auto ORBIT_CENTER__ = ORBIT_CENTER ? _fbb.CreateString(ORBIT_CENTER) : 0;
  auto DEPLOYMENT_DATE__ = DEPLOYMENT_DATE ? _fbb.CreateString(DEPLOYMENT_DATE) : 0;
  auto PAYLOADS__ = PAYLOADS ? _fbb.CreateVector<::flatbuffers::Offset<PLD>>(*PAYLOADS) : 0;
  return CreateCAT(
      _fbb,
      OBJECT_NAME__,
      OBJECT_ID__,
      NORAD_CAT_ID,
      OBJECT_TYPE,
      OPS_STATUS_CODE,
      OWNER__,
      LAUNCH_DATE__,
      LAUNCH_SITE__,
      DECAY_DATE__,
      PERIOD,
      INCLINATION,
      APOGEE,
      PERIGEE,
      RCS,
      DATA_STATUS_CODE,
      ORBIT_CENTER__,
      ORBIT_TYPE,
      DEPLOYMENT_DATE__,
      MANEUVERABLE,
      SIZE,
      MASS,
      MASS_TYPE,
      PAYLOADS__);
}

struct CATCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CATCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct CATCOLLECTIONBuilder {
  typedef CATCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> RECORDS) {
    fbb_.AddOffset(CATCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit CATCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CATCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CATCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CATCOLLECTION> CreateCATCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> RECORDS = 0) {
  CATCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CATCOLLECTION> CreateCATCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CAT>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<CAT>>(*RECORDS) : 0;
  return CreateCATCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const CAT *GetCAT(const void *buf) {
  return ::flatbuffers::GetRoot<CAT>(buf);
}

inline const CAT *GetSizePrefixedCAT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CAT>(buf);
}

inline const char *CATIdentifier() {
  return "$CAT";
}

inline bool CATBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CATIdentifier());
}

inline bool SizePrefixedCATBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CATIdentifier(), true);
}

inline bool VerifyCATBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CAT>(CATIdentifier());
}

inline bool VerifySizePrefixedCATBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CAT>(CATIdentifier());
}

inline void FinishCATBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CAT> root) {
  fbb.Finish(root, CATIdentifier());
}

inline void FinishSizePrefixedCATBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CAT> root) {
  fbb.FinishSizePrefixed(root, CATIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
