// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct GJNPosition;
struct GJNPositionBuilder;

struct GJNLinearRing;
struct GJNLinearRingBuilder;

struct GJNPolygonRings;
struct GJNPolygonRingsBuilder;

struct GJNGeometry;
struct GJNGeometryBuilder;

struct GJNProperty;
struct GJNPropertyBuilder;

struct GJNFeature;
struct GJNFeatureBuilder;

struct GJNBoundingBox;
struct GJNBoundingBoxBuilder;

struct GJN;
struct GJNBuilder;

enum GJNGeometryType : int8_t {
  GJNGeometryType_POINT = 0,
  GJNGeometryType_MULTI_POINT = 1,
  GJNGeometryType_LINE_STRING = 2,
  GJNGeometryType_MULTI_LINE_STRING = 3,
  GJNGeometryType_POLYGON = 4,
  GJNGeometryType_MULTI_POLYGON = 5,
  GJNGeometryType_GEOMETRY_COLLECTION = 6,
  GJNGeometryType_MIN = GJNGeometryType_POINT,
  GJNGeometryType_MAX = GJNGeometryType_GEOMETRY_COLLECTION
};

inline const GJNGeometryType (&EnumValuesGJNGeometryType())[7] {
  static const GJNGeometryType values[] = {
    GJNGeometryType_POINT,
    GJNGeometryType_MULTI_POINT,
    GJNGeometryType_LINE_STRING,
    GJNGeometryType_MULTI_LINE_STRING,
    GJNGeometryType_POLYGON,
    GJNGeometryType_MULTI_POLYGON,
    GJNGeometryType_GEOMETRY_COLLECTION
  };
  return values;
}

inline const char * const *EnumNamesGJNGeometryType() {
  static const char * const names[8] = {
    "POINT",
    "MULTI_POINT",
    "LINE_STRING",
    "MULTI_LINE_STRING",
    "POLYGON",
    "MULTI_POLYGON",
    "GEOMETRY_COLLECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameGJNGeometryType(GJNGeometryType e) {
  if (::flatbuffers::IsOutRange(e, GJNGeometryType_POINT, GJNGeometryType_GEOMETRY_COLLECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGJNGeometryType()[index];
}

/// A single position (longitude, latitude, optional altitude)
struct GJNPosition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNPositionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  /// Longitude in decimal degrees (WGS84)
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Latitude in decimal degrees (WGS84)
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Altitude in meters above WGS84 ellipsoid (optional)
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           verifier.EndTable();
  }
};

struct GJNPositionBuilder {
  typedef GJNPosition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(GJNPosition::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(GJNPosition::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(GJNPosition::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  explicit GJNPositionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNPosition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNPosition> CreateGJNPosition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LONGITUDE = 0.0,
    double LATITUDE = 0.0,
    double ALTITUDE = 0.0) {
  GJNPositionBuilder builder_(_fbb);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  return builder_.Finish();
}

/// A linear ring is a closed LineString with 4+ positions (first = last)
struct GJNLinearRing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNLinearRingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITIONS = 4
  };
  /// Ordered positions forming the ring
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>> *POSITIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>> *>(VT_POSITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(POSITIONS()) &&
           verifier.VerifyVectorOfTables(POSITIONS()) &&
           verifier.EndTable();
  }
};

struct GJNLinearRingBuilder {
  typedef GJNLinearRing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>>> POSITIONS) {
    fbb_.AddOffset(GJNLinearRing::VT_POSITIONS, POSITIONS);
  }
  explicit GJNLinearRingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNLinearRing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNLinearRing>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNLinearRing> CreateGJNLinearRing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>>> POSITIONS = 0) {
  GJNLinearRingBuilder builder_(_fbb);
  builder_.add_POSITIONS(POSITIONS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJNLinearRing> CreateGJNLinearRingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<GJNPosition>> *POSITIONS = nullptr) {
  auto POSITIONS__ = POSITIONS ? _fbb.CreateVector<::flatbuffers::Offset<GJNPosition>>(*POSITIONS) : 0;
  return CreateGJNLinearRing(
      _fbb,
      POSITIONS__);
}

/// A polygon represented as an array of rings (outer boundary + holes)
struct GJNPolygonRings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNPolygonRingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RINGS = 4
  };
  /// Rings: first is outer boundary, rest are holes
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>> *RINGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>> *>(VT_RINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RINGS) &&
           verifier.VerifyVector(RINGS()) &&
           verifier.VerifyVectorOfTables(RINGS()) &&
           verifier.EndTable();
  }
};

struct GJNPolygonRingsBuilder {
  typedef GJNPolygonRings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RINGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>>> RINGS) {
    fbb_.AddOffset(GJNPolygonRings::VT_RINGS, RINGS);
  }
  explicit GJNPolygonRingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNPolygonRings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNPolygonRings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNPolygonRings> CreateGJNPolygonRings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>>> RINGS = 0) {
  GJNPolygonRingsBuilder builder_(_fbb);
  builder_.add_RINGS(RINGS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJNPolygonRings> CreateGJNPolygonRingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<GJNLinearRing>> *RINGS = nullptr) {
  auto RINGS__ = RINGS ? _fbb.CreateVector<::flatbuffers::Offset<GJNLinearRing>>(*RINGS) : 0;
  return CreateGJNPolygonRings(
      _fbb,
      RINGS__);
}

/// GeoJSON Geometry object
struct GJNGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_POINT = 6,
    VT_POSITIONS = 8,
    VT_RINGS = 10,
    VT_POLYGON_RINGS = 12,
    VT_GEOMETRIES = 14
  };
  /// Geometry type
  GJNGeometryType TYPE() const {
    return static_cast<GJNGeometryType>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Single position (for Point)
  const GJNPosition *POINT() const {
    return GetPointer<const GJNPosition *>(VT_POINT);
  }
  /// Array of positions (for MultiPoint, LineString)
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>> *POSITIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>> *>(VT_POSITIONS);
  }
  /// Array of position arrays (for MultiLineString, Polygon rings)
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>> *RINGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>> *>(VT_RINGS);
  }
  /// Array of polygons each as array of rings (for MultiPolygon)
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPolygonRings>> *POLYGON_RINGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNPolygonRings>> *>(VT_POLYGON_RINGS);
  }
  /// Child geometries (for GeometryCollection)
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNGeometry>> *GEOMETRIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNGeometry>> *>(VT_GEOMETRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyTable(POINT()) &&
           VerifyOffset(verifier, VT_POSITIONS) &&
           verifier.VerifyVector(POSITIONS()) &&
           verifier.VerifyVectorOfTables(POSITIONS()) &&
           VerifyOffset(verifier, VT_RINGS) &&
           verifier.VerifyVector(RINGS()) &&
           verifier.VerifyVectorOfTables(RINGS()) &&
           VerifyOffset(verifier, VT_POLYGON_RINGS) &&
           verifier.VerifyVector(POLYGON_RINGS()) &&
           verifier.VerifyVectorOfTables(POLYGON_RINGS()) &&
           VerifyOffset(verifier, VT_GEOMETRIES) &&
           verifier.VerifyVector(GEOMETRIES()) &&
           verifier.VerifyVectorOfTables(GEOMETRIES()) &&
           verifier.EndTable();
  }
};

struct GJNGeometryBuilder {
  typedef GJNGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TYPE(GJNGeometryType TYPE) {
    fbb_.AddElement<int8_t>(GJNGeometry::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_POINT(::flatbuffers::Offset<GJNPosition> POINT) {
    fbb_.AddOffset(GJNGeometry::VT_POINT, POINT);
  }
  void add_POSITIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>>> POSITIONS) {
    fbb_.AddOffset(GJNGeometry::VT_POSITIONS, POSITIONS);
  }
  void add_RINGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>>> RINGS) {
    fbb_.AddOffset(GJNGeometry::VT_RINGS, RINGS);
  }
  void add_POLYGON_RINGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPolygonRings>>> POLYGON_RINGS) {
    fbb_.AddOffset(GJNGeometry::VT_POLYGON_RINGS, POLYGON_RINGS);
  }
  void add_GEOMETRIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNGeometry>>> GEOMETRIES) {
    fbb_.AddOffset(GJNGeometry::VT_GEOMETRIES, GEOMETRIES);
  }
  explicit GJNGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNGeometry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNGeometry> CreateGJNGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GJNGeometryType TYPE = GJNGeometryType_POINT,
    ::flatbuffers::Offset<GJNPosition> POINT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPosition>>> POSITIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNLinearRing>>> RINGS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNPolygonRings>>> POLYGON_RINGS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNGeometry>>> GEOMETRIES = 0) {
  GJNGeometryBuilder builder_(_fbb);
  builder_.add_GEOMETRIES(GEOMETRIES);
  builder_.add_POLYGON_RINGS(POLYGON_RINGS);
  builder_.add_RINGS(RINGS);
  builder_.add_POSITIONS(POSITIONS);
  builder_.add_POINT(POINT);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJNGeometry> CreateGJNGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    GJNGeometryType TYPE = GJNGeometryType_POINT,
    ::flatbuffers::Offset<GJNPosition> POINT = 0,
    const std::vector<::flatbuffers::Offset<GJNPosition>> *POSITIONS = nullptr,
    const std::vector<::flatbuffers::Offset<GJNLinearRing>> *RINGS = nullptr,
    const std::vector<::flatbuffers::Offset<GJNPolygonRings>> *POLYGON_RINGS = nullptr,
    const std::vector<::flatbuffers::Offset<GJNGeometry>> *GEOMETRIES = nullptr) {
  auto POSITIONS__ = POSITIONS ? _fbb.CreateVector<::flatbuffers::Offset<GJNPosition>>(*POSITIONS) : 0;
  auto RINGS__ = RINGS ? _fbb.CreateVector<::flatbuffers::Offset<GJNLinearRing>>(*RINGS) : 0;
  auto POLYGON_RINGS__ = POLYGON_RINGS ? _fbb.CreateVector<::flatbuffers::Offset<GJNPolygonRings>>(*POLYGON_RINGS) : 0;
  auto GEOMETRIES__ = GEOMETRIES ? _fbb.CreateVector<::flatbuffers::Offset<GJNGeometry>>(*GEOMETRIES) : 0;
  return CreateGJNGeometry(
      _fbb,
      TYPE,
      POINT,
      POSITIONS__,
      RINGS__,
      POLYGON_RINGS__,
      GEOMETRIES__);
}

/// A key-value property entry for Feature properties
struct GJNProperty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNPropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6,
    VT_NUM_VALUE = 8,
    VT_IS_NUMERIC = 10
  };
  /// Property key
  const ::flatbuffers::String *KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  /// Property value as string
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  /// Property value as number (use if numeric)
  double NUM_VALUE() const {
    return GetField<double>(VT_NUM_VALUE, 0.0);
  }
  /// True if NUM_VALUE should be used instead of VALUE
  bool IS_NUMERIC() const {
    return GetField<uint8_t>(VT_IS_NUMERIC, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(KEY()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           VerifyField<double>(verifier, VT_NUM_VALUE, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_NUMERIC, 1) &&
           verifier.EndTable();
  }
};

struct GJNPropertyBuilder {
  typedef GJNProperty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_KEY(::flatbuffers::Offset<::flatbuffers::String> KEY) {
    fbb_.AddOffset(GJNProperty::VT_KEY, KEY);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(GJNProperty::VT_VALUE, VALUE);
  }
  void add_NUM_VALUE(double NUM_VALUE) {
    fbb_.AddElement<double>(GJNProperty::VT_NUM_VALUE, NUM_VALUE, 0.0);
  }
  void add_IS_NUMERIC(bool IS_NUMERIC) {
    fbb_.AddElement<uint8_t>(GJNProperty::VT_IS_NUMERIC, static_cast<uint8_t>(IS_NUMERIC), 0);
  }
  explicit GJNPropertyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNProperty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNProperty> CreateGJNProperty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0,
    double NUM_VALUE = 0.0,
    bool IS_NUMERIC = false) {
  GJNPropertyBuilder builder_(_fbb);
  builder_.add_NUM_VALUE(NUM_VALUE);
  builder_.add_VALUE(VALUE);
  builder_.add_KEY(KEY);
  builder_.add_IS_NUMERIC(IS_NUMERIC);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJNProperty> CreateGJNPropertyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *KEY = nullptr,
    const char *VALUE = nullptr,
    double NUM_VALUE = 0.0,
    bool IS_NUMERIC = false) {
  auto KEY__ = KEY ? _fbb.CreateString(KEY) : 0;
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateGJNProperty(
      _fbb,
      KEY__,
      VALUE__,
      NUM_VALUE,
      IS_NUMERIC);
}

/// GeoJSON Feature object
struct GJNFeature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNFeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_GEOMETRY = 6,
    VT_PROPERTIES = 8
  };
  /// Feature identifier (optional)
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Geometry of the feature
  const GJNGeometry *GEOMETRY() const {
    return GetPointer<const GJNGeometry *>(VT_GEOMETRY);
  }
  /// Properties as key-value pairs
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNProperty>> *PROPERTIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNProperty>> *>(VT_PROPERTIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyTable(GEOMETRY()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(PROPERTIES()) &&
           verifier.VerifyVectorOfTables(PROPERTIES()) &&
           verifier.EndTable();
  }
};

struct GJNFeatureBuilder {
  typedef GJNFeature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(GJNFeature::VT_ID, ID);
  }
  void add_GEOMETRY(::flatbuffers::Offset<GJNGeometry> GEOMETRY) {
    fbb_.AddOffset(GJNFeature::VT_GEOMETRY, GEOMETRY);
  }
  void add_PROPERTIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNProperty>>> PROPERTIES) {
    fbb_.AddOffset(GJNFeature::VT_PROPERTIES, PROPERTIES);
  }
  explicit GJNFeatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNFeature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNFeature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNFeature> CreateGJNFeature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<GJNGeometry> GEOMETRY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNProperty>>> PROPERTIES = 0) {
  GJNFeatureBuilder builder_(_fbb);
  builder_.add_PROPERTIES(PROPERTIES);
  builder_.add_GEOMETRY(GEOMETRY);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJNFeature> CreateGJNFeatureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    ::flatbuffers::Offset<GJNGeometry> GEOMETRY = 0,
    const std::vector<::flatbuffers::Offset<GJNProperty>> *PROPERTIES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto PROPERTIES__ = PROPERTIES ? _fbb.CreateVector<::flatbuffers::Offset<GJNProperty>>(*PROPERTIES) : 0;
  return CreateGJNFeature(
      _fbb,
      ID__,
      GEOMETRY,
      PROPERTIES__);
}

/// GeoJSON Bounding Box [west, south, east, north] or [west, south, min-alt, east, north, max-alt]
struct GJNBoundingBox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNBoundingBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEST = 4,
    VT_SOUTH = 6,
    VT_EAST = 8,
    VT_NORTH = 10,
    VT_MIN_ALTITUDE = 12,
    VT_MAX_ALTITUDE = 14
  };
  /// Western longitude
  double WEST() const {
    return GetField<double>(VT_WEST, 0.0);
  }
  /// Southern latitude
  double SOUTH() const {
    return GetField<double>(VT_SOUTH, 0.0);
  }
  /// Eastern longitude
  double EAST() const {
    return GetField<double>(VT_EAST, 0.0);
  }
  /// Northern latitude
  double NORTH() const {
    return GetField<double>(VT_NORTH, 0.0);
  }
  /// Minimum altitude (optional)
  double MIN_ALTITUDE() const {
    return GetField<double>(VT_MIN_ALTITUDE, 0.0);
  }
  /// Maximum altitude (optional)
  double MAX_ALTITUDE() const {
    return GetField<double>(VT_MAX_ALTITUDE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_WEST, 8) &&
           VerifyField<double>(verifier, VT_SOUTH, 8) &&
           VerifyField<double>(verifier, VT_EAST, 8) &&
           VerifyField<double>(verifier, VT_NORTH, 8) &&
           VerifyField<double>(verifier, VT_MIN_ALTITUDE, 8) &&
           VerifyField<double>(verifier, VT_MAX_ALTITUDE, 8) &&
           verifier.EndTable();
  }
};

struct GJNBoundingBoxBuilder {
  typedef GJNBoundingBox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_WEST(double WEST) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_WEST, WEST, 0.0);
  }
  void add_SOUTH(double SOUTH) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_SOUTH, SOUTH, 0.0);
  }
  void add_EAST(double EAST) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_EAST, EAST, 0.0);
  }
  void add_NORTH(double NORTH) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_NORTH, NORTH, 0.0);
  }
  void add_MIN_ALTITUDE(double MIN_ALTITUDE) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_MIN_ALTITUDE, MIN_ALTITUDE, 0.0);
  }
  void add_MAX_ALTITUDE(double MAX_ALTITUDE) {
    fbb_.AddElement<double>(GJNBoundingBox::VT_MAX_ALTITUDE, MAX_ALTITUDE, 0.0);
  }
  explicit GJNBoundingBoxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJNBoundingBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJNBoundingBox>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJNBoundingBox> CreateGJNBoundingBox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double WEST = 0.0,
    double SOUTH = 0.0,
    double EAST = 0.0,
    double NORTH = 0.0,
    double MIN_ALTITUDE = 0.0,
    double MAX_ALTITUDE = 0.0) {
  GJNBoundingBoxBuilder builder_(_fbb);
  builder_.add_MAX_ALTITUDE(MAX_ALTITUDE);
  builder_.add_MIN_ALTITUDE(MIN_ALTITUDE);
  builder_.add_NORTH(NORTH);
  builder_.add_EAST(EAST);
  builder_.add_SOUTH(SOUTH);
  builder_.add_WEST(WEST);
  return builder_.Finish();
}

/// GeoJSON FeatureCollection
struct GJN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GJNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATURES = 4,
    VT_BBOX = 6
  };
  /// Features in the collection
  const ::flatbuffers::Vector<::flatbuffers::Offset<GJNFeature>> *FEATURES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GJNFeature>> *>(VT_FEATURES);
  }
  /// Bounding box (optional)
  const GJNBoundingBox *BBOX() const {
    return GetPointer<const GJNBoundingBox *>(VT_BBOX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(FEATURES()) &&
           verifier.VerifyVectorOfTables(FEATURES()) &&
           VerifyOffset(verifier, VT_BBOX) &&
           verifier.VerifyTable(BBOX()) &&
           verifier.EndTable();
  }
};

struct GJNBuilder {
  typedef GJN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FEATURES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNFeature>>> FEATURES) {
    fbb_.AddOffset(GJN::VT_FEATURES, FEATURES);
  }
  void add_BBOX(::flatbuffers::Offset<GJNBoundingBox> BBOX) {
    fbb_.AddOffset(GJN::VT_BBOX, BBOX);
  }
  explicit GJNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GJN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GJN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GJN> CreateGJN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GJNFeature>>> FEATURES = 0,
    ::flatbuffers::Offset<GJNBoundingBox> BBOX = 0) {
  GJNBuilder builder_(_fbb);
  builder_.add_BBOX(BBOX);
  builder_.add_FEATURES(FEATURES);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GJN> CreateGJNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<GJNFeature>> *FEATURES = nullptr,
    ::flatbuffers::Offset<GJNBoundingBox> BBOX = 0) {
  auto FEATURES__ = FEATURES ? _fbb.CreateVector<::flatbuffers::Offset<GJNFeature>>(*FEATURES) : 0;
  return CreateGJN(
      _fbb,
      FEATURES__,
      BBOX);
}

inline const GJN *GetGJN(const void *buf) {
  return ::flatbuffers::GetRoot<GJN>(buf);
}

inline const GJN *GetSizePrefixedGJN(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GJN>(buf);
}

inline const char *GJNIdentifier() {
  return "$GJN";
}

inline bool GJNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GJNIdentifier());
}

inline bool SizePrefixedGJNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GJNIdentifier(), true);
}

inline bool VerifyGJNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GJN>(GJNIdentifier());
}

inline bool VerifySizePrefixedGJNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GJN>(GJNIdentifier());
}

inline void FinishGJNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GJN> root) {
  fbb.Finish(root, GJNIdentifier());
}

inline void FinishSizePrefixedGJNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GJN> root) {
  fbb.FinishSizePrefixed(root, GJNIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
