// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct FrequencyRange;
struct FrequencyRangeBuilder;

struct StokesParameters;
struct StokesParametersBuilder;

struct Band;
struct BandBuilder;

struct IDM;
struct IDMBuilder;

/// Different types of polarization in EMT
enum PolarizationType : int8_t {
  PolarizationType_linear = 0,
  PolarizationType_circular = 1,
  PolarizationType_elliptical = 2,
  PolarizationType_unpolarized = 3,
  PolarizationType_MIN = PolarizationType_linear,
  PolarizationType_MAX = PolarizationType_unpolarized
};

inline const PolarizationType (&EnumValuesPolarizationType())[4] {
  static const PolarizationType values[] = {
    PolarizationType_linear,
    PolarizationType_circular,
    PolarizationType_elliptical,
    PolarizationType_unpolarized
  };
  return values;
}

inline const char * const *EnumNamesPolarizationType() {
  static const char * const names[5] = {
    "linear",
    "circular",
    "elliptical",
    "unpolarized",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolarizationType(PolarizationType e) {
  if (::flatbuffers::IsOutRange(e, PolarizationType_linear, PolarizationType_unpolarized)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPolarizationType()[index];
}

/// Simple polarization types
enum SimplePolarization : int8_t {
  SimplePolarization_vertical = 0,
  SimplePolarization_horizontal = 1,
  SimplePolarization_leftHandCircular = 2,
  SimplePolarization_rightHandCircular = 3,
  SimplePolarization_MIN = SimplePolarization_vertical,
  SimplePolarization_MAX = SimplePolarization_rightHandCircular
};

inline const SimplePolarization (&EnumValuesSimplePolarization())[4] {
  static const SimplePolarization values[] = {
    SimplePolarization_vertical,
    SimplePolarization_horizontal,
    SimplePolarization_leftHandCircular,
    SimplePolarization_rightHandCircular
  };
  return values;
}

inline const char * const *EnumNamesSimplePolarization() {
  static const char * const names[5] = {
    "vertical",
    "horizontal",
    "leftHandCircular",
    "rightHandCircular",
    nullptr
  };
  return names;
}

inline const char *EnumNameSimplePolarization(SimplePolarization e) {
  if (::flatbuffers::IsOutRange(e, SimplePolarization_vertical, SimplePolarization_rightHandCircular)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSimplePolarization()[index];
}

/// Enum for the mode of data (real, simulated, synthetic)
enum DataMode : int8_t {
  DataMode_REAL = 0,
  DataMode_SIMULATED = 1,
  DataMode_SYNTHETIC = 2,
  DataMode_MIN = DataMode_REAL,
  DataMode_MAX = DataMode_SYNTHETIC
};

inline const DataMode (&EnumValuesDataMode())[3] {
  static const DataMode values[] = {
    DataMode_REAL,
    DataMode_SIMULATED,
    DataMode_SYNTHETIC
  };
  return values;
}

inline const char * const *EnumNamesDataMode() {
  static const char * const names[4] = {
    "REAL",
    "SIMULATED",
    "SYNTHETIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataMode(DataMode e) {
  if (::flatbuffers::IsOutRange(e, DataMode_REAL, DataMode_SYNTHETIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataMode()[index];
}

enum DeviceType : int8_t {
  /// Basic or undefined sensor type
  DeviceType_UNKNOWN = 0,
  /// General optical sensors
  DeviceType_OPTICAL = 1,
  /// Detects infrared radiation
  DeviceType_INFRARED_SENSOR = 2,
  /// Sensitive to ultraviolet light
  DeviceType_ULTRAVIOLET_SENSOR = 3,
  /// For X-ray detection
  DeviceType_X_RAY_SENSOR = 4,
  /// For gamma-ray detection
  DeviceType_GAMMA_RAY_SENSOR = 5,
  /// Basic radar systems
  DeviceType_RADAR = 6,
  /// Advanced radar with phased array technology
  DeviceType_PHASED_ARRAY_RADAR = 7,
  /// For high-resolution imaging
  DeviceType_SYNTHETIC_APERTURE_RADAR = 8,
  /// For astronomical observations using bistatic setup
  DeviceType_BISTATIC_RADIO_TELESCOPE = 9,
  /// For radio astronomy
  DeviceType_RADIO_TELESCOPE = 10,
  /// For atmospheric studies
  DeviceType_ATMOSPHERIC_SENSOR = 11,
  /// For observing space weather phenomena
  DeviceType_SPACE_WEATHER_SENSOR = 12,
  /// General environmental monitoring
  DeviceType_ENVIRONMENTAL_SENSOR = 13,
  /// For measuring seismic activities
  DeviceType_SEISMIC_SENSOR = 14,
  /// For gravity measurements
  DeviceType_GRAVIMETRIC_SENSOR = 15,
  /// For magnetic field detection
  DeviceType_MAGNETIC_SENSOR = 16,
  /// For electromagnetic field analysis
  DeviceType_ELECTROMAGNETIC_SENSOR = 17,
  /// For temperature and heat detection
  DeviceType_THERMAL_SENSOR = 18,
  /// For detecting chemicals and substances
  DeviceType_CHEMICAL_SENSOR = 19,
  /// For biological research and detection
  DeviceType_BIOLOGICAL_SENSOR = 20,
  /// For detecting ionizing radiation
  DeviceType_RADIATION_SENSOR = 21,
  /// For detecting subatomic particles
  DeviceType_PARTICLE_DETECTOR = 22,
  /// Light Detection and Ranging
  DeviceType_LIDAR = 23,
  /// Sound Navigation and Ranging
  DeviceType_SONAR = 24,
  /// General telescopes for astronomical observations
  DeviceType_TELESCOPE = 25,
  /// For spectral analysis
  DeviceType_SPECTROSCOPIC_SENSOR = 26,
  /// For measuring light intensity
  DeviceType_PHOTOMETRIC_SENSOR = 27,
  /// For analyzing polarization of light
  DeviceType_POLARIMETRIC_SENSOR = 28,
  /// For detailed imaging using interference
  DeviceType_INTERFEROMETRIC_SENSOR = 29,
  /// Capturing image data at multiple wavelengths
  DeviceType_MULTISPECTRAL_SENSOR = 30,
  /// Advanced imaging across many spectral bands
  DeviceType_HYPERSPECTRAL_SENSOR = 31,
  /// For Global Positioning System reception
  DeviceType_GPS_RECEIVER = 32,
  /// Standard radio communication device
  DeviceType_RADIO_COMMUNICATIONS = 33,
  /// Advanced laser communication system
  DeviceType_LASER_COMMUNICATIONS = 34,
  /// Satellite communication system
  DeviceType_SATELLITE_COMMUNICATIONS = 35,
  /// Device for laser-based experiments and measurements
  DeviceType_LASER_INSTRUMENT = 36,
  /// Radio frequency analysis and measurement device
  DeviceType_RF_ANALYZER = 37,
  /// Device for ionospheric research
  DeviceType_IONOSPHERIC_SENSOR = 38,
  /// Device for laser-based imaging
  DeviceType_LASER_IMAGING = 39,
  /// Advanced optical telescope
  DeviceType_OPTICAL_TELESCOPE = 40,
  /// Device for high-resolution optical observations
  DeviceType_HIGH_RESOLUTION_OPTICAL = 41,
  DeviceType_RADIO = 42,
  /// Microwave communication device
  DeviceType_MICROWAVE_TRANSMITTER = 43,
  /// Device for radio frequency monitoring
  DeviceType_RF_MONITOR = 44,
  /// High-frequency radio communication device
  DeviceType_HF_RADIO_COMMUNICATIONS = 45,
  DeviceType_MIN = DeviceType_UNKNOWN,
  DeviceType_MAX = DeviceType_HF_RADIO_COMMUNICATIONS
};

inline const DeviceType (&EnumValuesDeviceType())[46] {
  static const DeviceType values[] = {
    DeviceType_UNKNOWN,
    DeviceType_OPTICAL,
    DeviceType_INFRARED_SENSOR,
    DeviceType_ULTRAVIOLET_SENSOR,
    DeviceType_X_RAY_SENSOR,
    DeviceType_GAMMA_RAY_SENSOR,
    DeviceType_RADAR,
    DeviceType_PHASED_ARRAY_RADAR,
    DeviceType_SYNTHETIC_APERTURE_RADAR,
    DeviceType_BISTATIC_RADIO_TELESCOPE,
    DeviceType_RADIO_TELESCOPE,
    DeviceType_ATMOSPHERIC_SENSOR,
    DeviceType_SPACE_WEATHER_SENSOR,
    DeviceType_ENVIRONMENTAL_SENSOR,
    DeviceType_SEISMIC_SENSOR,
    DeviceType_GRAVIMETRIC_SENSOR,
    DeviceType_MAGNETIC_SENSOR,
    DeviceType_ELECTROMAGNETIC_SENSOR,
    DeviceType_THERMAL_SENSOR,
    DeviceType_CHEMICAL_SENSOR,
    DeviceType_BIOLOGICAL_SENSOR,
    DeviceType_RADIATION_SENSOR,
    DeviceType_PARTICLE_DETECTOR,
    DeviceType_LIDAR,
    DeviceType_SONAR,
    DeviceType_TELESCOPE,
    DeviceType_SPECTROSCOPIC_SENSOR,
    DeviceType_PHOTOMETRIC_SENSOR,
    DeviceType_POLARIMETRIC_SENSOR,
    DeviceType_INTERFEROMETRIC_SENSOR,
    DeviceType_MULTISPECTRAL_SENSOR,
    DeviceType_HYPERSPECTRAL_SENSOR,
    DeviceType_GPS_RECEIVER,
    DeviceType_RADIO_COMMUNICATIONS,
    DeviceType_LASER_COMMUNICATIONS,
    DeviceType_SATELLITE_COMMUNICATIONS,
    DeviceType_LASER_INSTRUMENT,
    DeviceType_RF_ANALYZER,
    DeviceType_IONOSPHERIC_SENSOR,
    DeviceType_LASER_IMAGING,
    DeviceType_OPTICAL_TELESCOPE,
    DeviceType_HIGH_RESOLUTION_OPTICAL,
    DeviceType_RADIO,
    DeviceType_MICROWAVE_TRANSMITTER,
    DeviceType_RF_MONITOR,
    DeviceType_HF_RADIO_COMMUNICATIONS
  };
  return values;
}

inline const char * const *EnumNamesDeviceType() {
  static const char * const names[47] = {
    "UNKNOWN",
    "OPTICAL",
    "INFRARED_SENSOR",
    "ULTRAVIOLET_SENSOR",
    "X_RAY_SENSOR",
    "GAMMA_RAY_SENSOR",
    "RADAR",
    "PHASED_ARRAY_RADAR",
    "SYNTHETIC_APERTURE_RADAR",
    "BISTATIC_RADIO_TELESCOPE",
    "RADIO_TELESCOPE",
    "ATMOSPHERIC_SENSOR",
    "SPACE_WEATHER_SENSOR",
    "ENVIRONMENTAL_SENSOR",
    "SEISMIC_SENSOR",
    "GRAVIMETRIC_SENSOR",
    "MAGNETIC_SENSOR",
    "ELECTROMAGNETIC_SENSOR",
    "THERMAL_SENSOR",
    "CHEMICAL_SENSOR",
    "BIOLOGICAL_SENSOR",
    "RADIATION_SENSOR",
    "PARTICLE_DETECTOR",
    "LIDAR",
    "SONAR",
    "TELESCOPE",
    "SPECTROSCOPIC_SENSOR",
    "PHOTOMETRIC_SENSOR",
    "POLARIMETRIC_SENSOR",
    "INTERFEROMETRIC_SENSOR",
    "MULTISPECTRAL_SENSOR",
    "HYPERSPECTRAL_SENSOR",
    "GPS_RECEIVER",
    "RADIO_COMMUNICATIONS",
    "LASER_COMMUNICATIONS",
    "SATELLITE_COMMUNICATIONS",
    "LASER_INSTRUMENT",
    "RF_ANALYZER",
    "IONOSPHERIC_SENSOR",
    "LASER_IMAGING",
    "OPTICAL_TELESCOPE",
    "HIGH_RESOLUTION_OPTICAL",
    "RADIO",
    "MICROWAVE_TRANSMITTER",
    "RF_MONITOR",
    "HF_RADIO_COMMUNICATIONS",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) {
  if (::flatbuffers::IsOutRange(e, DeviceType_UNKNOWN, DeviceType_HF_RADIO_COMMUNICATIONS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceType()[index];
}

/// Frequency range with lower and upper limits
struct FrequencyRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrequencyRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOWER = 4,
    VT_UPPER = 6
  };
  /// Lower frequency in MHz
  double LOWER() const {
    return GetField<double>(VT_LOWER, 0.0);
  }
  /// Upper frequency in MHz
  double UPPER() const {
    return GetField<double>(VT_UPPER, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LOWER, 8) &&
           VerifyField<double>(verifier, VT_UPPER, 8) &&
           verifier.EndTable();
  }
};

struct FrequencyRangeBuilder {
  typedef FrequencyRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LOWER(double LOWER) {
    fbb_.AddElement<double>(FrequencyRange::VT_LOWER, LOWER, 0.0);
  }
  void add_UPPER(double UPPER) {
    fbb_.AddElement<double>(FrequencyRange::VT_UPPER, UPPER, 0.0);
  }
  explicit FrequencyRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FrequencyRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FrequencyRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FrequencyRange> CreateFrequencyRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LOWER = 0.0,
    double UPPER = 0.0) {
  FrequencyRangeBuilder builder_(_fbb);
  builder_.add_UPPER(UPPER);
  builder_.add_LOWER(LOWER);
  return builder_.Finish();
}

/// Stokes parameters, representing different aspects of polarization
struct StokesParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StokesParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_I = 4,
    VT_Q = 6,
    VT_U = 8,
    VT_V = 10
  };
  /// Intensity
  double I() const {
    return GetField<double>(VT_I, 0.0);
  }
  /// Linear polarization
  double Q() const {
    return GetField<double>(VT_Q, 0.0);
  }
  /// Another linear polarization, orthogonal to Q
  double U() const {
    return GetField<double>(VT_U, 0.0);
  }
  /// Circular polarization
  double V() const {
    return GetField<double>(VT_V, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_I, 8) &&
           VerifyField<double>(verifier, VT_Q, 8) &&
           VerifyField<double>(verifier, VT_U, 8) &&
           VerifyField<double>(verifier, VT_V, 8) &&
           verifier.EndTable();
  }
};

struct StokesParametersBuilder {
  typedef StokesParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_I(double I) {
    fbb_.AddElement<double>(StokesParameters::VT_I, I, 0.0);
  }
  void add_Q(double Q) {
    fbb_.AddElement<double>(StokesParameters::VT_Q, Q, 0.0);
  }
  void add_U(double U) {
    fbb_.AddElement<double>(StokesParameters::VT_U, U, 0.0);
  }
  void add_V(double V) {
    fbb_.AddElement<double>(StokesParameters::VT_V, V, 0.0);
  }
  explicit StokesParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StokesParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StokesParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StokesParameters> CreateStokesParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double I = 0.0,
    double Q = 0.0,
    double U = 0.0,
    double V = 0.0) {
  StokesParametersBuilder builder_(_fbb);
  builder_.add_V(V);
  builder_.add_U(U);
  builder_.add_Q(Q);
  builder_.add_I(I);
  return builder_.Finish();
}

/// Table representing a frequency band with a name and frequency range
struct Band FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FREQUENCY_RANGE = 6
  };
  /// Name of the band
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Frequency range of the band
  const FrequencyRange *FREQUENCY_RANGE() const {
    return GetPointer<const FrequencyRange *>(VT_FREQUENCY_RANGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_FREQUENCY_RANGE) &&
           verifier.VerifyTable(FREQUENCY_RANGE()) &&
           verifier.EndTable();
  }
};

struct BandBuilder {
  typedef Band Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(Band::VT_NAME, NAME);
  }
  void add_FREQUENCY_RANGE(::flatbuffers::Offset<FrequencyRange> FREQUENCY_RANGE) {
    fbb_.AddOffset(Band::VT_FREQUENCY_RANGE, FREQUENCY_RANGE);
  }
  explicit BandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Band> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Band>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Band> CreateBand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<FrequencyRange> FREQUENCY_RANGE = 0) {
  BandBuilder builder_(_fbb);
  builder_.add_FREQUENCY_RANGE(FREQUENCY_RANGE);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Band> CreateBandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    ::flatbuffers::Offset<FrequencyRange> FREQUENCY_RANGE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return CreateBand(
      _fbb,
      NAME__,
      FREQUENCY_RANGE);
}

/// Integrated Device Message
struct IDM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IDMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DATA_MODE = 8,
    VT_UPLINK = 10,
    VT_DOWNLINK = 12,
    VT_BEACON = 14,
    VT_BAND = 16,
    VT_POLARIZATION_TYPE = 18,
    VT_SIMPLE_POLARIZATION = 20,
    VT_STOKES_PARAMETERS = 22,
    VT_POWER_REQUIRED = 24,
    VT_POWER_TYPE = 26,
    VT_TRANSMIT = 28,
    VT_RECEIVE = 30,
    VT_SENSOR_TYPE = 32,
    VT_SOURCE = 34,
    VT_LAST_OB_TIME = 36,
    VT_LOWER_LEFT_ELEVATION_LIMIT = 38,
    VT_UPPER_LEFT_AZIMUTH_LIMIT = 40,
    VT_LOWER_RIGHT_ELEVATION_LIMIT = 42,
    VT_LOWER_LEFT_AZIMUTH_LIMIT = 44,
    VT_UPPER_RIGHT_ELEVATION_LIMIT = 46,
    VT_UPPER_RIGHT_AZIMUTH_LIMIT = 48,
    VT_LOWER_RIGHT_AZIMUTH_LIMIT = 50,
    VT_UPPER_LEFT_ELEVATION_LIMIT = 52,
    VT_RIGHT_GEO_BELT_LIMIT = 54,
    VT_LEFT_GEO_BELT_LIMIT = 56,
    VT_MAGNITUDE_LIMIT = 58,
    VT_TASKABLE = 60
  };
  /// Unique identifier for the EMT
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Name of the EMT
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Mode of the data (real, simulated, synthetic)
  DataMode DATA_MODE() const {
    return static_cast<DataMode>(GetField<int8_t>(VT_DATA_MODE, 0));
  }
  /// Uplink frequency range
  const FrequencyRange *UPLINK() const {
    return GetPointer<const FrequencyRange *>(VT_UPLINK);
  }
  /// Downlink frequency range
  const FrequencyRange *DOWNLINK() const {
    return GetPointer<const FrequencyRange *>(VT_DOWNLINK);
  }
  /// Beacon frequency range
  const FrequencyRange *BEACON() const {
    return GetPointer<const FrequencyRange *>(VT_BEACON);
  }
  /// Bands associated with the EMT
  const ::flatbuffers::Vector<::flatbuffers::Offset<Band>> *BAND() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Band>> *>(VT_BAND);
  }
  /// Type of polarization used
  PolarizationType POLARIZATION_TYPE() const {
    return static_cast<PolarizationType>(GetField<int8_t>(VT_POLARIZATION_TYPE, 0));
  }
  /// Simple polarization configuration
  SimplePolarization SIMPLE_POLARIZATION() const {
    return static_cast<SimplePolarization>(GetField<int8_t>(VT_SIMPLE_POLARIZATION, 0));
  }
  /// Stokes parameters for polarization characterization
  const StokesParameters *STOKES_PARAMETERS() const {
    return GetPointer<const StokesParameters *>(VT_STOKES_PARAMETERS);
  }
  /// Power required in Watts
  double POWER_REQUIRED() const {
    return GetField<double>(VT_POWER_REQUIRED, 0.0);
  }
  /// Type of power (eg. AC or DC)
  const ::flatbuffers::String *POWER_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POWER_TYPE);
  }
  /// Indicates if the EMT can transmit
  bool TRANSMIT() const {
    return GetField<uint8_t>(VT_TRANSMIT, 0) != 0;
  }
  /// Indicates if the EMT can receive
  bool RECEIVE() const {
    return GetField<uint8_t>(VT_RECEIVE, 0) != 0;
  }
  /// Type of the sensor
  DeviceType SENSOR_TYPE() const {
    return static_cast<DeviceType>(GetField<int8_t>(VT_SENSOR_TYPE, 0));
  }
  /// Source of the data
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Timestamp of the last observation
  const ::flatbuffers::String *LAST_OB_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAST_OB_TIME);
  }
  /// Lower left elevation limit
  double LOWER_LEFT_ELEVATION_LIMIT() const {
    return GetField<double>(VT_LOWER_LEFT_ELEVATION_LIMIT, 0.0);
  }
  /// Upper left azimuth limit
  double UPPER_LEFT_AZIMUTH_LIMIT() const {
    return GetField<double>(VT_UPPER_LEFT_AZIMUTH_LIMIT, 0.0);
  }
  /// Lower right elevation limit
  double LOWER_RIGHT_ELEVATION_LIMIT() const {
    return GetField<double>(VT_LOWER_RIGHT_ELEVATION_LIMIT, 0.0);
  }
  /// Lower left azimuth limit
  double LOWER_LEFT_AZIMUTH_LIMIT() const {
    return GetField<double>(VT_LOWER_LEFT_AZIMUTH_LIMIT, 0.0);
  }
  /// Upper right elevation limit
  double UPPER_RIGHT_ELEVATION_LIMIT() const {
    return GetField<double>(VT_UPPER_RIGHT_ELEVATION_LIMIT, 0.0);
  }
  /// Upper right azimuth limit
  double UPPER_RIGHT_AZIMUTH_LIMIT() const {
    return GetField<double>(VT_UPPER_RIGHT_AZIMUTH_LIMIT, 0.0);
  }
  /// Lower right azimuth limit
  double LOWER_RIGHT_AZIMUTH_LIMIT() const {
    return GetField<double>(VT_LOWER_RIGHT_AZIMUTH_LIMIT, 0.0);
  }
  /// Upper left elevation limit
  double UPPER_LEFT_ELEVATION_LIMIT() const {
    return GetField<double>(VT_UPPER_LEFT_ELEVATION_LIMIT, 0.0);
  }
  /// Right geostationary belt limit
  double RIGHT_GEO_BELT_LIMIT() const {
    return GetField<double>(VT_RIGHT_GEO_BELT_LIMIT, 0.0);
  }
  /// Left geostationary belt limit
  double LEFT_GEO_BELT_LIMIT() const {
    return GetField<double>(VT_LEFT_GEO_BELT_LIMIT, 0.0);
  }
  /// Magnitude limit of the sensor
  double MAGNITUDE_LIMIT() const {
    return GetField<double>(VT_MAGNITUDE_LIMIT, 0.0);
  }
  /// Indicates if the site is taskable
  bool TASKABLE() const {
    return GetField<uint8_t>(VT_TASKABLE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<int8_t>(verifier, VT_DATA_MODE, 1) &&
           VerifyOffset(verifier, VT_UPLINK) &&
           verifier.VerifyTable(UPLINK()) &&
           VerifyOffset(verifier, VT_DOWNLINK) &&
           verifier.VerifyTable(DOWNLINK()) &&
           VerifyOffset(verifier, VT_BEACON) &&
           verifier.VerifyTable(BEACON()) &&
           VerifyOffset(verifier, VT_BAND) &&
           verifier.VerifyVector(BAND()) &&
           verifier.VerifyVectorOfTables(BAND()) &&
           VerifyField<int8_t>(verifier, VT_POLARIZATION_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_SIMPLE_POLARIZATION, 1) &&
           VerifyOffset(verifier, VT_STOKES_PARAMETERS) &&
           verifier.VerifyTable(STOKES_PARAMETERS()) &&
           VerifyField<double>(verifier, VT_POWER_REQUIRED, 8) &&
           VerifyOffset(verifier, VT_POWER_TYPE) &&
           verifier.VerifyString(POWER_TYPE()) &&
           VerifyField<uint8_t>(verifier, VT_TRANSMIT, 1) &&
           VerifyField<uint8_t>(verifier, VT_RECEIVE, 1) &&
           VerifyField<int8_t>(verifier, VT_SENSOR_TYPE, 1) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_LAST_OB_TIME) &&
           verifier.VerifyString(LAST_OB_TIME()) &&
           VerifyField<double>(verifier, VT_LOWER_LEFT_ELEVATION_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPER_LEFT_AZIMUTH_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWER_RIGHT_ELEVATION_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWER_LEFT_AZIMUTH_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPER_RIGHT_ELEVATION_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPER_RIGHT_AZIMUTH_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWER_RIGHT_AZIMUTH_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPER_LEFT_ELEVATION_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_RIGHT_GEO_BELT_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_LEFT_GEO_BELT_LIMIT, 8) &&
           VerifyField<double>(verifier, VT_MAGNITUDE_LIMIT, 8) &&
           VerifyField<uint8_t>(verifier, VT_TASKABLE, 1) &&
           verifier.EndTable();
  }
};

struct IDMBuilder {
  typedef IDM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(IDM::VT_ID, ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(IDM::VT_NAME, NAME);
  }
  void add_DATA_MODE(DataMode DATA_MODE) {
    fbb_.AddElement<int8_t>(IDM::VT_DATA_MODE, static_cast<int8_t>(DATA_MODE), 0);
  }
  void add_UPLINK(::flatbuffers::Offset<FrequencyRange> UPLINK) {
    fbb_.AddOffset(IDM::VT_UPLINK, UPLINK);
  }
  void add_DOWNLINK(::flatbuffers::Offset<FrequencyRange> DOWNLINK) {
    fbb_.AddOffset(IDM::VT_DOWNLINK, DOWNLINK);
  }
  void add_BEACON(::flatbuffers::Offset<FrequencyRange> BEACON) {
    fbb_.AddOffset(IDM::VT_BEACON, BEACON);
  }
  void add_BAND(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Band>>> BAND) {
    fbb_.AddOffset(IDM::VT_BAND, BAND);
  }
  void add_POLARIZATION_TYPE(PolarizationType POLARIZATION_TYPE) {
    fbb_.AddElement<int8_t>(IDM::VT_POLARIZATION_TYPE, static_cast<int8_t>(POLARIZATION_TYPE), 0);
  }
  void add_SIMPLE_POLARIZATION(SimplePolarization SIMPLE_POLARIZATION) {
    fbb_.AddElement<int8_t>(IDM::VT_SIMPLE_POLARIZATION, static_cast<int8_t>(SIMPLE_POLARIZATION), 0);
  }
  void add_STOKES_PARAMETERS(::flatbuffers::Offset<StokesParameters> STOKES_PARAMETERS) {
    fbb_.AddOffset(IDM::VT_STOKES_PARAMETERS, STOKES_PARAMETERS);
  }
  void add_POWER_REQUIRED(double POWER_REQUIRED) {
    fbb_.AddElement<double>(IDM::VT_POWER_REQUIRED, POWER_REQUIRED, 0.0);
  }
  void add_POWER_TYPE(::flatbuffers::Offset<::flatbuffers::String> POWER_TYPE) {
    fbb_.AddOffset(IDM::VT_POWER_TYPE, POWER_TYPE);
  }
  void add_TRANSMIT(bool TRANSMIT) {
    fbb_.AddElement<uint8_t>(IDM::VT_TRANSMIT, static_cast<uint8_t>(TRANSMIT), 0);
  }
  void add_RECEIVE(bool RECEIVE) {
    fbb_.AddElement<uint8_t>(IDM::VT_RECEIVE, static_cast<uint8_t>(RECEIVE), 0);
  }
  void add_SENSOR_TYPE(DeviceType SENSOR_TYPE) {
    fbb_.AddElement<int8_t>(IDM::VT_SENSOR_TYPE, static_cast<int8_t>(SENSOR_TYPE), 0);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(IDM::VT_SOURCE, SOURCE);
  }
  void add_LAST_OB_TIME(::flatbuffers::Offset<::flatbuffers::String> LAST_OB_TIME) {
    fbb_.AddOffset(IDM::VT_LAST_OB_TIME, LAST_OB_TIME);
  }
  void add_LOWER_LEFT_ELEVATION_LIMIT(double LOWER_LEFT_ELEVATION_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_LOWER_LEFT_ELEVATION_LIMIT, LOWER_LEFT_ELEVATION_LIMIT, 0.0);
  }
  void add_UPPER_LEFT_AZIMUTH_LIMIT(double UPPER_LEFT_AZIMUTH_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_UPPER_LEFT_AZIMUTH_LIMIT, UPPER_LEFT_AZIMUTH_LIMIT, 0.0);
  }
  void add_LOWER_RIGHT_ELEVATION_LIMIT(double LOWER_RIGHT_ELEVATION_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_LOWER_RIGHT_ELEVATION_LIMIT, LOWER_RIGHT_ELEVATION_LIMIT, 0.0);
  }
  void add_LOWER_LEFT_AZIMUTH_LIMIT(double LOWER_LEFT_AZIMUTH_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_LOWER_LEFT_AZIMUTH_LIMIT, LOWER_LEFT_AZIMUTH_LIMIT, 0.0);
  }
  void add_UPPER_RIGHT_ELEVATION_LIMIT(double UPPER_RIGHT_ELEVATION_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_UPPER_RIGHT_ELEVATION_LIMIT, UPPER_RIGHT_ELEVATION_LIMIT, 0.0);
  }
  void add_UPPER_RIGHT_AZIMUTH_LIMIT(double UPPER_RIGHT_AZIMUTH_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_UPPER_RIGHT_AZIMUTH_LIMIT, UPPER_RIGHT_AZIMUTH_LIMIT, 0.0);
  }
  void add_LOWER_RIGHT_AZIMUTH_LIMIT(double LOWER_RIGHT_AZIMUTH_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_LOWER_RIGHT_AZIMUTH_LIMIT, LOWER_RIGHT_AZIMUTH_LIMIT, 0.0);
  }
  void add_UPPER_LEFT_ELEVATION_LIMIT(double UPPER_LEFT_ELEVATION_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_UPPER_LEFT_ELEVATION_LIMIT, UPPER_LEFT_ELEVATION_LIMIT, 0.0);
  }
  void add_RIGHT_GEO_BELT_LIMIT(double RIGHT_GEO_BELT_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_RIGHT_GEO_BELT_LIMIT, RIGHT_GEO_BELT_LIMIT, 0.0);
  }
  void add_LEFT_GEO_BELT_LIMIT(double LEFT_GEO_BELT_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_LEFT_GEO_BELT_LIMIT, LEFT_GEO_BELT_LIMIT, 0.0);
  }
  void add_MAGNITUDE_LIMIT(double MAGNITUDE_LIMIT) {
    fbb_.AddElement<double>(IDM::VT_MAGNITUDE_LIMIT, MAGNITUDE_LIMIT, 0.0);
  }
  void add_TASKABLE(bool TASKABLE) {
    fbb_.AddElement<uint8_t>(IDM::VT_TASKABLE, static_cast<uint8_t>(TASKABLE), 0);
  }
  explicit IDMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IDM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IDM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IDM> CreateIDM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    DataMode DATA_MODE = DataMode_REAL,
    ::flatbuffers::Offset<FrequencyRange> UPLINK = 0,
    ::flatbuffers::Offset<FrequencyRange> DOWNLINK = 0,
    ::flatbuffers::Offset<FrequencyRange> BEACON = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Band>>> BAND = 0,
    PolarizationType POLARIZATION_TYPE = PolarizationType_linear,
    SimplePolarization SIMPLE_POLARIZATION = SimplePolarization_vertical,
    ::flatbuffers::Offset<StokesParameters> STOKES_PARAMETERS = 0,
    double POWER_REQUIRED = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> POWER_TYPE = 0,
    bool TRANSMIT = false,
    bool RECEIVE = false,
    DeviceType SENSOR_TYPE = DeviceType_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAST_OB_TIME = 0,
    double LOWER_LEFT_ELEVATION_LIMIT = 0.0,
    double UPPER_LEFT_AZIMUTH_LIMIT = 0.0,
    double LOWER_RIGHT_ELEVATION_LIMIT = 0.0,
    double LOWER_LEFT_AZIMUTH_LIMIT = 0.0,
    double UPPER_RIGHT_ELEVATION_LIMIT = 0.0,
    double UPPER_RIGHT_AZIMUTH_LIMIT = 0.0,
    double LOWER_RIGHT_AZIMUTH_LIMIT = 0.0,
    double UPPER_LEFT_ELEVATION_LIMIT = 0.0,
    double RIGHT_GEO_BELT_LIMIT = 0.0,
    double LEFT_GEO_BELT_LIMIT = 0.0,
    double MAGNITUDE_LIMIT = 0.0,
    bool TASKABLE = false) {
  IDMBuilder builder_(_fbb);
  builder_.add_MAGNITUDE_LIMIT(MAGNITUDE_LIMIT);
  builder_.add_LEFT_GEO_BELT_LIMIT(LEFT_GEO_BELT_LIMIT);
  builder_.add_RIGHT_GEO_BELT_LIMIT(RIGHT_GEO_BELT_LIMIT);
  builder_.add_UPPER_LEFT_ELEVATION_LIMIT(UPPER_LEFT_ELEVATION_LIMIT);
  builder_.add_LOWER_RIGHT_AZIMUTH_LIMIT(LOWER_RIGHT_AZIMUTH_LIMIT);
  builder_.add_UPPER_RIGHT_AZIMUTH_LIMIT(UPPER_RIGHT_AZIMUTH_LIMIT);
  builder_.add_UPPER_RIGHT_ELEVATION_LIMIT(UPPER_RIGHT_ELEVATION_LIMIT);
  builder_.add_LOWER_LEFT_AZIMUTH_LIMIT(LOWER_LEFT_AZIMUTH_LIMIT);
  builder_.add_LOWER_RIGHT_ELEVATION_LIMIT(LOWER_RIGHT_ELEVATION_LIMIT);
  builder_.add_UPPER_LEFT_AZIMUTH_LIMIT(UPPER_LEFT_AZIMUTH_LIMIT);
  builder_.add_LOWER_LEFT_ELEVATION_LIMIT(LOWER_LEFT_ELEVATION_LIMIT);
  builder_.add_POWER_REQUIRED(POWER_REQUIRED);
  builder_.add_LAST_OB_TIME(LAST_OB_TIME);
  builder_.add_SOURCE(SOURCE);
  builder_.add_POWER_TYPE(POWER_TYPE);
  builder_.add_STOKES_PARAMETERS(STOKES_PARAMETERS);
  builder_.add_BAND(BAND);
  builder_.add_BEACON(BEACON);
  builder_.add_DOWNLINK(DOWNLINK);
  builder_.add_UPLINK(UPLINK);
  builder_.add_NAME(NAME);
  builder_.add_ID(ID);
  builder_.add_TASKABLE(TASKABLE);
  builder_.add_SENSOR_TYPE(SENSOR_TYPE);
  builder_.add_RECEIVE(RECEIVE);
  builder_.add_TRANSMIT(TRANSMIT);
  builder_.add_SIMPLE_POLARIZATION(SIMPLE_POLARIZATION);
  builder_.add_POLARIZATION_TYPE(POLARIZATION_TYPE);
  builder_.add_DATA_MODE(DATA_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IDM> CreateIDMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *NAME = nullptr,
    DataMode DATA_MODE = DataMode_REAL,
    ::flatbuffers::Offset<FrequencyRange> UPLINK = 0,
    ::flatbuffers::Offset<FrequencyRange> DOWNLINK = 0,
    ::flatbuffers::Offset<FrequencyRange> BEACON = 0,
    const std::vector<::flatbuffers::Offset<Band>> *BAND = nullptr,
    PolarizationType POLARIZATION_TYPE = PolarizationType_linear,
    SimplePolarization SIMPLE_POLARIZATION = SimplePolarization_vertical,
    ::flatbuffers::Offset<StokesParameters> STOKES_PARAMETERS = 0,
    double POWER_REQUIRED = 0.0,
    const char *POWER_TYPE = nullptr,
    bool TRANSMIT = false,
    bool RECEIVE = false,
    DeviceType SENSOR_TYPE = DeviceType_UNKNOWN,
    const char *SOURCE = nullptr,
    const char *LAST_OB_TIME = nullptr,
    double LOWER_LEFT_ELEVATION_LIMIT = 0.0,
    double UPPER_LEFT_AZIMUTH_LIMIT = 0.0,
    double LOWER_RIGHT_ELEVATION_LIMIT = 0.0,
    double LOWER_LEFT_AZIMUTH_LIMIT = 0.0,
    double UPPER_RIGHT_ELEVATION_LIMIT = 0.0,
    double UPPER_RIGHT_AZIMUTH_LIMIT = 0.0,
    double LOWER_RIGHT_AZIMUTH_LIMIT = 0.0,
    double UPPER_LEFT_ELEVATION_LIMIT = 0.0,
    double RIGHT_GEO_BELT_LIMIT = 0.0,
    double LEFT_GEO_BELT_LIMIT = 0.0,
    double MAGNITUDE_LIMIT = 0.0,
    bool TASKABLE = false) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto BAND__ = BAND ? _fbb.CreateVector<::flatbuffers::Offset<Band>>(*BAND) : 0;
  auto POWER_TYPE__ = POWER_TYPE ? _fbb.CreateString(POWER_TYPE) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto LAST_OB_TIME__ = LAST_OB_TIME ? _fbb.CreateString(LAST_OB_TIME) : 0;
  return CreateIDM(
      _fbb,
      ID__,
      NAME__,
      DATA_MODE,
      UPLINK,
      DOWNLINK,
      BEACON,
      BAND__,
      POLARIZATION_TYPE,
      SIMPLE_POLARIZATION,
      STOKES_PARAMETERS,
      POWER_REQUIRED,
      POWER_TYPE__,
      TRANSMIT,
      RECEIVE,
      SENSOR_TYPE,
      SOURCE__,
      LAST_OB_TIME__,
      LOWER_LEFT_ELEVATION_LIMIT,
      UPPER_LEFT_AZIMUTH_LIMIT,
      LOWER_RIGHT_ELEVATION_LIMIT,
      LOWER_LEFT_AZIMUTH_LIMIT,
      UPPER_RIGHT_ELEVATION_LIMIT,
      UPPER_RIGHT_AZIMUTH_LIMIT,
      LOWER_RIGHT_AZIMUTH_LIMIT,
      UPPER_LEFT_ELEVATION_LIMIT,
      RIGHT_GEO_BELT_LIMIT,
      LEFT_GEO_BELT_LIMIT,
      MAGNITUDE_LIMIT,
      TASKABLE);
}

inline const IDM *GetIDM(const void *buf) {
  return ::flatbuffers::GetRoot<IDM>(buf);
}

inline const IDM *GetSizePrefixedIDM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<IDM>(buf);
}

inline const char *IDMIdentifier() {
  return "$IDM";
}

inline bool IDMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, IDMIdentifier());
}

inline bool SizePrefixedIDMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, IDMIdentifier(), true);
}

inline bool VerifyIDMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<IDM>(IDMIdentifier());
}

inline bool VerifySizePrefixedIDMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<IDM>(IDMIdentifier());
}

inline void FinishIDMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IDM> root) {
  fbb.Finish(root, IDMIdentifier());
}

inline void FinishSizePrefixedIDMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<IDM> root) {
  fbb.FinishSizePrefixed(root, IDMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
