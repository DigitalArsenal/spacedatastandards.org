// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct Detail;
struct DetailBuilder;

struct PNM;
struct PNMBuilder;

struct PNMCOLLECTION;
struct PNMCOLLECTIONBuilder;

/// Details of Published Message
struct Detail FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetailBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIFORMAT_ADDRESS = 4,
    VT_CID = 6,
    VT_ETH_DIGITAL_SIGNATURE = 8,
    VT_BTC_DIGITAL_SIGNATURE = 10,
    VT_LTC_DIGITAL_SIGNATURE = 12,
    VT_XRP_DIGITAL_SIGNATURE = 14,
    VT_ADA_DIGITAL_SIGNATURE = 16,
    VT_XLM_DIGITAL_SIGNATURE = 18,
    VT_DOGE_DIGITAL_SIGNATURE = 20,
    VT_XMR_DIGITAL_SIGNATURE = 22,
    VT_DOT_DIGITAL_SIGNATURE = 24,
    VT_FIL_DIGITAL_SIGNATURE = 26,
    VT_XTZ_DIGITAL_SIGNATURE = 28,
    VT_ATOM_DIGITAL_SIGNATURE = 30,
    VT_TRX_DIGITAL_SIGNATURE = 32,
    VT_BNB_DIGITAL_SIGNATURE = 34,
    VT_AVAX_DIGITAL_SIGNATURE = 36,
    VT_SOL_DIGITAL_SIGNATURE = 38
  };
  /// Multiformat Address
  /// https://multiformats.io/multiaddr/
  /// A universal address format for representing multiple network protocols. Examples include:
  /// - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
  /// - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
  /// - /dns4/example.com for a domain name resolvable only to IPv4 addresses
  /// - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
  const ::flatbuffers::String *MULTIFORMAT_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MULTIFORMAT_ADDRESS);
  }
  /// Concatenated Content Identifier (CID)
  /// This field is a unique ID for distributed systems (CID).
  /// The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
  const ::flatbuffers::String *CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CID);
  }
  /// Ethereum Digital Signature
  /// Digital signature of the CID using Ethereum's signing mechanism.
  /// Refer to the Ethereum Blockchain integration section for details.
  const ::flatbuffers::String *ETH_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETH_DIGITAL_SIGNATURE);
  }
  /// Bitcoin Digital Signature
  /// Digital signature of the CID using Bitcoin's signing mechanism.
  /// Refer to the Bitcoin Blockchain integration section for details.
  const ::flatbuffers::String *BTC_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BTC_DIGITAL_SIGNATURE);
  }
  /// Litecoin Digital Signature
  /// Digital signature of the CID using Litecoin's signing mechanism.
  /// Refer to the Litecoin Blockchain integration section for details.
  const ::flatbuffers::String *LTC_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LTC_DIGITAL_SIGNATURE);
  }
  /// Ripple Digital Signature
  /// Digital signature of the CID using Ripple's signing mechanism.
  /// Refer to the Ripple Blockchain integration section for details.
  const ::flatbuffers::String *XRP_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XRP_DIGITAL_SIGNATURE);
  }
  /// Cardano Digital Signature
  /// Digital signature of the CID using Cardano's signing mechanism.
  /// Refer to the Cardano Blockchain integration section for details.
  const ::flatbuffers::String *ADA_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADA_DIGITAL_SIGNATURE);
  }
  /// Stellar Digital Signature
  /// Digital signature of the CID using Stellar's signing mechanism.
  /// Refer to the Stellar Blockchain integration section for details.
  const ::flatbuffers::String *XLM_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XLM_DIGITAL_SIGNATURE);
  }
  /// Dogecoin Digital Signature
  /// Digital signature of the CID using Dogecoin's signing mechanism.
  /// Refer to the Dogecoin Blockchain integration section for details.
  const ::flatbuffers::String *DOGE_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOGE_DIGITAL_SIGNATURE);
  }
  /// Monero Digital Signature
  /// Digital signature of the CID using Monero's signing mechanism.
  /// Refer to the Monero Blockchain integration section for details.
  const ::flatbuffers::String *XMR_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XMR_DIGITAL_SIGNATURE);
  }
  /// Polkadot Digital Signature
  /// Digital signature of the CID using Polkadot's signing mechanism.
  /// Refer to the Polkadot Blockchain integration section for details.
  const ::flatbuffers::String *DOT_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOT_DIGITAL_SIGNATURE);
  }
  /// Filecoin Digital Signature
  /// Digital signature of the CID using Filecoin's signing mechanism.
  /// Refer to the Filecoin Blockchain integration section for details.
  const ::flatbuffers::String *FIL_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIL_DIGITAL_SIGNATURE);
  }
  /// Tezos Digital Signature
  /// Digital signature of the CID using Tezos's signing mechanism.
  /// Refer to the Tezos Blockchain integration section for details.
  const ::flatbuffers::String *XTZ_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XTZ_DIGITAL_SIGNATURE);
  }
  /// Cosmos Digital Signature
  /// Digital signature of the CID using Cosmos's signing mechanism.
  /// Refer to the Cosmos Blockchain integration section for details.
  const ::flatbuffers::String *ATOM_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATOM_DIGITAL_SIGNATURE);
  }
  /// Tron Digital Signature
  /// Digital signature of the CID using Tron's signing mechanism.
  /// Refer to the Tron Blockchain integration section for details.
  const ::flatbuffers::String *TRX_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRX_DIGITAL_SIGNATURE);
  }
  /// Binance Coin Digital Signature
  /// Digital signature of the CID using Binance Coin's signing mechanism.
  /// Refer to the Binance Coin Blockchain integration section for details.
  const ::flatbuffers::String *BNB_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BNB_DIGITAL_SIGNATURE);
  }
  /// Avalanche Digital Signature
  /// Digital signature of the CID using Avalanche's signing mechanism.
  /// Refer to the Avalanche Blockchain integration section for details.
  const ::flatbuffers::String *AVAX_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AVAX_DIGITAL_SIGNATURE);
  }
  /// Solana Digital Signature
  /// Digital signature of the CID using Solana's signing mechanism.
  /// Refer to the Solana Blockchain integration section for details.
  const ::flatbuffers::String *SOL_DIGITAL_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOL_DIGITAL_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTIFORMAT_ADDRESS) &&
           verifier.VerifyString(MULTIFORMAT_ADDRESS()) &&
           VerifyOffset(verifier, VT_CID) &&
           verifier.VerifyString(CID()) &&
           VerifyOffset(verifier, VT_ETH_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(ETH_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_BTC_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(BTC_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_LTC_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(LTC_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_XRP_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(XRP_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_ADA_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(ADA_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_XLM_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(XLM_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_DOGE_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(DOGE_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_XMR_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(XMR_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_DOT_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(DOT_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_FIL_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(FIL_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_XTZ_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(XTZ_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_ATOM_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(ATOM_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_TRX_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(TRX_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_BNB_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(BNB_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_AVAX_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(AVAX_DIGITAL_SIGNATURE()) &&
           VerifyOffset(verifier, VT_SOL_DIGITAL_SIGNATURE) &&
           verifier.VerifyString(SOL_DIGITAL_SIGNATURE()) &&
           verifier.EndTable();
  }
};

struct DetailBuilder {
  typedef Detail Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MULTIFORMAT_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> MULTIFORMAT_ADDRESS) {
    fbb_.AddOffset(Detail::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  void add_CID(::flatbuffers::Offset<::flatbuffers::String> CID) {
    fbb_.AddOffset(Detail::VT_CID, CID);
  }
  void add_ETH_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> ETH_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_ETH_DIGITAL_SIGNATURE, ETH_DIGITAL_SIGNATURE);
  }
  void add_BTC_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> BTC_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_BTC_DIGITAL_SIGNATURE, BTC_DIGITAL_SIGNATURE);
  }
  void add_LTC_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> LTC_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_LTC_DIGITAL_SIGNATURE, LTC_DIGITAL_SIGNATURE);
  }
  void add_XRP_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> XRP_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_XRP_DIGITAL_SIGNATURE, XRP_DIGITAL_SIGNATURE);
  }
  void add_ADA_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> ADA_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_ADA_DIGITAL_SIGNATURE, ADA_DIGITAL_SIGNATURE);
  }
  void add_XLM_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> XLM_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_XLM_DIGITAL_SIGNATURE, XLM_DIGITAL_SIGNATURE);
  }
  void add_DOGE_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> DOGE_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_DOGE_DIGITAL_SIGNATURE, DOGE_DIGITAL_SIGNATURE);
  }
  void add_XMR_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> XMR_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_XMR_DIGITAL_SIGNATURE, XMR_DIGITAL_SIGNATURE);
  }
  void add_DOT_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> DOT_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_DOT_DIGITAL_SIGNATURE, DOT_DIGITAL_SIGNATURE);
  }
  void add_FIL_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> FIL_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_FIL_DIGITAL_SIGNATURE, FIL_DIGITAL_SIGNATURE);
  }
  void add_XTZ_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> XTZ_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_XTZ_DIGITAL_SIGNATURE, XTZ_DIGITAL_SIGNATURE);
  }
  void add_ATOM_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> ATOM_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_ATOM_DIGITAL_SIGNATURE, ATOM_DIGITAL_SIGNATURE);
  }
  void add_TRX_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> TRX_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_TRX_DIGITAL_SIGNATURE, TRX_DIGITAL_SIGNATURE);
  }
  void add_BNB_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> BNB_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_BNB_DIGITAL_SIGNATURE, BNB_DIGITAL_SIGNATURE);
  }
  void add_AVAX_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> AVAX_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_AVAX_DIGITAL_SIGNATURE, AVAX_DIGITAL_SIGNATURE);
  }
  void add_SOL_DIGITAL_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> SOL_DIGITAL_SIGNATURE) {
    fbb_.AddOffset(Detail::VT_SOL_DIGITAL_SIGNATURE, SOL_DIGITAL_SIGNATURE);
  }
  explicit DetailBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Detail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Detail>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Detail> CreateDetail(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> MULTIFORMAT_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ETH_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> BTC_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LTC_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XRP_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADA_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XLM_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DOGE_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XMR_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DOT_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FIL_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XTZ_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATOM_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRX_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> BNB_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AVAX_DIGITAL_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOL_DIGITAL_SIGNATURE = 0) {
  DetailBuilder builder_(_fbb);
  builder_.add_SOL_DIGITAL_SIGNATURE(SOL_DIGITAL_SIGNATURE);
  builder_.add_AVAX_DIGITAL_SIGNATURE(AVAX_DIGITAL_SIGNATURE);
  builder_.add_BNB_DIGITAL_SIGNATURE(BNB_DIGITAL_SIGNATURE);
  builder_.add_TRX_DIGITAL_SIGNATURE(TRX_DIGITAL_SIGNATURE);
  builder_.add_ATOM_DIGITAL_SIGNATURE(ATOM_DIGITAL_SIGNATURE);
  builder_.add_XTZ_DIGITAL_SIGNATURE(XTZ_DIGITAL_SIGNATURE);
  builder_.add_FIL_DIGITAL_SIGNATURE(FIL_DIGITAL_SIGNATURE);
  builder_.add_DOT_DIGITAL_SIGNATURE(DOT_DIGITAL_SIGNATURE);
  builder_.add_XMR_DIGITAL_SIGNATURE(XMR_DIGITAL_SIGNATURE);
  builder_.add_DOGE_DIGITAL_SIGNATURE(DOGE_DIGITAL_SIGNATURE);
  builder_.add_XLM_DIGITAL_SIGNATURE(XLM_DIGITAL_SIGNATURE);
  builder_.add_ADA_DIGITAL_SIGNATURE(ADA_DIGITAL_SIGNATURE);
  builder_.add_XRP_DIGITAL_SIGNATURE(XRP_DIGITAL_SIGNATURE);
  builder_.add_LTC_DIGITAL_SIGNATURE(LTC_DIGITAL_SIGNATURE);
  builder_.add_BTC_DIGITAL_SIGNATURE(BTC_DIGITAL_SIGNATURE);
  builder_.add_ETH_DIGITAL_SIGNATURE(ETH_DIGITAL_SIGNATURE);
  builder_.add_CID(CID);
  builder_.add_MULTIFORMAT_ADDRESS(MULTIFORMAT_ADDRESS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Detail> CreateDetailDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *MULTIFORMAT_ADDRESS = nullptr,
    const char *CID = nullptr,
    const char *ETH_DIGITAL_SIGNATURE = nullptr,
    const char *BTC_DIGITAL_SIGNATURE = nullptr,
    const char *LTC_DIGITAL_SIGNATURE = nullptr,
    const char *XRP_DIGITAL_SIGNATURE = nullptr,
    const char *ADA_DIGITAL_SIGNATURE = nullptr,
    const char *XLM_DIGITAL_SIGNATURE = nullptr,
    const char *DOGE_DIGITAL_SIGNATURE = nullptr,
    const char *XMR_DIGITAL_SIGNATURE = nullptr,
    const char *DOT_DIGITAL_SIGNATURE = nullptr,
    const char *FIL_DIGITAL_SIGNATURE = nullptr,
    const char *XTZ_DIGITAL_SIGNATURE = nullptr,
    const char *ATOM_DIGITAL_SIGNATURE = nullptr,
    const char *TRX_DIGITAL_SIGNATURE = nullptr,
    const char *BNB_DIGITAL_SIGNATURE = nullptr,
    const char *AVAX_DIGITAL_SIGNATURE = nullptr,
    const char *SOL_DIGITAL_SIGNATURE = nullptr) {
  auto MULTIFORMAT_ADDRESS__ = MULTIFORMAT_ADDRESS ? _fbb.CreateString(MULTIFORMAT_ADDRESS) : 0;
  auto CID__ = CID ? _fbb.CreateString(CID) : 0;
  auto ETH_DIGITAL_SIGNATURE__ = ETH_DIGITAL_SIGNATURE ? _fbb.CreateString(ETH_DIGITAL_SIGNATURE) : 0;
  auto BTC_DIGITAL_SIGNATURE__ = BTC_DIGITAL_SIGNATURE ? _fbb.CreateString(BTC_DIGITAL_SIGNATURE) : 0;
  auto LTC_DIGITAL_SIGNATURE__ = LTC_DIGITAL_SIGNATURE ? _fbb.CreateString(LTC_DIGITAL_SIGNATURE) : 0;
  auto XRP_DIGITAL_SIGNATURE__ = XRP_DIGITAL_SIGNATURE ? _fbb.CreateString(XRP_DIGITAL_SIGNATURE) : 0;
  auto ADA_DIGITAL_SIGNATURE__ = ADA_DIGITAL_SIGNATURE ? _fbb.CreateString(ADA_DIGITAL_SIGNATURE) : 0;
  auto XLM_DIGITAL_SIGNATURE__ = XLM_DIGITAL_SIGNATURE ? _fbb.CreateString(XLM_DIGITAL_SIGNATURE) : 0;
  auto DOGE_DIGITAL_SIGNATURE__ = DOGE_DIGITAL_SIGNATURE ? _fbb.CreateString(DOGE_DIGITAL_SIGNATURE) : 0;
  auto XMR_DIGITAL_SIGNATURE__ = XMR_DIGITAL_SIGNATURE ? _fbb.CreateString(XMR_DIGITAL_SIGNATURE) : 0;
  auto DOT_DIGITAL_SIGNATURE__ = DOT_DIGITAL_SIGNATURE ? _fbb.CreateString(DOT_DIGITAL_SIGNATURE) : 0;
  auto FIL_DIGITAL_SIGNATURE__ = FIL_DIGITAL_SIGNATURE ? _fbb.CreateString(FIL_DIGITAL_SIGNATURE) : 0;
  auto XTZ_DIGITAL_SIGNATURE__ = XTZ_DIGITAL_SIGNATURE ? _fbb.CreateString(XTZ_DIGITAL_SIGNATURE) : 0;
  auto ATOM_DIGITAL_SIGNATURE__ = ATOM_DIGITAL_SIGNATURE ? _fbb.CreateString(ATOM_DIGITAL_SIGNATURE) : 0;
  auto TRX_DIGITAL_SIGNATURE__ = TRX_DIGITAL_SIGNATURE ? _fbb.CreateString(TRX_DIGITAL_SIGNATURE) : 0;
  auto BNB_DIGITAL_SIGNATURE__ = BNB_DIGITAL_SIGNATURE ? _fbb.CreateString(BNB_DIGITAL_SIGNATURE) : 0;
  auto AVAX_DIGITAL_SIGNATURE__ = AVAX_DIGITAL_SIGNATURE ? _fbb.CreateString(AVAX_DIGITAL_SIGNATURE) : 0;
  auto SOL_DIGITAL_SIGNATURE__ = SOL_DIGITAL_SIGNATURE ? _fbb.CreateString(SOL_DIGITAL_SIGNATURE) : 0;
  return CreateDetail(
      _fbb,
      MULTIFORMAT_ADDRESS__,
      CID__,
      ETH_DIGITAL_SIGNATURE__,
      BTC_DIGITAL_SIGNATURE__,
      LTC_DIGITAL_SIGNATURE__,
      XRP_DIGITAL_SIGNATURE__,
      ADA_DIGITAL_SIGNATURE__,
      XLM_DIGITAL_SIGNATURE__,
      DOGE_DIGITAL_SIGNATURE__,
      XMR_DIGITAL_SIGNATURE__,
      DOT_DIGITAL_SIGNATURE__,
      FIL_DIGITAL_SIGNATURE__,
      XTZ_DIGITAL_SIGNATURE__,
      ATOM_DIGITAL_SIGNATURE__,
      TRX_DIGITAL_SIGNATURE__,
      BNB_DIGITAL_SIGNATURE__,
      AVAX_DIGITAL_SIGNATURE__,
      SOL_DIGITAL_SIGNATURE__);
}

/// Publish Notification Message
struct PNM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PNMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE = 4,
    VT_FILE_ENCRYPTED = 6
  };
  /// Unencrypted PNM Details
  /// This field contains the details of the Publish Notification Message without encryption.
  const Detail *FILE() const {
    return GetPointer<const Detail *>(VT_FILE);
  }
  /// Encrypted PNM Details
  /// This field contains the details of the Publish Notification Message with encryption.
  const Detail *FILE_ENCRYPTED() const {
    return GetPointer<const Detail *>(VT_FILE_ENCRYPTED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyTable(FILE()) &&
           VerifyOffset(verifier, VT_FILE_ENCRYPTED) &&
           verifier.VerifyTable(FILE_ENCRYPTED()) &&
           verifier.EndTable();
  }
};

struct PNMBuilder {
  typedef PNM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FILE(::flatbuffers::Offset<Detail> FILE) {
    fbb_.AddOffset(PNM::VT_FILE, FILE);
  }
  void add_FILE_ENCRYPTED(::flatbuffers::Offset<Detail> FILE_ENCRYPTED) {
    fbb_.AddOffset(PNM::VT_FILE_ENCRYPTED, FILE_ENCRYPTED);
  }
  explicit PNMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PNM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PNM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PNM> CreatePNM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Detail> FILE = 0,
    ::flatbuffers::Offset<Detail> FILE_ENCRYPTED = 0) {
  PNMBuilder builder_(_fbb);
  builder_.add_FILE_ENCRYPTED(FILE_ENCRYPTED);
  builder_.add_FILE(FILE);
  return builder_.Finish();
}

/// Collection of Publish Notification Messages
/// This table groups multiple PNM records for batch processing and management.
struct PNMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PNMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PNM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PNM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct PNMCOLLECTIONBuilder {
  typedef PNMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PNM>>> RECORDS) {
    fbb_.AddOffset(PNMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit PNMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PNMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PNMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PNMCOLLECTION> CreatePNMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PNM>>> RECORDS = 0) {
  PNMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PNMCOLLECTION> CreatePNMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PNM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<PNM>>(*RECORDS) : 0;
  return CreatePNMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const PNMCOLLECTION *GetPNMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetRoot<PNMCOLLECTION>(buf);
}

inline const PNMCOLLECTION *GetSizePrefixedPNMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PNMCOLLECTION>(buf);
}

inline const char *PNMCOLLECTIONIdentifier() {
  return "$PNM";
}

inline bool PNMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PNMCOLLECTIONIdentifier());
}

inline bool SizePrefixedPNMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PNMCOLLECTIONIdentifier(), true);
}

inline bool VerifyPNMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PNMCOLLECTION>(PNMCOLLECTIONIdentifier());
}

inline bool VerifySizePrefixedPNMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PNMCOLLECTION>(PNMCOLLECTIONIdentifier());
}

inline void FinishPNMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PNMCOLLECTION> root) {
  fbb.Finish(root, PNMCOLLECTIONIdentifier());
}

inline void FinishSizePrefixedPNMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PNMCOLLECTION> root) {
  fbb.FinishSizePrefixed(root, PNMCOLLECTIONIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
