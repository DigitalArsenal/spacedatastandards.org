// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct PNM;
struct PNMBuilder;

struct PNMCOLLECTION;
struct PNMCOLLECTIONBuilder;

/// Publish Notification Message
struct PNM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PNMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIFORMAT_ADDRESS = 4,
    VT_PUBLISH_TIMESTAMP = 6,
    VT_CID = 8,
    VT_FILE_NAME = 10,
    VT_FILE_ID = 12,
    VT_SIGNATURE = 14,
    VT_TIMESTAMP_SIGNATURE = 16,
    VT_SIGNATURE_TYPE = 18,
    VT_TIMESTAMP_SIGNATURE_TYPE = 20
  };
  /// Multiformat Address
  /// https://multiformats.io/multiaddr/
  /// A universal address format for representing multiple network protocols. Examples include:
  /// - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
  /// - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
  /// - /dns4/example.com for a domain name resolvable only to IPv4 addresses
  /// - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
  const ::flatbuffers::String *MULTIFORMAT_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MULTIFORMAT_ADDRESS);
  }
  /// Publish Time OF THE Publish Notification Message
  const ::flatbuffers::String *PUBLISH_TIMESTAMP() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PUBLISH_TIMESTAMP);
  }
  /// Concatenated Content Identifier (CID)
  /// This field is a unique ID for distributed systems (CID).
  /// The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
  const ::flatbuffers::String *CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CID);
  }
  /// File ID
  /// This field is the Name
  const ::flatbuffers::String *FILE_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_NAME);
  }
  /// File ID
  /// This field is the file ID / Standard Type
  const ::flatbuffers::String *FILE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_ID);
  }
  /// Digital Signature of the CID
  /// This is the digital signature of the CID, signed using the specified cryptographic method.
  const ::flatbuffers::String *SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE);
  }
  /// Timestamp Signature
  /// Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
  const ::flatbuffers::String *TIMESTAMP_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMESTAMP_SIGNATURE);
  }
  /// Type of Cryptographic Signature Used
  /// Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  const ::flatbuffers::String *SIGNATURE_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNATURE_TYPE);
  }
  /// Type of Cryptographic Signature Used for Timestamp
  /// Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  const ::flatbuffers::String *TIMESTAMP_SIGNATURE_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIMESTAMP_SIGNATURE_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTIFORMAT_ADDRESS) &&
           verifier.VerifyString(MULTIFORMAT_ADDRESS()) &&
           VerifyOffset(verifier, VT_PUBLISH_TIMESTAMP) &&
           verifier.VerifyString(PUBLISH_TIMESTAMP()) &&
           VerifyOffset(verifier, VT_CID) &&
           verifier.VerifyString(CID()) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(FILE_NAME()) &&
           VerifyOffset(verifier, VT_FILE_ID) &&
           verifier.VerifyString(FILE_ID()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyString(SIGNATURE()) &&
           VerifyOffset(verifier, VT_TIMESTAMP_SIGNATURE) &&
           verifier.VerifyString(TIMESTAMP_SIGNATURE()) &&
           VerifyOffset(verifier, VT_SIGNATURE_TYPE) &&
           verifier.VerifyString(SIGNATURE_TYPE()) &&
           VerifyOffset(verifier, VT_TIMESTAMP_SIGNATURE_TYPE) &&
           verifier.VerifyString(TIMESTAMP_SIGNATURE_TYPE()) &&
           verifier.EndTable();
  }
};

struct PNMBuilder {
  typedef PNM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MULTIFORMAT_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> MULTIFORMAT_ADDRESS) {
    fbb_.AddOffset(PNM::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  void add_PUBLISH_TIMESTAMP(::flatbuffers::Offset<::flatbuffers::String> PUBLISH_TIMESTAMP) {
    fbb_.AddOffset(PNM::VT_PUBLISH_TIMESTAMP, PUBLISH_TIMESTAMP);
  }
  void add_CID(::flatbuffers::Offset<::flatbuffers::String> CID) {
    fbb_.AddOffset(PNM::VT_CID, CID);
  }
  void add_FILE_NAME(::flatbuffers::Offset<::flatbuffers::String> FILE_NAME) {
    fbb_.AddOffset(PNM::VT_FILE_NAME, FILE_NAME);
  }
  void add_FILE_ID(::flatbuffers::Offset<::flatbuffers::String> FILE_ID) {
    fbb_.AddOffset(PNM::VT_FILE_ID, FILE_ID);
  }
  void add_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> SIGNATURE) {
    fbb_.AddOffset(PNM::VT_SIGNATURE, SIGNATURE);
  }
  void add_TIMESTAMP_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> TIMESTAMP_SIGNATURE) {
    fbb_.AddOffset(PNM::VT_TIMESTAMP_SIGNATURE, TIMESTAMP_SIGNATURE);
  }
  void add_SIGNATURE_TYPE(::flatbuffers::Offset<::flatbuffers::String> SIGNATURE_TYPE) {
    fbb_.AddOffset(PNM::VT_SIGNATURE_TYPE, SIGNATURE_TYPE);
  }
  void add_TIMESTAMP_SIGNATURE_TYPE(::flatbuffers::Offset<::flatbuffers::String> TIMESTAMP_SIGNATURE_TYPE) {
    fbb_.AddOffset(PNM::VT_TIMESTAMP_SIGNATURE_TYPE, TIMESTAMP_SIGNATURE_TYPE);
  }
  explicit PNMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PNM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PNM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PNM> CreatePNM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> MULTIFORMAT_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PUBLISH_TIMESTAMP = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FILE_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FILE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIMESTAMP_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SIGNATURE_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIMESTAMP_SIGNATURE_TYPE = 0) {
  PNMBuilder builder_(_fbb);
  builder_.add_TIMESTAMP_SIGNATURE_TYPE(TIMESTAMP_SIGNATURE_TYPE);
  builder_.add_SIGNATURE_TYPE(SIGNATURE_TYPE);
  builder_.add_TIMESTAMP_SIGNATURE(TIMESTAMP_SIGNATURE);
  builder_.add_SIGNATURE(SIGNATURE);
  builder_.add_FILE_ID(FILE_ID);
  builder_.add_FILE_NAME(FILE_NAME);
  builder_.add_CID(CID);
  builder_.add_PUBLISH_TIMESTAMP(PUBLISH_TIMESTAMP);
  builder_.add_MULTIFORMAT_ADDRESS(MULTIFORMAT_ADDRESS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PNM> CreatePNMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *MULTIFORMAT_ADDRESS = nullptr,
    const char *PUBLISH_TIMESTAMP = nullptr,
    const char *CID = nullptr,
    const char *FILE_NAME = nullptr,
    const char *FILE_ID = nullptr,
    const char *SIGNATURE = nullptr,
    const char *TIMESTAMP_SIGNATURE = nullptr,
    const char *SIGNATURE_TYPE = nullptr,
    const char *TIMESTAMP_SIGNATURE_TYPE = nullptr) {
  auto MULTIFORMAT_ADDRESS__ = MULTIFORMAT_ADDRESS ? _fbb.CreateString(MULTIFORMAT_ADDRESS) : 0;
  auto PUBLISH_TIMESTAMP__ = PUBLISH_TIMESTAMP ? _fbb.CreateString(PUBLISH_TIMESTAMP) : 0;
  auto CID__ = CID ? _fbb.CreateString(CID) : 0;
  auto FILE_NAME__ = FILE_NAME ? _fbb.CreateString(FILE_NAME) : 0;
  auto FILE_ID__ = FILE_ID ? _fbb.CreateString(FILE_ID) : 0;
  auto SIGNATURE__ = SIGNATURE ? _fbb.CreateString(SIGNATURE) : 0;
  auto TIMESTAMP_SIGNATURE__ = TIMESTAMP_SIGNATURE ? _fbb.CreateString(TIMESTAMP_SIGNATURE) : 0;
  auto SIGNATURE_TYPE__ = SIGNATURE_TYPE ? _fbb.CreateString(SIGNATURE_TYPE) : 0;
  auto TIMESTAMP_SIGNATURE_TYPE__ = TIMESTAMP_SIGNATURE_TYPE ? _fbb.CreateString(TIMESTAMP_SIGNATURE_TYPE) : 0;
  return CreatePNM(
      _fbb,
      MULTIFORMAT_ADDRESS__,
      PUBLISH_TIMESTAMP__,
      CID__,
      FILE_NAME__,
      FILE_ID__,
      SIGNATURE__,
      TIMESTAMP_SIGNATURE__,
      SIGNATURE_TYPE__,
      TIMESTAMP_SIGNATURE_TYPE__);
}

struct PNMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PNMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PNM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PNM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct PNMCOLLECTIONBuilder {
  typedef PNMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PNM>>> RECORDS) {
    fbb_.AddOffset(PNMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit PNMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PNMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PNMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PNMCOLLECTION> CreatePNMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PNM>>> RECORDS = 0) {
  PNMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PNMCOLLECTION> CreatePNMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PNM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<PNM>>(*RECORDS) : 0;
  return CreatePNMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const PNM *GetPNM(const void *buf) {
  return ::flatbuffers::GetRoot<PNM>(buf);
}

inline const PNM *GetSizePrefixedPNM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PNM>(buf);
}

inline const char *PNMIdentifier() {
  return "$PNM";
}

inline bool PNMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PNMIdentifier());
}

inline bool SizePrefixedPNMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PNMIdentifier(), true);
}

inline bool VerifyPNMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PNM>(PNMIdentifier());
}

inline bool VerifySizePrefixedPNMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PNM>(PNMIdentifier());
}

inline void FinishPNMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PNM> root) {
  fbb.Finish(root, PNMIdentifier());
}

inline void FinishSizePrefixedPNMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PNM> root) {
  fbb.FinishSizePrefixed(root, PNMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
