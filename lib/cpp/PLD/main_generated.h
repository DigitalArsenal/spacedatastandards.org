// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct PLD;
struct PLDBuilder;

struct PLDCOLLECTION;
struct PLDCOLLECTIONBuilder;

/// Payload Information
struct PLD FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PLDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAYLOAD_DURATION = 4,
    VT_MASS_AT_LAUNCH = 6,
    VT_DIMENSIONS = 8,
    VT_SOLAR_ARRAY_AREA = 10,
    VT_SOLAR_ARRAY_DIMENSIONS = 12,
    VT_NOMINAL_OPERATIONAL_LIFETIME = 14,
    VT_INSTRUMENTS = 16
  };
  const ::flatbuffers::String *PAYLOAD_DURATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYLOAD_DURATION);
  }
  float MASS_AT_LAUNCH() const {
    return GetField<float>(VT_MASS_AT_LAUNCH, 0.0f);
  }
  const ::flatbuffers::String *DIMENSIONS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIMENSIONS);
  }
  float SOLAR_ARRAY_AREA() const {
    return GetField<float>(VT_SOLAR_ARRAY_AREA, 0.0f);
  }
  const ::flatbuffers::String *SOLAR_ARRAY_DIMENSIONS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOLAR_ARRAY_DIMENSIONS);
  }
  const ::flatbuffers::String *NOMINAL_OPERATIONAL_LIFETIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOMINAL_OPERATIONAL_LIFETIME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<IDM>> *INSTRUMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<IDM>> *>(VT_INSTRUMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYLOAD_DURATION) &&
           verifier.VerifyString(PAYLOAD_DURATION()) &&
           VerifyField<float>(verifier, VT_MASS_AT_LAUNCH, 4) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyString(DIMENSIONS()) &&
           VerifyField<float>(verifier, VT_SOLAR_ARRAY_AREA, 4) &&
           VerifyOffset(verifier, VT_SOLAR_ARRAY_DIMENSIONS) &&
           verifier.VerifyString(SOLAR_ARRAY_DIMENSIONS()) &&
           VerifyOffset(verifier, VT_NOMINAL_OPERATIONAL_LIFETIME) &&
           verifier.VerifyString(NOMINAL_OPERATIONAL_LIFETIME()) &&
           VerifyOffset(verifier, VT_INSTRUMENTS) &&
           verifier.VerifyVector(INSTRUMENTS()) &&
           verifier.VerifyVectorOfTables(INSTRUMENTS()) &&
           verifier.EndTable();
  }
};

struct PLDBuilder {
  typedef PLD Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PAYLOAD_DURATION(::flatbuffers::Offset<::flatbuffers::String> PAYLOAD_DURATION) {
    fbb_.AddOffset(PLD::VT_PAYLOAD_DURATION, PAYLOAD_DURATION);
  }
  void add_MASS_AT_LAUNCH(float MASS_AT_LAUNCH) {
    fbb_.AddElement<float>(PLD::VT_MASS_AT_LAUNCH, MASS_AT_LAUNCH, 0.0f);
  }
  void add_DIMENSIONS(::flatbuffers::Offset<::flatbuffers::String> DIMENSIONS) {
    fbb_.AddOffset(PLD::VT_DIMENSIONS, DIMENSIONS);
  }
  void add_SOLAR_ARRAY_AREA(float SOLAR_ARRAY_AREA) {
    fbb_.AddElement<float>(PLD::VT_SOLAR_ARRAY_AREA, SOLAR_ARRAY_AREA, 0.0f);
  }
  void add_SOLAR_ARRAY_DIMENSIONS(::flatbuffers::Offset<::flatbuffers::String> SOLAR_ARRAY_DIMENSIONS) {
    fbb_.AddOffset(PLD::VT_SOLAR_ARRAY_DIMENSIONS, SOLAR_ARRAY_DIMENSIONS);
  }
  void add_NOMINAL_OPERATIONAL_LIFETIME(::flatbuffers::Offset<::flatbuffers::String> NOMINAL_OPERATIONAL_LIFETIME) {
    fbb_.AddOffset(PLD::VT_NOMINAL_OPERATIONAL_LIFETIME, NOMINAL_OPERATIONAL_LIFETIME);
  }
  void add_INSTRUMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IDM>>> INSTRUMENTS) {
    fbb_.AddOffset(PLD::VT_INSTRUMENTS, INSTRUMENTS);
  }
  explicit PLDBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PLD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PLD>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PLD> CreatePLD(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PAYLOAD_DURATION = 0,
    float MASS_AT_LAUNCH = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> DIMENSIONS = 0,
    float SOLAR_ARRAY_AREA = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> SOLAR_ARRAY_DIMENSIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOMINAL_OPERATIONAL_LIFETIME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IDM>>> INSTRUMENTS = 0) {
  PLDBuilder builder_(_fbb);
  builder_.add_INSTRUMENTS(INSTRUMENTS);
  builder_.add_NOMINAL_OPERATIONAL_LIFETIME(NOMINAL_OPERATIONAL_LIFETIME);
  builder_.add_SOLAR_ARRAY_DIMENSIONS(SOLAR_ARRAY_DIMENSIONS);
  builder_.add_SOLAR_ARRAY_AREA(SOLAR_ARRAY_AREA);
  builder_.add_DIMENSIONS(DIMENSIONS);
  builder_.add_MASS_AT_LAUNCH(MASS_AT_LAUNCH);
  builder_.add_PAYLOAD_DURATION(PAYLOAD_DURATION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PLD> CreatePLDDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PAYLOAD_DURATION = nullptr,
    float MASS_AT_LAUNCH = 0.0f,
    const char *DIMENSIONS = nullptr,
    float SOLAR_ARRAY_AREA = 0.0f,
    const char *SOLAR_ARRAY_DIMENSIONS = nullptr,
    const char *NOMINAL_OPERATIONAL_LIFETIME = nullptr,
    const std::vector<::flatbuffers::Offset<IDM>> *INSTRUMENTS = nullptr) {
  auto PAYLOAD_DURATION__ = PAYLOAD_DURATION ? _fbb.CreateString(PAYLOAD_DURATION) : 0;
  auto DIMENSIONS__ = DIMENSIONS ? _fbb.CreateString(DIMENSIONS) : 0;
  auto SOLAR_ARRAY_DIMENSIONS__ = SOLAR_ARRAY_DIMENSIONS ? _fbb.CreateString(SOLAR_ARRAY_DIMENSIONS) : 0;
  auto NOMINAL_OPERATIONAL_LIFETIME__ = NOMINAL_OPERATIONAL_LIFETIME ? _fbb.CreateString(NOMINAL_OPERATIONAL_LIFETIME) : 0;
  auto INSTRUMENTS__ = INSTRUMENTS ? _fbb.CreateVector<::flatbuffers::Offset<IDM>>(*INSTRUMENTS) : 0;
  return CreatePLD(
      _fbb,
      PAYLOAD_DURATION__,
      MASS_AT_LAUNCH,
      DIMENSIONS__,
      SOLAR_ARRAY_AREA,
      SOLAR_ARRAY_DIMENSIONS__,
      NOMINAL_OPERATIONAL_LIFETIME__,
      INSTRUMENTS__);
}

struct PLDCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PLDCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PLD>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct PLDCOLLECTIONBuilder {
  typedef PLDCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> RECORDS) {
    fbb_.AddOffset(PLDCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit PLDCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PLDCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PLDCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PLDCOLLECTION> CreatePLDCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PLD>>> RECORDS = 0) {
  PLDCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PLDCOLLECTION> CreatePLDCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PLD>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<PLD>>(*RECORDS) : 0;
  return CreatePLDCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const PLD *GetPLD(const void *buf) {
  return ::flatbuffers::GetRoot<PLD>(buf);
}

inline const PLD *GetSizePrefixedPLD(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PLD>(buf);
}

inline const char *PLDIdentifier() {
  return "$PLD";
}

inline bool PLDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLDIdentifier());
}

inline bool SizePrefixedPLDBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLDIdentifier(), true);
}

inline bool VerifyPLDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PLD>(PLDIdentifier());
}

inline bool VerifySizePrefixedPLDBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PLD>(PLDIdentifier());
}

inline void FinishPLDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLD> root) {
  fbb.Finish(root, PLDIdentifier());
}

inline void FinishSizePrefixedPLDBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLD> root) {
  fbb.FinishSizePrefixed(root, PLDIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
