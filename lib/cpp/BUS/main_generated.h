// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct BUS;
struct BUSBuilder;

enum busSize : int8_t {
  busSize_FEMTO = 0,
  busSize_PICO = 1,
  busSize_NANO = 2,
  busSize_MICRO = 3,
  busSize_MINI = 4,
  busSize_SMALL = 5,
  busSize_MEDIUM = 6,
  busSize_LARGE = 7,
  busSize_HEAVY = 8,
  busSize_MIN = busSize_FEMTO,
  busSize_MAX = busSize_HEAVY
};

inline const busSize (&EnumValuesbusSize())[9] {
  static const busSize values[] = {
    busSize_FEMTO,
    busSize_PICO,
    busSize_NANO,
    busSize_MICRO,
    busSize_MINI,
    busSize_SMALL,
    busSize_MEDIUM,
    busSize_LARGE,
    busSize_HEAVY
  };
  return values;
}

inline const char * const *EnumNamesbusSize() {
  static const char * const names[10] = {
    "FEMTO",
    "PICO",
    "NANO",
    "MICRO",
    "MINI",
    "SMALL",
    "MEDIUM",
    "LARGE",
    "HEAVY",
    nullptr
  };
  return names;
}

inline const char *EnumNamebusSize(busSize e) {
  if (::flatbuffers::IsOutRange(e, busSize_FEMTO, busSize_HEAVY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesbusSize()[index];
}

enum BusStabilizationType : int8_t {
  BusStabilizationType_THREE_AXIS = 0,
  BusStabilizationType_SPIN = 1,
  BusStabilizationType_GRAVITY_GRADIENT = 2,
  BusStabilizationType_MAGNETIC = 3,
  BusStabilizationType_DUAL_SPIN = 4,
  BusStabilizationType_NONE = 5,
  BusStabilizationType_MIN = BusStabilizationType_THREE_AXIS,
  BusStabilizationType_MAX = BusStabilizationType_NONE
};

inline const BusStabilizationType (&EnumValuesBusStabilizationType())[6] {
  static const BusStabilizationType values[] = {
    BusStabilizationType_THREE_AXIS,
    BusStabilizationType_SPIN,
    BusStabilizationType_GRAVITY_GRADIENT,
    BusStabilizationType_MAGNETIC,
    BusStabilizationType_DUAL_SPIN,
    BusStabilizationType_NONE
  };
  return values;
}

inline const char * const *EnumNamesBusStabilizationType() {
  static const char * const names[7] = {
    "THREE_AXIS",
    "SPIN",
    "GRAVITY_GRADIENT",
    "MAGNETIC",
    "DUAL_SPIN",
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBusStabilizationType(BusStabilizationType e) {
  if (::flatbuffers::IsOutRange(e, BusStabilizationType_THREE_AXIS, BusStabilizationType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBusStabilizationType()[index];
}

/// Satellite Bus Specification
struct BUS FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BUSBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_MANUFACTURER = 8,
    VT_SIZE = 10,
    VT_DRY_MASS = 12,
    VT_WET_MASS = 14,
    VT_PAYLOAD_MASS = 16,
    VT_DIM_X = 18,
    VT_DIM_Y = 20,
    VT_DIM_Z = 22,
    VT_STOWED_X = 24,
    VT_STOWED_Y = 26,
    VT_STOWED_Z = 28,
    VT_POWER_GENERATION = 30,
    VT_PAYLOAD_POWER = 32,
    VT_BATTERY_CAPACITY = 34,
    VT_STABILIZATION = 36,
    VT_POINTING_ACCURACY = 38,
    VT_POINTING_KNOWLEDGE = 40,
    VT_DESIGN_LIFE = 42,
    VT_DATA_STORAGE = 44,
    VT_DOWNLINK_RATE = 46,
    VT_PAYLOAD_SLOTS = 48,
    VT_HERITAGE_COUNT = 50,
    VT_NOTES = 52
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Bus name or model
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Manufacturer
  const ::flatbuffers::String *MANUFACTURER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANUFACTURER);
  }
  /// Bus size category
  busSize SIZE() const {
    return static_cast<busSize>(GetField<int8_t>(VT_SIZE, 0));
  }
  /// Dry mass in kg
  double DRY_MASS() const {
    return GetField<double>(VT_DRY_MASS, 0.0);
  }
  /// Maximum wet mass (with propellant) in kg
  double WET_MASS() const {
    return GetField<double>(VT_WET_MASS, 0.0);
  }
  /// Maximum payload mass in kg
  double PAYLOAD_MASS() const {
    return GetField<double>(VT_PAYLOAD_MASS, 0.0);
  }
  /// Bus dimensions X in meters
  double DIM_X() const {
    return GetField<double>(VT_DIM_X, 0.0);
  }
  /// Bus dimensions Y in meters
  double DIM_Y() const {
    return GetField<double>(VT_DIM_Y, 0.0);
  }
  /// Bus dimensions Z in meters
  double DIM_Z() const {
    return GetField<double>(VT_DIM_Z, 0.0);
  }
  /// Stowed dimensions X in meters
  double STOWED_X() const {
    return GetField<double>(VT_STOWED_X, 0.0);
  }
  /// Stowed dimensions Y in meters
  double STOWED_Y() const {
    return GetField<double>(VT_STOWED_Y, 0.0);
  }
  /// Stowed dimensions Z in meters
  double STOWED_Z() const {
    return GetField<double>(VT_STOWED_Z, 0.0);
  }
  /// Total power generation in Watts
  double POWER_GENERATION() const {
    return GetField<double>(VT_POWER_GENERATION, 0.0);
  }
  /// Available payload power in Watts
  double PAYLOAD_POWER() const {
    return GetField<double>(VT_PAYLOAD_POWER, 0.0);
  }
  /// Battery capacity in Watt-hours
  double BATTERY_CAPACITY() const {
    return GetField<double>(VT_BATTERY_CAPACITY, 0.0);
  }
  /// Stabilization method
  BusStabilizationType STABILIZATION() const {
    return static_cast<BusStabilizationType>(GetField<int8_t>(VT_STABILIZATION, 0));
  }
  /// Pointing accuracy in degrees
  double POINTING_ACCURACY() const {
    return GetField<double>(VT_POINTING_ACCURACY, 0.0);
  }
  /// Pointing knowledge in degrees
  double POINTING_KNOWLEDGE() const {
    return GetField<double>(VT_POINTING_KNOWLEDGE, 0.0);
  }
  /// Design life in years
  double DESIGN_LIFE() const {
    return GetField<double>(VT_DESIGN_LIFE, 0.0);
  }
  /// Data storage capacity in Gbits
  double DATA_STORAGE() const {
    return GetField<double>(VT_DATA_STORAGE, 0.0);
  }
  /// Downlink data rate in Mbps
  double DOWNLINK_RATE() const {
    return GetField<double>(VT_DOWNLINK_RATE, 0.0);
  }
  /// Number of payload slots/interfaces
  uint32_t PAYLOAD_SLOTS() const {
    return GetField<uint32_t>(VT_PAYLOAD_SLOTS, 0);
  }
  /// Heritage missions count
  uint32_t HERITAGE_COUNT() const {
    return GetField<uint32_t>(VT_HERITAGE_COUNT, 0);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_MANUFACTURER) &&
           verifier.VerifyString(MANUFACTURER()) &&
           VerifyField<int8_t>(verifier, VT_SIZE, 1) &&
           VerifyField<double>(verifier, VT_DRY_MASS, 8) &&
           VerifyField<double>(verifier, VT_WET_MASS, 8) &&
           VerifyField<double>(verifier, VT_PAYLOAD_MASS, 8) &&
           VerifyField<double>(verifier, VT_DIM_X, 8) &&
           VerifyField<double>(verifier, VT_DIM_Y, 8) &&
           VerifyField<double>(verifier, VT_DIM_Z, 8) &&
           VerifyField<double>(verifier, VT_STOWED_X, 8) &&
           VerifyField<double>(verifier, VT_STOWED_Y, 8) &&
           VerifyField<double>(verifier, VT_STOWED_Z, 8) &&
           VerifyField<double>(verifier, VT_POWER_GENERATION, 8) &&
           VerifyField<double>(verifier, VT_PAYLOAD_POWER, 8) &&
           VerifyField<double>(verifier, VT_BATTERY_CAPACITY, 8) &&
           VerifyField<int8_t>(verifier, VT_STABILIZATION, 1) &&
           VerifyField<double>(verifier, VT_POINTING_ACCURACY, 8) &&
           VerifyField<double>(verifier, VT_POINTING_KNOWLEDGE, 8) &&
           VerifyField<double>(verifier, VT_DESIGN_LIFE, 8) &&
           VerifyField<double>(verifier, VT_DATA_STORAGE, 8) &&
           VerifyField<double>(verifier, VT_DOWNLINK_RATE, 8) &&
           VerifyField<uint32_t>(verifier, VT_PAYLOAD_SLOTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_HERITAGE_COUNT, 4) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct BUSBuilder {
  typedef BUS Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(BUS::VT_ID, ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(BUS::VT_NAME, NAME);
  }
  void add_MANUFACTURER(::flatbuffers::Offset<::flatbuffers::String> MANUFACTURER) {
    fbb_.AddOffset(BUS::VT_MANUFACTURER, MANUFACTURER);
  }
  void add_SIZE(busSize SIZE) {
    fbb_.AddElement<int8_t>(BUS::VT_SIZE, static_cast<int8_t>(SIZE), 0);
  }
  void add_DRY_MASS(double DRY_MASS) {
    fbb_.AddElement<double>(BUS::VT_DRY_MASS, DRY_MASS, 0.0);
  }
  void add_WET_MASS(double WET_MASS) {
    fbb_.AddElement<double>(BUS::VT_WET_MASS, WET_MASS, 0.0);
  }
  void add_PAYLOAD_MASS(double PAYLOAD_MASS) {
    fbb_.AddElement<double>(BUS::VT_PAYLOAD_MASS, PAYLOAD_MASS, 0.0);
  }
  void add_DIM_X(double DIM_X) {
    fbb_.AddElement<double>(BUS::VT_DIM_X, DIM_X, 0.0);
  }
  void add_DIM_Y(double DIM_Y) {
    fbb_.AddElement<double>(BUS::VT_DIM_Y, DIM_Y, 0.0);
  }
  void add_DIM_Z(double DIM_Z) {
    fbb_.AddElement<double>(BUS::VT_DIM_Z, DIM_Z, 0.0);
  }
  void add_STOWED_X(double STOWED_X) {
    fbb_.AddElement<double>(BUS::VT_STOWED_X, STOWED_X, 0.0);
  }
  void add_STOWED_Y(double STOWED_Y) {
    fbb_.AddElement<double>(BUS::VT_STOWED_Y, STOWED_Y, 0.0);
  }
  void add_STOWED_Z(double STOWED_Z) {
    fbb_.AddElement<double>(BUS::VT_STOWED_Z, STOWED_Z, 0.0);
  }
  void add_POWER_GENERATION(double POWER_GENERATION) {
    fbb_.AddElement<double>(BUS::VT_POWER_GENERATION, POWER_GENERATION, 0.0);
  }
  void add_PAYLOAD_POWER(double PAYLOAD_POWER) {
    fbb_.AddElement<double>(BUS::VT_PAYLOAD_POWER, PAYLOAD_POWER, 0.0);
  }
  void add_BATTERY_CAPACITY(double BATTERY_CAPACITY) {
    fbb_.AddElement<double>(BUS::VT_BATTERY_CAPACITY, BATTERY_CAPACITY, 0.0);
  }
  void add_STABILIZATION(BusStabilizationType STABILIZATION) {
    fbb_.AddElement<int8_t>(BUS::VT_STABILIZATION, static_cast<int8_t>(STABILIZATION), 0);
  }
  void add_POINTING_ACCURACY(double POINTING_ACCURACY) {
    fbb_.AddElement<double>(BUS::VT_POINTING_ACCURACY, POINTING_ACCURACY, 0.0);
  }
  void add_POINTING_KNOWLEDGE(double POINTING_KNOWLEDGE) {
    fbb_.AddElement<double>(BUS::VT_POINTING_KNOWLEDGE, POINTING_KNOWLEDGE, 0.0);
  }
  void add_DESIGN_LIFE(double DESIGN_LIFE) {
    fbb_.AddElement<double>(BUS::VT_DESIGN_LIFE, DESIGN_LIFE, 0.0);
  }
  void add_DATA_STORAGE(double DATA_STORAGE) {
    fbb_.AddElement<double>(BUS::VT_DATA_STORAGE, DATA_STORAGE, 0.0);
  }
  void add_DOWNLINK_RATE(double DOWNLINK_RATE) {
    fbb_.AddElement<double>(BUS::VT_DOWNLINK_RATE, DOWNLINK_RATE, 0.0);
  }
  void add_PAYLOAD_SLOTS(uint32_t PAYLOAD_SLOTS) {
    fbb_.AddElement<uint32_t>(BUS::VT_PAYLOAD_SLOTS, PAYLOAD_SLOTS, 0);
  }
  void add_HERITAGE_COUNT(uint32_t HERITAGE_COUNT) {
    fbb_.AddElement<uint32_t>(BUS::VT_HERITAGE_COUNT, HERITAGE_COUNT, 0);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(BUS::VT_NOTES, NOTES);
  }
  explicit BUSBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BUS>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BUS> CreateBUS(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MANUFACTURER = 0,
    busSize SIZE = busSize_FEMTO,
    double DRY_MASS = 0.0,
    double WET_MASS = 0.0,
    double PAYLOAD_MASS = 0.0,
    double DIM_X = 0.0,
    double DIM_Y = 0.0,
    double DIM_Z = 0.0,
    double STOWED_X = 0.0,
    double STOWED_Y = 0.0,
    double STOWED_Z = 0.0,
    double POWER_GENERATION = 0.0,
    double PAYLOAD_POWER = 0.0,
    double BATTERY_CAPACITY = 0.0,
    BusStabilizationType STABILIZATION = BusStabilizationType_THREE_AXIS,
    double POINTING_ACCURACY = 0.0,
    double POINTING_KNOWLEDGE = 0.0,
    double DESIGN_LIFE = 0.0,
    double DATA_STORAGE = 0.0,
    double DOWNLINK_RATE = 0.0,
    uint32_t PAYLOAD_SLOTS = 0,
    uint32_t HERITAGE_COUNT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  BUSBuilder builder_(_fbb);
  builder_.add_DOWNLINK_RATE(DOWNLINK_RATE);
  builder_.add_DATA_STORAGE(DATA_STORAGE);
  builder_.add_DESIGN_LIFE(DESIGN_LIFE);
  builder_.add_POINTING_KNOWLEDGE(POINTING_KNOWLEDGE);
  builder_.add_POINTING_ACCURACY(POINTING_ACCURACY);
  builder_.add_BATTERY_CAPACITY(BATTERY_CAPACITY);
  builder_.add_PAYLOAD_POWER(PAYLOAD_POWER);
  builder_.add_POWER_GENERATION(POWER_GENERATION);
  builder_.add_STOWED_Z(STOWED_Z);
  builder_.add_STOWED_Y(STOWED_Y);
  builder_.add_STOWED_X(STOWED_X);
  builder_.add_DIM_Z(DIM_Z);
  builder_.add_DIM_Y(DIM_Y);
  builder_.add_DIM_X(DIM_X);
  builder_.add_PAYLOAD_MASS(PAYLOAD_MASS);
  builder_.add_WET_MASS(WET_MASS);
  builder_.add_DRY_MASS(DRY_MASS);
  builder_.add_NOTES(NOTES);
  builder_.add_HERITAGE_COUNT(HERITAGE_COUNT);
  builder_.add_PAYLOAD_SLOTS(PAYLOAD_SLOTS);
  builder_.add_MANUFACTURER(MANUFACTURER);
  builder_.add_NAME(NAME);
  builder_.add_ID(ID);
  builder_.add_STABILIZATION(STABILIZATION);
  builder_.add_SIZE(SIZE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BUS> CreateBUSDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *NAME = nullptr,
    const char *MANUFACTURER = nullptr,
    busSize SIZE = busSize_FEMTO,
    double DRY_MASS = 0.0,
    double WET_MASS = 0.0,
    double PAYLOAD_MASS = 0.0,
    double DIM_X = 0.0,
    double DIM_Y = 0.0,
    double DIM_Z = 0.0,
    double STOWED_X = 0.0,
    double STOWED_Y = 0.0,
    double STOWED_Z = 0.0,
    double POWER_GENERATION = 0.0,
    double PAYLOAD_POWER = 0.0,
    double BATTERY_CAPACITY = 0.0,
    BusStabilizationType STABILIZATION = BusStabilizationType_THREE_AXIS,
    double POINTING_ACCURACY = 0.0,
    double POINTING_KNOWLEDGE = 0.0,
    double DESIGN_LIFE = 0.0,
    double DATA_STORAGE = 0.0,
    double DOWNLINK_RATE = 0.0,
    uint32_t PAYLOAD_SLOTS = 0,
    uint32_t HERITAGE_COUNT = 0,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto MANUFACTURER__ = MANUFACTURER ? _fbb.CreateString(MANUFACTURER) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateBUS(
      _fbb,
      ID__,
      NAME__,
      MANUFACTURER__,
      SIZE,
      DRY_MASS,
      WET_MASS,
      PAYLOAD_MASS,
      DIM_X,
      DIM_Y,
      DIM_Z,
      STOWED_X,
      STOWED_Y,
      STOWED_Z,
      POWER_GENERATION,
      PAYLOAD_POWER,
      BATTERY_CAPACITY,
      STABILIZATION,
      POINTING_ACCURACY,
      POINTING_KNOWLEDGE,
      DESIGN_LIFE,
      DATA_STORAGE,
      DOWNLINK_RATE,
      PAYLOAD_SLOTS,
      HERITAGE_COUNT,
      NOTES__);
}

inline const BUS *GetBUS(const void *buf) {
  return ::flatbuffers::GetRoot<BUS>(buf);
}

inline const BUS *GetSizePrefixedBUS(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<BUS>(buf);
}

inline const char *BUSIdentifier() {
  return "$BUS";
}

inline bool BUSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BUSIdentifier());
}

inline bool SizePrefixedBUSBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BUSIdentifier(), true);
}

inline bool VerifyBUSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BUS>(BUSIdentifier());
}

inline bool VerifySizePrefixedBUSBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BUS>(BUSIdentifier());
}

inline void FinishBUSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BUS> root) {
  fbb.Finish(root, BUSIdentifier());
}

inline void FinishSizePrefixedBUSBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BUS> root) {
  fbb.FinishSizePrefixed(root, BUSIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
