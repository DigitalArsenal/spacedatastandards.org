// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CTR;
struct CTRBuilder;

struct CTRCOLLECTION;
struct CTRCOLLECTIONBuilder;

/// Country Identity Message
struct CTR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CTRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_GENC_CODE = 8,
    VT_ALPHA_2_CODE = 10,
    VT_ALPHA_3_CODE = 12,
    VT_STANAG_CODE = 14,
    VT_INTERNET_CCTLD = 16,
    VT_COMMENT = 18
  };
  /// ISO 3166 Numeric code
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Country name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// GENC code
  const ::flatbuffers::String *GENC_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GENC_CODE);
  }
  /// ISO 3166 Alpha-2 code
  const ::flatbuffers::String *ALPHA_2_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALPHA_2_CODE);
  }
  /// ISO 3166 Alpha-3 code
  const ::flatbuffers::String *ALPHA_3_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALPHA_3_CODE);
  }
  /// Stanag code
  const ::flatbuffers::String *STANAG_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STANAG_CODE);
  }
  /// Internet country code top-level domain (ccTLD)
  const ::flatbuffers::String *INTERNET_CCTLD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERNET_CCTLD);
  }
  /// Additional comments
  const ::flatbuffers::String *COMMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_GENC_CODE) &&
           verifier.VerifyString(GENC_CODE()) &&
           VerifyOffset(verifier, VT_ALPHA_2_CODE) &&
           verifier.VerifyString(ALPHA_2_CODE()) &&
           VerifyOffset(verifier, VT_ALPHA_3_CODE) &&
           verifier.VerifyString(ALPHA_3_CODE()) &&
           VerifyOffset(verifier, VT_STANAG_CODE) &&
           verifier.VerifyString(STANAG_CODE()) &&
           VerifyOffset(verifier, VT_INTERNET_CCTLD) &&
           verifier.VerifyString(INTERNET_CCTLD()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           verifier.EndTable();
  }
};

struct CTRBuilder {
  typedef CTR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(CTR::VT_ID, ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CTR::VT_NAME, NAME);
  }
  void add_GENC_CODE(::flatbuffers::Offset<::flatbuffers::String> GENC_CODE) {
    fbb_.AddOffset(CTR::VT_GENC_CODE, GENC_CODE);
  }
  void add_ALPHA_2_CODE(::flatbuffers::Offset<::flatbuffers::String> ALPHA_2_CODE) {
    fbb_.AddOffset(CTR::VT_ALPHA_2_CODE, ALPHA_2_CODE);
  }
  void add_ALPHA_3_CODE(::flatbuffers::Offset<::flatbuffers::String> ALPHA_3_CODE) {
    fbb_.AddOffset(CTR::VT_ALPHA_3_CODE, ALPHA_3_CODE);
  }
  void add_STANAG_CODE(::flatbuffers::Offset<::flatbuffers::String> STANAG_CODE) {
    fbb_.AddOffset(CTR::VT_STANAG_CODE, STANAG_CODE);
  }
  void add_INTERNET_CCTLD(::flatbuffers::Offset<::flatbuffers::String> INTERNET_CCTLD) {
    fbb_.AddOffset(CTR::VT_INTERNET_CCTLD, INTERNET_CCTLD);
  }
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::String> COMMENT) {
    fbb_.AddOffset(CTR::VT_COMMENT, COMMENT);
  }
  explicit CTRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CTR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CTR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CTR> CreateCTR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GENC_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALPHA_2_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALPHA_3_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STANAG_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INTERNET_CCTLD = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COMMENT = 0) {
  CTRBuilder builder_(_fbb);
  builder_.add_COMMENT(COMMENT);
  builder_.add_INTERNET_CCTLD(INTERNET_CCTLD);
  builder_.add_STANAG_CODE(STANAG_CODE);
  builder_.add_ALPHA_3_CODE(ALPHA_3_CODE);
  builder_.add_ALPHA_2_CODE(ALPHA_2_CODE);
  builder_.add_GENC_CODE(GENC_CODE);
  builder_.add_NAME(NAME);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CTR> CreateCTRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *NAME = nullptr,
    const char *GENC_CODE = nullptr,
    const char *ALPHA_2_CODE = nullptr,
    const char *ALPHA_3_CODE = nullptr,
    const char *STANAG_CODE = nullptr,
    const char *INTERNET_CCTLD = nullptr,
    const char *COMMENT = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto GENC_CODE__ = GENC_CODE ? _fbb.CreateString(GENC_CODE) : 0;
  auto ALPHA_2_CODE__ = ALPHA_2_CODE ? _fbb.CreateString(ALPHA_2_CODE) : 0;
  auto ALPHA_3_CODE__ = ALPHA_3_CODE ? _fbb.CreateString(ALPHA_3_CODE) : 0;
  auto STANAG_CODE__ = STANAG_CODE ? _fbb.CreateString(STANAG_CODE) : 0;
  auto INTERNET_CCTLD__ = INTERNET_CCTLD ? _fbb.CreateString(INTERNET_CCTLD) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  return CreateCTR(
      _fbb,
      ID__,
      NAME__,
      GENC_CODE__,
      ALPHA_2_CODE__,
      ALPHA_3_CODE__,
      STANAG_CODE__,
      INTERNET_CCTLD__,
      COMMENT__);
}

struct CTRCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CTRCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CTR>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CTR>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct CTRCOLLECTIONBuilder {
  typedef CTRCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CTR>>> RECORDS) {
    fbb_.AddOffset(CTRCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit CTRCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CTRCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CTRCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CTRCOLLECTION> CreateCTRCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CTR>>> RECORDS = 0) {
  CTRCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CTRCOLLECTION> CreateCTRCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CTR>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<CTR>>(*RECORDS) : 0;
  return CreateCTRCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const CTR *GetCTR(const void *buf) {
  return ::flatbuffers::GetRoot<CTR>(buf);
}

inline const CTR *GetSizePrefixedCTR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CTR>(buf);
}

inline const char *CTRIdentifier() {
  return "$CTR";
}

inline bool CTRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CTRIdentifier());
}

inline bool SizePrefixedCTRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CTRIdentifier(), true);
}

inline bool VerifyCTRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CTR>(CTRIdentifier());
}

inline bool VerifySizePrefixedCTRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CTR>(CTRIdentifier());
}

inline void FinishCTRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CTR> root) {
  fbb.Finish(root, CTRIdentifier());
}

inline void FinishSizePrefixedCTRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CTR> root) {
  fbb.FinishSizePrefixed(root, CTRIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
