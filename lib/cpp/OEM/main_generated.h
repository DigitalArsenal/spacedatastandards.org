// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"

struct ephemerisDataLine;
struct ephemerisDataLineBuilder;

struct covarianceMatrixLine;
struct covarianceMatrixLineBuilder;

struct ephemerisDataBlock;
struct ephemerisDataBlockBuilder;

struct OEM;
struct OEMBuilder;

/// A single ephemeris data line
struct ephemerisDataLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ephemerisDataLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_X_DOT = 12,
    VT_Y_DOT = 14,
    VT_Z_DOT = 16,
    VT_X_DDOT = 18,
    VT_Y_DDOT = 20,
    VT_Z_DDOT = 22
  };
  /// Epoch time, in ISO 8601 UTC format
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// Position vector X-component km
  double X() const {
    return GetField<double>(VT_X, 0.0);
  }
  /// Position vector Y-component km
  double Y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  /// Position vector Z-component km
  double Z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  /// Velocity vector X-component km/s
  double X_DOT() const {
    return GetField<double>(VT_X_DOT, 0.0);
  }
  /// Velocity vector Y-component km/s
  double Y_DOT() const {
    return GetField<double>(VT_Y_DOT, 0.0);
  }
  /// Velocity vector Z-component km/s
  double Z_DOT() const {
    return GetField<double>(VT_Z_DOT, 0.0);
  }
  /// Optional: Acceleration vector X-component km/s/s
  double X_DDOT() const {
    return GetField<double>(VT_X_DDOT, 0.0);
  }
  /// Optional: Acceleration vector Y-component km/s/s
  double Y_DDOT() const {
    return GetField<double>(VT_Y_DDOT, 0.0);
  }
  /// Optional: Acceleration vector Z-component km/s/s
  double Z_DDOT() const {
    return GetField<double>(VT_Z_DDOT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_X_DOT, 8) &&
           VerifyField<double>(verifier, VT_Y_DOT, 8) &&
           VerifyField<double>(verifier, VT_Z_DOT, 8) &&
           VerifyField<double>(verifier, VT_X_DDOT, 8) &&
           VerifyField<double>(verifier, VT_Y_DDOT, 8) &&
           VerifyField<double>(verifier, VT_Z_DDOT, 8) &&
           verifier.EndTable();
  }
};

struct ephemerisDataLineBuilder {
  typedef ephemerisDataLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(ephemerisDataLine::VT_EPOCH, EPOCH);
  }
  void add_X(double X) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_X, X, 0.0);
  }
  void add_Y(double Y) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Y, Y, 0.0);
  }
  void add_Z(double Z) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Z, Z, 0.0);
  }
  void add_X_DOT(double X_DOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_X_DOT, X_DOT, 0.0);
  }
  void add_Y_DOT(double Y_DOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Y_DOT, Y_DOT, 0.0);
  }
  void add_Z_DOT(double Z_DOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Z_DOT, Z_DOT, 0.0);
  }
  void add_X_DDOT(double X_DDOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_X_DDOT, X_DDOT, 0.0);
  }
  void add_Y_DDOT(double Y_DDOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Y_DDOT, Y_DDOT, 0.0);
  }
  void add_Z_DDOT(double Z_DDOT) {
    fbb_.AddElement<double>(ephemerisDataLine::VT_Z_DDOT, Z_DDOT, 0.0);
  }
  explicit ephemerisDataLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ephemerisDataLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ephemerisDataLine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ephemerisDataLine> CreateephemerisDataLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double X_DOT = 0.0,
    double Y_DOT = 0.0,
    double Z_DOT = 0.0,
    double X_DDOT = 0.0,
    double Y_DDOT = 0.0,
    double Z_DDOT = 0.0) {
  ephemerisDataLineBuilder builder_(_fbb);
  builder_.add_Z_DDOT(Z_DDOT);
  builder_.add_Y_DDOT(Y_DDOT);
  builder_.add_X_DDOT(X_DDOT);
  builder_.add_Z_DOT(Z_DOT);
  builder_.add_Y_DOT(Y_DOT);
  builder_.add_X_DOT(X_DOT);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_EPOCH(EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ephemerisDataLine> CreateephemerisDataLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *EPOCH = nullptr,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double X_DOT = 0.0,
    double Y_DOT = 0.0,
    double Z_DOT = 0.0,
    double X_DDOT = 0.0,
    double Y_DDOT = 0.0,
    double Z_DDOT = 0.0) {
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  return CreateephemerisDataLine(
      _fbb,
      EPOCH__,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT);
}

/// Position/Velocity Covariance Matrix Line
struct covarianceMatrixLine FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef covarianceMatrixLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH = 4,
    VT_CX_X = 6,
    VT_CY_X = 8,
    VT_CY_Y = 10,
    VT_CZ_X = 12,
    VT_CZ_Y = 14,
    VT_CZ_Z = 16,
    VT_CX_DOT_X = 18,
    VT_CX_DOT_Y = 20,
    VT_CX_DOT_Z = 22,
    VT_CX_DOT_X_DOT = 24,
    VT_CY_DOT_X = 26,
    VT_CY_DOT_Y = 28,
    VT_CY_DOT_Z = 30,
    VT_CY_DOT_X_DOT = 32,
    VT_CY_DOT_Y_DOT = 34,
    VT_CZ_DOT_X = 36,
    VT_CZ_DOT_Y = 38,
    VT_CZ_DOT_Z = 40,
    VT_CZ_DOT_X_DOT = 42,
    VT_CZ_DOT_Y_DOT = 44,
    VT_CZ_DOT_Z_DOT = 46
  };
  /// Epoch
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// Covariance matrix [1,1] km**2
  double CX_X() const {
    return GetField<double>(VT_CX_X, 0.0);
  }
  /// Covariance matrix [2,1] km**2
  double CY_X() const {
    return GetField<double>(VT_CY_X, 0.0);
  }
  /// Covariance matrix [2,2] km**2
  double CY_Y() const {
    return GetField<double>(VT_CY_Y, 0.0);
  }
  /// Covariance matrix [3,1] km**2
  double CZ_X() const {
    return GetField<double>(VT_CZ_X, 0.0);
  }
  /// Covariance matrix [3,2] km**2
  double CZ_Y() const {
    return GetField<double>(VT_CZ_Y, 0.0);
  }
  /// Covariance matrix [3,3] km**2
  double CZ_Z() const {
    return GetField<double>(VT_CZ_Z, 0.0);
  }
  /// Covariance matrix [4,1] km**2/s
  double CX_DOT_X() const {
    return GetField<double>(VT_CX_DOT_X, 0.0);
  }
  /// Covariance matrix [4,2] km**2/s
  double CX_DOT_Y() const {
    return GetField<double>(VT_CX_DOT_Y, 0.0);
  }
  /// Covariance matrix [4,3] km**2/s
  double CX_DOT_Z() const {
    return GetField<double>(VT_CX_DOT_Z, 0.0);
  }
  /// Covariance matrix [4,4] km**2/s**2
  double CX_DOT_X_DOT() const {
    return GetField<double>(VT_CX_DOT_X_DOT, 0.0);
  }
  /// Covariance matrix [5,1] km**2/s
  double CY_DOT_X() const {
    return GetField<double>(VT_CY_DOT_X, 0.0);
  }
  /// Covariance matrix [5,2] km**2/s
  double CY_DOT_Y() const {
    return GetField<double>(VT_CY_DOT_Y, 0.0);
  }
  /// Covariance matrix [5,3] km**2/s
  double CY_DOT_Z() const {
    return GetField<double>(VT_CY_DOT_Z, 0.0);
  }
  /// Covariance matrix [5,4] km**2/s**2
  double CY_DOT_X_DOT() const {
    return GetField<double>(VT_CY_DOT_X_DOT, 0.0);
  }
  /// Covariance matrix [5,5] km**2/s**2
  double CY_DOT_Y_DOT() const {
    return GetField<double>(VT_CY_DOT_Y_DOT, 0.0);
  }
  /// Covariance matrix [6,1] km**2/s
  double CZ_DOT_X() const {
    return GetField<double>(VT_CZ_DOT_X, 0.0);
  }
  /// Covariance matrix [6,2] km**2/s
  double CZ_DOT_Y() const {
    return GetField<double>(VT_CZ_DOT_Y, 0.0);
  }
  /// Covariance matrix [6,3] km**2/s
  double CZ_DOT_Z() const {
    return GetField<double>(VT_CZ_DOT_Z, 0.0);
  }
  /// Covariance matrix [6,4] km**2/s**2
  double CZ_DOT_X_DOT() const {
    return GetField<double>(VT_CZ_DOT_X_DOT, 0.0);
  }
  /// Covariance matrix [6,5] km**2/s**2
  double CZ_DOT_Y_DOT() const {
    return GetField<double>(VT_CZ_DOT_Y_DOT, 0.0);
  }
  /// Covariance matrix [6,6] km**2/s**2
  double CZ_DOT_Z_DOT() const {
    return GetField<double>(VT_CZ_DOT_Z_DOT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_CX_X, 8) &&
           VerifyField<double>(verifier, VT_CY_X, 8) &&
           VerifyField<double>(verifier, VT_CY_Y, 8) &&
           VerifyField<double>(verifier, VT_CZ_X, 8) &&
           VerifyField<double>(verifier, VT_CZ_Y, 8) &&
           VerifyField<double>(verifier, VT_CZ_Z, 8) &&
           VerifyField<double>(verifier, VT_CX_DOT_X, 8) &&
           VerifyField<double>(verifier, VT_CX_DOT_Y, 8) &&
           VerifyField<double>(verifier, VT_CX_DOT_Z, 8) &&
           VerifyField<double>(verifier, VT_CX_DOT_X_DOT, 8) &&
           VerifyField<double>(verifier, VT_CY_DOT_X, 8) &&
           VerifyField<double>(verifier, VT_CY_DOT_Y, 8) &&
           VerifyField<double>(verifier, VT_CY_DOT_Z, 8) &&
           VerifyField<double>(verifier, VT_CY_DOT_X_DOT, 8) &&
           VerifyField<double>(verifier, VT_CY_DOT_Y_DOT, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_X, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Y, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Z, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_X_DOT, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Y_DOT, 8) &&
           VerifyField<double>(verifier, VT_CZ_DOT_Z_DOT, 8) &&
           verifier.EndTable();
  }
};

struct covarianceMatrixLineBuilder {
  typedef covarianceMatrixLine Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(covarianceMatrixLine::VT_EPOCH, EPOCH);
  }
  void add_CX_X(double CX_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CX_X, CX_X, 0.0);
  }
  void add_CY_X(double CY_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_X, CY_X, 0.0);
  }
  void add_CY_Y(double CY_Y) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_Y, CY_Y, 0.0);
  }
  void add_CZ_X(double CZ_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_X, CZ_X, 0.0);
  }
  void add_CZ_Y(double CZ_Y) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_Y, CZ_Y, 0.0);
  }
  void add_CZ_Z(double CZ_Z) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_Z, CZ_Z, 0.0);
  }
  void add_CX_DOT_X(double CX_DOT_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  void add_CX_DOT_Y(double CX_DOT_Y) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CX_DOT_Y, CX_DOT_Y, 0.0);
  }
  void add_CX_DOT_Z(double CX_DOT_Z) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CX_DOT_Z, CX_DOT_Z, 0.0);
  }
  void add_CX_DOT_X_DOT(double CX_DOT_X_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CX_DOT_X_DOT, CX_DOT_X_DOT, 0.0);
  }
  void add_CY_DOT_X(double CY_DOT_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_DOT_X, CY_DOT_X, 0.0);
  }
  void add_CY_DOT_Y(double CY_DOT_Y) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_DOT_Y, CY_DOT_Y, 0.0);
  }
  void add_CY_DOT_Z(double CY_DOT_Z) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_DOT_Z, CY_DOT_Z, 0.0);
  }
  void add_CY_DOT_X_DOT(double CY_DOT_X_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_DOT_X_DOT, CY_DOT_X_DOT, 0.0);
  }
  void add_CY_DOT_Y_DOT(double CY_DOT_Y_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CY_DOT_Y_DOT, CY_DOT_Y_DOT, 0.0);
  }
  void add_CZ_DOT_X(double CZ_DOT_X) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_X, CZ_DOT_X, 0.0);
  }
  void add_CZ_DOT_Y(double CZ_DOT_Y) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_Y, CZ_DOT_Y, 0.0);
  }
  void add_CZ_DOT_Z(double CZ_DOT_Z) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_Z, CZ_DOT_Z, 0.0);
  }
  void add_CZ_DOT_X_DOT(double CZ_DOT_X_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_X_DOT, CZ_DOT_X_DOT, 0.0);
  }
  void add_CZ_DOT_Y_DOT(double CZ_DOT_Y_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_Y_DOT, CZ_DOT_Y_DOT, 0.0);
  }
  void add_CZ_DOT_Z_DOT(double CZ_DOT_Z_DOT) {
    fbb_.AddElement<double>(covarianceMatrixLine::VT_CZ_DOT_Z_DOT, CZ_DOT_Z_DOT, 0.0);
  }
  explicit covarianceMatrixLineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<covarianceMatrixLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<covarianceMatrixLine>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<covarianceMatrixLine> CreatecovarianceMatrixLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    double CX_X = 0.0,
    double CY_X = 0.0,
    double CY_Y = 0.0,
    double CZ_X = 0.0,
    double CZ_Y = 0.0,
    double CZ_Z = 0.0,
    double CX_DOT_X = 0.0,
    double CX_DOT_Y = 0.0,
    double CX_DOT_Z = 0.0,
    double CX_DOT_X_DOT = 0.0,
    double CY_DOT_X = 0.0,
    double CY_DOT_Y = 0.0,
    double CY_DOT_Z = 0.0,
    double CY_DOT_X_DOT = 0.0,
    double CY_DOT_Y_DOT = 0.0,
    double CZ_DOT_X = 0.0,
    double CZ_DOT_Y = 0.0,
    double CZ_DOT_Z = 0.0,
    double CZ_DOT_X_DOT = 0.0,
    double CZ_DOT_Y_DOT = 0.0,
    double CZ_DOT_Z_DOT = 0.0) {
  covarianceMatrixLineBuilder builder_(_fbb);
  builder_.add_CZ_DOT_Z_DOT(CZ_DOT_Z_DOT);
  builder_.add_CZ_DOT_Y_DOT(CZ_DOT_Y_DOT);
  builder_.add_CZ_DOT_X_DOT(CZ_DOT_X_DOT);
  builder_.add_CZ_DOT_Z(CZ_DOT_Z);
  builder_.add_CZ_DOT_Y(CZ_DOT_Y);
  builder_.add_CZ_DOT_X(CZ_DOT_X);
  builder_.add_CY_DOT_Y_DOT(CY_DOT_Y_DOT);
  builder_.add_CY_DOT_X_DOT(CY_DOT_X_DOT);
  builder_.add_CY_DOT_Z(CY_DOT_Z);
  builder_.add_CY_DOT_Y(CY_DOT_Y);
  builder_.add_CY_DOT_X(CY_DOT_X);
  builder_.add_CX_DOT_X_DOT(CX_DOT_X_DOT);
  builder_.add_CX_DOT_Z(CX_DOT_Z);
  builder_.add_CX_DOT_Y(CX_DOT_Y);
  builder_.add_CX_DOT_X(CX_DOT_X);
  builder_.add_CZ_Z(CZ_Z);
  builder_.add_CZ_Y(CZ_Y);
  builder_.add_CZ_X(CZ_X);
  builder_.add_CY_Y(CY_Y);
  builder_.add_CY_X(CY_X);
  builder_.add_CX_X(CX_X);
  builder_.add_EPOCH(EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<covarianceMatrixLine> CreatecovarianceMatrixLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *EPOCH = nullptr,
    double CX_X = 0.0,
    double CY_X = 0.0,
    double CY_Y = 0.0,
    double CZ_X = 0.0,
    double CZ_Y = 0.0,
    double CZ_Z = 0.0,
    double CX_DOT_X = 0.0,
    double CX_DOT_Y = 0.0,
    double CX_DOT_Z = 0.0,
    double CX_DOT_X_DOT = 0.0,
    double CY_DOT_X = 0.0,
    double CY_DOT_Y = 0.0,
    double CY_DOT_Z = 0.0,
    double CY_DOT_X_DOT = 0.0,
    double CY_DOT_Y_DOT = 0.0,
    double CZ_DOT_X = 0.0,
    double CZ_DOT_Y = 0.0,
    double CZ_DOT_Z = 0.0,
    double CZ_DOT_X_DOT = 0.0,
    double CZ_DOT_Y_DOT = 0.0,
    double CZ_DOT_Z_DOT = 0.0) {
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  return CreatecovarianceMatrixLine(
      _fbb,
      EPOCH__,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT);
}

/// OEM Ephemeris Data Block
struct ephemerisDataBlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ephemerisDataBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMENT = 4,
    VT_OBJECT = 6,
    VT_CENTER_NAME = 8,
    VT_REFERENCE_FRAME = 10,
    VT_REFERENCE_FRAME_EPOCH = 12,
    VT_COV_REFERENCE_FRAME = 14,
    VT_TIME_SYSTEM = 16,
    VT_START_TIME = 18,
    VT_USEABLE_START_TIME = 20,
    VT_USEABLE_STOP_TIME = 22,
    VT_STOP_TIME = 24,
    VT_STEP_SIZE = 26,
    VT_INTERPOLATION = 28,
    VT_INTERPOLATION_DEGREE = 30,
    VT_EPHEMERIS_DATA_LINES = 32,
    VT_COVARIANCE_MATRIX_LINES = 34
  };
  /// Plain-Text Comment
  const ::flatbuffers::String *COMMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  /// Satellite name for the first object
  const CAT *OBJECT() const {
    return GetPointer<const CAT *>(VT_OBJECT);
  }
  /// Origin of reference frame (EARTH, MARS, MOON, etc.)
  const ::flatbuffers::String *CENTER_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CENTER_NAME);
  }
  /// Name of the reference frame (TEME, EME2000, etc.)
  const RFM *REFERENCE_FRAME() const {
    return GetPointer<const RFM *>(VT_REFERENCE_FRAME);
  }
  /// Epoch of reference frame, if not intrinsic to the definition of the reference frame
  const ::flatbuffers::String *REFERENCE_FRAME_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCE_FRAME_EPOCH);
  }
  /// Reference frame for the covariance matrix
  const RFM *COV_REFERENCE_FRAME() const {
    return GetPointer<const RFM *>(VT_COV_REFERENCE_FRAME);
  }
  /// Time system used for the orbit state and covariance matrix. (UTC)
  timeSystem TIME_SYSTEM() const {
    return static_cast<timeSystem>(GetField<int8_t>(VT_TIME_SYSTEM, 0));
  }
  /// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  /// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
  const ::flatbuffers::String *USEABLE_START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USEABLE_START_TIME);
  }
  /// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
  const ::flatbuffers::String *USEABLE_STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USEABLE_STOP_TIME);
  }
  /// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  const ::flatbuffers::String *STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOP_TIME);
  }
  /// Step size in seconds separating the epochs of each ephemeris data row
  double STEP_SIZE() const {
    return GetField<double>(VT_STEP_SIZE, 0.0);
  }
  /// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
  const ::flatbuffers::String *INTERPOLATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERPOLATION);
  }
  /// Recommended interpolation degree for ephemeris data
  uint32_t INTERPOLATION_DEGREE() const {
    return GetField<uint32_t>(VT_INTERPOLATION_DEGREE, 0);
  }
  /// Array of ephemeris data lines
  const ::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataLine>> *EPHEMERIS_DATA_LINES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataLine>> *>(VT_EPHEMERIS_DATA_LINES);
  }
  /// Array of covariance matrix lines
  const ::flatbuffers::Vector<::flatbuffers::Offset<covarianceMatrixLine>> *COVARIANCE_MATRIX_LINES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<covarianceMatrixLine>> *>(VT_COVARIANCE_MATRIX_LINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           verifier.VerifyTable(OBJECT()) &&
           VerifyOffset(verifier, VT_CENTER_NAME) &&
           verifier.VerifyString(CENTER_NAME()) &&
           VerifyOffset(verifier, VT_REFERENCE_FRAME) &&
           verifier.VerifyTable(REFERENCE_FRAME()) &&
           VerifyOffset(verifier, VT_REFERENCE_FRAME_EPOCH) &&
           verifier.VerifyString(REFERENCE_FRAME_EPOCH()) &&
           VerifyOffset(verifier, VT_COV_REFERENCE_FRAME) &&
           verifier.VerifyTable(COV_REFERENCE_FRAME()) &&
           VerifyField<int8_t>(verifier, VT_TIME_SYSTEM, 1) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_USEABLE_START_TIME) &&
           verifier.VerifyString(USEABLE_START_TIME()) &&
           VerifyOffset(verifier, VT_USEABLE_STOP_TIME) &&
           verifier.VerifyString(USEABLE_STOP_TIME()) &&
           VerifyOffset(verifier, VT_STOP_TIME) &&
           verifier.VerifyString(STOP_TIME()) &&
           VerifyField<double>(verifier, VT_STEP_SIZE, 8) &&
           VerifyOffset(verifier, VT_INTERPOLATION) &&
           verifier.VerifyString(INTERPOLATION()) &&
           VerifyField<uint32_t>(verifier, VT_INTERPOLATION_DEGREE, 4) &&
           VerifyOffset(verifier, VT_EPHEMERIS_DATA_LINES) &&
           verifier.VerifyVector(EPHEMERIS_DATA_LINES()) &&
           verifier.VerifyVectorOfTables(EPHEMERIS_DATA_LINES()) &&
           VerifyOffset(verifier, VT_COVARIANCE_MATRIX_LINES) &&
           verifier.VerifyVector(COVARIANCE_MATRIX_LINES()) &&
           verifier.VerifyVectorOfTables(COVARIANCE_MATRIX_LINES()) &&
           verifier.EndTable();
  }
};

struct ephemerisDataBlockBuilder {
  typedef ephemerisDataBlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::String> COMMENT) {
    fbb_.AddOffset(ephemerisDataBlock::VT_COMMENT, COMMENT);
  }
  void add_OBJECT(::flatbuffers::Offset<CAT> OBJECT) {
    fbb_.AddOffset(ephemerisDataBlock::VT_OBJECT, OBJECT);
  }
  void add_CENTER_NAME(::flatbuffers::Offset<::flatbuffers::String> CENTER_NAME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_CENTER_NAME, CENTER_NAME);
  }
  void add_REFERENCE_FRAME(::flatbuffers::Offset<RFM> REFERENCE_FRAME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_REFERENCE_FRAME, REFERENCE_FRAME);
  }
  void add_REFERENCE_FRAME_EPOCH(::flatbuffers::Offset<::flatbuffers::String> REFERENCE_FRAME_EPOCH) {
    fbb_.AddOffset(ephemerisDataBlock::VT_REFERENCE_FRAME_EPOCH, REFERENCE_FRAME_EPOCH);
  }
  void add_COV_REFERENCE_FRAME(::flatbuffers::Offset<RFM> COV_REFERENCE_FRAME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_COV_REFERENCE_FRAME, COV_REFERENCE_FRAME);
  }
  void add_TIME_SYSTEM(timeSystem TIME_SYSTEM) {
    fbb_.AddElement<int8_t>(ephemerisDataBlock::VT_TIME_SYSTEM, static_cast<int8_t>(TIME_SYSTEM), 0);
  }
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_START_TIME, START_TIME);
  }
  void add_USEABLE_START_TIME(::flatbuffers::Offset<::flatbuffers::String> USEABLE_START_TIME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_USEABLE_START_TIME, USEABLE_START_TIME);
  }
  void add_USEABLE_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> USEABLE_STOP_TIME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_USEABLE_STOP_TIME, USEABLE_STOP_TIME);
  }
  void add_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> STOP_TIME) {
    fbb_.AddOffset(ephemerisDataBlock::VT_STOP_TIME, STOP_TIME);
  }
  void add_STEP_SIZE(double STEP_SIZE) {
    fbb_.AddElement<double>(ephemerisDataBlock::VT_STEP_SIZE, STEP_SIZE, 0.0);
  }
  void add_INTERPOLATION(::flatbuffers::Offset<::flatbuffers::String> INTERPOLATION) {
    fbb_.AddOffset(ephemerisDataBlock::VT_INTERPOLATION, INTERPOLATION);
  }
  void add_INTERPOLATION_DEGREE(uint32_t INTERPOLATION_DEGREE) {
    fbb_.AddElement<uint32_t>(ephemerisDataBlock::VT_INTERPOLATION_DEGREE, INTERPOLATION_DEGREE, 0);
  }
  void add_EPHEMERIS_DATA_LINES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataLine>>> EPHEMERIS_DATA_LINES) {
    fbb_.AddOffset(ephemerisDataBlock::VT_EPHEMERIS_DATA_LINES, EPHEMERIS_DATA_LINES);
  }
  void add_COVARIANCE_MATRIX_LINES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<covarianceMatrixLine>>> COVARIANCE_MATRIX_LINES) {
    fbb_.AddOffset(ephemerisDataBlock::VT_COVARIANCE_MATRIX_LINES, COVARIANCE_MATRIX_LINES);
  }
  explicit ephemerisDataBlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ephemerisDataBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ephemerisDataBlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ephemerisDataBlock> CreateephemerisDataBlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMENT = 0,
    ::flatbuffers::Offset<CAT> OBJECT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CENTER_NAME = 0,
    ::flatbuffers::Offset<RFM> REFERENCE_FRAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REFERENCE_FRAME_EPOCH = 0,
    ::flatbuffers::Offset<RFM> COV_REFERENCE_FRAME = 0,
    timeSystem TIME_SYSTEM = timeSystem_GMST,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> USEABLE_START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> USEABLE_STOP_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STOP_TIME = 0,
    double STEP_SIZE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> INTERPOLATION = 0,
    uint32_t INTERPOLATION_DEGREE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataLine>>> EPHEMERIS_DATA_LINES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<covarianceMatrixLine>>> COVARIANCE_MATRIX_LINES = 0) {
  ephemerisDataBlockBuilder builder_(_fbb);
  builder_.add_STEP_SIZE(STEP_SIZE);
  builder_.add_COVARIANCE_MATRIX_LINES(COVARIANCE_MATRIX_LINES);
  builder_.add_EPHEMERIS_DATA_LINES(EPHEMERIS_DATA_LINES);
  builder_.add_INTERPOLATION_DEGREE(INTERPOLATION_DEGREE);
  builder_.add_INTERPOLATION(INTERPOLATION);
  builder_.add_STOP_TIME(STOP_TIME);
  builder_.add_USEABLE_STOP_TIME(USEABLE_STOP_TIME);
  builder_.add_USEABLE_START_TIME(USEABLE_START_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_COV_REFERENCE_FRAME(COV_REFERENCE_FRAME);
  builder_.add_REFERENCE_FRAME_EPOCH(REFERENCE_FRAME_EPOCH);
  builder_.add_REFERENCE_FRAME(REFERENCE_FRAME);
  builder_.add_CENTER_NAME(CENTER_NAME);
  builder_.add_OBJECT(OBJECT);
  builder_.add_COMMENT(COMMENT);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ephemerisDataBlock> CreateephemerisDataBlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMENT = nullptr,
    ::flatbuffers::Offset<CAT> OBJECT = 0,
    const char *CENTER_NAME = nullptr,
    ::flatbuffers::Offset<RFM> REFERENCE_FRAME = 0,
    const char *REFERENCE_FRAME_EPOCH = nullptr,
    ::flatbuffers::Offset<RFM> COV_REFERENCE_FRAME = 0,
    timeSystem TIME_SYSTEM = timeSystem_GMST,
    const char *START_TIME = nullptr,
    const char *USEABLE_START_TIME = nullptr,
    const char *USEABLE_STOP_TIME = nullptr,
    const char *STOP_TIME = nullptr,
    double STEP_SIZE = 0.0,
    const char *INTERPOLATION = nullptr,
    uint32_t INTERPOLATION_DEGREE = 0,
    const std::vector<::flatbuffers::Offset<ephemerisDataLine>> *EPHEMERIS_DATA_LINES = nullptr,
    const std::vector<::flatbuffers::Offset<covarianceMatrixLine>> *COVARIANCE_MATRIX_LINES = nullptr) {
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  auto CENTER_NAME__ = CENTER_NAME ? _fbb.CreateString(CENTER_NAME) : 0;
  auto REFERENCE_FRAME_EPOCH__ = REFERENCE_FRAME_EPOCH ? _fbb.CreateString(REFERENCE_FRAME_EPOCH) : 0;
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto USEABLE_START_TIME__ = USEABLE_START_TIME ? _fbb.CreateString(USEABLE_START_TIME) : 0;
  auto USEABLE_STOP_TIME__ = USEABLE_STOP_TIME ? _fbb.CreateString(USEABLE_STOP_TIME) : 0;
  auto STOP_TIME__ = STOP_TIME ? _fbb.CreateString(STOP_TIME) : 0;
  auto INTERPOLATION__ = INTERPOLATION ? _fbb.CreateString(INTERPOLATION) : 0;
  auto EPHEMERIS_DATA_LINES__ = EPHEMERIS_DATA_LINES ? _fbb.CreateVector<::flatbuffers::Offset<ephemerisDataLine>>(*EPHEMERIS_DATA_LINES) : 0;
  auto COVARIANCE_MATRIX_LINES__ = COVARIANCE_MATRIX_LINES ? _fbb.CreateVector<::flatbuffers::Offset<covarianceMatrixLine>>(*COVARIANCE_MATRIX_LINES) : 0;
  return CreateephemerisDataBlock(
      _fbb,
      COMMENT__,
      OBJECT,
      CENTER_NAME__,
      REFERENCE_FRAME,
      REFERENCE_FRAME_EPOCH__,
      COV_REFERENCE_FRAME,
      TIME_SYSTEM,
      START_TIME__,
      USEABLE_START_TIME__,
      USEABLE_STOP_TIME__,
      STOP_TIME__,
      STEP_SIZE,
      INTERPOLATION__,
      INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES__,
      COVARIANCE_MATRIX_LINES__);
}

/// Orbit Ephemeris Message
struct OEM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OEMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSIFICATION = 4,
    VT_CCSDS_OEM_VERS = 6,
    VT_CREATION_DATE = 8,
    VT_ORIGINATOR = 10,
    VT_EPHEMERIS_DATA_BLOCK = 12
  };
  /// OEM Header
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  const ::flatbuffers::String *CLASSIFICATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION);
  }
  /// OEM Version
  double CCSDS_OEM_VERS() const {
    return GetField<double>(VT_CCSDS_OEM_VERS, 0.0);
  }
  /// Creation Date
  const ::flatbuffers::String *CREATION_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATION_DATE);
  }
  /// Originator
  const ::flatbuffers::String *ORIGINATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  /// Array of ephemeris data blocks
  const ::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataBlock>> *EPHEMERIS_DATA_BLOCK() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataBlock>> *>(VT_EPHEMERIS_DATA_BLOCK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyString(CLASSIFICATION()) &&
           VerifyField<double>(verifier, VT_CCSDS_OEM_VERS, 8) &&
           VerifyOffset(verifier, VT_CREATION_DATE) &&
           verifier.VerifyString(CREATION_DATE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(ORIGINATOR()) &&
           VerifyOffset(verifier, VT_EPHEMERIS_DATA_BLOCK) &&
           verifier.VerifyVector(EPHEMERIS_DATA_BLOCK()) &&
           verifier.VerifyVectorOfTables(EPHEMERIS_DATA_BLOCK()) &&
           verifier.EndTable();
  }
};

struct OEMBuilder {
  typedef OEM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CLASSIFICATION(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION) {
    fbb_.AddOffset(OEM::VT_CLASSIFICATION, CLASSIFICATION);
  }
  void add_CCSDS_OEM_VERS(double CCSDS_OEM_VERS) {
    fbb_.AddElement<double>(OEM::VT_CCSDS_OEM_VERS, CCSDS_OEM_VERS, 0.0);
  }
  void add_CREATION_DATE(::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE) {
    fbb_.AddOffset(OEM::VT_CREATION_DATE, CREATION_DATE);
  }
  void add_ORIGINATOR(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR) {
    fbb_.AddOffset(OEM::VT_ORIGINATOR, ORIGINATOR);
  }
  void add_EPHEMERIS_DATA_BLOCK(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataBlock>>> EPHEMERIS_DATA_BLOCK) {
    fbb_.AddOffset(OEM::VT_EPHEMERIS_DATA_BLOCK, EPHEMERIS_DATA_BLOCK);
  }
  explicit OEMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OEM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OEM> CreateOEM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION = 0,
    double CCSDS_OEM_VERS = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ephemerisDataBlock>>> EPHEMERIS_DATA_BLOCK = 0) {
  OEMBuilder builder_(_fbb);
  builder_.add_CCSDS_OEM_VERS(CCSDS_OEM_VERS);
  builder_.add_EPHEMERIS_DATA_BLOCK(EPHEMERIS_DATA_BLOCK);
  builder_.add_ORIGINATOR(ORIGINATOR);
  builder_.add_CREATION_DATE(CREATION_DATE);
  builder_.add_CLASSIFICATION(CLASSIFICATION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OEM> CreateOEMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CLASSIFICATION = nullptr,
    double CCSDS_OEM_VERS = 0.0,
    const char *CREATION_DATE = nullptr,
    const char *ORIGINATOR = nullptr,
    const std::vector<::flatbuffers::Offset<ephemerisDataBlock>> *EPHEMERIS_DATA_BLOCK = nullptr) {
  auto CLASSIFICATION__ = CLASSIFICATION ? _fbb.CreateString(CLASSIFICATION) : 0;
  auto CREATION_DATE__ = CREATION_DATE ? _fbb.CreateString(CREATION_DATE) : 0;
  auto ORIGINATOR__ = ORIGINATOR ? _fbb.CreateString(ORIGINATOR) : 0;
  auto EPHEMERIS_DATA_BLOCK__ = EPHEMERIS_DATA_BLOCK ? _fbb.CreateVector<::flatbuffers::Offset<ephemerisDataBlock>>(*EPHEMERIS_DATA_BLOCK) : 0;
  return CreateOEM(
      _fbb,
      CLASSIFICATION__,
      CCSDS_OEM_VERS,
      CREATION_DATE__,
      ORIGINATOR__,
      EPHEMERIS_DATA_BLOCK__);
}

inline const OEM *GetOEM(const void *buf) {
  return ::flatbuffers::GetRoot<OEM>(buf);
}

inline const OEM *GetSizePrefixedOEM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OEM>(buf);
}

inline const char *OEMIdentifier() {
  return "$OEM";
}

inline bool OEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OEMIdentifier());
}

inline bool SizePrefixedOEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OEMIdentifier(), true);
}

inline bool VerifyOEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OEM>(OEMIdentifier());
}

inline bool VerifySizePrefixedOEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OEM>(OEMIdentifier());
}

inline void FinishOEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OEM> root) {
  fbb.Finish(root, OEMIdentifier());
}

inline void FinishSizePrefixedOEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OEM> root) {
  fbb.FinishSizePrefixed(root, OEMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
