// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct MPE;
struct MPEBuilder;

struct MPECOLLECTION;
struct MPECOLLECTIONBuilder;

enum referenceFrame : int8_t {
  /// Earth Mean Equator and Equinox of J2000
  referenceFrame_EME2000 = 0,
  /// Geocentric Celestial Reference Frame
  referenceFrame_GCRF = 1,
  /// Greenwich Rotating Coordinates
  referenceFrame_GRC = 2,
  /// International Celestial Reference Frame
  referenceFrame_ICRF = 3,
  /// International Terrestrial Reference Frame 2000
  referenceFrame_ITRF2000 = 4,
  /// International Terrestrial Reference Frame 1993
  referenceFrame_ITRF93 = 5,
  /// International Terrestrial Reference Frame 1997
  referenceFrame_ITRF97 = 6,
  /// Mars Centered Inertial
  referenceFrame_MCI = 7,
  /// True of Date, Rotating
  referenceFrame_TDR = 8,
  /// True Equator Mean Equinox
  referenceFrame_TEME = 9,
  /// True of Date
  referenceFrame_TOD = 10,
  referenceFrame_MIN = referenceFrame_EME2000,
  referenceFrame_MAX = referenceFrame_TOD
};

inline const referenceFrame (&EnumValuesreferenceFrame())[11] {
  static const referenceFrame values[] = {
    referenceFrame_EME2000,
    referenceFrame_GCRF,
    referenceFrame_GRC,
    referenceFrame_ICRF,
    referenceFrame_ITRF2000,
    referenceFrame_ITRF93,
    referenceFrame_ITRF97,
    referenceFrame_MCI,
    referenceFrame_TDR,
    referenceFrame_TEME,
    referenceFrame_TOD
  };
  return values;
}

inline const char * const *EnumNamesreferenceFrame() {
  static const char * const names[12] = {
    "EME2000",
    "GCRF",
    "GRC",
    "ICRF",
    "ITRF2000",
    "ITRF93",
    "ITRF97",
    "MCI",
    "TDR",
    "TEME",
    "TOD",
    nullptr
  };
  return names;
}

inline const char *EnumNamereferenceFrame(referenceFrame e) {
  if (::flatbuffers::IsOutRange(e, referenceFrame_EME2000, referenceFrame_TOD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesreferenceFrame()[index];
}

enum timeSystem : int8_t {
  /// Greenwich Mean Sidereal Time
  timeSystem_GMST = 0,
  /// Global Positioning System
  timeSystem_GPS = 1,
  /// Mission Elapsed Time
  timeSystem_MET = 2,
  /// Mission Relative Time
  timeSystem_MRT = 3,
  /// Spacecraft Clock (receiver) (requires rules for interpretation in ICD)
  timeSystem_SCLK = 4,
  /// International Atomic Time
  timeSystem_TAI = 5,
  /// Barycentric Coordinate Time
  timeSystem_TCB = 6,
  /// Barycentric Dynamical Time
  timeSystem_TDB = 7,
  /// Geocentric Coordinate Time
  timeSystem_TCG = 8,
  /// Terrestrial Time
  timeSystem_TT = 9,
  /// Universal Time
  timeSystem_UT1 = 10,
  /// Coordinated Universal Time
  timeSystem_UTC = 11,
  timeSystem_MIN = timeSystem_GMST,
  timeSystem_MAX = timeSystem_UTC
};

inline const timeSystem (&EnumValuestimeSystem())[12] {
  static const timeSystem values[] = {
    timeSystem_GMST,
    timeSystem_GPS,
    timeSystem_MET,
    timeSystem_MRT,
    timeSystem_SCLK,
    timeSystem_TAI,
    timeSystem_TCB,
    timeSystem_TDB,
    timeSystem_TCG,
    timeSystem_TT,
    timeSystem_UT1,
    timeSystem_UTC
  };
  return values;
}

inline const char * const *EnumNamestimeSystem() {
  static const char * const names[13] = {
    "GMST",
    "GPS",
    "MET",
    "MRT",
    "SCLK",
    "TAI",
    "TCB",
    "TDB",
    "TCG",
    "TT",
    "UT1",
    "UTC",
    nullptr
  };
  return names;
}

inline const char *EnumNametimeSystem(timeSystem e) {
  if (::flatbuffers::IsOutRange(e, timeSystem_GMST, timeSystem_UTC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamestimeSystem()[index];
}

enum meanElementTheory : int8_t {
  /// Simplified General Perturbation Model 4
  meanElementTheory_SGP4 = 0,
  /// Draper Semi-analytical Satellite Theory
  meanElementTheory_DSST = 1,
  /// Universal Semianalytical Method
  meanElementTheory_USM = 2,
  meanElementTheory_MIN = meanElementTheory_SGP4,
  meanElementTheory_MAX = meanElementTheory_USM
};

inline const meanElementTheory (&EnumValuesmeanElementTheory())[3] {
  static const meanElementTheory values[] = {
    meanElementTheory_SGP4,
    meanElementTheory_DSST,
    meanElementTheory_USM
  };
  return values;
}

inline const char * const *EnumNamesmeanElementTheory() {
  static const char * const names[4] = {
    "SGP4",
    "DSST",
    "USM",
    nullptr
  };
  return names;
}

inline const char *EnumNamemeanElementTheory(meanElementTheory e) {
  if (::flatbuffers::IsOutRange(e, meanElementTheory_SGP4, meanElementTheory_USM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmeanElementTheory()[index];
}

/// Minimum Propagatable Element Set
struct MPE FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MPEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY_ID = 4,
    VT_EPOCH = 6,
    VT_MEAN_MOTION = 8,
    VT_ECCENTRICITY = 10,
    VT_INCLINATION = 12,
    VT_RA_OF_ASC_NODE = 14,
    VT_ARG_OF_PERICENTER = 16,
    VT_MEAN_ANOMALY = 18,
    VT_BSTAR = 20
  };
  /// Unique ID as a String
  const ::flatbuffers::String *ENTITY_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENTITY_ID);
  }
  /// Epoch of Mean Keplerian elements. (UNIX TimeStamp)
  double EPOCH() const {
    return GetField<double>(VT_EPOCH, 0.0);
  }
  /// Semi-major axis in km or mean motion in rev/day
  double MEAN_MOTION() const {
    return GetField<double>(VT_MEAN_MOTION, 0.0);
  }
  /// Eccentricity
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  /// Inclination
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Right ascension of ascending node
  double RA_OF_ASC_NODE() const {
    return GetField<double>(VT_RA_OF_ASC_NODE, 0.0);
  }
  /// Argument of pericenter
  double ARG_OF_PERICENTER() const {
    return GetField<double>(VT_ARG_OF_PERICENTER, 0.0);
  }
  /// Mean anomaly
  double MEAN_ANOMALY() const {
    return GetField<double>(VT_MEAN_ANOMALY, 0.0);
  }
  /// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
  double BSTAR() const {
    return GetField<double>(VT_BSTAR, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_ID) &&
           verifier.VerifyString(ENTITY_ID()) &&
           VerifyField<double>(verifier, VT_EPOCH, 8) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION, 8) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_RA_OF_ASC_NODE, 8) &&
           VerifyField<double>(verifier, VT_ARG_OF_PERICENTER, 8) &&
           VerifyField<double>(verifier, VT_MEAN_ANOMALY, 8) &&
           VerifyField<double>(verifier, VT_BSTAR, 8) &&
           verifier.EndTable();
  }
};

struct MPEBuilder {
  typedef MPE Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ENTITY_ID(::flatbuffers::Offset<::flatbuffers::String> ENTITY_ID) {
    fbb_.AddOffset(MPE::VT_ENTITY_ID, ENTITY_ID);
  }
  void add_EPOCH(double EPOCH) {
    fbb_.AddElement<double>(MPE::VT_EPOCH, EPOCH, 0.0);
  }
  void add_MEAN_MOTION(double MEAN_MOTION) {
    fbb_.AddElement<double>(MPE::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(MPE::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(MPE::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_RA_OF_ASC_NODE(double RA_OF_ASC_NODE) {
    fbb_.AddElement<double>(MPE::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  void add_ARG_OF_PERICENTER(double ARG_OF_PERICENTER) {
    fbb_.AddElement<double>(MPE::VT_ARG_OF_PERICENTER, ARG_OF_PERICENTER, 0.0);
  }
  void add_MEAN_ANOMALY(double MEAN_ANOMALY) {
    fbb_.AddElement<double>(MPE::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  void add_BSTAR(double BSTAR) {
    fbb_.AddElement<double>(MPE::VT_BSTAR, BSTAR, 0.0);
  }
  explicit MPEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MPE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MPE>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MPE> CreateMPE(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ENTITY_ID = 0,
    double EPOCH = 0.0,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RA_OF_ASC_NODE = 0.0,
    double ARG_OF_PERICENTER = 0.0,
    double MEAN_ANOMALY = 0.0,
    double BSTAR = 0.0) {
  MPEBuilder builder_(_fbb);
  builder_.add_BSTAR(BSTAR);
  builder_.add_MEAN_ANOMALY(MEAN_ANOMALY);
  builder_.add_ARG_OF_PERICENTER(ARG_OF_PERICENTER);
  builder_.add_RA_OF_ASC_NODE(RA_OF_ASC_NODE);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_MEAN_MOTION(MEAN_MOTION);
  builder_.add_EPOCH(EPOCH);
  builder_.add_ENTITY_ID(ENTITY_ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MPE> CreateMPEDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ENTITY_ID = nullptr,
    double EPOCH = 0.0,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RA_OF_ASC_NODE = 0.0,
    double ARG_OF_PERICENTER = 0.0,
    double MEAN_ANOMALY = 0.0,
    double BSTAR = 0.0) {
  auto ENTITY_ID__ = ENTITY_ID ? _fbb.CreateString(ENTITY_ID) : 0;
  return CreateMPE(
      _fbb,
      ENTITY_ID__,
      EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      MEAN_ANOMALY,
      BSTAR);
}

/// Collection of MPE Records
struct MPECOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MPECOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSIFICATION_TYPE = 4,
    VT_REF_FRAME = 6,
    VT_REF_FRAME_EPOCH = 8,
    VT_TIME_SYSTEM = 10,
    VT_MEAN_ELEMENT_THEORY = 12,
    VT_RECORDS = 14
  };
  /// Default value = U
  const ::flatbuffers::String *CLASSIFICATION_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION_TYPE);
  }
  /// Name of the reference frame (TEME, EME2000, etc.)
  referenceFrame REF_FRAME() const {
    return static_cast<referenceFrame>(GetField<int8_t>(VT_REF_FRAME, 9));
  }
  /// Epoch of the Reference Frame. (UNIX TimeStamp)
  double REF_FRAME_EPOCH() const {
    return GetField<double>(VT_REF_FRAME_EPOCH, 0.0);
  }
  /// Time system used for the orbit state and covariance matrix. (UTC)
  timeSystem TIME_SYSTEM() const {
    return static_cast<timeSystem>(GetField<int8_t>(VT_TIME_SYSTEM, 11));
  }
  /// Description of the Mean Element Theory. (SGP4,DSST,USM)
  meanElementTheory MEAN_ELEMENT_THEORY() const {
    return static_cast<meanElementTheory>(GetField<int8_t>(VT_MEAN_ELEMENT_THEORY, 0));
  }
  /// Array of MPE records
  const ::flatbuffers::Vector<::flatbuffers::Offset<MPE>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MPE>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLASSIFICATION_TYPE) &&
           verifier.VerifyString(CLASSIFICATION_TYPE()) &&
           VerifyField<int8_t>(verifier, VT_REF_FRAME, 1) &&
           VerifyField<double>(verifier, VT_REF_FRAME_EPOCH, 8) &&
           VerifyField<int8_t>(verifier, VT_TIME_SYSTEM, 1) &&
           VerifyField<int8_t>(verifier, VT_MEAN_ELEMENT_THEORY, 1) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct MPECOLLECTIONBuilder {
  typedef MPECOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CLASSIFICATION_TYPE(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION_TYPE) {
    fbb_.AddOffset(MPECOLLECTION::VT_CLASSIFICATION_TYPE, CLASSIFICATION_TYPE);
  }
  void add_REF_FRAME(referenceFrame REF_FRAME) {
    fbb_.AddElement<int8_t>(MPECOLLECTION::VT_REF_FRAME, static_cast<int8_t>(REF_FRAME), 9);
  }
  void add_REF_FRAME_EPOCH(double REF_FRAME_EPOCH) {
    fbb_.AddElement<double>(MPECOLLECTION::VT_REF_FRAME_EPOCH, REF_FRAME_EPOCH, 0.0);
  }
  void add_TIME_SYSTEM(timeSystem TIME_SYSTEM) {
    fbb_.AddElement<int8_t>(MPECOLLECTION::VT_TIME_SYSTEM, static_cast<int8_t>(TIME_SYSTEM), 11);
  }
  void add_MEAN_ELEMENT_THEORY(meanElementTheory MEAN_ELEMENT_THEORY) {
    fbb_.AddElement<int8_t>(MPECOLLECTION::VT_MEAN_ELEMENT_THEORY, static_cast<int8_t>(MEAN_ELEMENT_THEORY), 0);
  }
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MPE>>> RECORDS) {
    fbb_.AddOffset(MPECOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit MPECOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MPECOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MPECOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MPECOLLECTION> CreateMPECOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION_TYPE = 0,
    referenceFrame REF_FRAME = referenceFrame_TEME,
    double REF_FRAME_EPOCH = 0.0,
    timeSystem TIME_SYSTEM = timeSystem_UTC,
    meanElementTheory MEAN_ELEMENT_THEORY = meanElementTheory_SGP4,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MPE>>> RECORDS = 0) {
  MPECOLLECTIONBuilder builder_(_fbb);
  builder_.add_REF_FRAME_EPOCH(REF_FRAME_EPOCH);
  builder_.add_RECORDS(RECORDS);
  builder_.add_CLASSIFICATION_TYPE(CLASSIFICATION_TYPE);
  builder_.add_MEAN_ELEMENT_THEORY(MEAN_ELEMENT_THEORY);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  builder_.add_REF_FRAME(REF_FRAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MPECOLLECTION> CreateMPECOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CLASSIFICATION_TYPE = nullptr,
    referenceFrame REF_FRAME = referenceFrame_TEME,
    double REF_FRAME_EPOCH = 0.0,
    timeSystem TIME_SYSTEM = timeSystem_UTC,
    meanElementTheory MEAN_ELEMENT_THEORY = meanElementTheory_SGP4,
    const std::vector<::flatbuffers::Offset<MPE>> *RECORDS = nullptr) {
  auto CLASSIFICATION_TYPE__ = CLASSIFICATION_TYPE ? _fbb.CreateString(CLASSIFICATION_TYPE) : 0;
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<MPE>>(*RECORDS) : 0;
  return CreateMPECOLLECTION(
      _fbb,
      CLASSIFICATION_TYPE__,
      REF_FRAME,
      REF_FRAME_EPOCH,
      TIME_SYSTEM,
      MEAN_ELEMENT_THEORY,
      RECORDS__);
}

inline const MPE *GetMPE(const void *buf) {
  return ::flatbuffers::GetRoot<MPE>(buf);
}

inline const MPE *GetSizePrefixedMPE(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MPE>(buf);
}

inline const char *MPEIdentifier() {
  return "$MPE";
}

inline bool MPEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MPEIdentifier());
}

inline bool SizePrefixedMPEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MPEIdentifier(), true);
}

inline bool VerifyMPEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MPE>(MPEIdentifier());
}

inline bool VerifySizePrefixedMPEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MPE>(MPEIdentifier());
}

inline void FinishMPEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MPE> root) {
  fbb.Finish(root, MPEIdentifier());
}

inline void FinishSizePrefixedMPEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MPE> root) {
  fbb.FinishSizePrefixed(root, MPEIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
