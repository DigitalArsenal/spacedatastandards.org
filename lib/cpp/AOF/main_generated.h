// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AOF;
struct AOFBuilder;

/// AOS Transfer Frame (CCSDS 732.0-B-3)
struct AOF FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AOFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_SPACECRAFT_ID = 6,
    VT_VIRTUAL_CHANNEL_ID = 8,
    VT_VIRTUAL_FRAME_COUNT = 10,
    VT_REPLAY_FLAG = 12,
    VT_VC_FRAME_COUNT_USAGE = 14,
    VT_VC_FRAME_COUNT_CYCLE = 16,
    VT_INSERT_ZONE = 18,
    VT_DATA = 20,
    VT_OCF = 22,
    VT_FECF = 24
  };
  /// Transfer frame version
  uint8_t VERSION() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  /// Spacecraft identifier
  uint16_t SPACECRAFT_ID() const {
    return GetField<uint16_t>(VT_SPACECRAFT_ID, 0);
  }
  /// Virtual channel identifier
  uint8_t VIRTUAL_CHANNEL_ID() const {
    return GetField<uint8_t>(VT_VIRTUAL_CHANNEL_ID, 0);
  }
  /// Virtual channel frame count
  uint32_t VIRTUAL_FRAME_COUNT() const {
    return GetField<uint32_t>(VT_VIRTUAL_FRAME_COUNT, 0);
  }
  /// Replay flag
  bool REPLAY_FLAG() const {
    return GetField<uint8_t>(VT_REPLAY_FLAG, 0) != 0;
  }
  /// VC frame count usage flag
  bool VC_FRAME_COUNT_USAGE() const {
    return GetField<uint8_t>(VT_VC_FRAME_COUNT_USAGE, 0) != 0;
  }
  /// VC frame count cycle
  uint8_t VC_FRAME_COUNT_CYCLE() const {
    return GetField<uint8_t>(VT_VC_FRAME_COUNT_CYCLE, 0);
  }
  /// Insert zone
  const ::flatbuffers::Vector<uint8_t> *INSERT_ZONE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_INSERT_ZONE);
  }
  /// Data field
  const ::flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  /// Operational control field
  const ::flatbuffers::Vector<uint8_t> *OCF() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OCF);
  }
  /// Frame error control field
  uint16_t FECF() const {
    return GetField<uint16_t>(VT_FECF, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION, 1) &&
           VerifyField<uint16_t>(verifier, VT_SPACECRAFT_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_VIRTUAL_CHANNEL_ID, 1) &&
           VerifyField<uint32_t>(verifier, VT_VIRTUAL_FRAME_COUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_REPLAY_FLAG, 1) &&
           VerifyField<uint8_t>(verifier, VT_VC_FRAME_COUNT_USAGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_VC_FRAME_COUNT_CYCLE, 1) &&
           VerifyOffset(verifier, VT_INSERT_ZONE) &&
           verifier.VerifyVector(INSERT_ZONE()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           VerifyOffset(verifier, VT_OCF) &&
           verifier.VerifyVector(OCF()) &&
           VerifyField<uint16_t>(verifier, VT_FECF, 2) &&
           verifier.EndTable();
  }
};

struct AOFBuilder {
  typedef AOF Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(uint8_t VERSION) {
    fbb_.AddElement<uint8_t>(AOF::VT_VERSION, VERSION, 0);
  }
  void add_SPACECRAFT_ID(uint16_t SPACECRAFT_ID) {
    fbb_.AddElement<uint16_t>(AOF::VT_SPACECRAFT_ID, SPACECRAFT_ID, 0);
  }
  void add_VIRTUAL_CHANNEL_ID(uint8_t VIRTUAL_CHANNEL_ID) {
    fbb_.AddElement<uint8_t>(AOF::VT_VIRTUAL_CHANNEL_ID, VIRTUAL_CHANNEL_ID, 0);
  }
  void add_VIRTUAL_FRAME_COUNT(uint32_t VIRTUAL_FRAME_COUNT) {
    fbb_.AddElement<uint32_t>(AOF::VT_VIRTUAL_FRAME_COUNT, VIRTUAL_FRAME_COUNT, 0);
  }
  void add_REPLAY_FLAG(bool REPLAY_FLAG) {
    fbb_.AddElement<uint8_t>(AOF::VT_REPLAY_FLAG, static_cast<uint8_t>(REPLAY_FLAG), 0);
  }
  void add_VC_FRAME_COUNT_USAGE(bool VC_FRAME_COUNT_USAGE) {
    fbb_.AddElement<uint8_t>(AOF::VT_VC_FRAME_COUNT_USAGE, static_cast<uint8_t>(VC_FRAME_COUNT_USAGE), 0);
  }
  void add_VC_FRAME_COUNT_CYCLE(uint8_t VC_FRAME_COUNT_CYCLE) {
    fbb_.AddElement<uint8_t>(AOF::VT_VC_FRAME_COUNT_CYCLE, VC_FRAME_COUNT_CYCLE, 0);
  }
  void add_INSERT_ZONE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> INSERT_ZONE) {
    fbb_.AddOffset(AOF::VT_INSERT_ZONE, INSERT_ZONE);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(AOF::VT_DATA, DATA);
  }
  void add_OCF(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> OCF) {
    fbb_.AddOffset(AOF::VT_OCF, OCF);
  }
  void add_FECF(uint16_t FECF) {
    fbb_.AddElement<uint16_t>(AOF::VT_FECF, FECF, 0);
  }
  explicit AOFBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AOF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AOF>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AOF> CreateAOF(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 0,
    uint16_t SPACECRAFT_ID = 0,
    uint8_t VIRTUAL_CHANNEL_ID = 0,
    uint32_t VIRTUAL_FRAME_COUNT = 0,
    bool REPLAY_FLAG = false,
    bool VC_FRAME_COUNT_USAGE = false,
    uint8_t VC_FRAME_COUNT_CYCLE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> INSERT_ZONE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> OCF = 0,
    uint16_t FECF = 0) {
  AOFBuilder builder_(_fbb);
  builder_.add_OCF(OCF);
  builder_.add_DATA(DATA);
  builder_.add_INSERT_ZONE(INSERT_ZONE);
  builder_.add_VIRTUAL_FRAME_COUNT(VIRTUAL_FRAME_COUNT);
  builder_.add_FECF(FECF);
  builder_.add_SPACECRAFT_ID(SPACECRAFT_ID);
  builder_.add_VC_FRAME_COUNT_CYCLE(VC_FRAME_COUNT_CYCLE);
  builder_.add_VC_FRAME_COUNT_USAGE(VC_FRAME_COUNT_USAGE);
  builder_.add_REPLAY_FLAG(REPLAY_FLAG);
  builder_.add_VIRTUAL_CHANNEL_ID(VIRTUAL_CHANNEL_ID);
  builder_.add_VERSION(VERSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AOF> CreateAOFDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 0,
    uint16_t SPACECRAFT_ID = 0,
    uint8_t VIRTUAL_CHANNEL_ID = 0,
    uint32_t VIRTUAL_FRAME_COUNT = 0,
    bool REPLAY_FLAG = false,
    bool VC_FRAME_COUNT_USAGE = false,
    uint8_t VC_FRAME_COUNT_CYCLE = 0,
    const std::vector<uint8_t> *INSERT_ZONE = nullptr,
    const std::vector<uint8_t> *DATA = nullptr,
    const std::vector<uint8_t> *OCF = nullptr,
    uint16_t FECF = 0) {
  auto INSERT_ZONE__ = INSERT_ZONE ? _fbb.CreateVector<uint8_t>(*INSERT_ZONE) : 0;
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  auto OCF__ = OCF ? _fbb.CreateVector<uint8_t>(*OCF) : 0;
  return CreateAOF(
      _fbb,
      VERSION,
      SPACECRAFT_ID,
      VIRTUAL_CHANNEL_ID,
      VIRTUAL_FRAME_COUNT,
      REPLAY_FLAG,
      VC_FRAME_COUNT_USAGE,
      VC_FRAME_COUNT_CYCLE,
      INSERT_ZONE__,
      DATA__,
      OCF__,
      FECF);
}

inline const AOF *GetAOF(const void *buf) {
  return ::flatbuffers::GetRoot<AOF>(buf);
}

inline const AOF *GetSizePrefixedAOF(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AOF>(buf);
}

inline const char *AOFIdentifier() {
  return "$AOF";
}

inline bool AOFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AOFIdentifier());
}

inline bool SizePrefixedAOFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AOFIdentifier(), true);
}

inline bool VerifyAOFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AOF>(AOFIdentifier());
}

inline bool VerifySizePrefixedAOFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AOF>(AOFIdentifier());
}

inline void FinishAOFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AOF> root) {
  fbb.Finish(root, AOFIdentifier());
}

inline void FinishSizePrefixedAOFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AOF> root) {
  fbb.FinishSizePrefixed(root, AOFIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
