// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct NAV;
struct NAVBuilder;

enum VesselType : int8_t {
  VesselType_CARRIER = 0,
  VesselType_BATTLESHIP = 1,
  VesselType_CRUISER = 2,
  VesselType_DESTROYER = 3,
  VesselType_FRIGATE = 4,
  VesselType_CORVETTE = 5,
  VesselType_PATROL = 6,
  VesselType_SUBMARINE_SSN = 7,
  VesselType_SUBMARINE_SSBN = 8,
  VesselType_SUBMARINE_SSK = 9,
  VesselType_AMPHIBIOUS = 10,
  VesselType_CARGO = 11,
  VesselType_TANKER = 12,
  VesselType_AUXILIARY = 13,
  VesselType_FAST_ATTACK = 14,
  VesselType_TORPEDO_BOAT = 15,
  VesselType_MIN = VesselType_CARRIER,
  VesselType_MAX = VesselType_TORPEDO_BOAT
};

inline const VesselType (&EnumValuesVesselType())[16] {
  static const VesselType values[] = {
    VesselType_CARRIER,
    VesselType_BATTLESHIP,
    VesselType_CRUISER,
    VesselType_DESTROYER,
    VesselType_FRIGATE,
    VesselType_CORVETTE,
    VesselType_PATROL,
    VesselType_SUBMARINE_SSN,
    VesselType_SUBMARINE_SSBN,
    VesselType_SUBMARINE_SSK,
    VesselType_AMPHIBIOUS,
    VesselType_CARGO,
    VesselType_TANKER,
    VesselType_AUXILIARY,
    VesselType_FAST_ATTACK,
    VesselType_TORPEDO_BOAT
  };
  return values;
}

inline const char * const *EnumNamesVesselType() {
  static const char * const names[17] = {
    "CARRIER",
    "BATTLESHIP",
    "CRUISER",
    "DESTROYER",
    "FRIGATE",
    "CORVETTE",
    "PATROL",
    "SUBMARINE_SSN",
    "SUBMARINE_SSBN",
    "SUBMARINE_SSK",
    "AMPHIBIOUS",
    "CARGO",
    "TANKER",
    "AUXILIARY",
    "FAST_ATTACK",
    "TORPEDO_BOAT",
    nullptr
  };
  return names;
}

inline const char *EnumNameVesselType(VesselType e) {
  if (::flatbuffers::IsOutRange(e, VesselType_CARRIER, VesselType_TORPEDO_BOAT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVesselType()[index];
}

enum PropulsionType : int8_t {
  PropulsionType_STEAM = 0,
  PropulsionType_GAS_TURBINE = 1,
  PropulsionType_DIESEL = 2,
  PropulsionType_DIESEL_ELECTRIC = 3,
  PropulsionType_NUCLEAR = 4,
  PropulsionType_CODAG = 5,
  PropulsionType_COGAG = 6,
  PropulsionType_CODLAG = 7,
  PropulsionType_AIP = 8,
  PropulsionType_MIN = PropulsionType_STEAM,
  PropulsionType_MAX = PropulsionType_AIP
};

inline const PropulsionType (&EnumValuesPropulsionType())[9] {
  static const PropulsionType values[] = {
    PropulsionType_STEAM,
    PropulsionType_GAS_TURBINE,
    PropulsionType_DIESEL,
    PropulsionType_DIESEL_ELECTRIC,
    PropulsionType_NUCLEAR,
    PropulsionType_CODAG,
    PropulsionType_COGAG,
    PropulsionType_CODLAG,
    PropulsionType_AIP
  };
  return values;
}

inline const char * const *EnumNamesPropulsionType() {
  static const char * const names[10] = {
    "STEAM",
    "GAS_TURBINE",
    "DIESEL",
    "DIESEL_ELECTRIC",
    "NUCLEAR",
    "CODAG",
    "COGAG",
    "CODLAG",
    "AIP",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropulsionType(PropulsionType e) {
  if (::flatbuffers::IsOutRange(e, PropulsionType_STEAM, PropulsionType_AIP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropulsionType()[index];
}

enum DCState : int8_t {
  DCState_NORMAL = 0,
  DCState_MINOR_DAMAGE = 1,
  DCState_MODERATE_DAMAGE = 2,
  DCState_SEVERE_DAMAGE = 3,
  DCState_CRITICAL = 4,
  DCState_SINKING = 5,
  DCState_ABANDONED = 6,
  DCState_MIN = DCState_NORMAL,
  DCState_MAX = DCState_ABANDONED
};

inline const DCState (&EnumValuesDCState())[7] {
  static const DCState values[] = {
    DCState_NORMAL,
    DCState_MINOR_DAMAGE,
    DCState_MODERATE_DAMAGE,
    DCState_SEVERE_DAMAGE,
    DCState_CRITICAL,
    DCState_SINKING,
    DCState_ABANDONED
  };
  return values;
}

inline const char * const *EnumNamesDCState() {
  static const char * const names[8] = {
    "NORMAL",
    "MINOR_DAMAGE",
    "MODERATE_DAMAGE",
    "SEVERE_DAMAGE",
    "CRITICAL",
    "SINKING",
    "ABANDONED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDCState(DCState e) {
  if (::flatbuffers::IsOutRange(e, DCState_NORMAL, DCState_ABANDONED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDCState()[index];
}

/// Naval Vessels
struct NAV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NAVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POSITION_Z = 8,
    VT_VELOCITY_X = 10,
    VT_VELOCITY_Y = 12,
    VT_VELOCITY_Z = 14,
    VT_ATTITUDE_X = 16,
    VT_ATTITUDE_Y = 18,
    VT_ATTITUDE_Z = 20,
    VT_ATTITUDE_W = 22,
    VT_OMEGA_X = 24,
    VT_OMEGA_Y = 26,
    VT_OMEGA_Z = 28,
    VT_SPEED_KNOTS = 30,
    VT_HEADING = 32,
    VT_COURSE = 34,
    VT_RUDDER_ANGLE = 36,
    VT_HULL = 38,
    VT_PROPULSION = 40,
    VT_DC_STATE = 42,
    VT_FIRES_ACTIVE = 44,
    VT_FLOODING_ACTIVE = 46,
    VT_CREW_CASUALTIES = 48,
    VT_HULL_INTEGRITY = 50,
    VT_POWER_AVAILABLE = 52,
    VT_WEAPONS_ONLINE = 54,
    VT_SENSORS_ONLINE = 56,
    VT_RESERVED1 = 58,
    VT_FUEL_REMAINING = 60,
    VT_AMMO_MAIN = 62,
    VT_MISSILES_REMAINING = 64,
    VT_TORPEDOES_REMAINING = 66,
    VT_VESSEL_TYPE = 68,
    VT_PROPULSION_TYPE = 70,
    VT_RESERVED = 72
  };
  double POSITION_X() const {
    return GetField<double>(VT_POSITION_X, 0.0);
  }
  double POSITION_Y() const {
    return GetField<double>(VT_POSITION_Y, 0.0);
  }
  double POSITION_Z() const {
    return GetField<double>(VT_POSITION_Z, 0.0);
  }
  double VELOCITY_X() const {
    return GetField<double>(VT_VELOCITY_X, 0.0);
  }
  double VELOCITY_Y() const {
    return GetField<double>(VT_VELOCITY_Y, 0.0);
  }
  double VELOCITY_Z() const {
    return GetField<double>(VT_VELOCITY_Z, 0.0);
  }
  double ATTITUDE_X() const {
    return GetField<double>(VT_ATTITUDE_X, 0.0);
  }
  double ATTITUDE_Y() const {
    return GetField<double>(VT_ATTITUDE_Y, 0.0);
  }
  double ATTITUDE_Z() const {
    return GetField<double>(VT_ATTITUDE_Z, 0.0);
  }
  double ATTITUDE_W() const {
    return GetField<double>(VT_ATTITUDE_W, 0.0);
  }
  double OMEGA_X() const {
    return GetField<double>(VT_OMEGA_X, 0.0);
  }
  double OMEGA_Y() const {
    return GetField<double>(VT_OMEGA_Y, 0.0);
  }
  double OMEGA_Z() const {
    return GetField<double>(VT_OMEGA_Z, 0.0);
  }
  float SPEED_KNOTS() const {
    return GetField<float>(VT_SPEED_KNOTS, 0.0f);
  }
  float HEADING() const {
    return GetField<float>(VT_HEADING, 0.0f);
  }
  float COURSE() const {
    return GetField<float>(VT_COURSE, 0.0f);
  }
  float RUDDER_ANGLE() const {
    return GetField<float>(VT_RUDDER_ANGLE, 0.0f);
  }
  const ::flatbuffers::String *HULL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HULL);
  }
  const ::flatbuffers::String *PROPULSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROPULSION);
  }
  uint8_t DC_STATE() const {
    return GetField<uint8_t>(VT_DC_STATE, 0);
  }
  uint8_t FIRES_ACTIVE() const {
    return GetField<uint8_t>(VT_FIRES_ACTIVE, 0);
  }
  uint8_t FLOODING_ACTIVE() const {
    return GetField<uint8_t>(VT_FLOODING_ACTIVE, 0);
  }
  uint8_t CREW_CASUALTIES() const {
    return GetField<uint8_t>(VT_CREW_CASUALTIES, 0);
  }
  float HULL_INTEGRITY() const {
    return GetField<float>(VT_HULL_INTEGRITY, 0.0f);
  }
  float POWER_AVAILABLE() const {
    return GetField<float>(VT_POWER_AVAILABLE, 0.0f);
  }
  uint8_t WEAPONS_ONLINE() const {
    return GetField<uint8_t>(VT_WEAPONS_ONLINE, 0);
  }
  uint8_t SENSORS_ONLINE() const {
    return GetField<uint8_t>(VT_SENSORS_ONLINE, 0);
  }
  uint16_t RESERVED1() const {
    return GetField<uint16_t>(VT_RESERVED1, 0);
  }
  float FUEL_REMAINING() const {
    return GetField<float>(VT_FUEL_REMAINING, 0.0f);
  }
  uint16_t AMMO_MAIN() const {
    return GetField<uint16_t>(VT_AMMO_MAIN, 0);
  }
  uint8_t MISSILES_REMAINING() const {
    return GetField<uint8_t>(VT_MISSILES_REMAINING, 0);
  }
  uint8_t TORPEDOES_REMAINING() const {
    return GetField<uint8_t>(VT_TORPEDOES_REMAINING, 0);
  }
  uint8_t VESSEL_TYPE() const {
    return GetField<uint8_t>(VT_VESSEL_TYPE, 0);
  }
  uint8_t PROPULSION_TYPE() const {
    return GetField<uint8_t>(VT_PROPULSION_TYPE, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_X, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Y, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_W, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_X, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Y, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Z, 8) &&
           VerifyField<float>(verifier, VT_SPEED_KNOTS, 4) &&
           VerifyField<float>(verifier, VT_HEADING, 4) &&
           VerifyField<float>(verifier, VT_COURSE, 4) &&
           VerifyField<float>(verifier, VT_RUDDER_ANGLE, 4) &&
           VerifyOffset(verifier, VT_HULL) &&
           verifier.VerifyString(HULL()) &&
           VerifyOffset(verifier, VT_PROPULSION) &&
           verifier.VerifyString(PROPULSION()) &&
           VerifyField<uint8_t>(verifier, VT_DC_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIRES_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOODING_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CREW_CASUALTIES, 1) &&
           VerifyField<float>(verifier, VT_HULL_INTEGRITY, 4) &&
           VerifyField<float>(verifier, VT_POWER_AVAILABLE, 4) &&
           VerifyField<uint8_t>(verifier, VT_WEAPONS_ONLINE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SENSORS_ONLINE, 1) &&
           VerifyField<uint16_t>(verifier, VT_RESERVED1, 2) &&
           VerifyField<float>(verifier, VT_FUEL_REMAINING, 4) &&
           VerifyField<uint16_t>(verifier, VT_AMMO_MAIN, 2) &&
           VerifyField<uint8_t>(verifier, VT_MISSILES_REMAINING, 1) &&
           VerifyField<uint8_t>(verifier, VT_TORPEDOES_REMAINING, 1) &&
           VerifyField<uint8_t>(verifier, VT_VESSEL_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PROPULSION_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct NAVBuilder {
  typedef NAV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITION_X(double POSITION_X) {
    fbb_.AddElement<double>(NAV::VT_POSITION_X, POSITION_X, 0.0);
  }
  void add_POSITION_Y(double POSITION_Y) {
    fbb_.AddElement<double>(NAV::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  void add_POSITION_Z(double POSITION_Z) {
    fbb_.AddElement<double>(NAV::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  void add_VELOCITY_X(double VELOCITY_X) {
    fbb_.AddElement<double>(NAV::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  void add_VELOCITY_Y(double VELOCITY_Y) {
    fbb_.AddElement<double>(NAV::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  void add_VELOCITY_Z(double VELOCITY_Z) {
    fbb_.AddElement<double>(NAV::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  void add_ATTITUDE_X(double ATTITUDE_X) {
    fbb_.AddElement<double>(NAV::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  void add_ATTITUDE_Y(double ATTITUDE_Y) {
    fbb_.AddElement<double>(NAV::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  void add_ATTITUDE_Z(double ATTITUDE_Z) {
    fbb_.AddElement<double>(NAV::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  void add_ATTITUDE_W(double ATTITUDE_W) {
    fbb_.AddElement<double>(NAV::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  void add_OMEGA_X(double OMEGA_X) {
    fbb_.AddElement<double>(NAV::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  void add_OMEGA_Y(double OMEGA_Y) {
    fbb_.AddElement<double>(NAV::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  void add_OMEGA_Z(double OMEGA_Z) {
    fbb_.AddElement<double>(NAV::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  void add_SPEED_KNOTS(float SPEED_KNOTS) {
    fbb_.AddElement<float>(NAV::VT_SPEED_KNOTS, SPEED_KNOTS, 0.0f);
  }
  void add_HEADING(float HEADING) {
    fbb_.AddElement<float>(NAV::VT_HEADING, HEADING, 0.0f);
  }
  void add_COURSE(float COURSE) {
    fbb_.AddElement<float>(NAV::VT_COURSE, COURSE, 0.0f);
  }
  void add_RUDDER_ANGLE(float RUDDER_ANGLE) {
    fbb_.AddElement<float>(NAV::VT_RUDDER_ANGLE, RUDDER_ANGLE, 0.0f);
  }
  void add_HULL(::flatbuffers::Offset<::flatbuffers::String> HULL) {
    fbb_.AddOffset(NAV::VT_HULL, HULL);
  }
  void add_PROPULSION(::flatbuffers::Offset<::flatbuffers::String> PROPULSION) {
    fbb_.AddOffset(NAV::VT_PROPULSION, PROPULSION);
  }
  void add_DC_STATE(uint8_t DC_STATE) {
    fbb_.AddElement<uint8_t>(NAV::VT_DC_STATE, DC_STATE, 0);
  }
  void add_FIRES_ACTIVE(uint8_t FIRES_ACTIVE) {
    fbb_.AddElement<uint8_t>(NAV::VT_FIRES_ACTIVE, FIRES_ACTIVE, 0);
  }
  void add_FLOODING_ACTIVE(uint8_t FLOODING_ACTIVE) {
    fbb_.AddElement<uint8_t>(NAV::VT_FLOODING_ACTIVE, FLOODING_ACTIVE, 0);
  }
  void add_CREW_CASUALTIES(uint8_t CREW_CASUALTIES) {
    fbb_.AddElement<uint8_t>(NAV::VT_CREW_CASUALTIES, CREW_CASUALTIES, 0);
  }
  void add_HULL_INTEGRITY(float HULL_INTEGRITY) {
    fbb_.AddElement<float>(NAV::VT_HULL_INTEGRITY, HULL_INTEGRITY, 0.0f);
  }
  void add_POWER_AVAILABLE(float POWER_AVAILABLE) {
    fbb_.AddElement<float>(NAV::VT_POWER_AVAILABLE, POWER_AVAILABLE, 0.0f);
  }
  void add_WEAPONS_ONLINE(uint8_t WEAPONS_ONLINE) {
    fbb_.AddElement<uint8_t>(NAV::VT_WEAPONS_ONLINE, WEAPONS_ONLINE, 0);
  }
  void add_SENSORS_ONLINE(uint8_t SENSORS_ONLINE) {
    fbb_.AddElement<uint8_t>(NAV::VT_SENSORS_ONLINE, SENSORS_ONLINE, 0);
  }
  void add_RESERVED1(uint16_t RESERVED1) {
    fbb_.AddElement<uint16_t>(NAV::VT_RESERVED1, RESERVED1, 0);
  }
  void add_FUEL_REMAINING(float FUEL_REMAINING) {
    fbb_.AddElement<float>(NAV::VT_FUEL_REMAINING, FUEL_REMAINING, 0.0f);
  }
  void add_AMMO_MAIN(uint16_t AMMO_MAIN) {
    fbb_.AddElement<uint16_t>(NAV::VT_AMMO_MAIN, AMMO_MAIN, 0);
  }
  void add_MISSILES_REMAINING(uint8_t MISSILES_REMAINING) {
    fbb_.AddElement<uint8_t>(NAV::VT_MISSILES_REMAINING, MISSILES_REMAINING, 0);
  }
  void add_TORPEDOES_REMAINING(uint8_t TORPEDOES_REMAINING) {
    fbb_.AddElement<uint8_t>(NAV::VT_TORPEDOES_REMAINING, TORPEDOES_REMAINING, 0);
  }
  void add_VESSEL_TYPE(uint8_t VESSEL_TYPE) {
    fbb_.AddElement<uint8_t>(NAV::VT_VESSEL_TYPE, VESSEL_TYPE, 0);
  }
  void add_PROPULSION_TYPE(uint8_t PROPULSION_TYPE) {
    fbb_.AddElement<uint8_t>(NAV::VT_PROPULSION_TYPE, PROPULSION_TYPE, 0);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(NAV::VT_RESERVED, RESERVED);
  }
  explicit NAVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NAV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NAV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NAV> CreateNAV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    float SPEED_KNOTS = 0.0f,
    float HEADING = 0.0f,
    float COURSE = 0.0f,
    float RUDDER_ANGLE = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> HULL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROPULSION = 0,
    uint8_t DC_STATE = 0,
    uint8_t FIRES_ACTIVE = 0,
    uint8_t FLOODING_ACTIVE = 0,
    uint8_t CREW_CASUALTIES = 0,
    float HULL_INTEGRITY = 0.0f,
    float POWER_AVAILABLE = 0.0f,
    uint8_t WEAPONS_ONLINE = 0,
    uint8_t SENSORS_ONLINE = 0,
    uint16_t RESERVED1 = 0,
    float FUEL_REMAINING = 0.0f,
    uint16_t AMMO_MAIN = 0,
    uint8_t MISSILES_REMAINING = 0,
    uint8_t TORPEDOES_REMAINING = 0,
    uint8_t VESSEL_TYPE = 0,
    uint8_t PROPULSION_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  NAVBuilder builder_(_fbb);
  builder_.add_OMEGA_Z(OMEGA_Z);
  builder_.add_OMEGA_Y(OMEGA_Y);
  builder_.add_OMEGA_X(OMEGA_X);
  builder_.add_ATTITUDE_W(ATTITUDE_W);
  builder_.add_ATTITUDE_Z(ATTITUDE_Z);
  builder_.add_ATTITUDE_Y(ATTITUDE_Y);
  builder_.add_ATTITUDE_X(ATTITUDE_X);
  builder_.add_VELOCITY_Z(VELOCITY_Z);
  builder_.add_VELOCITY_Y(VELOCITY_Y);
  builder_.add_VELOCITY_X(VELOCITY_X);
  builder_.add_POSITION_Z(POSITION_Z);
  builder_.add_POSITION_Y(POSITION_Y);
  builder_.add_POSITION_X(POSITION_X);
  builder_.add_RESERVED(RESERVED);
  builder_.add_FUEL_REMAINING(FUEL_REMAINING);
  builder_.add_POWER_AVAILABLE(POWER_AVAILABLE);
  builder_.add_HULL_INTEGRITY(HULL_INTEGRITY);
  builder_.add_PROPULSION(PROPULSION);
  builder_.add_HULL(HULL);
  builder_.add_RUDDER_ANGLE(RUDDER_ANGLE);
  builder_.add_COURSE(COURSE);
  builder_.add_HEADING(HEADING);
  builder_.add_SPEED_KNOTS(SPEED_KNOTS);
  builder_.add_AMMO_MAIN(AMMO_MAIN);
  builder_.add_RESERVED1(RESERVED1);
  builder_.add_PROPULSION_TYPE(PROPULSION_TYPE);
  builder_.add_VESSEL_TYPE(VESSEL_TYPE);
  builder_.add_TORPEDOES_REMAINING(TORPEDOES_REMAINING);
  builder_.add_MISSILES_REMAINING(MISSILES_REMAINING);
  builder_.add_SENSORS_ONLINE(SENSORS_ONLINE);
  builder_.add_WEAPONS_ONLINE(WEAPONS_ONLINE);
  builder_.add_CREW_CASUALTIES(CREW_CASUALTIES);
  builder_.add_FLOODING_ACTIVE(FLOODING_ACTIVE);
  builder_.add_FIRES_ACTIVE(FIRES_ACTIVE);
  builder_.add_DC_STATE(DC_STATE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NAV> CreateNAVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    float SPEED_KNOTS = 0.0f,
    float HEADING = 0.0f,
    float COURSE = 0.0f,
    float RUDDER_ANGLE = 0.0f,
    const char *HULL = nullptr,
    const char *PROPULSION = nullptr,
    uint8_t DC_STATE = 0,
    uint8_t FIRES_ACTIVE = 0,
    uint8_t FLOODING_ACTIVE = 0,
    uint8_t CREW_CASUALTIES = 0,
    float HULL_INTEGRITY = 0.0f,
    float POWER_AVAILABLE = 0.0f,
    uint8_t WEAPONS_ONLINE = 0,
    uint8_t SENSORS_ONLINE = 0,
    uint16_t RESERVED1 = 0,
    float FUEL_REMAINING = 0.0f,
    uint16_t AMMO_MAIN = 0,
    uint8_t MISSILES_REMAINING = 0,
    uint8_t TORPEDOES_REMAINING = 0,
    uint8_t VESSEL_TYPE = 0,
    uint8_t PROPULSION_TYPE = 0,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto HULL__ = HULL ? _fbb.CreateString(HULL) : 0;
  auto PROPULSION__ = PROPULSION ? _fbb.CreateString(PROPULSION) : 0;
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateNAV(
      _fbb,
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED_KNOTS,
      HEADING,
      COURSE,
      RUDDER_ANGLE,
      HULL__,
      PROPULSION__,
      DC_STATE,
      FIRES_ACTIVE,
      FLOODING_ACTIVE,
      CREW_CASUALTIES,
      HULL_INTEGRITY,
      POWER_AVAILABLE,
      WEAPONS_ONLINE,
      SENSORS_ONLINE,
      RESERVED1,
      FUEL_REMAINING,
      AMMO_MAIN,
      MISSILES_REMAINING,
      TORPEDOES_REMAINING,
      VESSEL_TYPE,
      PROPULSION_TYPE,
      RESERVED__);
}

inline const NAV *GetNAV(const void *buf) {
  return ::flatbuffers::GetRoot<NAV>(buf);
}

inline const NAV *GetSizePrefixedNAV(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NAV>(buf);
}

inline const char *NAVIdentifier() {
  return "$NAV";
}

inline bool NAVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, NAVIdentifier());
}

inline bool SizePrefixedNAVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, NAVIdentifier(), true);
}

inline bool VerifyNAVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NAV>(NAVIdentifier());
}

inline bool VerifySizePrefixedNAVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NAV>(NAVIdentifier());
}

inline void FinishNAVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NAV> root) {
  fbb.Finish(root, NAVIdentifier());
}

inline void FinishSizePrefixedNAVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NAV> root) {
  fbb.FinishSizePrefixed(root, NAVIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
