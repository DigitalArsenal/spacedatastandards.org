// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct IntegerDataEncoding;
struct IntegerDataEncodingBuilder;

struct FloatDataEncoding;
struct FloatDataEncodingBuilder;

struct StringDataEncoding;
struct StringDataEncodingBuilder;

struct BinaryDataEncoding;
struct BinaryDataEncodingBuilder;

struct PolynomialCalibrator;
struct PolynomialCalibratorBuilder;

struct SplinePoint;
struct SplinePointBuilder;

struct SplineCalibrator;
struct SplineCalibratorBuilder;

struct MathOperation;
struct MathOperationBuilder;

struct ContextCalibrator;
struct ContextCalibratorBuilder;

struct AlarmRange;
struct AlarmRangeBuilder;

struct StaticAlarmRanges;
struct StaticAlarmRangesBuilder;

struct EnumerationAlarm;
struct EnumerationAlarmBuilder;

struct DefaultAlarm;
struct DefaultAlarmBuilder;

struct ContextAlarm;
struct ContextAlarmBuilder;

struct ParameterComparison;
struct ParameterComparisonBuilder;

struct BooleanExpression;
struct BooleanExpressionBuilder;

struct MatchCriteria;
struct MatchCriteriaBuilder;

struct Unit;
struct UnitBuilder;

struct EnumerationValue;
struct EnumerationValueBuilder;

struct IntegerParameterType;
struct IntegerParameterTypeBuilder;

struct FloatParameterType;
struct FloatParameterTypeBuilder;

struct StringParameterType;
struct StringParameterTypeBuilder;

struct BooleanParameterType;
struct BooleanParameterTypeBuilder;

struct EnumeratedParameterType;
struct EnumeratedParameterTypeBuilder;

struct BinaryParameterType;
struct BinaryParameterTypeBuilder;

struct AbsoluteTimeParameterType;
struct AbsoluteTimeParameterTypeBuilder;

struct RelativeTimeParameterType;
struct RelativeTimeParameterTypeBuilder;

struct ArrayDimension;
struct ArrayDimensionBuilder;

struct ArrayParameterType;
struct ArrayParameterTypeBuilder;

struct AggregateMember;
struct AggregateMemberBuilder;

struct AggregateParameterType;
struct AggregateParameterTypeBuilder;

struct ParameterTypeSet;
struct ParameterTypeSetBuilder;

struct ParameterProperties;
struct ParameterPropertiesBuilder;

struct Parameter;
struct ParameterBuilder;

struct ParameterSet;
struct ParameterSetBuilder;

struct LocationInContainer;
struct LocationInContainerBuilder;

struct RepeatEntry;
struct RepeatEntryBuilder;

struct ParameterRefEntry;
struct ParameterRefEntryBuilder;

struct ContainerRefEntry;
struct ContainerRefEntryBuilder;

struct FixedValueEntry;
struct FixedValueEntryBuilder;

struct ArrayParameterRefEntry;
struct ArrayParameterRefEntryBuilder;

struct ContainerEntry;
struct ContainerEntryBuilder;

struct BaseContainer;
struct BaseContainerBuilder;

struct RateInStream;
struct RateInStreamBuilder;

struct ContainerBinaryEncoding;
struct ContainerBinaryEncodingBuilder;

struct SequenceContainer;
struct SequenceContainerBuilder;

struct ContainerSet;
struct ContainerSetBuilder;

struct AlgorithmInput;
struct AlgorithmInputBuilder;

struct AlgorithmOutput;
struct AlgorithmOutputBuilder;

struct AlgorithmTrigger;
struct AlgorithmTriggerBuilder;

struct CustomAlgorithm;
struct CustomAlgorithmBuilder;

struct MathAlgorithm;
struct MathAlgorithmBuilder;

struct AlgorithmSet;
struct AlgorithmSetBuilder;

struct IntegerArgumentType;
struct IntegerArgumentTypeBuilder;

struct FloatArgumentType;
struct FloatArgumentTypeBuilder;

struct StringArgumentType;
struct StringArgumentTypeBuilder;

struct BooleanArgumentType;
struct BooleanArgumentTypeBuilder;

struct EnumeratedArgumentType;
struct EnumeratedArgumentTypeBuilder;

struct BinaryArgumentType;
struct BinaryArgumentTypeBuilder;

struct AggregateArgumentType;
struct AggregateArgumentTypeBuilder;

struct ArgumentTypeSet;
struct ArgumentTypeSetBuilder;

struct Argument;
struct ArgumentBuilder;

struct ArgumentRefEntry;
struct ArgumentRefEntryBuilder;

struct CommandContainerEntry;
struct CommandContainerEntryBuilder;

struct CommandContainer;
struct CommandContainerBuilder;

struct CommandVerifier;
struct CommandVerifierBuilder;

struct CommandSignificance;
struct CommandSignificanceBuilder;

struct BaseMetaCommand;
struct BaseMetaCommandBuilder;

struct ArgumentAssignment;
struct ArgumentAssignmentBuilder;

struct Interlock;
struct InterlockBuilder;

struct MetaCommand;
struct MetaCommandBuilder;

struct MetaCommandSet;
struct MetaCommandSetBuilder;

struct FixedFrameStream;
struct FixedFrameStreamBuilder;

struct VariableFrameStream;
struct VariableFrameStreamBuilder;

struct CustomStream;
struct CustomStreamBuilder;

struct StreamSet;
struct StreamSetBuilder;

struct Service;
struct ServiceBuilder;

struct ServiceSet;
struct ServiceSetBuilder;

struct XTCHeader;
struct XTCHeaderBuilder;

struct TelemetryMetaData;
struct TelemetryMetaDataBuilder;

struct CommandMetaData;
struct CommandMetaDataBuilder;

struct XTC;
struct XTCBuilder;

/// Comparison operators for match criteria and conditions
enum ComparisonOperator : int8_t {
  /// Equal to
  ComparisonOperator_EQ = 0,
  /// Not equal to
  ComparisonOperator_NE = 1,
  /// Greater than
  ComparisonOperator_GT = 2,
  /// Less than
  ComparisonOperator_LT = 3,
  /// Greater than or equal to
  ComparisonOperator_GE = 4,
  /// Less than or equal to
  ComparisonOperator_LE = 5,
  /// String starts with
  ComparisonOperator_STARTS_WITH = 6,
  /// String ends with
  ComparisonOperator_ENDS_WITH = 7,
  /// String contains
  ComparisonOperator_CONTAINS = 8,
  /// String does not start with
  ComparisonOperator_NOT_STARTS_WITH = 9,
  /// String does not end with
  ComparisonOperator_NOT_ENDS_WITH = 10,
  /// String does not contain
  ComparisonOperator_NOT_CONTAINS = 11,
  ComparisonOperator_MIN = ComparisonOperator_EQ,
  ComparisonOperator_MAX = ComparisonOperator_NOT_CONTAINS
};

inline const ComparisonOperator (&EnumValuesComparisonOperator())[12] {
  static const ComparisonOperator values[] = {
    ComparisonOperator_EQ,
    ComparisonOperator_NE,
    ComparisonOperator_GT,
    ComparisonOperator_LT,
    ComparisonOperator_GE,
    ComparisonOperator_LE,
    ComparisonOperator_STARTS_WITH,
    ComparisonOperator_ENDS_WITH,
    ComparisonOperator_CONTAINS,
    ComparisonOperator_NOT_STARTS_WITH,
    ComparisonOperator_NOT_ENDS_WITH,
    ComparisonOperator_NOT_CONTAINS
  };
  return values;
}

inline const char * const *EnumNamesComparisonOperator() {
  static const char * const names[13] = {
    "EQ",
    "NE",
    "GT",
    "LT",
    "GE",
    "LE",
    "STARTS_WITH",
    "ENDS_WITH",
    "CONTAINS",
    "NOT_STARTS_WITH",
    "NOT_ENDS_WITH",
    "NOT_CONTAINS",
    nullptr
  };
  return names;
}

inline const char *EnumNameComparisonOperator(ComparisonOperator e) {
  if (::flatbuffers::IsOutRange(e, ComparisonOperator_EQ, ComparisonOperator_NOT_CONTAINS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComparisonOperator()[index];
}

/// Data source types for telemetry parameters
enum DataSourceType : int8_t {
  /// Data received from spacecraft telemetry
  DataSourceType_TELEMETERED = 0,
  /// Computed from other parameters
  DataSourceType_DERIVED = 1,
  /// Fixed constant value
  DataSourceType_CONSTANT = 2,
  /// Local ground system value
  DataSourceType_LOCAL = 3,
  /// Ground-generated data
  DataSourceType_GROUND = 4,
  DataSourceType_MIN = DataSourceType_TELEMETERED,
  DataSourceType_MAX = DataSourceType_GROUND
};

inline const DataSourceType (&EnumValuesDataSourceType())[5] {
  static const DataSourceType values[] = {
    DataSourceType_TELEMETERED,
    DataSourceType_DERIVED,
    DataSourceType_CONSTANT,
    DataSourceType_LOCAL,
    DataSourceType_GROUND
  };
  return values;
}

inline const char * const *EnumNamesDataSourceType() {
  static const char * const names[6] = {
    "TELEMETERED",
    "DERIVED",
    "CONSTANT",
    "LOCAL",
    "GROUND",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataSourceType(DataSourceType e) {
  if (::flatbuffers::IsOutRange(e, DataSourceType_TELEMETERED, DataSourceType_GROUND)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataSourceType()[index];
}

/// Boolean operators for combining conditions
enum BooleanOperatorType : int8_t {
  /// Logical AND
  BooleanOperatorType_AND = 0,
  /// Logical OR
  BooleanOperatorType_OR = 1,
  /// Logical XOR
  BooleanOperatorType_XOR = 2,
  BooleanOperatorType_MIN = BooleanOperatorType_AND,
  BooleanOperatorType_MAX = BooleanOperatorType_XOR
};

inline const BooleanOperatorType (&EnumValuesBooleanOperatorType())[3] {
  static const BooleanOperatorType values[] = {
    BooleanOperatorType_AND,
    BooleanOperatorType_OR,
    BooleanOperatorType_XOR
  };
  return values;
}

inline const char * const *EnumNamesBooleanOperatorType() {
  static const char * const names[4] = {
    "AND",
    "OR",
    "XOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameBooleanOperatorType(BooleanOperatorType e) {
  if (::flatbuffers::IsOutRange(e, BooleanOperatorType_AND, BooleanOperatorType_XOR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBooleanOperatorType()[index];
}

/// Reference location for positioning within containers
enum ReferenceLocationType : int8_t {
  /// Start of the container
  ReferenceLocationType_CONTAINER_START = 0,
  /// End of the container
  ReferenceLocationType_CONTAINER_END = 1,
  /// End of previous entry
  ReferenceLocationType_PREVIOUS_ENTRY = 2,
  /// Start of next entry
  ReferenceLocationType_NEXT_ENTRY = 3,
  ReferenceLocationType_MIN = ReferenceLocationType_CONTAINER_START,
  ReferenceLocationType_MAX = ReferenceLocationType_NEXT_ENTRY
};

inline const ReferenceLocationType (&EnumValuesReferenceLocationType())[4] {
  static const ReferenceLocationType values[] = {
    ReferenceLocationType_CONTAINER_START,
    ReferenceLocationType_CONTAINER_END,
    ReferenceLocationType_PREVIOUS_ENTRY,
    ReferenceLocationType_NEXT_ENTRY
  };
  return values;
}

inline const char * const *EnumNamesReferenceLocationType() {
  static const char * const names[5] = {
    "CONTAINER_START",
    "CONTAINER_END",
    "PREVIOUS_ENTRY",
    "NEXT_ENTRY",
    nullptr
  };
  return names;
}

inline const char *EnumNameReferenceLocationType(ReferenceLocationType e) {
  if (::flatbuffers::IsOutRange(e, ReferenceLocationType_CONTAINER_START, ReferenceLocationType_NEXT_ENTRY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReferenceLocationType()[index];
}

/// Rate basis for stream rate specifications
enum RateBasisType : int8_t {
  /// Rate per second
  RateBasisType_PER_SECOND = 0,
  /// Rate per container occurrence
  RateBasisType_PER_CONTAINER = 1,
  RateBasisType_MIN = RateBasisType_PER_SECOND,
  RateBasisType_MAX = RateBasisType_PER_CONTAINER
};

inline const RateBasisType (&EnumValuesRateBasisType())[2] {
  static const RateBasisType values[] = {
    RateBasisType_PER_SECOND,
    RateBasisType_PER_CONTAINER
  };
  return values;
}

inline const char * const *EnumNamesRateBasisType() {
  static const char * const names[3] = {
    "PER_SECOND",
    "PER_CONTAINER",
    nullptr
  };
  return names;
}

inline const char *EnumNameRateBasisType(RateBasisType e) {
  if (::flatbuffers::IsOutRange(e, RateBasisType_PER_SECOND, RateBasisType_PER_CONTAINER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRateBasisType()[index];
}

/// Byte ordering for data encoding
enum ByteOrderType : int8_t {
  /// Most significant byte first
  ByteOrderType_BIG_ENDIAN = 0,
  /// Least significant byte first
  ByteOrderType_LITTLE_ENDIAN = 1,
  ByteOrderType_MIN = ByteOrderType_BIG_ENDIAN,
  ByteOrderType_MAX = ByteOrderType_LITTLE_ENDIAN
};

inline const ByteOrderType (&EnumValuesByteOrderType())[2] {
  static const ByteOrderType values[] = {
    ByteOrderType_BIG_ENDIAN,
    ByteOrderType_LITTLE_ENDIAN
  };
  return values;
}

inline const char * const *EnumNamesByteOrderType() {
  static const char * const names[3] = {
    "BIG_ENDIAN",
    "LITTLE_ENDIAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameByteOrderType(ByteOrderType e) {
  if (::flatbuffers::IsOutRange(e, ByteOrderType_BIG_ENDIAN, ByteOrderType_LITTLE_ENDIAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesByteOrderType()[index];
}

/// Integer encoding types
enum IntegerEncodingType : int8_t {
  /// Unsigned binary
  IntegerEncodingType_UNSIGNED = 0,
  /// Two's complement signed
  IntegerEncodingType_TWOS_COMPLEMENT = 1,
  /// Sign-magnitude representation
  IntegerEncodingType_SIGN_MAGNITUDE = 2,
  /// Ones' complement signed
  IntegerEncodingType_ONES_COMPLEMENT = 3,
  /// Binary Coded Decimal
  IntegerEncodingType_BCD = 4,
  /// Packed BCD
  IntegerEncodingType_PACKED_BCD = 5,
  IntegerEncodingType_MIN = IntegerEncodingType_UNSIGNED,
  IntegerEncodingType_MAX = IntegerEncodingType_PACKED_BCD
};

inline const IntegerEncodingType (&EnumValuesIntegerEncodingType())[6] {
  static const IntegerEncodingType values[] = {
    IntegerEncodingType_UNSIGNED,
    IntegerEncodingType_TWOS_COMPLEMENT,
    IntegerEncodingType_SIGN_MAGNITUDE,
    IntegerEncodingType_ONES_COMPLEMENT,
    IntegerEncodingType_BCD,
    IntegerEncodingType_PACKED_BCD
  };
  return values;
}

inline const char * const *EnumNamesIntegerEncodingType() {
  static const char * const names[7] = {
    "UNSIGNED",
    "TWOS_COMPLEMENT",
    "SIGN_MAGNITUDE",
    "ONES_COMPLEMENT",
    "BCD",
    "PACKED_BCD",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntegerEncodingType(IntegerEncodingType e) {
  if (::flatbuffers::IsOutRange(e, IntegerEncodingType_UNSIGNED, IntegerEncodingType_PACKED_BCD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntegerEncodingType()[index];
}

/// Float encoding formats
enum FloatEncodingType : int8_t {
  /// IEEE 754-1985 single precision (32-bit)
  FloatEncodingType_IEEE754_1985 = 0,
  /// MIL-STD-1750A format
  FloatEncodingType_MILSTD_1750A = 1,
  /// DEC PDP format
  FloatEncodingType_DEC = 2,
  /// IBM System/360 format
  FloatEncodingType_IBM = 3,
  /// Texas Instruments TI format
  FloatEncodingType_TI = 4,
  FloatEncodingType_MIN = FloatEncodingType_IEEE754_1985,
  FloatEncodingType_MAX = FloatEncodingType_TI
};

inline const FloatEncodingType (&EnumValuesFloatEncodingType())[5] {
  static const FloatEncodingType values[] = {
    FloatEncodingType_IEEE754_1985,
    FloatEncodingType_MILSTD_1750A,
    FloatEncodingType_DEC,
    FloatEncodingType_IBM,
    FloatEncodingType_TI
  };
  return values;
}

inline const char * const *EnumNamesFloatEncodingType() {
  static const char * const names[6] = {
    "IEEE754_1985",
    "MILSTD_1750A",
    "DEC",
    "IBM",
    "TI",
    nullptr
  };
  return names;
}

inline const char *EnumNameFloatEncodingType(FloatEncodingType e) {
  if (::flatbuffers::IsOutRange(e, FloatEncodingType_IEEE754_1985, FloatEncodingType_TI)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFloatEncodingType()[index];
}

/// String encoding character sets
enum StringEncodingType : int8_t {
  /// US-ASCII (7-bit)
  StringEncodingType_US_ASCII = 0,
  /// ISO 8859-1 Latin-1
  StringEncodingType_ISO_8859_1 = 1,
  /// Windows-1252
  StringEncodingType_WINDOWS_1252 = 2,
  /// UTF-8
  StringEncodingType_UTF_8 = 3,
  /// UTF-16
  StringEncodingType_UTF_16 = 4,
  /// UTF-16 Big Endian
  StringEncodingType_UTF_16BE = 5,
  /// UTF-16 Little Endian
  StringEncodingType_UTF_16LE = 6,
  StringEncodingType_MIN = StringEncodingType_US_ASCII,
  StringEncodingType_MAX = StringEncodingType_UTF_16LE
};

inline const StringEncodingType (&EnumValuesStringEncodingType())[7] {
  static const StringEncodingType values[] = {
    StringEncodingType_US_ASCII,
    StringEncodingType_ISO_8859_1,
    StringEncodingType_WINDOWS_1252,
    StringEncodingType_UTF_8,
    StringEncodingType_UTF_16,
    StringEncodingType_UTF_16BE,
    StringEncodingType_UTF_16LE
  };
  return values;
}

inline const char * const *EnumNamesStringEncodingType() {
  static const char * const names[8] = {
    "US_ASCII",
    "ISO_8859_1",
    "WINDOWS_1252",
    "UTF_8",
    "UTF_16",
    "UTF_16BE",
    "UTF_16LE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStringEncodingType(StringEncodingType e) {
  if (::flatbuffers::IsOutRange(e, StringEncodingType_US_ASCII, StringEncodingType_UTF_16LE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStringEncodingType()[index];
}

/// String size specification type
enum StringSizeType : int8_t {
  /// Fixed length string
  StringSizeType_FIXED = 0,
  /// Variable with leading count
  StringSizeType_LEADING_SIZE = 1,
  /// Variable with termination character
  StringSizeType_TERMINATION_CHAR = 2,
  StringSizeType_MIN = StringSizeType_FIXED,
  StringSizeType_MAX = StringSizeType_TERMINATION_CHAR
};

inline const StringSizeType (&EnumValuesStringSizeType())[3] {
  static const StringSizeType values[] = {
    StringSizeType_FIXED,
    StringSizeType_LEADING_SIZE,
    StringSizeType_TERMINATION_CHAR
  };
  return values;
}

inline const char * const *EnumNamesStringSizeType() {
  static const char * const names[4] = {
    "FIXED",
    "LEADING_SIZE",
    "TERMINATION_CHAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameStringSizeType(StringSizeType e) {
  if (::flatbuffers::IsOutRange(e, StringSizeType_FIXED, StringSizeType_TERMINATION_CHAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStringSizeType()[index];
}

/// Alarm severity levels
enum AlarmSeverityType : int8_t {
  /// Normal operation
  AlarmSeverityType_NORMAL = 0,
  /// Watch level - early warning
  AlarmSeverityType_WATCH = 1,
  /// Warning level
  AlarmSeverityType_WARNING = 2,
  /// Distress level - significant issue
  AlarmSeverityType_DISTRESS = 3,
  /// Critical level - immediate action required
  AlarmSeverityType_CRITICAL = 4,
  /// Severe level - system failure
  AlarmSeverityType_SEVERE = 5,
  AlarmSeverityType_MIN = AlarmSeverityType_NORMAL,
  AlarmSeverityType_MAX = AlarmSeverityType_SEVERE
};

inline const AlarmSeverityType (&EnumValuesAlarmSeverityType())[6] {
  static const AlarmSeverityType values[] = {
    AlarmSeverityType_NORMAL,
    AlarmSeverityType_WATCH,
    AlarmSeverityType_WARNING,
    AlarmSeverityType_DISTRESS,
    AlarmSeverityType_CRITICAL,
    AlarmSeverityType_SEVERE
  };
  return values;
}

inline const char * const *EnumNamesAlarmSeverityType() {
  static const char * const names[7] = {
    "NORMAL",
    "WATCH",
    "WARNING",
    "DISTRESS",
    "CRITICAL",
    "SEVERE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAlarmSeverityType(AlarmSeverityType e) {
  if (::flatbuffers::IsOutRange(e, AlarmSeverityType_NORMAL, AlarmSeverityType_SEVERE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAlarmSeverityType()[index];
}

/// Verifier type for command verification
enum VerifierType : int8_t {
  /// Execution started
  VerifierType_START = 0,
  /// Progress update
  VerifierType_PROGRESS = 1,
  /// Execution complete
  VerifierType_COMPLETE = 2,
  /// Command failed
  VerifierType_FAILED = 3,
  VerifierType_MIN = VerifierType_START,
  VerifierType_MAX = VerifierType_FAILED
};

inline const VerifierType (&EnumValuesVerifierType())[4] {
  static const VerifierType values[] = {
    VerifierType_START,
    VerifierType_PROGRESS,
    VerifierType_COMPLETE,
    VerifierType_FAILED
  };
  return values;
}

inline const char * const *EnumNamesVerifierType() {
  static const char * const names[5] = {
    "START",
    "PROGRESS",
    "COMPLETE",
    "FAILED",
    nullptr
  };
  return names;
}

inline const char *EnumNameVerifierType(VerifierType e) {
  if (::flatbuffers::IsOutRange(e, VerifierType_START, VerifierType_FAILED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVerifierType()[index];
}

/// Time window reference for command verification
enum TimeWindowRefType : int8_t {
  /// Relative to command release time
  TimeWindowRefType_COMMAND_RELEASE = 0,
  /// Relative to last verifier passed
  TimeWindowRefType_TIME_LAST_VERIFIER_PASSED = 1,
  TimeWindowRefType_MIN = TimeWindowRefType_COMMAND_RELEASE,
  TimeWindowRefType_MAX = TimeWindowRefType_TIME_LAST_VERIFIER_PASSED
};

inline const TimeWindowRefType (&EnumValuesTimeWindowRefType())[2] {
  static const TimeWindowRefType values[] = {
    TimeWindowRefType_COMMAND_RELEASE,
    TimeWindowRefType_TIME_LAST_VERIFIER_PASSED
  };
  return values;
}

inline const char * const *EnumNamesTimeWindowRefType() {
  static const char * const names[3] = {
    "COMMAND_RELEASE",
    "TIME_LAST_VERIFIER_PASSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeWindowRefType(TimeWindowRefType e) {
  if (::flatbuffers::IsOutRange(e, TimeWindowRefType_COMMAND_RELEASE, TimeWindowRefType_TIME_LAST_VERIFIER_PASSED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeWindowRefType()[index];
}

/// Epoch reference for absolute time
enum EpochType : int8_t {
  /// TAI epoch (1958-01-01)
  EpochType_TAI = 0,
  /// J2000 epoch (2000-01-01 12:00:00 TT)
  EpochType_J2000 = 1,
  /// Unix epoch (1970-01-01)
  EpochType_UNIX = 2,
  /// GPS epoch (1980-01-06)
  EpochType_GPS = 3,
  /// Custom epoch specified in offset
  EpochType_CUSTOM = 4,
  EpochType_MIN = EpochType_TAI,
  EpochType_MAX = EpochType_CUSTOM
};

inline const EpochType (&EnumValuesEpochType())[5] {
  static const EpochType values[] = {
    EpochType_TAI,
    EpochType_J2000,
    EpochType_UNIX,
    EpochType_GPS,
    EpochType_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesEpochType() {
  static const char * const names[6] = {
    "TAI",
    "J2000",
    "UNIX",
    "GPS",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameEpochType(EpochType e) {
  if (::flatbuffers::IsOutRange(e, EpochType_TAI, EpochType_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEpochType()[index];
}

/// Error detection/correction algorithms
enum ErrorDetectionType : int8_t {
  /// No error detection
  ErrorDetectionType_NONE = 0,
  /// Cyclic redundancy check
  ErrorDetectionType_CRC = 1,
  /// Checksum
  ErrorDetectionType_CHECKSUM = 2,
  /// Parity
  ErrorDetectionType_PARITY = 3,
  ErrorDetectionType_MIN = ErrorDetectionType_NONE,
  ErrorDetectionType_MAX = ErrorDetectionType_PARITY
};

inline const ErrorDetectionType (&EnumValuesErrorDetectionType())[4] {
  static const ErrorDetectionType values[] = {
    ErrorDetectionType_NONE,
    ErrorDetectionType_CRC,
    ErrorDetectionType_CHECKSUM,
    ErrorDetectionType_PARITY
  };
  return values;
}

inline const char * const *EnumNamesErrorDetectionType() {
  static const char * const names[5] = {
    "NONE",
    "CRC",
    "CHECKSUM",
    "PARITY",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorDetectionType(ErrorDetectionType e) {
  if (::flatbuffers::IsOutRange(e, ErrorDetectionType_NONE, ErrorDetectionType_PARITY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorDetectionType()[index];
}

/// Integer data encoding specification
struct IntegerDataEncoding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerDataEncodingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE_IN_BITS = 4,
    VT_BYTE_ORDER = 6,
    VT_ENCODING = 8,
    VT_DEFAULT_CALIBRATOR = 10,
    VT_CONTEXT_CALIBRATOR_LIST = 12
  };
  /// Number of bits for this integer
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Byte ordering
  ByteOrderType BYTE_ORDER() const {
    return static_cast<ByteOrderType>(GetField<int8_t>(VT_BYTE_ORDER, 0));
  }
  /// Integer encoding type
  IntegerEncodingType ENCODING() const {
    return static_cast<IntegerEncodingType>(GetField<int8_t>(VT_ENCODING, 0));
  }
  /// Default calibrator reference
  const ::flatbuffers::String *DEFAULT_CALIBRATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEFAULT_CALIBRATOR);
  }
  /// Context-dependent calibrators
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>> *CONTEXT_CALIBRATOR_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>> *>(VT_CONTEXT_CALIBRATOR_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<int8_t>(verifier, VT_BYTE_ORDER, 1) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, 1) &&
           VerifyOffset(verifier, VT_DEFAULT_CALIBRATOR) &&
           verifier.VerifyString(DEFAULT_CALIBRATOR()) &&
           VerifyOffset(verifier, VT_CONTEXT_CALIBRATOR_LIST) &&
           verifier.VerifyVector(CONTEXT_CALIBRATOR_LIST()) &&
           verifier.VerifyVectorOfTables(CONTEXT_CALIBRATOR_LIST()) &&
           verifier.EndTable();
  }
};

struct IntegerDataEncodingBuilder {
  typedef IntegerDataEncoding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(IntegerDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_BYTE_ORDER(ByteOrderType BYTE_ORDER) {
    fbb_.AddElement<int8_t>(IntegerDataEncoding::VT_BYTE_ORDER, static_cast<int8_t>(BYTE_ORDER), 0);
  }
  void add_ENCODING(IntegerEncodingType ENCODING) {
    fbb_.AddElement<int8_t>(IntegerDataEncoding::VT_ENCODING, static_cast<int8_t>(ENCODING), 0);
  }
  void add_DEFAULT_CALIBRATOR(::flatbuffers::Offset<::flatbuffers::String> DEFAULT_CALIBRATOR) {
    fbb_.AddOffset(IntegerDataEncoding::VT_DEFAULT_CALIBRATOR, DEFAULT_CALIBRATOR);
  }
  void add_CONTEXT_CALIBRATOR_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>>> CONTEXT_CALIBRATOR_LIST) {
    fbb_.AddOffset(IntegerDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, CONTEXT_CALIBRATOR_LIST);
  }
  explicit IntegerDataEncodingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerDataEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerDataEncoding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerDataEncoding> CreateIntegerDataEncoding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t SIZE_IN_BITS = 0,
    ByteOrderType BYTE_ORDER = ByteOrderType_BIG_ENDIAN,
    IntegerEncodingType ENCODING = IntegerEncodingType_UNSIGNED,
    ::flatbuffers::Offset<::flatbuffers::String> DEFAULT_CALIBRATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>>> CONTEXT_CALIBRATOR_LIST = 0) {
  IntegerDataEncodingBuilder builder_(_fbb);
  builder_.add_CONTEXT_CALIBRATOR_LIST(CONTEXT_CALIBRATOR_LIST);
  builder_.add_DEFAULT_CALIBRATOR(DEFAULT_CALIBRATOR);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_ENCODING(ENCODING);
  builder_.add_BYTE_ORDER(BYTE_ORDER);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntegerDataEncoding> CreateIntegerDataEncodingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t SIZE_IN_BITS = 0,
    ByteOrderType BYTE_ORDER = ByteOrderType_BIG_ENDIAN,
    IntegerEncodingType ENCODING = IntegerEncodingType_UNSIGNED,
    const char *DEFAULT_CALIBRATOR = nullptr,
    const std::vector<::flatbuffers::Offset<ContextCalibrator>> *CONTEXT_CALIBRATOR_LIST = nullptr) {
  auto DEFAULT_CALIBRATOR__ = DEFAULT_CALIBRATOR ? _fbb.CreateString(DEFAULT_CALIBRATOR) : 0;
  auto CONTEXT_CALIBRATOR_LIST__ = CONTEXT_CALIBRATOR_LIST ? _fbb.CreateVector<::flatbuffers::Offset<ContextCalibrator>>(*CONTEXT_CALIBRATOR_LIST) : 0;
  return CreateIntegerDataEncoding(
      _fbb,
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR__,
      CONTEXT_CALIBRATOR_LIST__);
}

/// Float data encoding specification
struct FloatDataEncoding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatDataEncodingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE_IN_BITS = 4,
    VT_BYTE_ORDER = 6,
    VT_ENCODING = 8,
    VT_DEFAULT_CALIBRATOR = 10,
    VT_CONTEXT_CALIBRATOR_LIST = 12
  };
  /// Number of bits (typically 32 or 64)
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Byte ordering
  ByteOrderType BYTE_ORDER() const {
    return static_cast<ByteOrderType>(GetField<int8_t>(VT_BYTE_ORDER, 0));
  }
  /// Float encoding format
  FloatEncodingType ENCODING() const {
    return static_cast<FloatEncodingType>(GetField<int8_t>(VT_ENCODING, 0));
  }
  /// Default calibrator reference
  const ::flatbuffers::String *DEFAULT_CALIBRATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEFAULT_CALIBRATOR);
  }
  /// Context-dependent calibrators
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>> *CONTEXT_CALIBRATOR_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>> *>(VT_CONTEXT_CALIBRATOR_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<int8_t>(verifier, VT_BYTE_ORDER, 1) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, 1) &&
           VerifyOffset(verifier, VT_DEFAULT_CALIBRATOR) &&
           verifier.VerifyString(DEFAULT_CALIBRATOR()) &&
           VerifyOffset(verifier, VT_CONTEXT_CALIBRATOR_LIST) &&
           verifier.VerifyVector(CONTEXT_CALIBRATOR_LIST()) &&
           verifier.VerifyVectorOfTables(CONTEXT_CALIBRATOR_LIST()) &&
           verifier.EndTable();
  }
};

struct FloatDataEncodingBuilder {
  typedef FloatDataEncoding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(FloatDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_BYTE_ORDER(ByteOrderType BYTE_ORDER) {
    fbb_.AddElement<int8_t>(FloatDataEncoding::VT_BYTE_ORDER, static_cast<int8_t>(BYTE_ORDER), 0);
  }
  void add_ENCODING(FloatEncodingType ENCODING) {
    fbb_.AddElement<int8_t>(FloatDataEncoding::VT_ENCODING, static_cast<int8_t>(ENCODING), 0);
  }
  void add_DEFAULT_CALIBRATOR(::flatbuffers::Offset<::flatbuffers::String> DEFAULT_CALIBRATOR) {
    fbb_.AddOffset(FloatDataEncoding::VT_DEFAULT_CALIBRATOR, DEFAULT_CALIBRATOR);
  }
  void add_CONTEXT_CALIBRATOR_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>>> CONTEXT_CALIBRATOR_LIST) {
    fbb_.AddOffset(FloatDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, CONTEXT_CALIBRATOR_LIST);
  }
  explicit FloatDataEncodingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatDataEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatDataEncoding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatDataEncoding> CreateFloatDataEncoding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t SIZE_IN_BITS = 0,
    ByteOrderType BYTE_ORDER = ByteOrderType_BIG_ENDIAN,
    FloatEncodingType ENCODING = FloatEncodingType_IEEE754_1985,
    ::flatbuffers::Offset<::flatbuffers::String> DEFAULT_CALIBRATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextCalibrator>>> CONTEXT_CALIBRATOR_LIST = 0) {
  FloatDataEncodingBuilder builder_(_fbb);
  builder_.add_CONTEXT_CALIBRATOR_LIST(CONTEXT_CALIBRATOR_LIST);
  builder_.add_DEFAULT_CALIBRATOR(DEFAULT_CALIBRATOR);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_ENCODING(ENCODING);
  builder_.add_BYTE_ORDER(BYTE_ORDER);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatDataEncoding> CreateFloatDataEncodingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t SIZE_IN_BITS = 0,
    ByteOrderType BYTE_ORDER = ByteOrderType_BIG_ENDIAN,
    FloatEncodingType ENCODING = FloatEncodingType_IEEE754_1985,
    const char *DEFAULT_CALIBRATOR = nullptr,
    const std::vector<::flatbuffers::Offset<ContextCalibrator>> *CONTEXT_CALIBRATOR_LIST = nullptr) {
  auto DEFAULT_CALIBRATOR__ = DEFAULT_CALIBRATOR ? _fbb.CreateString(DEFAULT_CALIBRATOR) : 0;
  auto CONTEXT_CALIBRATOR_LIST__ = CONTEXT_CALIBRATOR_LIST ? _fbb.CreateVector<::flatbuffers::Offset<ContextCalibrator>>(*CONTEXT_CALIBRATOR_LIST) : 0;
  return CreateFloatDataEncoding(
      _fbb,
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR__,
      CONTEXT_CALIBRATOR_LIST__);
}

/// String data encoding specification
struct StringDataEncoding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringDataEncodingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCODING = 4,
    VT_SIZE_TYPE = 6,
    VT_SIZE_IN_BITS = 8,
    VT_TERMINATION_CHAR = 10,
    VT_MAX_SIZE_IN_BITS = 12,
    VT_LEADING_SIZE_BITS = 14
  };
  /// Character encoding
  StringEncodingType ENCODING() const {
    return static_cast<StringEncodingType>(GetField<int8_t>(VT_ENCODING, 3));
  }
  /// Size type specification
  StringSizeType SIZE_TYPE() const {
    return static_cast<StringSizeType>(GetField<int8_t>(VT_SIZE_TYPE, 0));
  }
  /// Fixed size in bits (when SIZE_TYPE=FIXED)
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Termination character (when SIZE_TYPE=TERMINATION_CHAR)
  uint8_t TERMINATION_CHAR() const {
    return GetField<uint8_t>(VT_TERMINATION_CHAR, 0);
  }
  /// Maximum size in bits (for variable length)
  uint16_t MAX_SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_MAX_SIZE_IN_BITS, 0);
  }
  /// Leading size field bits (when SIZE_TYPE=LEADING_SIZE)
  uint8_t LEADING_SIZE_BITS() const {
    return GetField<uint8_t>(VT_LEADING_SIZE_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ENCODING, 1) &&
           VerifyField<int8_t>(verifier, VT_SIZE_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<uint8_t>(verifier, VT_TERMINATION_CHAR, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_SIZE_IN_BITS, 2) &&
           VerifyField<uint8_t>(verifier, VT_LEADING_SIZE_BITS, 1) &&
           verifier.EndTable();
  }
};

struct StringDataEncodingBuilder {
  typedef StringDataEncoding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ENCODING(StringEncodingType ENCODING) {
    fbb_.AddElement<int8_t>(StringDataEncoding::VT_ENCODING, static_cast<int8_t>(ENCODING), 3);
  }
  void add_SIZE_TYPE(StringSizeType SIZE_TYPE) {
    fbb_.AddElement<int8_t>(StringDataEncoding::VT_SIZE_TYPE, static_cast<int8_t>(SIZE_TYPE), 0);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(StringDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_TERMINATION_CHAR(uint8_t TERMINATION_CHAR) {
    fbb_.AddElement<uint8_t>(StringDataEncoding::VT_TERMINATION_CHAR, TERMINATION_CHAR, 0);
  }
  void add_MAX_SIZE_IN_BITS(uint16_t MAX_SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(StringDataEncoding::VT_MAX_SIZE_IN_BITS, MAX_SIZE_IN_BITS, 0);
  }
  void add_LEADING_SIZE_BITS(uint8_t LEADING_SIZE_BITS) {
    fbb_.AddElement<uint8_t>(StringDataEncoding::VT_LEADING_SIZE_BITS, LEADING_SIZE_BITS, 0);
  }
  explicit StringDataEncodingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringDataEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringDataEncoding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringDataEncoding> CreateStringDataEncoding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    StringEncodingType ENCODING = StringEncodingType_UTF_8,
    StringSizeType SIZE_TYPE = StringSizeType_FIXED,
    uint16_t SIZE_IN_BITS = 0,
    uint8_t TERMINATION_CHAR = 0,
    uint16_t MAX_SIZE_IN_BITS = 0,
    uint8_t LEADING_SIZE_BITS = 0) {
  StringDataEncodingBuilder builder_(_fbb);
  builder_.add_MAX_SIZE_IN_BITS(MAX_SIZE_IN_BITS);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_LEADING_SIZE_BITS(LEADING_SIZE_BITS);
  builder_.add_TERMINATION_CHAR(TERMINATION_CHAR);
  builder_.add_SIZE_TYPE(SIZE_TYPE);
  builder_.add_ENCODING(ENCODING);
  return builder_.Finish();
}

/// Binary data encoding specification
struct BinaryDataEncoding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryDataEncodingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE_IN_BITS = 4,
    VT_MAX_SIZE_IN_BITS = 6,
    VT_LEADING_SIZE_BITS = 8
  };
  /// Fixed size in bits
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Maximum size in bits (for variable length)
  uint16_t MAX_SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_MAX_SIZE_IN_BITS, 0);
  }
  /// Leading size field bits (for variable length)
  uint8_t LEADING_SIZE_BITS() const {
    return GetField<uint8_t>(VT_LEADING_SIZE_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<uint16_t>(verifier, VT_MAX_SIZE_IN_BITS, 2) &&
           VerifyField<uint8_t>(verifier, VT_LEADING_SIZE_BITS, 1) &&
           verifier.EndTable();
  }
};

struct BinaryDataEncodingBuilder {
  typedef BinaryDataEncoding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(BinaryDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_MAX_SIZE_IN_BITS(uint16_t MAX_SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(BinaryDataEncoding::VT_MAX_SIZE_IN_BITS, MAX_SIZE_IN_BITS, 0);
  }
  void add_LEADING_SIZE_BITS(uint8_t LEADING_SIZE_BITS) {
    fbb_.AddElement<uint8_t>(BinaryDataEncoding::VT_LEADING_SIZE_BITS, LEADING_SIZE_BITS, 0);
  }
  explicit BinaryDataEncodingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryDataEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryDataEncoding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryDataEncoding> CreateBinaryDataEncoding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t SIZE_IN_BITS = 0,
    uint16_t MAX_SIZE_IN_BITS = 0,
    uint8_t LEADING_SIZE_BITS = 0) {
  BinaryDataEncodingBuilder builder_(_fbb);
  builder_.add_MAX_SIZE_IN_BITS(MAX_SIZE_IN_BITS);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_LEADING_SIZE_BITS(LEADING_SIZE_BITS);
  return builder_.Finish();
}

/// Polynomial calibrator - converts raw to engineering using polynomial
struct PolynomialCalibrator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PolynomialCalibratorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COEFFICIENTS = 4
  };
  /// Polynomial terms (index is power, value is coefficient)
  const ::flatbuffers::Vector<double> *COEFFICIENTS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_COEFFICIENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COEFFICIENTS) &&
           verifier.VerifyVector(COEFFICIENTS()) &&
           verifier.EndTable();
  }
};

struct PolynomialCalibratorBuilder {
  typedef PolynomialCalibrator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COEFFICIENTS(::flatbuffers::Offset<::flatbuffers::Vector<double>> COEFFICIENTS) {
    fbb_.AddOffset(PolynomialCalibrator::VT_COEFFICIENTS, COEFFICIENTS);
  }
  explicit PolynomialCalibratorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PolynomialCalibrator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PolynomialCalibrator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PolynomialCalibrator> CreatePolynomialCalibrator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> COEFFICIENTS = 0) {
  PolynomialCalibratorBuilder builder_(_fbb);
  builder_.add_COEFFICIENTS(COEFFICIENTS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PolynomialCalibrator> CreatePolynomialCalibratorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *COEFFICIENTS = nullptr) {
  auto COEFFICIENTS__ = COEFFICIENTS ? _fbb.CreateVector<double>(*COEFFICIENTS) : 0;
  return CreatePolynomialCalibrator(
      _fbb,
      COEFFICIENTS__);
}

/// Spline point for spline calibration
struct SplinePoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SplinePointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RAW = 4,
    VT_CALIBRATED = 6
  };
  /// Raw value
  double RAW() const {
    return GetField<double>(VT_RAW, 0.0);
  }
  /// Calibrated/engineering value
  double CALIBRATED() const {
    return GetField<double>(VT_CALIBRATED, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RAW, 8) &&
           VerifyField<double>(verifier, VT_CALIBRATED, 8) &&
           verifier.EndTable();
  }
};

struct SplinePointBuilder {
  typedef SplinePoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RAW(double RAW) {
    fbb_.AddElement<double>(SplinePoint::VT_RAW, RAW, 0.0);
  }
  void add_CALIBRATED(double CALIBRATED) {
    fbb_.AddElement<double>(SplinePoint::VT_CALIBRATED, CALIBRATED, 0.0);
  }
  explicit SplinePointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplinePoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplinePoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplinePoint> CreateSplinePoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double RAW = 0.0,
    double CALIBRATED = 0.0) {
  SplinePointBuilder builder_(_fbb);
  builder_.add_CALIBRATED(CALIBRATED);
  builder_.add_RAW(RAW);
  return builder_.Finish();
}

/// Spline calibrator - piecewise linear interpolation
struct SplineCalibrator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SplineCalibratorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_EXTRAPOLATE_LOW = 6,
    VT_EXTRAPOLATE_HIGH = 8
  };
  /// Spline points ordered by raw value
  const ::flatbuffers::Vector<::flatbuffers::Offset<SplinePoint>> *POINTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SplinePoint>> *>(VT_POINTS);
  }
  /// Extrapolate below minimum point
  bool EXTRAPOLATE_LOW() const {
    return GetField<uint8_t>(VT_EXTRAPOLATE_LOW, 0) != 0;
  }
  /// Extrapolate above maximum point
  bool EXTRAPOLATE_HIGH() const {
    return GetField<uint8_t>(VT_EXTRAPOLATE_HIGH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(POINTS()) &&
           verifier.VerifyVectorOfTables(POINTS()) &&
           VerifyField<uint8_t>(verifier, VT_EXTRAPOLATE_LOW, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTRAPOLATE_HIGH, 1) &&
           verifier.EndTable();
  }
};

struct SplineCalibratorBuilder {
  typedef SplineCalibrator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POINTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SplinePoint>>> POINTS) {
    fbb_.AddOffset(SplineCalibrator::VT_POINTS, POINTS);
  }
  void add_EXTRAPOLATE_LOW(bool EXTRAPOLATE_LOW) {
    fbb_.AddElement<uint8_t>(SplineCalibrator::VT_EXTRAPOLATE_LOW, static_cast<uint8_t>(EXTRAPOLATE_LOW), 0);
  }
  void add_EXTRAPOLATE_HIGH(bool EXTRAPOLATE_HIGH) {
    fbb_.AddElement<uint8_t>(SplineCalibrator::VT_EXTRAPOLATE_HIGH, static_cast<uint8_t>(EXTRAPOLATE_HIGH), 0);
  }
  explicit SplineCalibratorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SplineCalibrator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SplineCalibrator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SplineCalibrator> CreateSplineCalibrator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SplinePoint>>> POINTS = 0,
    bool EXTRAPOLATE_LOW = false,
    bool EXTRAPOLATE_HIGH = false) {
  SplineCalibratorBuilder builder_(_fbb);
  builder_.add_POINTS(POINTS);
  builder_.add_EXTRAPOLATE_HIGH(EXTRAPOLATE_HIGH);
  builder_.add_EXTRAPOLATE_LOW(EXTRAPOLATE_LOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SplineCalibrator> CreateSplineCalibratorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<SplinePoint>> *POINTS = nullptr,
    bool EXTRAPOLATE_LOW = false,
    bool EXTRAPOLATE_HIGH = false) {
  auto POINTS__ = POINTS ? _fbb.CreateVector<::flatbuffers::Offset<SplinePoint>>(*POINTS) : 0;
  return CreateSplineCalibrator(
      _fbb,
      POINTS__,
      EXTRAPOLATE_LOW,
      EXTRAPOLATE_HIGH);
}

/// Mathematical operation for math operation calibrator
struct MathOperation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MathOperationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RPN_EXPRESSION = 4
  };
  /// Operation in Reverse Polish Notation (RPN)
  const ::flatbuffers::String *RPN_EXPRESSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RPN_EXPRESSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RPN_EXPRESSION) &&
           verifier.VerifyString(RPN_EXPRESSION()) &&
           verifier.EndTable();
  }
};

struct MathOperationBuilder {
  typedef MathOperation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RPN_EXPRESSION(::flatbuffers::Offset<::flatbuffers::String> RPN_EXPRESSION) {
    fbb_.AddOffset(MathOperation::VT_RPN_EXPRESSION, RPN_EXPRESSION);
  }
  explicit MathOperationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MathOperation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MathOperation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MathOperation> CreateMathOperation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> RPN_EXPRESSION = 0) {
  MathOperationBuilder builder_(_fbb);
  builder_.add_RPN_EXPRESSION(RPN_EXPRESSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MathOperation> CreateMathOperationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *RPN_EXPRESSION = nullptr) {
  auto RPN_EXPRESSION__ = RPN_EXPRESSION ? _fbb.CreateString(RPN_EXPRESSION) : 0;
  return CreateMathOperation(
      _fbb,
      RPN_EXPRESSION__);
}

/// Context-dependent calibrator selection
struct ContextCalibrator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContextCalibratorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATCH_CRITERIA = 4,
    VT_POLYNOMIAL = 6,
    VT_SPLINE = 8,
    VT_MATH_OPERATION = 10
  };
  /// Match criteria for selecting this calibrator
  const MatchCriteria *MATCH_CRITERIA() const {
    return GetPointer<const MatchCriteria *>(VT_MATCH_CRITERIA);
  }
  /// Polynomial calibrator (if used)
  const PolynomialCalibrator *POLYNOMIAL() const {
    return GetPointer<const PolynomialCalibrator *>(VT_POLYNOMIAL);
  }
  /// Spline calibrator (if used)
  const SplineCalibrator *SPLINE() const {
    return GetPointer<const SplineCalibrator *>(VT_SPLINE);
  }
  /// Math operation calibrator (if used)
  const MathOperation *MATH_OPERATION() const {
    return GetPointer<const MathOperation *>(VT_MATH_OPERATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATCH_CRITERIA) &&
           verifier.VerifyTable(MATCH_CRITERIA()) &&
           VerifyOffset(verifier, VT_POLYNOMIAL) &&
           verifier.VerifyTable(POLYNOMIAL()) &&
           VerifyOffset(verifier, VT_SPLINE) &&
           verifier.VerifyTable(SPLINE()) &&
           VerifyOffset(verifier, VT_MATH_OPERATION) &&
           verifier.VerifyTable(MATH_OPERATION()) &&
           verifier.EndTable();
  }
};

struct ContextCalibratorBuilder {
  typedef ContextCalibrator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MATCH_CRITERIA(::flatbuffers::Offset<MatchCriteria> MATCH_CRITERIA) {
    fbb_.AddOffset(ContextCalibrator::VT_MATCH_CRITERIA, MATCH_CRITERIA);
  }
  void add_POLYNOMIAL(::flatbuffers::Offset<PolynomialCalibrator> POLYNOMIAL) {
    fbb_.AddOffset(ContextCalibrator::VT_POLYNOMIAL, POLYNOMIAL);
  }
  void add_SPLINE(::flatbuffers::Offset<SplineCalibrator> SPLINE) {
    fbb_.AddOffset(ContextCalibrator::VT_SPLINE, SPLINE);
  }
  void add_MATH_OPERATION(::flatbuffers::Offset<MathOperation> MATH_OPERATION) {
    fbb_.AddOffset(ContextCalibrator::VT_MATH_OPERATION, MATH_OPERATION);
  }
  explicit ContextCalibratorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContextCalibrator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContextCalibrator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContextCalibrator> CreateContextCalibrator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MatchCriteria> MATCH_CRITERIA = 0,
    ::flatbuffers::Offset<PolynomialCalibrator> POLYNOMIAL = 0,
    ::flatbuffers::Offset<SplineCalibrator> SPLINE = 0,
    ::flatbuffers::Offset<MathOperation> MATH_OPERATION = 0) {
  ContextCalibratorBuilder builder_(_fbb);
  builder_.add_MATH_OPERATION(MATH_OPERATION);
  builder_.add_SPLINE(SPLINE);
  builder_.add_POLYNOMIAL(POLYNOMIAL);
  builder_.add_MATCH_CRITERIA(MATCH_CRITERIA);
  return builder_.Finish();
}

/// Numeric alarm range
struct AlarmRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlarmRangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_INCLUSIVE = 4,
    VT_MAX_INCLUSIVE = 6,
    VT_MIN_EXCLUSIVE = 8,
    VT_MAX_EXCLUSIVE = 10
  };
  /// Minimum value (inclusive)
  double MIN_INCLUSIVE() const {
    return GetField<double>(VT_MIN_INCLUSIVE, 0.0);
  }
  /// Maximum value (inclusive)
  double MAX_INCLUSIVE() const {
    return GetField<double>(VT_MAX_INCLUSIVE, 0.0);
  }
  /// Minimum value (exclusive)
  double MIN_EXCLUSIVE() const {
    return GetField<double>(VT_MIN_EXCLUSIVE, 0.0);
  }
  /// Maximum value (exclusive)
  double MAX_EXCLUSIVE() const {
    return GetField<double>(VT_MAX_EXCLUSIVE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MIN_INCLUSIVE, 8) &&
           VerifyField<double>(verifier, VT_MAX_INCLUSIVE, 8) &&
           VerifyField<double>(verifier, VT_MIN_EXCLUSIVE, 8) &&
           VerifyField<double>(verifier, VT_MAX_EXCLUSIVE, 8) &&
           verifier.EndTable();
  }
};

struct AlarmRangeBuilder {
  typedef AlarmRange Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MIN_INCLUSIVE(double MIN_INCLUSIVE) {
    fbb_.AddElement<double>(AlarmRange::VT_MIN_INCLUSIVE, MIN_INCLUSIVE, 0.0);
  }
  void add_MAX_INCLUSIVE(double MAX_INCLUSIVE) {
    fbb_.AddElement<double>(AlarmRange::VT_MAX_INCLUSIVE, MAX_INCLUSIVE, 0.0);
  }
  void add_MIN_EXCLUSIVE(double MIN_EXCLUSIVE) {
    fbb_.AddElement<double>(AlarmRange::VT_MIN_EXCLUSIVE, MIN_EXCLUSIVE, 0.0);
  }
  void add_MAX_EXCLUSIVE(double MAX_EXCLUSIVE) {
    fbb_.AddElement<double>(AlarmRange::VT_MAX_EXCLUSIVE, MAX_EXCLUSIVE, 0.0);
  }
  explicit AlarmRangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlarmRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlarmRange>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlarmRange> CreateAlarmRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double MIN_INCLUSIVE = 0.0,
    double MAX_INCLUSIVE = 0.0,
    double MIN_EXCLUSIVE = 0.0,
    double MAX_EXCLUSIVE = 0.0) {
  AlarmRangeBuilder builder_(_fbb);
  builder_.add_MAX_EXCLUSIVE(MAX_EXCLUSIVE);
  builder_.add_MIN_EXCLUSIVE(MIN_EXCLUSIVE);
  builder_.add_MAX_INCLUSIVE(MAX_INCLUSIVE);
  builder_.add_MIN_INCLUSIVE(MIN_INCLUSIVE);
  return builder_.Finish();
}

/// Static numeric alarm levels
struct StaticAlarmRanges FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StaticAlarmRangesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WATCH_RANGE = 4,
    VT_WARNING_RANGE = 6,
    VT_DISTRESS_RANGE = 8,
    VT_CRITICAL_RANGE = 10,
    VT_SEVERE_RANGE = 12
  };
  /// Watch range
  const AlarmRange *WATCH_RANGE() const {
    return GetPointer<const AlarmRange *>(VT_WATCH_RANGE);
  }
  /// Warning range
  const AlarmRange *WARNING_RANGE() const {
    return GetPointer<const AlarmRange *>(VT_WARNING_RANGE);
  }
  /// Distress range
  const AlarmRange *DISTRESS_RANGE() const {
    return GetPointer<const AlarmRange *>(VT_DISTRESS_RANGE);
  }
  /// Critical range
  const AlarmRange *CRITICAL_RANGE() const {
    return GetPointer<const AlarmRange *>(VT_CRITICAL_RANGE);
  }
  /// Severe range
  const AlarmRange *SEVERE_RANGE() const {
    return GetPointer<const AlarmRange *>(VT_SEVERE_RANGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WATCH_RANGE) &&
           verifier.VerifyTable(WATCH_RANGE()) &&
           VerifyOffset(verifier, VT_WARNING_RANGE) &&
           verifier.VerifyTable(WARNING_RANGE()) &&
           VerifyOffset(verifier, VT_DISTRESS_RANGE) &&
           verifier.VerifyTable(DISTRESS_RANGE()) &&
           VerifyOffset(verifier, VT_CRITICAL_RANGE) &&
           verifier.VerifyTable(CRITICAL_RANGE()) &&
           VerifyOffset(verifier, VT_SEVERE_RANGE) &&
           verifier.VerifyTable(SEVERE_RANGE()) &&
           verifier.EndTable();
  }
};

struct StaticAlarmRangesBuilder {
  typedef StaticAlarmRanges Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_WATCH_RANGE(::flatbuffers::Offset<AlarmRange> WATCH_RANGE) {
    fbb_.AddOffset(StaticAlarmRanges::VT_WATCH_RANGE, WATCH_RANGE);
  }
  void add_WARNING_RANGE(::flatbuffers::Offset<AlarmRange> WARNING_RANGE) {
    fbb_.AddOffset(StaticAlarmRanges::VT_WARNING_RANGE, WARNING_RANGE);
  }
  void add_DISTRESS_RANGE(::flatbuffers::Offset<AlarmRange> DISTRESS_RANGE) {
    fbb_.AddOffset(StaticAlarmRanges::VT_DISTRESS_RANGE, DISTRESS_RANGE);
  }
  void add_CRITICAL_RANGE(::flatbuffers::Offset<AlarmRange> CRITICAL_RANGE) {
    fbb_.AddOffset(StaticAlarmRanges::VT_CRITICAL_RANGE, CRITICAL_RANGE);
  }
  void add_SEVERE_RANGE(::flatbuffers::Offset<AlarmRange> SEVERE_RANGE) {
    fbb_.AddOffset(StaticAlarmRanges::VT_SEVERE_RANGE, SEVERE_RANGE);
  }
  explicit StaticAlarmRangesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StaticAlarmRanges> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StaticAlarmRanges>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StaticAlarmRanges> CreateStaticAlarmRanges(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<AlarmRange> WATCH_RANGE = 0,
    ::flatbuffers::Offset<AlarmRange> WARNING_RANGE = 0,
    ::flatbuffers::Offset<AlarmRange> DISTRESS_RANGE = 0,
    ::flatbuffers::Offset<AlarmRange> CRITICAL_RANGE = 0,
    ::flatbuffers::Offset<AlarmRange> SEVERE_RANGE = 0) {
  StaticAlarmRangesBuilder builder_(_fbb);
  builder_.add_SEVERE_RANGE(SEVERE_RANGE);
  builder_.add_CRITICAL_RANGE(CRITICAL_RANGE);
  builder_.add_DISTRESS_RANGE(DISTRESS_RANGE);
  builder_.add_WARNING_RANGE(WARNING_RANGE);
  builder_.add_WATCH_RANGE(WATCH_RANGE);
  return builder_.Finish();
}

/// Enumerated alarm
struct EnumerationAlarm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerationAlarmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_ALARM_LEVEL = 6
  };
  /// Enumerated value label
  const ::flatbuffers::String *LABEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  /// Alarm level for this value
  AlarmSeverityType ALARM_LEVEL() const {
    return static_cast<AlarmSeverityType>(GetField<int8_t>(VT_ALARM_LEVEL, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(LABEL()) &&
           VerifyField<int8_t>(verifier, VT_ALARM_LEVEL, 1) &&
           verifier.EndTable();
  }
};

struct EnumerationAlarmBuilder {
  typedef EnumerationAlarm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LABEL(::flatbuffers::Offset<::flatbuffers::String> LABEL) {
    fbb_.AddOffset(EnumerationAlarm::VT_LABEL, LABEL);
  }
  void add_ALARM_LEVEL(AlarmSeverityType ALARM_LEVEL) {
    fbb_.AddElement<int8_t>(EnumerationAlarm::VT_ALARM_LEVEL, static_cast<int8_t>(ALARM_LEVEL), 0);
  }
  explicit EnumerationAlarmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerationAlarm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerationAlarm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerationAlarm> CreateEnumerationAlarm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> LABEL = 0,
    AlarmSeverityType ALARM_LEVEL = AlarmSeverityType_NORMAL) {
  EnumerationAlarmBuilder builder_(_fbb);
  builder_.add_LABEL(LABEL);
  builder_.add_ALARM_LEVEL(ALARM_LEVEL);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumerationAlarm> CreateEnumerationAlarmDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *LABEL = nullptr,
    AlarmSeverityType ALARM_LEVEL = AlarmSeverityType_NORMAL) {
  auto LABEL__ = LABEL ? _fbb.CreateString(LABEL) : 0;
  return CreateEnumerationAlarm(
      _fbb,
      LABEL__,
      ALARM_LEVEL);
}

/// Default alarm definition
struct DefaultAlarm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DefaultAlarmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_VIOLATIONS = 4,
    VT_STATIC_ALARM_RANGES = 6,
    VT_ENUMERATION_ALARMS = 8
  };
  /// Minimum violations before alarm triggers
  uint16_t MIN_VIOLATIONS() const {
    return GetField<uint16_t>(VT_MIN_VIOLATIONS, 0);
  }
  /// Static numeric alarm ranges
  const StaticAlarmRanges *STATIC_ALARM_RANGES() const {
    return GetPointer<const StaticAlarmRanges *>(VT_STATIC_ALARM_RANGES);
  }
  /// Enumeration alarms for enumerated types
  const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationAlarm>> *ENUMERATION_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationAlarm>> *>(VT_ENUMERATION_ALARMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MIN_VIOLATIONS, 2) &&
           VerifyOffset(verifier, VT_STATIC_ALARM_RANGES) &&
           verifier.VerifyTable(STATIC_ALARM_RANGES()) &&
           VerifyOffset(verifier, VT_ENUMERATION_ALARMS) &&
           verifier.VerifyVector(ENUMERATION_ALARMS()) &&
           verifier.VerifyVectorOfTables(ENUMERATION_ALARMS()) &&
           verifier.EndTable();
  }
};

struct DefaultAlarmBuilder {
  typedef DefaultAlarm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MIN_VIOLATIONS(uint16_t MIN_VIOLATIONS) {
    fbb_.AddElement<uint16_t>(DefaultAlarm::VT_MIN_VIOLATIONS, MIN_VIOLATIONS, 0);
  }
  void add_STATIC_ALARM_RANGES(::flatbuffers::Offset<StaticAlarmRanges> STATIC_ALARM_RANGES) {
    fbb_.AddOffset(DefaultAlarm::VT_STATIC_ALARM_RANGES, STATIC_ALARM_RANGES);
  }
  void add_ENUMERATION_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationAlarm>>> ENUMERATION_ALARMS) {
    fbb_.AddOffset(DefaultAlarm::VT_ENUMERATION_ALARMS, ENUMERATION_ALARMS);
  }
  explicit DefaultAlarmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DefaultAlarm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DefaultAlarm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DefaultAlarm> CreateDefaultAlarm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MIN_VIOLATIONS = 0,
    ::flatbuffers::Offset<StaticAlarmRanges> STATIC_ALARM_RANGES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationAlarm>>> ENUMERATION_ALARMS = 0) {
  DefaultAlarmBuilder builder_(_fbb);
  builder_.add_ENUMERATION_ALARMS(ENUMERATION_ALARMS);
  builder_.add_STATIC_ALARM_RANGES(STATIC_ALARM_RANGES);
  builder_.add_MIN_VIOLATIONS(MIN_VIOLATIONS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DefaultAlarm> CreateDefaultAlarmDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t MIN_VIOLATIONS = 0,
    ::flatbuffers::Offset<StaticAlarmRanges> STATIC_ALARM_RANGES = 0,
    const std::vector<::flatbuffers::Offset<EnumerationAlarm>> *ENUMERATION_ALARMS = nullptr) {
  auto ENUMERATION_ALARMS__ = ENUMERATION_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<EnumerationAlarm>>(*ENUMERATION_ALARMS) : 0;
  return CreateDefaultAlarm(
      _fbb,
      MIN_VIOLATIONS,
      STATIC_ALARM_RANGES,
      ENUMERATION_ALARMS__);
}

/// Context-dependent alarm
struct ContextAlarm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContextAlarmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATCH_CRITERIA = 4,
    VT_ALARM = 6
  };
  /// Match criteria for this alarm context
  const MatchCriteria *MATCH_CRITERIA() const {
    return GetPointer<const MatchCriteria *>(VT_MATCH_CRITERIA);
  }
  /// Alarm definition for this context
  const DefaultAlarm *ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_ALARM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MATCH_CRITERIA) &&
           verifier.VerifyTable(MATCH_CRITERIA()) &&
           VerifyOffset(verifier, VT_ALARM) &&
           verifier.VerifyTable(ALARM()) &&
           verifier.EndTable();
  }
};

struct ContextAlarmBuilder {
  typedef ContextAlarm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MATCH_CRITERIA(::flatbuffers::Offset<MatchCriteria> MATCH_CRITERIA) {
    fbb_.AddOffset(ContextAlarm::VT_MATCH_CRITERIA, MATCH_CRITERIA);
  }
  void add_ALARM(::flatbuffers::Offset<DefaultAlarm> ALARM) {
    fbb_.AddOffset(ContextAlarm::VT_ALARM, ALARM);
  }
  explicit ContextAlarmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContextAlarm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContextAlarm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContextAlarm> CreateContextAlarm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MatchCriteria> MATCH_CRITERIA = 0,
    ::flatbuffers::Offset<DefaultAlarm> ALARM = 0) {
  ContextAlarmBuilder builder_(_fbb);
  builder_.add_ALARM(ALARM);
  builder_.add_MATCH_CRITERIA(MATCH_CRITERIA);
  return builder_.Finish();
}

/// Parameter comparison for match criteria
struct ParameterComparison FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterComparisonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_OPERATOR = 6,
    VT_VALUE = 8,
    VT_USE_CALIBRATED_VALUE = 10
  };
  /// Parameter reference path
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Comparison operator
  ComparisonOperator OPERATOR() const {
    return static_cast<ComparisonOperator>(GetField<int8_t>(VT_OPERATOR, 0));
  }
  /// Value to compare against
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  /// Use calibrated value (true) or raw value (false)
  bool USE_CALIBRATED_VALUE() const {
    return GetField<uint8_t>(VT_USE_CALIBRATED_VALUE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyField<int8_t>(verifier, VT_OPERATOR, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           VerifyField<uint8_t>(verifier, VT_USE_CALIBRATED_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct ParameterComparisonBuilder {
  typedef ParameterComparison Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(ParameterComparison::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_OPERATOR(ComparisonOperator OPERATOR) {
    fbb_.AddElement<int8_t>(ParameterComparison::VT_OPERATOR, static_cast<int8_t>(OPERATOR), 0);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(ParameterComparison::VT_VALUE, VALUE);
  }
  void add_USE_CALIBRATED_VALUE(bool USE_CALIBRATED_VALUE) {
    fbb_.AddElement<uint8_t>(ParameterComparison::VT_USE_CALIBRATED_VALUE, static_cast<uint8_t>(USE_CALIBRATED_VALUE), 1);
  }
  explicit ParameterComparisonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterComparison> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterComparison>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterComparison> CreateParameterComparison(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ComparisonOperator OPERATOR = ComparisonOperator_EQ,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0,
    bool USE_CALIBRATED_VALUE = true) {
  ParameterComparisonBuilder builder_(_fbb);
  builder_.add_VALUE(VALUE);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  builder_.add_USE_CALIBRATED_VALUE(USE_CALIBRATED_VALUE);
  builder_.add_OPERATOR(OPERATOR);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParameterComparison> CreateParameterComparisonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    ComparisonOperator OPERATOR = ComparisonOperator_EQ,
    const char *VALUE = nullptr,
    bool USE_CALIBRATED_VALUE = true) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateParameterComparison(
      _fbb,
      PARAMETER_REF__,
      OPERATOR,
      VALUE__,
      USE_CALIBRATED_VALUE);
}

/// Boolean expression combining comparisons
struct BooleanExpression FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanExpressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATOR = 4,
    VT_CONDITIONS = 6,
    VT_EXPRESSIONS = 8
  };
  /// Boolean operator
  BooleanOperatorType OPERATOR() const {
    return static_cast<BooleanOperatorType>(GetField<int8_t>(VT_OPERATOR, 0));
  }
  /// Comparison conditions
  const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>> *CONDITIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>> *>(VT_CONDITIONS);
  }
  /// Nested expressions
  const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanExpression>> *EXPRESSIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanExpression>> *>(VT_EXPRESSIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPERATOR, 1) &&
           VerifyOffset(verifier, VT_CONDITIONS) &&
           verifier.VerifyVector(CONDITIONS()) &&
           verifier.VerifyVectorOfTables(CONDITIONS()) &&
           VerifyOffset(verifier, VT_EXPRESSIONS) &&
           verifier.VerifyVector(EXPRESSIONS()) &&
           verifier.VerifyVectorOfTables(EXPRESSIONS()) &&
           verifier.EndTable();
  }
};

struct BooleanExpressionBuilder {
  typedef BooleanExpression Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OPERATOR(BooleanOperatorType OPERATOR) {
    fbb_.AddElement<int8_t>(BooleanExpression::VT_OPERATOR, static_cast<int8_t>(OPERATOR), 0);
  }
  void add_CONDITIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>>> CONDITIONS) {
    fbb_.AddOffset(BooleanExpression::VT_CONDITIONS, CONDITIONS);
  }
  void add_EXPRESSIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanExpression>>> EXPRESSIONS) {
    fbb_.AddOffset(BooleanExpression::VT_EXPRESSIONS, EXPRESSIONS);
  }
  explicit BooleanExpressionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BooleanExpression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BooleanExpression>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BooleanExpression> CreateBooleanExpression(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BooleanOperatorType OPERATOR = BooleanOperatorType_AND,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>>> CONDITIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanExpression>>> EXPRESSIONS = 0) {
  BooleanExpressionBuilder builder_(_fbb);
  builder_.add_EXPRESSIONS(EXPRESSIONS);
  builder_.add_CONDITIONS(CONDITIONS);
  builder_.add_OPERATOR(OPERATOR);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BooleanExpression> CreateBooleanExpressionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    BooleanOperatorType OPERATOR = BooleanOperatorType_AND,
    const std::vector<::flatbuffers::Offset<ParameterComparison>> *CONDITIONS = nullptr,
    const std::vector<::flatbuffers::Offset<BooleanExpression>> *EXPRESSIONS = nullptr) {
  auto CONDITIONS__ = CONDITIONS ? _fbb.CreateVector<::flatbuffers::Offset<ParameterComparison>>(*CONDITIONS) : 0;
  auto EXPRESSIONS__ = EXPRESSIONS ? _fbb.CreateVector<::flatbuffers::Offset<BooleanExpression>>(*EXPRESSIONS) : 0;
  return CreateBooleanExpression(
      _fbb,
      OPERATOR,
      CONDITIONS__,
      EXPRESSIONS__);
}

/// Match criteria for conditional logic
struct MatchCriteria FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatchCriteriaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPARISON = 4,
    VT_COMPARISON_LIST = 6,
    VT_BOOLEAN_EXPRESSION = 8,
    VT_CUSTOM_ALGORITHM = 10
  };
  /// Single comparison
  const ParameterComparison *COMPARISON() const {
    return GetPointer<const ParameterComparison *>(VT_COMPARISON);
  }
  /// List of comparisons (implicit AND)
  const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>> *COMPARISON_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>> *>(VT_COMPARISON_LIST);
  }
  /// Boolean expression
  const BooleanExpression *BOOLEAN_EXPRESSION() const {
    return GetPointer<const BooleanExpression *>(VT_BOOLEAN_EXPRESSION);
  }
  /// Custom algorithm reference
  const ::flatbuffers::String *CUSTOM_ALGORITHM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOM_ALGORITHM);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMPARISON) &&
           verifier.VerifyTable(COMPARISON()) &&
           VerifyOffset(verifier, VT_COMPARISON_LIST) &&
           verifier.VerifyVector(COMPARISON_LIST()) &&
           verifier.VerifyVectorOfTables(COMPARISON_LIST()) &&
           VerifyOffset(verifier, VT_BOOLEAN_EXPRESSION) &&
           verifier.VerifyTable(BOOLEAN_EXPRESSION()) &&
           VerifyOffset(verifier, VT_CUSTOM_ALGORITHM) &&
           verifier.VerifyString(CUSTOM_ALGORITHM()) &&
           verifier.EndTable();
  }
};

struct MatchCriteriaBuilder {
  typedef MatchCriteria Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMPARISON(::flatbuffers::Offset<ParameterComparison> COMPARISON) {
    fbb_.AddOffset(MatchCriteria::VT_COMPARISON, COMPARISON);
  }
  void add_COMPARISON_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>>> COMPARISON_LIST) {
    fbb_.AddOffset(MatchCriteria::VT_COMPARISON_LIST, COMPARISON_LIST);
  }
  void add_BOOLEAN_EXPRESSION(::flatbuffers::Offset<BooleanExpression> BOOLEAN_EXPRESSION) {
    fbb_.AddOffset(MatchCriteria::VT_BOOLEAN_EXPRESSION, BOOLEAN_EXPRESSION);
  }
  void add_CUSTOM_ALGORITHM(::flatbuffers::Offset<::flatbuffers::String> CUSTOM_ALGORITHM) {
    fbb_.AddOffset(MatchCriteria::VT_CUSTOM_ALGORITHM, CUSTOM_ALGORITHM);
  }
  explicit MatchCriteriaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatchCriteria> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatchCriteria>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatchCriteria> CreateMatchCriteria(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ParameterComparison> COMPARISON = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ParameterComparison>>> COMPARISON_LIST = 0,
    ::flatbuffers::Offset<BooleanExpression> BOOLEAN_EXPRESSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CUSTOM_ALGORITHM = 0) {
  MatchCriteriaBuilder builder_(_fbb);
  builder_.add_CUSTOM_ALGORITHM(CUSTOM_ALGORITHM);
  builder_.add_BOOLEAN_EXPRESSION(BOOLEAN_EXPRESSION);
  builder_.add_COMPARISON_LIST(COMPARISON_LIST);
  builder_.add_COMPARISON(COMPARISON);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MatchCriteria> CreateMatchCriteriaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ParameterComparison> COMPARISON = 0,
    const std::vector<::flatbuffers::Offset<ParameterComparison>> *COMPARISON_LIST = nullptr,
    ::flatbuffers::Offset<BooleanExpression> BOOLEAN_EXPRESSION = 0,
    const char *CUSTOM_ALGORITHM = nullptr) {
  auto COMPARISON_LIST__ = COMPARISON_LIST ? _fbb.CreateVector<::flatbuffers::Offset<ParameterComparison>>(*COMPARISON_LIST) : 0;
  auto CUSTOM_ALGORITHM__ = CUSTOM_ALGORITHM ? _fbb.CreateString(CUSTOM_ALGORITHM) : 0;
  return CreateMatchCriteria(
      _fbb,
      COMPARISON,
      COMPARISON_LIST__,
      BOOLEAN_EXPRESSION,
      CUSTOM_ALGORITHM__);
}

/// Unit specification
struct Unit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESCRIPTION = 4,
    VT_SYMBOL = 6,
    VT_POWER = 8,
    VT_FACTOR = 10
  };
  /// Unit description (e.g., "meters per second")
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Unit symbol (e.g., "m/s")
  const ::flatbuffers::String *SYMBOL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  /// Power/exponent for this unit
  double POWER() const {
    return GetField<double>(VT_POWER, 0.0);
  }
  /// Factor multiplier
  double FACTOR() const {
    return GetField<double>(VT_FACTOR, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(SYMBOL()) &&
           VerifyField<double>(verifier, VT_POWER, 8) &&
           VerifyField<double>(verifier, VT_FACTOR, 8) &&
           verifier.EndTable();
  }
};

struct UnitBuilder {
  typedef Unit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(Unit::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_SYMBOL(::flatbuffers::Offset<::flatbuffers::String> SYMBOL) {
    fbb_.AddOffset(Unit::VT_SYMBOL, SYMBOL);
  }
  void add_POWER(double POWER) {
    fbb_.AddElement<double>(Unit::VT_POWER, POWER, 0.0);
  }
  void add_FACTOR(double FACTOR) {
    fbb_.AddElement<double>(Unit::VT_FACTOR, FACTOR, 0.0);
  }
  explicit UnitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Unit> CreateUnit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SYMBOL = 0,
    double POWER = 0.0,
    double FACTOR = 0.0) {
  UnitBuilder builder_(_fbb);
  builder_.add_FACTOR(FACTOR);
  builder_.add_POWER(POWER);
  builder_.add_SYMBOL(SYMBOL);
  builder_.add_DESCRIPTION(DESCRIPTION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Unit> CreateUnitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *DESCRIPTION = nullptr,
    const char *SYMBOL = nullptr,
    double POWER = 0.0,
    double FACTOR = 0.0) {
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto SYMBOL__ = SYMBOL ? _fbb.CreateString(SYMBOL) : 0;
  return CreateUnit(
      _fbb,
      DESCRIPTION__,
      SYMBOL__,
      POWER,
      FACTOR);
}

/// Enumeration value mapping
struct EnumerationValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumerationValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_VALUE = 6,
    VT_MAX_VALUE = 8,
    VT_DESCRIPTION = 10
  };
  /// Label/name for this value
  const ::flatbuffers::String *LABEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  /// Numeric value
  int64_t VALUE() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  /// Maximum value (for ranges)
  int64_t MAX_VALUE() const {
    return GetField<int64_t>(VT_MAX_VALUE, 0);
  }
  /// Description of this enumeration value
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(LABEL()) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           VerifyField<int64_t>(verifier, VT_MAX_VALUE, 8) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           verifier.EndTable();
  }
};

struct EnumerationValueBuilder {
  typedef EnumerationValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LABEL(::flatbuffers::Offset<::flatbuffers::String> LABEL) {
    fbb_.AddOffset(EnumerationValue::VT_LABEL, LABEL);
  }
  void add_VALUE(int64_t VALUE) {
    fbb_.AddElement<int64_t>(EnumerationValue::VT_VALUE, VALUE, 0);
  }
  void add_MAX_VALUE(int64_t MAX_VALUE) {
    fbb_.AddElement<int64_t>(EnumerationValue::VT_MAX_VALUE, MAX_VALUE, 0);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(EnumerationValue::VT_DESCRIPTION, DESCRIPTION);
  }
  explicit EnumerationValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumerationValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumerationValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumerationValue> CreateEnumerationValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> LABEL = 0,
    int64_t VALUE = 0,
    int64_t MAX_VALUE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0) {
  EnumerationValueBuilder builder_(_fbb);
  builder_.add_MAX_VALUE(MAX_VALUE);
  builder_.add_VALUE(VALUE);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_LABEL(LABEL);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumerationValue> CreateEnumerationValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *LABEL = nullptr,
    int64_t VALUE = 0,
    int64_t MAX_VALUE = 0,
    const char *DESCRIPTION = nullptr) {
  auto LABEL__ = LABEL ? _fbb.CreateString(LABEL) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  return CreateEnumerationValue(
      _fbb,
      LABEL__,
      VALUE,
      MAX_VALUE,
      DESCRIPTION__);
}

/// Integer parameter type
struct IntegerParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_UNITS = 10,
    VT_DATA_ENCODING = 12,
    VT_DEFAULT_ALARM = 14,
    VT_CONTEXT_ALARMS = 16,
    VT_VALID_MIN = 18,
    VT_VALID_MAX = 20,
    VT_SIGNED = 22,
    VT_SIZE_IN_BITS = 24,
    VT_INITIAL_VALUE = 26
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Units
  const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  /// Minimum valid value
  int64_t VALID_MIN() const {
    return GetField<int64_t>(VT_VALID_MIN, 0);
  }
  /// Maximum valid value
  int64_t VALID_MAX() const {
    return GetField<int64_t>(VT_VALID_MAX, 0);
  }
  /// Signed integer (true) or unsigned (false)
  bool SIGNED() const {
    return GetField<uint8_t>(VT_SIGNED, 0) != 0;
  }
  /// Size in bits
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Initial/default value
  int64_t INITIAL_VALUE() const {
    return GetField<int64_t>(VT_INITIAL_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(UNITS()) &&
           verifier.VerifyVectorOfTables(UNITS()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           VerifyField<int64_t>(verifier, VT_VALID_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_VALID_MAX, 8) &&
           VerifyField<uint8_t>(verifier, VT_SIGNED, 1) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<int64_t>(verifier, VT_INITIAL_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct IntegerParameterTypeBuilder {
  typedef IntegerParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(IntegerParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(IntegerParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(IntegerParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS) {
    fbb_.AddOffset(IntegerParameterType::VT_UNITS, UNITS);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(IntegerParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(IntegerParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(IntegerParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  void add_VALID_MIN(int64_t VALID_MIN) {
    fbb_.AddElement<int64_t>(IntegerParameterType::VT_VALID_MIN, VALID_MIN, 0);
  }
  void add_VALID_MAX(int64_t VALID_MAX) {
    fbb_.AddElement<int64_t>(IntegerParameterType::VT_VALID_MAX, VALID_MAX, 0);
  }
  void add_SIGNED(bool SIGNED) {
    fbb_.AddElement<uint8_t>(IntegerParameterType::VT_SIGNED, static_cast<uint8_t>(SIGNED), 0);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(IntegerParameterType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_INITIAL_VALUE(int64_t INITIAL_VALUE) {
    fbb_.AddElement<int64_t>(IntegerParameterType::VT_INITIAL_VALUE, INITIAL_VALUE, 0);
  }
  explicit IntegerParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerParameterType> CreateIntegerParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0,
    int64_t VALID_MIN = 0,
    int64_t VALID_MAX = 0,
    bool SIGNED = false,
    uint16_t SIZE_IN_BITS = 0,
    int64_t INITIAL_VALUE = 0) {
  IntegerParameterTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_VALID_MAX(VALID_MAX);
  builder_.add_VALID_MIN(VALID_MIN);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_UNITS(UNITS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_SIGNED(SIGNED);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntegerParameterType> CreateIntegerParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<Unit>> *UNITS = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr,
    int64_t VALID_MIN = 0,
    int64_t VALID_MAX = 0,
    bool SIGNED = false,
    uint16_t SIZE_IN_BITS = 0,
    int64_t INITIAL_VALUE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto UNITS__ = UNITS ? _fbb.CreateVector<::flatbuffers::Offset<Unit>>(*UNITS) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  return CreateIntegerParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      UNITS__,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE);
}

/// Float parameter type
struct FloatParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_UNITS = 10,
    VT_DATA_ENCODING = 12,
    VT_DEFAULT_ALARM = 14,
    VT_CONTEXT_ALARMS = 16,
    VT_VALID_MIN = 18,
    VT_VALID_MAX = 20,
    VT_SIZE_IN_BITS = 22,
    VT_INITIAL_VALUE = 24
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Units
  const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  /// Data encoding
  const FloatDataEncoding *DATA_ENCODING() const {
    return GetPointer<const FloatDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  /// Minimum valid value
  double VALID_MIN() const {
    return GetField<double>(VT_VALID_MIN, 0.0);
  }
  /// Maximum valid value
  double VALID_MAX() const {
    return GetField<double>(VT_VALID_MAX, 0.0);
  }
  /// Size in bits (32 or 64)
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Initial/default value
  double INITIAL_VALUE() const {
    return GetField<double>(VT_INITIAL_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(UNITS()) &&
           verifier.VerifyVectorOfTables(UNITS()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           VerifyField<double>(verifier, VT_VALID_MIN, 8) &&
           VerifyField<double>(verifier, VT_VALID_MAX, 8) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<double>(verifier, VT_INITIAL_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct FloatParameterTypeBuilder {
  typedef FloatParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(FloatParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(FloatParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(FloatParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS) {
    fbb_.AddOffset(FloatParameterType::VT_UNITS, UNITS);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(FloatParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(FloatParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(FloatParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  void add_VALID_MIN(double VALID_MIN) {
    fbb_.AddElement<double>(FloatParameterType::VT_VALID_MIN, VALID_MIN, 0.0);
  }
  void add_VALID_MAX(double VALID_MAX) {
    fbb_.AddElement<double>(FloatParameterType::VT_VALID_MAX, VALID_MAX, 0.0);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(FloatParameterType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_INITIAL_VALUE(double INITIAL_VALUE) {
    fbb_.AddElement<double>(FloatParameterType::VT_INITIAL_VALUE, INITIAL_VALUE, 0.0);
  }
  explicit FloatParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatParameterType> CreateFloatParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS = 0,
    ::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0,
    double VALID_MIN = 0.0,
    double VALID_MAX = 0.0,
    uint16_t SIZE_IN_BITS = 0,
    double INITIAL_VALUE = 0.0) {
  FloatParameterTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_VALID_MAX(VALID_MAX);
  builder_.add_VALID_MIN(VALID_MIN);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_UNITS(UNITS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatParameterType> CreateFloatParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<Unit>> *UNITS = nullptr,
    ::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr,
    double VALID_MIN = 0.0,
    double VALID_MAX = 0.0,
    uint16_t SIZE_IN_BITS = 0,
    double INITIAL_VALUE = 0.0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto UNITS__ = UNITS ? _fbb.CreateVector<::flatbuffers::Offset<Unit>>(*UNITS) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  return CreateFloatParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      UNITS__,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE);
}

/// String parameter type
struct StringParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_DEFAULT_ALARM = 12,
    VT_CONTEXT_ALARMS = 14,
    VT_INITIAL_VALUE = 16,
    VT_RESTRICTION_PATTERN = 18
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const StringDataEncoding *DATA_ENCODING() const {
    return GetPointer<const StringDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  /// Initial/default value
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  /// Restriction pattern (regex)
  const ::flatbuffers::String *RESTRICTION_PATTERN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESTRICTION_PATTERN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           VerifyOffset(verifier, VT_RESTRICTION_PATTERN) &&
           verifier.VerifyString(RESTRICTION_PATTERN()) &&
           verifier.EndTable();
  }
};

struct StringParameterTypeBuilder {
  typedef StringParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(StringParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(StringParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(StringParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(StringParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(StringParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(StringParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(StringParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  void add_RESTRICTION_PATTERN(::flatbuffers::Offset<::flatbuffers::String> RESTRICTION_PATTERN) {
    fbb_.AddOffset(StringParameterType::VT_RESTRICTION_PATTERN, RESTRICTION_PATTERN);
  }
  explicit StringParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringParameterType> CreateStringParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RESTRICTION_PATTERN = 0) {
  StringParameterTypeBuilder builder_(_fbb);
  builder_.add_RESTRICTION_PATTERN(RESTRICTION_PATTERN);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringParameterType> CreateStringParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr,
    const char *INITIAL_VALUE = nullptr,
    const char *RESTRICTION_PATTERN = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  auto RESTRICTION_PATTERN__ = RESTRICTION_PATTERN ? _fbb.CreateString(RESTRICTION_PATTERN) : 0;
  return CreateStringParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__,
      INITIAL_VALUE__,
      RESTRICTION_PATTERN__);
}

/// Boolean parameter type
struct BooleanParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_ONE_STRING_VALUE = 12,
    VT_ZERO_STRING_VALUE = 14,
    VT_INITIAL_VALUE = 16
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding (typically IntegerDataEncoding with 1 bit)
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// String representation of true value
  const ::flatbuffers::String *ONE_STRING_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ONE_STRING_VALUE);
  }
  /// String representation of false value
  const ::flatbuffers::String *ZERO_STRING_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZERO_STRING_VALUE);
  }
  /// Initial/default value
  bool INITIAL_VALUE() const {
    return GetField<uint8_t>(VT_INITIAL_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_ONE_STRING_VALUE) &&
           verifier.VerifyString(ONE_STRING_VALUE()) &&
           VerifyOffset(verifier, VT_ZERO_STRING_VALUE) &&
           verifier.VerifyString(ZERO_STRING_VALUE()) &&
           VerifyField<uint8_t>(verifier, VT_INITIAL_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanParameterTypeBuilder {
  typedef BooleanParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(BooleanParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(BooleanParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(BooleanParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(BooleanParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_ONE_STRING_VALUE(::flatbuffers::Offset<::flatbuffers::String> ONE_STRING_VALUE) {
    fbb_.AddOffset(BooleanParameterType::VT_ONE_STRING_VALUE, ONE_STRING_VALUE);
  }
  void add_ZERO_STRING_VALUE(::flatbuffers::Offset<::flatbuffers::String> ZERO_STRING_VALUE) {
    fbb_.AddOffset(BooleanParameterType::VT_ZERO_STRING_VALUE, ZERO_STRING_VALUE);
  }
  void add_INITIAL_VALUE(bool INITIAL_VALUE) {
    fbb_.AddElement<uint8_t>(BooleanParameterType::VT_INITIAL_VALUE, static_cast<uint8_t>(INITIAL_VALUE), 0);
  }
  explicit BooleanParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BooleanParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BooleanParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BooleanParameterType> CreateBooleanParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ONE_STRING_VALUE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ZERO_STRING_VALUE = 0,
    bool INITIAL_VALUE = false) {
  BooleanParameterTypeBuilder builder_(_fbb);
  builder_.add_ZERO_STRING_VALUE(ZERO_STRING_VALUE);
  builder_.add_ONE_STRING_VALUE(ONE_STRING_VALUE);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BooleanParameterType> CreateBooleanParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    const char *ONE_STRING_VALUE = nullptr,
    const char *ZERO_STRING_VALUE = nullptr,
    bool INITIAL_VALUE = false) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ONE_STRING_VALUE__ = ONE_STRING_VALUE ? _fbb.CreateString(ONE_STRING_VALUE) : 0;
  auto ZERO_STRING_VALUE__ = ZERO_STRING_VALUE ? _fbb.CreateString(ZERO_STRING_VALUE) : 0;
  return CreateBooleanParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      ONE_STRING_VALUE__,
      ZERO_STRING_VALUE__,
      INITIAL_VALUE);
}

/// Enumerated parameter type
struct EnumeratedParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumeratedParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_DEFAULT_ALARM = 12,
    VT_CONTEXT_ALARMS = 14,
    VT_ENUMERATION_LIST = 16,
    VT_INITIAL_VALUE = 18
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  /// Enumeration values list
  const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>> *ENUMERATION_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>> *>(VT_ENUMERATION_LIST);
  }
  /// Initial/default value label
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           VerifyOffset(verifier, VT_ENUMERATION_LIST) &&
           verifier.VerifyVector(ENUMERATION_LIST()) &&
           verifier.VerifyVectorOfTables(ENUMERATION_LIST()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct EnumeratedParameterTypeBuilder {
  typedef EnumeratedParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(EnumeratedParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(EnumeratedParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(EnumeratedParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(EnumeratedParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(EnumeratedParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(EnumeratedParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  void add_ENUMERATION_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>>> ENUMERATION_LIST) {
    fbb_.AddOffset(EnumeratedParameterType::VT_ENUMERATION_LIST, ENUMERATION_LIST);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(EnumeratedParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit EnumeratedParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumeratedParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumeratedParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumeratedParameterType> CreateEnumeratedParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>>> ENUMERATION_LIST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  EnumeratedParameterTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_ENUMERATION_LIST(ENUMERATION_LIST);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumeratedParameterType> CreateEnumeratedParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr,
    const std::vector<::flatbuffers::Offset<EnumerationValue>> *ENUMERATION_LIST = nullptr,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  auto ENUMERATION_LIST__ = ENUMERATION_LIST ? _fbb.CreateVector<::flatbuffers::Offset<EnumerationValue>>(*ENUMERATION_LIST) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateEnumeratedParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__,
      ENUMERATION_LIST__,
      INITIAL_VALUE__);
}

/// Binary parameter type
struct BinaryParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_INITIAL_VALUE = 12
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const BinaryDataEncoding *DATA_ENCODING() const {
    return GetPointer<const BinaryDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Initial/default value (hex string)
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct BinaryParameterTypeBuilder {
  typedef BinaryParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(BinaryParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(BinaryParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(BinaryParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(BinaryParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(BinaryParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit BinaryParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryParameterType> CreateBinaryParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  BinaryParameterTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BinaryParameterType> CreateBinaryParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING = 0,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateBinaryParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      INITIAL_VALUE__);
}

/// Absolute time parameter type
struct AbsoluteTimeParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AbsoluteTimeParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_EPOCH = 10,
    VT_EPOCH_DATE = 12,
    VT_DATA_ENCODING = 14,
    VT_SCALE = 16,
    VT_OFFSET = 18,
    VT_DEFAULT_ALARM = 20,
    VT_CONTEXT_ALARMS = 22
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Reference epoch
  EpochType EPOCH() const {
    return static_cast<EpochType>(GetField<int8_t>(VT_EPOCH, 2));
  }
  /// Custom epoch date (ISO 8601) when EPOCH=CUSTOM
  const ::flatbuffers::String *EPOCH_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH_DATE);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Time unit scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  /// Time unit offset
  double OFFSET() const {
    return GetField<double>(VT_OFFSET, 0.0);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyField<int8_t>(verifier, VT_EPOCH, 1) &&
           VerifyOffset(verifier, VT_EPOCH_DATE) &&
           verifier.VerifyString(EPOCH_DATE()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<double>(verifier, VT_OFFSET, 8) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           verifier.EndTable();
  }
};

struct AbsoluteTimeParameterTypeBuilder {
  typedef AbsoluteTimeParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_EPOCH(EpochType EPOCH) {
    fbb_.AddElement<int8_t>(AbsoluteTimeParameterType::VT_EPOCH, static_cast<int8_t>(EPOCH), 2);
  }
  void add_EPOCH_DATE(::flatbuffers::Offset<::flatbuffers::String> EPOCH_DATE) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_EPOCH_DATE, EPOCH_DATE);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(AbsoluteTimeParameterType::VT_SCALE, SCALE, 0.0);
  }
  void add_OFFSET(double OFFSET) {
    fbb_.AddElement<double>(AbsoluteTimeParameterType::VT_OFFSET, OFFSET, 0.0);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(AbsoluteTimeParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  explicit AbsoluteTimeParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AbsoluteTimeParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AbsoluteTimeParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AbsoluteTimeParameterType> CreateAbsoluteTimeParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    EpochType EPOCH = EpochType_UNIX,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH_DATE = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    double SCALE = 0.0,
    double OFFSET = 0.0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0) {
  AbsoluteTimeParameterTypeBuilder builder_(_fbb);
  builder_.add_OFFSET(OFFSET);
  builder_.add_SCALE(SCALE);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_EPOCH_DATE(EPOCH_DATE);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_EPOCH(EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AbsoluteTimeParameterType> CreateAbsoluteTimeParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    EpochType EPOCH = EpochType_UNIX,
    const char *EPOCH_DATE = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    double SCALE = 0.0,
    double OFFSET = 0.0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto EPOCH_DATE__ = EPOCH_DATE ? _fbb.CreateString(EPOCH_DATE) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  return CreateAbsoluteTimeParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      EPOCH,
      EPOCH_DATE__,
      DATA_ENCODING,
      SCALE,
      OFFSET,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__);
}

/// Relative time parameter type
struct RelativeTimeParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelativeTimeParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_UNITS = 10,
    VT_DATA_ENCODING = 12,
    VT_DEFAULT_ALARM = 14,
    VT_CONTEXT_ALARMS = 16
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Units
  const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Default alarm
  const DefaultAlarm *DEFAULT_ALARM() const {
    return GetPointer<const DefaultAlarm *>(VT_DEFAULT_ALARM);
  }
  /// Context alarms
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>> *>(VT_CONTEXT_ALARMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(UNITS()) &&
           verifier.VerifyVectorOfTables(UNITS()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_DEFAULT_ALARM) &&
           verifier.VerifyTable(DEFAULT_ALARM()) &&
           VerifyOffset(verifier, VT_CONTEXT_ALARMS) &&
           verifier.VerifyVector(CONTEXT_ALARMS()) &&
           verifier.VerifyVectorOfTables(CONTEXT_ALARMS()) &&
           verifier.EndTable();
  }
};

struct RelativeTimeParameterTypeBuilder {
  typedef RelativeTimeParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_UNITS, UNITS);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_DEFAULT_ALARM(::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  void add_CONTEXT_ALARMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS) {
    fbb_.AddOffset(RelativeTimeParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  explicit RelativeTimeParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RelativeTimeParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RelativeTimeParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RelativeTimeParameterType> CreateRelativeTimeParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContextAlarm>>> CONTEXT_ALARMS = 0) {
  RelativeTimeParameterTypeBuilder builder_(_fbb);
  builder_.add_CONTEXT_ALARMS(CONTEXT_ALARMS);
  builder_.add_DEFAULT_ALARM(DEFAULT_ALARM);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_UNITS(UNITS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RelativeTimeParameterType> CreateRelativeTimeParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<Unit>> *UNITS = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<DefaultAlarm> DEFAULT_ALARM = 0,
    const std::vector<::flatbuffers::Offset<ContextAlarm>> *CONTEXT_ALARMS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto UNITS__ = UNITS ? _fbb.CreateVector<::flatbuffers::Offset<Unit>>(*UNITS) : 0;
  auto CONTEXT_ALARMS__ = CONTEXT_ALARMS ? _fbb.CreateVector<::flatbuffers::Offset<ContextAlarm>>(*CONTEXT_ALARMS) : 0;
  return CreateRelativeTimeParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      UNITS__,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS__);
}

/// Array dimension specification
struct ArrayDimension FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayDimensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_SIZE_PARAMETER_REF = 6
  };
  /// Fixed size of this dimension
  uint32_t SIZE() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  /// Dynamic size from parameter reference
  const ::flatbuffers::String *SIZE_PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIZE_PARAMETER_REF);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyOffset(verifier, VT_SIZE_PARAMETER_REF) &&
           verifier.VerifyString(SIZE_PARAMETER_REF()) &&
           verifier.EndTable();
  }
};

struct ArrayDimensionBuilder {
  typedef ArrayDimension Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SIZE(uint32_t SIZE) {
    fbb_.AddElement<uint32_t>(ArrayDimension::VT_SIZE, SIZE, 0);
  }
  void add_SIZE_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> SIZE_PARAMETER_REF) {
    fbb_.AddOffset(ArrayDimension::VT_SIZE_PARAMETER_REF, SIZE_PARAMETER_REF);
  }
  explicit ArrayDimensionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayDimension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayDimension>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayDimension> CreateArrayDimension(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SIZE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SIZE_PARAMETER_REF = 0) {
  ArrayDimensionBuilder builder_(_fbb);
  builder_.add_SIZE_PARAMETER_REF(SIZE_PARAMETER_REF);
  builder_.add_SIZE(SIZE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayDimension> CreateArrayDimensionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SIZE = 0,
    const char *SIZE_PARAMETER_REF = nullptr) {
  auto SIZE_PARAMETER_REF__ = SIZE_PARAMETER_REF ? _fbb.CreateString(SIZE_PARAMETER_REF) : 0;
  return CreateArrayDimension(
      _fbb,
      SIZE,
      SIZE_PARAMETER_REF__);
}

/// Array parameter type
struct ArrayParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_ARRAY_TYPE_REF = 10,
    VT_DIMENSIONS = 12
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Reference to the array element type
  const ::flatbuffers::String *ARRAY_TYPE_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARRAY_TYPE_REF);
  }
  /// Dimension list
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArrayDimension>> *DIMENSIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArrayDimension>> *>(VT_DIMENSIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_ARRAY_TYPE_REF) &&
           verifier.VerifyString(ARRAY_TYPE_REF()) &&
           VerifyOffset(verifier, VT_DIMENSIONS) &&
           verifier.VerifyVector(DIMENSIONS()) &&
           verifier.VerifyVectorOfTables(DIMENSIONS()) &&
           verifier.EndTable();
  }
};

struct ArrayParameterTypeBuilder {
  typedef ArrayParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(ArrayParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(ArrayParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(ArrayParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_ARRAY_TYPE_REF(::flatbuffers::Offset<::flatbuffers::String> ARRAY_TYPE_REF) {
    fbb_.AddOffset(ArrayParameterType::VT_ARRAY_TYPE_REF, ARRAY_TYPE_REF);
  }
  void add_DIMENSIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArrayDimension>>> DIMENSIONS) {
    fbb_.AddOffset(ArrayParameterType::VT_DIMENSIONS, DIMENSIONS);
  }
  explicit ArrayParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayParameterType> CreateArrayParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ARRAY_TYPE_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArrayDimension>>> DIMENSIONS = 0) {
  ArrayParameterTypeBuilder builder_(_fbb);
  builder_.add_DIMENSIONS(DIMENSIONS);
  builder_.add_ARRAY_TYPE_REF(ARRAY_TYPE_REF);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayParameterType> CreateArrayParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const char *ARRAY_TYPE_REF = nullptr,
    const std::vector<::flatbuffers::Offset<ArrayDimension>> *DIMENSIONS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ARRAY_TYPE_REF__ = ARRAY_TYPE_REF ? _fbb.CreateString(ARRAY_TYPE_REF) : 0;
  auto DIMENSIONS__ = DIMENSIONS ? _fbb.CreateVector<::flatbuffers::Offset<ArrayDimension>>(*DIMENSIONS) : 0;
  return CreateArrayParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      ARRAY_TYPE_REF__,
      DIMENSIONS__);
}

/// Aggregate member definition
struct AggregateMember FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AggregateMemberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE_REF = 6,
    VT_SHORT_DESCRIPTION = 8
  };
  /// Member name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Reference to parameter type
  const ::flatbuffers::String *TYPE_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_REF);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_TYPE_REF) &&
           verifier.VerifyString(TYPE_REF()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           verifier.EndTable();
  }
};

struct AggregateMemberBuilder {
  typedef AggregateMember Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(AggregateMember::VT_NAME, NAME);
  }
  void add_TYPE_REF(::flatbuffers::Offset<::flatbuffers::String> TYPE_REF) {
    fbb_.AddOffset(AggregateMember::VT_TYPE_REF, TYPE_REF);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(AggregateMember::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  explicit AggregateMemberBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AggregateMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AggregateMember>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AggregateMember> CreateAggregateMember(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0) {
  AggregateMemberBuilder builder_(_fbb);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_TYPE_REF(TYPE_REF);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AggregateMember> CreateAggregateMemberDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *TYPE_REF = nullptr,
    const char *SHORT_DESCRIPTION = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto TYPE_REF__ = TYPE_REF ? _fbb.CreateString(TYPE_REF) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  return CreateAggregateMember(
      _fbb,
      NAME__,
      TYPE_REF__,
      SHORT_DESCRIPTION__);
}

/// Aggregate parameter type (structure)
struct AggregateParameterType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AggregateParameterTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_MEMBERS = 10
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Member list
  const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>> *MEMBERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>> *>(VT_MEMBERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(MEMBERS()) &&
           verifier.VerifyVectorOfTables(MEMBERS()) &&
           verifier.EndTable();
  }
};

struct AggregateParameterTypeBuilder {
  typedef AggregateParameterType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(AggregateParameterType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(AggregateParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(AggregateParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_MEMBERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>>> MEMBERS) {
    fbb_.AddOffset(AggregateParameterType::VT_MEMBERS, MEMBERS);
  }
  explicit AggregateParameterTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AggregateParameterType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AggregateParameterType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AggregateParameterType> CreateAggregateParameterType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>>> MEMBERS = 0) {
  AggregateParameterTypeBuilder builder_(_fbb);
  builder_.add_MEMBERS(MEMBERS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AggregateParameterType> CreateAggregateParameterTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<AggregateMember>> *MEMBERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto MEMBERS__ = MEMBERS ? _fbb.CreateVector<::flatbuffers::Offset<AggregateMember>>(*MEMBERS) : 0;
  return CreateAggregateParameterType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      MEMBERS__);
}

/// Collection of all parameter types
struct ParameterTypeSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterTypeSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGER_TYPES = 4,
    VT_FLOAT_TYPES = 6,
    VT_STRING_TYPES = 8,
    VT_BOOLEAN_TYPES = 10,
    VT_ENUMERATED_TYPES = 12,
    VT_BINARY_TYPES = 14,
    VT_ABSOLUTE_TIME_TYPES = 16,
    VT_RELATIVE_TIME_TYPES = 18,
    VT_ARRAY_TYPES = 20,
    VT_AGGREGATE_TYPES = 22
  };
  /// Integer parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerParameterType>> *INTEGER_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerParameterType>> *>(VT_INTEGER_TYPES);
  }
  /// Float parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<FloatParameterType>> *FLOAT_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FloatParameterType>> *>(VT_FLOAT_TYPES);
  }
  /// String parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<StringParameterType>> *STRING_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StringParameterType>> *>(VT_STRING_TYPES);
  }
  /// Boolean parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanParameterType>> *BOOLEAN_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanParameterType>> *>(VT_BOOLEAN_TYPES);
  }
  /// Enumerated parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedParameterType>> *ENUMERATED_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedParameterType>> *>(VT_ENUMERATED_TYPES);
  }
  /// Binary parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<BinaryParameterType>> *BINARY_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BinaryParameterType>> *>(VT_BINARY_TYPES);
  }
  /// Absolute time parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<AbsoluteTimeParameterType>> *ABSOLUTE_TIME_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AbsoluteTimeParameterType>> *>(VT_ABSOLUTE_TIME_TYPES);
  }
  /// Relative time parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<RelativeTimeParameterType>> *RELATIVE_TIME_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RelativeTimeParameterType>> *>(VT_RELATIVE_TIME_TYPES);
  }
  /// Array parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArrayParameterType>> *ARRAY_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArrayParameterType>> *>(VT_ARRAY_TYPES);
  }
  /// Aggregate parameter types
  const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateParameterType>> *AGGREGATE_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateParameterType>> *>(VT_AGGREGATE_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTEGER_TYPES) &&
           verifier.VerifyVector(INTEGER_TYPES()) &&
           verifier.VerifyVectorOfTables(INTEGER_TYPES()) &&
           VerifyOffset(verifier, VT_FLOAT_TYPES) &&
           verifier.VerifyVector(FLOAT_TYPES()) &&
           verifier.VerifyVectorOfTables(FLOAT_TYPES()) &&
           VerifyOffset(verifier, VT_STRING_TYPES) &&
           verifier.VerifyVector(STRING_TYPES()) &&
           verifier.VerifyVectorOfTables(STRING_TYPES()) &&
           VerifyOffset(verifier, VT_BOOLEAN_TYPES) &&
           verifier.VerifyVector(BOOLEAN_TYPES()) &&
           verifier.VerifyVectorOfTables(BOOLEAN_TYPES()) &&
           VerifyOffset(verifier, VT_ENUMERATED_TYPES) &&
           verifier.VerifyVector(ENUMERATED_TYPES()) &&
           verifier.VerifyVectorOfTables(ENUMERATED_TYPES()) &&
           VerifyOffset(verifier, VT_BINARY_TYPES) &&
           verifier.VerifyVector(BINARY_TYPES()) &&
           verifier.VerifyVectorOfTables(BINARY_TYPES()) &&
           VerifyOffset(verifier, VT_ABSOLUTE_TIME_TYPES) &&
           verifier.VerifyVector(ABSOLUTE_TIME_TYPES()) &&
           verifier.VerifyVectorOfTables(ABSOLUTE_TIME_TYPES()) &&
           VerifyOffset(verifier, VT_RELATIVE_TIME_TYPES) &&
           verifier.VerifyVector(RELATIVE_TIME_TYPES()) &&
           verifier.VerifyVectorOfTables(RELATIVE_TIME_TYPES()) &&
           VerifyOffset(verifier, VT_ARRAY_TYPES) &&
           verifier.VerifyVector(ARRAY_TYPES()) &&
           verifier.VerifyVectorOfTables(ARRAY_TYPES()) &&
           VerifyOffset(verifier, VT_AGGREGATE_TYPES) &&
           verifier.VerifyVector(AGGREGATE_TYPES()) &&
           verifier.VerifyVectorOfTables(AGGREGATE_TYPES()) &&
           verifier.EndTable();
  }
};

struct ParameterTypeSetBuilder {
  typedef ParameterTypeSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_INTEGER_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerParameterType>>> INTEGER_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_INTEGER_TYPES, INTEGER_TYPES);
  }
  void add_FLOAT_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FloatParameterType>>> FLOAT_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_FLOAT_TYPES, FLOAT_TYPES);
  }
  void add_STRING_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StringParameterType>>> STRING_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_STRING_TYPES, STRING_TYPES);
  }
  void add_BOOLEAN_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanParameterType>>> BOOLEAN_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_BOOLEAN_TYPES, BOOLEAN_TYPES);
  }
  void add_ENUMERATED_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedParameterType>>> ENUMERATED_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_ENUMERATED_TYPES, ENUMERATED_TYPES);
  }
  void add_BINARY_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BinaryParameterType>>> BINARY_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_BINARY_TYPES, BINARY_TYPES);
  }
  void add_ABSOLUTE_TIME_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AbsoluteTimeParameterType>>> ABSOLUTE_TIME_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_ABSOLUTE_TIME_TYPES, ABSOLUTE_TIME_TYPES);
  }
  void add_RELATIVE_TIME_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RelativeTimeParameterType>>> RELATIVE_TIME_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_RELATIVE_TIME_TYPES, RELATIVE_TIME_TYPES);
  }
  void add_ARRAY_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArrayParameterType>>> ARRAY_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_ARRAY_TYPES, ARRAY_TYPES);
  }
  void add_AGGREGATE_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateParameterType>>> AGGREGATE_TYPES) {
    fbb_.AddOffset(ParameterTypeSet::VT_AGGREGATE_TYPES, AGGREGATE_TYPES);
  }
  explicit ParameterTypeSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterTypeSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterTypeSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterTypeSet> CreateParameterTypeSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerParameterType>>> INTEGER_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FloatParameterType>>> FLOAT_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StringParameterType>>> STRING_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanParameterType>>> BOOLEAN_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedParameterType>>> ENUMERATED_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BinaryParameterType>>> BINARY_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AbsoluteTimeParameterType>>> ABSOLUTE_TIME_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RelativeTimeParameterType>>> RELATIVE_TIME_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArrayParameterType>>> ARRAY_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateParameterType>>> AGGREGATE_TYPES = 0) {
  ParameterTypeSetBuilder builder_(_fbb);
  builder_.add_AGGREGATE_TYPES(AGGREGATE_TYPES);
  builder_.add_ARRAY_TYPES(ARRAY_TYPES);
  builder_.add_RELATIVE_TIME_TYPES(RELATIVE_TIME_TYPES);
  builder_.add_ABSOLUTE_TIME_TYPES(ABSOLUTE_TIME_TYPES);
  builder_.add_BINARY_TYPES(BINARY_TYPES);
  builder_.add_ENUMERATED_TYPES(ENUMERATED_TYPES);
  builder_.add_BOOLEAN_TYPES(BOOLEAN_TYPES);
  builder_.add_STRING_TYPES(STRING_TYPES);
  builder_.add_FLOAT_TYPES(FLOAT_TYPES);
  builder_.add_INTEGER_TYPES(INTEGER_TYPES);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParameterTypeSet> CreateParameterTypeSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<IntegerParameterType>> *INTEGER_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<FloatParameterType>> *FLOAT_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<StringParameterType>> *STRING_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<BooleanParameterType>> *BOOLEAN_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<EnumeratedParameterType>> *ENUMERATED_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<BinaryParameterType>> *BINARY_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<AbsoluteTimeParameterType>> *ABSOLUTE_TIME_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<RelativeTimeParameterType>> *RELATIVE_TIME_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<ArrayParameterType>> *ARRAY_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<AggregateParameterType>> *AGGREGATE_TYPES = nullptr) {
  auto INTEGER_TYPES__ = INTEGER_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<IntegerParameterType>>(*INTEGER_TYPES) : 0;
  auto FLOAT_TYPES__ = FLOAT_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<FloatParameterType>>(*FLOAT_TYPES) : 0;
  auto STRING_TYPES__ = STRING_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<StringParameterType>>(*STRING_TYPES) : 0;
  auto BOOLEAN_TYPES__ = BOOLEAN_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<BooleanParameterType>>(*BOOLEAN_TYPES) : 0;
  auto ENUMERATED_TYPES__ = ENUMERATED_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<EnumeratedParameterType>>(*ENUMERATED_TYPES) : 0;
  auto BINARY_TYPES__ = BINARY_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<BinaryParameterType>>(*BINARY_TYPES) : 0;
  auto ABSOLUTE_TIME_TYPES__ = ABSOLUTE_TIME_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<AbsoluteTimeParameterType>>(*ABSOLUTE_TIME_TYPES) : 0;
  auto RELATIVE_TIME_TYPES__ = RELATIVE_TIME_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<RelativeTimeParameterType>>(*RELATIVE_TIME_TYPES) : 0;
  auto ARRAY_TYPES__ = ARRAY_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<ArrayParameterType>>(*ARRAY_TYPES) : 0;
  auto AGGREGATE_TYPES__ = AGGREGATE_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<AggregateParameterType>>(*AGGREGATE_TYPES) : 0;
  return CreateParameterTypeSet(
      _fbb,
      INTEGER_TYPES__,
      FLOAT_TYPES__,
      STRING_TYPES__,
      BOOLEAN_TYPES__,
      ENUMERATED_TYPES__,
      BINARY_TYPES__,
      ABSOLUTE_TIME_TYPES__,
      RELATIVE_TIME_TYPES__,
      ARRAY_TYPES__,
      AGGREGATE_TYPES__);
}

/// Parameter properties
struct ParameterProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_SOURCE = 4,
    VT_READ_ONLY = 6,
    VT_SYSTEM_NAME = 8,
    VT_VALIDITY_CONDITION = 10
  };
  /// Data source type
  DataSourceType DATA_SOURCE() const {
    return static_cast<DataSourceType>(GetField<int8_t>(VT_DATA_SOURCE, 0));
  }
  /// Read-only parameter
  bool READ_ONLY() const {
    return GetField<uint8_t>(VT_READ_ONLY, 1) != 0;
  }
  /// System/subsystem name
  const ::flatbuffers::String *SYSTEM_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYSTEM_NAME);
  }
  /// Validity condition
  const MatchCriteria *VALIDITY_CONDITION() const {
    return GetPointer<const MatchCriteria *>(VT_VALIDITY_CONDITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DATA_SOURCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_READ_ONLY, 1) &&
           VerifyOffset(verifier, VT_SYSTEM_NAME) &&
           verifier.VerifyString(SYSTEM_NAME()) &&
           VerifyOffset(verifier, VT_VALIDITY_CONDITION) &&
           verifier.VerifyTable(VALIDITY_CONDITION()) &&
           verifier.EndTable();
  }
};

struct ParameterPropertiesBuilder {
  typedef ParameterProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DATA_SOURCE(DataSourceType DATA_SOURCE) {
    fbb_.AddElement<int8_t>(ParameterProperties::VT_DATA_SOURCE, static_cast<int8_t>(DATA_SOURCE), 0);
  }
  void add_READ_ONLY(bool READ_ONLY) {
    fbb_.AddElement<uint8_t>(ParameterProperties::VT_READ_ONLY, static_cast<uint8_t>(READ_ONLY), 1);
  }
  void add_SYSTEM_NAME(::flatbuffers::Offset<::flatbuffers::String> SYSTEM_NAME) {
    fbb_.AddOffset(ParameterProperties::VT_SYSTEM_NAME, SYSTEM_NAME);
  }
  void add_VALIDITY_CONDITION(::flatbuffers::Offset<MatchCriteria> VALIDITY_CONDITION) {
    fbb_.AddOffset(ParameterProperties::VT_VALIDITY_CONDITION, VALIDITY_CONDITION);
  }
  explicit ParameterPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterProperties>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterProperties> CreateParameterProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DataSourceType DATA_SOURCE = DataSourceType_TELEMETERED,
    bool READ_ONLY = true,
    ::flatbuffers::Offset<::flatbuffers::String> SYSTEM_NAME = 0,
    ::flatbuffers::Offset<MatchCriteria> VALIDITY_CONDITION = 0) {
  ParameterPropertiesBuilder builder_(_fbb);
  builder_.add_VALIDITY_CONDITION(VALIDITY_CONDITION);
  builder_.add_SYSTEM_NAME(SYSTEM_NAME);
  builder_.add_READ_ONLY(READ_ONLY);
  builder_.add_DATA_SOURCE(DATA_SOURCE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParameterProperties> CreateParameterPropertiesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DataSourceType DATA_SOURCE = DataSourceType_TELEMETERED,
    bool READ_ONLY = true,
    const char *SYSTEM_NAME = nullptr,
    ::flatbuffers::Offset<MatchCriteria> VALIDITY_CONDITION = 0) {
  auto SYSTEM_NAME__ = SYSTEM_NAME ? _fbb.CreateString(SYSTEM_NAME) : 0;
  return CreateParameterProperties(
      _fbb,
      DATA_SOURCE,
      READ_ONLY,
      SYSTEM_NAME__,
      VALIDITY_CONDITION);
}

/// Parameter definition
struct Parameter FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARAMETER_TYPE_REF = 6,
    VT_SHORT_DESCRIPTION = 8,
    VT_LONG_DESCRIPTION = 10,
    VT_PROPERTIES = 12,
    VT_PHYSICAL_ADDRESS = 14,
    VT_INITIAL_VALUE = 16
  };
  /// Parameter name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Reference to parameter type
  const ::flatbuffers::String *PARAMETER_TYPE_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_TYPE_REF);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Parameter properties
  const ParameterProperties *PROPERTIES() const {
    return GetPointer<const ParameterProperties *>(VT_PROPERTIES);
  }
  /// Physical address mapping
  const ::flatbuffers::String *PHYSICAL_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHYSICAL_ADDRESS);
  }
  /// Initial/default value
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPE_REF) &&
           verifier.VerifyString(PARAMETER_TYPE_REF()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyTable(PROPERTIES()) &&
           VerifyOffset(verifier, VT_PHYSICAL_ADDRESS) &&
           verifier.VerifyString(PHYSICAL_ADDRESS()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct ParameterBuilder {
  typedef Parameter Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(Parameter::VT_NAME, NAME);
  }
  void add_PARAMETER_TYPE_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_TYPE_REF) {
    fbb_.AddOffset(Parameter::VT_PARAMETER_TYPE_REF, PARAMETER_TYPE_REF);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(Parameter::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(Parameter::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_PROPERTIES(::flatbuffers::Offset<ParameterProperties> PROPERTIES) {
    fbb_.AddOffset(Parameter::VT_PROPERTIES, PROPERTIES);
  }
  void add_PHYSICAL_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> PHYSICAL_ADDRESS) {
    fbb_.AddOffset(Parameter::VT_PHYSICAL_ADDRESS, PHYSICAL_ADDRESS);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(Parameter::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit ParameterBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Parameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Parameter>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Parameter> CreateParameter(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_TYPE_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<ParameterProperties> PROPERTIES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PHYSICAL_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  ParameterBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_PHYSICAL_ADDRESS(PHYSICAL_ADDRESS);
  builder_.add_PROPERTIES(PROPERTIES);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_PARAMETER_TYPE_REF(PARAMETER_TYPE_REF);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Parameter> CreateParameterDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *PARAMETER_TYPE_REF = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<ParameterProperties> PROPERTIES = 0,
    const char *PHYSICAL_ADDRESS = nullptr,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto PARAMETER_TYPE_REF__ = PARAMETER_TYPE_REF ? _fbb.CreateString(PARAMETER_TYPE_REF) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto PHYSICAL_ADDRESS__ = PHYSICAL_ADDRESS ? _fbb.CreateString(PHYSICAL_ADDRESS) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateParameter(
      _fbb,
      NAME__,
      PARAMETER_TYPE_REF__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      PROPERTIES,
      PHYSICAL_ADDRESS__,
      INITIAL_VALUE__);
}

/// Collection of parameters
struct ParameterSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETERS = 4
  };
  /// Parameters
  const ::flatbuffers::Vector<::flatbuffers::Offset<Parameter>> *PARAMETERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Parameter>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(PARAMETERS()) &&
           verifier.VerifyVectorOfTables(PARAMETERS()) &&
           verifier.EndTable();
  }
};

struct ParameterSetBuilder {
  typedef ParameterSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Parameter>>> PARAMETERS) {
    fbb_.AddOffset(ParameterSet::VT_PARAMETERS, PARAMETERS);
  }
  explicit ParameterSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterSet> CreateParameterSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Parameter>>> PARAMETERS = 0) {
  ParameterSetBuilder builder_(_fbb);
  builder_.add_PARAMETERS(PARAMETERS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParameterSet> CreateParameterSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Parameter>> *PARAMETERS = nullptr) {
  auto PARAMETERS__ = PARAMETERS ? _fbb.CreateVector<::flatbuffers::Offset<Parameter>>(*PARAMETERS) : 0;
  return CreateParameterSet(
      _fbb,
      PARAMETERS__);
}

/// Location specification within a container
struct LocationInContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocationInContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_LOCATION = 4,
    VT_OFFSET_IN_BITS = 6
  };
  /// Reference location type
  ReferenceLocationType REFERENCE_LOCATION() const {
    return static_cast<ReferenceLocationType>(GetField<int8_t>(VT_REFERENCE_LOCATION, 2));
  }
  /// Offset in bits from reference location
  int32_t OFFSET_IN_BITS() const {
    return GetField<int32_t>(VT_OFFSET_IN_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REFERENCE_LOCATION, 1) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_IN_BITS, 4) &&
           verifier.EndTable();
  }
};

struct LocationInContainerBuilder {
  typedef LocationInContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_REFERENCE_LOCATION(ReferenceLocationType REFERENCE_LOCATION) {
    fbb_.AddElement<int8_t>(LocationInContainer::VT_REFERENCE_LOCATION, static_cast<int8_t>(REFERENCE_LOCATION), 2);
  }
  void add_OFFSET_IN_BITS(int32_t OFFSET_IN_BITS) {
    fbb_.AddElement<int32_t>(LocationInContainer::VT_OFFSET_IN_BITS, OFFSET_IN_BITS, 0);
  }
  explicit LocationInContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocationInContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocationInContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocationInContainer> CreateLocationInContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ReferenceLocationType REFERENCE_LOCATION = ReferenceLocationType_PREVIOUS_ENTRY,
    int32_t OFFSET_IN_BITS = 0) {
  LocationInContainerBuilder builder_(_fbb);
  builder_.add_OFFSET_IN_BITS(OFFSET_IN_BITS);
  builder_.add_REFERENCE_LOCATION(REFERENCE_LOCATION);
  return builder_.Finish();
}

/// Repeat entry specification
struct RepeatEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RepeatEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT = 4,
    VT_COUNT_PARAMETER_REF = 6,
    VT_OFFSET_IN_BITS = 8
  };
  /// Fixed repeat count
  uint32_t COUNT() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  /// Dynamic count from parameter reference
  const ::flatbuffers::String *COUNT_PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNT_PARAMETER_REF);
  }
  /// Offset in bits between repetitions
  int32_t OFFSET_IN_BITS() const {
    return GetField<int32_t>(VT_OFFSET_IN_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyOffset(verifier, VT_COUNT_PARAMETER_REF) &&
           verifier.VerifyString(COUNT_PARAMETER_REF()) &&
           VerifyField<int32_t>(verifier, VT_OFFSET_IN_BITS, 4) &&
           verifier.EndTable();
  }
};

struct RepeatEntryBuilder {
  typedef RepeatEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COUNT(uint32_t COUNT) {
    fbb_.AddElement<uint32_t>(RepeatEntry::VT_COUNT, COUNT, 0);
  }
  void add_COUNT_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> COUNT_PARAMETER_REF) {
    fbb_.AddOffset(RepeatEntry::VT_COUNT_PARAMETER_REF, COUNT_PARAMETER_REF);
  }
  void add_OFFSET_IN_BITS(int32_t OFFSET_IN_BITS) {
    fbb_.AddElement<int32_t>(RepeatEntry::VT_OFFSET_IN_BITS, OFFSET_IN_BITS, 0);
  }
  explicit RepeatEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RepeatEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RepeatEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RepeatEntry> CreateRepeatEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t COUNT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COUNT_PARAMETER_REF = 0,
    int32_t OFFSET_IN_BITS = 0) {
  RepeatEntryBuilder builder_(_fbb);
  builder_.add_OFFSET_IN_BITS(OFFSET_IN_BITS);
  builder_.add_COUNT_PARAMETER_REF(COUNT_PARAMETER_REF);
  builder_.add_COUNT(COUNT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RepeatEntry> CreateRepeatEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t COUNT = 0,
    const char *COUNT_PARAMETER_REF = nullptr,
    int32_t OFFSET_IN_BITS = 0) {
  auto COUNT_PARAMETER_REF__ = COUNT_PARAMETER_REF ? _fbb.CreateString(COUNT_PARAMETER_REF) : 0;
  return CreateRepeatEntry(
      _fbb,
      COUNT,
      COUNT_PARAMETER_REF__,
      OFFSET_IN_BITS);
}

/// Parameter reference entry in container
struct ParameterRefEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterRefEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_LOCATION = 6,
    VT_REPEAT = 8,
    VT_INCLUDE_CONDITION = 10,
    VT_SHORT_DESCRIPTION = 12
  };
  /// Parameter reference path
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Location in container
  const LocationInContainer *LOCATION() const {
    return GetPointer<const LocationInContainer *>(VT_LOCATION);
  }
  /// Repeat specification
  const RepeatEntry *REPEAT() const {
    return GetPointer<const RepeatEntry *>(VT_REPEAT);
  }
  /// Include condition
  const MatchCriteria *INCLUDE_CONDITION() const {
    return GetPointer<const MatchCriteria *>(VT_INCLUDE_CONDITION);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(LOCATION()) &&
           VerifyOffset(verifier, VT_REPEAT) &&
           verifier.VerifyTable(REPEAT()) &&
           VerifyOffset(verifier, VT_INCLUDE_CONDITION) &&
           verifier.VerifyTable(INCLUDE_CONDITION()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           verifier.EndTable();
  }
};

struct ParameterRefEntryBuilder {
  typedef ParameterRefEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(ParameterRefEntry::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_LOCATION(::flatbuffers::Offset<LocationInContainer> LOCATION) {
    fbb_.AddOffset(ParameterRefEntry::VT_LOCATION, LOCATION);
  }
  void add_REPEAT(::flatbuffers::Offset<RepeatEntry> REPEAT) {
    fbb_.AddOffset(ParameterRefEntry::VT_REPEAT, REPEAT);
  }
  void add_INCLUDE_CONDITION(::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION) {
    fbb_.AddOffset(ParameterRefEntry::VT_INCLUDE_CONDITION, INCLUDE_CONDITION);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(ParameterRefEntry::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  explicit ParameterRefEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterRefEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterRefEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterRefEntry> CreateParameterRefEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    ::flatbuffers::Offset<RepeatEntry> REPEAT = 0,
    ::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0) {
  ParameterRefEntryBuilder builder_(_fbb);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_INCLUDE_CONDITION(INCLUDE_CONDITION);
  builder_.add_REPEAT(REPEAT);
  builder_.add_LOCATION(LOCATION);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ParameterRefEntry> CreateParameterRefEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    ::flatbuffers::Offset<RepeatEntry> REPEAT = 0,
    ::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION = 0,
    const char *SHORT_DESCRIPTION = nullptr) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  return CreateParameterRefEntry(
      _fbb,
      PARAMETER_REF__,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION,
      SHORT_DESCRIPTION__);
}

/// Container reference entry (nested container)
struct ContainerRefEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContainerRefEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAINER_REF = 4,
    VT_LOCATION = 6,
    VT_REPEAT = 8,
    VT_INCLUDE_CONDITION = 10
  };
  /// Container reference path
  const ::flatbuffers::String *CONTAINER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER_REF);
  }
  /// Location in container
  const LocationInContainer *LOCATION() const {
    return GetPointer<const LocationInContainer *>(VT_LOCATION);
  }
  /// Repeat specification
  const RepeatEntry *REPEAT() const {
    return GetPointer<const RepeatEntry *>(VT_REPEAT);
  }
  /// Include condition
  const MatchCriteria *INCLUDE_CONDITION() const {
    return GetPointer<const MatchCriteria *>(VT_INCLUDE_CONDITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAINER_REF) &&
           verifier.VerifyString(CONTAINER_REF()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(LOCATION()) &&
           VerifyOffset(verifier, VT_REPEAT) &&
           verifier.VerifyTable(REPEAT()) &&
           VerifyOffset(verifier, VT_INCLUDE_CONDITION) &&
           verifier.VerifyTable(INCLUDE_CONDITION()) &&
           verifier.EndTable();
  }
};

struct ContainerRefEntryBuilder {
  typedef ContainerRefEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CONTAINER_REF(::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF) {
    fbb_.AddOffset(ContainerRefEntry::VT_CONTAINER_REF, CONTAINER_REF);
  }
  void add_LOCATION(::flatbuffers::Offset<LocationInContainer> LOCATION) {
    fbb_.AddOffset(ContainerRefEntry::VT_LOCATION, LOCATION);
  }
  void add_REPEAT(::flatbuffers::Offset<RepeatEntry> REPEAT) {
    fbb_.AddOffset(ContainerRefEntry::VT_REPEAT, REPEAT);
  }
  void add_INCLUDE_CONDITION(::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION) {
    fbb_.AddOffset(ContainerRefEntry::VT_INCLUDE_CONDITION, INCLUDE_CONDITION);
  }
  explicit ContainerRefEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContainerRefEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContainerRefEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContainerRefEntry> CreateContainerRefEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF = 0,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    ::flatbuffers::Offset<RepeatEntry> REPEAT = 0,
    ::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION = 0) {
  ContainerRefEntryBuilder builder_(_fbb);
  builder_.add_INCLUDE_CONDITION(INCLUDE_CONDITION);
  builder_.add_REPEAT(REPEAT);
  builder_.add_LOCATION(LOCATION);
  builder_.add_CONTAINER_REF(CONTAINER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContainerRefEntry> CreateContainerRefEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CONTAINER_REF = nullptr,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    ::flatbuffers::Offset<RepeatEntry> REPEAT = 0,
    ::flatbuffers::Offset<MatchCriteria> INCLUDE_CONDITION = 0) {
  auto CONTAINER_REF__ = CONTAINER_REF ? _fbb.CreateString(CONTAINER_REF) : 0;
  return CreateContainerRefEntry(
      _fbb,
      CONTAINER_REF__,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION);
}

/// Fixed value entry (static padding/header)
struct FixedValueEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixedValueEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BINARY_VALUE = 4,
    VT_SIZE_IN_BITS = 6,
    VT_NAME = 8,
    VT_LOCATION = 10
  };
  /// Binary value (hex string)
  const ::flatbuffers::String *BINARY_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BINARY_VALUE);
  }
  /// Size in bits
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Name/description
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Location in container
  const LocationInContainer *LOCATION() const {
    return GetPointer<const LocationInContainer *>(VT_LOCATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BINARY_VALUE) &&
           verifier.VerifyString(BINARY_VALUE()) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(LOCATION()) &&
           verifier.EndTable();
  }
};

struct FixedValueEntryBuilder {
  typedef FixedValueEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_BINARY_VALUE(::flatbuffers::Offset<::flatbuffers::String> BINARY_VALUE) {
    fbb_.AddOffset(FixedValueEntry::VT_BINARY_VALUE, BINARY_VALUE);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(FixedValueEntry::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(FixedValueEntry::VT_NAME, NAME);
  }
  void add_LOCATION(::flatbuffers::Offset<LocationInContainer> LOCATION) {
    fbb_.AddOffset(FixedValueEntry::VT_LOCATION, LOCATION);
  }
  explicit FixedValueEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FixedValueEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FixedValueEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FixedValueEntry> CreateFixedValueEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> BINARY_VALUE = 0,
    uint16_t SIZE_IN_BITS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0) {
  FixedValueEntryBuilder builder_(_fbb);
  builder_.add_LOCATION(LOCATION);
  builder_.add_NAME(NAME);
  builder_.add_BINARY_VALUE(BINARY_VALUE);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FixedValueEntry> CreateFixedValueEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *BINARY_VALUE = nullptr,
    uint16_t SIZE_IN_BITS = 0,
    const char *NAME = nullptr,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0) {
  auto BINARY_VALUE__ = BINARY_VALUE ? _fbb.CreateString(BINARY_VALUE) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  return CreateFixedValueEntry(
      _fbb,
      BINARY_VALUE__,
      SIZE_IN_BITS,
      NAME__,
      LOCATION);
}

/// Array parameter reference entry
struct ArrayParameterRefEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArrayParameterRefEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_LOCATION = 6,
    VT_FIRST_INDEX = 8,
    VT_LAST_INDEX = 10
  };
  /// Parameter reference path
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Location in container
  const LocationInContainer *LOCATION() const {
    return GetPointer<const LocationInContainer *>(VT_LOCATION);
  }
  /// First index to include
  uint32_t FIRST_INDEX() const {
    return GetField<uint32_t>(VT_FIRST_INDEX, 0);
  }
  /// Last index to include
  uint32_t LAST_INDEX() const {
    return GetField<uint32_t>(VT_LAST_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(LOCATION()) &&
           VerifyField<uint32_t>(verifier, VT_FIRST_INDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_LAST_INDEX, 4) &&
           verifier.EndTable();
  }
};

struct ArrayParameterRefEntryBuilder {
  typedef ArrayParameterRefEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(ArrayParameterRefEntry::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_LOCATION(::flatbuffers::Offset<LocationInContainer> LOCATION) {
    fbb_.AddOffset(ArrayParameterRefEntry::VT_LOCATION, LOCATION);
  }
  void add_FIRST_INDEX(uint32_t FIRST_INDEX) {
    fbb_.AddElement<uint32_t>(ArrayParameterRefEntry::VT_FIRST_INDEX, FIRST_INDEX, 0);
  }
  void add_LAST_INDEX(uint32_t LAST_INDEX) {
    fbb_.AddElement<uint32_t>(ArrayParameterRefEntry::VT_LAST_INDEX, LAST_INDEX, 0);
  }
  explicit ArrayParameterRefEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArrayParameterRefEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArrayParameterRefEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArrayParameterRefEntry> CreateArrayParameterRefEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    uint32_t FIRST_INDEX = 0,
    uint32_t LAST_INDEX = 0) {
  ArrayParameterRefEntryBuilder builder_(_fbb);
  builder_.add_LAST_INDEX(LAST_INDEX);
  builder_.add_FIRST_INDEX(FIRST_INDEX);
  builder_.add_LOCATION(LOCATION);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArrayParameterRefEntry> CreateArrayParameterRefEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    uint32_t FIRST_INDEX = 0,
    uint32_t LAST_INDEX = 0) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  return CreateArrayParameterRefEntry(
      _fbb,
      PARAMETER_REF__,
      LOCATION,
      FIRST_INDEX,
      LAST_INDEX);
}

/// Container entry list item (union of entry types)
struct ContainerEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContainerEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF_ENTRY = 4,
    VT_CONTAINER_REF_ENTRY = 6,
    VT_FIXED_VALUE_ENTRY = 8,
    VT_ARRAY_PARAMETER_REF_ENTRY = 10
  };
  /// Parameter reference entry
  const ParameterRefEntry *PARAMETER_REF_ENTRY() const {
    return GetPointer<const ParameterRefEntry *>(VT_PARAMETER_REF_ENTRY);
  }
  /// Container reference entry
  const ContainerRefEntry *CONTAINER_REF_ENTRY() const {
    return GetPointer<const ContainerRefEntry *>(VT_CONTAINER_REF_ENTRY);
  }
  /// Fixed value entry
  const FixedValueEntry *FIXED_VALUE_ENTRY() const {
    return GetPointer<const FixedValueEntry *>(VT_FIXED_VALUE_ENTRY);
  }
  /// Array parameter reference entry
  const ArrayParameterRefEntry *ARRAY_PARAMETER_REF_ENTRY() const {
    return GetPointer<const ArrayParameterRefEntry *>(VT_ARRAY_PARAMETER_REF_ENTRY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF_ENTRY) &&
           verifier.VerifyTable(PARAMETER_REF_ENTRY()) &&
           VerifyOffset(verifier, VT_CONTAINER_REF_ENTRY) &&
           verifier.VerifyTable(CONTAINER_REF_ENTRY()) &&
           VerifyOffset(verifier, VT_FIXED_VALUE_ENTRY) &&
           verifier.VerifyTable(FIXED_VALUE_ENTRY()) &&
           VerifyOffset(verifier, VT_ARRAY_PARAMETER_REF_ENTRY) &&
           verifier.VerifyTable(ARRAY_PARAMETER_REF_ENTRY()) &&
           verifier.EndTable();
  }
};

struct ContainerEntryBuilder {
  typedef ContainerEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF_ENTRY(::flatbuffers::Offset<ParameterRefEntry> PARAMETER_REF_ENTRY) {
    fbb_.AddOffset(ContainerEntry::VT_PARAMETER_REF_ENTRY, PARAMETER_REF_ENTRY);
  }
  void add_CONTAINER_REF_ENTRY(::flatbuffers::Offset<ContainerRefEntry> CONTAINER_REF_ENTRY) {
    fbb_.AddOffset(ContainerEntry::VT_CONTAINER_REF_ENTRY, CONTAINER_REF_ENTRY);
  }
  void add_FIXED_VALUE_ENTRY(::flatbuffers::Offset<FixedValueEntry> FIXED_VALUE_ENTRY) {
    fbb_.AddOffset(ContainerEntry::VT_FIXED_VALUE_ENTRY, FIXED_VALUE_ENTRY);
  }
  void add_ARRAY_PARAMETER_REF_ENTRY(::flatbuffers::Offset<ArrayParameterRefEntry> ARRAY_PARAMETER_REF_ENTRY) {
    fbb_.AddOffset(ContainerEntry::VT_ARRAY_PARAMETER_REF_ENTRY, ARRAY_PARAMETER_REF_ENTRY);
  }
  explicit ContainerEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContainerEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContainerEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContainerEntry> CreateContainerEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ParameterRefEntry> PARAMETER_REF_ENTRY = 0,
    ::flatbuffers::Offset<ContainerRefEntry> CONTAINER_REF_ENTRY = 0,
    ::flatbuffers::Offset<FixedValueEntry> FIXED_VALUE_ENTRY = 0,
    ::flatbuffers::Offset<ArrayParameterRefEntry> ARRAY_PARAMETER_REF_ENTRY = 0) {
  ContainerEntryBuilder builder_(_fbb);
  builder_.add_ARRAY_PARAMETER_REF_ENTRY(ARRAY_PARAMETER_REF_ENTRY);
  builder_.add_FIXED_VALUE_ENTRY(FIXED_VALUE_ENTRY);
  builder_.add_CONTAINER_REF_ENTRY(CONTAINER_REF_ENTRY);
  builder_.add_PARAMETER_REF_ENTRY(PARAMETER_REF_ENTRY);
  return builder_.Finish();
}

/// Base container reference with restriction
struct BaseContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BaseContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAINER_REF = 4,
    VT_RESTRICTION_CRITERIA = 6
  };
  /// Container reference path
  const ::flatbuffers::String *CONTAINER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER_REF);
  }
  /// Restriction criteria
  const MatchCriteria *RESTRICTION_CRITERIA() const {
    return GetPointer<const MatchCriteria *>(VT_RESTRICTION_CRITERIA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAINER_REF) &&
           verifier.VerifyString(CONTAINER_REF()) &&
           VerifyOffset(verifier, VT_RESTRICTION_CRITERIA) &&
           verifier.VerifyTable(RESTRICTION_CRITERIA()) &&
           verifier.EndTable();
  }
};

struct BaseContainerBuilder {
  typedef BaseContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CONTAINER_REF(::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF) {
    fbb_.AddOffset(BaseContainer::VT_CONTAINER_REF, CONTAINER_REF);
  }
  void add_RESTRICTION_CRITERIA(::flatbuffers::Offset<MatchCriteria> RESTRICTION_CRITERIA) {
    fbb_.AddOffset(BaseContainer::VT_RESTRICTION_CRITERIA, RESTRICTION_CRITERIA);
  }
  explicit BaseContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BaseContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BaseContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BaseContainer> CreateBaseContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF = 0,
    ::flatbuffers::Offset<MatchCriteria> RESTRICTION_CRITERIA = 0) {
  BaseContainerBuilder builder_(_fbb);
  builder_.add_RESTRICTION_CRITERIA(RESTRICTION_CRITERIA);
  builder_.add_CONTAINER_REF(CONTAINER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BaseContainer> CreateBaseContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CONTAINER_REF = nullptr,
    ::flatbuffers::Offset<MatchCriteria> RESTRICTION_CRITERIA = 0) {
  auto CONTAINER_REF__ = CONTAINER_REF ? _fbb.CreateString(CONTAINER_REF) : 0;
  return CreateBaseContainer(
      _fbb,
      CONTAINER_REF__,
      RESTRICTION_CRITERIA);
}

/// Rate specification for container in stream
struct RateInStream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RateInStreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STREAM_REF = 4,
    VT_RATE = 6,
    VT_BASIS = 8
  };
  /// Stream reference
  const ::flatbuffers::String *STREAM_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREAM_REF);
  }
  /// Rate value
  double RATE() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  /// Rate basis
  RateBasisType BASIS() const {
    return static_cast<RateBasisType>(GetField<int8_t>(VT_BASIS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STREAM_REF) &&
           verifier.VerifyString(STREAM_REF()) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           VerifyField<int8_t>(verifier, VT_BASIS, 1) &&
           verifier.EndTable();
  }
};

struct RateInStreamBuilder {
  typedef RateInStream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_STREAM_REF(::flatbuffers::Offset<::flatbuffers::String> STREAM_REF) {
    fbb_.AddOffset(RateInStream::VT_STREAM_REF, STREAM_REF);
  }
  void add_RATE(double RATE) {
    fbb_.AddElement<double>(RateInStream::VT_RATE, RATE, 0.0);
  }
  void add_BASIS(RateBasisType BASIS) {
    fbb_.AddElement<int8_t>(RateInStream::VT_BASIS, static_cast<int8_t>(BASIS), 0);
  }
  explicit RateInStreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RateInStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RateInStream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RateInStream> CreateRateInStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> STREAM_REF = 0,
    double RATE = 0.0,
    RateBasisType BASIS = RateBasisType_PER_SECOND) {
  RateInStreamBuilder builder_(_fbb);
  builder_.add_RATE(RATE);
  builder_.add_STREAM_REF(STREAM_REF);
  builder_.add_BASIS(BASIS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RateInStream> CreateRateInStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *STREAM_REF = nullptr,
    double RATE = 0.0,
    RateBasisType BASIS = RateBasisType_PER_SECOND) {
  auto STREAM_REF__ = STREAM_REF ? _fbb.CreateString(STREAM_REF) : 0;
  return CreateRateInStream(
      _fbb,
      STREAM_REF__,
      RATE,
      BASIS);
}

/// Binary encoding specification for container
struct ContainerBinaryEncoding FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContainerBinaryEncodingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_DETECTION = 4,
    VT_CRC_POLYNOMIAL = 6,
    VT_SIZE_IN_BITS = 8
  };
  /// Error detection type
  ErrorDetectionType ERROR_DETECTION() const {
    return static_cast<ErrorDetectionType>(GetField<int8_t>(VT_ERROR_DETECTION, 0));
  }
  /// CRC polynomial (for CRC error detection)
  const ::flatbuffers::String *CRC_POLYNOMIAL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CRC_POLYNOMIAL);
  }
  /// Size in bits
  uint32_t SIZE_IN_BITS() const {
    return GetField<uint32_t>(VT_SIZE_IN_BITS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ERROR_DETECTION, 1) &&
           VerifyOffset(verifier, VT_CRC_POLYNOMIAL) &&
           verifier.VerifyString(CRC_POLYNOMIAL()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_IN_BITS, 4) &&
           verifier.EndTable();
  }
};

struct ContainerBinaryEncodingBuilder {
  typedef ContainerBinaryEncoding Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ERROR_DETECTION(ErrorDetectionType ERROR_DETECTION) {
    fbb_.AddElement<int8_t>(ContainerBinaryEncoding::VT_ERROR_DETECTION, static_cast<int8_t>(ERROR_DETECTION), 0);
  }
  void add_CRC_POLYNOMIAL(::flatbuffers::Offset<::flatbuffers::String> CRC_POLYNOMIAL) {
    fbb_.AddOffset(ContainerBinaryEncoding::VT_CRC_POLYNOMIAL, CRC_POLYNOMIAL);
  }
  void add_SIZE_IN_BITS(uint32_t SIZE_IN_BITS) {
    fbb_.AddElement<uint32_t>(ContainerBinaryEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  explicit ContainerBinaryEncodingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContainerBinaryEncoding> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContainerBinaryEncoding>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContainerBinaryEncoding> CreateContainerBinaryEncoding(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ErrorDetectionType ERROR_DETECTION = ErrorDetectionType_NONE,
    ::flatbuffers::Offset<::flatbuffers::String> CRC_POLYNOMIAL = 0,
    uint32_t SIZE_IN_BITS = 0) {
  ContainerBinaryEncodingBuilder builder_(_fbb);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_CRC_POLYNOMIAL(CRC_POLYNOMIAL);
  builder_.add_ERROR_DETECTION(ERROR_DETECTION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContainerBinaryEncoding> CreateContainerBinaryEncodingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ErrorDetectionType ERROR_DETECTION = ErrorDetectionType_NONE,
    const char *CRC_POLYNOMIAL = nullptr,
    uint32_t SIZE_IN_BITS = 0) {
  auto CRC_POLYNOMIAL__ = CRC_POLYNOMIAL ? _fbb.CreateString(CRC_POLYNOMIAL) : 0;
  return CreateContainerBinaryEncoding(
      _fbb,
      ERROR_DETECTION,
      CRC_POLYNOMIAL__,
      SIZE_IN_BITS);
}

/// Sequence container (packet definition)
struct SequenceContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SequenceContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_ABSTRACT = 10,
    VT_ENTRY_LIST = 12,
    VT_BASE_CONTAINER = 14,
    VT_BINARY_ENCODING = 16,
    VT_RATE_IN_STREAM = 18,
    VT_IDLE_PATTERN = 20
  };
  /// Container name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Abstract container (used as base only)
  bool ABSTRACT() const {
    return GetField<uint8_t>(VT_ABSTRACT, 0) != 0;
  }
  /// Container entry list
  const ::flatbuffers::Vector<::flatbuffers::Offset<ContainerEntry>> *ENTRY_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ContainerEntry>> *>(VT_ENTRY_LIST);
  }
  /// Base container (inheritance)
  const BaseContainer *BASE_CONTAINER() const {
    return GetPointer<const BaseContainer *>(VT_BASE_CONTAINER);
  }
  /// Binary encoding
  const ContainerBinaryEncoding *BINARY_ENCODING() const {
    return GetPointer<const ContainerBinaryEncoding *>(VT_BINARY_ENCODING);
  }
  /// Rate in stream
  const RateInStream *RATE_IN_STREAM() const {
    return GetPointer<const RateInStream *>(VT_RATE_IN_STREAM);
  }
  /// Idle pattern (hex string for padding)
  const ::flatbuffers::String *IDLE_PATTERN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDLE_PATTERN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_ABSTRACT, 1) &&
           VerifyOffset(verifier, VT_ENTRY_LIST) &&
           verifier.VerifyVector(ENTRY_LIST()) &&
           verifier.VerifyVectorOfTables(ENTRY_LIST()) &&
           VerifyOffset(verifier, VT_BASE_CONTAINER) &&
           verifier.VerifyTable(BASE_CONTAINER()) &&
           VerifyOffset(verifier, VT_BINARY_ENCODING) &&
           verifier.VerifyTable(BINARY_ENCODING()) &&
           VerifyOffset(verifier, VT_RATE_IN_STREAM) &&
           verifier.VerifyTable(RATE_IN_STREAM()) &&
           VerifyOffset(verifier, VT_IDLE_PATTERN) &&
           verifier.VerifyString(IDLE_PATTERN()) &&
           verifier.EndTable();
  }
};

struct SequenceContainerBuilder {
  typedef SequenceContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(SequenceContainer::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(SequenceContainer::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(SequenceContainer::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_ABSTRACT(bool ABSTRACT) {
    fbb_.AddElement<uint8_t>(SequenceContainer::VT_ABSTRACT, static_cast<uint8_t>(ABSTRACT), 0);
  }
  void add_ENTRY_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContainerEntry>>> ENTRY_LIST) {
    fbb_.AddOffset(SequenceContainer::VT_ENTRY_LIST, ENTRY_LIST);
  }
  void add_BASE_CONTAINER(::flatbuffers::Offset<BaseContainer> BASE_CONTAINER) {
    fbb_.AddOffset(SequenceContainer::VT_BASE_CONTAINER, BASE_CONTAINER);
  }
  void add_BINARY_ENCODING(::flatbuffers::Offset<ContainerBinaryEncoding> BINARY_ENCODING) {
    fbb_.AddOffset(SequenceContainer::VT_BINARY_ENCODING, BINARY_ENCODING);
  }
  void add_RATE_IN_STREAM(::flatbuffers::Offset<RateInStream> RATE_IN_STREAM) {
    fbb_.AddOffset(SequenceContainer::VT_RATE_IN_STREAM, RATE_IN_STREAM);
  }
  void add_IDLE_PATTERN(::flatbuffers::Offset<::flatbuffers::String> IDLE_PATTERN) {
    fbb_.AddOffset(SequenceContainer::VT_IDLE_PATTERN, IDLE_PATTERN);
  }
  explicit SequenceContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SequenceContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SequenceContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SequenceContainer> CreateSequenceContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    bool ABSTRACT = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ContainerEntry>>> ENTRY_LIST = 0,
    ::flatbuffers::Offset<BaseContainer> BASE_CONTAINER = 0,
    ::flatbuffers::Offset<ContainerBinaryEncoding> BINARY_ENCODING = 0,
    ::flatbuffers::Offset<RateInStream> RATE_IN_STREAM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> IDLE_PATTERN = 0) {
  SequenceContainerBuilder builder_(_fbb);
  builder_.add_IDLE_PATTERN(IDLE_PATTERN);
  builder_.add_RATE_IN_STREAM(RATE_IN_STREAM);
  builder_.add_BINARY_ENCODING(BINARY_ENCODING);
  builder_.add_BASE_CONTAINER(BASE_CONTAINER);
  builder_.add_ENTRY_LIST(ENTRY_LIST);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_ABSTRACT(ABSTRACT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SequenceContainer> CreateSequenceContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    bool ABSTRACT = false,
    const std::vector<::flatbuffers::Offset<ContainerEntry>> *ENTRY_LIST = nullptr,
    ::flatbuffers::Offset<BaseContainer> BASE_CONTAINER = 0,
    ::flatbuffers::Offset<ContainerBinaryEncoding> BINARY_ENCODING = 0,
    ::flatbuffers::Offset<RateInStream> RATE_IN_STREAM = 0,
    const char *IDLE_PATTERN = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ENTRY_LIST__ = ENTRY_LIST ? _fbb.CreateVector<::flatbuffers::Offset<ContainerEntry>>(*ENTRY_LIST) : 0;
  auto IDLE_PATTERN__ = IDLE_PATTERN ? _fbb.CreateString(IDLE_PATTERN) : 0;
  return CreateSequenceContainer(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      ABSTRACT,
      ENTRY_LIST__,
      BASE_CONTAINER,
      BINARY_ENCODING,
      RATE_IN_STREAM,
      IDLE_PATTERN__);
}

/// Collection of sequence containers
struct ContainerSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContainerSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAINERS = 4
  };
  /// Sequence containers
  const ::flatbuffers::Vector<::flatbuffers::Offset<SequenceContainer>> *CONTAINERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<SequenceContainer>> *>(VT_CONTAINERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAINERS) &&
           verifier.VerifyVector(CONTAINERS()) &&
           verifier.VerifyVectorOfTables(CONTAINERS()) &&
           verifier.EndTable();
  }
};

struct ContainerSetBuilder {
  typedef ContainerSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CONTAINERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SequenceContainer>>> CONTAINERS) {
    fbb_.AddOffset(ContainerSet::VT_CONTAINERS, CONTAINERS);
  }
  explicit ContainerSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ContainerSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ContainerSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ContainerSet> CreateContainerSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<SequenceContainer>>> CONTAINERS = 0) {
  ContainerSetBuilder builder_(_fbb);
  builder_.add_CONTAINERS(CONTAINERS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ContainerSet> CreateContainerSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<SequenceContainer>> *CONTAINERS = nullptr) {
  auto CONTAINERS__ = CONTAINERS ? _fbb.CreateVector<::flatbuffers::Offset<SequenceContainer>>(*CONTAINERS) : 0;
  return CreateContainerSet(
      _fbb,
      CONTAINERS__);
}

/// Algorithm input binding
struct AlgorithmInput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlgorithmInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_INPUT_NAME = 6
  };
  /// Parameter reference
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Input name in algorithm
  const ::flatbuffers::String *INPUT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INPUT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_INPUT_NAME) &&
           verifier.VerifyString(INPUT_NAME()) &&
           verifier.EndTable();
  }
};

struct AlgorithmInputBuilder {
  typedef AlgorithmInput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(AlgorithmInput::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_INPUT_NAME(::flatbuffers::Offset<::flatbuffers::String> INPUT_NAME) {
    fbb_.AddOffset(AlgorithmInput::VT_INPUT_NAME, INPUT_NAME);
  }
  explicit AlgorithmInputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlgorithmInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlgorithmInput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlgorithmInput> CreateAlgorithmInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INPUT_NAME = 0) {
  AlgorithmInputBuilder builder_(_fbb);
  builder_.add_INPUT_NAME(INPUT_NAME);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlgorithmInput> CreateAlgorithmInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    const char *INPUT_NAME = nullptr) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto INPUT_NAME__ = INPUT_NAME ? _fbb.CreateString(INPUT_NAME) : 0;
  return CreateAlgorithmInput(
      _fbb,
      PARAMETER_REF__,
      INPUT_NAME__);
}

/// Algorithm output binding
struct AlgorithmOutput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlgorithmOutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_OUTPUT_NAME = 6
  };
  /// Parameter reference
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Output name in algorithm
  const ::flatbuffers::String *OUTPUT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OUTPUT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_OUTPUT_NAME) &&
           verifier.VerifyString(OUTPUT_NAME()) &&
           verifier.EndTable();
  }
};

struct AlgorithmOutputBuilder {
  typedef AlgorithmOutput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(AlgorithmOutput::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_OUTPUT_NAME(::flatbuffers::Offset<::flatbuffers::String> OUTPUT_NAME) {
    fbb_.AddOffset(AlgorithmOutput::VT_OUTPUT_NAME, OUTPUT_NAME);
  }
  explicit AlgorithmOutputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlgorithmOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlgorithmOutput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlgorithmOutput> CreateAlgorithmOutput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OUTPUT_NAME = 0) {
  AlgorithmOutputBuilder builder_(_fbb);
  builder_.add_OUTPUT_NAME(OUTPUT_NAME);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlgorithmOutput> CreateAlgorithmOutputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    const char *OUTPUT_NAME = nullptr) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto OUTPUT_NAME__ = OUTPUT_NAME ? _fbb.CreateString(OUTPUT_NAME) : 0;
  return CreateAlgorithmOutput(
      _fbb,
      PARAMETER_REF__,
      OUTPUT_NAME__);
}

/// Trigger condition for algorithm execution
struct AlgorithmTrigger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlgorithmTriggerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_CONTAINER_REF = 6,
    VT_RATE = 8
  };
  /// Trigger on parameter update
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Trigger on container reception
  const ::flatbuffers::String *CONTAINER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER_REF);
  }
  /// Trigger rate (per second)
  double RATE() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_CONTAINER_REF) &&
           verifier.VerifyString(CONTAINER_REF()) &&
           VerifyField<double>(verifier, VT_RATE, 8) &&
           verifier.EndTable();
  }
};

struct AlgorithmTriggerBuilder {
  typedef AlgorithmTrigger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(AlgorithmTrigger::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_CONTAINER_REF(::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF) {
    fbb_.AddOffset(AlgorithmTrigger::VT_CONTAINER_REF, CONTAINER_REF);
  }
  void add_RATE(double RATE) {
    fbb_.AddElement<double>(AlgorithmTrigger::VT_RATE, RATE, 0.0);
  }
  explicit AlgorithmTriggerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlgorithmTrigger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlgorithmTrigger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlgorithmTrigger> CreateAlgorithmTrigger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF = 0,
    double RATE = 0.0) {
  AlgorithmTriggerBuilder builder_(_fbb);
  builder_.add_RATE(RATE);
  builder_.add_CONTAINER_REF(CONTAINER_REF);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlgorithmTrigger> CreateAlgorithmTriggerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    const char *CONTAINER_REF = nullptr,
    double RATE = 0.0) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto CONTAINER_REF__ = CONTAINER_REF ? _fbb.CreateString(CONTAINER_REF) : 0;
  return CreateAlgorithmTrigger(
      _fbb,
      PARAMETER_REF__,
      CONTAINER_REF__,
      RATE);
}

/// Custom algorithm definition
struct CustomAlgorithm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomAlgorithmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_LANGUAGE = 10,
    VT_ALGORITHM_TEXT = 12,
    VT_EXTERNAL_ALGORITHM_REF = 14,
    VT_INPUTS = 16,
    VT_OUTPUTS = 18,
    VT_TRIGGERS = 20
  };
  /// Algorithm name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Programming language
  const ::flatbuffers::String *LANGUAGE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LANGUAGE);
  }
  /// Algorithm text/code
  const ::flatbuffers::String *ALGORITHM_TEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM_TEXT);
  }
  /// External algorithm reference
  const ::flatbuffers::String *EXTERNAL_ALGORITHM_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNAL_ALGORITHM_REF);
  }
  /// Input bindings
  const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmInput>> *INPUTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmInput>> *>(VT_INPUTS);
  }
  /// Output bindings
  const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmOutput>> *OUTPUTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmOutput>> *>(VT_OUTPUTS);
  }
  /// Trigger conditions
  const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>> *TRIGGERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>> *>(VT_TRIGGERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LANGUAGE) &&
           verifier.VerifyString(LANGUAGE()) &&
           VerifyOffset(verifier, VT_ALGORITHM_TEXT) &&
           verifier.VerifyString(ALGORITHM_TEXT()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ALGORITHM_REF) &&
           verifier.VerifyString(EXTERNAL_ALGORITHM_REF()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(INPUTS()) &&
           verifier.VerifyVectorOfTables(INPUTS()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(OUTPUTS()) &&
           verifier.VerifyVectorOfTables(OUTPUTS()) &&
           VerifyOffset(verifier, VT_TRIGGERS) &&
           verifier.VerifyVector(TRIGGERS()) &&
           verifier.VerifyVectorOfTables(TRIGGERS()) &&
           verifier.EndTable();
  }
};

struct CustomAlgorithmBuilder {
  typedef CustomAlgorithm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CustomAlgorithm::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(CustomAlgorithm::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(CustomAlgorithm::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_LANGUAGE(::flatbuffers::Offset<::flatbuffers::String> LANGUAGE) {
    fbb_.AddOffset(CustomAlgorithm::VT_LANGUAGE, LANGUAGE);
  }
  void add_ALGORITHM_TEXT(::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_TEXT) {
    fbb_.AddOffset(CustomAlgorithm::VT_ALGORITHM_TEXT, ALGORITHM_TEXT);
  }
  void add_EXTERNAL_ALGORITHM_REF(::flatbuffers::Offset<::flatbuffers::String> EXTERNAL_ALGORITHM_REF) {
    fbb_.AddOffset(CustomAlgorithm::VT_EXTERNAL_ALGORITHM_REF, EXTERNAL_ALGORITHM_REF);
  }
  void add_INPUTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmInput>>> INPUTS) {
    fbb_.AddOffset(CustomAlgorithm::VT_INPUTS, INPUTS);
  }
  void add_OUTPUTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmOutput>>> OUTPUTS) {
    fbb_.AddOffset(CustomAlgorithm::VT_OUTPUTS, OUTPUTS);
  }
  void add_TRIGGERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>>> TRIGGERS) {
    fbb_.AddOffset(CustomAlgorithm::VT_TRIGGERS, TRIGGERS);
  }
  explicit CustomAlgorithmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomAlgorithm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomAlgorithm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomAlgorithm> CreateCustomAlgorithm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LANGUAGE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_TEXT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EXTERNAL_ALGORITHM_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmInput>>> INPUTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmOutput>>> OUTPUTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>>> TRIGGERS = 0) {
  CustomAlgorithmBuilder builder_(_fbb);
  builder_.add_TRIGGERS(TRIGGERS);
  builder_.add_OUTPUTS(OUTPUTS);
  builder_.add_INPUTS(INPUTS);
  builder_.add_EXTERNAL_ALGORITHM_REF(EXTERNAL_ALGORITHM_REF);
  builder_.add_ALGORITHM_TEXT(ALGORITHM_TEXT);
  builder_.add_LANGUAGE(LANGUAGE);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomAlgorithm> CreateCustomAlgorithmDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const char *LANGUAGE = nullptr,
    const char *ALGORITHM_TEXT = nullptr,
    const char *EXTERNAL_ALGORITHM_REF = nullptr,
    const std::vector<::flatbuffers::Offset<AlgorithmInput>> *INPUTS = nullptr,
    const std::vector<::flatbuffers::Offset<AlgorithmOutput>> *OUTPUTS = nullptr,
    const std::vector<::flatbuffers::Offset<AlgorithmTrigger>> *TRIGGERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto LANGUAGE__ = LANGUAGE ? _fbb.CreateString(LANGUAGE) : 0;
  auto ALGORITHM_TEXT__ = ALGORITHM_TEXT ? _fbb.CreateString(ALGORITHM_TEXT) : 0;
  auto EXTERNAL_ALGORITHM_REF__ = EXTERNAL_ALGORITHM_REF ? _fbb.CreateString(EXTERNAL_ALGORITHM_REF) : 0;
  auto INPUTS__ = INPUTS ? _fbb.CreateVector<::flatbuffers::Offset<AlgorithmInput>>(*INPUTS) : 0;
  auto OUTPUTS__ = OUTPUTS ? _fbb.CreateVector<::flatbuffers::Offset<AlgorithmOutput>>(*OUTPUTS) : 0;
  auto TRIGGERS__ = TRIGGERS ? _fbb.CreateVector<::flatbuffers::Offset<AlgorithmTrigger>>(*TRIGGERS) : 0;
  return CreateCustomAlgorithm(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      LANGUAGE__,
      ALGORITHM_TEXT__,
      EXTERNAL_ALGORITHM_REF__,
      INPUTS__,
      OUTPUTS__,
      TRIGGERS__);
}

/// Math algorithm (inline calculation)
struct MathAlgorithm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MathAlgorithmBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_MATH_OPERATION = 8,
    VT_OUTPUT_PARAMETER_REF = 10,
    VT_TRIGGERS = 12
  };
  /// Algorithm name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Math operation in RPN
  const ::flatbuffers::String *MATH_OPERATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATH_OPERATION);
  }
  /// Output parameter reference
  const ::flatbuffers::String *OUTPUT_PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OUTPUT_PARAMETER_REF);
  }
  /// Trigger conditions
  const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>> *TRIGGERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>> *>(VT_TRIGGERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_MATH_OPERATION) &&
           verifier.VerifyString(MATH_OPERATION()) &&
           VerifyOffset(verifier, VT_OUTPUT_PARAMETER_REF) &&
           verifier.VerifyString(OUTPUT_PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_TRIGGERS) &&
           verifier.VerifyVector(TRIGGERS()) &&
           verifier.VerifyVectorOfTables(TRIGGERS()) &&
           verifier.EndTable();
  }
};

struct MathAlgorithmBuilder {
  typedef MathAlgorithm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(MathAlgorithm::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(MathAlgorithm::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_MATH_OPERATION(::flatbuffers::Offset<::flatbuffers::String> MATH_OPERATION) {
    fbb_.AddOffset(MathAlgorithm::VT_MATH_OPERATION, MATH_OPERATION);
  }
  void add_OUTPUT_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> OUTPUT_PARAMETER_REF) {
    fbb_.AddOffset(MathAlgorithm::VT_OUTPUT_PARAMETER_REF, OUTPUT_PARAMETER_REF);
  }
  void add_TRIGGERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>>> TRIGGERS) {
    fbb_.AddOffset(MathAlgorithm::VT_TRIGGERS, TRIGGERS);
  }
  explicit MathAlgorithmBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MathAlgorithm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MathAlgorithm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MathAlgorithm> CreateMathAlgorithm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MATH_OPERATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OUTPUT_PARAMETER_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AlgorithmTrigger>>> TRIGGERS = 0) {
  MathAlgorithmBuilder builder_(_fbb);
  builder_.add_TRIGGERS(TRIGGERS);
  builder_.add_OUTPUT_PARAMETER_REF(OUTPUT_PARAMETER_REF);
  builder_.add_MATH_OPERATION(MATH_OPERATION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MathAlgorithm> CreateMathAlgorithmDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *MATH_OPERATION = nullptr,
    const char *OUTPUT_PARAMETER_REF = nullptr,
    const std::vector<::flatbuffers::Offset<AlgorithmTrigger>> *TRIGGERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto MATH_OPERATION__ = MATH_OPERATION ? _fbb.CreateString(MATH_OPERATION) : 0;
  auto OUTPUT_PARAMETER_REF__ = OUTPUT_PARAMETER_REF ? _fbb.CreateString(OUTPUT_PARAMETER_REF) : 0;
  auto TRIGGERS__ = TRIGGERS ? _fbb.CreateVector<::flatbuffers::Offset<AlgorithmTrigger>>(*TRIGGERS) : 0;
  return CreateMathAlgorithm(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      MATH_OPERATION__,
      OUTPUT_PARAMETER_REF__,
      TRIGGERS__);
}

/// Collection of algorithms
struct AlgorithmSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AlgorithmSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM_ALGORITHMS = 4,
    VT_MATH_ALGORITHMS = 6
  };
  /// Custom algorithms
  const ::flatbuffers::Vector<::flatbuffers::Offset<CustomAlgorithm>> *CUSTOM_ALGORITHMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CustomAlgorithm>> *>(VT_CUSTOM_ALGORITHMS);
  }
  /// Math algorithms
  const ::flatbuffers::Vector<::flatbuffers::Offset<MathAlgorithm>> *MATH_ALGORITHMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MathAlgorithm>> *>(VT_MATH_ALGORITHMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM_ALGORITHMS) &&
           verifier.VerifyVector(CUSTOM_ALGORITHMS()) &&
           verifier.VerifyVectorOfTables(CUSTOM_ALGORITHMS()) &&
           VerifyOffset(verifier, VT_MATH_ALGORITHMS) &&
           verifier.VerifyVector(MATH_ALGORITHMS()) &&
           verifier.VerifyVectorOfTables(MATH_ALGORITHMS()) &&
           verifier.EndTable();
  }
};

struct AlgorithmSetBuilder {
  typedef AlgorithmSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CUSTOM_ALGORITHMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CustomAlgorithm>>> CUSTOM_ALGORITHMS) {
    fbb_.AddOffset(AlgorithmSet::VT_CUSTOM_ALGORITHMS, CUSTOM_ALGORITHMS);
  }
  void add_MATH_ALGORITHMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MathAlgorithm>>> MATH_ALGORITHMS) {
    fbb_.AddOffset(AlgorithmSet::VT_MATH_ALGORITHMS, MATH_ALGORITHMS);
  }
  explicit AlgorithmSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AlgorithmSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AlgorithmSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AlgorithmSet> CreateAlgorithmSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CustomAlgorithm>>> CUSTOM_ALGORITHMS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MathAlgorithm>>> MATH_ALGORITHMS = 0) {
  AlgorithmSetBuilder builder_(_fbb);
  builder_.add_MATH_ALGORITHMS(MATH_ALGORITHMS);
  builder_.add_CUSTOM_ALGORITHMS(CUSTOM_ALGORITHMS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AlgorithmSet> CreateAlgorithmSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CustomAlgorithm>> *CUSTOM_ALGORITHMS = nullptr,
    const std::vector<::flatbuffers::Offset<MathAlgorithm>> *MATH_ALGORITHMS = nullptr) {
  auto CUSTOM_ALGORITHMS__ = CUSTOM_ALGORITHMS ? _fbb.CreateVector<::flatbuffers::Offset<CustomAlgorithm>>(*CUSTOM_ALGORITHMS) : 0;
  auto MATH_ALGORITHMS__ = MATH_ALGORITHMS ? _fbb.CreateVector<::flatbuffers::Offset<MathAlgorithm>>(*MATH_ALGORITHMS) : 0;
  return CreateAlgorithmSet(
      _fbb,
      CUSTOM_ALGORITHMS__,
      MATH_ALGORITHMS__);
}

/// Integer argument type
struct IntegerArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_UNITS = 10,
    VT_DATA_ENCODING = 12,
    VT_VALID_MIN = 14,
    VT_VALID_MAX = 16,
    VT_SIGNED = 18,
    VT_SIZE_IN_BITS = 20,
    VT_INITIAL_VALUE = 22
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Units
  const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Minimum valid value
  int64_t VALID_MIN() const {
    return GetField<int64_t>(VT_VALID_MIN, 0);
  }
  /// Maximum valid value
  int64_t VALID_MAX() const {
    return GetField<int64_t>(VT_VALID_MAX, 0);
  }
  /// Signed integer (true) or unsigned (false)
  bool SIGNED() const {
    return GetField<uint8_t>(VT_SIGNED, 0) != 0;
  }
  /// Size in bits
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Initial/default value
  int64_t INITIAL_VALUE() const {
    return GetField<int64_t>(VT_INITIAL_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(UNITS()) &&
           verifier.VerifyVectorOfTables(UNITS()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyField<int64_t>(verifier, VT_VALID_MIN, 8) &&
           VerifyField<int64_t>(verifier, VT_VALID_MAX, 8) &&
           VerifyField<uint8_t>(verifier, VT_SIGNED, 1) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<int64_t>(verifier, VT_INITIAL_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct IntegerArgumentTypeBuilder {
  typedef IntegerArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(IntegerArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(IntegerArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(IntegerArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS) {
    fbb_.AddOffset(IntegerArgumentType::VT_UNITS, UNITS);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(IntegerArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_VALID_MIN(int64_t VALID_MIN) {
    fbb_.AddElement<int64_t>(IntegerArgumentType::VT_VALID_MIN, VALID_MIN, 0);
  }
  void add_VALID_MAX(int64_t VALID_MAX) {
    fbb_.AddElement<int64_t>(IntegerArgumentType::VT_VALID_MAX, VALID_MAX, 0);
  }
  void add_SIGNED(bool SIGNED) {
    fbb_.AddElement<uint8_t>(IntegerArgumentType::VT_SIGNED, static_cast<uint8_t>(SIGNED), 0);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(IntegerArgumentType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_INITIAL_VALUE(int64_t INITIAL_VALUE) {
    fbb_.AddElement<int64_t>(IntegerArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE, 0);
  }
  explicit IntegerArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerArgumentType> CreateIntegerArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    int64_t VALID_MIN = 0,
    int64_t VALID_MAX = 0,
    bool SIGNED = false,
    uint16_t SIZE_IN_BITS = 0,
    int64_t INITIAL_VALUE = 0) {
  IntegerArgumentTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_VALID_MAX(VALID_MAX);
  builder_.add_VALID_MIN(VALID_MIN);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_UNITS(UNITS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  builder_.add_SIGNED(SIGNED);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IntegerArgumentType> CreateIntegerArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<Unit>> *UNITS = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    int64_t VALID_MIN = 0,
    int64_t VALID_MAX = 0,
    bool SIGNED = false,
    uint16_t SIZE_IN_BITS = 0,
    int64_t INITIAL_VALUE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto UNITS__ = UNITS ? _fbb.CreateVector<::flatbuffers::Offset<Unit>>(*UNITS) : 0;
  return CreateIntegerArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      UNITS__,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE);
}

/// Float argument type
struct FloatArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_UNITS = 10,
    VT_DATA_ENCODING = 12,
    VT_VALID_MIN = 14,
    VT_VALID_MAX = 16,
    VT_SIZE_IN_BITS = 18,
    VT_INITIAL_VALUE = 20
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Units
  const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *UNITS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  /// Data encoding
  const FloatDataEncoding *DATA_ENCODING() const {
    return GetPointer<const FloatDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Minimum valid value
  double VALID_MIN() const {
    return GetField<double>(VT_VALID_MIN, 0.0);
  }
  /// Maximum valid value
  double VALID_MAX() const {
    return GetField<double>(VT_VALID_MAX, 0.0);
  }
  /// Size in bits
  uint16_t SIZE_IN_BITS() const {
    return GetField<uint16_t>(VT_SIZE_IN_BITS, 0);
  }
  /// Initial/default value
  double INITIAL_VALUE() const {
    return GetField<double>(VT_INITIAL_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.VerifyVector(UNITS()) &&
           verifier.VerifyVectorOfTables(UNITS()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyField<double>(verifier, VT_VALID_MIN, 8) &&
           VerifyField<double>(verifier, VT_VALID_MAX, 8) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_IN_BITS, 2) &&
           VerifyField<double>(verifier, VT_INITIAL_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct FloatArgumentTypeBuilder {
  typedef FloatArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(FloatArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(FloatArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(FloatArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_UNITS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS) {
    fbb_.AddOffset(FloatArgumentType::VT_UNITS, UNITS);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(FloatArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_VALID_MIN(double VALID_MIN) {
    fbb_.AddElement<double>(FloatArgumentType::VT_VALID_MIN, VALID_MIN, 0.0);
  }
  void add_VALID_MAX(double VALID_MAX) {
    fbb_.AddElement<double>(FloatArgumentType::VT_VALID_MAX, VALID_MAX, 0.0);
  }
  void add_SIZE_IN_BITS(uint16_t SIZE_IN_BITS) {
    fbb_.AddElement<uint16_t>(FloatArgumentType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  void add_INITIAL_VALUE(double INITIAL_VALUE) {
    fbb_.AddElement<double>(FloatArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE, 0.0);
  }
  explicit FloatArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatArgumentType> CreateFloatArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Unit>>> UNITS = 0,
    ::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING = 0,
    double VALID_MIN = 0.0,
    double VALID_MAX = 0.0,
    uint16_t SIZE_IN_BITS = 0,
    double INITIAL_VALUE = 0.0) {
  FloatArgumentTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_VALID_MAX(VALID_MAX);
  builder_.add_VALID_MIN(VALID_MIN);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_UNITS(UNITS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_SIZE_IN_BITS(SIZE_IN_BITS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FloatArgumentType> CreateFloatArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<Unit>> *UNITS = nullptr,
    ::flatbuffers::Offset<FloatDataEncoding> DATA_ENCODING = 0,
    double VALID_MIN = 0.0,
    double VALID_MAX = 0.0,
    uint16_t SIZE_IN_BITS = 0,
    double INITIAL_VALUE = 0.0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto UNITS__ = UNITS ? _fbb.CreateVector<::flatbuffers::Offset<Unit>>(*UNITS) : 0;
  return CreateFloatArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      UNITS__,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE);
}

/// String argument type
struct StringArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_INITIAL_VALUE = 12,
    VT_RESTRICTION_PATTERN = 14
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const StringDataEncoding *DATA_ENCODING() const {
    return GetPointer<const StringDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Initial/default value
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  /// Restriction pattern (regex)
  const ::flatbuffers::String *RESTRICTION_PATTERN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESTRICTION_PATTERN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           VerifyOffset(verifier, VT_RESTRICTION_PATTERN) &&
           verifier.VerifyString(RESTRICTION_PATTERN()) &&
           verifier.EndTable();
  }
};

struct StringArgumentTypeBuilder {
  typedef StringArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(StringArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(StringArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(StringArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(StringArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(StringArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  void add_RESTRICTION_PATTERN(::flatbuffers::Offset<::flatbuffers::String> RESTRICTION_PATTERN) {
    fbb_.AddOffset(StringArgumentType::VT_RESTRICTION_PATTERN, RESTRICTION_PATTERN);
  }
  explicit StringArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringArgumentType> CreateStringArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RESTRICTION_PATTERN = 0) {
  StringArgumentTypeBuilder builder_(_fbb);
  builder_.add_RESTRICTION_PATTERN(RESTRICTION_PATTERN);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringArgumentType> CreateStringArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<StringDataEncoding> DATA_ENCODING = 0,
    const char *INITIAL_VALUE = nullptr,
    const char *RESTRICTION_PATTERN = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  auto RESTRICTION_PATTERN__ = RESTRICTION_PATTERN ? _fbb.CreateString(RESTRICTION_PATTERN) : 0;
  return CreateStringArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      INITIAL_VALUE__,
      RESTRICTION_PATTERN__);
}

/// Boolean argument type
struct BooleanArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_ONE_STRING_VALUE = 12,
    VT_ZERO_STRING_VALUE = 14,
    VT_INITIAL_VALUE = 16
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// String representation of true value
  const ::flatbuffers::String *ONE_STRING_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ONE_STRING_VALUE);
  }
  /// String representation of false value
  const ::flatbuffers::String *ZERO_STRING_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ZERO_STRING_VALUE);
  }
  /// Initial/default value
  bool INITIAL_VALUE() const {
    return GetField<uint8_t>(VT_INITIAL_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_ONE_STRING_VALUE) &&
           verifier.VerifyString(ONE_STRING_VALUE()) &&
           VerifyOffset(verifier, VT_ZERO_STRING_VALUE) &&
           verifier.VerifyString(ZERO_STRING_VALUE()) &&
           VerifyField<uint8_t>(verifier, VT_INITIAL_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanArgumentTypeBuilder {
  typedef BooleanArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(BooleanArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(BooleanArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(BooleanArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(BooleanArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_ONE_STRING_VALUE(::flatbuffers::Offset<::flatbuffers::String> ONE_STRING_VALUE) {
    fbb_.AddOffset(BooleanArgumentType::VT_ONE_STRING_VALUE, ONE_STRING_VALUE);
  }
  void add_ZERO_STRING_VALUE(::flatbuffers::Offset<::flatbuffers::String> ZERO_STRING_VALUE) {
    fbb_.AddOffset(BooleanArgumentType::VT_ZERO_STRING_VALUE, ZERO_STRING_VALUE);
  }
  void add_INITIAL_VALUE(bool INITIAL_VALUE) {
    fbb_.AddElement<uint8_t>(BooleanArgumentType::VT_INITIAL_VALUE, static_cast<uint8_t>(INITIAL_VALUE), 0);
  }
  explicit BooleanArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BooleanArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BooleanArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BooleanArgumentType> CreateBooleanArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ONE_STRING_VALUE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ZERO_STRING_VALUE = 0,
    bool INITIAL_VALUE = false) {
  BooleanArgumentTypeBuilder builder_(_fbb);
  builder_.add_ZERO_STRING_VALUE(ZERO_STRING_VALUE);
  builder_.add_ONE_STRING_VALUE(ONE_STRING_VALUE);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BooleanArgumentType> CreateBooleanArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    const char *ONE_STRING_VALUE = nullptr,
    const char *ZERO_STRING_VALUE = nullptr,
    bool INITIAL_VALUE = false) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ONE_STRING_VALUE__ = ONE_STRING_VALUE ? _fbb.CreateString(ONE_STRING_VALUE) : 0;
  auto ZERO_STRING_VALUE__ = ZERO_STRING_VALUE ? _fbb.CreateString(ZERO_STRING_VALUE) : 0;
  return CreateBooleanArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      ONE_STRING_VALUE__,
      ZERO_STRING_VALUE__,
      INITIAL_VALUE);
}

/// Enumerated argument type
struct EnumeratedArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumeratedArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_ENUMERATION_LIST = 12,
    VT_INITIAL_VALUE = 14
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const IntegerDataEncoding *DATA_ENCODING() const {
    return GetPointer<const IntegerDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Enumeration values list
  const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>> *ENUMERATION_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>> *>(VT_ENUMERATION_LIST);
  }
  /// Initial/default value label
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_ENUMERATION_LIST) &&
           verifier.VerifyVector(ENUMERATION_LIST()) &&
           verifier.VerifyVectorOfTables(ENUMERATION_LIST()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct EnumeratedArgumentTypeBuilder {
  typedef EnumeratedArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_ENUMERATION_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>>> ENUMERATION_LIST) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_ENUMERATION_LIST, ENUMERATION_LIST);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(EnumeratedArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit EnumeratedArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumeratedArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumeratedArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumeratedArgumentType> CreateEnumeratedArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumerationValue>>> ENUMERATION_LIST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  EnumeratedArgumentTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_ENUMERATION_LIST(ENUMERATION_LIST);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EnumeratedArgumentType> CreateEnumeratedArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<IntegerDataEncoding> DATA_ENCODING = 0,
    const std::vector<::flatbuffers::Offset<EnumerationValue>> *ENUMERATION_LIST = nullptr,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ENUMERATION_LIST__ = ENUMERATION_LIST ? _fbb.CreateVector<::flatbuffers::Offset<EnumerationValue>>(*ENUMERATION_LIST) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateEnumeratedArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      ENUMERATION_LIST__,
      INITIAL_VALUE__);
}

/// Binary argument type
struct BinaryArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_DATA_ENCODING = 10,
    VT_INITIAL_VALUE = 12
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Data encoding
  const BinaryDataEncoding *DATA_ENCODING() const {
    return GetPointer<const BinaryDataEncoding *>(VT_DATA_ENCODING);
  }
  /// Initial/default value (hex string)
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_ENCODING) &&
           verifier.VerifyTable(DATA_ENCODING()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct BinaryArgumentTypeBuilder {
  typedef BinaryArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(BinaryArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(BinaryArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(BinaryArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_DATA_ENCODING(::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING) {
    fbb_.AddOffset(BinaryArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(BinaryArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit BinaryArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryArgumentType> CreateBinaryArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  BinaryArgumentTypeBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_DATA_ENCODING(DATA_ENCODING);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BinaryArgumentType> CreateBinaryArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    ::flatbuffers::Offset<BinaryDataEncoding> DATA_ENCODING = 0,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateBinaryArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      DATA_ENCODING,
      INITIAL_VALUE__);
}

/// Aggregate argument type
struct AggregateArgumentType FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AggregateArgumentTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_MEMBERS = 10
  };
  /// Type name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Member list
  const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>> *MEMBERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>> *>(VT_MEMBERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(MEMBERS()) &&
           verifier.VerifyVectorOfTables(MEMBERS()) &&
           verifier.EndTable();
  }
};

struct AggregateArgumentTypeBuilder {
  typedef AggregateArgumentType Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(AggregateArgumentType::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(AggregateArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(AggregateArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_MEMBERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>>> MEMBERS) {
    fbb_.AddOffset(AggregateArgumentType::VT_MEMBERS, MEMBERS);
  }
  explicit AggregateArgumentTypeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AggregateArgumentType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AggregateArgumentType>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AggregateArgumentType> CreateAggregateArgumentType(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateMember>>> MEMBERS = 0) {
  AggregateArgumentTypeBuilder builder_(_fbb);
  builder_.add_MEMBERS(MEMBERS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AggregateArgumentType> CreateAggregateArgumentTypeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<AggregateMember>> *MEMBERS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto MEMBERS__ = MEMBERS ? _fbb.CreateVector<::flatbuffers::Offset<AggregateMember>>(*MEMBERS) : 0;
  return CreateAggregateArgumentType(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      MEMBERS__);
}

/// Collection of argument types
struct ArgumentTypeSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgumentTypeSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTEGER_TYPES = 4,
    VT_FLOAT_TYPES = 6,
    VT_STRING_TYPES = 8,
    VT_BOOLEAN_TYPES = 10,
    VT_ENUMERATED_TYPES = 12,
    VT_BINARY_TYPES = 14,
    VT_AGGREGATE_TYPES = 16
  };
  /// Integer argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerArgumentType>> *INTEGER_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<IntegerArgumentType>> *>(VT_INTEGER_TYPES);
  }
  /// Float argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<FloatArgumentType>> *FLOAT_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FloatArgumentType>> *>(VT_FLOAT_TYPES);
  }
  /// String argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<StringArgumentType>> *STRING_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<StringArgumentType>> *>(VT_STRING_TYPES);
  }
  /// Boolean argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanArgumentType>> *BOOLEAN_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BooleanArgumentType>> *>(VT_BOOLEAN_TYPES);
  }
  /// Enumerated argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedArgumentType>> *ENUMERATED_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedArgumentType>> *>(VT_ENUMERATED_TYPES);
  }
  /// Binary argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<BinaryArgumentType>> *BINARY_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BinaryArgumentType>> *>(VT_BINARY_TYPES);
  }
  /// Aggregate argument types
  const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateArgumentType>> *AGGREGATE_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AggregateArgumentType>> *>(VT_AGGREGATE_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTEGER_TYPES) &&
           verifier.VerifyVector(INTEGER_TYPES()) &&
           verifier.VerifyVectorOfTables(INTEGER_TYPES()) &&
           VerifyOffset(verifier, VT_FLOAT_TYPES) &&
           verifier.VerifyVector(FLOAT_TYPES()) &&
           verifier.VerifyVectorOfTables(FLOAT_TYPES()) &&
           VerifyOffset(verifier, VT_STRING_TYPES) &&
           verifier.VerifyVector(STRING_TYPES()) &&
           verifier.VerifyVectorOfTables(STRING_TYPES()) &&
           VerifyOffset(verifier, VT_BOOLEAN_TYPES) &&
           verifier.VerifyVector(BOOLEAN_TYPES()) &&
           verifier.VerifyVectorOfTables(BOOLEAN_TYPES()) &&
           VerifyOffset(verifier, VT_ENUMERATED_TYPES) &&
           verifier.VerifyVector(ENUMERATED_TYPES()) &&
           verifier.VerifyVectorOfTables(ENUMERATED_TYPES()) &&
           VerifyOffset(verifier, VT_BINARY_TYPES) &&
           verifier.VerifyVector(BINARY_TYPES()) &&
           verifier.VerifyVectorOfTables(BINARY_TYPES()) &&
           VerifyOffset(verifier, VT_AGGREGATE_TYPES) &&
           verifier.VerifyVector(AGGREGATE_TYPES()) &&
           verifier.VerifyVectorOfTables(AGGREGATE_TYPES()) &&
           verifier.EndTable();
  }
};

struct ArgumentTypeSetBuilder {
  typedef ArgumentTypeSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_INTEGER_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerArgumentType>>> INTEGER_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_INTEGER_TYPES, INTEGER_TYPES);
  }
  void add_FLOAT_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FloatArgumentType>>> FLOAT_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_FLOAT_TYPES, FLOAT_TYPES);
  }
  void add_STRING_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StringArgumentType>>> STRING_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_STRING_TYPES, STRING_TYPES);
  }
  void add_BOOLEAN_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanArgumentType>>> BOOLEAN_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_BOOLEAN_TYPES, BOOLEAN_TYPES);
  }
  void add_ENUMERATED_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedArgumentType>>> ENUMERATED_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_ENUMERATED_TYPES, ENUMERATED_TYPES);
  }
  void add_BINARY_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BinaryArgumentType>>> BINARY_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_BINARY_TYPES, BINARY_TYPES);
  }
  void add_AGGREGATE_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateArgumentType>>> AGGREGATE_TYPES) {
    fbb_.AddOffset(ArgumentTypeSet::VT_AGGREGATE_TYPES, AGGREGATE_TYPES);
  }
  explicit ArgumentTypeSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgumentTypeSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgumentTypeSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgumentTypeSet> CreateArgumentTypeSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<IntegerArgumentType>>> INTEGER_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FloatArgumentType>>> FLOAT_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<StringArgumentType>>> STRING_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BooleanArgumentType>>> BOOLEAN_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EnumeratedArgumentType>>> ENUMERATED_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BinaryArgumentType>>> BINARY_TYPES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AggregateArgumentType>>> AGGREGATE_TYPES = 0) {
  ArgumentTypeSetBuilder builder_(_fbb);
  builder_.add_AGGREGATE_TYPES(AGGREGATE_TYPES);
  builder_.add_BINARY_TYPES(BINARY_TYPES);
  builder_.add_ENUMERATED_TYPES(ENUMERATED_TYPES);
  builder_.add_BOOLEAN_TYPES(BOOLEAN_TYPES);
  builder_.add_STRING_TYPES(STRING_TYPES);
  builder_.add_FLOAT_TYPES(FLOAT_TYPES);
  builder_.add_INTEGER_TYPES(INTEGER_TYPES);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArgumentTypeSet> CreateArgumentTypeSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<IntegerArgumentType>> *INTEGER_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<FloatArgumentType>> *FLOAT_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<StringArgumentType>> *STRING_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<BooleanArgumentType>> *BOOLEAN_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<EnumeratedArgumentType>> *ENUMERATED_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<BinaryArgumentType>> *BINARY_TYPES = nullptr,
    const std::vector<::flatbuffers::Offset<AggregateArgumentType>> *AGGREGATE_TYPES = nullptr) {
  auto INTEGER_TYPES__ = INTEGER_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<IntegerArgumentType>>(*INTEGER_TYPES) : 0;
  auto FLOAT_TYPES__ = FLOAT_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<FloatArgumentType>>(*FLOAT_TYPES) : 0;
  auto STRING_TYPES__ = STRING_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<StringArgumentType>>(*STRING_TYPES) : 0;
  auto BOOLEAN_TYPES__ = BOOLEAN_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<BooleanArgumentType>>(*BOOLEAN_TYPES) : 0;
  auto ENUMERATED_TYPES__ = ENUMERATED_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<EnumeratedArgumentType>>(*ENUMERATED_TYPES) : 0;
  auto BINARY_TYPES__ = BINARY_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<BinaryArgumentType>>(*BINARY_TYPES) : 0;
  auto AGGREGATE_TYPES__ = AGGREGATE_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<AggregateArgumentType>>(*AGGREGATE_TYPES) : 0;
  return CreateArgumentTypeSet(
      _fbb,
      INTEGER_TYPES__,
      FLOAT_TYPES__,
      STRING_TYPES__,
      BOOLEAN_TYPES__,
      ENUMERATED_TYPES__,
      BINARY_TYPES__,
      AGGREGATE_TYPES__);
}

/// Command argument definition
struct Argument FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgumentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ARGUMENT_TYPE_REF = 6,
    VT_SHORT_DESCRIPTION = 8,
    VT_LONG_DESCRIPTION = 10,
    VT_INITIAL_VALUE = 12
  };
  /// Argument name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Reference to argument type
  const ::flatbuffers::String *ARGUMENT_TYPE_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENT_TYPE_REF);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Initial/default value
  const ::flatbuffers::String *INITIAL_VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_ARGUMENT_TYPE_REF) &&
           verifier.VerifyString(ARGUMENT_TYPE_REF()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_INITIAL_VALUE) &&
           verifier.VerifyString(INITIAL_VALUE()) &&
           verifier.EndTable();
  }
};

struct ArgumentBuilder {
  typedef Argument Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(Argument::VT_NAME, NAME);
  }
  void add_ARGUMENT_TYPE_REF(::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_TYPE_REF) {
    fbb_.AddOffset(Argument::VT_ARGUMENT_TYPE_REF, ARGUMENT_TYPE_REF);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(Argument::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(Argument::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_INITIAL_VALUE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE) {
    fbb_.AddOffset(Argument::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  explicit ArgumentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Argument> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Argument>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Argument> CreateArgument(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_TYPE_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_VALUE = 0) {
  ArgumentBuilder builder_(_fbb);
  builder_.add_INITIAL_VALUE(INITIAL_VALUE);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_ARGUMENT_TYPE_REF(ARGUMENT_TYPE_REF);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Argument> CreateArgumentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *ARGUMENT_TYPE_REF = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const char *INITIAL_VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto ARGUMENT_TYPE_REF__ = ARGUMENT_TYPE_REF ? _fbb.CreateString(ARGUMENT_TYPE_REF) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto INITIAL_VALUE__ = INITIAL_VALUE ? _fbb.CreateString(INITIAL_VALUE) : 0;
  return CreateArgument(
      _fbb,
      NAME__,
      ARGUMENT_TYPE_REF__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      INITIAL_VALUE__);
}

/// Argument reference entry in command container
struct ArgumentRefEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgumentRefEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENT_REF = 4,
    VT_LOCATION = 6,
    VT_SHORT_DESCRIPTION = 8
  };
  /// Argument reference
  const ::flatbuffers::String *ARGUMENT_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENT_REF);
  }
  /// Location in container
  const LocationInContainer *LOCATION() const {
    return GetPointer<const LocationInContainer *>(VT_LOCATION);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENT_REF) &&
           verifier.VerifyString(ARGUMENT_REF()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(LOCATION()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           verifier.EndTable();
  }
};

struct ArgumentRefEntryBuilder {
  typedef ArgumentRefEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ARGUMENT_REF(::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_REF) {
    fbb_.AddOffset(ArgumentRefEntry::VT_ARGUMENT_REF, ARGUMENT_REF);
  }
  void add_LOCATION(::flatbuffers::Offset<LocationInContainer> LOCATION) {
    fbb_.AddOffset(ArgumentRefEntry::VT_LOCATION, LOCATION);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(ArgumentRefEntry::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  explicit ArgumentRefEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgumentRefEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgumentRefEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgumentRefEntry> CreateArgumentRefEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_REF = 0,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0) {
  ArgumentRefEntryBuilder builder_(_fbb);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_LOCATION(LOCATION);
  builder_.add_ARGUMENT_REF(ARGUMENT_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArgumentRefEntry> CreateArgumentRefEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ARGUMENT_REF = nullptr,
    ::flatbuffers::Offset<LocationInContainer> LOCATION = 0,
    const char *SHORT_DESCRIPTION = nullptr) {
  auto ARGUMENT_REF__ = ARGUMENT_REF ? _fbb.CreateString(ARGUMENT_REF) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  return CreateArgumentRefEntry(
      _fbb,
      ARGUMENT_REF__,
      LOCATION,
      SHORT_DESCRIPTION__);
}

/// Command container entry
struct CommandContainerEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandContainerEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENT_REF_ENTRY = 4,
    VT_PARAMETER_REF_ENTRY = 6,
    VT_FIXED_VALUE_ENTRY = 8
  };
  /// Argument reference entry
  const ArgumentRefEntry *ARGUMENT_REF_ENTRY() const {
    return GetPointer<const ArgumentRefEntry *>(VT_ARGUMENT_REF_ENTRY);
  }
  /// Parameter reference entry
  const ParameterRefEntry *PARAMETER_REF_ENTRY() const {
    return GetPointer<const ParameterRefEntry *>(VT_PARAMETER_REF_ENTRY);
  }
  /// Fixed value entry
  const FixedValueEntry *FIXED_VALUE_ENTRY() const {
    return GetPointer<const FixedValueEntry *>(VT_FIXED_VALUE_ENTRY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENT_REF_ENTRY) &&
           verifier.VerifyTable(ARGUMENT_REF_ENTRY()) &&
           VerifyOffset(verifier, VT_PARAMETER_REF_ENTRY) &&
           verifier.VerifyTable(PARAMETER_REF_ENTRY()) &&
           VerifyOffset(verifier, VT_FIXED_VALUE_ENTRY) &&
           verifier.VerifyTable(FIXED_VALUE_ENTRY()) &&
           verifier.EndTable();
  }
};

struct CommandContainerEntryBuilder {
  typedef CommandContainerEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ARGUMENT_REF_ENTRY(::flatbuffers::Offset<ArgumentRefEntry> ARGUMENT_REF_ENTRY) {
    fbb_.AddOffset(CommandContainerEntry::VT_ARGUMENT_REF_ENTRY, ARGUMENT_REF_ENTRY);
  }
  void add_PARAMETER_REF_ENTRY(::flatbuffers::Offset<ParameterRefEntry> PARAMETER_REF_ENTRY) {
    fbb_.AddOffset(CommandContainerEntry::VT_PARAMETER_REF_ENTRY, PARAMETER_REF_ENTRY);
  }
  void add_FIXED_VALUE_ENTRY(::flatbuffers::Offset<FixedValueEntry> FIXED_VALUE_ENTRY) {
    fbb_.AddOffset(CommandContainerEntry::VT_FIXED_VALUE_ENTRY, FIXED_VALUE_ENTRY);
  }
  explicit CommandContainerEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandContainerEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandContainerEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandContainerEntry> CreateCommandContainerEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ArgumentRefEntry> ARGUMENT_REF_ENTRY = 0,
    ::flatbuffers::Offset<ParameterRefEntry> PARAMETER_REF_ENTRY = 0,
    ::flatbuffers::Offset<FixedValueEntry> FIXED_VALUE_ENTRY = 0) {
  CommandContainerEntryBuilder builder_(_fbb);
  builder_.add_FIXED_VALUE_ENTRY(FIXED_VALUE_ENTRY);
  builder_.add_PARAMETER_REF_ENTRY(PARAMETER_REF_ENTRY);
  builder_.add_ARGUMENT_REF_ENTRY(ARGUMENT_REF_ENTRY);
  return builder_.Finish();
}

/// Command container definition
struct CommandContainer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandContainerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ENTRY_LIST = 6,
    VT_BASE_CONTAINER = 8
  };
  /// Container name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Entry list
  const ::flatbuffers::Vector<::flatbuffers::Offset<CommandContainerEntry>> *ENTRY_LIST() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CommandContainerEntry>> *>(VT_ENTRY_LIST);
  }
  /// Base container reference
  const BaseContainer *BASE_CONTAINER() const {
    return GetPointer<const BaseContainer *>(VT_BASE_CONTAINER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_ENTRY_LIST) &&
           verifier.VerifyVector(ENTRY_LIST()) &&
           verifier.VerifyVectorOfTables(ENTRY_LIST()) &&
           VerifyOffset(verifier, VT_BASE_CONTAINER) &&
           verifier.VerifyTable(BASE_CONTAINER()) &&
           verifier.EndTable();
  }
};

struct CommandContainerBuilder {
  typedef CommandContainer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CommandContainer::VT_NAME, NAME);
  }
  void add_ENTRY_LIST(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CommandContainerEntry>>> ENTRY_LIST) {
    fbb_.AddOffset(CommandContainer::VT_ENTRY_LIST, ENTRY_LIST);
  }
  void add_BASE_CONTAINER(::flatbuffers::Offset<BaseContainer> BASE_CONTAINER) {
    fbb_.AddOffset(CommandContainer::VT_BASE_CONTAINER, BASE_CONTAINER);
  }
  explicit CommandContainerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandContainer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandContainer> CreateCommandContainer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CommandContainerEntry>>> ENTRY_LIST = 0,
    ::flatbuffers::Offset<BaseContainer> BASE_CONTAINER = 0) {
  CommandContainerBuilder builder_(_fbb);
  builder_.add_BASE_CONTAINER(BASE_CONTAINER);
  builder_.add_ENTRY_LIST(ENTRY_LIST);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandContainer> CreateCommandContainerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const std::vector<::flatbuffers::Offset<CommandContainerEntry>> *ENTRY_LIST = nullptr,
    ::flatbuffers::Offset<BaseContainer> BASE_CONTAINER = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto ENTRY_LIST__ = ENTRY_LIST ? _fbb.CreateVector<::flatbuffers::Offset<CommandContainerEntry>>(*ENTRY_LIST) : 0;
  return CreateCommandContainer(
      _fbb,
      NAME__,
      ENTRY_LIST__,
      BASE_CONTAINER);
}

/// Command verifier definition
struct CommandVerifier FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandVerifierBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERIFIER_TYPE = 6,
    VT_CONDITION = 8,
    VT_CONTAINER_REF = 10,
    VT_TIME_WINDOW_START = 12,
    VT_TIME_WINDOW_STOP = 14,
    VT_TIME_WINDOW_REF = 16
  };
  /// Verifier name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Verifier type
  VerifierType VERIFIER_TYPE() const {
    return static_cast<VerifierType>(GetField<int8_t>(VT_VERIFIER_TYPE, 0));
  }
  /// Verification condition
  const MatchCriteria *CONDITION() const {
    return GetPointer<const MatchCriteria *>(VT_CONDITION);
  }
  /// Container reference for verification
  const ::flatbuffers::String *CONTAINER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAINER_REF);
  }
  /// Time window start (seconds)
  double TIME_WINDOW_START() const {
    return GetField<double>(VT_TIME_WINDOW_START, 0.0);
  }
  /// Time window stop (seconds)
  double TIME_WINDOW_STOP() const {
    return GetField<double>(VT_TIME_WINDOW_STOP, 0.0);
  }
  /// Time window reference type
  TimeWindowRefType TIME_WINDOW_REF() const {
    return static_cast<TimeWindowRefType>(GetField<int8_t>(VT_TIME_WINDOW_REF, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<int8_t>(verifier, VT_VERIFIER_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyTable(CONDITION()) &&
           VerifyOffset(verifier, VT_CONTAINER_REF) &&
           verifier.VerifyString(CONTAINER_REF()) &&
           VerifyField<double>(verifier, VT_TIME_WINDOW_START, 8) &&
           VerifyField<double>(verifier, VT_TIME_WINDOW_STOP, 8) &&
           VerifyField<int8_t>(verifier, VT_TIME_WINDOW_REF, 1) &&
           verifier.EndTable();
  }
};

struct CommandVerifierBuilder {
  typedef CommandVerifier Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CommandVerifier::VT_NAME, NAME);
  }
  void add_VERIFIER_TYPE(VerifierType VERIFIER_TYPE) {
    fbb_.AddElement<int8_t>(CommandVerifier::VT_VERIFIER_TYPE, static_cast<int8_t>(VERIFIER_TYPE), 0);
  }
  void add_CONDITION(::flatbuffers::Offset<MatchCriteria> CONDITION) {
    fbb_.AddOffset(CommandVerifier::VT_CONDITION, CONDITION);
  }
  void add_CONTAINER_REF(::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF) {
    fbb_.AddOffset(CommandVerifier::VT_CONTAINER_REF, CONTAINER_REF);
  }
  void add_TIME_WINDOW_START(double TIME_WINDOW_START) {
    fbb_.AddElement<double>(CommandVerifier::VT_TIME_WINDOW_START, TIME_WINDOW_START, 0.0);
  }
  void add_TIME_WINDOW_STOP(double TIME_WINDOW_STOP) {
    fbb_.AddElement<double>(CommandVerifier::VT_TIME_WINDOW_STOP, TIME_WINDOW_STOP, 0.0);
  }
  void add_TIME_WINDOW_REF(TimeWindowRefType TIME_WINDOW_REF) {
    fbb_.AddElement<int8_t>(CommandVerifier::VT_TIME_WINDOW_REF, static_cast<int8_t>(TIME_WINDOW_REF), 0);
  }
  explicit CommandVerifierBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandVerifier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandVerifier>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandVerifier> CreateCommandVerifier(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    VerifierType VERIFIER_TYPE = VerifierType_START,
    ::flatbuffers::Offset<MatchCriteria> CONDITION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONTAINER_REF = 0,
    double TIME_WINDOW_START = 0.0,
    double TIME_WINDOW_STOP = 0.0,
    TimeWindowRefType TIME_WINDOW_REF = TimeWindowRefType_COMMAND_RELEASE) {
  CommandVerifierBuilder builder_(_fbb);
  builder_.add_TIME_WINDOW_STOP(TIME_WINDOW_STOP);
  builder_.add_TIME_WINDOW_START(TIME_WINDOW_START);
  builder_.add_CONTAINER_REF(CONTAINER_REF);
  builder_.add_CONDITION(CONDITION);
  builder_.add_NAME(NAME);
  builder_.add_TIME_WINDOW_REF(TIME_WINDOW_REF);
  builder_.add_VERIFIER_TYPE(VERIFIER_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandVerifier> CreateCommandVerifierDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    VerifierType VERIFIER_TYPE = VerifierType_START,
    ::flatbuffers::Offset<MatchCriteria> CONDITION = 0,
    const char *CONTAINER_REF = nullptr,
    double TIME_WINDOW_START = 0.0,
    double TIME_WINDOW_STOP = 0.0,
    TimeWindowRefType TIME_WINDOW_REF = TimeWindowRefType_COMMAND_RELEASE) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto CONTAINER_REF__ = CONTAINER_REF ? _fbb.CreateString(CONTAINER_REF) : 0;
  return CreateCommandVerifier(
      _fbb,
      NAME__,
      VERIFIER_TYPE,
      CONDITION,
      CONTAINER_REF__,
      TIME_WINDOW_START,
      TIME_WINDOW_STOP,
      TIME_WINDOW_REF);
}

/// Significance of command execution
struct CommandSignificance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandSignificanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSEQUENCE_LEVEL = 4,
    VT_REASON_FOR_WARNING = 6
  };
  /// Consequence level (1=lowest, higher=more severe)
  uint8_t CONSEQUENCE_LEVEL() const {
    return GetField<uint8_t>(VT_CONSEQUENCE_LEVEL, 0);
  }
  /// Reason for significance
  const ::flatbuffers::String *REASON_FOR_WARNING() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON_FOR_WARNING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONSEQUENCE_LEVEL, 1) &&
           VerifyOffset(verifier, VT_REASON_FOR_WARNING) &&
           verifier.VerifyString(REASON_FOR_WARNING()) &&
           verifier.EndTable();
  }
};

struct CommandSignificanceBuilder {
  typedef CommandSignificance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CONSEQUENCE_LEVEL(uint8_t CONSEQUENCE_LEVEL) {
    fbb_.AddElement<uint8_t>(CommandSignificance::VT_CONSEQUENCE_LEVEL, CONSEQUENCE_LEVEL, 0);
  }
  void add_REASON_FOR_WARNING(::flatbuffers::Offset<::flatbuffers::String> REASON_FOR_WARNING) {
    fbb_.AddOffset(CommandSignificance::VT_REASON_FOR_WARNING, REASON_FOR_WARNING);
  }
  explicit CommandSignificanceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandSignificance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandSignificance>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandSignificance> CreateCommandSignificance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t CONSEQUENCE_LEVEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REASON_FOR_WARNING = 0) {
  CommandSignificanceBuilder builder_(_fbb);
  builder_.add_REASON_FOR_WARNING(REASON_FOR_WARNING);
  builder_.add_CONSEQUENCE_LEVEL(CONSEQUENCE_LEVEL);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandSignificance> CreateCommandSignificanceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t CONSEQUENCE_LEVEL = 0,
    const char *REASON_FOR_WARNING = nullptr) {
  auto REASON_FOR_WARNING__ = REASON_FOR_WARNING ? _fbb.CreateString(REASON_FOR_WARNING) : 0;
  return CreateCommandSignificance(
      _fbb,
      CONSEQUENCE_LEVEL,
      REASON_FOR_WARNING__);
}

/// Base metacommand reference
struct BaseMetaCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BaseMetaCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META_COMMAND_REF = 4,
    VT_ARGUMENT_ASSIGNMENTS = 6
  };
  /// MetaCommand reference
  const ::flatbuffers::String *META_COMMAND_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_META_COMMAND_REF);
  }
  /// Argument assignments for inherited arguments
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArgumentAssignment>> *ARGUMENT_ASSIGNMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArgumentAssignment>> *>(VT_ARGUMENT_ASSIGNMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META_COMMAND_REF) &&
           verifier.VerifyString(META_COMMAND_REF()) &&
           VerifyOffset(verifier, VT_ARGUMENT_ASSIGNMENTS) &&
           verifier.VerifyVector(ARGUMENT_ASSIGNMENTS()) &&
           verifier.VerifyVectorOfTables(ARGUMENT_ASSIGNMENTS()) &&
           verifier.EndTable();
  }
};

struct BaseMetaCommandBuilder {
  typedef BaseMetaCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_META_COMMAND_REF(::flatbuffers::Offset<::flatbuffers::String> META_COMMAND_REF) {
    fbb_.AddOffset(BaseMetaCommand::VT_META_COMMAND_REF, META_COMMAND_REF);
  }
  void add_ARGUMENT_ASSIGNMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArgumentAssignment>>> ARGUMENT_ASSIGNMENTS) {
    fbb_.AddOffset(BaseMetaCommand::VT_ARGUMENT_ASSIGNMENTS, ARGUMENT_ASSIGNMENTS);
  }
  explicit BaseMetaCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BaseMetaCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BaseMetaCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BaseMetaCommand> CreateBaseMetaCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> META_COMMAND_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArgumentAssignment>>> ARGUMENT_ASSIGNMENTS = 0) {
  BaseMetaCommandBuilder builder_(_fbb);
  builder_.add_ARGUMENT_ASSIGNMENTS(ARGUMENT_ASSIGNMENTS);
  builder_.add_META_COMMAND_REF(META_COMMAND_REF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BaseMetaCommand> CreateBaseMetaCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *META_COMMAND_REF = nullptr,
    const std::vector<::flatbuffers::Offset<ArgumentAssignment>> *ARGUMENT_ASSIGNMENTS = nullptr) {
  auto META_COMMAND_REF__ = META_COMMAND_REF ? _fbb.CreateString(META_COMMAND_REF) : 0;
  auto ARGUMENT_ASSIGNMENTS__ = ARGUMENT_ASSIGNMENTS ? _fbb.CreateVector<::flatbuffers::Offset<ArgumentAssignment>>(*ARGUMENT_ASSIGNMENTS) : 0;
  return CreateBaseMetaCommand(
      _fbb,
      META_COMMAND_REF__,
      ARGUMENT_ASSIGNMENTS__);
}

/// Argument assignment (value binding)
struct ArgumentAssignment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgumentAssignmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENT_NAME = 4,
    VT_VALUE = 6
  };
  /// Argument name
  const ::flatbuffers::String *ARGUMENT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARGUMENT_NAME);
  }
  /// Assigned value
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENT_NAME) &&
           verifier.VerifyString(ARGUMENT_NAME()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           verifier.EndTable();
  }
};

struct ArgumentAssignmentBuilder {
  typedef ArgumentAssignment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ARGUMENT_NAME(::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_NAME) {
    fbb_.AddOffset(ArgumentAssignment::VT_ARGUMENT_NAME, ARGUMENT_NAME);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(ArgumentAssignment::VT_VALUE, VALUE);
  }
  explicit ArgumentAssignmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgumentAssignment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgumentAssignment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgumentAssignment> CreateArgumentAssignment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ARGUMENT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0) {
  ArgumentAssignmentBuilder builder_(_fbb);
  builder_.add_VALUE(VALUE);
  builder_.add_ARGUMENT_NAME(ARGUMENT_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ArgumentAssignment> CreateArgumentAssignmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ARGUMENT_NAME = nullptr,
    const char *VALUE = nullptr) {
  auto ARGUMENT_NAME__ = ARGUMENT_NAME ? _fbb.CreateString(ARGUMENT_NAME) : 0;
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateArgumentAssignment(
      _fbb,
      ARGUMENT_NAME__,
      VALUE__);
}

/// Interlock constraint
struct Interlock FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InterlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_REF = 4,
    VT_VALUE = 6,
    VT_OPERATOR = 8
  };
  /// Parameter reference
  const ::flatbuffers::String *PARAMETER_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARAMETER_REF);
  }
  /// Required value
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  /// Operator for comparison
  ComparisonOperator OPERATOR() const {
    return static_cast<ComparisonOperator>(GetField<int8_t>(VT_OPERATOR, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_REF) &&
           verifier.VerifyString(PARAMETER_REF()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           VerifyField<int8_t>(verifier, VT_OPERATOR, 1) &&
           verifier.EndTable();
  }
};

struct InterlockBuilder {
  typedef Interlock Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_REF(::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF) {
    fbb_.AddOffset(Interlock::VT_PARAMETER_REF, PARAMETER_REF);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(Interlock::VT_VALUE, VALUE);
  }
  void add_OPERATOR(ComparisonOperator OPERATOR) {
    fbb_.AddElement<int8_t>(Interlock::VT_OPERATOR, static_cast<int8_t>(OPERATOR), 0);
  }
  explicit InterlockBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Interlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Interlock>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Interlock> CreateInterlock(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PARAMETER_REF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0,
    ComparisonOperator OPERATOR = ComparisonOperator_EQ) {
  InterlockBuilder builder_(_fbb);
  builder_.add_VALUE(VALUE);
  builder_.add_PARAMETER_REF(PARAMETER_REF);
  builder_.add_OPERATOR(OPERATOR);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Interlock> CreateInterlockDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PARAMETER_REF = nullptr,
    const char *VALUE = nullptr,
    ComparisonOperator OPERATOR = ComparisonOperator_EQ) {
  auto PARAMETER_REF__ = PARAMETER_REF ? _fbb.CreateString(PARAMETER_REF) : 0;
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateInterlock(
      _fbb,
      PARAMETER_REF__,
      VALUE__,
      OPERATOR);
}

/// MetaCommand definition
struct MetaCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetaCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_ABSTRACT = 10,
    VT_ARGUMENTS = 12,
    VT_COMMAND_CONTAINER = 14,
    VT_BASE_META_COMMAND = 16,
    VT_VERIFIERS = 18,
    VT_SIGNIFICANCE = 20,
    VT_INTERLOCKS = 22,
    VT_DEFAULT_SIGNIFICANCE = 24
  };
  /// Command name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Abstract command (base only)
  bool ABSTRACT() const {
    return GetField<uint8_t>(VT_ABSTRACT, 0) != 0;
  }
  /// Argument list
  const ::flatbuffers::Vector<::flatbuffers::Offset<Argument>> *ARGUMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Argument>> *>(VT_ARGUMENTS);
  }
  /// Command container
  const CommandContainer *COMMAND_CONTAINER() const {
    return GetPointer<const CommandContainer *>(VT_COMMAND_CONTAINER);
  }
  /// Base metacommand (inheritance)
  const BaseMetaCommand *BASE_META_COMMAND() const {
    return GetPointer<const BaseMetaCommand *>(VT_BASE_META_COMMAND);
  }
  /// Command verifiers
  const ::flatbuffers::Vector<::flatbuffers::Offset<CommandVerifier>> *VERIFIERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CommandVerifier>> *>(VT_VERIFIERS);
  }
  /// Command significance
  const CommandSignificance *SIGNIFICANCE() const {
    return GetPointer<const CommandSignificance *>(VT_SIGNIFICANCE);
  }
  /// Interlock constraints
  const ::flatbuffers::Vector<::flatbuffers::Offset<Interlock>> *INTERLOCKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Interlock>> *>(VT_INTERLOCKS);
  }
  /// Default significance
  const CommandSignificance *DEFAULT_SIGNIFICANCE() const {
    return GetPointer<const CommandSignificance *>(VT_DEFAULT_SIGNIFICANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_ABSTRACT, 1) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(ARGUMENTS()) &&
           verifier.VerifyVectorOfTables(ARGUMENTS()) &&
           VerifyOffset(verifier, VT_COMMAND_CONTAINER) &&
           verifier.VerifyTable(COMMAND_CONTAINER()) &&
           VerifyOffset(verifier, VT_BASE_META_COMMAND) &&
           verifier.VerifyTable(BASE_META_COMMAND()) &&
           VerifyOffset(verifier, VT_VERIFIERS) &&
           verifier.VerifyVector(VERIFIERS()) &&
           verifier.VerifyVectorOfTables(VERIFIERS()) &&
           VerifyOffset(verifier, VT_SIGNIFICANCE) &&
           verifier.VerifyTable(SIGNIFICANCE()) &&
           VerifyOffset(verifier, VT_INTERLOCKS) &&
           verifier.VerifyVector(INTERLOCKS()) &&
           verifier.VerifyVectorOfTables(INTERLOCKS()) &&
           VerifyOffset(verifier, VT_DEFAULT_SIGNIFICANCE) &&
           verifier.VerifyTable(DEFAULT_SIGNIFICANCE()) &&
           verifier.EndTable();
  }
};

struct MetaCommandBuilder {
  typedef MetaCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(MetaCommand::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(MetaCommand::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(MetaCommand::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_ABSTRACT(bool ABSTRACT) {
    fbb_.AddElement<uint8_t>(MetaCommand::VT_ABSTRACT, static_cast<uint8_t>(ABSTRACT), 0);
  }
  void add_ARGUMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Argument>>> ARGUMENTS) {
    fbb_.AddOffset(MetaCommand::VT_ARGUMENTS, ARGUMENTS);
  }
  void add_COMMAND_CONTAINER(::flatbuffers::Offset<CommandContainer> COMMAND_CONTAINER) {
    fbb_.AddOffset(MetaCommand::VT_COMMAND_CONTAINER, COMMAND_CONTAINER);
  }
  void add_BASE_META_COMMAND(::flatbuffers::Offset<BaseMetaCommand> BASE_META_COMMAND) {
    fbb_.AddOffset(MetaCommand::VT_BASE_META_COMMAND, BASE_META_COMMAND);
  }
  void add_VERIFIERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CommandVerifier>>> VERIFIERS) {
    fbb_.AddOffset(MetaCommand::VT_VERIFIERS, VERIFIERS);
  }
  void add_SIGNIFICANCE(::flatbuffers::Offset<CommandSignificance> SIGNIFICANCE) {
    fbb_.AddOffset(MetaCommand::VT_SIGNIFICANCE, SIGNIFICANCE);
  }
  void add_INTERLOCKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Interlock>>> INTERLOCKS) {
    fbb_.AddOffset(MetaCommand::VT_INTERLOCKS, INTERLOCKS);
  }
  void add_DEFAULT_SIGNIFICANCE(::flatbuffers::Offset<CommandSignificance> DEFAULT_SIGNIFICANCE) {
    fbb_.AddOffset(MetaCommand::VT_DEFAULT_SIGNIFICANCE, DEFAULT_SIGNIFICANCE);
  }
  explicit MetaCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetaCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetaCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetaCommand> CreateMetaCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    bool ABSTRACT = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Argument>>> ARGUMENTS = 0,
    ::flatbuffers::Offset<CommandContainer> COMMAND_CONTAINER = 0,
    ::flatbuffers::Offset<BaseMetaCommand> BASE_META_COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CommandVerifier>>> VERIFIERS = 0,
    ::flatbuffers::Offset<CommandSignificance> SIGNIFICANCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Interlock>>> INTERLOCKS = 0,
    ::flatbuffers::Offset<CommandSignificance> DEFAULT_SIGNIFICANCE = 0) {
  MetaCommandBuilder builder_(_fbb);
  builder_.add_DEFAULT_SIGNIFICANCE(DEFAULT_SIGNIFICANCE);
  builder_.add_INTERLOCKS(INTERLOCKS);
  builder_.add_SIGNIFICANCE(SIGNIFICANCE);
  builder_.add_VERIFIERS(VERIFIERS);
  builder_.add_BASE_META_COMMAND(BASE_META_COMMAND);
  builder_.add_COMMAND_CONTAINER(COMMAND_CONTAINER);
  builder_.add_ARGUMENTS(ARGUMENTS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_ABSTRACT(ABSTRACT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MetaCommand> CreateMetaCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    bool ABSTRACT = false,
    const std::vector<::flatbuffers::Offset<Argument>> *ARGUMENTS = nullptr,
    ::flatbuffers::Offset<CommandContainer> COMMAND_CONTAINER = 0,
    ::flatbuffers::Offset<BaseMetaCommand> BASE_META_COMMAND = 0,
    const std::vector<::flatbuffers::Offset<CommandVerifier>> *VERIFIERS = nullptr,
    ::flatbuffers::Offset<CommandSignificance> SIGNIFICANCE = 0,
    const std::vector<::flatbuffers::Offset<Interlock>> *INTERLOCKS = nullptr,
    ::flatbuffers::Offset<CommandSignificance> DEFAULT_SIGNIFICANCE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto ARGUMENTS__ = ARGUMENTS ? _fbb.CreateVector<::flatbuffers::Offset<Argument>>(*ARGUMENTS) : 0;
  auto VERIFIERS__ = VERIFIERS ? _fbb.CreateVector<::flatbuffers::Offset<CommandVerifier>>(*VERIFIERS) : 0;
  auto INTERLOCKS__ = INTERLOCKS ? _fbb.CreateVector<::flatbuffers::Offset<Interlock>>(*INTERLOCKS) : 0;
  return CreateMetaCommand(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      ABSTRACT,
      ARGUMENTS__,
      COMMAND_CONTAINER,
      BASE_META_COMMAND,
      VERIFIERS__,
      SIGNIFICANCE,
      INTERLOCKS__,
      DEFAULT_SIGNIFICANCE);
}

/// Collection of metacommands
struct MetaCommandSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetaCommandSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_META_COMMANDS = 4
  };
  /// MetaCommands
  const ::flatbuffers::Vector<::flatbuffers::Offset<MetaCommand>> *META_COMMANDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MetaCommand>> *>(VT_META_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_META_COMMANDS) &&
           verifier.VerifyVector(META_COMMANDS()) &&
           verifier.VerifyVectorOfTables(META_COMMANDS()) &&
           verifier.EndTable();
  }
};

struct MetaCommandSetBuilder {
  typedef MetaCommandSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_META_COMMANDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MetaCommand>>> META_COMMANDS) {
    fbb_.AddOffset(MetaCommandSet::VT_META_COMMANDS, META_COMMANDS);
  }
  explicit MetaCommandSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetaCommandSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetaCommandSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetaCommandSet> CreateMetaCommandSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MetaCommand>>> META_COMMANDS = 0) {
  MetaCommandSetBuilder builder_(_fbb);
  builder_.add_META_COMMANDS(META_COMMANDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MetaCommandSet> CreateMetaCommandSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<MetaCommand>> *META_COMMANDS = nullptr) {
  auto META_COMMANDS__ = META_COMMANDS ? _fbb.CreateVector<::flatbuffers::Offset<MetaCommand>>(*META_COMMANDS) : 0;
  return CreateMetaCommandSet(
      _fbb,
      META_COMMANDS__);
}

/// Fixed frame stream
struct FixedFrameStream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FixedFrameStreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_FRAME_SIZE_IN_BITS = 8,
    VT_SYNC_PATTERN = 10
  };
  /// Stream name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Frame size in bits
  uint32_t FRAME_SIZE_IN_BITS() const {
    return GetField<uint32_t>(VT_FRAME_SIZE_IN_BITS, 0);
  }
  /// Sync pattern (hex string)
  const ::flatbuffers::String *SYNC_PATTERN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYNC_PATTERN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_SIZE_IN_BITS, 4) &&
           VerifyOffset(verifier, VT_SYNC_PATTERN) &&
           verifier.VerifyString(SYNC_PATTERN()) &&
           verifier.EndTable();
  }
};

struct FixedFrameStreamBuilder {
  typedef FixedFrameStream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(FixedFrameStream::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(FixedFrameStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_FRAME_SIZE_IN_BITS(uint32_t FRAME_SIZE_IN_BITS) {
    fbb_.AddElement<uint32_t>(FixedFrameStream::VT_FRAME_SIZE_IN_BITS, FRAME_SIZE_IN_BITS, 0);
  }
  void add_SYNC_PATTERN(::flatbuffers::Offset<::flatbuffers::String> SYNC_PATTERN) {
    fbb_.AddOffset(FixedFrameStream::VT_SYNC_PATTERN, SYNC_PATTERN);
  }
  explicit FixedFrameStreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FixedFrameStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FixedFrameStream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FixedFrameStream> CreateFixedFrameStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    uint32_t FRAME_SIZE_IN_BITS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SYNC_PATTERN = 0) {
  FixedFrameStreamBuilder builder_(_fbb);
  builder_.add_SYNC_PATTERN(SYNC_PATTERN);
  builder_.add_FRAME_SIZE_IN_BITS(FRAME_SIZE_IN_BITS);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FixedFrameStream> CreateFixedFrameStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    uint32_t FRAME_SIZE_IN_BITS = 0,
    const char *SYNC_PATTERN = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto SYNC_PATTERN__ = SYNC_PATTERN ? _fbb.CreateString(SYNC_PATTERN) : 0;
  return CreateFixedFrameStream(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      FRAME_SIZE_IN_BITS,
      SYNC_PATTERN__);
}

/// Variable frame stream
struct VariableFrameStream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VariableFrameStreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_MIN_FRAME_SIZE_IN_BITS = 8,
    VT_MAX_FRAME_SIZE_IN_BITS = 10,
    VT_SIZE_FIELD_OFFSET = 12,
    VT_SIZE_FIELD_SIZE = 14
  };
  /// Stream name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Minimum frame size in bits
  uint32_t MIN_FRAME_SIZE_IN_BITS() const {
    return GetField<uint32_t>(VT_MIN_FRAME_SIZE_IN_BITS, 0);
  }
  /// Maximum frame size in bits
  uint32_t MAX_FRAME_SIZE_IN_BITS() const {
    return GetField<uint32_t>(VT_MAX_FRAME_SIZE_IN_BITS, 0);
  }
  /// Size field location in bits
  uint32_t SIZE_FIELD_OFFSET() const {
    return GetField<uint32_t>(VT_SIZE_FIELD_OFFSET, 0);
  }
  /// Size field size in bits
  uint16_t SIZE_FIELD_SIZE() const {
    return GetField<uint16_t>(VT_SIZE_FIELD_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyField<uint32_t>(verifier, VT_MIN_FRAME_SIZE_IN_BITS, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_FRAME_SIZE_IN_BITS, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_FIELD_OFFSET, 4) &&
           VerifyField<uint16_t>(verifier, VT_SIZE_FIELD_SIZE, 2) &&
           verifier.EndTable();
  }
};

struct VariableFrameStreamBuilder {
  typedef VariableFrameStream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(VariableFrameStream::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(VariableFrameStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_MIN_FRAME_SIZE_IN_BITS(uint32_t MIN_FRAME_SIZE_IN_BITS) {
    fbb_.AddElement<uint32_t>(VariableFrameStream::VT_MIN_FRAME_SIZE_IN_BITS, MIN_FRAME_SIZE_IN_BITS, 0);
  }
  void add_MAX_FRAME_SIZE_IN_BITS(uint32_t MAX_FRAME_SIZE_IN_BITS) {
    fbb_.AddElement<uint32_t>(VariableFrameStream::VT_MAX_FRAME_SIZE_IN_BITS, MAX_FRAME_SIZE_IN_BITS, 0);
  }
  void add_SIZE_FIELD_OFFSET(uint32_t SIZE_FIELD_OFFSET) {
    fbb_.AddElement<uint32_t>(VariableFrameStream::VT_SIZE_FIELD_OFFSET, SIZE_FIELD_OFFSET, 0);
  }
  void add_SIZE_FIELD_SIZE(uint16_t SIZE_FIELD_SIZE) {
    fbb_.AddElement<uint16_t>(VariableFrameStream::VT_SIZE_FIELD_SIZE, SIZE_FIELD_SIZE, 0);
  }
  explicit VariableFrameStreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VariableFrameStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VariableFrameStream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VariableFrameStream> CreateVariableFrameStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    uint32_t MIN_FRAME_SIZE_IN_BITS = 0,
    uint32_t MAX_FRAME_SIZE_IN_BITS = 0,
    uint32_t SIZE_FIELD_OFFSET = 0,
    uint16_t SIZE_FIELD_SIZE = 0) {
  VariableFrameStreamBuilder builder_(_fbb);
  builder_.add_SIZE_FIELD_OFFSET(SIZE_FIELD_OFFSET);
  builder_.add_MAX_FRAME_SIZE_IN_BITS(MAX_FRAME_SIZE_IN_BITS);
  builder_.add_MIN_FRAME_SIZE_IN_BITS(MIN_FRAME_SIZE_IN_BITS);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_SIZE_FIELD_SIZE(SIZE_FIELD_SIZE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VariableFrameStream> CreateVariableFrameStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    uint32_t MIN_FRAME_SIZE_IN_BITS = 0,
    uint32_t MAX_FRAME_SIZE_IN_BITS = 0,
    uint32_t SIZE_FIELD_OFFSET = 0,
    uint16_t SIZE_FIELD_SIZE = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  return CreateVariableFrameStream(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      MIN_FRAME_SIZE_IN_BITS,
      MAX_FRAME_SIZE_IN_BITS,
      SIZE_FIELD_OFFSET,
      SIZE_FIELD_SIZE);
}

/// Custom stream
struct CustomStream FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomStreamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_ALGORITHM_REF = 8
  };
  /// Stream name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Algorithm reference for parsing
  const ::flatbuffers::String *ALGORITHM_REF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM_REF);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_ALGORITHM_REF) &&
           verifier.VerifyString(ALGORITHM_REF()) &&
           verifier.EndTable();
  }
};

struct CustomStreamBuilder {
  typedef CustomStream Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CustomStream::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(CustomStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_ALGORITHM_REF(::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_REF) {
    fbb_.AddOffset(CustomStream::VT_ALGORITHM_REF, ALGORITHM_REF);
  }
  explicit CustomStreamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomStream> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomStream>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomStream> CreateCustomStream(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_REF = 0) {
  CustomStreamBuilder builder_(_fbb);
  builder_.add_ALGORITHM_REF(ALGORITHM_REF);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomStream> CreateCustomStreamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *ALGORITHM_REF = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto ALGORITHM_REF__ = ALGORITHM_REF ? _fbb.CreateString(ALGORITHM_REF) : 0;
  return CreateCustomStream(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      ALGORITHM_REF__);
}

/// Collection of streams
struct StreamSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StreamSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIXED_FRAME_STREAMS = 4,
    VT_VARIABLE_FRAME_STREAMS = 6,
    VT_CUSTOM_STREAMS = 8
  };
  /// Fixed frame streams
  const ::flatbuffers::Vector<::flatbuffers::Offset<FixedFrameStream>> *FIXED_FRAME_STREAMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FixedFrameStream>> *>(VT_FIXED_FRAME_STREAMS);
  }
  /// Variable frame streams
  const ::flatbuffers::Vector<::flatbuffers::Offset<VariableFrameStream>> *VARIABLE_FRAME_STREAMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VariableFrameStream>> *>(VT_VARIABLE_FRAME_STREAMS);
  }
  /// Custom streams
  const ::flatbuffers::Vector<::flatbuffers::Offset<CustomStream>> *CUSTOM_STREAMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CustomStream>> *>(VT_CUSTOM_STREAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIXED_FRAME_STREAMS) &&
           verifier.VerifyVector(FIXED_FRAME_STREAMS()) &&
           verifier.VerifyVectorOfTables(FIXED_FRAME_STREAMS()) &&
           VerifyOffset(verifier, VT_VARIABLE_FRAME_STREAMS) &&
           verifier.VerifyVector(VARIABLE_FRAME_STREAMS()) &&
           verifier.VerifyVectorOfTables(VARIABLE_FRAME_STREAMS()) &&
           VerifyOffset(verifier, VT_CUSTOM_STREAMS) &&
           verifier.VerifyVector(CUSTOM_STREAMS()) &&
           verifier.VerifyVectorOfTables(CUSTOM_STREAMS()) &&
           verifier.EndTable();
  }
};

struct StreamSetBuilder {
  typedef StreamSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FIXED_FRAME_STREAMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FixedFrameStream>>> FIXED_FRAME_STREAMS) {
    fbb_.AddOffset(StreamSet::VT_FIXED_FRAME_STREAMS, FIXED_FRAME_STREAMS);
  }
  void add_VARIABLE_FRAME_STREAMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VariableFrameStream>>> VARIABLE_FRAME_STREAMS) {
    fbb_.AddOffset(StreamSet::VT_VARIABLE_FRAME_STREAMS, VARIABLE_FRAME_STREAMS);
  }
  void add_CUSTOM_STREAMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CustomStream>>> CUSTOM_STREAMS) {
    fbb_.AddOffset(StreamSet::VT_CUSTOM_STREAMS, CUSTOM_STREAMS);
  }
  explicit StreamSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StreamSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StreamSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StreamSet> CreateStreamSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FixedFrameStream>>> FIXED_FRAME_STREAMS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VariableFrameStream>>> VARIABLE_FRAME_STREAMS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CustomStream>>> CUSTOM_STREAMS = 0) {
  StreamSetBuilder builder_(_fbb);
  builder_.add_CUSTOM_STREAMS(CUSTOM_STREAMS);
  builder_.add_VARIABLE_FRAME_STREAMS(VARIABLE_FRAME_STREAMS);
  builder_.add_FIXED_FRAME_STREAMS(FIXED_FRAME_STREAMS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StreamSet> CreateStreamSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<FixedFrameStream>> *FIXED_FRAME_STREAMS = nullptr,
    const std::vector<::flatbuffers::Offset<VariableFrameStream>> *VARIABLE_FRAME_STREAMS = nullptr,
    const std::vector<::flatbuffers::Offset<CustomStream>> *CUSTOM_STREAMS = nullptr) {
  auto FIXED_FRAME_STREAMS__ = FIXED_FRAME_STREAMS ? _fbb.CreateVector<::flatbuffers::Offset<FixedFrameStream>>(*FIXED_FRAME_STREAMS) : 0;
  auto VARIABLE_FRAME_STREAMS__ = VARIABLE_FRAME_STREAMS ? _fbb.CreateVector<::flatbuffers::Offset<VariableFrameStream>>(*VARIABLE_FRAME_STREAMS) : 0;
  auto CUSTOM_STREAMS__ = CUSTOM_STREAMS ? _fbb.CreateVector<::flatbuffers::Offset<CustomStream>>(*CUSTOM_STREAMS) : 0;
  return CreateStreamSet(
      _fbb,
      FIXED_FRAME_STREAMS__,
      VARIABLE_FRAME_STREAMS__,
      CUSTOM_STREAMS__);
}

/// Service definition
struct Service FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServiceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_CONTAINER_REFS = 10,
    VT_COMMAND_REFS = 12
  };
  /// Service name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Container references provided by this service
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *CONTAINER_REFS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CONTAINER_REFS);
  }
  /// Command references accepted by this service
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMAND_REFS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMMAND_REFS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_CONTAINER_REFS) &&
           verifier.VerifyVector(CONTAINER_REFS()) &&
           verifier.VerifyVectorOfStrings(CONTAINER_REFS()) &&
           VerifyOffset(verifier, VT_COMMAND_REFS) &&
           verifier.VerifyVector(COMMAND_REFS()) &&
           verifier.VerifyVectorOfStrings(COMMAND_REFS()) &&
           verifier.EndTable();
  }
};

struct ServiceBuilder {
  typedef Service Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(Service::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(Service::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(Service::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_CONTAINER_REFS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> CONTAINER_REFS) {
    fbb_.AddOffset(Service::VT_CONTAINER_REFS, CONTAINER_REFS);
  }
  void add_COMMAND_REFS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMAND_REFS) {
    fbb_.AddOffset(Service::VT_COMMAND_REFS, COMMAND_REFS);
  }
  explicit ServiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Service> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Service>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Service> CreateService(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> CONTAINER_REFS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMMAND_REFS = 0) {
  ServiceBuilder builder_(_fbb);
  builder_.add_COMMAND_REFS(COMMAND_REFS);
  builder_.add_CONTAINER_REFS(CONTAINER_REFS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Service> CreateServiceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *CONTAINER_REFS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMMAND_REFS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto CONTAINER_REFS__ = CONTAINER_REFS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*CONTAINER_REFS) : 0;
  auto COMMAND_REFS__ = COMMAND_REFS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMMAND_REFS) : 0;
  return CreateService(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      CONTAINER_REFS__,
      COMMAND_REFS__);
}

/// Collection of services
struct ServiceSet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServiceSetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERVICES = 4
  };
  /// Services
  const ::flatbuffers::Vector<::flatbuffers::Offset<Service>> *SERVICES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Service>> *>(VT_SERVICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.VerifyVector(SERVICES()) &&
           verifier.VerifyVectorOfTables(SERVICES()) &&
           verifier.EndTable();
  }
};

struct ServiceSetBuilder {
  typedef ServiceSet Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SERVICES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Service>>> SERVICES) {
    fbb_.AddOffset(ServiceSet::VT_SERVICES, SERVICES);
  }
  explicit ServiceSetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServiceSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServiceSet>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServiceSet> CreateServiceSet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Service>>> SERVICES = 0) {
  ServiceSetBuilder builder_(_fbb);
  builder_.add_SERVICES(SERVICES);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ServiceSet> CreateServiceSetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Service>> *SERVICES = nullptr) {
  auto SERVICES__ = SERVICES ? _fbb.CreateVector<::flatbuffers::Offset<Service>>(*SERVICES) : 0;
  return CreateServiceSet(
      _fbb,
      SERVICES__);
}

/// Document header information
struct XTCHeader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XTCHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_DATE = 6,
    VT_CLASSIFICATION = 8,
    VT_VALIDATION_STATUS = 10,
    VT_AUTHOR = 12,
    VT_NOTES = 14
  };
  /// Version of this XTCE document
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Date of document creation (ISO 8601)
  const ::flatbuffers::String *DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  /// Classification level
  const ::flatbuffers::String *CLASSIFICATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION);
  }
  /// Validation status
  const ::flatbuffers::String *VALIDATION_STATUS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALIDATION_STATUS);
  }
  /// Author information
  const ::flatbuffers::String *AUTHOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTHOR);
  }
  /// Notes/comments
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *NOTES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(DATE()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyString(CLASSIFICATION()) &&
           VerifyOffset(verifier, VT_VALIDATION_STATUS) &&
           verifier.VerifyString(VALIDATION_STATUS()) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(AUTHOR()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyVector(NOTES()) &&
           verifier.VerifyVectorOfStrings(NOTES()) &&
           verifier.EndTable();
  }
};

struct XTCHeaderBuilder {
  typedef XTCHeader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(XTCHeader::VT_VERSION, VERSION);
  }
  void add_DATE(::flatbuffers::Offset<::flatbuffers::String> DATE) {
    fbb_.AddOffset(XTCHeader::VT_DATE, DATE);
  }
  void add_CLASSIFICATION(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION) {
    fbb_.AddOffset(XTCHeader::VT_CLASSIFICATION, CLASSIFICATION);
  }
  void add_VALIDATION_STATUS(::flatbuffers::Offset<::flatbuffers::String> VALIDATION_STATUS) {
    fbb_.AddOffset(XTCHeader::VT_VALIDATION_STATUS, VALIDATION_STATUS);
  }
  void add_AUTHOR(::flatbuffers::Offset<::flatbuffers::String> AUTHOR) {
    fbb_.AddOffset(XTCHeader::VT_AUTHOR, AUTHOR);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> NOTES) {
    fbb_.AddOffset(XTCHeader::VT_NOTES, NOTES);
  }
  explicit XTCHeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XTCHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XTCHeader>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XTCHeader> CreateXTCHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VALIDATION_STATUS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AUTHOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> NOTES = 0) {
  XTCHeaderBuilder builder_(_fbb);
  builder_.add_NOTES(NOTES);
  builder_.add_AUTHOR(AUTHOR);
  builder_.add_VALIDATION_STATUS(VALIDATION_STATUS);
  builder_.add_CLASSIFICATION(CLASSIFICATION);
  builder_.add_DATE(DATE);
  builder_.add_VERSION(VERSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XTCHeader> CreateXTCHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *VERSION = nullptr,
    const char *DATE = nullptr,
    const char *CLASSIFICATION = nullptr,
    const char *VALIDATION_STATUS = nullptr,
    const char *AUTHOR = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *NOTES = nullptr) {
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  auto DATE__ = DATE ? _fbb.CreateString(DATE) : 0;
  auto CLASSIFICATION__ = CLASSIFICATION ? _fbb.CreateString(CLASSIFICATION) : 0;
  auto VALIDATION_STATUS__ = VALIDATION_STATUS ? _fbb.CreateString(VALIDATION_STATUS) : 0;
  auto AUTHOR__ = AUTHOR ? _fbb.CreateString(AUTHOR) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*NOTES) : 0;
  return CreateXTCHeader(
      _fbb,
      VERSION__,
      DATE__,
      CLASSIFICATION__,
      VALIDATION_STATUS__,
      AUTHOR__,
      NOTES__);
}

/// Telemetry metadata collection
struct TelemetryMetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TelemetryMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_TYPE_SET = 4,
    VT_PARAMETER_SET = 6,
    VT_CONTAINER_SET = 8,
    VT_ALGORITHM_SET = 10,
    VT_STREAM_SET = 12
  };
  /// Parameter type definitions
  const ParameterTypeSet *PARAMETER_TYPE_SET() const {
    return GetPointer<const ParameterTypeSet *>(VT_PARAMETER_TYPE_SET);
  }
  /// Parameter definitions
  const ParameterSet *PARAMETER_SET() const {
    return GetPointer<const ParameterSet *>(VT_PARAMETER_SET);
  }
  /// Container definitions
  const ContainerSet *CONTAINER_SET() const {
    return GetPointer<const ContainerSet *>(VT_CONTAINER_SET);
  }
  /// Algorithm definitions
  const AlgorithmSet *ALGORITHM_SET() const {
    return GetPointer<const AlgorithmSet *>(VT_ALGORITHM_SET);
  }
  /// Stream definitions
  const StreamSet *STREAM_SET() const {
    return GetPointer<const StreamSet *>(VT_STREAM_SET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPE_SET) &&
           verifier.VerifyTable(PARAMETER_TYPE_SET()) &&
           VerifyOffset(verifier, VT_PARAMETER_SET) &&
           verifier.VerifyTable(PARAMETER_SET()) &&
           VerifyOffset(verifier, VT_CONTAINER_SET) &&
           verifier.VerifyTable(CONTAINER_SET()) &&
           VerifyOffset(verifier, VT_ALGORITHM_SET) &&
           verifier.VerifyTable(ALGORITHM_SET()) &&
           VerifyOffset(verifier, VT_STREAM_SET) &&
           verifier.VerifyTable(STREAM_SET()) &&
           verifier.EndTable();
  }
};

struct TelemetryMetaDataBuilder {
  typedef TelemetryMetaData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PARAMETER_TYPE_SET(::flatbuffers::Offset<ParameterTypeSet> PARAMETER_TYPE_SET) {
    fbb_.AddOffset(TelemetryMetaData::VT_PARAMETER_TYPE_SET, PARAMETER_TYPE_SET);
  }
  void add_PARAMETER_SET(::flatbuffers::Offset<ParameterSet> PARAMETER_SET) {
    fbb_.AddOffset(TelemetryMetaData::VT_PARAMETER_SET, PARAMETER_SET);
  }
  void add_CONTAINER_SET(::flatbuffers::Offset<ContainerSet> CONTAINER_SET) {
    fbb_.AddOffset(TelemetryMetaData::VT_CONTAINER_SET, CONTAINER_SET);
  }
  void add_ALGORITHM_SET(::flatbuffers::Offset<AlgorithmSet> ALGORITHM_SET) {
    fbb_.AddOffset(TelemetryMetaData::VT_ALGORITHM_SET, ALGORITHM_SET);
  }
  void add_STREAM_SET(::flatbuffers::Offset<StreamSet> STREAM_SET) {
    fbb_.AddOffset(TelemetryMetaData::VT_STREAM_SET, STREAM_SET);
  }
  explicit TelemetryMetaDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TelemetryMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TelemetryMetaData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TelemetryMetaData> CreateTelemetryMetaData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ParameterTypeSet> PARAMETER_TYPE_SET = 0,
    ::flatbuffers::Offset<ParameterSet> PARAMETER_SET = 0,
    ::flatbuffers::Offset<ContainerSet> CONTAINER_SET = 0,
    ::flatbuffers::Offset<AlgorithmSet> ALGORITHM_SET = 0,
    ::flatbuffers::Offset<StreamSet> STREAM_SET = 0) {
  TelemetryMetaDataBuilder builder_(_fbb);
  builder_.add_STREAM_SET(STREAM_SET);
  builder_.add_ALGORITHM_SET(ALGORITHM_SET);
  builder_.add_CONTAINER_SET(CONTAINER_SET);
  builder_.add_PARAMETER_SET(PARAMETER_SET);
  builder_.add_PARAMETER_TYPE_SET(PARAMETER_TYPE_SET);
  return builder_.Finish();
}

/// Command metadata collection
struct CommandMetaData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandMetaDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENT_TYPE_SET = 4,
    VT_PARAMETER_TYPE_SET = 6,
    VT_PARAMETER_SET = 8,
    VT_META_COMMAND_SET = 10,
    VT_COMMAND_CONTAINER_SET = 12,
    VT_ALGORITHM_SET = 14,
    VT_STREAM_SET = 16
  };
  /// Argument type definitions
  const ArgumentTypeSet *ARGUMENT_TYPE_SET() const {
    return GetPointer<const ArgumentTypeSet *>(VT_ARGUMENT_TYPE_SET);
  }
  /// Parameter types used by commands
  const ParameterTypeSet *PARAMETER_TYPE_SET() const {
    return GetPointer<const ParameterTypeSet *>(VT_PARAMETER_TYPE_SET);
  }
  /// Parameters used by commands
  const ParameterSet *PARAMETER_SET() const {
    return GetPointer<const ParameterSet *>(VT_PARAMETER_SET);
  }
  /// MetaCommand definitions
  const MetaCommandSet *META_COMMAND_SET() const {
    return GetPointer<const MetaCommandSet *>(VT_META_COMMAND_SET);
  }
  /// Command container set
  const ContainerSet *COMMAND_CONTAINER_SET() const {
    return GetPointer<const ContainerSet *>(VT_COMMAND_CONTAINER_SET);
  }
  /// Algorithm definitions
  const AlgorithmSet *ALGORITHM_SET() const {
    return GetPointer<const AlgorithmSet *>(VT_ALGORITHM_SET);
  }
  /// Stream definitions
  const StreamSet *STREAM_SET() const {
    return GetPointer<const StreamSet *>(VT_STREAM_SET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENT_TYPE_SET) &&
           verifier.VerifyTable(ARGUMENT_TYPE_SET()) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPE_SET) &&
           verifier.VerifyTable(PARAMETER_TYPE_SET()) &&
           VerifyOffset(verifier, VT_PARAMETER_SET) &&
           verifier.VerifyTable(PARAMETER_SET()) &&
           VerifyOffset(verifier, VT_META_COMMAND_SET) &&
           verifier.VerifyTable(META_COMMAND_SET()) &&
           VerifyOffset(verifier, VT_COMMAND_CONTAINER_SET) &&
           verifier.VerifyTable(COMMAND_CONTAINER_SET()) &&
           VerifyOffset(verifier, VT_ALGORITHM_SET) &&
           verifier.VerifyTable(ALGORITHM_SET()) &&
           VerifyOffset(verifier, VT_STREAM_SET) &&
           verifier.VerifyTable(STREAM_SET()) &&
           verifier.EndTable();
  }
};

struct CommandMetaDataBuilder {
  typedef CommandMetaData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ARGUMENT_TYPE_SET(::flatbuffers::Offset<ArgumentTypeSet> ARGUMENT_TYPE_SET) {
    fbb_.AddOffset(CommandMetaData::VT_ARGUMENT_TYPE_SET, ARGUMENT_TYPE_SET);
  }
  void add_PARAMETER_TYPE_SET(::flatbuffers::Offset<ParameterTypeSet> PARAMETER_TYPE_SET) {
    fbb_.AddOffset(CommandMetaData::VT_PARAMETER_TYPE_SET, PARAMETER_TYPE_SET);
  }
  void add_PARAMETER_SET(::flatbuffers::Offset<ParameterSet> PARAMETER_SET) {
    fbb_.AddOffset(CommandMetaData::VT_PARAMETER_SET, PARAMETER_SET);
  }
  void add_META_COMMAND_SET(::flatbuffers::Offset<MetaCommandSet> META_COMMAND_SET) {
    fbb_.AddOffset(CommandMetaData::VT_META_COMMAND_SET, META_COMMAND_SET);
  }
  void add_COMMAND_CONTAINER_SET(::flatbuffers::Offset<ContainerSet> COMMAND_CONTAINER_SET) {
    fbb_.AddOffset(CommandMetaData::VT_COMMAND_CONTAINER_SET, COMMAND_CONTAINER_SET);
  }
  void add_ALGORITHM_SET(::flatbuffers::Offset<AlgorithmSet> ALGORITHM_SET) {
    fbb_.AddOffset(CommandMetaData::VT_ALGORITHM_SET, ALGORITHM_SET);
  }
  void add_STREAM_SET(::flatbuffers::Offset<StreamSet> STREAM_SET) {
    fbb_.AddOffset(CommandMetaData::VT_STREAM_SET, STREAM_SET);
  }
  explicit CommandMetaDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandMetaData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandMetaData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandMetaData> CreateCommandMetaData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ArgumentTypeSet> ARGUMENT_TYPE_SET = 0,
    ::flatbuffers::Offset<ParameterTypeSet> PARAMETER_TYPE_SET = 0,
    ::flatbuffers::Offset<ParameterSet> PARAMETER_SET = 0,
    ::flatbuffers::Offset<MetaCommandSet> META_COMMAND_SET = 0,
    ::flatbuffers::Offset<ContainerSet> COMMAND_CONTAINER_SET = 0,
    ::flatbuffers::Offset<AlgorithmSet> ALGORITHM_SET = 0,
    ::flatbuffers::Offset<StreamSet> STREAM_SET = 0) {
  CommandMetaDataBuilder builder_(_fbb);
  builder_.add_STREAM_SET(STREAM_SET);
  builder_.add_ALGORITHM_SET(ALGORITHM_SET);
  builder_.add_COMMAND_CONTAINER_SET(COMMAND_CONTAINER_SET);
  builder_.add_META_COMMAND_SET(META_COMMAND_SET);
  builder_.add_PARAMETER_SET(PARAMETER_SET);
  builder_.add_PARAMETER_TYPE_SET(PARAMETER_TYPE_SET);
  builder_.add_ARGUMENT_TYPE_SET(ARGUMENT_TYPE_SET);
  return builder_.Finish();
}

/// SpaceSystem - Root element for XTCE document
/// A SpaceSystem defines the telemetry and command configuration for a space
/// vehicle or subsystem. SpaceSystems can be nested hierarchically to represent
/// the structure of a spacecraft (e.g., spacecraft -> subsystem -> payload).
struct XTC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef XTCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHORT_DESCRIPTION = 6,
    VT_LONG_DESCRIPTION = 8,
    VT_OPERATIONAL_STATUS = 10,
    VT_HEADER = 12,
    VT_TELEMETRY_META_DATA = 14,
    VT_COMMAND_META_DATA = 16,
    VT_SERVICE_SET = 18,
    VT_CHILD_SYSTEMS = 20
  };
  /// Name of this space system
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Short description
  const ::flatbuffers::String *SHORT_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORT_DESCRIPTION);
  }
  /// Long description
  const ::flatbuffers::String *LONG_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LONG_DESCRIPTION);
  }
  /// Operational status
  const ::flatbuffers::String *OPERATIONAL_STATUS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATIONAL_STATUS);
  }
  /// Document header
  const XTCHeader *HEADER() const {
    return GetPointer<const XTCHeader *>(VT_HEADER);
  }
  /// Telemetry metadata
  const TelemetryMetaData *TELEMETRY_META_DATA() const {
    return GetPointer<const TelemetryMetaData *>(VT_TELEMETRY_META_DATA);
  }
  /// Command metadata
  const CommandMetaData *COMMAND_META_DATA() const {
    return GetPointer<const CommandMetaData *>(VT_COMMAND_META_DATA);
  }
  /// Service definitions
  const ServiceSet *SERVICE_SET() const {
    return GetPointer<const ServiceSet *>(VT_SERVICE_SET);
  }
  /// Child space systems (hierarchical structure)
  const ::flatbuffers::Vector<::flatbuffers::Offset<XTC>> *CHILD_SYSTEMS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<XTC>> *>(VT_CHILD_SYSTEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_SHORT_DESCRIPTION) &&
           verifier.VerifyString(SHORT_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_LONG_DESCRIPTION) &&
           verifier.VerifyString(LONG_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_OPERATIONAL_STATUS) &&
           verifier.VerifyString(OPERATIONAL_STATUS()) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(HEADER()) &&
           VerifyOffset(verifier, VT_TELEMETRY_META_DATA) &&
           verifier.VerifyTable(TELEMETRY_META_DATA()) &&
           VerifyOffset(verifier, VT_COMMAND_META_DATA) &&
           verifier.VerifyTable(COMMAND_META_DATA()) &&
           VerifyOffset(verifier, VT_SERVICE_SET) &&
           verifier.VerifyTable(SERVICE_SET()) &&
           VerifyOffset(verifier, VT_CHILD_SYSTEMS) &&
           verifier.VerifyVector(CHILD_SYSTEMS()) &&
           verifier.VerifyVectorOfTables(CHILD_SYSTEMS()) &&
           verifier.EndTable();
  }
};

struct XTCBuilder {
  typedef XTC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(XTC::VT_NAME, NAME);
  }
  void add_SHORT_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION) {
    fbb_.AddOffset(XTC::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  void add_LONG_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION) {
    fbb_.AddOffset(XTC::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  void add_OPERATIONAL_STATUS(::flatbuffers::Offset<::flatbuffers::String> OPERATIONAL_STATUS) {
    fbb_.AddOffset(XTC::VT_OPERATIONAL_STATUS, OPERATIONAL_STATUS);
  }
  void add_HEADER(::flatbuffers::Offset<XTCHeader> HEADER) {
    fbb_.AddOffset(XTC::VT_HEADER, HEADER);
  }
  void add_TELEMETRY_META_DATA(::flatbuffers::Offset<TelemetryMetaData> TELEMETRY_META_DATA) {
    fbb_.AddOffset(XTC::VT_TELEMETRY_META_DATA, TELEMETRY_META_DATA);
  }
  void add_COMMAND_META_DATA(::flatbuffers::Offset<CommandMetaData> COMMAND_META_DATA) {
    fbb_.AddOffset(XTC::VT_COMMAND_META_DATA, COMMAND_META_DATA);
  }
  void add_SERVICE_SET(::flatbuffers::Offset<ServiceSet> SERVICE_SET) {
    fbb_.AddOffset(XTC::VT_SERVICE_SET, SERVICE_SET);
  }
  void add_CHILD_SYSTEMS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XTC>>> CHILD_SYSTEMS) {
    fbb_.AddOffset(XTC::VT_CHILD_SYSTEMS, CHILD_SYSTEMS);
  }
  explicit XTCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<XTC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<XTC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<XTC> CreateXTC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SHORT_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LONG_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OPERATIONAL_STATUS = 0,
    ::flatbuffers::Offset<XTCHeader> HEADER = 0,
    ::flatbuffers::Offset<TelemetryMetaData> TELEMETRY_META_DATA = 0,
    ::flatbuffers::Offset<CommandMetaData> COMMAND_META_DATA = 0,
    ::flatbuffers::Offset<ServiceSet> SERVICE_SET = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<XTC>>> CHILD_SYSTEMS = 0) {
  XTCBuilder builder_(_fbb);
  builder_.add_CHILD_SYSTEMS(CHILD_SYSTEMS);
  builder_.add_SERVICE_SET(SERVICE_SET);
  builder_.add_COMMAND_META_DATA(COMMAND_META_DATA);
  builder_.add_TELEMETRY_META_DATA(TELEMETRY_META_DATA);
  builder_.add_HEADER(HEADER);
  builder_.add_OPERATIONAL_STATUS(OPERATIONAL_STATUS);
  builder_.add_LONG_DESCRIPTION(LONG_DESCRIPTION);
  builder_.add_SHORT_DESCRIPTION(SHORT_DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<XTC> CreateXTCDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *SHORT_DESCRIPTION = nullptr,
    const char *LONG_DESCRIPTION = nullptr,
    const char *OPERATIONAL_STATUS = nullptr,
    ::flatbuffers::Offset<XTCHeader> HEADER = 0,
    ::flatbuffers::Offset<TelemetryMetaData> TELEMETRY_META_DATA = 0,
    ::flatbuffers::Offset<CommandMetaData> COMMAND_META_DATA = 0,
    ::flatbuffers::Offset<ServiceSet> SERVICE_SET = 0,
    const std::vector<::flatbuffers::Offset<XTC>> *CHILD_SYSTEMS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto SHORT_DESCRIPTION__ = SHORT_DESCRIPTION ? _fbb.CreateString(SHORT_DESCRIPTION) : 0;
  auto LONG_DESCRIPTION__ = LONG_DESCRIPTION ? _fbb.CreateString(LONG_DESCRIPTION) : 0;
  auto OPERATIONAL_STATUS__ = OPERATIONAL_STATUS ? _fbb.CreateString(OPERATIONAL_STATUS) : 0;
  auto CHILD_SYSTEMS__ = CHILD_SYSTEMS ? _fbb.CreateVector<::flatbuffers::Offset<XTC>>(*CHILD_SYSTEMS) : 0;
  return CreateXTC(
      _fbb,
      NAME__,
      SHORT_DESCRIPTION__,
      LONG_DESCRIPTION__,
      OPERATIONAL_STATUS__,
      HEADER,
      TELEMETRY_META_DATA,
      COMMAND_META_DATA,
      SERVICE_SET,
      CHILD_SYSTEMS__);
}

inline const XTC *GetXTC(const void *buf) {
  return ::flatbuffers::GetRoot<XTC>(buf);
}

inline const XTC *GetSizePrefixedXTC(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<XTC>(buf);
}

inline const char *XTCIdentifier() {
  return "$XTC";
}

inline bool XTCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, XTCIdentifier());
}

inline bool SizePrefixedXTCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, XTCIdentifier(), true);
}

inline bool VerifyXTCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<XTC>(XTCIdentifier());
}

inline bool VerifySizePrefixedXTCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<XTC>(XTCIdentifier());
}

inline void FinishXTCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XTC> root) {
  fbb.Finish(root, XTCIdentifier());
}

inline void FinishSizePrefixedXTCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<XTC> root) {
  fbb.FinishSizePrefixed(root, XTCIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
