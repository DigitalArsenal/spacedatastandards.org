// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SNR;
struct SNRBuilder;

enum SensorType : int8_t {
  SensorType_RADAR_PULSE = 0,
  SensorType_RADAR_DOPPLER = 1,
  SensorType_RADAR_CW = 2,
  SensorType_RADAR_AESA = 3,
  SensorType_RADAR_PESA = 4,
  SensorType_IR_SEARCH = 5,
  SensorType_IR_IMAGING = 6,
  SensorType_EO_TV = 7,
  SensorType_EO_LLLTV = 8,
  SensorType_LASER_DESIGNATOR = 9,
  SensorType_LASER_RANGEFINDER = 10,
  SensorType_RWR = 11,
  SensorType_MAW = 12,
  SensorType_SONAR_ACTIVE = 13,
  SensorType_SONAR_PASSIVE = 14,
  SensorType_ACOUSTIC = 15,
  SensorType_MIN = SensorType_RADAR_PULSE,
  SensorType_MAX = SensorType_ACOUSTIC
};

inline const SensorType (&EnumValuesSensorType())[16] {
  static const SensorType values[] = {
    SensorType_RADAR_PULSE,
    SensorType_RADAR_DOPPLER,
    SensorType_RADAR_CW,
    SensorType_RADAR_AESA,
    SensorType_RADAR_PESA,
    SensorType_IR_SEARCH,
    SensorType_IR_IMAGING,
    SensorType_EO_TV,
    SensorType_EO_LLLTV,
    SensorType_LASER_DESIGNATOR,
    SensorType_LASER_RANGEFINDER,
    SensorType_RWR,
    SensorType_MAW,
    SensorType_SONAR_ACTIVE,
    SensorType_SONAR_PASSIVE,
    SensorType_ACOUSTIC
  };
  return values;
}

inline const char * const *EnumNamesSensorType() {
  static const char * const names[17] = {
    "RADAR_PULSE",
    "RADAR_DOPPLER",
    "RADAR_CW",
    "RADAR_AESA",
    "RADAR_PESA",
    "IR_SEARCH",
    "IR_IMAGING",
    "EO_TV",
    "EO_LLLTV",
    "LASER_DESIGNATOR",
    "LASER_RANGEFINDER",
    "RWR",
    "MAW",
    "SONAR_ACTIVE",
    "SONAR_PASSIVE",
    "ACOUSTIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorType(SensorType e) {
  if (::flatbuffers::IsOutRange(e, SensorType_RADAR_PULSE, SensorType_ACOUSTIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorType()[index];
}

enum SensorMode : int8_t {
  SensorMode_OFF = 0,
  SensorMode_STANDBY = 1,
  SensorMode_SEARCH = 2,
  SensorMode_ACQUISITION = 3,
  SensorMode_TRACK = 4,
  SensorMode_TRACK_WHILE_SCAN = 5,
  SensorMode_DESIGNATE = 6,
  SensorMode_JAMMED = 7,
  SensorMode_MIN = SensorMode_OFF,
  SensorMode_MAX = SensorMode_JAMMED
};

inline const SensorMode (&EnumValuesSensorMode())[8] {
  static const SensorMode values[] = {
    SensorMode_OFF,
    SensorMode_STANDBY,
    SensorMode_SEARCH,
    SensorMode_ACQUISITION,
    SensorMode_TRACK,
    SensorMode_TRACK_WHILE_SCAN,
    SensorMode_DESIGNATE,
    SensorMode_JAMMED
  };
  return values;
}

inline const char * const *EnumNamesSensorMode() {
  static const char * const names[9] = {
    "OFF",
    "STANDBY",
    "SEARCH",
    "ACQUISITION",
    "TRACK",
    "TRACK_WHILE_SCAN",
    "DESIGNATE",
    "JAMMED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorMode(SensorMode e) {
  if (::flatbuffers::IsOutRange(e, SensorMode_OFF, SensorMode_JAMMED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorMode()[index];
}

enum TrackQuality : int8_t {
  TrackQuality_NONE = 0,
  TrackQuality_TENTATIVE = 1,
  TrackQuality_FIRM = 2,
  TrackQuality_LOCKED = 3,
  TrackQuality_COASTING = 4,
  TrackQuality_LOST = 5,
  TrackQuality_MIN = TrackQuality_NONE,
  TrackQuality_MAX = TrackQuality_LOST
};

inline const TrackQuality (&EnumValuesTrackQuality())[6] {
  static const TrackQuality values[] = {
    TrackQuality_NONE,
    TrackQuality_TENTATIVE,
    TrackQuality_FIRM,
    TrackQuality_LOCKED,
    TrackQuality_COASTING,
    TrackQuality_LOST
  };
  return values;
}

inline const char * const *EnumNamesTrackQuality() {
  static const char * const names[7] = {
    "NONE",
    "TENTATIVE",
    "FIRM",
    "LOCKED",
    "COASTING",
    "LOST",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackQuality(TrackQuality e) {
  if (::flatbuffers::IsOutRange(e, TrackQuality_NONE, TrackQuality_LOST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackQuality()[index];
}

/// Sensor Systems
struct SNR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SNRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_MODE = 6,
    VT_RESERVED1 = 8,
    VT_MAX_RANGE = 10,
    VT_MIN_RANGE = 12,
    VT_FOV_AZIMUTH = 14,
    VT_FOV_ELEVATION = 16,
    VT_ANGULAR_RESOLUTION = 18,
    VT_RANGE_RESOLUTION = 20,
    VT_UPDATE_RATE = 22,
    VT_DETECTION_THRESHOLD = 24,
    VT_AZIMUTH_SCAN_RATE = 26,
    VT_ELEVATION_SCAN_RATE = 28,
    VT_POWER = 30,
    VT_FREQUENCY = 32,
    VT_RESERVED = 34
  };
  uint8_t TYPE() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint8_t MODE() const {
    return GetField<uint8_t>(VT_MODE, 0);
  }
  uint16_t RESERVED1() const {
    return GetField<uint16_t>(VT_RESERVED1, 0);
  }
  double MAX_RANGE() const {
    return GetField<double>(VT_MAX_RANGE, 0.0);
  }
  double MIN_RANGE() const {
    return GetField<double>(VT_MIN_RANGE, 0.0);
  }
  float FOV_AZIMUTH() const {
    return GetField<float>(VT_FOV_AZIMUTH, 0.0f);
  }
  float FOV_ELEVATION() const {
    return GetField<float>(VT_FOV_ELEVATION, 0.0f);
  }
  float ANGULAR_RESOLUTION() const {
    return GetField<float>(VT_ANGULAR_RESOLUTION, 0.0f);
  }
  float RANGE_RESOLUTION() const {
    return GetField<float>(VT_RANGE_RESOLUTION, 0.0f);
  }
  float UPDATE_RATE() const {
    return GetField<float>(VT_UPDATE_RATE, 0.0f);
  }
  float DETECTION_THRESHOLD() const {
    return GetField<float>(VT_DETECTION_THRESHOLD, 0.0f);
  }
  float AZIMUTH_SCAN_RATE() const {
    return GetField<float>(VT_AZIMUTH_SCAN_RATE, 0.0f);
  }
  float ELEVATION_SCAN_RATE() const {
    return GetField<float>(VT_ELEVATION_SCAN_RATE, 0.0f);
  }
  float POWER() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float FREQUENCY() const {
    return GetField<float>(VT_FREQUENCY, 0.0f);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_MODE, 1) &&
           VerifyField<uint16_t>(verifier, VT_RESERVED1, 2) &&
           VerifyField<double>(verifier, VT_MAX_RANGE, 8) &&
           VerifyField<double>(verifier, VT_MIN_RANGE, 8) &&
           VerifyField<float>(verifier, VT_FOV_AZIMUTH, 4) &&
           VerifyField<float>(verifier, VT_FOV_ELEVATION, 4) &&
           VerifyField<float>(verifier, VT_ANGULAR_RESOLUTION, 4) &&
           VerifyField<float>(verifier, VT_RANGE_RESOLUTION, 4) &&
           VerifyField<float>(verifier, VT_UPDATE_RATE, 4) &&
           VerifyField<float>(verifier, VT_DETECTION_THRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_AZIMUTH_SCAN_RATE, 4) &&
           VerifyField<float>(verifier, VT_ELEVATION_SCAN_RATE, 4) &&
           VerifyField<float>(verifier, VT_POWER, 4) &&
           VerifyField<float>(verifier, VT_FREQUENCY, 4) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct SNRBuilder {
  typedef SNR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TYPE(uint8_t TYPE) {
    fbb_.AddElement<uint8_t>(SNR::VT_TYPE, TYPE, 0);
  }
  void add_MODE(uint8_t MODE) {
    fbb_.AddElement<uint8_t>(SNR::VT_MODE, MODE, 0);
  }
  void add_RESERVED1(uint16_t RESERVED1) {
    fbb_.AddElement<uint16_t>(SNR::VT_RESERVED1, RESERVED1, 0);
  }
  void add_MAX_RANGE(double MAX_RANGE) {
    fbb_.AddElement<double>(SNR::VT_MAX_RANGE, MAX_RANGE, 0.0);
  }
  void add_MIN_RANGE(double MIN_RANGE) {
    fbb_.AddElement<double>(SNR::VT_MIN_RANGE, MIN_RANGE, 0.0);
  }
  void add_FOV_AZIMUTH(float FOV_AZIMUTH) {
    fbb_.AddElement<float>(SNR::VT_FOV_AZIMUTH, FOV_AZIMUTH, 0.0f);
  }
  void add_FOV_ELEVATION(float FOV_ELEVATION) {
    fbb_.AddElement<float>(SNR::VT_FOV_ELEVATION, FOV_ELEVATION, 0.0f);
  }
  void add_ANGULAR_RESOLUTION(float ANGULAR_RESOLUTION) {
    fbb_.AddElement<float>(SNR::VT_ANGULAR_RESOLUTION, ANGULAR_RESOLUTION, 0.0f);
  }
  void add_RANGE_RESOLUTION(float RANGE_RESOLUTION) {
    fbb_.AddElement<float>(SNR::VT_RANGE_RESOLUTION, RANGE_RESOLUTION, 0.0f);
  }
  void add_UPDATE_RATE(float UPDATE_RATE) {
    fbb_.AddElement<float>(SNR::VT_UPDATE_RATE, UPDATE_RATE, 0.0f);
  }
  void add_DETECTION_THRESHOLD(float DETECTION_THRESHOLD) {
    fbb_.AddElement<float>(SNR::VT_DETECTION_THRESHOLD, DETECTION_THRESHOLD, 0.0f);
  }
  void add_AZIMUTH_SCAN_RATE(float AZIMUTH_SCAN_RATE) {
    fbb_.AddElement<float>(SNR::VT_AZIMUTH_SCAN_RATE, AZIMUTH_SCAN_RATE, 0.0f);
  }
  void add_ELEVATION_SCAN_RATE(float ELEVATION_SCAN_RATE) {
    fbb_.AddElement<float>(SNR::VT_ELEVATION_SCAN_RATE, ELEVATION_SCAN_RATE, 0.0f);
  }
  void add_POWER(float POWER) {
    fbb_.AddElement<float>(SNR::VT_POWER, POWER, 0.0f);
  }
  void add_FREQUENCY(float FREQUENCY) {
    fbb_.AddElement<float>(SNR::VT_FREQUENCY, FREQUENCY, 0.0f);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(SNR::VT_RESERVED, RESERVED);
  }
  explicit SNRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SNR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SNR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SNR> CreateSNR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t TYPE = 0,
    uint8_t MODE = 0,
    uint16_t RESERVED1 = 0,
    double MAX_RANGE = 0.0,
    double MIN_RANGE = 0.0,
    float FOV_AZIMUTH = 0.0f,
    float FOV_ELEVATION = 0.0f,
    float ANGULAR_RESOLUTION = 0.0f,
    float RANGE_RESOLUTION = 0.0f,
    float UPDATE_RATE = 0.0f,
    float DETECTION_THRESHOLD = 0.0f,
    float AZIMUTH_SCAN_RATE = 0.0f,
    float ELEVATION_SCAN_RATE = 0.0f,
    float POWER = 0.0f,
    float FREQUENCY = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  SNRBuilder builder_(_fbb);
  builder_.add_MIN_RANGE(MIN_RANGE);
  builder_.add_MAX_RANGE(MAX_RANGE);
  builder_.add_RESERVED(RESERVED);
  builder_.add_FREQUENCY(FREQUENCY);
  builder_.add_POWER(POWER);
  builder_.add_ELEVATION_SCAN_RATE(ELEVATION_SCAN_RATE);
  builder_.add_AZIMUTH_SCAN_RATE(AZIMUTH_SCAN_RATE);
  builder_.add_DETECTION_THRESHOLD(DETECTION_THRESHOLD);
  builder_.add_UPDATE_RATE(UPDATE_RATE);
  builder_.add_RANGE_RESOLUTION(RANGE_RESOLUTION);
  builder_.add_ANGULAR_RESOLUTION(ANGULAR_RESOLUTION);
  builder_.add_FOV_ELEVATION(FOV_ELEVATION);
  builder_.add_FOV_AZIMUTH(FOV_AZIMUTH);
  builder_.add_RESERVED1(RESERVED1);
  builder_.add_MODE(MODE);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SNR> CreateSNRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t TYPE = 0,
    uint8_t MODE = 0,
    uint16_t RESERVED1 = 0,
    double MAX_RANGE = 0.0,
    double MIN_RANGE = 0.0,
    float FOV_AZIMUTH = 0.0f,
    float FOV_ELEVATION = 0.0f,
    float ANGULAR_RESOLUTION = 0.0f,
    float RANGE_RESOLUTION = 0.0f,
    float UPDATE_RATE = 0.0f,
    float DETECTION_THRESHOLD = 0.0f,
    float AZIMUTH_SCAN_RATE = 0.0f,
    float ELEVATION_SCAN_RATE = 0.0f,
    float POWER = 0.0f,
    float FREQUENCY = 0.0f,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateSNR(
      _fbb,
      TYPE,
      MODE,
      RESERVED1,
      MAX_RANGE,
      MIN_RANGE,
      FOV_AZIMUTH,
      FOV_ELEVATION,
      ANGULAR_RESOLUTION,
      RANGE_RESOLUTION,
      UPDATE_RATE,
      DETECTION_THRESHOLD,
      AZIMUTH_SCAN_RATE,
      ELEVATION_SCAN_RATE,
      POWER,
      FREQUENCY,
      RESERVED__);
}

inline const SNR *GetSNR(const void *buf) {
  return ::flatbuffers::GetRoot<SNR>(buf);
}

inline const SNR *GetSizePrefixedSNR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SNR>(buf);
}

inline const char *SNRIdentifier() {
  return "$SNR";
}

inline bool SNRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SNRIdentifier());
}

inline bool SizePrefixedSNRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SNRIdentifier(), true);
}

inline bool VerifySNRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SNR>(SNRIdentifier());
}

inline bool VerifySizePrefixedSNRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SNR>(SNRIdentifier());
}

inline void FinishSNRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SNR> root) {
  fbb.Finish(root, SNRIdentifier());
}

inline void FinishSizePrefixedSNRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SNR> root) {
  fbb.FinishSizePrefixed(root, SNRIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
