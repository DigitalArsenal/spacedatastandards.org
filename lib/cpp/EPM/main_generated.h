// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CryptoKey;
struct CryptoKeyBuilder;

struct Address;
struct AddressBuilder;

struct EPM;
struct EPMBuilder;

struct EPMCOLLECTION;
struct EPMCOLLECTIONBuilder;

enum KeyType : int8_t {
  KeyType_Signing = 0,
  KeyType_Encryption = 1,
  KeyType_MIN = KeyType_Signing,
  KeyType_MAX = KeyType_Encryption
};

inline const KeyType (&EnumValuesKeyType())[2] {
  static const KeyType values[] = {
    KeyType_Signing,
    KeyType_Encryption
  };
  return values;
}

inline const char * const *EnumNamesKeyType() {
  static const char * const names[3] = {
    "Signing",
    "Encryption",
    nullptr
  };
  return names;
}

inline const char *EnumNameKeyType(KeyType e) {
  if (::flatbuffers::IsOutRange(e, KeyType_Signing, KeyType_Encryption)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKeyType()[index];
}

/// Represents cryptographic key information
struct CryptoKey FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CryptoKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBLIC_KEY = 4,
    VT_XPUB = 6,
    VT_PRIVATE_KEY = 8,
    VT_XPRIV = 10,
    VT_KEY_ADDRESS = 12,
    VT_ADDRESS_TYPE = 14,
    VT_KEY_TYPE = 16
  };
  /// Public part of the cryptographic key, in hexidecimal format
  const ::flatbuffers::String *PUBLIC_KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PUBLIC_KEY);
  }
  /// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
  const ::flatbuffers::String *XPUB() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XPUB);
  }
  /// Private part of the cryptographic key in hexidecimal format, should be kept secret 
  const ::flatbuffers::String *PRIVATE_KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIVATE_KEY);
  }
  /// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
  const ::flatbuffers::String *XPRIV() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XPRIV);
  }
  /// Address generated from the cryptographic key
  const ::flatbuffers::String *KEY_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY_ADDRESS);
  }
  /// Type of the address generated from the cryptographic key
  const ::flatbuffers::String *ADDRESS_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDRESS_TYPE);
  }
  /// Type of the cryptographic key (signing or encryption)
  KeyType KEY_TYPE() const {
    return static_cast<KeyType>(GetField<int8_t>(VT_KEY_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBLIC_KEY) &&
           verifier.VerifyString(PUBLIC_KEY()) &&
           VerifyOffset(verifier, VT_XPUB) &&
           verifier.VerifyString(XPUB()) &&
           VerifyOffset(verifier, VT_PRIVATE_KEY) &&
           verifier.VerifyString(PRIVATE_KEY()) &&
           VerifyOffset(verifier, VT_XPRIV) &&
           verifier.VerifyString(XPRIV()) &&
           VerifyOffset(verifier, VT_KEY_ADDRESS) &&
           verifier.VerifyString(KEY_ADDRESS()) &&
           VerifyOffset(verifier, VT_ADDRESS_TYPE) &&
           verifier.VerifyString(ADDRESS_TYPE()) &&
           VerifyField<int8_t>(verifier, VT_KEY_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CryptoKeyBuilder {
  typedef CryptoKey Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PUBLIC_KEY(::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY) {
    fbb_.AddOffset(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  void add_XPUB(::flatbuffers::Offset<::flatbuffers::String> XPUB) {
    fbb_.AddOffset(CryptoKey::VT_XPUB, XPUB);
  }
  void add_PRIVATE_KEY(::flatbuffers::Offset<::flatbuffers::String> PRIVATE_KEY) {
    fbb_.AddOffset(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  void add_XPRIV(::flatbuffers::Offset<::flatbuffers::String> XPRIV) {
    fbb_.AddOffset(CryptoKey::VT_XPRIV, XPRIV);
  }
  void add_KEY_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> KEY_ADDRESS) {
    fbb_.AddOffset(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  void add_ADDRESS_TYPE(::flatbuffers::Offset<::flatbuffers::String> ADDRESS_TYPE) {
    fbb_.AddOffset(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE);
  }
  void add_KEY_TYPE(KeyType KEY_TYPE) {
    fbb_.AddElement<int8_t>(CryptoKey::VT_KEY_TYPE, static_cast<int8_t>(KEY_TYPE), 0);
  }
  explicit CryptoKeyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CryptoKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CryptoKey>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CryptoKey> CreateCryptoKey(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XPUB = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PRIVATE_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XPRIV = 0,
    ::flatbuffers::Offset<::flatbuffers::String> KEY_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADDRESS_TYPE = 0,
    KeyType KEY_TYPE = KeyType_Signing) {
  CryptoKeyBuilder builder_(_fbb);
  builder_.add_ADDRESS_TYPE(ADDRESS_TYPE);
  builder_.add_KEY_ADDRESS(KEY_ADDRESS);
  builder_.add_XPRIV(XPRIV);
  builder_.add_PRIVATE_KEY(PRIVATE_KEY);
  builder_.add_XPUB(XPUB);
  builder_.add_PUBLIC_KEY(PUBLIC_KEY);
  builder_.add_KEY_TYPE(KEY_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CryptoKey> CreateCryptoKeyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PUBLIC_KEY = nullptr,
    const char *XPUB = nullptr,
    const char *PRIVATE_KEY = nullptr,
    const char *XPRIV = nullptr,
    const char *KEY_ADDRESS = nullptr,
    const char *ADDRESS_TYPE = nullptr,
    KeyType KEY_TYPE = KeyType_Signing) {
  auto PUBLIC_KEY__ = PUBLIC_KEY ? _fbb.CreateString(PUBLIC_KEY) : 0;
  auto XPUB__ = XPUB ? _fbb.CreateString(XPUB) : 0;
  auto PRIVATE_KEY__ = PRIVATE_KEY ? _fbb.CreateString(PRIVATE_KEY) : 0;
  auto XPRIV__ = XPRIV ? _fbb.CreateString(XPRIV) : 0;
  auto KEY_ADDRESS__ = KEY_ADDRESS ? _fbb.CreateString(KEY_ADDRESS) : 0;
  auto ADDRESS_TYPE__ = ADDRESS_TYPE ? _fbb.CreateString(ADDRESS_TYPE) : 0;
  return CreateCryptoKey(
      _fbb,
      PUBLIC_KEY__,
      XPUB__,
      PRIVATE_KEY__,
      XPRIV__,
      KEY_ADDRESS__,
      ADDRESS_TYPE__,
      KEY_TYPE);
}

/// Represents a geographic address
struct Address FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddressBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNTRY = 4,
    VT_REGION = 6,
    VT_LOCALITY = 8,
    VT_POSTAL_CODE = 10,
    VT_STREET = 12,
    VT_POST_OFFICE_BOX_NUMBER = 14
  };
  /// Country of the address
  const ::flatbuffers::String *COUNTRY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRY);
  }
  /// Region of the address (e.g., state or province)
  const ::flatbuffers::String *REGION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGION);
  }
  /// Locality of the address (e.g., city or town)
  const ::flatbuffers::String *LOCALITY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALITY);
  }
  /// Postal code of the address
  const ::flatbuffers::String *POSTAL_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSTAL_CODE);
  }
  /// Street address
  const ::flatbuffers::String *STREET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREET);
  }
  /// Post office box number
  const ::flatbuffers::String *POST_OFFICE_BOX_NUMBER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POST_OFFICE_BOX_NUMBER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COUNTRY) &&
           verifier.VerifyString(COUNTRY()) &&
           VerifyOffset(verifier, VT_REGION) &&
           verifier.VerifyString(REGION()) &&
           VerifyOffset(verifier, VT_LOCALITY) &&
           verifier.VerifyString(LOCALITY()) &&
           VerifyOffset(verifier, VT_POSTAL_CODE) &&
           verifier.VerifyString(POSTAL_CODE()) &&
           VerifyOffset(verifier, VT_STREET) &&
           verifier.VerifyString(STREET()) &&
           VerifyOffset(verifier, VT_POST_OFFICE_BOX_NUMBER) &&
           verifier.VerifyString(POST_OFFICE_BOX_NUMBER()) &&
           verifier.EndTable();
  }
};

struct AddressBuilder {
  typedef Address Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COUNTRY(::flatbuffers::Offset<::flatbuffers::String> COUNTRY) {
    fbb_.AddOffset(Address::VT_COUNTRY, COUNTRY);
  }
  void add_REGION(::flatbuffers::Offset<::flatbuffers::String> REGION) {
    fbb_.AddOffset(Address::VT_REGION, REGION);
  }
  void add_LOCALITY(::flatbuffers::Offset<::flatbuffers::String> LOCALITY) {
    fbb_.AddOffset(Address::VT_LOCALITY, LOCALITY);
  }
  void add_POSTAL_CODE(::flatbuffers::Offset<::flatbuffers::String> POSTAL_CODE) {
    fbb_.AddOffset(Address::VT_POSTAL_CODE, POSTAL_CODE);
  }
  void add_STREET(::flatbuffers::Offset<::flatbuffers::String> STREET) {
    fbb_.AddOffset(Address::VT_STREET, STREET);
  }
  void add_POST_OFFICE_BOX_NUMBER(::flatbuffers::Offset<::flatbuffers::String> POST_OFFICE_BOX_NUMBER) {
    fbb_.AddOffset(Address::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  explicit AddressBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Address> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Address>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Address> CreateAddress(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COUNTRY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REGION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LOCALITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POSTAL_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STREET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POST_OFFICE_BOX_NUMBER = 0) {
  AddressBuilder builder_(_fbb);
  builder_.add_POST_OFFICE_BOX_NUMBER(POST_OFFICE_BOX_NUMBER);
  builder_.add_STREET(STREET);
  builder_.add_POSTAL_CODE(POSTAL_CODE);
  builder_.add_LOCALITY(LOCALITY);
  builder_.add_REGION(REGION);
  builder_.add_COUNTRY(COUNTRY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Address> CreateAddressDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COUNTRY = nullptr,
    const char *REGION = nullptr,
    const char *LOCALITY = nullptr,
    const char *POSTAL_CODE = nullptr,
    const char *STREET = nullptr,
    const char *POST_OFFICE_BOX_NUMBER = nullptr) {
  auto COUNTRY__ = COUNTRY ? _fbb.CreateString(COUNTRY) : 0;
  auto REGION__ = REGION ? _fbb.CreateString(REGION) : 0;
  auto LOCALITY__ = LOCALITY ? _fbb.CreateString(LOCALITY) : 0;
  auto POSTAL_CODE__ = POSTAL_CODE ? _fbb.CreateString(POSTAL_CODE) : 0;
  auto STREET__ = STREET ? _fbb.CreateString(STREET) : 0;
  auto POST_OFFICE_BOX_NUMBER__ = POST_OFFICE_BOX_NUMBER ? _fbb.CreateString(POST_OFFICE_BOX_NUMBER) : 0;
  return CreateAddress(
      _fbb,
      COUNTRY__,
      REGION__,
      LOCALITY__,
      POSTAL_CODE__,
      STREET__,
      POST_OFFICE_BOX_NUMBER__);
}

/// Entity Profile Message
struct EPM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EPMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DN = 4,
    VT_LEGAL_NAME = 6,
    VT_FAMILY_NAME = 8,
    VT_GIVEN_NAME = 10,
    VT_ADDITIONAL_NAME = 12,
    VT_HONORIFIC_PREFIX = 14,
    VT_HONORIFIC_SUFFIX = 16,
    VT_JOB_TITLE = 18,
    VT_OCCUPATION = 20,
    VT_ADDRESS = 22,
    VT_ALTERNATE_NAMES = 24,
    VT_EMAIL = 26,
    VT_TELEPHONE = 28,
    VT_KEYS = 30,
    VT_MULTIFORMAT_ADDRESS = 32
  };
  /// Distinguished Name of the entity
  const ::flatbuffers::String *DN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DN);
  }
  /// Common name of the entity (person or organization)
  const ::flatbuffers::String *LEGAL_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LEGAL_NAME);
  }
  /// Family name or surname of the person
  const ::flatbuffers::String *FAMILY_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FAMILY_NAME);
  }
  /// Given name or first name of the person
  const ::flatbuffers::String *GIVEN_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GIVEN_NAME);
  }
  /// Additional name or middle name of the person
  const ::flatbuffers::String *ADDITIONAL_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDITIONAL_NAME);
  }
  /// Honorific prefix preceding the person's name (e.g., Mr., Dr.)
  const ::flatbuffers::String *HONORIFIC_PREFIX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HONORIFIC_PREFIX);
  }
  /// Honorific suffix following the person's name (e.g., Jr., Sr.)
  const ::flatbuffers::String *HONORIFIC_SUFFIX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HONORIFIC_SUFFIX);
  }
  /// Job title of the person
  const ::flatbuffers::String *JOB_TITLE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JOB_TITLE);
  }
  /// Occupation of the person
  const ::flatbuffers::String *OCCUPATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OCCUPATION);
  }
  /// Physical Address
  const Address *ADDRESS() const {
    return GetPointer<const Address *>(VT_ADDRESS);
  }
  /// Alternate names for the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALTERNATE_NAMES);
  }
  /// Email address of the entity
  const ::flatbuffers::String *EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMAIL);
  }
  /// Telephone number of the entity
  const ::flatbuffers::String *TELEPHONE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TELEPHONE);
  }
  /// Cryptographic keys associated with the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>> *KEYS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>> *>(VT_KEYS);
  }
  /// Multiformat addresses associated with the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MULTIFORMAT_ADDRESS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MULTIFORMAT_ADDRESS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DN) &&
           verifier.VerifyString(DN()) &&
           VerifyOffset(verifier, VT_LEGAL_NAME) &&
           verifier.VerifyString(LEGAL_NAME()) &&
           VerifyOffset(verifier, VT_FAMILY_NAME) &&
           verifier.VerifyString(FAMILY_NAME()) &&
           VerifyOffset(verifier, VT_GIVEN_NAME) &&
           verifier.VerifyString(GIVEN_NAME()) &&
           VerifyOffset(verifier, VT_ADDITIONAL_NAME) &&
           verifier.VerifyString(ADDITIONAL_NAME()) &&
           VerifyOffset(verifier, VT_HONORIFIC_PREFIX) &&
           verifier.VerifyString(HONORIFIC_PREFIX()) &&
           VerifyOffset(verifier, VT_HONORIFIC_SUFFIX) &&
           verifier.VerifyString(HONORIFIC_SUFFIX()) &&
           VerifyOffset(verifier, VT_JOB_TITLE) &&
           verifier.VerifyString(JOB_TITLE()) &&
           VerifyOffset(verifier, VT_OCCUPATION) &&
           verifier.VerifyString(OCCUPATION()) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyTable(ADDRESS()) &&
           VerifyOffset(verifier, VT_ALTERNATE_NAMES) &&
           verifier.VerifyVector(ALTERNATE_NAMES()) &&
           verifier.VerifyVectorOfStrings(ALTERNATE_NAMES()) &&
           VerifyOffset(verifier, VT_EMAIL) &&
           verifier.VerifyString(EMAIL()) &&
           VerifyOffset(verifier, VT_TELEPHONE) &&
           verifier.VerifyString(TELEPHONE()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(KEYS()) &&
           verifier.VerifyVectorOfTables(KEYS()) &&
           VerifyOffset(verifier, VT_MULTIFORMAT_ADDRESS) &&
           verifier.VerifyVector(MULTIFORMAT_ADDRESS()) &&
           verifier.VerifyVectorOfStrings(MULTIFORMAT_ADDRESS()) &&
           verifier.EndTable();
  }
};

struct EPMBuilder {
  typedef EPM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DN(::flatbuffers::Offset<::flatbuffers::String> DN) {
    fbb_.AddOffset(EPM::VT_DN, DN);
  }
  void add_LEGAL_NAME(::flatbuffers::Offset<::flatbuffers::String> LEGAL_NAME) {
    fbb_.AddOffset(EPM::VT_LEGAL_NAME, LEGAL_NAME);
  }
  void add_FAMILY_NAME(::flatbuffers::Offset<::flatbuffers::String> FAMILY_NAME) {
    fbb_.AddOffset(EPM::VT_FAMILY_NAME, FAMILY_NAME);
  }
  void add_GIVEN_NAME(::flatbuffers::Offset<::flatbuffers::String> GIVEN_NAME) {
    fbb_.AddOffset(EPM::VT_GIVEN_NAME, GIVEN_NAME);
  }
  void add_ADDITIONAL_NAME(::flatbuffers::Offset<::flatbuffers::String> ADDITIONAL_NAME) {
    fbb_.AddOffset(EPM::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  void add_HONORIFIC_PREFIX(::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_PREFIX) {
    fbb_.AddOffset(EPM::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  void add_HONORIFIC_SUFFIX(::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_SUFFIX) {
    fbb_.AddOffset(EPM::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  void add_JOB_TITLE(::flatbuffers::Offset<::flatbuffers::String> JOB_TITLE) {
    fbb_.AddOffset(EPM::VT_JOB_TITLE, JOB_TITLE);
  }
  void add_OCCUPATION(::flatbuffers::Offset<::flatbuffers::String> OCCUPATION) {
    fbb_.AddOffset(EPM::VT_OCCUPATION, OCCUPATION);
  }
  void add_ADDRESS(::flatbuffers::Offset<Address> ADDRESS) {
    fbb_.AddOffset(EPM::VT_ADDRESS, ADDRESS);
  }
  void add_ALTERNATE_NAMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES) {
    fbb_.AddOffset(EPM::VT_ALTERNATE_NAMES, ALTERNATE_NAMES);
  }
  void add_EMAIL(::flatbuffers::Offset<::flatbuffers::String> EMAIL) {
    fbb_.AddOffset(EPM::VT_EMAIL, EMAIL);
  }
  void add_TELEPHONE(::flatbuffers::Offset<::flatbuffers::String> TELEPHONE) {
    fbb_.AddOffset(EPM::VT_TELEPHONE, TELEPHONE);
  }
  void add_KEYS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>>> KEYS) {
    fbb_.AddOffset(EPM::VT_KEYS, KEYS);
  }
  void add_MULTIFORMAT_ADDRESS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MULTIFORMAT_ADDRESS) {
    fbb_.AddOffset(EPM::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  explicit EPMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EPM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EPM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EPM> CreateEPM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> DN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LEGAL_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FAMILY_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GIVEN_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADDITIONAL_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_PREFIX = 0,
    ::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_SUFFIX = 0,
    ::flatbuffers::Offset<::flatbuffers::String> JOB_TITLE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OCCUPATION = 0,
    ::flatbuffers::Offset<Address> ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EMAIL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TELEPHONE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>>> KEYS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MULTIFORMAT_ADDRESS = 0) {
  EPMBuilder builder_(_fbb);
  builder_.add_MULTIFORMAT_ADDRESS(MULTIFORMAT_ADDRESS);
  builder_.add_KEYS(KEYS);
  builder_.add_TELEPHONE(TELEPHONE);
  builder_.add_EMAIL(EMAIL);
  builder_.add_ALTERNATE_NAMES(ALTERNATE_NAMES);
  builder_.add_ADDRESS(ADDRESS);
  builder_.add_OCCUPATION(OCCUPATION);
  builder_.add_JOB_TITLE(JOB_TITLE);
  builder_.add_HONORIFIC_SUFFIX(HONORIFIC_SUFFIX);
  builder_.add_HONORIFIC_PREFIX(HONORIFIC_PREFIX);
  builder_.add_ADDITIONAL_NAME(ADDITIONAL_NAME);
  builder_.add_GIVEN_NAME(GIVEN_NAME);
  builder_.add_FAMILY_NAME(FAMILY_NAME);
  builder_.add_LEGAL_NAME(LEGAL_NAME);
  builder_.add_DN(DN);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EPM> CreateEPMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *DN = nullptr,
    const char *LEGAL_NAME = nullptr,
    const char *FAMILY_NAME = nullptr,
    const char *GIVEN_NAME = nullptr,
    const char *ADDITIONAL_NAME = nullptr,
    const char *HONORIFIC_PREFIX = nullptr,
    const char *HONORIFIC_SUFFIX = nullptr,
    const char *JOB_TITLE = nullptr,
    const char *OCCUPATION = nullptr,
    ::flatbuffers::Offset<Address> ADDRESS = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES = nullptr,
    const char *EMAIL = nullptr,
    const char *TELEPHONE = nullptr,
    const std::vector<::flatbuffers::Offset<CryptoKey>> *KEYS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MULTIFORMAT_ADDRESS = nullptr) {
  auto DN__ = DN ? _fbb.CreateString(DN) : 0;
  auto LEGAL_NAME__ = LEGAL_NAME ? _fbb.CreateString(LEGAL_NAME) : 0;
  auto FAMILY_NAME__ = FAMILY_NAME ? _fbb.CreateString(FAMILY_NAME) : 0;
  auto GIVEN_NAME__ = GIVEN_NAME ? _fbb.CreateString(GIVEN_NAME) : 0;
  auto ADDITIONAL_NAME__ = ADDITIONAL_NAME ? _fbb.CreateString(ADDITIONAL_NAME) : 0;
  auto HONORIFIC_PREFIX__ = HONORIFIC_PREFIX ? _fbb.CreateString(HONORIFIC_PREFIX) : 0;
  auto HONORIFIC_SUFFIX__ = HONORIFIC_SUFFIX ? _fbb.CreateString(HONORIFIC_SUFFIX) : 0;
  auto JOB_TITLE__ = JOB_TITLE ? _fbb.CreateString(JOB_TITLE) : 0;
  auto OCCUPATION__ = OCCUPATION ? _fbb.CreateString(OCCUPATION) : 0;
  auto ALTERNATE_NAMES__ = ALTERNATE_NAMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ALTERNATE_NAMES) : 0;
  auto EMAIL__ = EMAIL ? _fbb.CreateString(EMAIL) : 0;
  auto TELEPHONE__ = TELEPHONE ? _fbb.CreateString(TELEPHONE) : 0;
  auto KEYS__ = KEYS ? _fbb.CreateVector<::flatbuffers::Offset<CryptoKey>>(*KEYS) : 0;
  auto MULTIFORMAT_ADDRESS__ = MULTIFORMAT_ADDRESS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MULTIFORMAT_ADDRESS) : 0;
  return CreateEPM(
      _fbb,
      DN__,
      LEGAL_NAME__,
      FAMILY_NAME__,
      GIVEN_NAME__,
      ADDITIONAL_NAME__,
      HONORIFIC_PREFIX__,
      HONORIFIC_SUFFIX__,
      JOB_TITLE__,
      OCCUPATION__,
      ADDRESS,
      ALTERNATE_NAMES__,
      EMAIL__,
      TELEPHONE__,
      KEYS__,
      MULTIFORMAT_ADDRESS__);
}

struct EPMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EPMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct EPMCOLLECTIONBuilder {
  typedef EPMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> RECORDS) {
    fbb_.AddOffset(EPMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit EPMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EPMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EPMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EPMCOLLECTION> CreateEPMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> RECORDS = 0) {
  EPMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EPMCOLLECTION> CreateEPMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EPM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<EPM>>(*RECORDS) : 0;
  return CreateEPMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const EPM *GetEPM(const void *buf) {
  return ::flatbuffers::GetRoot<EPM>(buf);
}

inline const EPM *GetSizePrefixedEPM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EPM>(buf);
}

inline const char *EPMIdentifier() {
  return "$EPM";
}

inline bool EPMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EPMIdentifier());
}

inline bool SizePrefixedEPMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EPMIdentifier(), true);
}

inline bool VerifyEPMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EPM>(EPMIdentifier());
}

inline bool VerifySizePrefixedEPMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EPM>(EPMIdentifier());
}

inline void FinishEPMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EPM> root) {
  fbb.Finish(root, EPMIdentifier());
}

inline void FinishSizePrefixedEPMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EPM> root) {
  fbb.FinishSizePrefixed(root, EPMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
