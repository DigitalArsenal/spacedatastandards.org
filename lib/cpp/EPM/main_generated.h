// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct DNComponent;
struct DNComponentBuilder;

struct DistinguishedName;
struct DistinguishedNameBuilder;

struct CryptoKey;
struct CryptoKeyBuilder;

struct Address;
struct AddressBuilder;

struct PersonAttributes;
struct PersonAttributesBuilder;

struct OrganizationAttributes;
struct OrganizationAttributesBuilder;

struct EPM;
struct EPMBuilder;

struct EPMCOLLECTION;
struct EPMCOLLECTIONBuilder;

/// Enumeration for LDAP attribute types relevant to Distinguished Names
enum LDIFAttributeType : int8_t {
  /// Common Name
  LDIFAttributeType_CN = 0,
  /// Organizational Unit Name
  LDIFAttributeType_OU = 1,
  /// Organization Name
  LDIFAttributeType_O = 2,
  /// Domain Component
  LDIFAttributeType_DC = 3,
  /// Country Name
  LDIFAttributeType_C = 4,
  /// Surname
  LDIFAttributeType_SN = 5,
  LDIFAttributeType_MIN = LDIFAttributeType_CN,
  LDIFAttributeType_MAX = LDIFAttributeType_SN
};

inline const LDIFAttributeType (&EnumValuesLDIFAttributeType())[6] {
  static const LDIFAttributeType values[] = {
    LDIFAttributeType_CN,
    LDIFAttributeType_OU,
    LDIFAttributeType_O,
    LDIFAttributeType_DC,
    LDIFAttributeType_C,
    LDIFAttributeType_SN
  };
  return values;
}

inline const char * const *EnumNamesLDIFAttributeType() {
  static const char * const names[7] = {
    "CN",
    "OU",
    "O",
    "DC",
    "C",
    "SN",
    nullptr
  };
  return names;
}

inline const char *EnumNameLDIFAttributeType(LDIFAttributeType e) {
  if (::flatbuffers::IsOutRange(e, LDIFAttributeType_CN, LDIFAttributeType_SN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLDIFAttributeType()[index];
}

/// Union for specific attributes, distinguishing between Person and Organization
enum SpecificAttributes : uint8_t {
  SpecificAttributes_NONE = 0,
  SpecificAttributes_PersonAttributes = 1,
  SpecificAttributes_OrganizationAttributes = 2,
  SpecificAttributes_MIN = SpecificAttributes_NONE,
  SpecificAttributes_MAX = SpecificAttributes_OrganizationAttributes
};

inline const SpecificAttributes (&EnumValuesSpecificAttributes())[3] {
  static const SpecificAttributes values[] = {
    SpecificAttributes_NONE,
    SpecificAttributes_PersonAttributes,
    SpecificAttributes_OrganizationAttributes
  };
  return values;
}

inline const char * const *EnumNamesSpecificAttributes() {
  static const char * const names[4] = {
    "NONE",
    "PersonAttributes",
    "OrganizationAttributes",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpecificAttributes(SpecificAttributes e) {
  if (::flatbuffers::IsOutRange(e, SpecificAttributes_NONE, SpecificAttributes_OrganizationAttributes)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSpecificAttributes()[index];
}

template<typename T> struct SpecificAttributesTraits {
  static const SpecificAttributes enum_value = SpecificAttributes_NONE;
};

template<> struct SpecificAttributesTraits<PersonAttributes> {
  static const SpecificAttributes enum_value = SpecificAttributes_PersonAttributes;
};

template<> struct SpecificAttributesTraits<OrganizationAttributes> {
  static const SpecificAttributes enum_value = SpecificAttributes_OrganizationAttributes;
};

bool VerifySpecificAttributes(::flatbuffers::Verifier &verifier, const void *obj, SpecificAttributes type);
bool VerifySpecificAttributesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

/// Represents a component of a Distinguished Name (DN) in LDAP
struct DNComponent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DNComponentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  /// The type of the DN component
  LDIFAttributeType TYPE() const {
    return static_cast<LDIFAttributeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// The value of the DN component
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           verifier.EndTable();
  }
};

struct DNComponentBuilder {
  typedef DNComponent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TYPE(LDIFAttributeType TYPE) {
    fbb_.AddElement<int8_t>(DNComponent::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(DNComponent::VT_VALUE, VALUE);
  }
  explicit DNComponentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DNComponent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DNComponent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DNComponent> CreateDNComponent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LDIFAttributeType TYPE = LDIFAttributeType_CN,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0) {
  DNComponentBuilder builder_(_fbb);
  builder_.add_VALUE(VALUE);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DNComponent> CreateDNComponentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    LDIFAttributeType TYPE = LDIFAttributeType_CN,
    const char *VALUE = nullptr) {
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateDNComponent(
      _fbb,
      TYPE,
      VALUE__);
}

/// Represents a Distinguished Name composed of DNComponents
struct DistinguishedName FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DistinguishedNameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPONENTS = 4
  };
  /// The sequence of components making up the DN
  const ::flatbuffers::Vector<::flatbuffers::Offset<DNComponent>> *COMPONENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DNComponent>> *>(VT_COMPONENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(COMPONENTS()) &&
           verifier.VerifyVectorOfTables(COMPONENTS()) &&
           verifier.EndTable();
  }
};

struct DistinguishedNameBuilder {
  typedef DistinguishedName Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMPONENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DNComponent>>> COMPONENTS) {
    fbb_.AddOffset(DistinguishedName::VT_COMPONENTS, COMPONENTS);
  }
  explicit DistinguishedNameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DistinguishedName> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DistinguishedName>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DistinguishedName> CreateDistinguishedName(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DNComponent>>> COMPONENTS = 0) {
  DistinguishedNameBuilder builder_(_fbb);
  builder_.add_COMPONENTS(COMPONENTS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DistinguishedName> CreateDistinguishedNameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DNComponent>> *COMPONENTS = nullptr) {
  auto COMPONENTS__ = COMPONENTS ? _fbb.CreateVector<::flatbuffers::Offset<DNComponent>>(*COMPONENTS) : 0;
  return CreateDistinguishedName(
      _fbb,
      COMPONENTS__);
}

/// Represents cryptographic key information
struct CryptoKey FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CryptoKeyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PUBLIC_KEY = 4,
    VT_XPUB = 6,
    VT_PRIVATE_KEY = 8,
    VT_XPRIV = 10,
    VT_KEY_ADDRESS = 12,
    VT_ADDRESS_TYPE = 14
  };
  /// Public part of the cryptographic key
  const ::flatbuffers::String *PUBLIC_KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PUBLIC_KEY);
  }
  /// Extended public key
  const ::flatbuffers::String *XPUB() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XPUB);
  }
  /// Private part of the cryptographic key, should be kept secret
  const ::flatbuffers::String *PRIVATE_KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIVATE_KEY);
  }
  /// Extended private key
  const ::flatbuffers::String *XPRIV() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XPRIV);
  }
  /// Address generated from the cryptographic key
  const ::flatbuffers::String *KEY_ADDRESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY_ADDRESS);
  }
  /// Type of the address generated from the cryptographic key
  const ::flatbuffers::String *ADDRESS_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDRESS_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PUBLIC_KEY) &&
           verifier.VerifyString(PUBLIC_KEY()) &&
           VerifyOffset(verifier, VT_XPUB) &&
           verifier.VerifyString(XPUB()) &&
           VerifyOffset(verifier, VT_PRIVATE_KEY) &&
           verifier.VerifyString(PRIVATE_KEY()) &&
           VerifyOffset(verifier, VT_XPRIV) &&
           verifier.VerifyString(XPRIV()) &&
           VerifyOffset(verifier, VT_KEY_ADDRESS) &&
           verifier.VerifyString(KEY_ADDRESS()) &&
           VerifyOffset(verifier, VT_ADDRESS_TYPE) &&
           verifier.VerifyString(ADDRESS_TYPE()) &&
           verifier.EndTable();
  }
};

struct CryptoKeyBuilder {
  typedef CryptoKey Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PUBLIC_KEY(::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY) {
    fbb_.AddOffset(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  void add_XPUB(::flatbuffers::Offset<::flatbuffers::String> XPUB) {
    fbb_.AddOffset(CryptoKey::VT_XPUB, XPUB);
  }
  void add_PRIVATE_KEY(::flatbuffers::Offset<::flatbuffers::String> PRIVATE_KEY) {
    fbb_.AddOffset(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  void add_XPRIV(::flatbuffers::Offset<::flatbuffers::String> XPRIV) {
    fbb_.AddOffset(CryptoKey::VT_XPRIV, XPRIV);
  }
  void add_KEY_ADDRESS(::flatbuffers::Offset<::flatbuffers::String> KEY_ADDRESS) {
    fbb_.AddOffset(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  void add_ADDRESS_TYPE(::flatbuffers::Offset<::flatbuffers::String> ADDRESS_TYPE) {
    fbb_.AddOffset(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE);
  }
  explicit CryptoKeyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CryptoKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CryptoKey>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CryptoKey> CreateCryptoKey(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XPUB = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PRIVATE_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> XPRIV = 0,
    ::flatbuffers::Offset<::flatbuffers::String> KEY_ADDRESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADDRESS_TYPE = 0) {
  CryptoKeyBuilder builder_(_fbb);
  builder_.add_ADDRESS_TYPE(ADDRESS_TYPE);
  builder_.add_KEY_ADDRESS(KEY_ADDRESS);
  builder_.add_XPRIV(XPRIV);
  builder_.add_PRIVATE_KEY(PRIVATE_KEY);
  builder_.add_XPUB(XPUB);
  builder_.add_PUBLIC_KEY(PUBLIC_KEY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CryptoKey> CreateCryptoKeyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PUBLIC_KEY = nullptr,
    const char *XPUB = nullptr,
    const char *PRIVATE_KEY = nullptr,
    const char *XPRIV = nullptr,
    const char *KEY_ADDRESS = nullptr,
    const char *ADDRESS_TYPE = nullptr) {
  auto PUBLIC_KEY__ = PUBLIC_KEY ? _fbb.CreateString(PUBLIC_KEY) : 0;
  auto XPUB__ = XPUB ? _fbb.CreateString(XPUB) : 0;
  auto PRIVATE_KEY__ = PRIVATE_KEY ? _fbb.CreateString(PRIVATE_KEY) : 0;
  auto XPRIV__ = XPRIV ? _fbb.CreateString(XPRIV) : 0;
  auto KEY_ADDRESS__ = KEY_ADDRESS ? _fbb.CreateString(KEY_ADDRESS) : 0;
  auto ADDRESS_TYPE__ = ADDRESS_TYPE ? _fbb.CreateString(ADDRESS_TYPE) : 0;
  return CreateCryptoKey(
      _fbb,
      PUBLIC_KEY__,
      XPUB__,
      PRIVATE_KEY__,
      XPRIV__,
      KEY_ADDRESS__,
      ADDRESS_TYPE__);
}

/// Represents a geographic address
struct Address FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddressBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNTRY = 4,
    VT_REGION = 6,
    VT_LOCALITY = 8,
    VT_POSTAL_CODE = 10,
    VT_STREET = 12,
    VT_POST_OFFICE_BOX_NUMBER = 14
  };
  /// Country of the address
  const ::flatbuffers::String *COUNTRY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRY);
  }
  /// Region of the address (e.g., state or province)
  const ::flatbuffers::String *REGION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGION);
  }
  /// Locality of the address (e.g., city or town)
  const ::flatbuffers::String *LOCALITY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALITY);
  }
  /// Postal code of the address
  const ::flatbuffers::String *POSTAL_CODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSTAL_CODE);
  }
  /// Street address
  const ::flatbuffers::String *STREET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STREET);
  }
  /// Post office box number
  const ::flatbuffers::String *POST_OFFICE_BOX_NUMBER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POST_OFFICE_BOX_NUMBER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COUNTRY) &&
           verifier.VerifyString(COUNTRY()) &&
           VerifyOffset(verifier, VT_REGION) &&
           verifier.VerifyString(REGION()) &&
           VerifyOffset(verifier, VT_LOCALITY) &&
           verifier.VerifyString(LOCALITY()) &&
           VerifyOffset(verifier, VT_POSTAL_CODE) &&
           verifier.VerifyString(POSTAL_CODE()) &&
           VerifyOffset(verifier, VT_STREET) &&
           verifier.VerifyString(STREET()) &&
           VerifyOffset(verifier, VT_POST_OFFICE_BOX_NUMBER) &&
           verifier.VerifyString(POST_OFFICE_BOX_NUMBER()) &&
           verifier.EndTable();
  }
};

struct AddressBuilder {
  typedef Address Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COUNTRY(::flatbuffers::Offset<::flatbuffers::String> COUNTRY) {
    fbb_.AddOffset(Address::VT_COUNTRY, COUNTRY);
  }
  void add_REGION(::flatbuffers::Offset<::flatbuffers::String> REGION) {
    fbb_.AddOffset(Address::VT_REGION, REGION);
  }
  void add_LOCALITY(::flatbuffers::Offset<::flatbuffers::String> LOCALITY) {
    fbb_.AddOffset(Address::VT_LOCALITY, LOCALITY);
  }
  void add_POSTAL_CODE(::flatbuffers::Offset<::flatbuffers::String> POSTAL_CODE) {
    fbb_.AddOffset(Address::VT_POSTAL_CODE, POSTAL_CODE);
  }
  void add_STREET(::flatbuffers::Offset<::flatbuffers::String> STREET) {
    fbb_.AddOffset(Address::VT_STREET, STREET);
  }
  void add_POST_OFFICE_BOX_NUMBER(::flatbuffers::Offset<::flatbuffers::String> POST_OFFICE_BOX_NUMBER) {
    fbb_.AddOffset(Address::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  explicit AddressBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Address> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Address>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Address> CreateAddress(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COUNTRY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REGION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LOCALITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POSTAL_CODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STREET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POST_OFFICE_BOX_NUMBER = 0) {
  AddressBuilder builder_(_fbb);
  builder_.add_POST_OFFICE_BOX_NUMBER(POST_OFFICE_BOX_NUMBER);
  builder_.add_STREET(STREET);
  builder_.add_POSTAL_CODE(POSTAL_CODE);
  builder_.add_LOCALITY(LOCALITY);
  builder_.add_REGION(REGION);
  builder_.add_COUNTRY(COUNTRY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Address> CreateAddressDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COUNTRY = nullptr,
    const char *REGION = nullptr,
    const char *LOCALITY = nullptr,
    const char *POSTAL_CODE = nullptr,
    const char *STREET = nullptr,
    const char *POST_OFFICE_BOX_NUMBER = nullptr) {
  auto COUNTRY__ = COUNTRY ? _fbb.CreateString(COUNTRY) : 0;
  auto REGION__ = REGION ? _fbb.CreateString(REGION) : 0;
  auto LOCALITY__ = LOCALITY ? _fbb.CreateString(LOCALITY) : 0;
  auto POSTAL_CODE__ = POSTAL_CODE ? _fbb.CreateString(POSTAL_CODE) : 0;
  auto STREET__ = STREET ? _fbb.CreateString(STREET) : 0;
  auto POST_OFFICE_BOX_NUMBER__ = POST_OFFICE_BOX_NUMBER ? _fbb.CreateString(POST_OFFICE_BOX_NUMBER) : 0;
  return CreateAddress(
      _fbb,
      COUNTRY__,
      REGION__,
      LOCALITY__,
      POSTAL_CODE__,
      STREET__,
      POST_OFFICE_BOX_NUMBER__);
}

/// Specific attributes for a Person
struct PersonAttributes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PersonAttributesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FAMILY_NAME = 4,
    VT_GIVEN_NAME = 6,
    VT_ADDITIONAL_NAME = 8,
    VT_HONORIFIC_PREFIX = 10,
    VT_HONORIFIC_SUFFIX = 12,
    VT_JOB_TITLE = 14,
    VT_OCCUPATION = 16
  };
  /// Family name or surname of the person
  const ::flatbuffers::String *FAMILY_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FAMILY_NAME);
  }
  /// Given name or first name of the person
  const ::flatbuffers::String *GIVEN_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GIVEN_NAME);
  }
  /// Additional name or middle name of the person
  const ::flatbuffers::String *ADDITIONAL_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDITIONAL_NAME);
  }
  /// Honorific prefix preceding the person's name (e.g., Mr., Dr.)
  const ::flatbuffers::String *HONORIFIC_PREFIX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HONORIFIC_PREFIX);
  }
  /// Honorific suffix following the person's name (e.g., Jr., Sr.)
  const ::flatbuffers::String *HONORIFIC_SUFFIX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HONORIFIC_SUFFIX);
  }
  /// Job title of the person
  const ::flatbuffers::String *JOB_TITLE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JOB_TITLE);
  }
  /// Occupation of the person
  const ::flatbuffers::String *OCCUPATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OCCUPATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FAMILY_NAME) &&
           verifier.VerifyString(FAMILY_NAME()) &&
           VerifyOffset(verifier, VT_GIVEN_NAME) &&
           verifier.VerifyString(GIVEN_NAME()) &&
           VerifyOffset(verifier, VT_ADDITIONAL_NAME) &&
           verifier.VerifyString(ADDITIONAL_NAME()) &&
           VerifyOffset(verifier, VT_HONORIFIC_PREFIX) &&
           verifier.VerifyString(HONORIFIC_PREFIX()) &&
           VerifyOffset(verifier, VT_HONORIFIC_SUFFIX) &&
           verifier.VerifyString(HONORIFIC_SUFFIX()) &&
           VerifyOffset(verifier, VT_JOB_TITLE) &&
           verifier.VerifyString(JOB_TITLE()) &&
           VerifyOffset(verifier, VT_OCCUPATION) &&
           verifier.VerifyString(OCCUPATION()) &&
           verifier.EndTable();
  }
};

struct PersonAttributesBuilder {
  typedef PersonAttributes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_FAMILY_NAME(::flatbuffers::Offset<::flatbuffers::String> FAMILY_NAME) {
    fbb_.AddOffset(PersonAttributes::VT_FAMILY_NAME, FAMILY_NAME);
  }
  void add_GIVEN_NAME(::flatbuffers::Offset<::flatbuffers::String> GIVEN_NAME) {
    fbb_.AddOffset(PersonAttributes::VT_GIVEN_NAME, GIVEN_NAME);
  }
  void add_ADDITIONAL_NAME(::flatbuffers::Offset<::flatbuffers::String> ADDITIONAL_NAME) {
    fbb_.AddOffset(PersonAttributes::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  void add_HONORIFIC_PREFIX(::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_PREFIX) {
    fbb_.AddOffset(PersonAttributes::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  void add_HONORIFIC_SUFFIX(::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_SUFFIX) {
    fbb_.AddOffset(PersonAttributes::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  void add_JOB_TITLE(::flatbuffers::Offset<::flatbuffers::String> JOB_TITLE) {
    fbb_.AddOffset(PersonAttributes::VT_JOB_TITLE, JOB_TITLE);
  }
  void add_OCCUPATION(::flatbuffers::Offset<::flatbuffers::String> OCCUPATION) {
    fbb_.AddOffset(PersonAttributes::VT_OCCUPATION, OCCUPATION);
  }
  explicit PersonAttributesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PersonAttributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PersonAttributes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PersonAttributes> CreatePersonAttributes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> FAMILY_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GIVEN_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ADDITIONAL_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_PREFIX = 0,
    ::flatbuffers::Offset<::flatbuffers::String> HONORIFIC_SUFFIX = 0,
    ::flatbuffers::Offset<::flatbuffers::String> JOB_TITLE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OCCUPATION = 0) {
  PersonAttributesBuilder builder_(_fbb);
  builder_.add_OCCUPATION(OCCUPATION);
  builder_.add_JOB_TITLE(JOB_TITLE);
  builder_.add_HONORIFIC_SUFFIX(HONORIFIC_SUFFIX);
  builder_.add_HONORIFIC_PREFIX(HONORIFIC_PREFIX);
  builder_.add_ADDITIONAL_NAME(ADDITIONAL_NAME);
  builder_.add_GIVEN_NAME(GIVEN_NAME);
  builder_.add_FAMILY_NAME(FAMILY_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PersonAttributes> CreatePersonAttributesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *FAMILY_NAME = nullptr,
    const char *GIVEN_NAME = nullptr,
    const char *ADDITIONAL_NAME = nullptr,
    const char *HONORIFIC_PREFIX = nullptr,
    const char *HONORIFIC_SUFFIX = nullptr,
    const char *JOB_TITLE = nullptr,
    const char *OCCUPATION = nullptr) {
  auto FAMILY_NAME__ = FAMILY_NAME ? _fbb.CreateString(FAMILY_NAME) : 0;
  auto GIVEN_NAME__ = GIVEN_NAME ? _fbb.CreateString(GIVEN_NAME) : 0;
  auto ADDITIONAL_NAME__ = ADDITIONAL_NAME ? _fbb.CreateString(ADDITIONAL_NAME) : 0;
  auto HONORIFIC_PREFIX__ = HONORIFIC_PREFIX ? _fbb.CreateString(HONORIFIC_PREFIX) : 0;
  auto HONORIFIC_SUFFIX__ = HONORIFIC_SUFFIX ? _fbb.CreateString(HONORIFIC_SUFFIX) : 0;
  auto JOB_TITLE__ = JOB_TITLE ? _fbb.CreateString(JOB_TITLE) : 0;
  auto OCCUPATION__ = OCCUPATION ? _fbb.CreateString(OCCUPATION) : 0;
  return CreatePersonAttributes(
      _fbb,
      FAMILY_NAME__,
      GIVEN_NAME__,
      ADDITIONAL_NAME__,
      HONORIFIC_PREFIX__,
      HONORIFIC_SUFFIX__,
      JOB_TITLE__,
      OCCUPATION__);
}

/// Specific attributes for an Organization
struct OrganizationAttributes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrganizationAttributesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEGAL_NAME = 4
  };
  /// Legal name of the organization
  const ::flatbuffers::String *LEGAL_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LEGAL_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEGAL_NAME) &&
           verifier.VerifyString(LEGAL_NAME()) &&
           verifier.EndTable();
  }
};

struct OrganizationAttributesBuilder {
  typedef OrganizationAttributes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LEGAL_NAME(::flatbuffers::Offset<::flatbuffers::String> LEGAL_NAME) {
    fbb_.AddOffset(OrganizationAttributes::VT_LEGAL_NAME, LEGAL_NAME);
  }
  explicit OrganizationAttributesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrganizationAttributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrganizationAttributes>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrganizationAttributes> CreateOrganizationAttributes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> LEGAL_NAME = 0) {
  OrganizationAttributesBuilder builder_(_fbb);
  builder_.add_LEGAL_NAME(LEGAL_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrganizationAttributes> CreateOrganizationAttributesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *LEGAL_NAME = nullptr) {
  auto LEGAL_NAME__ = LEGAL_NAME ? _fbb.CreateString(LEGAL_NAME) : 0;
  return CreateOrganizationAttributes(
      _fbb,
      LEGAL_NAME__);
}

/// Entity Profile Message
struct EPM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EPMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DN = 4,
    VT_NAME = 6,
    VT_ALTERNATE_NAMES = 8,
    VT_EMAIL = 10,
    VT_TELEPHONE = 12,
    VT_KEYS = 14,
    VT_MULTIFORMAT_ADDRESS = 16,
    VT_ATTRIBUTES_TYPE = 18,
    VT_ATTRIBUTES = 20
  };
  /// Distinguished Name of the entity
  const DistinguishedName *DN() const {
    return GetPointer<const DistinguishedName *>(VT_DN);
  }
  /// Common name of the entity (person or organization)
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Alternate names for the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALTERNATE_NAMES);
  }
  /// Email address of the entity
  const ::flatbuffers::String *EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EMAIL);
  }
  /// Telephone number of the entity
  const ::flatbuffers::String *TELEPHONE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TELEPHONE);
  }
  /// Cryptographic keys associated with the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>> *KEYS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>> *>(VT_KEYS);
  }
  /// Multiformat addresses associated with the entity
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MULTIFORMAT_ADDRESS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MULTIFORMAT_ADDRESS);
  }
  SpecificAttributes ATTRIBUTES_type() const {
    return static_cast<SpecificAttributes>(GetField<uint8_t>(VT_ATTRIBUTES_TYPE, 0));
  }
  /// Specific attributes for the entity, either Person or Organization
  const void *ATTRIBUTES() const {
    return GetPointer<const void *>(VT_ATTRIBUTES);
  }
  template<typename T> const T *ATTRIBUTES_as() const;
  const PersonAttributes *ATTRIBUTES_as_PersonAttributes() const {
    return ATTRIBUTES_type() == SpecificAttributes_PersonAttributes ? static_cast<const PersonAttributes *>(ATTRIBUTES()) : nullptr;
  }
  const OrganizationAttributes *ATTRIBUTES_as_OrganizationAttributes() const {
    return ATTRIBUTES_type() == SpecificAttributes_OrganizationAttributes ? static_cast<const OrganizationAttributes *>(ATTRIBUTES()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DN) &&
           verifier.VerifyTable(DN()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_ALTERNATE_NAMES) &&
           verifier.VerifyVector(ALTERNATE_NAMES()) &&
           verifier.VerifyVectorOfStrings(ALTERNATE_NAMES()) &&
           VerifyOffset(verifier, VT_EMAIL) &&
           verifier.VerifyString(EMAIL()) &&
           VerifyOffset(verifier, VT_TELEPHONE) &&
           verifier.VerifyString(TELEPHONE()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(KEYS()) &&
           verifier.VerifyVectorOfTables(KEYS()) &&
           VerifyOffset(verifier, VT_MULTIFORMAT_ADDRESS) &&
           verifier.VerifyVector(MULTIFORMAT_ADDRESS()) &&
           verifier.VerifyVectorOfStrings(MULTIFORMAT_ADDRESS()) &&
           VerifyField<uint8_t>(verifier, VT_ATTRIBUTES_TYPE, 1) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           VerifySpecificAttributes(verifier, ATTRIBUTES(), ATTRIBUTES_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PersonAttributes *EPM::ATTRIBUTES_as<PersonAttributes>() const {
  return ATTRIBUTES_as_PersonAttributes();
}

template<> inline const OrganizationAttributes *EPM::ATTRIBUTES_as<OrganizationAttributes>() const {
  return ATTRIBUTES_as_OrganizationAttributes();
}

struct EPMBuilder {
  typedef EPM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DN(::flatbuffers::Offset<DistinguishedName> DN) {
    fbb_.AddOffset(EPM::VT_DN, DN);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(EPM::VT_NAME, NAME);
  }
  void add_ALTERNATE_NAMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES) {
    fbb_.AddOffset(EPM::VT_ALTERNATE_NAMES, ALTERNATE_NAMES);
  }
  void add_EMAIL(::flatbuffers::Offset<::flatbuffers::String> EMAIL) {
    fbb_.AddOffset(EPM::VT_EMAIL, EMAIL);
  }
  void add_TELEPHONE(::flatbuffers::Offset<::flatbuffers::String> TELEPHONE) {
    fbb_.AddOffset(EPM::VT_TELEPHONE, TELEPHONE);
  }
  void add_KEYS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>>> KEYS) {
    fbb_.AddOffset(EPM::VT_KEYS, KEYS);
  }
  void add_MULTIFORMAT_ADDRESS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MULTIFORMAT_ADDRESS) {
    fbb_.AddOffset(EPM::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  void add_ATTRIBUTES_type(SpecificAttributes ATTRIBUTES_type) {
    fbb_.AddElement<uint8_t>(EPM::VT_ATTRIBUTES_TYPE, static_cast<uint8_t>(ATTRIBUTES_type), 0);
  }
  void add_ATTRIBUTES(::flatbuffers::Offset<void> ATTRIBUTES) {
    fbb_.AddOffset(EPM::VT_ATTRIBUTES, ATTRIBUTES);
  }
  explicit EPMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EPM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EPM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EPM> CreateEPM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DistinguishedName> DN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ALTERNATE_NAMES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EMAIL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TELEPHONE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CryptoKey>>> KEYS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MULTIFORMAT_ADDRESS = 0,
    SpecificAttributes ATTRIBUTES_type = SpecificAttributes_NONE,
    ::flatbuffers::Offset<void> ATTRIBUTES = 0) {
  EPMBuilder builder_(_fbb);
  builder_.add_ATTRIBUTES(ATTRIBUTES);
  builder_.add_MULTIFORMAT_ADDRESS(MULTIFORMAT_ADDRESS);
  builder_.add_KEYS(KEYS);
  builder_.add_TELEPHONE(TELEPHONE);
  builder_.add_EMAIL(EMAIL);
  builder_.add_ALTERNATE_NAMES(ALTERNATE_NAMES);
  builder_.add_NAME(NAME);
  builder_.add_DN(DN);
  builder_.add_ATTRIBUTES_type(ATTRIBUTES_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EPM> CreateEPMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<DistinguishedName> DN = 0,
    const char *NAME = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ALTERNATE_NAMES = nullptr,
    const char *EMAIL = nullptr,
    const char *TELEPHONE = nullptr,
    const std::vector<::flatbuffers::Offset<CryptoKey>> *KEYS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MULTIFORMAT_ADDRESS = nullptr,
    SpecificAttributes ATTRIBUTES_type = SpecificAttributes_NONE,
    ::flatbuffers::Offset<void> ATTRIBUTES = 0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto ALTERNATE_NAMES__ = ALTERNATE_NAMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ALTERNATE_NAMES) : 0;
  auto EMAIL__ = EMAIL ? _fbb.CreateString(EMAIL) : 0;
  auto TELEPHONE__ = TELEPHONE ? _fbb.CreateString(TELEPHONE) : 0;
  auto KEYS__ = KEYS ? _fbb.CreateVector<::flatbuffers::Offset<CryptoKey>>(*KEYS) : 0;
  auto MULTIFORMAT_ADDRESS__ = MULTIFORMAT_ADDRESS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MULTIFORMAT_ADDRESS) : 0;
  return CreateEPM(
      _fbb,
      DN,
      NAME__,
      ALTERNATE_NAMES__,
      EMAIL__,
      TELEPHONE__,
      KEYS__,
      MULTIFORMAT_ADDRESS__,
      ATTRIBUTES_type,
      ATTRIBUTES);
}

/// Collection of Entity Profile Messages
struct EPMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EPMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  /// Records of Entity Profile Messages
  const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct EPMCOLLECTIONBuilder {
  typedef EPMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> RECORDS) {
    fbb_.AddOffset(EPMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit EPMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EPMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EPMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EPMCOLLECTION> CreateEPMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> RECORDS = 0) {
  EPMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EPMCOLLECTION> CreateEPMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EPM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<EPM>>(*RECORDS) : 0;
  return CreateEPMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline bool VerifySpecificAttributes(::flatbuffers::Verifier &verifier, const void *obj, SpecificAttributes type) {
  switch (type) {
    case SpecificAttributes_NONE: {
      return true;
    }
    case SpecificAttributes_PersonAttributes: {
      auto ptr = reinterpret_cast<const PersonAttributes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SpecificAttributes_OrganizationAttributes: {
      auto ptr = reinterpret_cast<const OrganizationAttributes *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySpecificAttributesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySpecificAttributes(
        verifier,  values->Get(i), types->GetEnum<SpecificAttributes>(i))) {
      return false;
    }
  }
  return true;
}

inline const EPMCOLLECTION *GetEPMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetRoot<EPMCOLLECTION>(buf);
}

inline const EPMCOLLECTION *GetSizePrefixedEPMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EPMCOLLECTION>(buf);
}

inline const char *EPMCOLLECTIONIdentifier() {
  return "$EPM";
}

inline bool EPMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EPMCOLLECTIONIdentifier());
}

inline bool SizePrefixedEPMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EPMCOLLECTIONIdentifier(), true);
}

inline bool VerifyEPMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EPMCOLLECTION>(EPMCOLLECTIONIdentifier());
}

inline bool VerifySizePrefixedEPMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EPMCOLLECTION>(EPMCOLLECTIONIdentifier());
}

inline void FinishEPMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EPMCOLLECTION> root) {
  fbb.Finish(root, EPMCOLLECTIONIdentifier());
}

inline void FinishSizePrefixedEPMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EPMCOLLECTION> root) {
  fbb.FinishSizePrefixed(root, EPMCOLLECTIONIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
