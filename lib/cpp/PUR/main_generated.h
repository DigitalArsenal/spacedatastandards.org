// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct PUR;
struct PURBuilder;

/// Purchase Request - Request to purchase data from a storefront listing
struct PUR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PURBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_ID = 4,
    VT_LISTING_ID = 6,
    VT_TIER_NAME = 8,
    VT_BUYER_PEER_ID = 10,
    VT_BUYER_ENCRYPTION_PUBKEY = 12,
    VT_PAYMENT_METHOD = 14,
    VT_PAYMENT_AMOUNT = 16,
    VT_PAYMENT_CURRENCY = 18,
    VT_PAYMENT_TX_HASH = 20,
    VT_PAYMENT_CHAIN = 22,
    VT_PAYMENT_REFERENCE = 24,
    VT_BUYER_SIGNATURE = 26,
    VT_TIMESTAMP = 28
  };
  /// Unique identifier for this purchase request
  const ::flatbuffers::String *REQUEST_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REQUEST_ID);
  }
  /// ID of the listing being purchased
  const ::flatbuffers::String *LISTING_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LISTING_ID);
  }
  /// Name of the pricing tier selected
  const ::flatbuffers::String *TIER_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIER_NAME);
  }
  /// Peer ID of the buyer
  const ::flatbuffers::String *BUYER_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUYER_PEER_ID);
  }
  /// Buyer's encryption public key for encrypted delivery
  const ::flatbuffers::Vector<uint8_t> *BUYER_ENCRYPTION_PUBKEY() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUYER_ENCRYPTION_PUBKEY);
  }
  /// Payment method used
  paymentMethod PAYMENT_METHOD() const {
    return static_cast<paymentMethod>(GetField<int8_t>(VT_PAYMENT_METHOD, 0));
  }
  /// Payment amount in smallest unit
  uint64_t PAYMENT_AMOUNT() const {
    return GetField<uint64_t>(VT_PAYMENT_AMOUNT, 0);
  }
  /// Currency of payment
  const ::flatbuffers::String *PAYMENT_CURRENCY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_CURRENCY);
  }
  /// Transaction hash for cryptocurrency payments
  const ::flatbuffers::String *PAYMENT_TX_HASH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_TX_HASH);
  }
  /// Blockchain network: "ethereum", "solana", "bitcoin"
  const ::flatbuffers::String *PAYMENT_CHAIN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_CHAIN);
  }
  /// Reference ID for credit/fiat payments
  const ::flatbuffers::String *PAYMENT_REFERENCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_REFERENCE);
  }
  /// Ed25519 signature from buyer
  const ::flatbuffers::Vector<uint8_t> *BUYER_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUYER_SIGNATURE);
  }
  /// Unix timestamp of the request
  uint64_t TIMESTAMP() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REQUEST_ID) &&
           verifier.VerifyString(REQUEST_ID()) &&
           VerifyOffsetRequired(verifier, VT_LISTING_ID) &&
           verifier.VerifyString(LISTING_ID()) &&
           VerifyOffsetRequired(verifier, VT_TIER_NAME) &&
           verifier.VerifyString(TIER_NAME()) &&
           VerifyOffsetRequired(verifier, VT_BUYER_PEER_ID) &&
           verifier.VerifyString(BUYER_PEER_ID()) &&
           VerifyOffset(verifier, VT_BUYER_ENCRYPTION_PUBKEY) &&
           verifier.VerifyVector(BUYER_ENCRYPTION_PUBKEY()) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_METHOD, 1) &&
           VerifyField<uint64_t>(verifier, VT_PAYMENT_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_PAYMENT_CURRENCY) &&
           verifier.VerifyString(PAYMENT_CURRENCY()) &&
           VerifyOffset(verifier, VT_PAYMENT_TX_HASH) &&
           verifier.VerifyString(PAYMENT_TX_HASH()) &&
           VerifyOffset(verifier, VT_PAYMENT_CHAIN) &&
           verifier.VerifyString(PAYMENT_CHAIN()) &&
           VerifyOffset(verifier, VT_PAYMENT_REFERENCE) &&
           verifier.VerifyString(PAYMENT_REFERENCE()) &&
           VerifyOffset(verifier, VT_BUYER_SIGNATURE) &&
           verifier.VerifyVector(BUYER_SIGNATURE()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           verifier.EndTable();
  }
};

struct PURBuilder {
  typedef PUR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_REQUEST_ID(::flatbuffers::Offset<::flatbuffers::String> REQUEST_ID) {
    fbb_.AddOffset(PUR::VT_REQUEST_ID, REQUEST_ID);
  }
  void add_LISTING_ID(::flatbuffers::Offset<::flatbuffers::String> LISTING_ID) {
    fbb_.AddOffset(PUR::VT_LISTING_ID, LISTING_ID);
  }
  void add_TIER_NAME(::flatbuffers::Offset<::flatbuffers::String> TIER_NAME) {
    fbb_.AddOffset(PUR::VT_TIER_NAME, TIER_NAME);
  }
  void add_BUYER_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> BUYER_PEER_ID) {
    fbb_.AddOffset(PUR::VT_BUYER_PEER_ID, BUYER_PEER_ID);
  }
  void add_BUYER_ENCRYPTION_PUBKEY(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_ENCRYPTION_PUBKEY) {
    fbb_.AddOffset(PUR::VT_BUYER_ENCRYPTION_PUBKEY, BUYER_ENCRYPTION_PUBKEY);
  }
  void add_PAYMENT_METHOD(paymentMethod PAYMENT_METHOD) {
    fbb_.AddElement<int8_t>(PUR::VT_PAYMENT_METHOD, static_cast<int8_t>(PAYMENT_METHOD), 0);
  }
  void add_PAYMENT_AMOUNT(uint64_t PAYMENT_AMOUNT) {
    fbb_.AddElement<uint64_t>(PUR::VT_PAYMENT_AMOUNT, PAYMENT_AMOUNT, 0);
  }
  void add_PAYMENT_CURRENCY(::flatbuffers::Offset<::flatbuffers::String> PAYMENT_CURRENCY) {
    fbb_.AddOffset(PUR::VT_PAYMENT_CURRENCY, PAYMENT_CURRENCY);
  }
  void add_PAYMENT_TX_HASH(::flatbuffers::Offset<::flatbuffers::String> PAYMENT_TX_HASH) {
    fbb_.AddOffset(PUR::VT_PAYMENT_TX_HASH, PAYMENT_TX_HASH);
  }
  void add_PAYMENT_CHAIN(::flatbuffers::Offset<::flatbuffers::String> PAYMENT_CHAIN) {
    fbb_.AddOffset(PUR::VT_PAYMENT_CHAIN, PAYMENT_CHAIN);
  }
  void add_PAYMENT_REFERENCE(::flatbuffers::Offset<::flatbuffers::String> PAYMENT_REFERENCE) {
    fbb_.AddOffset(PUR::VT_PAYMENT_REFERENCE, PAYMENT_REFERENCE);
  }
  void add_BUYER_SIGNATURE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_SIGNATURE) {
    fbb_.AddOffset(PUR::VT_BUYER_SIGNATURE, BUYER_SIGNATURE);
  }
  void add_TIMESTAMP(uint64_t TIMESTAMP) {
    fbb_.AddElement<uint64_t>(PUR::VT_TIMESTAMP, TIMESTAMP, 0);
  }
  explicit PURBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PUR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PUR>(end);
    fbb_.Required(o, PUR::VT_REQUEST_ID);
    fbb_.Required(o, PUR::VT_LISTING_ID);
    fbb_.Required(o, PUR::VT_TIER_NAME);
    fbb_.Required(o, PUR::VT_BUYER_PEER_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<PUR> CreatePUR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> REQUEST_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LISTING_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIER_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> BUYER_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_ENCRYPTION_PUBKEY = 0,
    paymentMethod PAYMENT_METHOD = paymentMethod_Crypto_ETH,
    uint64_t PAYMENT_AMOUNT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PAYMENT_CURRENCY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PAYMENT_TX_HASH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PAYMENT_CHAIN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PAYMENT_REFERENCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_SIGNATURE = 0,
    uint64_t TIMESTAMP = 0) {
  PURBuilder builder_(_fbb);
  builder_.add_TIMESTAMP(TIMESTAMP);
  builder_.add_PAYMENT_AMOUNT(PAYMENT_AMOUNT);
  builder_.add_BUYER_SIGNATURE(BUYER_SIGNATURE);
  builder_.add_PAYMENT_REFERENCE(PAYMENT_REFERENCE);
  builder_.add_PAYMENT_CHAIN(PAYMENT_CHAIN);
  builder_.add_PAYMENT_TX_HASH(PAYMENT_TX_HASH);
  builder_.add_PAYMENT_CURRENCY(PAYMENT_CURRENCY);
  builder_.add_BUYER_ENCRYPTION_PUBKEY(BUYER_ENCRYPTION_PUBKEY);
  builder_.add_BUYER_PEER_ID(BUYER_PEER_ID);
  builder_.add_TIER_NAME(TIER_NAME);
  builder_.add_LISTING_ID(LISTING_ID);
  builder_.add_REQUEST_ID(REQUEST_ID);
  builder_.add_PAYMENT_METHOD(PAYMENT_METHOD);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PUR> CreatePURDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *REQUEST_ID = nullptr,
    const char *LISTING_ID = nullptr,
    const char *TIER_NAME = nullptr,
    const char *BUYER_PEER_ID = nullptr,
    const std::vector<uint8_t> *BUYER_ENCRYPTION_PUBKEY = nullptr,
    paymentMethod PAYMENT_METHOD = paymentMethod_Crypto_ETH,
    uint64_t PAYMENT_AMOUNT = 0,
    const char *PAYMENT_CURRENCY = nullptr,
    const char *PAYMENT_TX_HASH = nullptr,
    const char *PAYMENT_CHAIN = nullptr,
    const char *PAYMENT_REFERENCE = nullptr,
    const std::vector<uint8_t> *BUYER_SIGNATURE = nullptr,
    uint64_t TIMESTAMP = 0) {
  auto REQUEST_ID__ = REQUEST_ID ? _fbb.CreateString(REQUEST_ID) : 0;
  auto LISTING_ID__ = LISTING_ID ? _fbb.CreateString(LISTING_ID) : 0;
  auto TIER_NAME__ = TIER_NAME ? _fbb.CreateString(TIER_NAME) : 0;
  auto BUYER_PEER_ID__ = BUYER_PEER_ID ? _fbb.CreateString(BUYER_PEER_ID) : 0;
  auto BUYER_ENCRYPTION_PUBKEY__ = BUYER_ENCRYPTION_PUBKEY ? _fbb.CreateVector<uint8_t>(*BUYER_ENCRYPTION_PUBKEY) : 0;
  auto PAYMENT_CURRENCY__ = PAYMENT_CURRENCY ? _fbb.CreateString(PAYMENT_CURRENCY) : 0;
  auto PAYMENT_TX_HASH__ = PAYMENT_TX_HASH ? _fbb.CreateString(PAYMENT_TX_HASH) : 0;
  auto PAYMENT_CHAIN__ = PAYMENT_CHAIN ? _fbb.CreateString(PAYMENT_CHAIN) : 0;
  auto PAYMENT_REFERENCE__ = PAYMENT_REFERENCE ? _fbb.CreateString(PAYMENT_REFERENCE) : 0;
  auto BUYER_SIGNATURE__ = BUYER_SIGNATURE ? _fbb.CreateVector<uint8_t>(*BUYER_SIGNATURE) : 0;
  return CreatePUR(
      _fbb,
      REQUEST_ID__,
      LISTING_ID__,
      TIER_NAME__,
      BUYER_PEER_ID__,
      BUYER_ENCRYPTION_PUBKEY__,
      PAYMENT_METHOD,
      PAYMENT_AMOUNT,
      PAYMENT_CURRENCY__,
      PAYMENT_TX_HASH__,
      PAYMENT_CHAIN__,
      PAYMENT_REFERENCE__,
      BUYER_SIGNATURE__,
      TIMESTAMP);
}

inline const PUR *GetPUR(const void *buf) {
  return ::flatbuffers::GetRoot<PUR>(buf);
}

inline const PUR *GetSizePrefixedPUR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PUR>(buf);
}

inline const char *PURIdentifier() {
  return "$PUR";
}

inline bool PURBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PURIdentifier());
}

inline bool SizePrefixedPURBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PURIdentifier(), true);
}

inline bool VerifyPURBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PUR>(PURIdentifier());
}

inline bool VerifySizePrefixedPURBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PUR>(PURIdentifier());
}

inline void FinishPURBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PUR> root) {
  fbb.Finish(root, PURIdentifier());
}

inline void FinishSizePrefixedPURBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PUR> root) {
  fbb.FinishSizePrefixed(root, PURIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
