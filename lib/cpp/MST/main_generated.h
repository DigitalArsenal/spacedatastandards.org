// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MST;
struct MSTBuilder;

enum missileStatus : int8_t {
  missileStatus_BOOSTING = 0,
  missileStatus_MIDCOURSE = 1,
  missileStatus_TERMINAL = 2,
  missileStatus_IMPACT = 3,
  missileStatus_BURNOUT = 4,
  missileStatus_INTERCEPTED = 5,
  missileStatus_LOST = 6,
  missileStatus_UNKNOWN = 7,
  missileStatus_MIN = missileStatus_BOOSTING,
  missileStatus_MAX = missileStatus_UNKNOWN
};

inline const missileStatus (&EnumValuesmissileStatus())[8] {
  static const missileStatus values[] = {
    missileStatus_BOOSTING,
    missileStatus_MIDCOURSE,
    missileStatus_TERMINAL,
    missileStatus_IMPACT,
    missileStatus_BURNOUT,
    missileStatus_INTERCEPTED,
    missileStatus_LOST,
    missileStatus_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesmissileStatus() {
  static const char * const names[9] = {
    "BOOSTING",
    "MIDCOURSE",
    "TERMINAL",
    "IMPACT",
    "BURNOUT",
    "INTERCEPTED",
    "LOST",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNamemissileStatus(missileStatus e) {
  if (::flatbuffers::IsOutRange(e, missileStatus_BOOSTING, missileStatus_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmissileStatus()[index];
}

enum missileEnvironment : int8_t {
  missileEnvironment_SPACE = 0,
  missileEnvironment_ENDO_ATMOSPHERIC = 1,
  missileEnvironment_EXO_ATMOSPHERIC = 2,
  missileEnvironment_TRANSITIONAL = 3,
  missileEnvironment_UNKNOWN = 4,
  missileEnvironment_MIN = missileEnvironment_SPACE,
  missileEnvironment_MAX = missileEnvironment_UNKNOWN
};

inline const missileEnvironment (&EnumValuesmissileEnvironment())[5] {
  static const missileEnvironment values[] = {
    missileEnvironment_SPACE,
    missileEnvironment_ENDO_ATMOSPHERIC,
    missileEnvironment_EXO_ATMOSPHERIC,
    missileEnvironment_TRANSITIONAL,
    missileEnvironment_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesmissileEnvironment() {
  static const char * const names[6] = {
    "SPACE",
    "ENDO_ATMOSPHERIC",
    "EXO_ATMOSPHERIC",
    "TRANSITIONAL",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNamemissileEnvironment(missileEnvironment e) {
  if (::flatbuffers::IsOutRange(e, missileEnvironment_SPACE, missileEnvironment_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmissileEnvironment()[index];
}

enum aouReportType : int8_t {
  aouReportType_CIRCULAR = 0,
  aouReportType_ELLIPTICAL = 1,
  aouReportType_RECTANGULAR = 2,
  aouReportType_NONE = 3,
  aouReportType_MIN = aouReportType_CIRCULAR,
  aouReportType_MAX = aouReportType_NONE
};

inline const aouReportType (&EnumValuesaouReportType())[4] {
  static const aouReportType values[] = {
    aouReportType_CIRCULAR,
    aouReportType_ELLIPTICAL,
    aouReportType_RECTANGULAR,
    aouReportType_NONE
  };
  return values;
}

inline const char * const *EnumNamesaouReportType() {
  static const char * const names[5] = {
    "CIRCULAR",
    "ELLIPTICAL",
    "RECTANGULAR",
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameaouReportType(aouReportType e) {
  if (::flatbuffers::IsOutRange(e, aouReportType_CIRCULAR, aouReportType_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesaouReportType()[index];
}

/// Missile Track
struct MST FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MSTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG_SUB_TYPE = 8,
    VT_MSG_CREATE_DATE = 10,
    VT_ENVIRONMENT = 12,
    VT_OBJ_TYPE = 14,
    VT_OBJ_TYPE_CONF = 16,
    VT_OBJ_PLAT = 18,
    VT_OBJ_IDENT = 20,
    VT_SPACE_AMP = 22,
    VT_SPACE_AMP_CONF = 24,
    VT_OBJ_ACT = 26,
    VT_SPACE_SPEC_TYPE = 28,
    VT_ACFT_SUB_TYPE = 30,
    VT_NAME = 32,
    VT_CALL_SIGN = 34,
    VT_LOST_TRK_IND = 36,
    VT_TRACK_ID = 38,
    VT_PARENT_TRACK_ID = 40,
    VT_MUID_SRC_TRK = 42,
    VT_MUID_SRC = 44,
    VT_ALERT = 46,
    VT_MSL_STATUS = 48,
    VT_TS = 50,
    VT_AOU_RPT_TYPE = 52,
    VT_CONTAINMENT = 54,
    VT_TRK_CONF = 56,
    VT_TRK_QUAL = 58,
    VT_ANG_ELEV = 60,
    VT_SEN_MODE = 62,
    VT_INFO_SOURCE = 64,
    VT_BOOSTING = 66,
    VT_POLAR_SING_LOC_LAT = 68,
    VT_POLAR_SING_LOC_LON = 70,
    VT_EMG_IND = 72,
    VT_DROP_PT_IND = 74,
    VT_LAUNCH_TIME = 76,
    VT_LAUNCH_LAT = 78,
    VT_LAUNCH_LON = 80,
    VT_AZ_CORR = 82,
    VT_BURNOUT_ALT = 84,
    VT_LAUNCH_AOU_TYPE = 86,
    VT_IMPACT_TIME = 88,
    VT_IMPACT_LAT = 90,
    VT_IMPACT_LON = 92,
    VT_IMPACT_AOU_TYPE = 94,
    VT_VECTOR_START_TIME = 96,
    VT_VECTOR_STEP_SIZE = 98,
    VT_VECTOR_COMPONENTS = 100,
    VT_VECTORS = 102,
    VT_AOU_RPT = 104,
    VT_LAUNCH_AOU = 106,
    VT_IMPACT_AOU = 108
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Message type code
  const ::flatbuffers::String *MSG_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG_TYPE);
  }
  /// Message sub-type
  const ::flatbuffers::String *MSG_SUB_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG_SUB_TYPE);
  }
  /// Message creation date (ISO 8601)
  const ::flatbuffers::String *MSG_CREATE_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSG_CREATE_DATE);
  }
  /// Track environment
  missileEnvironment ENVIRONMENT() const {
    return static_cast<missileEnvironment>(GetField<int8_t>(VT_ENVIRONMENT, 0));
  }
  /// Object type classification
  const ::flatbuffers::String *OBJ_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJ_TYPE);
  }
  /// Object type confidence (0-100)
  uint8_t OBJ_TYPE_CONF() const {
    return GetField<uint8_t>(VT_OBJ_TYPE_CONF, 0);
  }
  /// Object platform type
  const ::flatbuffers::String *OBJ_PLAT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJ_PLAT);
  }
  /// Object identity assessment
  const ::flatbuffers::String *OBJ_IDENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJ_IDENT);
  }
  /// Space amplification data
  const ::flatbuffers::String *SPACE_AMP() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_AMP);
  }
  /// Space amplification confidence (0-100)
  uint8_t SPACE_AMP_CONF() const {
    return GetField<uint8_t>(VT_SPACE_AMP_CONF, 0);
  }
  /// Object activity
  const ::flatbuffers::String *OBJ_ACT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJ_ACT);
  }
  /// Space specific type
  const ::flatbuffers::String *SPACE_SPEC_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPACE_SPEC_TYPE);
  }
  /// Aircraft sub-type (if applicable)
  const ::flatbuffers::String *ACFT_SUB_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACFT_SUB_TYPE);
  }
  /// Object name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Call sign
  const ::flatbuffers::String *CALL_SIGN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALL_SIGN);
  }
  /// True if track is lost
  bool LOST_TRK_IND() const {
    return GetField<uint8_t>(VT_LOST_TRK_IND, 0) != 0;
  }
  /// Track identifier
  const ::flatbuffers::String *TRACK_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACK_ID);
  }
  /// Parent track identifier
  const ::flatbuffers::String *PARENT_TRACK_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARENT_TRACK_ID);
  }
  /// Multi-unit identifier (source track)
  const ::flatbuffers::String *MUID_SRC_TRK() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUID_SRC_TRK);
  }
  /// Multi-unit identifier (source)
  const ::flatbuffers::String *MUID_SRC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MUID_SRC);
  }
  /// Alert classification
  const ::flatbuffers::String *ALERT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALERT);
  }
  /// Missile engagement status
  missileStatus MSL_STATUS() const {
    return static_cast<missileStatus>(GetField<int8_t>(VT_MSL_STATUS, 0));
  }
  /// Track timestamp (ISO 8601)
  const ::flatbuffers::String *TS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// AOU report type
  aouReportType AOU_RPT_TYPE() const {
    return static_cast<aouReportType>(GetField<int8_t>(VT_AOU_RPT_TYPE, 0));
  }
  /// Containment probability (0-1)
  double CONTAINMENT() const {
    return GetField<double>(VT_CONTAINMENT, 0.0);
  }
  /// Track confidence (0-1)
  double TRK_CONF() const {
    return GetField<double>(VT_TRK_CONF, 0.0);
  }
  /// Track quality (0-15)
  uint8_t TRK_QUAL() const {
    return GetField<uint8_t>(VT_TRK_QUAL, 0);
  }
  /// Elevation angle (degrees)
  double ANG_ELEV() const {
    return GetField<double>(VT_ANG_ELEV, 0.0);
  }
  /// Sensor mode
  const ::flatbuffers::String *SEN_MODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEN_MODE);
  }
  /// Information source
  const ::flatbuffers::String *INFO_SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INFO_SOURCE);
  }
  /// True if object is in boost phase
  bool BOOSTING() const {
    return GetField<uint8_t>(VT_BOOSTING, 0) != 0;
  }
  /// Polar singularity latitude (degrees)
  double POLAR_SING_LOC_LAT() const {
    return GetField<double>(VT_POLAR_SING_LOC_LAT, 0.0);
  }
  /// Polar singularity longitude (degrees)
  double POLAR_SING_LOC_LON() const {
    return GetField<double>(VT_POLAR_SING_LOC_LON, 0.0);
  }
  /// True if emergency indicator set
  bool EMG_IND() const {
    return GetField<uint8_t>(VT_EMG_IND, 0) != 0;
  }
  /// True if drop point indicator set
  bool DROP_PT_IND() const {
    return GetField<uint8_t>(VT_DROP_PT_IND, 0) != 0;
  }
  /// Launch time (ISO 8601)
  const ::flatbuffers::String *LAUNCH_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_TIME);
  }
  /// Launch latitude (degrees)
  double LAUNCH_LAT() const {
    return GetField<double>(VT_LAUNCH_LAT, 0.0);
  }
  /// Launch longitude (degrees)
  double LAUNCH_LON() const {
    return GetField<double>(VT_LAUNCH_LON, 0.0);
  }
  /// Azimuth correction (degrees)
  double AZ_CORR() const {
    return GetField<double>(VT_AZ_CORR, 0.0);
  }
  /// Burnout altitude (km)
  double BURNOUT_ALT() const {
    return GetField<double>(VT_BURNOUT_ALT, 0.0);
  }
  /// Launch AOU type
  aouReportType LAUNCH_AOU_TYPE() const {
    return static_cast<aouReportType>(GetField<int8_t>(VT_LAUNCH_AOU_TYPE, 0));
  }
  /// Predicted impact time (ISO 8601)
  const ::flatbuffers::String *IMPACT_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACT_TIME);
  }
  /// Predicted impact latitude (degrees)
  double IMPACT_LAT() const {
    return GetField<double>(VT_IMPACT_LAT, 0.0);
  }
  /// Predicted impact longitude (degrees)
  double IMPACT_LON() const {
    return GetField<double>(VT_IMPACT_LON, 0.0);
  }
  /// Impact AOU type
  aouReportType IMPACT_AOU_TYPE() const {
    return static_cast<aouReportType>(GetField<int8_t>(VT_IMPACT_AOU_TYPE, 0));
  }
  /// Start time for vector data (ISO 8601)
  const ::flatbuffers::String *VECTOR_START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VECTOR_START_TIME);
  }
  /// Time interval between vector points (seconds)
  double VECTOR_STEP_SIZE() const {
    return GetField<double>(VT_VECTOR_STEP_SIZE, 0.0);
  }
  /// Number of components per vector (default 6: X, Y, Z, VX, VY, VZ)
  uint8_t VECTOR_COMPONENTS() const {
    return GetField<uint8_t>(VT_VECTOR_COMPONENTS, 6);
  }
  /// Vector data as flat array [X0, Y0, Z0, VX0, VY0, VZ0, X1, ...]
  const ::flatbuffers::Vector<double> *VECTORS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_VECTORS);
  }
  /// AOU report data as flat array
  const ::flatbuffers::Vector<double> *AOU_RPT() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_AOU_RPT);
  }
  /// Launch AOU data as flat array
  const ::flatbuffers::Vector<double> *LAUNCH_AOU() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_LAUNCH_AOU);
  }
  /// Impact AOU data as flat array
  const ::flatbuffers::Vector<double> *IMPACT_AOU() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_IMPACT_AOU);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_MSG_TYPE) &&
           verifier.VerifyString(MSG_TYPE()) &&
           VerifyOffset(verifier, VT_MSG_SUB_TYPE) &&
           verifier.VerifyString(MSG_SUB_TYPE()) &&
           VerifyOffset(verifier, VT_MSG_CREATE_DATE) &&
           verifier.VerifyString(MSG_CREATE_DATE()) &&
           VerifyField<int8_t>(verifier, VT_ENVIRONMENT, 1) &&
           VerifyOffset(verifier, VT_OBJ_TYPE) &&
           verifier.VerifyString(OBJ_TYPE()) &&
           VerifyField<uint8_t>(verifier, VT_OBJ_TYPE_CONF, 1) &&
           VerifyOffset(verifier, VT_OBJ_PLAT) &&
           verifier.VerifyString(OBJ_PLAT()) &&
           VerifyOffset(verifier, VT_OBJ_IDENT) &&
           verifier.VerifyString(OBJ_IDENT()) &&
           VerifyOffset(verifier, VT_SPACE_AMP) &&
           verifier.VerifyString(SPACE_AMP()) &&
           VerifyField<uint8_t>(verifier, VT_SPACE_AMP_CONF, 1) &&
           VerifyOffset(verifier, VT_OBJ_ACT) &&
           verifier.VerifyString(OBJ_ACT()) &&
           VerifyOffset(verifier, VT_SPACE_SPEC_TYPE) &&
           verifier.VerifyString(SPACE_SPEC_TYPE()) &&
           VerifyOffset(verifier, VT_ACFT_SUB_TYPE) &&
           verifier.VerifyString(ACFT_SUB_TYPE()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_CALL_SIGN) &&
           verifier.VerifyString(CALL_SIGN()) &&
           VerifyField<uint8_t>(verifier, VT_LOST_TRK_IND, 1) &&
           VerifyOffset(verifier, VT_TRACK_ID) &&
           verifier.VerifyString(TRACK_ID()) &&
           VerifyOffset(verifier, VT_PARENT_TRACK_ID) &&
           verifier.VerifyString(PARENT_TRACK_ID()) &&
           VerifyOffset(verifier, VT_MUID_SRC_TRK) &&
           verifier.VerifyString(MUID_SRC_TRK()) &&
           VerifyOffset(verifier, VT_MUID_SRC) &&
           verifier.VerifyString(MUID_SRC()) &&
           VerifyOffset(verifier, VT_ALERT) &&
           verifier.VerifyString(ALERT()) &&
           VerifyField<int8_t>(verifier, VT_MSL_STATUS, 1) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(TS()) &&
           VerifyField<int8_t>(verifier, VT_AOU_RPT_TYPE, 1) &&
           VerifyField<double>(verifier, VT_CONTAINMENT, 8) &&
           VerifyField<double>(verifier, VT_TRK_CONF, 8) &&
           VerifyField<uint8_t>(verifier, VT_TRK_QUAL, 1) &&
           VerifyField<double>(verifier, VT_ANG_ELEV, 8) &&
           VerifyOffset(verifier, VT_SEN_MODE) &&
           verifier.VerifyString(SEN_MODE()) &&
           VerifyOffset(verifier, VT_INFO_SOURCE) &&
           verifier.VerifyString(INFO_SOURCE()) &&
           VerifyField<uint8_t>(verifier, VT_BOOSTING, 1) &&
           VerifyField<double>(verifier, VT_POLAR_SING_LOC_LAT, 8) &&
           VerifyField<double>(verifier, VT_POLAR_SING_LOC_LON, 8) &&
           VerifyField<uint8_t>(verifier, VT_EMG_IND, 1) &&
           VerifyField<uint8_t>(verifier, VT_DROP_PT_IND, 1) &&
           VerifyOffset(verifier, VT_LAUNCH_TIME) &&
           verifier.VerifyString(LAUNCH_TIME()) &&
           VerifyField<double>(verifier, VT_LAUNCH_LAT, 8) &&
           VerifyField<double>(verifier, VT_LAUNCH_LON, 8) &&
           VerifyField<double>(verifier, VT_AZ_CORR, 8) &&
           VerifyField<double>(verifier, VT_BURNOUT_ALT, 8) &&
           VerifyField<int8_t>(verifier, VT_LAUNCH_AOU_TYPE, 1) &&
           VerifyOffset(verifier, VT_IMPACT_TIME) &&
           verifier.VerifyString(IMPACT_TIME()) &&
           VerifyField<double>(verifier, VT_IMPACT_LAT, 8) &&
           VerifyField<double>(verifier, VT_IMPACT_LON, 8) &&
           VerifyField<int8_t>(verifier, VT_IMPACT_AOU_TYPE, 1) &&
           VerifyOffset(verifier, VT_VECTOR_START_TIME) &&
           verifier.VerifyString(VECTOR_START_TIME()) &&
           VerifyField<double>(verifier, VT_VECTOR_STEP_SIZE, 8) &&
           VerifyField<uint8_t>(verifier, VT_VECTOR_COMPONENTS, 1) &&
           VerifyOffset(verifier, VT_VECTORS) &&
           verifier.VerifyVector(VECTORS()) &&
           VerifyOffset(verifier, VT_AOU_RPT) &&
           verifier.VerifyVector(AOU_RPT()) &&
           VerifyOffset(verifier, VT_LAUNCH_AOU) &&
           verifier.VerifyVector(LAUNCH_AOU()) &&
           VerifyOffset(verifier, VT_IMPACT_AOU) &&
           verifier.VerifyVector(IMPACT_AOU()) &&
           verifier.EndTable();
  }
};

struct MSTBuilder {
  typedef MST Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(MST::VT_ID, ID);
  }
  void add_MSG_TYPE(::flatbuffers::Offset<::flatbuffers::String> MSG_TYPE) {
    fbb_.AddOffset(MST::VT_MSG_TYPE, MSG_TYPE);
  }
  void add_MSG_SUB_TYPE(::flatbuffers::Offset<::flatbuffers::String> MSG_SUB_TYPE) {
    fbb_.AddOffset(MST::VT_MSG_SUB_TYPE, MSG_SUB_TYPE);
  }
  void add_MSG_CREATE_DATE(::flatbuffers::Offset<::flatbuffers::String> MSG_CREATE_DATE) {
    fbb_.AddOffset(MST::VT_MSG_CREATE_DATE, MSG_CREATE_DATE);
  }
  void add_ENVIRONMENT(missileEnvironment ENVIRONMENT) {
    fbb_.AddElement<int8_t>(MST::VT_ENVIRONMENT, static_cast<int8_t>(ENVIRONMENT), 0);
  }
  void add_OBJ_TYPE(::flatbuffers::Offset<::flatbuffers::String> OBJ_TYPE) {
    fbb_.AddOffset(MST::VT_OBJ_TYPE, OBJ_TYPE);
  }
  void add_OBJ_TYPE_CONF(uint8_t OBJ_TYPE_CONF) {
    fbb_.AddElement<uint8_t>(MST::VT_OBJ_TYPE_CONF, OBJ_TYPE_CONF, 0);
  }
  void add_OBJ_PLAT(::flatbuffers::Offset<::flatbuffers::String> OBJ_PLAT) {
    fbb_.AddOffset(MST::VT_OBJ_PLAT, OBJ_PLAT);
  }
  void add_OBJ_IDENT(::flatbuffers::Offset<::flatbuffers::String> OBJ_IDENT) {
    fbb_.AddOffset(MST::VT_OBJ_IDENT, OBJ_IDENT);
  }
  void add_SPACE_AMP(::flatbuffers::Offset<::flatbuffers::String> SPACE_AMP) {
    fbb_.AddOffset(MST::VT_SPACE_AMP, SPACE_AMP);
  }
  void add_SPACE_AMP_CONF(uint8_t SPACE_AMP_CONF) {
    fbb_.AddElement<uint8_t>(MST::VT_SPACE_AMP_CONF, SPACE_AMP_CONF, 0);
  }
  void add_OBJ_ACT(::flatbuffers::Offset<::flatbuffers::String> OBJ_ACT) {
    fbb_.AddOffset(MST::VT_OBJ_ACT, OBJ_ACT);
  }
  void add_SPACE_SPEC_TYPE(::flatbuffers::Offset<::flatbuffers::String> SPACE_SPEC_TYPE) {
    fbb_.AddOffset(MST::VT_SPACE_SPEC_TYPE, SPACE_SPEC_TYPE);
  }
  void add_ACFT_SUB_TYPE(::flatbuffers::Offset<::flatbuffers::String> ACFT_SUB_TYPE) {
    fbb_.AddOffset(MST::VT_ACFT_SUB_TYPE, ACFT_SUB_TYPE);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(MST::VT_NAME, NAME);
  }
  void add_CALL_SIGN(::flatbuffers::Offset<::flatbuffers::String> CALL_SIGN) {
    fbb_.AddOffset(MST::VT_CALL_SIGN, CALL_SIGN);
  }
  void add_LOST_TRK_IND(bool LOST_TRK_IND) {
    fbb_.AddElement<uint8_t>(MST::VT_LOST_TRK_IND, static_cast<uint8_t>(LOST_TRK_IND), 0);
  }
  void add_TRACK_ID(::flatbuffers::Offset<::flatbuffers::String> TRACK_ID) {
    fbb_.AddOffset(MST::VT_TRACK_ID, TRACK_ID);
  }
  void add_PARENT_TRACK_ID(::flatbuffers::Offset<::flatbuffers::String> PARENT_TRACK_ID) {
    fbb_.AddOffset(MST::VT_PARENT_TRACK_ID, PARENT_TRACK_ID);
  }
  void add_MUID_SRC_TRK(::flatbuffers::Offset<::flatbuffers::String> MUID_SRC_TRK) {
    fbb_.AddOffset(MST::VT_MUID_SRC_TRK, MUID_SRC_TRK);
  }
  void add_MUID_SRC(::flatbuffers::Offset<::flatbuffers::String> MUID_SRC) {
    fbb_.AddOffset(MST::VT_MUID_SRC, MUID_SRC);
  }
  void add_ALERT(::flatbuffers::Offset<::flatbuffers::String> ALERT) {
    fbb_.AddOffset(MST::VT_ALERT, ALERT);
  }
  void add_MSL_STATUS(missileStatus MSL_STATUS) {
    fbb_.AddElement<int8_t>(MST::VT_MSL_STATUS, static_cast<int8_t>(MSL_STATUS), 0);
  }
  void add_TS(::flatbuffers::Offset<::flatbuffers::String> TS) {
    fbb_.AddOffset(MST::VT_TS, TS);
  }
  void add_AOU_RPT_TYPE(aouReportType AOU_RPT_TYPE) {
    fbb_.AddElement<int8_t>(MST::VT_AOU_RPT_TYPE, static_cast<int8_t>(AOU_RPT_TYPE), 0);
  }
  void add_CONTAINMENT(double CONTAINMENT) {
    fbb_.AddElement<double>(MST::VT_CONTAINMENT, CONTAINMENT, 0.0);
  }
  void add_TRK_CONF(double TRK_CONF) {
    fbb_.AddElement<double>(MST::VT_TRK_CONF, TRK_CONF, 0.0);
  }
  void add_TRK_QUAL(uint8_t TRK_QUAL) {
    fbb_.AddElement<uint8_t>(MST::VT_TRK_QUAL, TRK_QUAL, 0);
  }
  void add_ANG_ELEV(double ANG_ELEV) {
    fbb_.AddElement<double>(MST::VT_ANG_ELEV, ANG_ELEV, 0.0);
  }
  void add_SEN_MODE(::flatbuffers::Offset<::flatbuffers::String> SEN_MODE) {
    fbb_.AddOffset(MST::VT_SEN_MODE, SEN_MODE);
  }
  void add_INFO_SOURCE(::flatbuffers::Offset<::flatbuffers::String> INFO_SOURCE) {
    fbb_.AddOffset(MST::VT_INFO_SOURCE, INFO_SOURCE);
  }
  void add_BOOSTING(bool BOOSTING) {
    fbb_.AddElement<uint8_t>(MST::VT_BOOSTING, static_cast<uint8_t>(BOOSTING), 0);
  }
  void add_POLAR_SING_LOC_LAT(double POLAR_SING_LOC_LAT) {
    fbb_.AddElement<double>(MST::VT_POLAR_SING_LOC_LAT, POLAR_SING_LOC_LAT, 0.0);
  }
  void add_POLAR_SING_LOC_LON(double POLAR_SING_LOC_LON) {
    fbb_.AddElement<double>(MST::VT_POLAR_SING_LOC_LON, POLAR_SING_LOC_LON, 0.0);
  }
  void add_EMG_IND(bool EMG_IND) {
    fbb_.AddElement<uint8_t>(MST::VT_EMG_IND, static_cast<uint8_t>(EMG_IND), 0);
  }
  void add_DROP_PT_IND(bool DROP_PT_IND) {
    fbb_.AddElement<uint8_t>(MST::VT_DROP_PT_IND, static_cast<uint8_t>(DROP_PT_IND), 0);
  }
  void add_LAUNCH_TIME(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_TIME) {
    fbb_.AddOffset(MST::VT_LAUNCH_TIME, LAUNCH_TIME);
  }
  void add_LAUNCH_LAT(double LAUNCH_LAT) {
    fbb_.AddElement<double>(MST::VT_LAUNCH_LAT, LAUNCH_LAT, 0.0);
  }
  void add_LAUNCH_LON(double LAUNCH_LON) {
    fbb_.AddElement<double>(MST::VT_LAUNCH_LON, LAUNCH_LON, 0.0);
  }
  void add_AZ_CORR(double AZ_CORR) {
    fbb_.AddElement<double>(MST::VT_AZ_CORR, AZ_CORR, 0.0);
  }
  void add_BURNOUT_ALT(double BURNOUT_ALT) {
    fbb_.AddElement<double>(MST::VT_BURNOUT_ALT, BURNOUT_ALT, 0.0);
  }
  void add_LAUNCH_AOU_TYPE(aouReportType LAUNCH_AOU_TYPE) {
    fbb_.AddElement<int8_t>(MST::VT_LAUNCH_AOU_TYPE, static_cast<int8_t>(LAUNCH_AOU_TYPE), 0);
  }
  void add_IMPACT_TIME(::flatbuffers::Offset<::flatbuffers::String> IMPACT_TIME) {
    fbb_.AddOffset(MST::VT_IMPACT_TIME, IMPACT_TIME);
  }
  void add_IMPACT_LAT(double IMPACT_LAT) {
    fbb_.AddElement<double>(MST::VT_IMPACT_LAT, IMPACT_LAT, 0.0);
  }
  void add_IMPACT_LON(double IMPACT_LON) {
    fbb_.AddElement<double>(MST::VT_IMPACT_LON, IMPACT_LON, 0.0);
  }
  void add_IMPACT_AOU_TYPE(aouReportType IMPACT_AOU_TYPE) {
    fbb_.AddElement<int8_t>(MST::VT_IMPACT_AOU_TYPE, static_cast<int8_t>(IMPACT_AOU_TYPE), 0);
  }
  void add_VECTOR_START_TIME(::flatbuffers::Offset<::flatbuffers::String> VECTOR_START_TIME) {
    fbb_.AddOffset(MST::VT_VECTOR_START_TIME, VECTOR_START_TIME);
  }
  void add_VECTOR_STEP_SIZE(double VECTOR_STEP_SIZE) {
    fbb_.AddElement<double>(MST::VT_VECTOR_STEP_SIZE, VECTOR_STEP_SIZE, 0.0);
  }
  void add_VECTOR_COMPONENTS(uint8_t VECTOR_COMPONENTS) {
    fbb_.AddElement<uint8_t>(MST::VT_VECTOR_COMPONENTS, VECTOR_COMPONENTS, 6);
  }
  void add_VECTORS(::flatbuffers::Offset<::flatbuffers::Vector<double>> VECTORS) {
    fbb_.AddOffset(MST::VT_VECTORS, VECTORS);
  }
  void add_AOU_RPT(::flatbuffers::Offset<::flatbuffers::Vector<double>> AOU_RPT) {
    fbb_.AddOffset(MST::VT_AOU_RPT, AOU_RPT);
  }
  void add_LAUNCH_AOU(::flatbuffers::Offset<::flatbuffers::Vector<double>> LAUNCH_AOU) {
    fbb_.AddOffset(MST::VT_LAUNCH_AOU, LAUNCH_AOU);
  }
  void add_IMPACT_AOU(::flatbuffers::Offset<::flatbuffers::Vector<double>> IMPACT_AOU) {
    fbb_.AddOffset(MST::VT_IMPACT_AOU, IMPACT_AOU);
  }
  explicit MSTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MST>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MST> CreateMST(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MSG_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MSG_SUB_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MSG_CREATE_DATE = 0,
    missileEnvironment ENVIRONMENT = missileEnvironment_SPACE,
    ::flatbuffers::Offset<::flatbuffers::String> OBJ_TYPE = 0,
    uint8_t OBJ_TYPE_CONF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJ_PLAT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJ_IDENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SPACE_AMP = 0,
    uint8_t SPACE_AMP_CONF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJ_ACT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SPACE_SPEC_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ACFT_SUB_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CALL_SIGN = 0,
    bool LOST_TRK_IND = false,
    ::flatbuffers::Offset<::flatbuffers::String> TRACK_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PARENT_TRACK_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MUID_SRC_TRK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MUID_SRC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALERT = 0,
    missileStatus MSL_STATUS = missileStatus_BOOSTING,
    ::flatbuffers::Offset<::flatbuffers::String> TS = 0,
    aouReportType AOU_RPT_TYPE = aouReportType_CIRCULAR,
    double CONTAINMENT = 0.0,
    double TRK_CONF = 0.0,
    uint8_t TRK_QUAL = 0,
    double ANG_ELEV = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> SEN_MODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INFO_SOURCE = 0,
    bool BOOSTING = false,
    double POLAR_SING_LOC_LAT = 0.0,
    double POLAR_SING_LOC_LON = 0.0,
    bool EMG_IND = false,
    bool DROP_PT_IND = false,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_TIME = 0,
    double LAUNCH_LAT = 0.0,
    double LAUNCH_LON = 0.0,
    double AZ_CORR = 0.0,
    double BURNOUT_ALT = 0.0,
    aouReportType LAUNCH_AOU_TYPE = aouReportType_CIRCULAR,
    ::flatbuffers::Offset<::flatbuffers::String> IMPACT_TIME = 0,
    double IMPACT_LAT = 0.0,
    double IMPACT_LON = 0.0,
    aouReportType IMPACT_AOU_TYPE = aouReportType_CIRCULAR,
    ::flatbuffers::Offset<::flatbuffers::String> VECTOR_START_TIME = 0,
    double VECTOR_STEP_SIZE = 0.0,
    uint8_t VECTOR_COMPONENTS = 6,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> VECTORS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> AOU_RPT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> LAUNCH_AOU = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> IMPACT_AOU = 0) {
  MSTBuilder builder_(_fbb);
  builder_.add_VECTOR_STEP_SIZE(VECTOR_STEP_SIZE);
  builder_.add_IMPACT_LON(IMPACT_LON);
  builder_.add_IMPACT_LAT(IMPACT_LAT);
  builder_.add_BURNOUT_ALT(BURNOUT_ALT);
  builder_.add_AZ_CORR(AZ_CORR);
  builder_.add_LAUNCH_LON(LAUNCH_LON);
  builder_.add_LAUNCH_LAT(LAUNCH_LAT);
  builder_.add_POLAR_SING_LOC_LON(POLAR_SING_LOC_LON);
  builder_.add_POLAR_SING_LOC_LAT(POLAR_SING_LOC_LAT);
  builder_.add_ANG_ELEV(ANG_ELEV);
  builder_.add_TRK_CONF(TRK_CONF);
  builder_.add_CONTAINMENT(CONTAINMENT);
  builder_.add_IMPACT_AOU(IMPACT_AOU);
  builder_.add_LAUNCH_AOU(LAUNCH_AOU);
  builder_.add_AOU_RPT(AOU_RPT);
  builder_.add_VECTORS(VECTORS);
  builder_.add_VECTOR_START_TIME(VECTOR_START_TIME);
  builder_.add_IMPACT_TIME(IMPACT_TIME);
  builder_.add_LAUNCH_TIME(LAUNCH_TIME);
  builder_.add_INFO_SOURCE(INFO_SOURCE);
  builder_.add_SEN_MODE(SEN_MODE);
  builder_.add_TS(TS);
  builder_.add_ALERT(ALERT);
  builder_.add_MUID_SRC(MUID_SRC);
  builder_.add_MUID_SRC_TRK(MUID_SRC_TRK);
  builder_.add_PARENT_TRACK_ID(PARENT_TRACK_ID);
  builder_.add_TRACK_ID(TRACK_ID);
  builder_.add_CALL_SIGN(CALL_SIGN);
  builder_.add_NAME(NAME);
  builder_.add_ACFT_SUB_TYPE(ACFT_SUB_TYPE);
  builder_.add_SPACE_SPEC_TYPE(SPACE_SPEC_TYPE);
  builder_.add_OBJ_ACT(OBJ_ACT);
  builder_.add_SPACE_AMP(SPACE_AMP);
  builder_.add_OBJ_IDENT(OBJ_IDENT);
  builder_.add_OBJ_PLAT(OBJ_PLAT);
  builder_.add_OBJ_TYPE(OBJ_TYPE);
  builder_.add_MSG_CREATE_DATE(MSG_CREATE_DATE);
  builder_.add_MSG_SUB_TYPE(MSG_SUB_TYPE);
  builder_.add_MSG_TYPE(MSG_TYPE);
  builder_.add_ID(ID);
  builder_.add_VECTOR_COMPONENTS(VECTOR_COMPONENTS);
  builder_.add_IMPACT_AOU_TYPE(IMPACT_AOU_TYPE);
  builder_.add_LAUNCH_AOU_TYPE(LAUNCH_AOU_TYPE);
  builder_.add_DROP_PT_IND(DROP_PT_IND);
  builder_.add_EMG_IND(EMG_IND);
  builder_.add_BOOSTING(BOOSTING);
  builder_.add_TRK_QUAL(TRK_QUAL);
  builder_.add_AOU_RPT_TYPE(AOU_RPT_TYPE);
  builder_.add_MSL_STATUS(MSL_STATUS);
  builder_.add_LOST_TRK_IND(LOST_TRK_IND);
  builder_.add_SPACE_AMP_CONF(SPACE_AMP_CONF);
  builder_.add_OBJ_TYPE_CONF(OBJ_TYPE_CONF);
  builder_.add_ENVIRONMENT(ENVIRONMENT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MST> CreateMSTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *MSG_TYPE = nullptr,
    const char *MSG_SUB_TYPE = nullptr,
    const char *MSG_CREATE_DATE = nullptr,
    missileEnvironment ENVIRONMENT = missileEnvironment_SPACE,
    const char *OBJ_TYPE = nullptr,
    uint8_t OBJ_TYPE_CONF = 0,
    const char *OBJ_PLAT = nullptr,
    const char *OBJ_IDENT = nullptr,
    const char *SPACE_AMP = nullptr,
    uint8_t SPACE_AMP_CONF = 0,
    const char *OBJ_ACT = nullptr,
    const char *SPACE_SPEC_TYPE = nullptr,
    const char *ACFT_SUB_TYPE = nullptr,
    const char *NAME = nullptr,
    const char *CALL_SIGN = nullptr,
    bool LOST_TRK_IND = false,
    const char *TRACK_ID = nullptr,
    const char *PARENT_TRACK_ID = nullptr,
    const char *MUID_SRC_TRK = nullptr,
    const char *MUID_SRC = nullptr,
    const char *ALERT = nullptr,
    missileStatus MSL_STATUS = missileStatus_BOOSTING,
    const char *TS = nullptr,
    aouReportType AOU_RPT_TYPE = aouReportType_CIRCULAR,
    double CONTAINMENT = 0.0,
    double TRK_CONF = 0.0,
    uint8_t TRK_QUAL = 0,
    double ANG_ELEV = 0.0,
    const char *SEN_MODE = nullptr,
    const char *INFO_SOURCE = nullptr,
    bool BOOSTING = false,
    double POLAR_SING_LOC_LAT = 0.0,
    double POLAR_SING_LOC_LON = 0.0,
    bool EMG_IND = false,
    bool DROP_PT_IND = false,
    const char *LAUNCH_TIME = nullptr,
    double LAUNCH_LAT = 0.0,
    double LAUNCH_LON = 0.0,
    double AZ_CORR = 0.0,
    double BURNOUT_ALT = 0.0,
    aouReportType LAUNCH_AOU_TYPE = aouReportType_CIRCULAR,
    const char *IMPACT_TIME = nullptr,
    double IMPACT_LAT = 0.0,
    double IMPACT_LON = 0.0,
    aouReportType IMPACT_AOU_TYPE = aouReportType_CIRCULAR,
    const char *VECTOR_START_TIME = nullptr,
    double VECTOR_STEP_SIZE = 0.0,
    uint8_t VECTOR_COMPONENTS = 6,
    const std::vector<double> *VECTORS = nullptr,
    const std::vector<double> *AOU_RPT = nullptr,
    const std::vector<double> *LAUNCH_AOU = nullptr,
    const std::vector<double> *IMPACT_AOU = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto MSG_TYPE__ = MSG_TYPE ? _fbb.CreateString(MSG_TYPE) : 0;
  auto MSG_SUB_TYPE__ = MSG_SUB_TYPE ? _fbb.CreateString(MSG_SUB_TYPE) : 0;
  auto MSG_CREATE_DATE__ = MSG_CREATE_DATE ? _fbb.CreateString(MSG_CREATE_DATE) : 0;
  auto OBJ_TYPE__ = OBJ_TYPE ? _fbb.CreateString(OBJ_TYPE) : 0;
  auto OBJ_PLAT__ = OBJ_PLAT ? _fbb.CreateString(OBJ_PLAT) : 0;
  auto OBJ_IDENT__ = OBJ_IDENT ? _fbb.CreateString(OBJ_IDENT) : 0;
  auto SPACE_AMP__ = SPACE_AMP ? _fbb.CreateString(SPACE_AMP) : 0;
  auto OBJ_ACT__ = OBJ_ACT ? _fbb.CreateString(OBJ_ACT) : 0;
  auto SPACE_SPEC_TYPE__ = SPACE_SPEC_TYPE ? _fbb.CreateString(SPACE_SPEC_TYPE) : 0;
  auto ACFT_SUB_TYPE__ = ACFT_SUB_TYPE ? _fbb.CreateString(ACFT_SUB_TYPE) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto CALL_SIGN__ = CALL_SIGN ? _fbb.CreateString(CALL_SIGN) : 0;
  auto TRACK_ID__ = TRACK_ID ? _fbb.CreateString(TRACK_ID) : 0;
  auto PARENT_TRACK_ID__ = PARENT_TRACK_ID ? _fbb.CreateString(PARENT_TRACK_ID) : 0;
  auto MUID_SRC_TRK__ = MUID_SRC_TRK ? _fbb.CreateString(MUID_SRC_TRK) : 0;
  auto MUID_SRC__ = MUID_SRC ? _fbb.CreateString(MUID_SRC) : 0;
  auto ALERT__ = ALERT ? _fbb.CreateString(ALERT) : 0;
  auto TS__ = TS ? _fbb.CreateString(TS) : 0;
  auto SEN_MODE__ = SEN_MODE ? _fbb.CreateString(SEN_MODE) : 0;
  auto INFO_SOURCE__ = INFO_SOURCE ? _fbb.CreateString(INFO_SOURCE) : 0;
  auto LAUNCH_TIME__ = LAUNCH_TIME ? _fbb.CreateString(LAUNCH_TIME) : 0;
  auto IMPACT_TIME__ = IMPACT_TIME ? _fbb.CreateString(IMPACT_TIME) : 0;
  auto VECTOR_START_TIME__ = VECTOR_START_TIME ? _fbb.CreateString(VECTOR_START_TIME) : 0;
  auto VECTORS__ = VECTORS ? _fbb.CreateVector<double>(*VECTORS) : 0;
  auto AOU_RPT__ = AOU_RPT ? _fbb.CreateVector<double>(*AOU_RPT) : 0;
  auto LAUNCH_AOU__ = LAUNCH_AOU ? _fbb.CreateVector<double>(*LAUNCH_AOU) : 0;
  auto IMPACT_AOU__ = IMPACT_AOU ? _fbb.CreateVector<double>(*IMPACT_AOU) : 0;
  return CreateMST(
      _fbb,
      ID__,
      MSG_TYPE__,
      MSG_SUB_TYPE__,
      MSG_CREATE_DATE__,
      ENVIRONMENT,
      OBJ_TYPE__,
      OBJ_TYPE_CONF,
      OBJ_PLAT__,
      OBJ_IDENT__,
      SPACE_AMP__,
      SPACE_AMP_CONF,
      OBJ_ACT__,
      SPACE_SPEC_TYPE__,
      ACFT_SUB_TYPE__,
      NAME__,
      CALL_SIGN__,
      LOST_TRK_IND,
      TRACK_ID__,
      PARENT_TRACK_ID__,
      MUID_SRC_TRK__,
      MUID_SRC__,
      ALERT__,
      MSL_STATUS,
      TS__,
      AOU_RPT_TYPE,
      CONTAINMENT,
      TRK_CONF,
      TRK_QUAL,
      ANG_ELEV,
      SEN_MODE__,
      INFO_SOURCE__,
      BOOSTING,
      POLAR_SING_LOC_LAT,
      POLAR_SING_LOC_LON,
      EMG_IND,
      DROP_PT_IND,
      LAUNCH_TIME__,
      LAUNCH_LAT,
      LAUNCH_LON,
      AZ_CORR,
      BURNOUT_ALT,
      LAUNCH_AOU_TYPE,
      IMPACT_TIME__,
      IMPACT_LAT,
      IMPACT_LON,
      IMPACT_AOU_TYPE,
      VECTOR_START_TIME__,
      VECTOR_STEP_SIZE,
      VECTOR_COMPONENTS,
      VECTORS__,
      AOU_RPT__,
      LAUNCH_AOU__,
      IMPACT_AOU__);
}

inline const MST *GetMST(const void *buf) {
  return ::flatbuffers::GetRoot<MST>(buf);
}

inline const MST *GetSizePrefixedMST(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MST>(buf);
}

inline const char *MSTIdentifier() {
  return "$MST";
}

inline bool MSTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MSTIdentifier());
}

inline bool SizePrefixedMSTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MSTIdentifier(), true);
}

inline bool VerifyMSTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MST>(MSTIdentifier());
}

inline bool VerifySizePrefixedMSTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MST>(MSTIdentifier());
}

inline void FinishMSTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MST> root) {
  fbb.Finish(root, MSTIdentifier());
}

inline void FinishSizePrefixedMSTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MST> root) {
  fbb.FinishSizePrefixed(root, MSTIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
