// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OSM;
struct OSMBuilder;

struct OSMCOLLECTION;
struct OSMCOLLECTIONBuilder;

/// Observation Stability Message
struct OSM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OSMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_STABLE = 4,
    VT_NUM_OBS = 6,
    VT_OBJECT_ID = 8,
    VT_ID_SENSOR = 10,
    VT_PASS_START = 12,
    VT_PASS_DURATION = 14
  };
  /// Indicates whether the observation is stable or not
  bool IS_STABLE() const {
    return GetField<uint8_t>(VT_IS_STABLE, 0) != 0;
  }
  /// The number of observations
  int32_t NUM_OBS() const {
    return GetField<int32_t>(VT_NUM_OBS, 0);
  }
  /// Unique identifier for the object being observed
  const ::flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_ID);
  }
  /// Identifier of the sensor
  const ::flatbuffers::String *ID_SENSOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_SENSOR);
  }
  /// Timestamp of data creation
  const ::flatbuffers::String *PASS_START() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASS_START);
  }
  /// Duration of the observation pass in seconds
  int32_t PASS_DURATION() const {
    return GetField<int32_t>(VT_PASS_DURATION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_STABLE, 1) &&
           VerifyField<int32_t>(verifier, VT_NUM_OBS, 4) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyOffset(verifier, VT_ID_SENSOR) &&
           verifier.VerifyString(ID_SENSOR()) &&
           VerifyOffset(verifier, VT_PASS_START) &&
           verifier.VerifyString(PASS_START()) &&
           VerifyField<int32_t>(verifier, VT_PASS_DURATION, 4) &&
           verifier.EndTable();
  }
};

struct OSMBuilder {
  typedef OSM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_IS_STABLE(bool IS_STABLE) {
    fbb_.AddElement<uint8_t>(OSM::VT_IS_STABLE, static_cast<uint8_t>(IS_STABLE), 0);
  }
  void add_NUM_OBS(int32_t NUM_OBS) {
    fbb_.AddElement<int32_t>(OSM::VT_NUM_OBS, NUM_OBS, 0);
  }
  void add_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(OSM::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_ID_SENSOR(::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR) {
    fbb_.AddOffset(OSM::VT_ID_SENSOR, ID_SENSOR);
  }
  void add_PASS_START(::flatbuffers::Offset<::flatbuffers::String> PASS_START) {
    fbb_.AddOffset(OSM::VT_PASS_START, PASS_START);
  }
  void add_PASS_DURATION(int32_t PASS_DURATION) {
    fbb_.AddElement<int32_t>(OSM::VT_PASS_DURATION, PASS_DURATION, 0);
  }
  explicit OSMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OSM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OSM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OSM> CreateOSM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool IS_STABLE = false,
    int32_t NUM_OBS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PASS_START = 0,
    int32_t PASS_DURATION = 0) {
  OSMBuilder builder_(_fbb);
  builder_.add_PASS_DURATION(PASS_DURATION);
  builder_.add_PASS_START(PASS_START);
  builder_.add_ID_SENSOR(ID_SENSOR);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_NUM_OBS(NUM_OBS);
  builder_.add_IS_STABLE(IS_STABLE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OSM> CreateOSMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool IS_STABLE = false,
    int32_t NUM_OBS = 0,
    const char *OBJECT_ID = nullptr,
    const char *ID_SENSOR = nullptr,
    const char *PASS_START = nullptr,
    int32_t PASS_DURATION = 0) {
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto ID_SENSOR__ = ID_SENSOR ? _fbb.CreateString(ID_SENSOR) : 0;
  auto PASS_START__ = PASS_START ? _fbb.CreateString(PASS_START) : 0;
  return CreateOSM(
      _fbb,
      IS_STABLE,
      NUM_OBS,
      OBJECT_ID__,
      ID_SENSOR__,
      PASS_START__,
      PASS_DURATION);
}

struct OSMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OSMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<OSM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OSM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct OSMCOLLECTIONBuilder {
  typedef OSMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OSM>>> RECORDS) {
    fbb_.AddOffset(OSMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit OSMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OSMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OSMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OSMCOLLECTION> CreateOSMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OSM>>> RECORDS = 0) {
  OSMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OSMCOLLECTION> CreateOSMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<OSM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<OSM>>(*RECORDS) : 0;
  return CreateOSMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const OSM *GetOSM(const void *buf) {
  return ::flatbuffers::GetRoot<OSM>(buf);
}

inline const OSM *GetSizePrefixedOSM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OSM>(buf);
}

inline const char *OSMIdentifier() {
  return "$OSM";
}

inline bool OSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OSMIdentifier());
}

inline bool SizePrefixedOSMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OSMIdentifier(), true);
}

inline bool VerifyOSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OSM>(OSMIdentifier());
}

inline bool VerifySizePrefixedOSMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OSM>(OSMIdentifier());
}

inline void FinishOSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OSM> root) {
  fbb.Finish(root, OSMIdentifier());
}

inline void FinishSizePrefixedOSMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OSM> root) {
  fbb.FinishSizePrefixed(root, OSMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
