// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MSL;
struct MSLBuilder;

enum MissileType : int8_t {
  MissileType_AAM_IR = 0,
  MissileType_AAM_SARH = 1,
  MissileType_AAM_ARH = 2,
  MissileType_SAM_IR = 3,
  MissileType_SAM_SARH = 4,
  MissileType_SAM_COMMAND = 5,
  MissileType_ASM_AR = 6,
  MissileType_ASM_TV = 7,
  MissileType_ASM_LASER = 8,
  MissileType_ATGM_SACLOS = 9,
  MissileType_ATGM_BEAM = 10,
  MissileType_ATGM_TOP = 11,
  MissileType_CRUISE = 12,
  MissileType_BALLISTIC = 13,
  MissileType_TORPEDO = 14,
  MissileType_MIN = MissileType_AAM_IR,
  MissileType_MAX = MissileType_TORPEDO
};

inline const MissileType (&EnumValuesMissileType())[15] {
  static const MissileType values[] = {
    MissileType_AAM_IR,
    MissileType_AAM_SARH,
    MissileType_AAM_ARH,
    MissileType_SAM_IR,
    MissileType_SAM_SARH,
    MissileType_SAM_COMMAND,
    MissileType_ASM_AR,
    MissileType_ASM_TV,
    MissileType_ASM_LASER,
    MissileType_ATGM_SACLOS,
    MissileType_ATGM_BEAM,
    MissileType_ATGM_TOP,
    MissileType_CRUISE,
    MissileType_BALLISTIC,
    MissileType_TORPEDO
  };
  return values;
}

inline const char * const *EnumNamesMissileType() {
  static const char * const names[16] = {
    "AAM_IR",
    "AAM_SARH",
    "AAM_ARH",
    "SAM_IR",
    "SAM_SARH",
    "SAM_COMMAND",
    "ASM_AR",
    "ASM_TV",
    "ASM_LASER",
    "ATGM_SACLOS",
    "ATGM_BEAM",
    "ATGM_TOP",
    "CRUISE",
    "BALLISTIC",
    "TORPEDO",
    nullptr
  };
  return names;
}

inline const char *EnumNameMissileType(MissileType e) {
  if (::flatbuffers::IsOutRange(e, MissileType_AAM_IR, MissileType_TORPEDO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMissileType()[index];
}

enum SeekerType : int8_t {
  SeekerType_NONE = 0,
  SeekerType_IR_UNCOOLED = 1,
  SeekerType_IR_COOLED = 2,
  SeekerType_IR_IMAGING = 3,
  SeekerType_IR_2COLOR = 4,
  SeekerType_RADAR_SARH = 5,
  SeekerType_RADAR_ARH = 6,
  SeekerType_RADAR_PASSIVE = 7,
  SeekerType_TV_OPTICAL = 8,
  SeekerType_LASER_SH = 9,
  SeekerType_GPS_INS = 10,
  SeekerType_ACOUSTIC = 11,
  SeekerType_WIRE = 12,
  SeekerType_MIN = SeekerType_NONE,
  SeekerType_MAX = SeekerType_WIRE
};

inline const SeekerType (&EnumValuesSeekerType())[13] {
  static const SeekerType values[] = {
    SeekerType_NONE,
    SeekerType_IR_UNCOOLED,
    SeekerType_IR_COOLED,
    SeekerType_IR_IMAGING,
    SeekerType_IR_2COLOR,
    SeekerType_RADAR_SARH,
    SeekerType_RADAR_ARH,
    SeekerType_RADAR_PASSIVE,
    SeekerType_TV_OPTICAL,
    SeekerType_LASER_SH,
    SeekerType_GPS_INS,
    SeekerType_ACOUSTIC,
    SeekerType_WIRE
  };
  return values;
}

inline const char * const *EnumNamesSeekerType() {
  static const char * const names[14] = {
    "NONE",
    "IR_UNCOOLED",
    "IR_COOLED",
    "IR_IMAGING",
    "IR_2COLOR",
    "RADAR_SARH",
    "RADAR_ARH",
    "RADAR_PASSIVE",
    "TV_OPTICAL",
    "LASER_SH",
    "GPS_INS",
    "ACOUSTIC",
    "WIRE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSeekerType(SeekerType e) {
  if (::flatbuffers::IsOutRange(e, SeekerType_NONE, SeekerType_WIRE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSeekerType()[index];
}

enum GuidanceLaw : int8_t {
  GuidanceLaw_NONE = 0,
  GuidanceLaw_PURE_PURSUIT = 1,
  GuidanceLaw_LEAD_PURSUIT = 2,
  GuidanceLaw_PROPORTIONAL_NAV = 3,
  GuidanceLaw_AUGMENTED_PN = 4,
  GuidanceLaw_OPTIMAL_GUIDANCE = 5,
  GuidanceLaw_COMMAND_LOS = 6,
  GuidanceLaw_BEAM_RIDING = 7,
  GuidanceLaw_TVM = 8,
  GuidanceLaw_LOFT = 9,
  GuidanceLaw_TERRAIN_FOLLOW = 10,
  GuidanceLaw_MIN = GuidanceLaw_NONE,
  GuidanceLaw_MAX = GuidanceLaw_TERRAIN_FOLLOW
};

inline const GuidanceLaw (&EnumValuesGuidanceLaw())[11] {
  static const GuidanceLaw values[] = {
    GuidanceLaw_NONE,
    GuidanceLaw_PURE_PURSUIT,
    GuidanceLaw_LEAD_PURSUIT,
    GuidanceLaw_PROPORTIONAL_NAV,
    GuidanceLaw_AUGMENTED_PN,
    GuidanceLaw_OPTIMAL_GUIDANCE,
    GuidanceLaw_COMMAND_LOS,
    GuidanceLaw_BEAM_RIDING,
    GuidanceLaw_TVM,
    GuidanceLaw_LOFT,
    GuidanceLaw_TERRAIN_FOLLOW
  };
  return values;
}

inline const char * const *EnumNamesGuidanceLaw() {
  static const char * const names[12] = {
    "NONE",
    "PURE_PURSUIT",
    "LEAD_PURSUIT",
    "PROPORTIONAL_NAV",
    "AUGMENTED_PN",
    "OPTIMAL_GUIDANCE",
    "COMMAND_LOS",
    "BEAM_RIDING",
    "TVM",
    "LOFT",
    "TERRAIN_FOLLOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameGuidanceLaw(GuidanceLaw e) {
  if (::flatbuffers::IsOutRange(e, GuidanceLaw_NONE, GuidanceLaw_TERRAIN_FOLLOW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGuidanceLaw()[index];
}

enum MissilePhase : int8_t {
  MissilePhase_CAPTIVE = 0,
  MissilePhase_LAUNCH = 1,
  MissilePhase_BOOST = 2,
  MissilePhase_SUSTAIN = 3,
  MissilePhase_COAST = 4,
  MissilePhase_TERMINAL = 5,
  MissilePhase_INTERCEPT = 6,
  MissilePhase_MISS = 7,
  MissilePhase_SELF_DESTRUCT = 8,
  MissilePhase_MIN = MissilePhase_CAPTIVE,
  MissilePhase_MAX = MissilePhase_SELF_DESTRUCT
};

inline const MissilePhase (&EnumValuesMissilePhase())[9] {
  static const MissilePhase values[] = {
    MissilePhase_CAPTIVE,
    MissilePhase_LAUNCH,
    MissilePhase_BOOST,
    MissilePhase_SUSTAIN,
    MissilePhase_COAST,
    MissilePhase_TERMINAL,
    MissilePhase_INTERCEPT,
    MissilePhase_MISS,
    MissilePhase_SELF_DESTRUCT
  };
  return values;
}

inline const char * const *EnumNamesMissilePhase() {
  static const char * const names[10] = {
    "CAPTIVE",
    "LAUNCH",
    "BOOST",
    "SUSTAIN",
    "COAST",
    "TERMINAL",
    "INTERCEPT",
    "MISS",
    "SELF_DESTRUCT",
    nullptr
  };
  return names;
}

inline const char *EnumNameMissilePhase(MissilePhase e) {
  if (::flatbuffers::IsOutRange(e, MissilePhase_CAPTIVE, MissilePhase_SELF_DESTRUCT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMissilePhase()[index];
}

enum SeekerStatus : int8_t {
  SeekerStatus_OFF = 0,
  SeekerStatus_CAGED = 1,
  SeekerStatus_UNCAGED = 2,
  SeekerStatus_ACQUIRING = 3,
  SeekerStatus_TRACKING = 4,
  SeekerStatus_MEMORY = 5,
  SeekerStatus_JAMMED = 6,
  SeekerStatus_MIN = SeekerStatus_OFF,
  SeekerStatus_MAX = SeekerStatus_JAMMED
};

inline const SeekerStatus (&EnumValuesSeekerStatus())[7] {
  static const SeekerStatus values[] = {
    SeekerStatus_OFF,
    SeekerStatus_CAGED,
    SeekerStatus_UNCAGED,
    SeekerStatus_ACQUIRING,
    SeekerStatus_TRACKING,
    SeekerStatus_MEMORY,
    SeekerStatus_JAMMED
  };
  return values;
}

inline const char * const *EnumNamesSeekerStatus() {
  static const char * const names[8] = {
    "OFF",
    "CAGED",
    "UNCAGED",
    "ACQUIRING",
    "TRACKING",
    "MEMORY",
    "JAMMED",
    nullptr
  };
  return names;
}

inline const char *EnumNameSeekerStatus(SeekerStatus e) {
  if (::flatbuffers::IsOutRange(e, SeekerStatus_OFF, SeekerStatus_JAMMED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSeekerStatus()[index];
}

/// Guided Missiles
struct MSL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MSLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POSITION_Z = 8,
    VT_VELOCITY_X = 10,
    VT_VELOCITY_Y = 12,
    VT_VELOCITY_Z = 14,
    VT_ATTITUDE_X = 16,
    VT_ATTITUDE_Y = 18,
    VT_ATTITUDE_Z = 20,
    VT_ATTITUDE_W = 22,
    VT_OMEGA_X = 24,
    VT_OMEGA_Y = 26,
    VT_OMEGA_Z = 28,
    VT_MASS = 30,
    VT_MASS_INITIAL = 32,
    VT_TARGET_POSITION_X = 34,
    VT_TARGET_POSITION_Y = 36,
    VT_TARGET_POSITION_Z = 38,
    VT_TARGET_VELOCITY_X = 40,
    VT_TARGET_VELOCITY_Y = 42,
    VT_TARGET_VELOCITY_Z = 44,
    VT_MISS_DISTANCE = 46,
    VT_SEEKER = 48,
    VT_MOTOR = 50,
    VT_GUIDANCE_CMD = 52,
    VT_PHASE = 54,
    VT_GUIDANCE_LAW = 56,
    VT_TYPE = 58,
    VT_ARMED = 60,
    VT_TIME_OF_FLIGHT = 62,
    VT_MAX_G = 64,
    VT_RESERVED = 66
  };
  double POSITION_X() const {
    return GetField<double>(VT_POSITION_X, 0.0);
  }
  double POSITION_Y() const {
    return GetField<double>(VT_POSITION_Y, 0.0);
  }
  double POSITION_Z() const {
    return GetField<double>(VT_POSITION_Z, 0.0);
  }
  double VELOCITY_X() const {
    return GetField<double>(VT_VELOCITY_X, 0.0);
  }
  double VELOCITY_Y() const {
    return GetField<double>(VT_VELOCITY_Y, 0.0);
  }
  double VELOCITY_Z() const {
    return GetField<double>(VT_VELOCITY_Z, 0.0);
  }
  double ATTITUDE_X() const {
    return GetField<double>(VT_ATTITUDE_X, 0.0);
  }
  double ATTITUDE_Y() const {
    return GetField<double>(VT_ATTITUDE_Y, 0.0);
  }
  double ATTITUDE_Z() const {
    return GetField<double>(VT_ATTITUDE_Z, 0.0);
  }
  double ATTITUDE_W() const {
    return GetField<double>(VT_ATTITUDE_W, 0.0);
  }
  double OMEGA_X() const {
    return GetField<double>(VT_OMEGA_X, 0.0);
  }
  double OMEGA_Y() const {
    return GetField<double>(VT_OMEGA_Y, 0.0);
  }
  double OMEGA_Z() const {
    return GetField<double>(VT_OMEGA_Z, 0.0);
  }
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  double MASS_INITIAL() const {
    return GetField<double>(VT_MASS_INITIAL, 0.0);
  }
  double TARGET_POSITION_X() const {
    return GetField<double>(VT_TARGET_POSITION_X, 0.0);
  }
  double TARGET_POSITION_Y() const {
    return GetField<double>(VT_TARGET_POSITION_Y, 0.0);
  }
  double TARGET_POSITION_Z() const {
    return GetField<double>(VT_TARGET_POSITION_Z, 0.0);
  }
  double TARGET_VELOCITY_X() const {
    return GetField<double>(VT_TARGET_VELOCITY_X, 0.0);
  }
  double TARGET_VELOCITY_Y() const {
    return GetField<double>(VT_TARGET_VELOCITY_Y, 0.0);
  }
  double TARGET_VELOCITY_Z() const {
    return GetField<double>(VT_TARGET_VELOCITY_Z, 0.0);
  }
  double MISS_DISTANCE() const {
    return GetField<double>(VT_MISS_DISTANCE, 0.0);
  }
  const ::flatbuffers::String *SEEKER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEEKER);
  }
  const ::flatbuffers::String *MOTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MOTOR);
  }
  const ::flatbuffers::String *GUIDANCE_CMD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUIDANCE_CMD);
  }
  uint8_t PHASE() const {
    return GetField<uint8_t>(VT_PHASE, 0);
  }
  uint8_t GUIDANCE_LAW() const {
    return GetField<uint8_t>(VT_GUIDANCE_LAW, 0);
  }
  uint8_t TYPE() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint8_t ARMED() const {
    return GetField<uint8_t>(VT_ARMED, 0);
  }
  float TIME_OF_FLIGHT() const {
    return GetField<float>(VT_TIME_OF_FLIGHT, 0.0f);
  }
  float MAX_G() const {
    return GetField<float>(VT_MAX_G, 0.0f);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_X, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Y, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_W, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_X, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Y, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Z, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyField<double>(verifier, VT_MASS_INITIAL, 8) &&
           VerifyField<double>(verifier, VT_TARGET_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_TARGET_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_TARGET_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_TARGET_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_TARGET_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_TARGET_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_MISS_DISTANCE, 8) &&
           VerifyOffset(verifier, VT_SEEKER) &&
           verifier.VerifyString(SEEKER()) &&
           VerifyOffset(verifier, VT_MOTOR) &&
           verifier.VerifyString(MOTOR()) &&
           VerifyOffset(verifier, VT_GUIDANCE_CMD) &&
           verifier.VerifyString(GUIDANCE_CMD()) &&
           VerifyField<uint8_t>(verifier, VT_PHASE, 1) &&
           VerifyField<uint8_t>(verifier, VT_GUIDANCE_LAW, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ARMED, 1) &&
           VerifyField<float>(verifier, VT_TIME_OF_FLIGHT, 4) &&
           VerifyField<float>(verifier, VT_MAX_G, 4) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct MSLBuilder {
  typedef MSL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITION_X(double POSITION_X) {
    fbb_.AddElement<double>(MSL::VT_POSITION_X, POSITION_X, 0.0);
  }
  void add_POSITION_Y(double POSITION_Y) {
    fbb_.AddElement<double>(MSL::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  void add_POSITION_Z(double POSITION_Z) {
    fbb_.AddElement<double>(MSL::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  void add_VELOCITY_X(double VELOCITY_X) {
    fbb_.AddElement<double>(MSL::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  void add_VELOCITY_Y(double VELOCITY_Y) {
    fbb_.AddElement<double>(MSL::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  void add_VELOCITY_Z(double VELOCITY_Z) {
    fbb_.AddElement<double>(MSL::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  void add_ATTITUDE_X(double ATTITUDE_X) {
    fbb_.AddElement<double>(MSL::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  void add_ATTITUDE_Y(double ATTITUDE_Y) {
    fbb_.AddElement<double>(MSL::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  void add_ATTITUDE_Z(double ATTITUDE_Z) {
    fbb_.AddElement<double>(MSL::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  void add_ATTITUDE_W(double ATTITUDE_W) {
    fbb_.AddElement<double>(MSL::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  void add_OMEGA_X(double OMEGA_X) {
    fbb_.AddElement<double>(MSL::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  void add_OMEGA_Y(double OMEGA_Y) {
    fbb_.AddElement<double>(MSL::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  void add_OMEGA_Z(double OMEGA_Z) {
    fbb_.AddElement<double>(MSL::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(MSL::VT_MASS, MASS, 0.0);
  }
  void add_MASS_INITIAL(double MASS_INITIAL) {
    fbb_.AddElement<double>(MSL::VT_MASS_INITIAL, MASS_INITIAL, 0.0);
  }
  void add_TARGET_POSITION_X(double TARGET_POSITION_X) {
    fbb_.AddElement<double>(MSL::VT_TARGET_POSITION_X, TARGET_POSITION_X, 0.0);
  }
  void add_TARGET_POSITION_Y(double TARGET_POSITION_Y) {
    fbb_.AddElement<double>(MSL::VT_TARGET_POSITION_Y, TARGET_POSITION_Y, 0.0);
  }
  void add_TARGET_POSITION_Z(double TARGET_POSITION_Z) {
    fbb_.AddElement<double>(MSL::VT_TARGET_POSITION_Z, TARGET_POSITION_Z, 0.0);
  }
  void add_TARGET_VELOCITY_X(double TARGET_VELOCITY_X) {
    fbb_.AddElement<double>(MSL::VT_TARGET_VELOCITY_X, TARGET_VELOCITY_X, 0.0);
  }
  void add_TARGET_VELOCITY_Y(double TARGET_VELOCITY_Y) {
    fbb_.AddElement<double>(MSL::VT_TARGET_VELOCITY_Y, TARGET_VELOCITY_Y, 0.0);
  }
  void add_TARGET_VELOCITY_Z(double TARGET_VELOCITY_Z) {
    fbb_.AddElement<double>(MSL::VT_TARGET_VELOCITY_Z, TARGET_VELOCITY_Z, 0.0);
  }
  void add_MISS_DISTANCE(double MISS_DISTANCE) {
    fbb_.AddElement<double>(MSL::VT_MISS_DISTANCE, MISS_DISTANCE, 0.0);
  }
  void add_SEEKER(::flatbuffers::Offset<::flatbuffers::String> SEEKER) {
    fbb_.AddOffset(MSL::VT_SEEKER, SEEKER);
  }
  void add_MOTOR(::flatbuffers::Offset<::flatbuffers::String> MOTOR) {
    fbb_.AddOffset(MSL::VT_MOTOR, MOTOR);
  }
  void add_GUIDANCE_CMD(::flatbuffers::Offset<::flatbuffers::String> GUIDANCE_CMD) {
    fbb_.AddOffset(MSL::VT_GUIDANCE_CMD, GUIDANCE_CMD);
  }
  void add_PHASE(uint8_t PHASE) {
    fbb_.AddElement<uint8_t>(MSL::VT_PHASE, PHASE, 0);
  }
  void add_GUIDANCE_LAW(uint8_t GUIDANCE_LAW) {
    fbb_.AddElement<uint8_t>(MSL::VT_GUIDANCE_LAW, GUIDANCE_LAW, 0);
  }
  void add_TYPE(uint8_t TYPE) {
    fbb_.AddElement<uint8_t>(MSL::VT_TYPE, TYPE, 0);
  }
  void add_ARMED(uint8_t ARMED) {
    fbb_.AddElement<uint8_t>(MSL::VT_ARMED, ARMED, 0);
  }
  void add_TIME_OF_FLIGHT(float TIME_OF_FLIGHT) {
    fbb_.AddElement<float>(MSL::VT_TIME_OF_FLIGHT, TIME_OF_FLIGHT, 0.0f);
  }
  void add_MAX_G(float MAX_G) {
    fbb_.AddElement<float>(MSL::VT_MAX_G, MAX_G, 0.0f);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(MSL::VT_RESERVED, RESERVED);
  }
  explicit MSLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MSL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MSL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MSL> CreateMSL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    double MASS = 0.0,
    double MASS_INITIAL = 0.0,
    double TARGET_POSITION_X = 0.0,
    double TARGET_POSITION_Y = 0.0,
    double TARGET_POSITION_Z = 0.0,
    double TARGET_VELOCITY_X = 0.0,
    double TARGET_VELOCITY_Y = 0.0,
    double TARGET_VELOCITY_Z = 0.0,
    double MISS_DISTANCE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> SEEKER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MOTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GUIDANCE_CMD = 0,
    uint8_t PHASE = 0,
    uint8_t GUIDANCE_LAW = 0,
    uint8_t TYPE = 0,
    uint8_t ARMED = 0,
    float TIME_OF_FLIGHT = 0.0f,
    float MAX_G = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  MSLBuilder builder_(_fbb);
  builder_.add_MISS_DISTANCE(MISS_DISTANCE);
  builder_.add_TARGET_VELOCITY_Z(TARGET_VELOCITY_Z);
  builder_.add_TARGET_VELOCITY_Y(TARGET_VELOCITY_Y);
  builder_.add_TARGET_VELOCITY_X(TARGET_VELOCITY_X);
  builder_.add_TARGET_POSITION_Z(TARGET_POSITION_Z);
  builder_.add_TARGET_POSITION_Y(TARGET_POSITION_Y);
  builder_.add_TARGET_POSITION_X(TARGET_POSITION_X);
  builder_.add_MASS_INITIAL(MASS_INITIAL);
  builder_.add_MASS(MASS);
  builder_.add_OMEGA_Z(OMEGA_Z);
  builder_.add_OMEGA_Y(OMEGA_Y);
  builder_.add_OMEGA_X(OMEGA_X);
  builder_.add_ATTITUDE_W(ATTITUDE_W);
  builder_.add_ATTITUDE_Z(ATTITUDE_Z);
  builder_.add_ATTITUDE_Y(ATTITUDE_Y);
  builder_.add_ATTITUDE_X(ATTITUDE_X);
  builder_.add_VELOCITY_Z(VELOCITY_Z);
  builder_.add_VELOCITY_Y(VELOCITY_Y);
  builder_.add_VELOCITY_X(VELOCITY_X);
  builder_.add_POSITION_Z(POSITION_Z);
  builder_.add_POSITION_Y(POSITION_Y);
  builder_.add_POSITION_X(POSITION_X);
  builder_.add_RESERVED(RESERVED);
  builder_.add_MAX_G(MAX_G);
  builder_.add_TIME_OF_FLIGHT(TIME_OF_FLIGHT);
  builder_.add_GUIDANCE_CMD(GUIDANCE_CMD);
  builder_.add_MOTOR(MOTOR);
  builder_.add_SEEKER(SEEKER);
  builder_.add_ARMED(ARMED);
  builder_.add_TYPE(TYPE);
  builder_.add_GUIDANCE_LAW(GUIDANCE_LAW);
  builder_.add_PHASE(PHASE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MSL> CreateMSLDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    double MASS = 0.0,
    double MASS_INITIAL = 0.0,
    double TARGET_POSITION_X = 0.0,
    double TARGET_POSITION_Y = 0.0,
    double TARGET_POSITION_Z = 0.0,
    double TARGET_VELOCITY_X = 0.0,
    double TARGET_VELOCITY_Y = 0.0,
    double TARGET_VELOCITY_Z = 0.0,
    double MISS_DISTANCE = 0.0,
    const char *SEEKER = nullptr,
    const char *MOTOR = nullptr,
    const char *GUIDANCE_CMD = nullptr,
    uint8_t PHASE = 0,
    uint8_t GUIDANCE_LAW = 0,
    uint8_t TYPE = 0,
    uint8_t ARMED = 0,
    float TIME_OF_FLIGHT = 0.0f,
    float MAX_G = 0.0f,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto SEEKER__ = SEEKER ? _fbb.CreateString(SEEKER) : 0;
  auto MOTOR__ = MOTOR ? _fbb.CreateString(MOTOR) : 0;
  auto GUIDANCE_CMD__ = GUIDANCE_CMD ? _fbb.CreateString(GUIDANCE_CMD) : 0;
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateMSL(
      _fbb,
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      MASS_INITIAL,
      TARGET_POSITION_X,
      TARGET_POSITION_Y,
      TARGET_POSITION_Z,
      TARGET_VELOCITY_X,
      TARGET_VELOCITY_Y,
      TARGET_VELOCITY_Z,
      MISS_DISTANCE,
      SEEKER__,
      MOTOR__,
      GUIDANCE_CMD__,
      PHASE,
      GUIDANCE_LAW,
      TYPE,
      ARMED,
      TIME_OF_FLIGHT,
      MAX_G,
      RESERVED__);
}

inline const MSL *GetMSL(const void *buf) {
  return ::flatbuffers::GetRoot<MSL>(buf);
}

inline const MSL *GetSizePrefixedMSL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MSL>(buf);
}

inline const char *MSLIdentifier() {
  return "$MSL";
}

inline bool MSLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MSLIdentifier());
}

inline bool SizePrefixedMSLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MSLIdentifier(), true);
}

inline bool VerifyMSLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MSL>(MSLIdentifier());
}

inline bool VerifySizePrefixedMSLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MSL>(MSLIdentifier());
}

inline void FinishMSLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MSL> root) {
  fbb.Finish(root, MSLIdentifier());
}

inline void FinishSizePrefixedMSLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MSL> root) {
  fbb.FinishSizePrefixed(root, MSLIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
