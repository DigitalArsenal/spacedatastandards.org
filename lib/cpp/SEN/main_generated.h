// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct sensorMaintenanceEvent;
struct sensorMaintenanceEventBuilder;

struct sensorPlan;
struct sensorPlanBuilder;

struct sensorStats;
struct sensorStatsBuilder;

struct SEN;
struct SENBuilder;

enum sensorStatus : int8_t {
  sensorStatus_OPERATIONAL = 0,
  sensorStatus_DEGRADED = 1,
  sensorStatus_MAINTENANCE = 2,
  sensorStatus_OFFLINE = 3,
  sensorStatus_CALIBRATING = 4,
  sensorStatus_TESTING = 5,
  sensorStatus_DECOMMISSIONED = 6,
  sensorStatus_MIN = sensorStatus_OPERATIONAL,
  sensorStatus_MAX = sensorStatus_DECOMMISSIONED
};

inline const sensorStatus (&EnumValuessensorStatus())[7] {
  static const sensorStatus values[] = {
    sensorStatus_OPERATIONAL,
    sensorStatus_DEGRADED,
    sensorStatus_MAINTENANCE,
    sensorStatus_OFFLINE,
    sensorStatus_CALIBRATING,
    sensorStatus_TESTING,
    sensorStatus_DECOMMISSIONED
  };
  return values;
}

inline const char * const *EnumNamessensorStatus() {
  static const char * const names[8] = {
    "OPERATIONAL",
    "DEGRADED",
    "MAINTENANCE",
    "OFFLINE",
    "CALIBRATING",
    "TESTING",
    "DECOMMISSIONED",
    nullptr
  };
  return names;
}

inline const char *EnumNamesensorStatus(sensorStatus e) {
  if (::flatbuffers::IsOutRange(e, sensorStatus_OPERATIONAL, sensorStatus_DECOMMISSIONED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamessensorStatus()[index];
}

enum maintenanceType : int8_t {
  maintenanceType_SCHEDULED = 0,
  maintenanceType_UNSCHEDULED = 1,
  maintenanceType_CORRECTIVE = 2,
  maintenanceType_PREVENTIVE = 3,
  maintenanceType_CALIBRATION = 4,
  maintenanceType_UPGRADE = 5,
  maintenanceType_INSPECTION = 6,
  maintenanceType_MIN = maintenanceType_SCHEDULED,
  maintenanceType_MAX = maintenanceType_INSPECTION
};

inline const maintenanceType (&EnumValuesmaintenanceType())[7] {
  static const maintenanceType values[] = {
    maintenanceType_SCHEDULED,
    maintenanceType_UNSCHEDULED,
    maintenanceType_CORRECTIVE,
    maintenanceType_PREVENTIVE,
    maintenanceType_CALIBRATION,
    maintenanceType_UPGRADE,
    maintenanceType_INSPECTION
  };
  return values;
}

inline const char * const *EnumNamesmaintenanceType() {
  static const char * const names[8] = {
    "SCHEDULED",
    "UNSCHEDULED",
    "CORRECTIVE",
    "PREVENTIVE",
    "CALIBRATION",
    "UPGRADE",
    "INSPECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNamemaintenanceType(maintenanceType e) {
  if (::flatbuffers::IsOutRange(e, maintenanceType_SCHEDULED, maintenanceType_INSPECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmaintenanceType()[index];
}

/// Sensor Maintenance Event
struct sensorMaintenanceEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef sensorMaintenanceEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_TIME = 4,
    VT_END_TIME = 6,
    VT_TYPE = 8,
    VT_DESCRIPTION = 10,
    VT_COMPONENTS = 12
  };
  /// Maintenance start time (ISO 8601)
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  /// Maintenance end time (ISO 8601)
  const ::flatbuffers::String *END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_TIME);
  }
  /// Type of maintenance
  maintenanceType TYPE() const {
    return static_cast<maintenanceType>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Description of maintenance performed
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Components affected
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COMPONENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COMPONENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_END_TIME) &&
           verifier.VerifyString(END_TIME()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(COMPONENTS()) &&
           verifier.VerifyVectorOfStrings(COMPONENTS()) &&
           verifier.EndTable();
  }
};

struct sensorMaintenanceEventBuilder {
  typedef sensorMaintenanceEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(sensorMaintenanceEvent::VT_START_TIME, START_TIME);
  }
  void add_END_TIME(::flatbuffers::Offset<::flatbuffers::String> END_TIME) {
    fbb_.AddOffset(sensorMaintenanceEvent::VT_END_TIME, END_TIME);
  }
  void add_TYPE(maintenanceType TYPE) {
    fbb_.AddElement<int8_t>(sensorMaintenanceEvent::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(sensorMaintenanceEvent::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_COMPONENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMPONENTS) {
    fbb_.AddOffset(sensorMaintenanceEvent::VT_COMPONENTS, COMPONENTS);
  }
  explicit sensorMaintenanceEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<sensorMaintenanceEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<sensorMaintenanceEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<sensorMaintenanceEvent> CreatesensorMaintenanceEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> END_TIME = 0,
    maintenanceType TYPE = maintenanceType_SCHEDULED,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COMPONENTS = 0) {
  sensorMaintenanceEventBuilder builder_(_fbb);
  builder_.add_COMPONENTS(COMPONENTS);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_END_TIME(END_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<sensorMaintenanceEvent> CreatesensorMaintenanceEventDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *START_TIME = nullptr,
    const char *END_TIME = nullptr,
    maintenanceType TYPE = maintenanceType_SCHEDULED,
    const char *DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COMPONENTS = nullptr) {
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto END_TIME__ = END_TIME ? _fbb.CreateString(END_TIME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto COMPONENTS__ = COMPONENTS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COMPONENTS) : 0;
  return CreatesensorMaintenanceEvent(
      _fbb,
      START_TIME__,
      END_TIME__,
      TYPE,
      DESCRIPTION__,
      COMPONENTS__);
}

/// Sensor Tasking Plan
struct sensorPlan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef sensorPlanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_TIME = 4,
    VT_END_TIME = 6,
    VT_TARGET_ID = 8,
    VT_PRIORITY = 10,
    VT_MODE = 12,
    VT_MIN_ELEVATION = 14,
    VT_MAX_RANGE = 16
  };
  /// Plan start time (ISO 8601)
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  /// Plan end time (ISO 8601)
  const ::flatbuffers::String *END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_TIME);
  }
  /// Target satellite number or designator
  const ::flatbuffers::String *TARGET_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_ID);
  }
  /// Priority level (1=highest)
  uint8_t PRIORITY() const {
    return GetField<uint8_t>(VT_PRIORITY, 0);
  }
  /// Requested observation mode
  const ::flatbuffers::String *MODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODE);
  }
  /// Minimum elevation in degrees
  double MIN_ELEVATION() const {
    return GetField<double>(VT_MIN_ELEVATION, 0.0);
  }
  /// Maximum range in km
  double MAX_RANGE() const {
    return GetField<double>(VT_MAX_RANGE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_END_TIME) &&
           verifier.VerifyString(END_TIME()) &&
           VerifyOffset(verifier, VT_TARGET_ID) &&
           verifier.VerifyString(TARGET_ID()) &&
           VerifyField<uint8_t>(verifier, VT_PRIORITY, 1) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(MODE()) &&
           VerifyField<double>(verifier, VT_MIN_ELEVATION, 8) &&
           VerifyField<double>(verifier, VT_MAX_RANGE, 8) &&
           verifier.EndTable();
  }
};

struct sensorPlanBuilder {
  typedef sensorPlan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(sensorPlan::VT_START_TIME, START_TIME);
  }
  void add_END_TIME(::flatbuffers::Offset<::flatbuffers::String> END_TIME) {
    fbb_.AddOffset(sensorPlan::VT_END_TIME, END_TIME);
  }
  void add_TARGET_ID(::flatbuffers::Offset<::flatbuffers::String> TARGET_ID) {
    fbb_.AddOffset(sensorPlan::VT_TARGET_ID, TARGET_ID);
  }
  void add_PRIORITY(uint8_t PRIORITY) {
    fbb_.AddElement<uint8_t>(sensorPlan::VT_PRIORITY, PRIORITY, 0);
  }
  void add_MODE(::flatbuffers::Offset<::flatbuffers::String> MODE) {
    fbb_.AddOffset(sensorPlan::VT_MODE, MODE);
  }
  void add_MIN_ELEVATION(double MIN_ELEVATION) {
    fbb_.AddElement<double>(sensorPlan::VT_MIN_ELEVATION, MIN_ELEVATION, 0.0);
  }
  void add_MAX_RANGE(double MAX_RANGE) {
    fbb_.AddElement<double>(sensorPlan::VT_MAX_RANGE, MAX_RANGE, 0.0);
  }
  explicit sensorPlanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<sensorPlan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<sensorPlan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<sensorPlan> CreatesensorPlan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> END_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TARGET_ID = 0,
    uint8_t PRIORITY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MODE = 0,
    double MIN_ELEVATION = 0.0,
    double MAX_RANGE = 0.0) {
  sensorPlanBuilder builder_(_fbb);
  builder_.add_MAX_RANGE(MAX_RANGE);
  builder_.add_MIN_ELEVATION(MIN_ELEVATION);
  builder_.add_MODE(MODE);
  builder_.add_TARGET_ID(TARGET_ID);
  builder_.add_END_TIME(END_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_PRIORITY(PRIORITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<sensorPlan> CreatesensorPlanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *START_TIME = nullptr,
    const char *END_TIME = nullptr,
    const char *TARGET_ID = nullptr,
    uint8_t PRIORITY = 0,
    const char *MODE = nullptr,
    double MIN_ELEVATION = 0.0,
    double MAX_RANGE = 0.0) {
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto END_TIME__ = END_TIME ? _fbb.CreateString(END_TIME) : 0;
  auto TARGET_ID__ = TARGET_ID ? _fbb.CreateString(TARGET_ID) : 0;
  auto MODE__ = MODE ? _fbb.CreateString(MODE) : 0;
  return CreatesensorPlan(
      _fbb,
      START_TIME__,
      END_TIME__,
      TARGET_ID__,
      PRIORITY,
      MODE__,
      MIN_ELEVATION,
      MAX_RANGE);
}

/// Sensor Operational Statistics
struct sensorStats FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef sensorStatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERIOD_START = 4,
    VT_PERIOD_END = 6,
    VT_OBS_ATTEMPTED = 8,
    VT_OBS_SUCCESSFUL = 10,
    VT_OBS_FAILED = 12,
    VT_UPTIME = 14,
    VT_AVG_ACCURACY = 16,
    VT_DETECTIONS = 18,
    VT_UCT_COUNT = 20
  };
  /// Statistics period start (ISO 8601)
  const ::flatbuffers::String *PERIOD_START() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PERIOD_START);
  }
  /// Statistics period end (ISO 8601)
  const ::flatbuffers::String *PERIOD_END() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PERIOD_END);
  }
  /// Total observation attempts
  uint32_t OBS_ATTEMPTED() const {
    return GetField<uint32_t>(VT_OBS_ATTEMPTED, 0);
  }
  /// Successful observations
  uint32_t OBS_SUCCESSFUL() const {
    return GetField<uint32_t>(VT_OBS_SUCCESSFUL, 0);
  }
  /// Failed observations
  uint32_t OBS_FAILED() const {
    return GetField<uint32_t>(VT_OBS_FAILED, 0);
  }
  /// Uptime fraction (0.0-1.0)
  double UPTIME() const {
    return GetField<double>(VT_UPTIME, 0.0);
  }
  /// Average tracking accuracy in arcseconds
  double AVG_ACCURACY() const {
    return GetField<double>(VT_AVG_ACCURACY, 0.0);
  }
  /// Detected objects count
  uint32_t DETECTIONS() const {
    return GetField<uint32_t>(VT_DETECTIONS, 0);
  }
  /// Uncorrelated tracks count
  uint32_t UCT_COUNT() const {
    return GetField<uint32_t>(VT_UCT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERIOD_START) &&
           verifier.VerifyString(PERIOD_START()) &&
           VerifyOffset(verifier, VT_PERIOD_END) &&
           verifier.VerifyString(PERIOD_END()) &&
           VerifyField<uint32_t>(verifier, VT_OBS_ATTEMPTED, 4) &&
           VerifyField<uint32_t>(verifier, VT_OBS_SUCCESSFUL, 4) &&
           VerifyField<uint32_t>(verifier, VT_OBS_FAILED, 4) &&
           VerifyField<double>(verifier, VT_UPTIME, 8) &&
           VerifyField<double>(verifier, VT_AVG_ACCURACY, 8) &&
           VerifyField<uint32_t>(verifier, VT_DETECTIONS, 4) &&
           VerifyField<uint32_t>(verifier, VT_UCT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct sensorStatsBuilder {
  typedef sensorStats Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PERIOD_START(::flatbuffers::Offset<::flatbuffers::String> PERIOD_START) {
    fbb_.AddOffset(sensorStats::VT_PERIOD_START, PERIOD_START);
  }
  void add_PERIOD_END(::flatbuffers::Offset<::flatbuffers::String> PERIOD_END) {
    fbb_.AddOffset(sensorStats::VT_PERIOD_END, PERIOD_END);
  }
  void add_OBS_ATTEMPTED(uint32_t OBS_ATTEMPTED) {
    fbb_.AddElement<uint32_t>(sensorStats::VT_OBS_ATTEMPTED, OBS_ATTEMPTED, 0);
  }
  void add_OBS_SUCCESSFUL(uint32_t OBS_SUCCESSFUL) {
    fbb_.AddElement<uint32_t>(sensorStats::VT_OBS_SUCCESSFUL, OBS_SUCCESSFUL, 0);
  }
  void add_OBS_FAILED(uint32_t OBS_FAILED) {
    fbb_.AddElement<uint32_t>(sensorStats::VT_OBS_FAILED, OBS_FAILED, 0);
  }
  void add_UPTIME(double UPTIME) {
    fbb_.AddElement<double>(sensorStats::VT_UPTIME, UPTIME, 0.0);
  }
  void add_AVG_ACCURACY(double AVG_ACCURACY) {
    fbb_.AddElement<double>(sensorStats::VT_AVG_ACCURACY, AVG_ACCURACY, 0.0);
  }
  void add_DETECTIONS(uint32_t DETECTIONS) {
    fbb_.AddElement<uint32_t>(sensorStats::VT_DETECTIONS, DETECTIONS, 0);
  }
  void add_UCT_COUNT(uint32_t UCT_COUNT) {
    fbb_.AddElement<uint32_t>(sensorStats::VT_UCT_COUNT, UCT_COUNT, 0);
  }
  explicit sensorStatsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<sensorStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<sensorStats>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<sensorStats> CreatesensorStats(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PERIOD_START = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PERIOD_END = 0,
    uint32_t OBS_ATTEMPTED = 0,
    uint32_t OBS_SUCCESSFUL = 0,
    uint32_t OBS_FAILED = 0,
    double UPTIME = 0.0,
    double AVG_ACCURACY = 0.0,
    uint32_t DETECTIONS = 0,
    uint32_t UCT_COUNT = 0) {
  sensorStatsBuilder builder_(_fbb);
  builder_.add_AVG_ACCURACY(AVG_ACCURACY);
  builder_.add_UPTIME(UPTIME);
  builder_.add_UCT_COUNT(UCT_COUNT);
  builder_.add_DETECTIONS(DETECTIONS);
  builder_.add_OBS_FAILED(OBS_FAILED);
  builder_.add_OBS_SUCCESSFUL(OBS_SUCCESSFUL);
  builder_.add_OBS_ATTEMPTED(OBS_ATTEMPTED);
  builder_.add_PERIOD_END(PERIOD_END);
  builder_.add_PERIOD_START(PERIOD_START);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<sensorStats> CreatesensorStatsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PERIOD_START = nullptr,
    const char *PERIOD_END = nullptr,
    uint32_t OBS_ATTEMPTED = 0,
    uint32_t OBS_SUCCESSFUL = 0,
    uint32_t OBS_FAILED = 0,
    double UPTIME = 0.0,
    double AVG_ACCURACY = 0.0,
    uint32_t DETECTIONS = 0,
    uint32_t UCT_COUNT = 0) {
  auto PERIOD_START__ = PERIOD_START ? _fbb.CreateString(PERIOD_START) : 0;
  auto PERIOD_END__ = PERIOD_END ? _fbb.CreateString(PERIOD_END) : 0;
  return CreatesensorStats(
      _fbb,
      PERIOD_START__,
      PERIOD_END__,
      OBS_ATTEMPTED,
      OBS_SUCCESSFUL,
      OBS_FAILED,
      UPTIME,
      AVG_ACCURACY,
      DETECTIONS,
      UCT_COUNT);
}

/// Sensor Management
struct SEN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SENBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_STATUS = 10,
    VT_SITE_ID = 12,
    VT_LATITUDE = 14,
    VT_LONGITUDE = 16,
    VT_ALTITUDE = 18,
    VT_STATUS_TIME = 20,
    VT_MAINTENANCE = 22,
    VT_PLANS = 24,
    VT_STATISTICS = 26,
    VT_NOTES = 28
  };
  /// Unique sensor identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Sensor name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Sensor type
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Current operational status
  sensorStatus STATUS() const {
    return static_cast<sensorStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  /// Site identifier
  const ::flatbuffers::String *SITE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SITE_ID);
  }
  /// Geodetic latitude in degrees
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Geodetic longitude in degrees
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Altitude in meters above WGS-84
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  /// Last status update (ISO 8601)
  const ::flatbuffers::String *STATUS_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS_TIME);
  }
  /// Maintenance history
  const ::flatbuffers::Vector<::flatbuffers::Offset<sensorMaintenanceEvent>> *MAINTENANCE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<sensorMaintenanceEvent>> *>(VT_MAINTENANCE);
  }
  /// Observation plans/taskings
  const ::flatbuffers::Vector<::flatbuffers::Offset<sensorPlan>> *PLANS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<sensorPlan>> *>(VT_PLANS);
  }
  /// Operational statistics
  const ::flatbuffers::Vector<::flatbuffers::Offset<sensorStats>> *STATISTICS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<sensorStats>> *>(VT_STATISTICS);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_SITE_ID) &&
           verifier.VerifyString(SITE_ID()) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyOffset(verifier, VT_STATUS_TIME) &&
           verifier.VerifyString(STATUS_TIME()) &&
           VerifyOffset(verifier, VT_MAINTENANCE) &&
           verifier.VerifyVector(MAINTENANCE()) &&
           verifier.VerifyVectorOfTables(MAINTENANCE()) &&
           VerifyOffset(verifier, VT_PLANS) &&
           verifier.VerifyVector(PLANS()) &&
           verifier.VerifyVectorOfTables(PLANS()) &&
           VerifyOffset(verifier, VT_STATISTICS) &&
           verifier.VerifyVector(STATISTICS()) &&
           verifier.VerifyVectorOfTables(STATISTICS()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct SENBuilder {
  typedef SEN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(SEN::VT_ID, ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(SEN::VT_NAME, NAME);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(SEN::VT_TYPE, TYPE);
  }
  void add_STATUS(sensorStatus STATUS) {
    fbb_.AddElement<int8_t>(SEN::VT_STATUS, static_cast<int8_t>(STATUS), 0);
  }
  void add_SITE_ID(::flatbuffers::Offset<::flatbuffers::String> SITE_ID) {
    fbb_.AddOffset(SEN::VT_SITE_ID, SITE_ID);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(SEN::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(SEN::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(SEN::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  void add_STATUS_TIME(::flatbuffers::Offset<::flatbuffers::String> STATUS_TIME) {
    fbb_.AddOffset(SEN::VT_STATUS_TIME, STATUS_TIME);
  }
  void add_MAINTENANCE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorMaintenanceEvent>>> MAINTENANCE) {
    fbb_.AddOffset(SEN::VT_MAINTENANCE, MAINTENANCE);
  }
  void add_PLANS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorPlan>>> PLANS) {
    fbb_.AddOffset(SEN::VT_PLANS, PLANS);
  }
  void add_STATISTICS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorStats>>> STATISTICS) {
    fbb_.AddOffset(SEN::VT_STATISTICS, STATISTICS);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(SEN::VT_NOTES, NOTES);
  }
  explicit SENBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SEN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SEN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SEN> CreateSEN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    sensorStatus STATUS = sensorStatus_OPERATIONAL,
    ::flatbuffers::Offset<::flatbuffers::String> SITE_ID = 0,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    double ALTITUDE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> STATUS_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorMaintenanceEvent>>> MAINTENANCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorPlan>>> PLANS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<sensorStats>>> STATISTICS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  SENBuilder builder_(_fbb);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_NOTES(NOTES);
  builder_.add_STATISTICS(STATISTICS);
  builder_.add_PLANS(PLANS);
  builder_.add_MAINTENANCE(MAINTENANCE);
  builder_.add_STATUS_TIME(STATUS_TIME);
  builder_.add_SITE_ID(SITE_ID);
  builder_.add_TYPE(TYPE);
  builder_.add_NAME(NAME);
  builder_.add_ID(ID);
  builder_.add_STATUS(STATUS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SEN> CreateSENDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *NAME = nullptr,
    const char *TYPE = nullptr,
    sensorStatus STATUS = sensorStatus_OPERATIONAL,
    const char *SITE_ID = nullptr,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    double ALTITUDE = 0.0,
    const char *STATUS_TIME = nullptr,
    const std::vector<::flatbuffers::Offset<sensorMaintenanceEvent>> *MAINTENANCE = nullptr,
    const std::vector<::flatbuffers::Offset<sensorPlan>> *PLANS = nullptr,
    const std::vector<::flatbuffers::Offset<sensorStats>> *STATISTICS = nullptr,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto SITE_ID__ = SITE_ID ? _fbb.CreateString(SITE_ID) : 0;
  auto STATUS_TIME__ = STATUS_TIME ? _fbb.CreateString(STATUS_TIME) : 0;
  auto MAINTENANCE__ = MAINTENANCE ? _fbb.CreateVector<::flatbuffers::Offset<sensorMaintenanceEvent>>(*MAINTENANCE) : 0;
  auto PLANS__ = PLANS ? _fbb.CreateVector<::flatbuffers::Offset<sensorPlan>>(*PLANS) : 0;
  auto STATISTICS__ = STATISTICS ? _fbb.CreateVector<::flatbuffers::Offset<sensorStats>>(*STATISTICS) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateSEN(
      _fbb,
      ID__,
      NAME__,
      TYPE__,
      STATUS,
      SITE_ID__,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      STATUS_TIME__,
      MAINTENANCE__,
      PLANS__,
      STATISTICS__,
      NOTES__);
}

inline const SEN *GetSEN(const void *buf) {
  return ::flatbuffers::GetRoot<SEN>(buf);
}

inline const SEN *GetSizePrefixedSEN(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SEN>(buf);
}

inline const char *SENIdentifier() {
  return "$SEN";
}

inline bool SENBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SENIdentifier());
}

inline bool SizePrefixedSENBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SENIdentifier(), true);
}

inline bool VerifySENBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SEN>(SENIdentifier());
}

inline bool VerifySizePrefixedSENBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SEN>(SENIdentifier());
}

inline void FinishSENBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SEN> root) {
  fbb.Finish(root, SENIdentifier());
}

inline void FinishSizePrefixedSENBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SEN> root) {
  fbb.FinishSizePrefixed(root, SENIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
