// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ACR;
struct ACRBuilder;

enum AircraftType : int8_t {
  AircraftType_FIGHTER = 0,
  AircraftType_ATTACK = 1,
  AircraftType_BOMBER = 2,
  AircraftType_TRANSPORT = 3,
  AircraftType_TRAINER = 4,
  AircraftType_RECON = 5,
  AircraftType_TANKER = 6,
  AircraftType_AWACS = 7,
  AircraftType_UAV = 8,
  AircraftType_PROP_SINGLE = 9,
  AircraftType_PROP_MULTI = 10,
  AircraftType_SEAPLANE = 11,
  AircraftType_MIN = AircraftType_FIGHTER,
  AircraftType_MAX = AircraftType_SEAPLANE
};

inline const AircraftType (&EnumValuesAircraftType())[12] {
  static const AircraftType values[] = {
    AircraftType_FIGHTER,
    AircraftType_ATTACK,
    AircraftType_BOMBER,
    AircraftType_TRANSPORT,
    AircraftType_TRAINER,
    AircraftType_RECON,
    AircraftType_TANKER,
    AircraftType_AWACS,
    AircraftType_UAV,
    AircraftType_PROP_SINGLE,
    AircraftType_PROP_MULTI,
    AircraftType_SEAPLANE
  };
  return values;
}

inline const char * const *EnumNamesAircraftType() {
  static const char * const names[13] = {
    "FIGHTER",
    "ATTACK",
    "BOMBER",
    "TRANSPORT",
    "TRAINER",
    "RECON",
    "TANKER",
    "AWACS",
    "UAV",
    "PROP_SINGLE",
    "PROP_MULTI",
    "SEAPLANE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAircraftType(AircraftType e) {
  if (::flatbuffers::IsOutRange(e, AircraftType_FIGHTER, AircraftType_SEAPLANE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAircraftType()[index];
}

enum EngineType : int8_t {
  EngineType_TURBOJET = 0,
  EngineType_TURBOFAN_LOW = 1,
  EngineType_TURBOFAN_HIGH = 2,
  EngineType_TURBOPROP = 3,
  EngineType_PISTON = 4,
  EngineType_RAMJET = 5,
  EngineType_SCRAMJET = 6,
  EngineType_ELECTRIC = 7,
  EngineType_MIN = EngineType_TURBOJET,
  EngineType_MAX = EngineType_ELECTRIC
};

inline const EngineType (&EnumValuesEngineType())[8] {
  static const EngineType values[] = {
    EngineType_TURBOJET,
    EngineType_TURBOFAN_LOW,
    EngineType_TURBOFAN_HIGH,
    EngineType_TURBOPROP,
    EngineType_PISTON,
    EngineType_RAMJET,
    EngineType_SCRAMJET,
    EngineType_ELECTRIC
  };
  return values;
}

inline const char * const *EnumNamesEngineType() {
  static const char * const names[9] = {
    "TURBOJET",
    "TURBOFAN_LOW",
    "TURBOFAN_HIGH",
    "TURBOPROP",
    "PISTON",
    "RAMJET",
    "SCRAMJET",
    "ELECTRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameEngineType(EngineType e) {
  if (::flatbuffers::IsOutRange(e, EngineType_TURBOJET, EngineType_ELECTRIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEngineType()[index];
}

enum FlightPhase : int8_t {
  FlightPhase_PARKED = 0,
  FlightPhase_TAXI = 1,
  FlightPhase_TAKEOFF = 2,
  FlightPhase_CLIMB = 3,
  FlightPhase_CRUISE = 4,
  FlightPhase_DESCENT = 5,
  FlightPhase_APPROACH = 6,
  FlightPhase_LANDING = 7,
  FlightPhase_GO_AROUND = 8,
  FlightPhase_EMERGENCY = 9,
  FlightPhase_MIN = FlightPhase_PARKED,
  FlightPhase_MAX = FlightPhase_EMERGENCY
};

inline const FlightPhase (&EnumValuesFlightPhase())[10] {
  static const FlightPhase values[] = {
    FlightPhase_PARKED,
    FlightPhase_TAXI,
    FlightPhase_TAKEOFF,
    FlightPhase_CLIMB,
    FlightPhase_CRUISE,
    FlightPhase_DESCENT,
    FlightPhase_APPROACH,
    FlightPhase_LANDING,
    FlightPhase_GO_AROUND,
    FlightPhase_EMERGENCY
  };
  return values;
}

inline const char * const *EnumNamesFlightPhase() {
  static const char * const names[11] = {
    "PARKED",
    "TAXI",
    "TAKEOFF",
    "CLIMB",
    "CRUISE",
    "DESCENT",
    "APPROACH",
    "LANDING",
    "GO_AROUND",
    "EMERGENCY",
    nullptr
  };
  return names;
}

inline const char *EnumNameFlightPhase(FlightPhase e) {
  if (::flatbuffers::IsOutRange(e, FlightPhase_PARKED, FlightPhase_EMERGENCY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlightPhase()[index];
}

enum GearState : int8_t {
  GearState_UP = 0,
  GearState_TRANSIT_DOWN = 1,
  GearState_DOWN = 2,
  GearState_TRANSIT_UP = 3,
  GearState_DAMAGED = 4,
  GearState_MIN = GearState_UP,
  GearState_MAX = GearState_DAMAGED
};

inline const GearState (&EnumValuesGearState())[5] {
  static const GearState values[] = {
    GearState_UP,
    GearState_TRANSIT_DOWN,
    GearState_DOWN,
    GearState_TRANSIT_UP,
    GearState_DAMAGED
  };
  return values;
}

inline const char * const *EnumNamesGearState() {
  static const char * const names[6] = {
    "UP",
    "TRANSIT_DOWN",
    "DOWN",
    "TRANSIT_UP",
    "DAMAGED",
    nullptr
  };
  return names;
}

inline const char *EnumNameGearState(GearState e) {
  if (::flatbuffers::IsOutRange(e, GearState_UP, GearState_DAMAGED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGearState()[index];
}

/// Aircraft Dynamics
struct ACR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ACRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POSITION_Z = 8,
    VT_VELOCITY_X = 10,
    VT_VELOCITY_Y = 12,
    VT_VELOCITY_Z = 14,
    VT_ATTITUDE_X = 16,
    VT_ATTITUDE_Y = 18,
    VT_ATTITUDE_Z = 20,
    VT_ATTITUDE_W = 22,
    VT_OMEGA_X = 24,
    VT_OMEGA_Y = 26,
    VT_OMEGA_Z = 28,
    VT_MASS = 30,
    VT_CG_X = 32,
    VT_CG_Z = 34,
    VT_AERO = 36,
    VT_CONTROLS = 38,
    VT_ENGINE = 40,
    VT_GEAR_STATE = 42,
    VT_GEAR_POSITION = 44,
    VT_FLAP_POSITION = 46,
    VT_SPEEDBRAKE_POS = 48,
    VT_FLIGHT_PHASE = 50,
    VT_AUTOPILOT_MODE = 52,
    VT_WEIGHT_ON_WHEELS = 54,
    VT_RESERVED = 56
  };
  double POSITION_X() const {
    return GetField<double>(VT_POSITION_X, 0.0);
  }
  double POSITION_Y() const {
    return GetField<double>(VT_POSITION_Y, 0.0);
  }
  double POSITION_Z() const {
    return GetField<double>(VT_POSITION_Z, 0.0);
  }
  double VELOCITY_X() const {
    return GetField<double>(VT_VELOCITY_X, 0.0);
  }
  double VELOCITY_Y() const {
    return GetField<double>(VT_VELOCITY_Y, 0.0);
  }
  double VELOCITY_Z() const {
    return GetField<double>(VT_VELOCITY_Z, 0.0);
  }
  double ATTITUDE_X() const {
    return GetField<double>(VT_ATTITUDE_X, 0.0);
  }
  double ATTITUDE_Y() const {
    return GetField<double>(VT_ATTITUDE_Y, 0.0);
  }
  double ATTITUDE_Z() const {
    return GetField<double>(VT_ATTITUDE_Z, 0.0);
  }
  double ATTITUDE_W() const {
    return GetField<double>(VT_ATTITUDE_W, 0.0);
  }
  double OMEGA_X() const {
    return GetField<double>(VT_OMEGA_X, 0.0);
  }
  double OMEGA_Y() const {
    return GetField<double>(VT_OMEGA_Y, 0.0);
  }
  double OMEGA_Z() const {
    return GetField<double>(VT_OMEGA_Z, 0.0);
  }
  double MASS() const {
    return GetField<double>(VT_MASS, 0.0);
  }
  float CG_X() const {
    return GetField<float>(VT_CG_X, 0.0f);
  }
  float CG_Z() const {
    return GetField<float>(VT_CG_Z, 0.0f);
  }
  const ::flatbuffers::String *AERO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AERO);
  }
  const ::flatbuffers::String *CONTROLS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTROLS);
  }
  const ::flatbuffers::String *ENGINE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENGINE);
  }
  uint8_t GEAR_STATE() const {
    return GetField<uint8_t>(VT_GEAR_STATE, 0);
  }
  uint8_t GEAR_POSITION() const {
    return GetField<uint8_t>(VT_GEAR_POSITION, 0);
  }
  uint8_t FLAP_POSITION() const {
    return GetField<uint8_t>(VT_FLAP_POSITION, 0);
  }
  uint8_t SPEEDBRAKE_POS() const {
    return GetField<uint8_t>(VT_SPEEDBRAKE_POS, 0);
  }
  uint8_t FLIGHT_PHASE() const {
    return GetField<uint8_t>(VT_FLIGHT_PHASE, 0);
  }
  uint8_t AUTOPILOT_MODE() const {
    return GetField<uint8_t>(VT_AUTOPILOT_MODE, 0);
  }
  uint8_t WEIGHT_ON_WHEELS() const {
    return GetField<uint8_t>(VT_WEIGHT_ON_WHEELS, 0);
  }
  uint8_t RESERVED() const {
    return GetField<uint8_t>(VT_RESERVED, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_X, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Y, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_W, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_X, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Y, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Z, 8) &&
           VerifyField<double>(verifier, VT_MASS, 8) &&
           VerifyField<float>(verifier, VT_CG_X, 4) &&
           VerifyField<float>(verifier, VT_CG_Z, 4) &&
           VerifyOffset(verifier, VT_AERO) &&
           verifier.VerifyString(AERO()) &&
           VerifyOffset(verifier, VT_CONTROLS) &&
           verifier.VerifyString(CONTROLS()) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(ENGINE()) &&
           VerifyField<uint8_t>(verifier, VT_GEAR_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_GEAR_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLAP_POSITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPEEDBRAKE_POS, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLIGHT_PHASE, 1) &&
           VerifyField<uint8_t>(verifier, VT_AUTOPILOT_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_WEIGHT_ON_WHEELS, 1) &&
           VerifyField<uint8_t>(verifier, VT_RESERVED, 1) &&
           verifier.EndTable();
  }
};

struct ACRBuilder {
  typedef ACR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITION_X(double POSITION_X) {
    fbb_.AddElement<double>(ACR::VT_POSITION_X, POSITION_X, 0.0);
  }
  void add_POSITION_Y(double POSITION_Y) {
    fbb_.AddElement<double>(ACR::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  void add_POSITION_Z(double POSITION_Z) {
    fbb_.AddElement<double>(ACR::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  void add_VELOCITY_X(double VELOCITY_X) {
    fbb_.AddElement<double>(ACR::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  void add_VELOCITY_Y(double VELOCITY_Y) {
    fbb_.AddElement<double>(ACR::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  void add_VELOCITY_Z(double VELOCITY_Z) {
    fbb_.AddElement<double>(ACR::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  void add_ATTITUDE_X(double ATTITUDE_X) {
    fbb_.AddElement<double>(ACR::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  void add_ATTITUDE_Y(double ATTITUDE_Y) {
    fbb_.AddElement<double>(ACR::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  void add_ATTITUDE_Z(double ATTITUDE_Z) {
    fbb_.AddElement<double>(ACR::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  void add_ATTITUDE_W(double ATTITUDE_W) {
    fbb_.AddElement<double>(ACR::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  void add_OMEGA_X(double OMEGA_X) {
    fbb_.AddElement<double>(ACR::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  void add_OMEGA_Y(double OMEGA_Y) {
    fbb_.AddElement<double>(ACR::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  void add_OMEGA_Z(double OMEGA_Z) {
    fbb_.AddElement<double>(ACR::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  void add_MASS(double MASS) {
    fbb_.AddElement<double>(ACR::VT_MASS, MASS, 0.0);
  }
  void add_CG_X(float CG_X) {
    fbb_.AddElement<float>(ACR::VT_CG_X, CG_X, 0.0f);
  }
  void add_CG_Z(float CG_Z) {
    fbb_.AddElement<float>(ACR::VT_CG_Z, CG_Z, 0.0f);
  }
  void add_AERO(::flatbuffers::Offset<::flatbuffers::String> AERO) {
    fbb_.AddOffset(ACR::VT_AERO, AERO);
  }
  void add_CONTROLS(::flatbuffers::Offset<::flatbuffers::String> CONTROLS) {
    fbb_.AddOffset(ACR::VT_CONTROLS, CONTROLS);
  }
  void add_ENGINE(::flatbuffers::Offset<::flatbuffers::String> ENGINE) {
    fbb_.AddOffset(ACR::VT_ENGINE, ENGINE);
  }
  void add_GEAR_STATE(uint8_t GEAR_STATE) {
    fbb_.AddElement<uint8_t>(ACR::VT_GEAR_STATE, GEAR_STATE, 0);
  }
  void add_GEAR_POSITION(uint8_t GEAR_POSITION) {
    fbb_.AddElement<uint8_t>(ACR::VT_GEAR_POSITION, GEAR_POSITION, 0);
  }
  void add_FLAP_POSITION(uint8_t FLAP_POSITION) {
    fbb_.AddElement<uint8_t>(ACR::VT_FLAP_POSITION, FLAP_POSITION, 0);
  }
  void add_SPEEDBRAKE_POS(uint8_t SPEEDBRAKE_POS) {
    fbb_.AddElement<uint8_t>(ACR::VT_SPEEDBRAKE_POS, SPEEDBRAKE_POS, 0);
  }
  void add_FLIGHT_PHASE(uint8_t FLIGHT_PHASE) {
    fbb_.AddElement<uint8_t>(ACR::VT_FLIGHT_PHASE, FLIGHT_PHASE, 0);
  }
  void add_AUTOPILOT_MODE(uint8_t AUTOPILOT_MODE) {
    fbb_.AddElement<uint8_t>(ACR::VT_AUTOPILOT_MODE, AUTOPILOT_MODE, 0);
  }
  void add_WEIGHT_ON_WHEELS(uint8_t WEIGHT_ON_WHEELS) {
    fbb_.AddElement<uint8_t>(ACR::VT_WEIGHT_ON_WHEELS, WEIGHT_ON_WHEELS, 0);
  }
  void add_RESERVED(uint8_t RESERVED) {
    fbb_.AddElement<uint8_t>(ACR::VT_RESERVED, RESERVED, 0);
  }
  explicit ACRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ACR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ACR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ACR> CreateACR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    double MASS = 0.0,
    float CG_X = 0.0f,
    float CG_Z = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> AERO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONTROLS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ENGINE = 0,
    uint8_t GEAR_STATE = 0,
    uint8_t GEAR_POSITION = 0,
    uint8_t FLAP_POSITION = 0,
    uint8_t SPEEDBRAKE_POS = 0,
    uint8_t FLIGHT_PHASE = 0,
    uint8_t AUTOPILOT_MODE = 0,
    uint8_t WEIGHT_ON_WHEELS = 0,
    uint8_t RESERVED = 0) {
  ACRBuilder builder_(_fbb);
  builder_.add_MASS(MASS);
  builder_.add_OMEGA_Z(OMEGA_Z);
  builder_.add_OMEGA_Y(OMEGA_Y);
  builder_.add_OMEGA_X(OMEGA_X);
  builder_.add_ATTITUDE_W(ATTITUDE_W);
  builder_.add_ATTITUDE_Z(ATTITUDE_Z);
  builder_.add_ATTITUDE_Y(ATTITUDE_Y);
  builder_.add_ATTITUDE_X(ATTITUDE_X);
  builder_.add_VELOCITY_Z(VELOCITY_Z);
  builder_.add_VELOCITY_Y(VELOCITY_Y);
  builder_.add_VELOCITY_X(VELOCITY_X);
  builder_.add_POSITION_Z(POSITION_Z);
  builder_.add_POSITION_Y(POSITION_Y);
  builder_.add_POSITION_X(POSITION_X);
  builder_.add_ENGINE(ENGINE);
  builder_.add_CONTROLS(CONTROLS);
  builder_.add_AERO(AERO);
  builder_.add_CG_Z(CG_Z);
  builder_.add_CG_X(CG_X);
  builder_.add_RESERVED(RESERVED);
  builder_.add_WEIGHT_ON_WHEELS(WEIGHT_ON_WHEELS);
  builder_.add_AUTOPILOT_MODE(AUTOPILOT_MODE);
  builder_.add_FLIGHT_PHASE(FLIGHT_PHASE);
  builder_.add_SPEEDBRAKE_POS(SPEEDBRAKE_POS);
  builder_.add_FLAP_POSITION(FLAP_POSITION);
  builder_.add_GEAR_POSITION(GEAR_POSITION);
  builder_.add_GEAR_STATE(GEAR_STATE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ACR> CreateACRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    double MASS = 0.0,
    float CG_X = 0.0f,
    float CG_Z = 0.0f,
    const char *AERO = nullptr,
    const char *CONTROLS = nullptr,
    const char *ENGINE = nullptr,
    uint8_t GEAR_STATE = 0,
    uint8_t GEAR_POSITION = 0,
    uint8_t FLAP_POSITION = 0,
    uint8_t SPEEDBRAKE_POS = 0,
    uint8_t FLIGHT_PHASE = 0,
    uint8_t AUTOPILOT_MODE = 0,
    uint8_t WEIGHT_ON_WHEELS = 0,
    uint8_t RESERVED = 0) {
  auto AERO__ = AERO ? _fbb.CreateString(AERO) : 0;
  auto CONTROLS__ = CONTROLS ? _fbb.CreateString(CONTROLS) : 0;
  auto ENGINE__ = ENGINE ? _fbb.CreateString(ENGINE) : 0;
  return CreateACR(
      _fbb,
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      CG_X,
      CG_Z,
      AERO__,
      CONTROLS__,
      ENGINE__,
      GEAR_STATE,
      GEAR_POSITION,
      FLAP_POSITION,
      SPEEDBRAKE_POS,
      FLIGHT_PHASE,
      AUTOPILOT_MODE,
      WEIGHT_ON_WHEELS,
      RESERVED);
}

inline const ACR *GetACR(const void *buf) {
  return ::flatbuffers::GetRoot<ACR>(buf);
}

inline const ACR *GetSizePrefixedACR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ACR>(buf);
}

inline const char *ACRIdentifier() {
  return "$ACR";
}

inline bool ACRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ACRIdentifier());
}

inline bool SizePrefixedACRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ACRIdentifier(), true);
}

inline bool VerifyACRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ACR>(ACRIdentifier());
}

inline bool VerifySizePrefixedACRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ACR>(ACRIdentifier());
}

inline void FinishACRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ACR> root) {
  fbb.Finish(root, ACRIdentifier());
}

inline void FinishSizePrefixedACRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ACR> root) {
  fbb.FinishSizePrefixed(root, ACRIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
