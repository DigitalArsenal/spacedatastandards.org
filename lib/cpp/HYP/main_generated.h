// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct Score;
struct ScoreBuilder;

struct HYP;
struct HYPBuilder;

struct HYPCOLLECTION;
struct HYPCOLLECTIONBuilder;

enum ScoreType : int8_t {
  ScoreType_OUTLIER = 0,
  ScoreType_MIN = ScoreType_OUTLIER,
  ScoreType_MAX = ScoreType_OUTLIER
};

inline const ScoreType (&EnumValuesScoreType())[1] {
  static const ScoreType values[] = {
    ScoreType_OUTLIER
  };
  return values;
}

inline const char * const *EnumNamesScoreType() {
  static const char * const names[2] = {
    "OUTLIER",
    nullptr
  };
  return names;
}

inline const char *EnumNameScoreType(ScoreType e) {
  if (::flatbuffers::IsOutRange(e, ScoreType_OUTLIER, ScoreType_OUTLIER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScoreType()[index];
}

struct Score FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScoreBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORAD_CAT_ID = 4,
    VT_TYPE = 6,
    VT_TAG = 8,
    VT_SCORE = 10
  };
  const ::flatbuffers::String *NORAD_CAT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NORAD_CAT_ID);
  }
  ScoreType TYPE() const {
    return static_cast<ScoreType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *TAG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  float SCORE() const {
    return GetField<float>(VT_SCORE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORAD_CAT_ID) &&
           verifier.VerifyString(NORAD_CAT_ID()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyString(TAG()) &&
           VerifyField<float>(verifier, VT_SCORE, 4) &&
           verifier.EndTable();
  }
};

struct ScoreBuilder {
  typedef Score Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NORAD_CAT_ID(::flatbuffers::Offset<::flatbuffers::String> NORAD_CAT_ID) {
    fbb_.AddOffset(Score::VT_NORAD_CAT_ID, NORAD_CAT_ID);
  }
  void add_TYPE(ScoreType TYPE) {
    fbb_.AddElement<int8_t>(Score::VT_TYPE, static_cast<int8_t>(TYPE), 0);
  }
  void add_TAG(::flatbuffers::Offset<::flatbuffers::String> TAG) {
    fbb_.AddOffset(Score::VT_TAG, TAG);
  }
  void add_SCORE(float SCORE) {
    fbb_.AddElement<float>(Score::VT_SCORE, SCORE, 0.0f);
  }
  explicit ScoreBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Score> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Score>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Score> CreateScore(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NORAD_CAT_ID = 0,
    ScoreType TYPE = ScoreType_OUTLIER,
    ::flatbuffers::Offset<::flatbuffers::String> TAG = 0,
    float SCORE = 0.0f) {
  ScoreBuilder builder_(_fbb);
  builder_.add_SCORE(SCORE);
  builder_.add_TAG(TAG);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Score> CreateScoreDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NORAD_CAT_ID = nullptr,
    ScoreType TYPE = ScoreType_OUTLIER,
    const char *TAG = nullptr,
    float SCORE = 0.0f) {
  auto NORAD_CAT_ID__ = NORAD_CAT_ID ? _fbb.CreateString(NORAD_CAT_ID) : 0;
  auto TAG__ = TAG ? _fbb.CreateString(TAG) : 0;
  return CreateScore(
      _fbb,
      NORAD_CAT_ID__,
      TYPE,
      TAG__,
      SCORE);
}

/// Hypothesis Message
struct HYP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HYPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAT_IDS = 4,
    VT_SIT_IDS = 6,
    VT_NAME = 8,
    VT_CATEGORY = 10,
    VT_ROW_INDICATORS = 12,
    VT_COL_INDICATORS = 14,
    VT_MATRIX = 16,
    VT_SCORE = 18,
    VT_ANALYSIS_METHOD = 20,
    VT_EVENT_START_TIME = 22,
    VT_EVENT_END_TIME = 24
  };
  /// Space Objects Involved
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *CAT_IDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CAT_IDS);
  }
  /// Space Objects Involved
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *SIT_IDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SIT_IDS);
  }
  /// Name of the hypothesis
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Category of the hypothesis
  const ::flatbuffers::String *CATEGORY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATEGORY);
  }
  /// Row indicators for the hypothesis matrix
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ROW_INDICATORS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ROW_INDICATORS);
  }
  /// Column indicators for the hypothesis matrix
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *COL_INDICATORS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_COL_INDICATORS);
  }
  /// Matrix data as a boolean array in row major format; if overflow, adds additional rows
  const ::flatbuffers::Vector<uint8_t> *MATRIX() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_MATRIX);
  }
  /// Scores for objects
  const ::flatbuffers::Vector<::flatbuffers::Offset<Score>> *SCORE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Score>> *>(VT_SCORE);
  }
  /// Analysis methodology used to form the hypothesis
  const ::flatbuffers::String *ANALYSIS_METHOD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ANALYSIS_METHOD);
  }
  const ::flatbuffers::String *EVENT_START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_START_TIME);
  }
  const ::flatbuffers::String *EVENT_END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENT_END_TIME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAT_IDS) &&
           verifier.VerifyVector(CAT_IDS()) &&
           verifier.VerifyVectorOfStrings(CAT_IDS()) &&
           VerifyOffset(verifier, VT_SIT_IDS) &&
           verifier.VerifyVector(SIT_IDS()) &&
           verifier.VerifyVectorOfStrings(SIT_IDS()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(CATEGORY()) &&
           VerifyOffset(verifier, VT_ROW_INDICATORS) &&
           verifier.VerifyVector(ROW_INDICATORS()) &&
           verifier.VerifyVectorOfStrings(ROW_INDICATORS()) &&
           VerifyOffset(verifier, VT_COL_INDICATORS) &&
           verifier.VerifyVector(COL_INDICATORS()) &&
           verifier.VerifyVectorOfStrings(COL_INDICATORS()) &&
           VerifyOffset(verifier, VT_MATRIX) &&
           verifier.VerifyVector(MATRIX()) &&
           VerifyOffset(verifier, VT_SCORE) &&
           verifier.VerifyVector(SCORE()) &&
           verifier.VerifyVectorOfTables(SCORE()) &&
           VerifyOffset(verifier, VT_ANALYSIS_METHOD) &&
           verifier.VerifyString(ANALYSIS_METHOD()) &&
           VerifyOffset(verifier, VT_EVENT_START_TIME) &&
           verifier.VerifyString(EVENT_START_TIME()) &&
           VerifyOffset(verifier, VT_EVENT_END_TIME) &&
           verifier.VerifyString(EVENT_END_TIME()) &&
           verifier.EndTable();
  }
};

struct HYPBuilder {
  typedef HYP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CAT_IDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> CAT_IDS) {
    fbb_.AddOffset(HYP::VT_CAT_IDS, CAT_IDS);
  }
  void add_SIT_IDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> SIT_IDS) {
    fbb_.AddOffset(HYP::VT_SIT_IDS, SIT_IDS);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(HYP::VT_NAME, NAME);
  }
  void add_CATEGORY(::flatbuffers::Offset<::flatbuffers::String> CATEGORY) {
    fbb_.AddOffset(HYP::VT_CATEGORY, CATEGORY);
  }
  void add_ROW_INDICATORS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ROW_INDICATORS) {
    fbb_.AddOffset(HYP::VT_ROW_INDICATORS, ROW_INDICATORS);
  }
  void add_COL_INDICATORS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COL_INDICATORS) {
    fbb_.AddOffset(HYP::VT_COL_INDICATORS, COL_INDICATORS);
  }
  void add_MATRIX(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> MATRIX) {
    fbb_.AddOffset(HYP::VT_MATRIX, MATRIX);
  }
  void add_SCORE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Score>>> SCORE) {
    fbb_.AddOffset(HYP::VT_SCORE, SCORE);
  }
  void add_ANALYSIS_METHOD(::flatbuffers::Offset<::flatbuffers::String> ANALYSIS_METHOD) {
    fbb_.AddOffset(HYP::VT_ANALYSIS_METHOD, ANALYSIS_METHOD);
  }
  void add_EVENT_START_TIME(::flatbuffers::Offset<::flatbuffers::String> EVENT_START_TIME) {
    fbb_.AddOffset(HYP::VT_EVENT_START_TIME, EVENT_START_TIME);
  }
  void add_EVENT_END_TIME(::flatbuffers::Offset<::flatbuffers::String> EVENT_END_TIME) {
    fbb_.AddOffset(HYP::VT_EVENT_END_TIME, EVENT_END_TIME);
  }
  explicit HYPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HYP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HYP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HYP> CreateHYP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> CAT_IDS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> SIT_IDS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CATEGORY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ROW_INDICATORS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> COL_INDICATORS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> MATRIX = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Score>>> SCORE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ANALYSIS_METHOD = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EVENT_START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EVENT_END_TIME = 0) {
  HYPBuilder builder_(_fbb);
  builder_.add_EVENT_END_TIME(EVENT_END_TIME);
  builder_.add_EVENT_START_TIME(EVENT_START_TIME);
  builder_.add_ANALYSIS_METHOD(ANALYSIS_METHOD);
  builder_.add_SCORE(SCORE);
  builder_.add_MATRIX(MATRIX);
  builder_.add_COL_INDICATORS(COL_INDICATORS);
  builder_.add_ROW_INDICATORS(ROW_INDICATORS);
  builder_.add_CATEGORY(CATEGORY);
  builder_.add_NAME(NAME);
  builder_.add_SIT_IDS(SIT_IDS);
  builder_.add_CAT_IDS(CAT_IDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HYP> CreateHYPDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *CAT_IDS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *SIT_IDS = nullptr,
    const char *NAME = nullptr,
    const char *CATEGORY = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ROW_INDICATORS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *COL_INDICATORS = nullptr,
    const std::vector<uint8_t> *MATRIX = nullptr,
    const std::vector<::flatbuffers::Offset<Score>> *SCORE = nullptr,
    const char *ANALYSIS_METHOD = nullptr,
    const char *EVENT_START_TIME = nullptr,
    const char *EVENT_END_TIME = nullptr) {
  auto CAT_IDS__ = CAT_IDS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*CAT_IDS) : 0;
  auto SIT_IDS__ = SIT_IDS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*SIT_IDS) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto CATEGORY__ = CATEGORY ? _fbb.CreateString(CATEGORY) : 0;
  auto ROW_INDICATORS__ = ROW_INDICATORS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ROW_INDICATORS) : 0;
  auto COL_INDICATORS__ = COL_INDICATORS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*COL_INDICATORS) : 0;
  auto MATRIX__ = MATRIX ? _fbb.CreateVector<uint8_t>(*MATRIX) : 0;
  auto SCORE__ = SCORE ? _fbb.CreateVector<::flatbuffers::Offset<Score>>(*SCORE) : 0;
  auto ANALYSIS_METHOD__ = ANALYSIS_METHOD ? _fbb.CreateString(ANALYSIS_METHOD) : 0;
  auto EVENT_START_TIME__ = EVENT_START_TIME ? _fbb.CreateString(EVENT_START_TIME) : 0;
  auto EVENT_END_TIME__ = EVENT_END_TIME ? _fbb.CreateString(EVENT_END_TIME) : 0;
  return CreateHYP(
      _fbb,
      CAT_IDS__,
      SIT_IDS__,
      NAME__,
      CATEGORY__,
      ROW_INDICATORS__,
      COL_INDICATORS__,
      MATRIX__,
      SCORE__,
      ANALYSIS_METHOD__,
      EVENT_START_TIME__,
      EVENT_END_TIME__);
}

/// Collection of HYP records
struct HYPCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HYPCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<HYP>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<HYP>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct HYPCOLLECTIONBuilder {
  typedef HYPCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HYP>>> RECORDS) {
    fbb_.AddOffset(HYPCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit HYPCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HYPCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HYPCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HYPCOLLECTION> CreateHYPCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<HYP>>> RECORDS = 0) {
  HYPCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HYPCOLLECTION> CreateHYPCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<HYP>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<HYP>>(*RECORDS) : 0;
  return CreateHYPCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const HYPCOLLECTION *GetHYPCOLLECTION(const void *buf) {
  return ::flatbuffers::GetRoot<HYPCOLLECTION>(buf);
}

inline const HYPCOLLECTION *GetSizePrefixedHYPCOLLECTION(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HYPCOLLECTION>(buf);
}

inline const char *HYPCOLLECTIONIdentifier() {
  return "$HYP";
}

inline bool HYPCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HYPCOLLECTIONIdentifier());
}

inline bool SizePrefixedHYPCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HYPCOLLECTIONIdentifier(), true);
}

inline bool VerifyHYPCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HYPCOLLECTION>(HYPCOLLECTIONIdentifier());
}

inline bool VerifySizePrefixedHYPCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HYPCOLLECTION>(HYPCOLLECTIONIdentifier());
}

inline void FinishHYPCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HYPCOLLECTION> root) {
  fbb.Finish(root, HYPCOLLECTIONIdentifier());
}

inline void FinishSizePrefixedHYPCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HYPCOLLECTION> root) {
  fbb.FinishSizePrefixed(root, HYPCOLLECTIONIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
