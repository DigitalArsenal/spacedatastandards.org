// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct RAF;
struct RAFBuilder;

enum rafPduType : int8_t {
  rafPduType_BIND_INVOCATION = 0,
  rafPduType_BIND_RETURN = 1,
  rafPduType_UNBIND_INVOCATION = 2,
  rafPduType_UNBIND_RETURN = 3,
  rafPduType_START_INVOCATION = 4,
  rafPduType_START_RETURN = 5,
  rafPduType_STOP_INVOCATION = 6,
  rafPduType_STOP_RETURN = 7,
  rafPduType_TRANSFER_BUFFER = 8,
  rafPduType_STATUS_REPORT = 9,
  rafPduType_PEER_ABORT = 10,
  rafPduType_MIN = rafPduType_BIND_INVOCATION,
  rafPduType_MAX = rafPduType_PEER_ABORT
};

inline const rafPduType (&EnumValuesrafPduType())[11] {
  static const rafPduType values[] = {
    rafPduType_BIND_INVOCATION,
    rafPduType_BIND_RETURN,
    rafPduType_UNBIND_INVOCATION,
    rafPduType_UNBIND_RETURN,
    rafPduType_START_INVOCATION,
    rafPduType_START_RETURN,
    rafPduType_STOP_INVOCATION,
    rafPduType_STOP_RETURN,
    rafPduType_TRANSFER_BUFFER,
    rafPduType_STATUS_REPORT,
    rafPduType_PEER_ABORT
  };
  return values;
}

inline const char * const *EnumNamesrafPduType() {
  static const char * const names[12] = {
    "BIND_INVOCATION",
    "BIND_RETURN",
    "UNBIND_INVOCATION",
    "UNBIND_RETURN",
    "START_INVOCATION",
    "START_RETURN",
    "STOP_INVOCATION",
    "STOP_RETURN",
    "TRANSFER_BUFFER",
    "STATUS_REPORT",
    "PEER_ABORT",
    nullptr
  };
  return names;
}

inline const char *EnumNamerafPduType(rafPduType e) {
  if (::flatbuffers::IsOutRange(e, rafPduType_BIND_INVOCATION, rafPduType_PEER_ABORT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesrafPduType()[index];
}

/// Return All Frames Service (CCSDS 913.1-B-2)
struct RAF FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RAFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PDU_TYPE = 4,
    VT_INITIATOR_ID = 6,
    VT_RESPONDER_PORT_ID = 8,
    VT_SERVICE_TYPE = 10,
    VT_VERSION = 12,
    VT_INVOKE_ID = 14,
    VT_FRAME_QUALITY = 16,
    VT_DATA = 18
  };
  /// PDU type
  rafPduType PDU_TYPE() const {
    return static_cast<rafPduType>(GetField<int8_t>(VT_PDU_TYPE, 0));
  }
  /// Initiator identifier
  const ::flatbuffers::String *INITIATOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIATOR_ID);
  }
  /// Responder port identifier
  const ::flatbuffers::String *RESPONDER_PORT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESPONDER_PORT_ID);
  }
  /// Service type
  uint8_t SERVICE_TYPE() const {
    return GetField<uint8_t>(VT_SERVICE_TYPE, 0);
  }
  /// Version number
  uint16_t VERSION() const {
    return GetField<uint16_t>(VT_VERSION, 0);
  }
  /// Invoke ID
  uint32_t INVOKE_ID() const {
    return GetField<uint32_t>(VT_INVOKE_ID, 0);
  }
  /// Frame quality
  uint8_t FRAME_QUALITY() const {
    return GetField<uint8_t>(VT_FRAME_QUALITY, 0);
  }
  /// Data
  const ::flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PDU_TYPE, 1) &&
           VerifyOffset(verifier, VT_INITIATOR_ID) &&
           verifier.VerifyString(INITIATOR_ID()) &&
           VerifyOffset(verifier, VT_RESPONDER_PORT_ID) &&
           verifier.VerifyString(RESPONDER_PORT_ID()) &&
           VerifyField<uint8_t>(verifier, VT_SERVICE_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_VERSION, 2) &&
           VerifyField<uint32_t>(verifier, VT_INVOKE_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_FRAME_QUALITY, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           verifier.EndTable();
  }
};

struct RAFBuilder {
  typedef RAF Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PDU_TYPE(rafPduType PDU_TYPE) {
    fbb_.AddElement<int8_t>(RAF::VT_PDU_TYPE, static_cast<int8_t>(PDU_TYPE), 0);
  }
  void add_INITIATOR_ID(::flatbuffers::Offset<::flatbuffers::String> INITIATOR_ID) {
    fbb_.AddOffset(RAF::VT_INITIATOR_ID, INITIATOR_ID);
  }
  void add_RESPONDER_PORT_ID(::flatbuffers::Offset<::flatbuffers::String> RESPONDER_PORT_ID) {
    fbb_.AddOffset(RAF::VT_RESPONDER_PORT_ID, RESPONDER_PORT_ID);
  }
  void add_SERVICE_TYPE(uint8_t SERVICE_TYPE) {
    fbb_.AddElement<uint8_t>(RAF::VT_SERVICE_TYPE, SERVICE_TYPE, 0);
  }
  void add_VERSION(uint16_t VERSION) {
    fbb_.AddElement<uint16_t>(RAF::VT_VERSION, VERSION, 0);
  }
  void add_INVOKE_ID(uint32_t INVOKE_ID) {
    fbb_.AddElement<uint32_t>(RAF::VT_INVOKE_ID, INVOKE_ID, 0);
  }
  void add_FRAME_QUALITY(uint8_t FRAME_QUALITY) {
    fbb_.AddElement<uint8_t>(RAF::VT_FRAME_QUALITY, FRAME_QUALITY, 0);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(RAF::VT_DATA, DATA);
  }
  explicit RAFBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RAF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RAF>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RAF> CreateRAF(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rafPduType PDU_TYPE = rafPduType_BIND_INVOCATION,
    ::flatbuffers::Offset<::flatbuffers::String> INITIATOR_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RESPONDER_PORT_ID = 0,
    uint8_t SERVICE_TYPE = 0,
    uint16_t VERSION = 0,
    uint32_t INVOKE_ID = 0,
    uint8_t FRAME_QUALITY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA = 0) {
  RAFBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_INVOKE_ID(INVOKE_ID);
  builder_.add_RESPONDER_PORT_ID(RESPONDER_PORT_ID);
  builder_.add_INITIATOR_ID(INITIATOR_ID);
  builder_.add_VERSION(VERSION);
  builder_.add_FRAME_QUALITY(FRAME_QUALITY);
  builder_.add_SERVICE_TYPE(SERVICE_TYPE);
  builder_.add_PDU_TYPE(PDU_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RAF> CreateRAFDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    rafPduType PDU_TYPE = rafPduType_BIND_INVOCATION,
    const char *INITIATOR_ID = nullptr,
    const char *RESPONDER_PORT_ID = nullptr,
    uint8_t SERVICE_TYPE = 0,
    uint16_t VERSION = 0,
    uint32_t INVOKE_ID = 0,
    uint8_t FRAME_QUALITY = 0,
    const std::vector<uint8_t> *DATA = nullptr) {
  auto INITIATOR_ID__ = INITIATOR_ID ? _fbb.CreateString(INITIATOR_ID) : 0;
  auto RESPONDER_PORT_ID__ = RESPONDER_PORT_ID ? _fbb.CreateString(RESPONDER_PORT_ID) : 0;
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  return CreateRAF(
      _fbb,
      PDU_TYPE,
      INITIATOR_ID__,
      RESPONDER_PORT_ID__,
      SERVICE_TYPE,
      VERSION,
      INVOKE_ID,
      FRAME_QUALITY,
      DATA__);
}

inline const RAF *GetRAF(const void *buf) {
  return ::flatbuffers::GetRoot<RAF>(buf);
}

inline const RAF *GetSizePrefixedRAF(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RAF>(buf);
}

inline const char *RAFIdentifier() {
  return "$RAF";
}

inline bool RAFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RAFIdentifier());
}

inline bool SizePrefixedRAFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RAFIdentifier(), true);
}

inline bool VerifyRAFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RAF>(RAFIdentifier());
}

inline bool VerifySizePrefixedRAFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RAF>(RAFIdentifier());
}

inline void FinishRAFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RAF> root) {
  fbb.Finish(root, RAFIdentifier());
}

inline void FinishSizePrefixedRAFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RAF> root) {
  fbb.FinishSizePrefixed(root, RAFIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
