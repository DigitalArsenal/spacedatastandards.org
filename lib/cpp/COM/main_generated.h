// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct COM;
struct COMBuilder;

enum ComModulationType : int8_t {
  ComModulationType_AM = 0,
  ComModulationType_FM = 1,
  ComModulationType_PM = 2,
  ComModulationType_BPSK = 3,
  ComModulationType_QPSK = 4,
  ComModulationType_PSK8 = 5,
  ComModulationType_QAM16 = 6,
  ComModulationType_QAM64 = 7,
  ComModulationType_QAM256 = 8,
  ComModulationType_FSK = 9,
  ComModulationType_MSK = 10,
  ComModulationType_OFDM = 11,
  ComModulationType_SPREAD_SPECTRUM = 12,
  ComModulationType_FHSS = 13,
  ComModulationType_DSSS = 14,
  ComModulationType_MIN = ComModulationType_AM,
  ComModulationType_MAX = ComModulationType_DSSS
};

inline const ComModulationType (&EnumValuesComModulationType())[15] {
  static const ComModulationType values[] = {
    ComModulationType_AM,
    ComModulationType_FM,
    ComModulationType_PM,
    ComModulationType_BPSK,
    ComModulationType_QPSK,
    ComModulationType_PSK8,
    ComModulationType_QAM16,
    ComModulationType_QAM64,
    ComModulationType_QAM256,
    ComModulationType_FSK,
    ComModulationType_MSK,
    ComModulationType_OFDM,
    ComModulationType_SPREAD_SPECTRUM,
    ComModulationType_FHSS,
    ComModulationType_DSSS
  };
  return values;
}

inline const char * const *EnumNamesComModulationType() {
  static const char * const names[16] = {
    "AM",
    "FM",
    "PM",
    "BPSK",
    "QPSK",
    "PSK8",
    "QAM16",
    "QAM64",
    "QAM256",
    "FSK",
    "MSK",
    "OFDM",
    "SPREAD_SPECTRUM",
    "FHSS",
    "DSSS",
    nullptr
  };
  return names;
}

inline const char *EnumNameComModulationType(ComModulationType e) {
  if (::flatbuffers::IsOutRange(e, ComModulationType_AM, ComModulationType_DSSS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesComModulationType()[index];
}

enum BandType : int8_t {
  BandType_HF = 0,
  BandType_VHF = 1,
  BandType_UHF = 2,
  BandType_L_BAND = 3,
  BandType_S_BAND = 4,
  BandType_C_BAND = 5,
  BandType_X_BAND = 6,
  BandType_KU_BAND = 7,
  BandType_K_BAND = 8,
  BandType_KA_BAND = 9,
  BandType_V_BAND = 10,
  BandType_W_BAND = 11,
  BandType_MM_WAVE = 12,
  BandType_MIN = BandType_HF,
  BandType_MAX = BandType_MM_WAVE
};

inline const BandType (&EnumValuesBandType())[13] {
  static const BandType values[] = {
    BandType_HF,
    BandType_VHF,
    BandType_UHF,
    BandType_L_BAND,
    BandType_S_BAND,
    BandType_C_BAND,
    BandType_X_BAND,
    BandType_KU_BAND,
    BandType_K_BAND,
    BandType_KA_BAND,
    BandType_V_BAND,
    BandType_W_BAND,
    BandType_MM_WAVE
  };
  return values;
}

inline const char * const *EnumNamesBandType() {
  static const char * const names[14] = {
    "HF",
    "VHF",
    "UHF",
    "L_BAND",
    "S_BAND",
    "C_BAND",
    "X_BAND",
    "KU_BAND",
    "K_BAND",
    "KA_BAND",
    "V_BAND",
    "W_BAND",
    "MM_WAVE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBandType(BandType e) {
  if (::flatbuffers::IsOutRange(e, BandType_HF, BandType_MM_WAVE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBandType()[index];
}

enum PropagationModel : int8_t {
  PropagationModel_FREE_SPACE = 0,
  PropagationModel_TWO_RAY_GROUND = 1,
  PropagationModel_HATA_URBAN = 2,
  PropagationModel_HATA_SUBURBAN = 3,
  PropagationModel_COST231 = 4,
  PropagationModel_ITU_R_P525 = 5,
  PropagationModel_ITU_R_P676 = 6,
  PropagationModel_ITU_R_P838 = 7,
  PropagationModel_ITU_R_P840 = 8,
  PropagationModel_LONGLEY_RICE = 9,
  PropagationModel_OKUMURA = 10,
  PropagationModel_LOG_DISTANCE = 11,
  PropagationModel_TERRAIN_INTEGRATED = 12,
  PropagationModel_MIN = PropagationModel_FREE_SPACE,
  PropagationModel_MAX = PropagationModel_TERRAIN_INTEGRATED
};

inline const PropagationModel (&EnumValuesPropagationModel())[13] {
  static const PropagationModel values[] = {
    PropagationModel_FREE_SPACE,
    PropagationModel_TWO_RAY_GROUND,
    PropagationModel_HATA_URBAN,
    PropagationModel_HATA_SUBURBAN,
    PropagationModel_COST231,
    PropagationModel_ITU_R_P525,
    PropagationModel_ITU_R_P676,
    PropagationModel_ITU_R_P838,
    PropagationModel_ITU_R_P840,
    PropagationModel_LONGLEY_RICE,
    PropagationModel_OKUMURA,
    PropagationModel_LOG_DISTANCE,
    PropagationModel_TERRAIN_INTEGRATED
  };
  return values;
}

inline const char * const *EnumNamesPropagationModel() {
  static const char * const names[14] = {
    "FREE_SPACE",
    "TWO_RAY_GROUND",
    "HATA_URBAN",
    "HATA_SUBURBAN",
    "COST231",
    "ITU_R_P525",
    "ITU_R_P676",
    "ITU_R_P838",
    "ITU_R_P840",
    "LONGLEY_RICE",
    "OKUMURA",
    "LOG_DISTANCE",
    "TERRAIN_INTEGRATED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropagationModel(PropagationModel e) {
  if (::flatbuffers::IsOutRange(e, PropagationModel_FREE_SPACE, PropagationModel_TERRAIN_INTEGRATED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropagationModel()[index];
}

enum DataLinkType : int8_t {
  DataLinkType_LINK_16 = 0,
  DataLinkType_LINK_11 = 1,
  DataLinkType_LINK_22 = 2,
  DataLinkType_CDL = 3,
  DataLinkType_TCDL = 4,
  DataLinkType_SADL = 5,
  DataLinkType_IFDL = 6,
  DataLinkType_VMF = 7,
  DataLinkType_JREAP = 8,
  DataLinkType_SATCOM = 9,
  DataLinkType_ADS_B = 10,
  DataLinkType_AIS = 11,
  DataLinkType_HAVEQUICK = 12,
  DataLinkType_SINCGARS = 13,
  DataLinkType_CUSTOM = 14,
  DataLinkType_MIN = DataLinkType_LINK_16,
  DataLinkType_MAX = DataLinkType_CUSTOM
};

inline const DataLinkType (&EnumValuesDataLinkType())[15] {
  static const DataLinkType values[] = {
    DataLinkType_LINK_16,
    DataLinkType_LINK_11,
    DataLinkType_LINK_22,
    DataLinkType_CDL,
    DataLinkType_TCDL,
    DataLinkType_SADL,
    DataLinkType_IFDL,
    DataLinkType_VMF,
    DataLinkType_JREAP,
    DataLinkType_SATCOM,
    DataLinkType_ADS_B,
    DataLinkType_AIS,
    DataLinkType_HAVEQUICK,
    DataLinkType_SINCGARS,
    DataLinkType_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesDataLinkType() {
  static const char * const names[16] = {
    "LINK_16",
    "LINK_11",
    "LINK_22",
    "CDL",
    "TCDL",
    "SADL",
    "IFDL",
    "VMF",
    "JREAP",
    "SATCOM",
    "ADS_B",
    "AIS",
    "HAVEQUICK",
    "SINCGARS",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataLinkType(DataLinkType e) {
  if (::flatbuffers::IsOutRange(e, DataLinkType_LINK_16, DataLinkType_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataLinkType()[index];
}

enum AntennaPattern : int8_t {
  AntennaPattern_ISOTROPIC = 0,
  AntennaPattern_DIPOLE = 1,
  AntennaPattern_YAGI = 2,
  AntennaPattern_PARABOLIC = 3,
  AntennaPattern_PHASED_ARRAY = 4,
  AntennaPattern_HORN = 5,
  AntennaPattern_PATCH = 6,
  AntennaPattern_HELICAL = 7,
  AntennaPattern_LOG_PERIODIC = 8,
  AntennaPattern_OMNIDIRECTIONAL = 9,
  AntennaPattern_SECTOR = 10,
  AntennaPattern_CUSTOM_PATTERN = 11,
  AntennaPattern_MIN = AntennaPattern_ISOTROPIC,
  AntennaPattern_MAX = AntennaPattern_CUSTOM_PATTERN
};

inline const AntennaPattern (&EnumValuesAntennaPattern())[12] {
  static const AntennaPattern values[] = {
    AntennaPattern_ISOTROPIC,
    AntennaPattern_DIPOLE,
    AntennaPattern_YAGI,
    AntennaPattern_PARABOLIC,
    AntennaPattern_PHASED_ARRAY,
    AntennaPattern_HORN,
    AntennaPattern_PATCH,
    AntennaPattern_HELICAL,
    AntennaPattern_LOG_PERIODIC,
    AntennaPattern_OMNIDIRECTIONAL,
    AntennaPattern_SECTOR,
    AntennaPattern_CUSTOM_PATTERN
  };
  return values;
}

inline const char * const *EnumNamesAntennaPattern() {
  static const char * const names[13] = {
    "ISOTROPIC",
    "DIPOLE",
    "YAGI",
    "PARABOLIC",
    "PHASED_ARRAY",
    "HORN",
    "PATCH",
    "HELICAL",
    "LOG_PERIODIC",
    "OMNIDIRECTIONAL",
    "SECTOR",
    "CUSTOM_PATTERN",
    nullptr
  };
  return names;
}

inline const char *EnumNameAntennaPattern(AntennaPattern e) {
  if (::flatbuffers::IsOutRange(e, AntennaPattern_ISOTROPIC, AntennaPattern_CUSTOM_PATTERN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAntennaPattern()[index];
}

/// Communications Systems
struct COM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_ID = 4,
    VT_ENTITY_ID = 6,
    VT_IS_TRANSMITTING = 8,
    VT_IS_RECEIVING = 10,
    VT_CURRENT_FREQUENCY_HZ = 12,
    VT_CURRENT_POWER_WATTS = 14,
    VT_CURRENT_DATA_RATE_BPS = 16,
    VT_MESSAGES_SENT = 18,
    VT_MESSAGES_RECEIVED = 20,
    VT_BYTES_SENT = 22,
    VT_BYTES_RECEIVED = 24,
    VT_CONNECTED_NODES = 26,
    VT_ACTIVE_LINKS = 28,
    VT_LAST_UPDATE_MS = 30
  };
  uint32_t SYSTEM_ID() const {
    return GetField<uint32_t>(VT_SYSTEM_ID, 0);
  }
  uint32_t ENTITY_ID() const {
    return GetField<uint32_t>(VT_ENTITY_ID, 0);
  }
  bool IS_TRANSMITTING() const {
    return GetField<uint8_t>(VT_IS_TRANSMITTING, 0) != 0;
  }
  bool IS_RECEIVING() const {
    return GetField<uint8_t>(VT_IS_RECEIVING, 0) != 0;
  }
  double CURRENT_FREQUENCY_HZ() const {
    return GetField<double>(VT_CURRENT_FREQUENCY_HZ, 0.0);
  }
  double CURRENT_POWER_WATTS() const {
    return GetField<double>(VT_CURRENT_POWER_WATTS, 0.0);
  }
  double CURRENT_DATA_RATE_BPS() const {
    return GetField<double>(VT_CURRENT_DATA_RATE_BPS, 0.0);
  }
  uint64_t MESSAGES_SENT() const {
    return GetField<uint64_t>(VT_MESSAGES_SENT, 0);
  }
  uint64_t MESSAGES_RECEIVED() const {
    return GetField<uint64_t>(VT_MESSAGES_RECEIVED, 0);
  }
  uint64_t BYTES_SENT() const {
    return GetField<uint64_t>(VT_BYTES_SENT, 0);
  }
  uint64_t BYTES_RECEIVED() const {
    return GetField<uint64_t>(VT_BYTES_RECEIVED, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *CONNECTED_NODES() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_CONNECTED_NODES);
  }
  const ::flatbuffers::Vector<int8_t> *ACTIVE_LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_ACTIVE_LINKS);
  }
  int64_t LAST_UPDATE_MS() const {
    return GetField<int64_t>(VT_LAST_UPDATE_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SYSTEM_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ENTITY_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_TRANSMITTING, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_RECEIVING, 1) &&
           VerifyField<double>(verifier, VT_CURRENT_FREQUENCY_HZ, 8) &&
           VerifyField<double>(verifier, VT_CURRENT_POWER_WATTS, 8) &&
           VerifyField<double>(verifier, VT_CURRENT_DATA_RATE_BPS, 8) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGES_SENT, 8) &&
           VerifyField<uint64_t>(verifier, VT_MESSAGES_RECEIVED, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTES_SENT, 8) &&
           VerifyField<uint64_t>(verifier, VT_BYTES_RECEIVED, 8) &&
           VerifyOffset(verifier, VT_CONNECTED_NODES) &&
           verifier.VerifyVector(CONNECTED_NODES()) &&
           VerifyOffset(verifier, VT_ACTIVE_LINKS) &&
           verifier.VerifyVector(ACTIVE_LINKS()) &&
           VerifyField<int64_t>(verifier, VT_LAST_UPDATE_MS, 8) &&
           verifier.EndTable();
  }
};

struct COMBuilder {
  typedef COM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SYSTEM_ID(uint32_t SYSTEM_ID) {
    fbb_.AddElement<uint32_t>(COM::VT_SYSTEM_ID, SYSTEM_ID, 0);
  }
  void add_ENTITY_ID(uint32_t ENTITY_ID) {
    fbb_.AddElement<uint32_t>(COM::VT_ENTITY_ID, ENTITY_ID, 0);
  }
  void add_IS_TRANSMITTING(bool IS_TRANSMITTING) {
    fbb_.AddElement<uint8_t>(COM::VT_IS_TRANSMITTING, static_cast<uint8_t>(IS_TRANSMITTING), 0);
  }
  void add_IS_RECEIVING(bool IS_RECEIVING) {
    fbb_.AddElement<uint8_t>(COM::VT_IS_RECEIVING, static_cast<uint8_t>(IS_RECEIVING), 0);
  }
  void add_CURRENT_FREQUENCY_HZ(double CURRENT_FREQUENCY_HZ) {
    fbb_.AddElement<double>(COM::VT_CURRENT_FREQUENCY_HZ, CURRENT_FREQUENCY_HZ, 0.0);
  }
  void add_CURRENT_POWER_WATTS(double CURRENT_POWER_WATTS) {
    fbb_.AddElement<double>(COM::VT_CURRENT_POWER_WATTS, CURRENT_POWER_WATTS, 0.0);
  }
  void add_CURRENT_DATA_RATE_BPS(double CURRENT_DATA_RATE_BPS) {
    fbb_.AddElement<double>(COM::VT_CURRENT_DATA_RATE_BPS, CURRENT_DATA_RATE_BPS, 0.0);
  }
  void add_MESSAGES_SENT(uint64_t MESSAGES_SENT) {
    fbb_.AddElement<uint64_t>(COM::VT_MESSAGES_SENT, MESSAGES_SENT, 0);
  }
  void add_MESSAGES_RECEIVED(uint64_t MESSAGES_RECEIVED) {
    fbb_.AddElement<uint64_t>(COM::VT_MESSAGES_RECEIVED, MESSAGES_RECEIVED, 0);
  }
  void add_BYTES_SENT(uint64_t BYTES_SENT) {
    fbb_.AddElement<uint64_t>(COM::VT_BYTES_SENT, BYTES_SENT, 0);
  }
  void add_BYTES_RECEIVED(uint64_t BYTES_RECEIVED) {
    fbb_.AddElement<uint64_t>(COM::VT_BYTES_RECEIVED, BYTES_RECEIVED, 0);
  }
  void add_CONNECTED_NODES(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> CONNECTED_NODES) {
    fbb_.AddOffset(COM::VT_CONNECTED_NODES, CONNECTED_NODES);
  }
  void add_ACTIVE_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> ACTIVE_LINKS) {
    fbb_.AddOffset(COM::VT_ACTIVE_LINKS, ACTIVE_LINKS);
  }
  void add_LAST_UPDATE_MS(int64_t LAST_UPDATE_MS) {
    fbb_.AddElement<int64_t>(COM::VT_LAST_UPDATE_MS, LAST_UPDATE_MS, 0);
  }
  explicit COMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COM> CreateCOM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SYSTEM_ID = 0,
    uint32_t ENTITY_ID = 0,
    bool IS_TRANSMITTING = false,
    bool IS_RECEIVING = false,
    double CURRENT_FREQUENCY_HZ = 0.0,
    double CURRENT_POWER_WATTS = 0.0,
    double CURRENT_DATA_RATE_BPS = 0.0,
    uint64_t MESSAGES_SENT = 0,
    uint64_t MESSAGES_RECEIVED = 0,
    uint64_t BYTES_SENT = 0,
    uint64_t BYTES_RECEIVED = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> CONNECTED_NODES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> ACTIVE_LINKS = 0,
    int64_t LAST_UPDATE_MS = 0) {
  COMBuilder builder_(_fbb);
  builder_.add_LAST_UPDATE_MS(LAST_UPDATE_MS);
  builder_.add_BYTES_RECEIVED(BYTES_RECEIVED);
  builder_.add_BYTES_SENT(BYTES_SENT);
  builder_.add_MESSAGES_RECEIVED(MESSAGES_RECEIVED);
  builder_.add_MESSAGES_SENT(MESSAGES_SENT);
  builder_.add_CURRENT_DATA_RATE_BPS(CURRENT_DATA_RATE_BPS);
  builder_.add_CURRENT_POWER_WATTS(CURRENT_POWER_WATTS);
  builder_.add_CURRENT_FREQUENCY_HZ(CURRENT_FREQUENCY_HZ);
  builder_.add_ACTIVE_LINKS(ACTIVE_LINKS);
  builder_.add_CONNECTED_NODES(CONNECTED_NODES);
  builder_.add_ENTITY_ID(ENTITY_ID);
  builder_.add_SYSTEM_ID(SYSTEM_ID);
  builder_.add_IS_RECEIVING(IS_RECEIVING);
  builder_.add_IS_TRANSMITTING(IS_TRANSMITTING);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<COM> CreateCOMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SYSTEM_ID = 0,
    uint32_t ENTITY_ID = 0,
    bool IS_TRANSMITTING = false,
    bool IS_RECEIVING = false,
    double CURRENT_FREQUENCY_HZ = 0.0,
    double CURRENT_POWER_WATTS = 0.0,
    double CURRENT_DATA_RATE_BPS = 0.0,
    uint64_t MESSAGES_SENT = 0,
    uint64_t MESSAGES_RECEIVED = 0,
    uint64_t BYTES_SENT = 0,
    uint64_t BYTES_RECEIVED = 0,
    const std::vector<uint32_t> *CONNECTED_NODES = nullptr,
    const std::vector<int8_t> *ACTIVE_LINKS = nullptr,
    int64_t LAST_UPDATE_MS = 0) {
  auto CONNECTED_NODES__ = CONNECTED_NODES ? _fbb.CreateVector<uint32_t>(*CONNECTED_NODES) : 0;
  auto ACTIVE_LINKS__ = ACTIVE_LINKS ? _fbb.CreateVector<int8_t>(*ACTIVE_LINKS) : 0;
  return CreateCOM(
      _fbb,
      SYSTEM_ID,
      ENTITY_ID,
      IS_TRANSMITTING,
      IS_RECEIVING,
      CURRENT_FREQUENCY_HZ,
      CURRENT_POWER_WATTS,
      CURRENT_DATA_RATE_BPS,
      MESSAGES_SENT,
      MESSAGES_RECEIVED,
      BYTES_SENT,
      BYTES_RECEIVED,
      CONNECTED_NODES__,
      ACTIVE_LINKS__,
      LAST_UPDATE_MS);
}

inline const COM *GetCOM(const void *buf) {
  return ::flatbuffers::GetRoot<COM>(buf);
}

inline const COM *GetSizePrefixedCOM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<COM>(buf);
}

inline const char *COMIdentifier() {
  return "$COM";
}

inline bool COMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, COMIdentifier());
}

inline bool SizePrefixedCOMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, COMIdentifier(), true);
}

inline bool VerifyCOMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<COM>(COMIdentifier());
}

inline bool VerifySizePrefixedCOMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<COM>(COMIdentifier());
}

inline void FinishCOMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<COM> root) {
  fbb.Finish(root, COMIdentifier());
}

inline void FinishSizePrefixedCOMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<COM> root) {
  fbb.FinishSizePrefixed(root, COMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
