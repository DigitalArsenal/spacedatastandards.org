// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EME;
struct EMEBuilder;

struct EMECOLLECTION;
struct EMECOLLECTIONBuilder;

/// Encrypted Message Envelope
struct EME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENCRYPTED_BLOB = 4,
    VT_EPHEMERAL_PUBLIC_KEY = 6,
    VT_MAC = 8,
    VT_NONCE = 10,
    VT_TAG = 12,
    VT_IV = 14,
    VT_PUBLIC_KEY_IDENTIFIER = 16,
    VT_CIPHER_SUITE = 18,
    VT_KDF_PARAMETERS = 20,
    VT_ENCRYPTION_ALGORITHM_PARAMETERS = 22
  };
  /// Encrypted data blob, containing the ciphertext of the original plaintext message.
  const ::flatbuffers::Vector<uint8_t> *ENCRYPTED_BLOB() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ENCRYPTED_BLOB);
  }
  /// Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  const ::flatbuffers::String *EPHEMERAL_PUBLIC_KEY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPHEMERAL_PUBLIC_KEY);
  }
  /// Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  const ::flatbuffers::String *MAC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAC);
  }
  /// Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
  const ::flatbuffers::String *NONCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NONCE);
  }
  /// Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  const ::flatbuffers::String *TAG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  /// Initialization vector used to introduce randomness in the encryption process, enhancing security.
  const ::flatbuffers::String *IV() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IV);
  }
  /// Identifier for the public key used, aiding in recipient key management and message decryption.
  const ::flatbuffers::String *PUBLIC_KEY_IDENTIFIER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PUBLIC_KEY_IDENTIFIER);
  }
  /// Specifies the set of cryptographic algorithms used in the encryption process.
  const ::flatbuffers::String *CIPHER_SUITE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CIPHER_SUITE);
  }
  /// Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  const ::flatbuffers::String *KDF_PARAMETERS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KDF_PARAMETERS);
  }
  /// Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  const ::flatbuffers::String *ENCRYPTION_ALGORITHM_PARAMETERS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENCRYPTION_ALGORITHM_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENCRYPTED_BLOB) &&
           verifier.VerifyVector(ENCRYPTED_BLOB()) &&
           VerifyOffset(verifier, VT_EPHEMERAL_PUBLIC_KEY) &&
           verifier.VerifyString(EPHEMERAL_PUBLIC_KEY()) &&
           VerifyOffset(verifier, VT_MAC) &&
           verifier.VerifyString(MAC()) &&
           VerifyOffset(verifier, VT_NONCE) &&
           verifier.VerifyString(NONCE()) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyString(TAG()) &&
           VerifyOffset(verifier, VT_IV) &&
           verifier.VerifyString(IV()) &&
           VerifyOffset(verifier, VT_PUBLIC_KEY_IDENTIFIER) &&
           verifier.VerifyString(PUBLIC_KEY_IDENTIFIER()) &&
           VerifyOffset(verifier, VT_CIPHER_SUITE) &&
           verifier.VerifyString(CIPHER_SUITE()) &&
           VerifyOffset(verifier, VT_KDF_PARAMETERS) &&
           verifier.VerifyString(KDF_PARAMETERS()) &&
           VerifyOffset(verifier, VT_ENCRYPTION_ALGORITHM_PARAMETERS) &&
           verifier.VerifyString(ENCRYPTION_ALGORITHM_PARAMETERS()) &&
           verifier.EndTable();
  }
};

struct EMEBuilder {
  typedef EME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ENCRYPTED_BLOB(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ENCRYPTED_BLOB) {
    fbb_.AddOffset(EME::VT_ENCRYPTED_BLOB, ENCRYPTED_BLOB);
  }
  void add_EPHEMERAL_PUBLIC_KEY(::flatbuffers::Offset<::flatbuffers::String> EPHEMERAL_PUBLIC_KEY) {
    fbb_.AddOffset(EME::VT_EPHEMERAL_PUBLIC_KEY, EPHEMERAL_PUBLIC_KEY);
  }
  void add_MAC(::flatbuffers::Offset<::flatbuffers::String> MAC) {
    fbb_.AddOffset(EME::VT_MAC, MAC);
  }
  void add_NONCE(::flatbuffers::Offset<::flatbuffers::String> NONCE) {
    fbb_.AddOffset(EME::VT_NONCE, NONCE);
  }
  void add_TAG(::flatbuffers::Offset<::flatbuffers::String> TAG) {
    fbb_.AddOffset(EME::VT_TAG, TAG);
  }
  void add_IV(::flatbuffers::Offset<::flatbuffers::String> IV) {
    fbb_.AddOffset(EME::VT_IV, IV);
  }
  void add_PUBLIC_KEY_IDENTIFIER(::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY_IDENTIFIER) {
    fbb_.AddOffset(EME::VT_PUBLIC_KEY_IDENTIFIER, PUBLIC_KEY_IDENTIFIER);
  }
  void add_CIPHER_SUITE(::flatbuffers::Offset<::flatbuffers::String> CIPHER_SUITE) {
    fbb_.AddOffset(EME::VT_CIPHER_SUITE, CIPHER_SUITE);
  }
  void add_KDF_PARAMETERS(::flatbuffers::Offset<::flatbuffers::String> KDF_PARAMETERS) {
    fbb_.AddOffset(EME::VT_KDF_PARAMETERS, KDF_PARAMETERS);
  }
  void add_ENCRYPTION_ALGORITHM_PARAMETERS(::flatbuffers::Offset<::flatbuffers::String> ENCRYPTION_ALGORITHM_PARAMETERS) {
    fbb_.AddOffset(EME::VT_ENCRYPTION_ALGORITHM_PARAMETERS, ENCRYPTION_ALGORITHM_PARAMETERS);
  }
  explicit EMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EME> CreateEME(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ENCRYPTED_BLOB = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EPHEMERAL_PUBLIC_KEY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NONCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TAG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> IV = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PUBLIC_KEY_IDENTIFIER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CIPHER_SUITE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> KDF_PARAMETERS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ENCRYPTION_ALGORITHM_PARAMETERS = 0) {
  EMEBuilder builder_(_fbb);
  builder_.add_ENCRYPTION_ALGORITHM_PARAMETERS(ENCRYPTION_ALGORITHM_PARAMETERS);
  builder_.add_KDF_PARAMETERS(KDF_PARAMETERS);
  builder_.add_CIPHER_SUITE(CIPHER_SUITE);
  builder_.add_PUBLIC_KEY_IDENTIFIER(PUBLIC_KEY_IDENTIFIER);
  builder_.add_IV(IV);
  builder_.add_TAG(TAG);
  builder_.add_NONCE(NONCE);
  builder_.add_MAC(MAC);
  builder_.add_EPHEMERAL_PUBLIC_KEY(EPHEMERAL_PUBLIC_KEY);
  builder_.add_ENCRYPTED_BLOB(ENCRYPTED_BLOB);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EME> CreateEMEDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ENCRYPTED_BLOB = nullptr,
    const char *EPHEMERAL_PUBLIC_KEY = nullptr,
    const char *MAC = nullptr,
    const char *NONCE = nullptr,
    const char *TAG = nullptr,
    const char *IV = nullptr,
    const char *PUBLIC_KEY_IDENTIFIER = nullptr,
    const char *CIPHER_SUITE = nullptr,
    const char *KDF_PARAMETERS = nullptr,
    const char *ENCRYPTION_ALGORITHM_PARAMETERS = nullptr) {
  auto ENCRYPTED_BLOB__ = ENCRYPTED_BLOB ? _fbb.CreateVector<uint8_t>(*ENCRYPTED_BLOB) : 0;
  auto EPHEMERAL_PUBLIC_KEY__ = EPHEMERAL_PUBLIC_KEY ? _fbb.CreateString(EPHEMERAL_PUBLIC_KEY) : 0;
  auto MAC__ = MAC ? _fbb.CreateString(MAC) : 0;
  auto NONCE__ = NONCE ? _fbb.CreateString(NONCE) : 0;
  auto TAG__ = TAG ? _fbb.CreateString(TAG) : 0;
  auto IV__ = IV ? _fbb.CreateString(IV) : 0;
  auto PUBLIC_KEY_IDENTIFIER__ = PUBLIC_KEY_IDENTIFIER ? _fbb.CreateString(PUBLIC_KEY_IDENTIFIER) : 0;
  auto CIPHER_SUITE__ = CIPHER_SUITE ? _fbb.CreateString(CIPHER_SUITE) : 0;
  auto KDF_PARAMETERS__ = KDF_PARAMETERS ? _fbb.CreateString(KDF_PARAMETERS) : 0;
  auto ENCRYPTION_ALGORITHM_PARAMETERS__ = ENCRYPTION_ALGORITHM_PARAMETERS ? _fbb.CreateString(ENCRYPTION_ALGORITHM_PARAMETERS) : 0;
  return CreateEME(
      _fbb,
      ENCRYPTED_BLOB__,
      EPHEMERAL_PUBLIC_KEY__,
      MAC__,
      NONCE__,
      TAG__,
      IV__,
      PUBLIC_KEY_IDENTIFIER__,
      CIPHER_SUITE__,
      KDF_PARAMETERS__,
      ENCRYPTION_ALGORITHM_PARAMETERS__);
}

struct EMECOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EMECOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<EME>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EME>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct EMECOLLECTIONBuilder {
  typedef EMECOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EME>>> RECORDS) {
    fbb_.AddOffset(EMECOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit EMECOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EMECOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EMECOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EMECOLLECTION> CreateEMECOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EME>>> RECORDS = 0) {
  EMECOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EMECOLLECTION> CreateEMECOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EME>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<EME>>(*RECORDS) : 0;
  return CreateEMECOLLECTION(
      _fbb,
      RECORDS__);
}

inline const EME *GetEME(const void *buf) {
  return ::flatbuffers::GetRoot<EME>(buf);
}

inline const EME *GetSizePrefixedEME(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EME>(buf);
}

inline const char *EMEIdentifier() {
  return "$EME";
}

inline bool EMEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EMEIdentifier());
}

inline bool SizePrefixedEMEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EMEIdentifier(), true);
}

inline bool VerifyEMEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EME>(EMEIdentifier());
}

inline bool VerifySizePrefixedEMEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EME>(EMEIdentifier());
}

inline void FinishEMEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EME> root) {
  fbb.Finish(root, EMEIdentifier());
}

inline void FinishSizePrefixedEMEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EME> root) {
  fbb.FinishSizePrefixed(root, EMEIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
