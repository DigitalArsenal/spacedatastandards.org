// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct DMG;
struct DMGBuilder;

enum ModuleType : int8_t {
  ModuleType_ENGINE = 0,
  ModuleType_TRANSMISSION = 1,
  ModuleType_FUEL_TANK = 2,
  ModuleType_AMMO_RACK = 3,
  ModuleType_AMMO_FIRST_STAGE = 4,
  ModuleType_GUN_BREECH = 5,
  ModuleType_GUN_BARREL = 6,
  ModuleType_TURRET_RING = 7,
  ModuleType_TURRET_DRIVE = 8,
  ModuleType_TRACKS = 9,
  ModuleType_WHEELS = 10,
  ModuleType_SUSPENSION = 11,
  ModuleType_DRIVER_PORT = 12,
  ModuleType_OPTICS_GUNNER = 13,
  ModuleType_OPTICS_COMMANDER = 14,
  ModuleType_FCS = 15,
  ModuleType_RADIO = 16,
  ModuleType_HYDRAULICS = 17,
  ModuleType_AUTOLOADER = 18,
  ModuleType_ERA_BLOCK = 19,
  ModuleType_RADAR = 20,
  ModuleType_WING_LEFT = 21,
  ModuleType_WING_RIGHT = 22,
  ModuleType_TAIL = 23,
  ModuleType_AILERON_LEFT = 24,
  ModuleType_AILERON_RIGHT = 25,
  ModuleType_ELEVATOR = 26,
  ModuleType_RUDDER = 27,
  ModuleType_LANDING_GEAR = 28,
  ModuleType_MAIN_ROTOR = 29,
  ModuleType_TAIL_ROTOR = 30,
  ModuleType_PROPELLER = 31,
  ModuleType_BRIDGE = 32,
  ModuleType_MAGAZINE = 33,
  ModuleType_MIN = ModuleType_ENGINE,
  ModuleType_MAX = ModuleType_MAGAZINE
};

inline const ModuleType (&EnumValuesModuleType())[34] {
  static const ModuleType values[] = {
    ModuleType_ENGINE,
    ModuleType_TRANSMISSION,
    ModuleType_FUEL_TANK,
    ModuleType_AMMO_RACK,
    ModuleType_AMMO_FIRST_STAGE,
    ModuleType_GUN_BREECH,
    ModuleType_GUN_BARREL,
    ModuleType_TURRET_RING,
    ModuleType_TURRET_DRIVE,
    ModuleType_TRACKS,
    ModuleType_WHEELS,
    ModuleType_SUSPENSION,
    ModuleType_DRIVER_PORT,
    ModuleType_OPTICS_GUNNER,
    ModuleType_OPTICS_COMMANDER,
    ModuleType_FCS,
    ModuleType_RADIO,
    ModuleType_HYDRAULICS,
    ModuleType_AUTOLOADER,
    ModuleType_ERA_BLOCK,
    ModuleType_RADAR,
    ModuleType_WING_LEFT,
    ModuleType_WING_RIGHT,
    ModuleType_TAIL,
    ModuleType_AILERON_LEFT,
    ModuleType_AILERON_RIGHT,
    ModuleType_ELEVATOR,
    ModuleType_RUDDER,
    ModuleType_LANDING_GEAR,
    ModuleType_MAIN_ROTOR,
    ModuleType_TAIL_ROTOR,
    ModuleType_PROPELLER,
    ModuleType_BRIDGE,
    ModuleType_MAGAZINE
  };
  return values;
}

inline const char * const *EnumNamesModuleType() {
  static const char * const names[35] = {
    "ENGINE",
    "TRANSMISSION",
    "FUEL_TANK",
    "AMMO_RACK",
    "AMMO_FIRST_STAGE",
    "GUN_BREECH",
    "GUN_BARREL",
    "TURRET_RING",
    "TURRET_DRIVE",
    "TRACKS",
    "WHEELS",
    "SUSPENSION",
    "DRIVER_PORT",
    "OPTICS_GUNNER",
    "OPTICS_COMMANDER",
    "FCS",
    "RADIO",
    "HYDRAULICS",
    "AUTOLOADER",
    "ERA_BLOCK",
    "RADAR",
    "WING_LEFT",
    "WING_RIGHT",
    "TAIL",
    "AILERON_LEFT",
    "AILERON_RIGHT",
    "ELEVATOR",
    "RUDDER",
    "LANDING_GEAR",
    "MAIN_ROTOR",
    "TAIL_ROTOR",
    "PROPELLER",
    "BRIDGE",
    "MAGAZINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameModuleType(ModuleType e) {
  if (::flatbuffers::IsOutRange(e, ModuleType_ENGINE, ModuleType_MAGAZINE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModuleType()[index];
}

enum ModuleState : int8_t {
  ModuleState_OPERATIONAL = 0,
  ModuleState_DAMAGED = 1,
  ModuleState_CRITICAL = 2,
  ModuleState_DESTROYED = 3,
  ModuleState_REPAIRING = 4,
  ModuleState_MIN = ModuleState_OPERATIONAL,
  ModuleState_MAX = ModuleState_REPAIRING
};

inline const ModuleState (&EnumValuesModuleState())[5] {
  static const ModuleState values[] = {
    ModuleState_OPERATIONAL,
    ModuleState_DAMAGED,
    ModuleState_CRITICAL,
    ModuleState_DESTROYED,
    ModuleState_REPAIRING
  };
  return values;
}

inline const char * const *EnumNamesModuleState() {
  static const char * const names[6] = {
    "OPERATIONAL",
    "DAMAGED",
    "CRITICAL",
    "DESTROYED",
    "REPAIRING",
    nullptr
  };
  return names;
}

inline const char *EnumNameModuleState(ModuleState e) {
  if (::flatbuffers::IsOutRange(e, ModuleState_OPERATIONAL, ModuleState_REPAIRING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModuleState()[index];
}

enum CrewRole : int8_t {
  CrewRole_COMMANDER = 0,
  CrewRole_GUNNER = 1,
  CrewRole_DRIVER = 2,
  CrewRole_LOADER = 3,
  CrewRole_RADIO_OP = 4,
  CrewRole_PILOT = 5,
  CrewRole_COPILOT = 6,
  CrewRole_ENGINEER = 7,
  CrewRole_HELMSMAN = 8,
  CrewRole_MIN = CrewRole_COMMANDER,
  CrewRole_MAX = CrewRole_HELMSMAN
};

inline const CrewRole (&EnumValuesCrewRole())[9] {
  static const CrewRole values[] = {
    CrewRole_COMMANDER,
    CrewRole_GUNNER,
    CrewRole_DRIVER,
    CrewRole_LOADER,
    CrewRole_RADIO_OP,
    CrewRole_PILOT,
    CrewRole_COPILOT,
    CrewRole_ENGINEER,
    CrewRole_HELMSMAN
  };
  return values;
}

inline const char * const *EnumNamesCrewRole() {
  static const char * const names[10] = {
    "COMMANDER",
    "GUNNER",
    "DRIVER",
    "LOADER",
    "RADIO_OP",
    "PILOT",
    "COPILOT",
    "ENGINEER",
    "HELMSMAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCrewRole(CrewRole e) {
  if (::flatbuffers::IsOutRange(e, CrewRole_COMMANDER, CrewRole_HELMSMAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCrewRole()[index];
}

enum CrewState : int8_t {
  CrewState_ALIVE = 0,
  CrewState_WOUNDED = 1,
  CrewState_UNCONSCIOUS = 2,
  CrewState_DEAD = 3,
  CrewState_BAILED = 4,
  CrewState_MIN = CrewState_ALIVE,
  CrewState_MAX = CrewState_BAILED
};

inline const CrewState (&EnumValuesCrewState())[5] {
  static const CrewState values[] = {
    CrewState_ALIVE,
    CrewState_WOUNDED,
    CrewState_UNCONSCIOUS,
    CrewState_DEAD,
    CrewState_BAILED
  };
  return values;
}

inline const char * const *EnumNamesCrewState() {
  static const char * const names[6] = {
    "ALIVE",
    "WOUNDED",
    "UNCONSCIOUS",
    "DEAD",
    "BAILED",
    nullptr
  };
  return names;
}

inline const char *EnumNameCrewState(CrewState e) {
  if (::flatbuffers::IsOutRange(e, CrewState_ALIVE, CrewState_BAILED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCrewState()[index];
}

enum DestructionCause : int8_t {
  DestructionCause_NONE = 0,
  DestructionCause_AMMO_DETONATION = 1,
  DestructionCause_FUEL_FIRE = 2,
  DestructionCause_CREW_LOST = 3,
  DestructionCause_STRUCTURAL_FAILURE = 4,
  DestructionCause_FLOODING = 5,
  DestructionCause_MIN = DestructionCause_NONE,
  DestructionCause_MAX = DestructionCause_FLOODING
};

inline const DestructionCause (&EnumValuesDestructionCause())[6] {
  static const DestructionCause values[] = {
    DestructionCause_NONE,
    DestructionCause_AMMO_DETONATION,
    DestructionCause_FUEL_FIRE,
    DestructionCause_CREW_LOST,
    DestructionCause_STRUCTURAL_FAILURE,
    DestructionCause_FLOODING
  };
  return values;
}

inline const char * const *EnumNamesDestructionCause() {
  static const char * const names[7] = {
    "NONE",
    "AMMO_DETONATION",
    "FUEL_FIRE",
    "CREW_LOST",
    "STRUCTURAL_FAILURE",
    "FLOODING",
    nullptr
  };
  return names;
}

inline const char *EnumNameDestructionCause(DestructionCause e) {
  if (::flatbuffers::IsOutRange(e, DestructionCause_NONE, DestructionCause_FLOODING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDestructionCause()[index];
}

/// Damage Models
struct DMG FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DMGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OVERALL_HEALTH = 4,
    VT_MOBILITY = 6,
    VT_FIREPOWER = 8,
    VT_MODULE_COUNT = 10,
    VT_CREW_COUNT = 12,
    VT_FIRE_COUNT = 14,
    VT_FLOOD_COUNT = 16,
    VT_IS_DESTROYED = 18,
    VT_DESTRUCTION_CAUSE = 20,
    VT_EXTINGUISHERS = 22,
    VT_REPAIR_ACTIVE = 24,
    VT_RELOAD_MULTIPLIER = 26,
    VT_ACCURACY_MULTIPLIER = 28,
    VT_CREW_ALIVE = 30,
    VT_CREW_WOUNDED = 32,
    VT_RESERVED = 34
  };
  float OVERALL_HEALTH() const {
    return GetField<float>(VT_OVERALL_HEALTH, 0.0f);
  }
  float MOBILITY() const {
    return GetField<float>(VT_MOBILITY, 0.0f);
  }
  float FIREPOWER() const {
    return GetField<float>(VT_FIREPOWER, 0.0f);
  }
  uint8_t MODULE_COUNT() const {
    return GetField<uint8_t>(VT_MODULE_COUNT, 0);
  }
  uint8_t CREW_COUNT() const {
    return GetField<uint8_t>(VT_CREW_COUNT, 0);
  }
  uint8_t FIRE_COUNT() const {
    return GetField<uint8_t>(VT_FIRE_COUNT, 0);
  }
  uint8_t FLOOD_COUNT() const {
    return GetField<uint8_t>(VT_FLOOD_COUNT, 0);
  }
  uint8_t IS_DESTROYED() const {
    return GetField<uint8_t>(VT_IS_DESTROYED, 0);
  }
  uint8_t DESTRUCTION_CAUSE() const {
    return GetField<uint8_t>(VT_DESTRUCTION_CAUSE, 0);
  }
  uint8_t EXTINGUISHERS() const {
    return GetField<uint8_t>(VT_EXTINGUISHERS, 0);
  }
  uint8_t REPAIR_ACTIVE() const {
    return GetField<uint8_t>(VT_REPAIR_ACTIVE, 0);
  }
  float RELOAD_MULTIPLIER() const {
    return GetField<float>(VT_RELOAD_MULTIPLIER, 0.0f);
  }
  float ACCURACY_MULTIPLIER() const {
    return GetField<float>(VT_ACCURACY_MULTIPLIER, 0.0f);
  }
  uint8_t CREW_ALIVE() const {
    return GetField<uint8_t>(VT_CREW_ALIVE, 0);
  }
  uint8_t CREW_WOUNDED() const {
    return GetField<uint8_t>(VT_CREW_WOUNDED, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_OVERALL_HEALTH, 4) &&
           VerifyField<float>(verifier, VT_MOBILITY, 4) &&
           VerifyField<float>(verifier, VT_FIREPOWER, 4) &&
           VerifyField<uint8_t>(verifier, VT_MODULE_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_CREW_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_FIRE_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_FLOOD_COUNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_DESTROYED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DESTRUCTION_CAUSE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTINGUISHERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_REPAIR_ACTIVE, 1) &&
           VerifyField<float>(verifier, VT_RELOAD_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_ACCURACY_MULTIPLIER, 4) &&
           VerifyField<uint8_t>(verifier, VT_CREW_ALIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CREW_WOUNDED, 1) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct DMGBuilder {
  typedef DMG Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OVERALL_HEALTH(float OVERALL_HEALTH) {
    fbb_.AddElement<float>(DMG::VT_OVERALL_HEALTH, OVERALL_HEALTH, 0.0f);
  }
  void add_MOBILITY(float MOBILITY) {
    fbb_.AddElement<float>(DMG::VT_MOBILITY, MOBILITY, 0.0f);
  }
  void add_FIREPOWER(float FIREPOWER) {
    fbb_.AddElement<float>(DMG::VT_FIREPOWER, FIREPOWER, 0.0f);
  }
  void add_MODULE_COUNT(uint8_t MODULE_COUNT) {
    fbb_.AddElement<uint8_t>(DMG::VT_MODULE_COUNT, MODULE_COUNT, 0);
  }
  void add_CREW_COUNT(uint8_t CREW_COUNT) {
    fbb_.AddElement<uint8_t>(DMG::VT_CREW_COUNT, CREW_COUNT, 0);
  }
  void add_FIRE_COUNT(uint8_t FIRE_COUNT) {
    fbb_.AddElement<uint8_t>(DMG::VT_FIRE_COUNT, FIRE_COUNT, 0);
  }
  void add_FLOOD_COUNT(uint8_t FLOOD_COUNT) {
    fbb_.AddElement<uint8_t>(DMG::VT_FLOOD_COUNT, FLOOD_COUNT, 0);
  }
  void add_IS_DESTROYED(uint8_t IS_DESTROYED) {
    fbb_.AddElement<uint8_t>(DMG::VT_IS_DESTROYED, IS_DESTROYED, 0);
  }
  void add_DESTRUCTION_CAUSE(uint8_t DESTRUCTION_CAUSE) {
    fbb_.AddElement<uint8_t>(DMG::VT_DESTRUCTION_CAUSE, DESTRUCTION_CAUSE, 0);
  }
  void add_EXTINGUISHERS(uint8_t EXTINGUISHERS) {
    fbb_.AddElement<uint8_t>(DMG::VT_EXTINGUISHERS, EXTINGUISHERS, 0);
  }
  void add_REPAIR_ACTIVE(uint8_t REPAIR_ACTIVE) {
    fbb_.AddElement<uint8_t>(DMG::VT_REPAIR_ACTIVE, REPAIR_ACTIVE, 0);
  }
  void add_RELOAD_MULTIPLIER(float RELOAD_MULTIPLIER) {
    fbb_.AddElement<float>(DMG::VT_RELOAD_MULTIPLIER, RELOAD_MULTIPLIER, 0.0f);
  }
  void add_ACCURACY_MULTIPLIER(float ACCURACY_MULTIPLIER) {
    fbb_.AddElement<float>(DMG::VT_ACCURACY_MULTIPLIER, ACCURACY_MULTIPLIER, 0.0f);
  }
  void add_CREW_ALIVE(uint8_t CREW_ALIVE) {
    fbb_.AddElement<uint8_t>(DMG::VT_CREW_ALIVE, CREW_ALIVE, 0);
  }
  void add_CREW_WOUNDED(uint8_t CREW_WOUNDED) {
    fbb_.AddElement<uint8_t>(DMG::VT_CREW_WOUNDED, CREW_WOUNDED, 0);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(DMG::VT_RESERVED, RESERVED);
  }
  explicit DMGBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DMG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DMG>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DMG> CreateDMG(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float OVERALL_HEALTH = 0.0f,
    float MOBILITY = 0.0f,
    float FIREPOWER = 0.0f,
    uint8_t MODULE_COUNT = 0,
    uint8_t CREW_COUNT = 0,
    uint8_t FIRE_COUNT = 0,
    uint8_t FLOOD_COUNT = 0,
    uint8_t IS_DESTROYED = 0,
    uint8_t DESTRUCTION_CAUSE = 0,
    uint8_t EXTINGUISHERS = 0,
    uint8_t REPAIR_ACTIVE = 0,
    float RELOAD_MULTIPLIER = 0.0f,
    float ACCURACY_MULTIPLIER = 0.0f,
    uint8_t CREW_ALIVE = 0,
    uint8_t CREW_WOUNDED = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  DMGBuilder builder_(_fbb);
  builder_.add_RESERVED(RESERVED);
  builder_.add_ACCURACY_MULTIPLIER(ACCURACY_MULTIPLIER);
  builder_.add_RELOAD_MULTIPLIER(RELOAD_MULTIPLIER);
  builder_.add_FIREPOWER(FIREPOWER);
  builder_.add_MOBILITY(MOBILITY);
  builder_.add_OVERALL_HEALTH(OVERALL_HEALTH);
  builder_.add_CREW_WOUNDED(CREW_WOUNDED);
  builder_.add_CREW_ALIVE(CREW_ALIVE);
  builder_.add_REPAIR_ACTIVE(REPAIR_ACTIVE);
  builder_.add_EXTINGUISHERS(EXTINGUISHERS);
  builder_.add_DESTRUCTION_CAUSE(DESTRUCTION_CAUSE);
  builder_.add_IS_DESTROYED(IS_DESTROYED);
  builder_.add_FLOOD_COUNT(FLOOD_COUNT);
  builder_.add_FIRE_COUNT(FIRE_COUNT);
  builder_.add_CREW_COUNT(CREW_COUNT);
  builder_.add_MODULE_COUNT(MODULE_COUNT);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DMG> CreateDMGDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float OVERALL_HEALTH = 0.0f,
    float MOBILITY = 0.0f,
    float FIREPOWER = 0.0f,
    uint8_t MODULE_COUNT = 0,
    uint8_t CREW_COUNT = 0,
    uint8_t FIRE_COUNT = 0,
    uint8_t FLOOD_COUNT = 0,
    uint8_t IS_DESTROYED = 0,
    uint8_t DESTRUCTION_CAUSE = 0,
    uint8_t EXTINGUISHERS = 0,
    uint8_t REPAIR_ACTIVE = 0,
    float RELOAD_MULTIPLIER = 0.0f,
    float ACCURACY_MULTIPLIER = 0.0f,
    uint8_t CREW_ALIVE = 0,
    uint8_t CREW_WOUNDED = 0,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateDMG(
      _fbb,
      OVERALL_HEALTH,
      MOBILITY,
      FIREPOWER,
      MODULE_COUNT,
      CREW_COUNT,
      FIRE_COUNT,
      FLOOD_COUNT,
      IS_DESTROYED,
      DESTRUCTION_CAUSE,
      EXTINGUISHERS,
      REPAIR_ACTIVE,
      RELOAD_MULTIPLIER,
      ACCURACY_MULTIPLIER,
      CREW_ALIVE,
      CREW_WOUNDED,
      RESERVED__);
}

inline const DMG *GetDMG(const void *buf) {
  return ::flatbuffers::GetRoot<DMG>(buf);
}

inline const DMG *GetSizePrefixedDMG(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DMG>(buf);
}

inline const char *DMGIdentifier() {
  return "$DMG";
}

inline bool DMGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DMGIdentifier());
}

inline bool SizePrefixedDMGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DMGIdentifier(), true);
}

inline bool VerifyDMGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DMG>(DMGIdentifier());
}

inline bool VerifySizePrefixedDMGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DMG>(DMGIdentifier());
}

inline void FinishDMGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DMG> root) {
  fbb.Finish(root, DMGIdentifier());
}

inline void FinishSizePrefixedDMGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DMG> root) {
  fbb.FinishSizePrefixed(root, DMGIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
