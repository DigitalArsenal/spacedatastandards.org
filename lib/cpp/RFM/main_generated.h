// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct RFM;
struct RFMBuilder;

struct RFMCOLLECTION;
struct RFMCOLLECTIONBuilder;

enum refFrame : int8_t {
  /// Earth-Centered-Earth-Fixed (ECEF) frame: Rotates with Earth. Origin at Earth's center. X-axis towards prime meridian, Y-axis eastward, Z-axis towards North Pole. Ideal for terrestrial points.
  refFrame_ECEF = 0,
  /// International Celestial Reference Frame (ICRF): An inertial frame fixed relative to distant stars. Based on quasars. Used for precision astronomy and unaffected by Earth's rotation.
  refFrame_ICRF = 1,
  /// True Equator Mean Equinox (TEME): Used in SGP4 model for satellite tracking. Accounts for Earth's precession and nutation. Dynamic frame useful for orbit prediction.
  refFrame_TEME = 2,
  /// East-North-Up (ENU): Local tangent plane system for surface points. "East" eastward, "North" northward, "Up" perpendicular to Earth's surface. Suited for stationary or slow-moving objects at low altitudes.
  refFrame_ENU = 3,
  /// North-East-Down (NED): Common in aviation and navigation. "North" northward, "East" eastward, "Down" towards Earth's center. Aligns with gravity, intuitive for aircraft and vehicles.
  refFrame_NED = 4,
  /// North-East-Up (NEU): Similar to NED but "Up" axis is opposite to gravity. Suited for applications preferring a conventional "Up" direction.
  refFrame_NEU = 5,
  /// Radial-Intrack-Cross-track (RIC): Aligned with spacecraft's UVW system. "Radial" axis towards spacecraft, "In-track" perpendicular to radial and cross-track, "Cross-track" normal to orbit plane. Used for spacecraft orientation and tracking.
  refFrame_RIC = 6,
  /// Earth Mean Equator and Equinox of J2000 (J2000): An Earth-Centered Inertial (ECI) frame defined by Earth's mean equator and equinox at the start of the year 2000. Fixed relative to distant stars, used for celestial mechanics and space navigation.
  refFrame_J2000 = 7,
  /// Geocentric Celestial Reference Frame
  refFrame_GCRF = 8,
  /// Greenwich Rotating Coordinates
  refFrame_GRC = 9,
  /// International Terrestrial Reference Frame 2000
  refFrame_ITRF2000 = 10,
  /// International Terrestrial Reference Frame 1993
  refFrame_ITRF93 = 11,
  /// International Terrestrial Reference Frame 1997
  refFrame_ITRF97 = 12,
  /// True of Date, Rotating
  refFrame_TDR = 13,
  /// True of Date
  refFrame_TOD = 14,
  /// Radial, Transverse, Normal
  refFrame_RTN = 15,
  /// Transverse, Velocity, Normal
  refFrame_TVN = 16,
  /// Vehicle-Body-Local-Horizontal (VVLH): An orbit reference frame with X-axis pointing from the center of the central body to the vehicle, Z-axis oppoOBSERVER to the orbital angular momentum vector, and Y-axis completing the right-handed system.
  refFrame_VVLH = 17,
  /// Vehicle-Local-Vertical-Local-Horizontal (VLVH): An orbit reference frame similar to VVLH, often used in close proximity operations or surface-oriented missions.
  refFrame_VLVH = 18,
  /// Local Tangent Plane (LTP): A local, surface-fixed reference frame often used for terrestrial applications, aligned with the local horizon.
  refFrame_LTP = 19,
  /// Local Vertical-Local Horizontal (LVLH): An orbit reference frame with the Z-axis pointing towards the center of the central body (oppoOBSERVER to local vertical), the X-axis in the velocity direction (local horizontal), and the Y-axis completing the right-hand system.
  refFrame_LVLH = 20,
  /// Polar-North-East (PNE): A variation of local coordinate systems typically used in polar regions, with axes aligned toward the geographic North Pole, Eastward, and perpendicular to the Earth's surface.
  refFrame_PNE = 21,
  /// Body-Fixed Reference Frame (BRF): A reference frame fixed to the body of a spacecraft or celestial object, oriented according to the body's principal axes.
  refFrame_BRF = 22,
  /// Another name for 'Radial, Transverse, Normal'
  refFrame_RSW = 23,
  /// A local orbital coordinate frame
  refFrame_TNW = 24,
  /// Radial, Intrack, Cross-track (UVW): An orbital frame used to describe the motion of a satellite relative to its orbit, with axes aligned radially, along-track, and cross-track.
  refFrame_UVW = 25,
  refFrame_MIN = refFrame_ECEF,
  refFrame_MAX = refFrame_UVW
};

inline const refFrame (&EnumValuesrefFrame())[26] {
  static const refFrame values[] = {
    refFrame_ECEF,
    refFrame_ICRF,
    refFrame_TEME,
    refFrame_ENU,
    refFrame_NED,
    refFrame_NEU,
    refFrame_RIC,
    refFrame_J2000,
    refFrame_GCRF,
    refFrame_GRC,
    refFrame_ITRF2000,
    refFrame_ITRF93,
    refFrame_ITRF97,
    refFrame_TDR,
    refFrame_TOD,
    refFrame_RTN,
    refFrame_TVN,
    refFrame_VVLH,
    refFrame_VLVH,
    refFrame_LTP,
    refFrame_LVLH,
    refFrame_PNE,
    refFrame_BRF,
    refFrame_RSW,
    refFrame_TNW,
    refFrame_UVW
  };
  return values;
}

inline const char * const *EnumNamesrefFrame() {
  static const char * const names[27] = {
    "ECEF",
    "ICRF",
    "TEME",
    "ENU",
    "NED",
    "NEU",
    "RIC",
    "J2000",
    "GCRF",
    "GRC",
    "ITRF2000",
    "ITRF93",
    "ITRF97",
    "TDR",
    "TOD",
    "RTN",
    "TVN",
    "VVLH",
    "VLVH",
    "LTP",
    "LVLH",
    "PNE",
    "BRF",
    "RSW",
    "TNW",
    "UVW",
    nullptr
  };
  return names;
}

inline const char *EnumNamerefFrame(refFrame e) {
  if (::flatbuffers::IsOutRange(e, refFrame_ECEF, refFrame_UVW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesrefFrame()[index];
}

/// Reference Frame Message
struct RFM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RFMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REFERENCE_FRAME = 4
  };
  refFrame REFERENCE_FRAME() const {
    return static_cast<refFrame>(GetField<int8_t>(VT_REFERENCE_FRAME, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REFERENCE_FRAME, 1) &&
           verifier.EndTable();
  }
};

struct RFMBuilder {
  typedef RFM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_REFERENCE_FRAME(refFrame REFERENCE_FRAME) {
    fbb_.AddElement<int8_t>(RFM::VT_REFERENCE_FRAME, static_cast<int8_t>(REFERENCE_FRAME), 0);
  }
  explicit RFMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RFM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RFM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RFM> CreateRFM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    refFrame REFERENCE_FRAME = refFrame_ECEF) {
  RFMBuilder builder_(_fbb);
  builder_.add_REFERENCE_FRAME(REFERENCE_FRAME);
  return builder_.Finish();
}

struct RFMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RFMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<RFM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<RFM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct RFMCOLLECTIONBuilder {
  typedef RFMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RFM>>> RECORDS) {
    fbb_.AddOffset(RFMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit RFMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RFMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RFMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RFMCOLLECTION> CreateRFMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<RFM>>> RECORDS = 0) {
  RFMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RFMCOLLECTION> CreateRFMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<RFM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<RFM>>(*RECORDS) : 0;
  return CreateRFMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const RFM *GetRFM(const void *buf) {
  return ::flatbuffers::GetRoot<RFM>(buf);
}

inline const RFM *GetSizePrefixedRFM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RFM>(buf);
}

inline const char *RFMIdentifier() {
  return "$RFM";
}

inline bool RFMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RFMIdentifier());
}

inline bool SizePrefixedRFMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RFMIdentifier(), true);
}

inline bool VerifyRFMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RFM>(RFMIdentifier());
}

inline bool VerifySizePrefixedRFMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RFM>(RFMIdentifier());
}

inline void FinishRFMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RFM> root) {
  fbb.Finish(root, RFMIdentifier());
}

inline void FinishSizePrefixedRFMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RFM> root) {
  fbb.FinishSizePrefixed(root, RFMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
