// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"

struct LDM;
struct LDMBuilder;

struct LDMCOLLECTION;
struct LDMCOLLECTIONBuilder;

/// Launch Data Message
struct LDM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LDMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SITE = 4,
    VT_AZIMUTH = 6,
    VT_REFERENCES = 8,
    VT_AGENCY_NAME = 10,
    VT_POINTS_OF_CONTACT = 12,
    VT_OPERATIONS_POINTS_OF_CONTACT = 14,
    VT_NET = 16,
    VT_ROCKET_CONFIGURATION = 18,
    VT_MISSION_NAME = 20,
    VT_MISSION_DESCRIPTION = 22,
    VT_MISSION_TYPE = 24,
    VT_ORBIT_TYPE = 26,
    VT_WEATHER_CONDITIONS = 28,
    VT_LAUNCH_STATUS = 30,
    VT_WEBCAST_URL = 32,
    VT_MEDIA_LINKS = 34,
    VT_EARLIEST_LAUNCH_TIMES = 36,
    VT_LATEST_LAUNCH_TIMES = 38,
    VT_LCOLA_WINDOW_CLOSURES = 40,
    VT_OBJECTS = 42,
    VT_TRACKING_REQUIREMENTS = 44,
    VT_COLA_SCREEN_DURATION = 46,
    VT_PROBABILITY_OF_COLLISION_THRESHOLD = 48,
    VT_COLA_RUNS_REQUIRED = 50,
    VT_COLA_POINTS_OF_CONTACT = 52,
    VT_ORBITAL_PARAMETERS = 54,
    VT_BURN_OUT_VECTORS = 56
  };
  /// Launch Site Information
  const SIT *SITE() const {
    return GetPointer<const SIT *>(VT_SITE);
  }
  /// Azimuth at Launch (in Degrees)
  float AZIMUTH() const {
    return GetField<float>(VT_AZIMUTH, 0.0f);
  }
  /// References for Launch Data
  const ::flatbuffers::String *REFERENCES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REFERENCES);
  }
  /// Launching Agency Name
  const ::flatbuffers::String *AGENCY_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AGENCY_NAME);
  }
  /// Points of Contact for Launch
  const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *POINTS_OF_CONTACT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *>(VT_POINTS_OF_CONTACT);
  }
  /// Operations Points of Contact for Launch
  const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *OPERATIONS_POINTS_OF_CONTACT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *>(VT_OPERATIONS_POINTS_OF_CONTACT);
  }
  /// Net Launch Time (UTC Format)
  const ::flatbuffers::String *NET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NET);
  }
  /// Rocket Configuration Details
  const ROC *ROCKET_CONFIGURATION() const {
    return GetPointer<const ROC *>(VT_ROCKET_CONFIGURATION);
  }
  /// Mission Name
  const ::flatbuffers::String *MISSION_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSION_NAME);
  }
  /// Description of the Mission
  const ::flatbuffers::String *MISSION_DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSION_DESCRIPTION);
  }
  /// Type of the Mission (e.g., Test Flight, Satellite Deployment)
  const ::flatbuffers::String *MISSION_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSION_TYPE);
  }
  /// Target Orbit Type (e.g., LEO, GEO)
  const ::flatbuffers::String *ORBIT_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBIT_TYPE);
  }
  /// Weather and Environmental Conditions at Launch
  const ::flatbuffers::String *WEATHER_CONDITIONS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHER_CONDITIONS);
  }
  /// Launch Outcome and Status (e.g., Successful, Failed)
  const ::flatbuffers::String *LAUNCH_STATUS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCH_STATUS);
  }
  /// Webcast URL for the Launch
  const ::flatbuffers::String *WEBCAST_URL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEBCAST_URL);
  }
  /// Media Links Related to the Launch
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MEDIA_LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MEDIA_LINKS);
  }
  /// Earliest Possible Launch Times
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *EARLIEST_LAUNCH_TIMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_EARLIEST_LAUNCH_TIMES);
  }
  /// Latest Possible Launch Times
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *LATEST_LAUNCH_TIMES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LATEST_LAUNCH_TIMES);
  }
  /// Launch Collision Avoidance Information
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *LCOLA_WINDOW_CLOSURES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LCOLA_WINDOW_CLOSURES);
  }
  /// Payload Information (Catalog Entities)
  const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *OBJECTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CAT>> *>(VT_OBJECTS);
  }
  /// Tracking and Collision Avoidance Requirements
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *TRACKING_REQUIREMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TRACKING_REQUIREMENTS);
  }
  /// Duration of Collision Avoidance Screen (in Seconds)
  const ::flatbuffers::String *COLA_SCREEN_DURATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLA_SCREEN_DURATION);
  }
  /// Probability of Collision Threshold (Percentage)
  const ::flatbuffers::String *PROBABILITY_OF_COLLISION_THRESHOLD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROBABILITY_OF_COLLISION_THRESHOLD);
  }
  /// Number of Required Collision Avoidance Runs
  const ::flatbuffers::String *COLA_RUNS_REQUIRED() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLA_RUNS_REQUIRED);
  }
  /// Points of Contact for Collision Avoidance
  const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *COLA_POINTS_OF_CONTACT() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EPM>> *>(VT_COLA_POINTS_OF_CONTACT);
  }
  /// Orbital Parameters of the Launch
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ORBITAL_PARAMETERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ORBITAL_PARAMETERS);
  }
  /// Burn Out Vectors for the Launch
  const ::flatbuffers::Vector<::flatbuffers::Offset<BOV>> *BURN_OUT_VECTORS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BOV>> *>(VT_BURN_OUT_VECTORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SITE) &&
           verifier.VerifyTable(SITE()) &&
           VerifyField<float>(verifier, VT_AZIMUTH, 4) &&
           VerifyOffset(verifier, VT_REFERENCES) &&
           verifier.VerifyString(REFERENCES()) &&
           VerifyOffset(verifier, VT_AGENCY_NAME) &&
           verifier.VerifyString(AGENCY_NAME()) &&
           VerifyOffset(verifier, VT_POINTS_OF_CONTACT) &&
           verifier.VerifyVector(POINTS_OF_CONTACT()) &&
           verifier.VerifyVectorOfTables(POINTS_OF_CONTACT()) &&
           VerifyOffset(verifier, VT_OPERATIONS_POINTS_OF_CONTACT) &&
           verifier.VerifyVector(OPERATIONS_POINTS_OF_CONTACT()) &&
           verifier.VerifyVectorOfTables(OPERATIONS_POINTS_OF_CONTACT()) &&
           VerifyOffset(verifier, VT_NET) &&
           verifier.VerifyString(NET()) &&
           VerifyOffset(verifier, VT_ROCKET_CONFIGURATION) &&
           verifier.VerifyTable(ROCKET_CONFIGURATION()) &&
           VerifyOffset(verifier, VT_MISSION_NAME) &&
           verifier.VerifyString(MISSION_NAME()) &&
           VerifyOffset(verifier, VT_MISSION_DESCRIPTION) &&
           verifier.VerifyString(MISSION_DESCRIPTION()) &&
           VerifyOffset(verifier, VT_MISSION_TYPE) &&
           verifier.VerifyString(MISSION_TYPE()) &&
           VerifyOffset(verifier, VT_ORBIT_TYPE) &&
           verifier.VerifyString(ORBIT_TYPE()) &&
           VerifyOffset(verifier, VT_WEATHER_CONDITIONS) &&
           verifier.VerifyString(WEATHER_CONDITIONS()) &&
           VerifyOffset(verifier, VT_LAUNCH_STATUS) &&
           verifier.VerifyString(LAUNCH_STATUS()) &&
           VerifyOffset(verifier, VT_WEBCAST_URL) &&
           verifier.VerifyString(WEBCAST_URL()) &&
           VerifyOffset(verifier, VT_MEDIA_LINKS) &&
           verifier.VerifyVector(MEDIA_LINKS()) &&
           verifier.VerifyVectorOfStrings(MEDIA_LINKS()) &&
           VerifyOffset(verifier, VT_EARLIEST_LAUNCH_TIMES) &&
           verifier.VerifyVector(EARLIEST_LAUNCH_TIMES()) &&
           verifier.VerifyVectorOfStrings(EARLIEST_LAUNCH_TIMES()) &&
           VerifyOffset(verifier, VT_LATEST_LAUNCH_TIMES) &&
           verifier.VerifyVector(LATEST_LAUNCH_TIMES()) &&
           verifier.VerifyVectorOfStrings(LATEST_LAUNCH_TIMES()) &&
           VerifyOffset(verifier, VT_LCOLA_WINDOW_CLOSURES) &&
           verifier.VerifyVector(LCOLA_WINDOW_CLOSURES()) &&
           verifier.VerifyVectorOfStrings(LCOLA_WINDOW_CLOSURES()) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(OBJECTS()) &&
           verifier.VerifyVectorOfTables(OBJECTS()) &&
           VerifyOffset(verifier, VT_TRACKING_REQUIREMENTS) &&
           verifier.VerifyVector(TRACKING_REQUIREMENTS()) &&
           verifier.VerifyVectorOfStrings(TRACKING_REQUIREMENTS()) &&
           VerifyOffset(verifier, VT_COLA_SCREEN_DURATION) &&
           verifier.VerifyString(COLA_SCREEN_DURATION()) &&
           VerifyOffset(verifier, VT_PROBABILITY_OF_COLLISION_THRESHOLD) &&
           verifier.VerifyString(PROBABILITY_OF_COLLISION_THRESHOLD()) &&
           VerifyOffset(verifier, VT_COLA_RUNS_REQUIRED) &&
           verifier.VerifyString(COLA_RUNS_REQUIRED()) &&
           VerifyOffset(verifier, VT_COLA_POINTS_OF_CONTACT) &&
           verifier.VerifyVector(COLA_POINTS_OF_CONTACT()) &&
           verifier.VerifyVectorOfTables(COLA_POINTS_OF_CONTACT()) &&
           VerifyOffset(verifier, VT_ORBITAL_PARAMETERS) &&
           verifier.VerifyVector(ORBITAL_PARAMETERS()) &&
           verifier.VerifyVectorOfStrings(ORBITAL_PARAMETERS()) &&
           VerifyOffset(verifier, VT_BURN_OUT_VECTORS) &&
           verifier.VerifyVector(BURN_OUT_VECTORS()) &&
           verifier.VerifyVectorOfTables(BURN_OUT_VECTORS()) &&
           verifier.EndTable();
  }
};

struct LDMBuilder {
  typedef LDM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SITE(::flatbuffers::Offset<SIT> SITE) {
    fbb_.AddOffset(LDM::VT_SITE, SITE);
  }
  void add_AZIMUTH(float AZIMUTH) {
    fbb_.AddElement<float>(LDM::VT_AZIMUTH, AZIMUTH, 0.0f);
  }
  void add_REFERENCES(::flatbuffers::Offset<::flatbuffers::String> REFERENCES) {
    fbb_.AddOffset(LDM::VT_REFERENCES, REFERENCES);
  }
  void add_AGENCY_NAME(::flatbuffers::Offset<::flatbuffers::String> AGENCY_NAME) {
    fbb_.AddOffset(LDM::VT_AGENCY_NAME, AGENCY_NAME);
  }
  void add_POINTS_OF_CONTACT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> POINTS_OF_CONTACT) {
    fbb_.AddOffset(LDM::VT_POINTS_OF_CONTACT, POINTS_OF_CONTACT);
  }
  void add_OPERATIONS_POINTS_OF_CONTACT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> OPERATIONS_POINTS_OF_CONTACT) {
    fbb_.AddOffset(LDM::VT_OPERATIONS_POINTS_OF_CONTACT, OPERATIONS_POINTS_OF_CONTACT);
  }
  void add_NET(::flatbuffers::Offset<::flatbuffers::String> NET) {
    fbb_.AddOffset(LDM::VT_NET, NET);
  }
  void add_ROCKET_CONFIGURATION(::flatbuffers::Offset<ROC> ROCKET_CONFIGURATION) {
    fbb_.AddOffset(LDM::VT_ROCKET_CONFIGURATION, ROCKET_CONFIGURATION);
  }
  void add_MISSION_NAME(::flatbuffers::Offset<::flatbuffers::String> MISSION_NAME) {
    fbb_.AddOffset(LDM::VT_MISSION_NAME, MISSION_NAME);
  }
  void add_MISSION_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> MISSION_DESCRIPTION) {
    fbb_.AddOffset(LDM::VT_MISSION_DESCRIPTION, MISSION_DESCRIPTION);
  }
  void add_MISSION_TYPE(::flatbuffers::Offset<::flatbuffers::String> MISSION_TYPE) {
    fbb_.AddOffset(LDM::VT_MISSION_TYPE, MISSION_TYPE);
  }
  void add_ORBIT_TYPE(::flatbuffers::Offset<::flatbuffers::String> ORBIT_TYPE) {
    fbb_.AddOffset(LDM::VT_ORBIT_TYPE, ORBIT_TYPE);
  }
  void add_WEATHER_CONDITIONS(::flatbuffers::Offset<::flatbuffers::String> WEATHER_CONDITIONS) {
    fbb_.AddOffset(LDM::VT_WEATHER_CONDITIONS, WEATHER_CONDITIONS);
  }
  void add_LAUNCH_STATUS(::flatbuffers::Offset<::flatbuffers::String> LAUNCH_STATUS) {
    fbb_.AddOffset(LDM::VT_LAUNCH_STATUS, LAUNCH_STATUS);
  }
  void add_WEBCAST_URL(::flatbuffers::Offset<::flatbuffers::String> WEBCAST_URL) {
    fbb_.AddOffset(LDM::VT_WEBCAST_URL, WEBCAST_URL);
  }
  void add_MEDIA_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MEDIA_LINKS) {
    fbb_.AddOffset(LDM::VT_MEDIA_LINKS, MEDIA_LINKS);
  }
  void add_EARLIEST_LAUNCH_TIMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> EARLIEST_LAUNCH_TIMES) {
    fbb_.AddOffset(LDM::VT_EARLIEST_LAUNCH_TIMES, EARLIEST_LAUNCH_TIMES);
  }
  void add_LATEST_LAUNCH_TIMES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LATEST_LAUNCH_TIMES) {
    fbb_.AddOffset(LDM::VT_LATEST_LAUNCH_TIMES, LATEST_LAUNCH_TIMES);
  }
  void add_LCOLA_WINDOW_CLOSURES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LCOLA_WINDOW_CLOSURES) {
    fbb_.AddOffset(LDM::VT_LCOLA_WINDOW_CLOSURES, LCOLA_WINDOW_CLOSURES);
  }
  void add_OBJECTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> OBJECTS) {
    fbb_.AddOffset(LDM::VT_OBJECTS, OBJECTS);
  }
  void add_TRACKING_REQUIREMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TRACKING_REQUIREMENTS) {
    fbb_.AddOffset(LDM::VT_TRACKING_REQUIREMENTS, TRACKING_REQUIREMENTS);
  }
  void add_COLA_SCREEN_DURATION(::flatbuffers::Offset<::flatbuffers::String> COLA_SCREEN_DURATION) {
    fbb_.AddOffset(LDM::VT_COLA_SCREEN_DURATION, COLA_SCREEN_DURATION);
  }
  void add_PROBABILITY_OF_COLLISION_THRESHOLD(::flatbuffers::Offset<::flatbuffers::String> PROBABILITY_OF_COLLISION_THRESHOLD) {
    fbb_.AddOffset(LDM::VT_PROBABILITY_OF_COLLISION_THRESHOLD, PROBABILITY_OF_COLLISION_THRESHOLD);
  }
  void add_COLA_RUNS_REQUIRED(::flatbuffers::Offset<::flatbuffers::String> COLA_RUNS_REQUIRED) {
    fbb_.AddOffset(LDM::VT_COLA_RUNS_REQUIRED, COLA_RUNS_REQUIRED);
  }
  void add_COLA_POINTS_OF_CONTACT(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> COLA_POINTS_OF_CONTACT) {
    fbb_.AddOffset(LDM::VT_COLA_POINTS_OF_CONTACT, COLA_POINTS_OF_CONTACT);
  }
  void add_ORBITAL_PARAMETERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ORBITAL_PARAMETERS) {
    fbb_.AddOffset(LDM::VT_ORBITAL_PARAMETERS, ORBITAL_PARAMETERS);
  }
  void add_BURN_OUT_VECTORS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BOV>>> BURN_OUT_VECTORS) {
    fbb_.AddOffset(LDM::VT_BURN_OUT_VECTORS, BURN_OUT_VECTORS);
  }
  explicit LDMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LDM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LDM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LDM> CreateLDM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SIT> SITE = 0,
    float AZIMUTH = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> REFERENCES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AGENCY_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> POINTS_OF_CONTACT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> OPERATIONS_POINTS_OF_CONTACT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NET = 0,
    ::flatbuffers::Offset<ROC> ROCKET_CONFIGURATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MISSION_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MISSION_DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MISSION_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORBIT_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> WEATHER_CONDITIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAUNCH_STATUS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> WEBCAST_URL = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MEDIA_LINKS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> EARLIEST_LAUNCH_TIMES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LATEST_LAUNCH_TIMES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LCOLA_WINDOW_CLOSURES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CAT>>> OBJECTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TRACKING_REQUIREMENTS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COLA_SCREEN_DURATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROBABILITY_OF_COLLISION_THRESHOLD = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COLA_RUNS_REQUIRED = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EPM>>> COLA_POINTS_OF_CONTACT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ORBITAL_PARAMETERS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BOV>>> BURN_OUT_VECTORS = 0) {
  LDMBuilder builder_(_fbb);
  builder_.add_BURN_OUT_VECTORS(BURN_OUT_VECTORS);
  builder_.add_ORBITAL_PARAMETERS(ORBITAL_PARAMETERS);
  builder_.add_COLA_POINTS_OF_CONTACT(COLA_POINTS_OF_CONTACT);
  builder_.add_COLA_RUNS_REQUIRED(COLA_RUNS_REQUIRED);
  builder_.add_PROBABILITY_OF_COLLISION_THRESHOLD(PROBABILITY_OF_COLLISION_THRESHOLD);
  builder_.add_COLA_SCREEN_DURATION(COLA_SCREEN_DURATION);
  builder_.add_TRACKING_REQUIREMENTS(TRACKING_REQUIREMENTS);
  builder_.add_OBJECTS(OBJECTS);
  builder_.add_LCOLA_WINDOW_CLOSURES(LCOLA_WINDOW_CLOSURES);
  builder_.add_LATEST_LAUNCH_TIMES(LATEST_LAUNCH_TIMES);
  builder_.add_EARLIEST_LAUNCH_TIMES(EARLIEST_LAUNCH_TIMES);
  builder_.add_MEDIA_LINKS(MEDIA_LINKS);
  builder_.add_WEBCAST_URL(WEBCAST_URL);
  builder_.add_LAUNCH_STATUS(LAUNCH_STATUS);
  builder_.add_WEATHER_CONDITIONS(WEATHER_CONDITIONS);
  builder_.add_ORBIT_TYPE(ORBIT_TYPE);
  builder_.add_MISSION_TYPE(MISSION_TYPE);
  builder_.add_MISSION_DESCRIPTION(MISSION_DESCRIPTION);
  builder_.add_MISSION_NAME(MISSION_NAME);
  builder_.add_ROCKET_CONFIGURATION(ROCKET_CONFIGURATION);
  builder_.add_NET(NET);
  builder_.add_OPERATIONS_POINTS_OF_CONTACT(OPERATIONS_POINTS_OF_CONTACT);
  builder_.add_POINTS_OF_CONTACT(POINTS_OF_CONTACT);
  builder_.add_AGENCY_NAME(AGENCY_NAME);
  builder_.add_REFERENCES(REFERENCES);
  builder_.add_AZIMUTH(AZIMUTH);
  builder_.add_SITE(SITE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LDM> CreateLDMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SIT> SITE = 0,
    float AZIMUTH = 0.0f,
    const char *REFERENCES = nullptr,
    const char *AGENCY_NAME = nullptr,
    const std::vector<::flatbuffers::Offset<EPM>> *POINTS_OF_CONTACT = nullptr,
    const std::vector<::flatbuffers::Offset<EPM>> *OPERATIONS_POINTS_OF_CONTACT = nullptr,
    const char *NET = nullptr,
    ::flatbuffers::Offset<ROC> ROCKET_CONFIGURATION = 0,
    const char *MISSION_NAME = nullptr,
    const char *MISSION_DESCRIPTION = nullptr,
    const char *MISSION_TYPE = nullptr,
    const char *ORBIT_TYPE = nullptr,
    const char *WEATHER_CONDITIONS = nullptr,
    const char *LAUNCH_STATUS = nullptr,
    const char *WEBCAST_URL = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MEDIA_LINKS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *EARLIEST_LAUNCH_TIMES = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *LATEST_LAUNCH_TIMES = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *LCOLA_WINDOW_CLOSURES = nullptr,
    const std::vector<::flatbuffers::Offset<CAT>> *OBJECTS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *TRACKING_REQUIREMENTS = nullptr,
    const char *COLA_SCREEN_DURATION = nullptr,
    const char *PROBABILITY_OF_COLLISION_THRESHOLD = nullptr,
    const char *COLA_RUNS_REQUIRED = nullptr,
    const std::vector<::flatbuffers::Offset<EPM>> *COLA_POINTS_OF_CONTACT = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ORBITAL_PARAMETERS = nullptr,
    const std::vector<::flatbuffers::Offset<BOV>> *BURN_OUT_VECTORS = nullptr) {
  auto REFERENCES__ = REFERENCES ? _fbb.CreateString(REFERENCES) : 0;
  auto AGENCY_NAME__ = AGENCY_NAME ? _fbb.CreateString(AGENCY_NAME) : 0;
  auto POINTS_OF_CONTACT__ = POINTS_OF_CONTACT ? _fbb.CreateVector<::flatbuffers::Offset<EPM>>(*POINTS_OF_CONTACT) : 0;
  auto OPERATIONS_POINTS_OF_CONTACT__ = OPERATIONS_POINTS_OF_CONTACT ? _fbb.CreateVector<::flatbuffers::Offset<EPM>>(*OPERATIONS_POINTS_OF_CONTACT) : 0;
  auto NET__ = NET ? _fbb.CreateString(NET) : 0;
  auto MISSION_NAME__ = MISSION_NAME ? _fbb.CreateString(MISSION_NAME) : 0;
  auto MISSION_DESCRIPTION__ = MISSION_DESCRIPTION ? _fbb.CreateString(MISSION_DESCRIPTION) : 0;
  auto MISSION_TYPE__ = MISSION_TYPE ? _fbb.CreateString(MISSION_TYPE) : 0;
  auto ORBIT_TYPE__ = ORBIT_TYPE ? _fbb.CreateString(ORBIT_TYPE) : 0;
  auto WEATHER_CONDITIONS__ = WEATHER_CONDITIONS ? _fbb.CreateString(WEATHER_CONDITIONS) : 0;
  auto LAUNCH_STATUS__ = LAUNCH_STATUS ? _fbb.CreateString(LAUNCH_STATUS) : 0;
  auto WEBCAST_URL__ = WEBCAST_URL ? _fbb.CreateString(WEBCAST_URL) : 0;
  auto MEDIA_LINKS__ = MEDIA_LINKS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MEDIA_LINKS) : 0;
  auto EARLIEST_LAUNCH_TIMES__ = EARLIEST_LAUNCH_TIMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*EARLIEST_LAUNCH_TIMES) : 0;
  auto LATEST_LAUNCH_TIMES__ = LATEST_LAUNCH_TIMES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*LATEST_LAUNCH_TIMES) : 0;
  auto LCOLA_WINDOW_CLOSURES__ = LCOLA_WINDOW_CLOSURES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*LCOLA_WINDOW_CLOSURES) : 0;
  auto OBJECTS__ = OBJECTS ? _fbb.CreateVector<::flatbuffers::Offset<CAT>>(*OBJECTS) : 0;
  auto TRACKING_REQUIREMENTS__ = TRACKING_REQUIREMENTS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*TRACKING_REQUIREMENTS) : 0;
  auto COLA_SCREEN_DURATION__ = COLA_SCREEN_DURATION ? _fbb.CreateString(COLA_SCREEN_DURATION) : 0;
  auto PROBABILITY_OF_COLLISION_THRESHOLD__ = PROBABILITY_OF_COLLISION_THRESHOLD ? _fbb.CreateString(PROBABILITY_OF_COLLISION_THRESHOLD) : 0;
  auto COLA_RUNS_REQUIRED__ = COLA_RUNS_REQUIRED ? _fbb.CreateString(COLA_RUNS_REQUIRED) : 0;
  auto COLA_POINTS_OF_CONTACT__ = COLA_POINTS_OF_CONTACT ? _fbb.CreateVector<::flatbuffers::Offset<EPM>>(*COLA_POINTS_OF_CONTACT) : 0;
  auto ORBITAL_PARAMETERS__ = ORBITAL_PARAMETERS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ORBITAL_PARAMETERS) : 0;
  auto BURN_OUT_VECTORS__ = BURN_OUT_VECTORS ? _fbb.CreateVector<::flatbuffers::Offset<BOV>>(*BURN_OUT_VECTORS) : 0;
  return CreateLDM(
      _fbb,
      SITE,
      AZIMUTH,
      REFERENCES__,
      AGENCY_NAME__,
      POINTS_OF_CONTACT__,
      OPERATIONS_POINTS_OF_CONTACT__,
      NET__,
      ROCKET_CONFIGURATION,
      MISSION_NAME__,
      MISSION_DESCRIPTION__,
      MISSION_TYPE__,
      ORBIT_TYPE__,
      WEATHER_CONDITIONS__,
      LAUNCH_STATUS__,
      WEBCAST_URL__,
      MEDIA_LINKS__,
      EARLIEST_LAUNCH_TIMES__,
      LATEST_LAUNCH_TIMES__,
      LCOLA_WINDOW_CLOSURES__,
      OBJECTS__,
      TRACKING_REQUIREMENTS__,
      COLA_SCREEN_DURATION__,
      PROBABILITY_OF_COLLISION_THRESHOLD__,
      COLA_RUNS_REQUIRED__,
      COLA_POINTS_OF_CONTACT__,
      ORBITAL_PARAMETERS__,
      BURN_OUT_VECTORS__);
}

struct LDMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LDMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  /// Collection of LDM Records
  const ::flatbuffers::Vector<::flatbuffers::Offset<LDM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<LDM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct LDMCOLLECTIONBuilder {
  typedef LDMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LDM>>> RECORDS) {
    fbb_.AddOffset(LDMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit LDMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LDMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LDMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LDMCOLLECTION> CreateLDMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<LDM>>> RECORDS = 0) {
  LDMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LDMCOLLECTION> CreateLDMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<LDM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<LDM>>(*RECORDS) : 0;
  return CreateLDMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const LDMCOLLECTION *GetLDMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetRoot<LDMCOLLECTION>(buf);
}

inline const LDMCOLLECTION *GetSizePrefixedLDMCOLLECTION(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<LDMCOLLECTION>(buf);
}

inline const char *LDMCOLLECTIONIdentifier() {
  return "$LDM";
}

inline bool LDMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LDMCOLLECTIONIdentifier());
}

inline bool SizePrefixedLDMCOLLECTIONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, LDMCOLLECTIONIdentifier(), true);
}

inline bool VerifyLDMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<LDMCOLLECTION>(LDMCOLLECTIONIdentifier());
}

inline bool VerifySizePrefixedLDMCOLLECTIONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<LDMCOLLECTION>(LDMCOLLECTIONIdentifier());
}

inline void FinishLDMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LDMCOLLECTION> root) {
  fbb.Finish(root, LDMCOLLECTIONIdentifier());
}

inline void FinishSizePrefixedLDMCOLLECTIONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<LDMCOLLECTION> root) {
  fbb.FinishSizePrefixed(root, LDMCOLLECTIONIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
