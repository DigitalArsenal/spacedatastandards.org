// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct PHY;
struct PHYBuilder;

enum IntegrationMethod : int8_t {
  IntegrationMethod_EULER = 0,
  IntegrationMethod_EULER_IMPROVED = 1,
  IntegrationMethod_RK2 = 2,
  IntegrationMethod_RK4 = 3,
  IntegrationMethod_RK45 = 4,
  IntegrationMethod_RK78 = 5,
  IntegrationMethod_VERLET = 6,
  IntegrationMethod_LEAPFROG = 7,
  IntegrationMethod_ADAMS_BASHFORTH = 8,
  IntegrationMethod_GAUSS_JACKSON = 9,
  IntegrationMethod_MIN = IntegrationMethod_EULER,
  IntegrationMethod_MAX = IntegrationMethod_GAUSS_JACKSON
};

inline const IntegrationMethod (&EnumValuesIntegrationMethod())[10] {
  static const IntegrationMethod values[] = {
    IntegrationMethod_EULER,
    IntegrationMethod_EULER_IMPROVED,
    IntegrationMethod_RK2,
    IntegrationMethod_RK4,
    IntegrationMethod_RK45,
    IntegrationMethod_RK78,
    IntegrationMethod_VERLET,
    IntegrationMethod_LEAPFROG,
    IntegrationMethod_ADAMS_BASHFORTH,
    IntegrationMethod_GAUSS_JACKSON
  };
  return values;
}

inline const char * const *EnumNamesIntegrationMethod() {
  static const char * const names[11] = {
    "EULER",
    "EULER_IMPROVED",
    "RK2",
    "RK4",
    "RK45",
    "RK78",
    "VERLET",
    "LEAPFROG",
    "ADAMS_BASHFORTH",
    "GAUSS_JACKSON",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntegrationMethod(IntegrationMethod e) {
  if (::flatbuffers::IsOutRange(e, IntegrationMethod_EULER, IntegrationMethod_GAUSS_JACKSON)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntegrationMethod()[index];
}

enum CollisionShape : int8_t {
  CollisionShape_SPHERE = 0,
  CollisionShape_BOX = 1,
  CollisionShape_CYLINDER = 2,
  CollisionShape_CAPSULE = 3,
  CollisionShape_CONE = 4,
  CollisionShape_CONVEX_HULL = 5,
  CollisionShape_MESH = 6,
  CollisionShape_COMPOUND = 7,
  CollisionShape_MIN = CollisionShape_SPHERE,
  CollisionShape_MAX = CollisionShape_COMPOUND
};

inline const CollisionShape (&EnumValuesCollisionShape())[8] {
  static const CollisionShape values[] = {
    CollisionShape_SPHERE,
    CollisionShape_BOX,
    CollisionShape_CYLINDER,
    CollisionShape_CAPSULE,
    CollisionShape_CONE,
    CollisionShape_CONVEX_HULL,
    CollisionShape_MESH,
    CollisionShape_COMPOUND
  };
  return values;
}

inline const char * const *EnumNamesCollisionShape() {
  static const char * const names[9] = {
    "SPHERE",
    "BOX",
    "CYLINDER",
    "CAPSULE",
    "CONE",
    "CONVEX_HULL",
    "MESH",
    "COMPOUND",
    nullptr
  };
  return names;
}

inline const char *EnumNameCollisionShape(CollisionShape e) {
  if (::flatbuffers::IsOutRange(e, CollisionShape_SPHERE, CollisionShape_COMPOUND)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCollisionShape()[index];
}

enum MaterialType : int8_t {
  MaterialType_STEEL = 0,
  MaterialType_ALUMINUM = 1,
  MaterialType_TITANIUM = 2,
  MaterialType_CERAMIC = 3,
  MaterialType_COMPOSITE = 4,
  MaterialType_CONCRETE = 5,
  MaterialType_WOOD = 6,
  MaterialType_RUBBER = 7,
  MaterialType_WATER = 8,
  MaterialType_AIR = 9,
  MaterialType_CUSTOM = 10,
  MaterialType_MIN = MaterialType_STEEL,
  MaterialType_MAX = MaterialType_CUSTOM
};

inline const MaterialType (&EnumValuesMaterialType())[11] {
  static const MaterialType values[] = {
    MaterialType_STEEL,
    MaterialType_ALUMINUM,
    MaterialType_TITANIUM,
    MaterialType_CERAMIC,
    MaterialType_COMPOSITE,
    MaterialType_CONCRETE,
    MaterialType_WOOD,
    MaterialType_RUBBER,
    MaterialType_WATER,
    MaterialType_AIR,
    MaterialType_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesMaterialType() {
  static const char * const names[12] = {
    "STEEL",
    "ALUMINUM",
    "TITANIUM",
    "CERAMIC",
    "COMPOSITE",
    "CONCRETE",
    "WOOD",
    "RUBBER",
    "WATER",
    "AIR",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialType(MaterialType e) {
  if (::flatbuffers::IsOutRange(e, MaterialType_STEEL, MaterialType_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMaterialType()[index];
}

enum ForceType : int8_t {
  ForceType_GRAVITY = 0,
  ForceType_THRUST = 1,
  ForceType_DRAG = 2,
  ForceType_LIFT = 3,
  ForceType_FRICTION = 4,
  ForceType_SPRING = 5,
  ForceType_DAMPER = 6,
  ForceType_CONTACT = 7,
  ForceType_MAGNETIC = 8,
  ForceType_ELECTRIC = 9,
  ForceType_CUSTOM = 10,
  ForceType_MIN = ForceType_GRAVITY,
  ForceType_MAX = ForceType_CUSTOM
};

inline const ForceType (&EnumValuesForceType())[11] {
  static const ForceType values[] = {
    ForceType_GRAVITY,
    ForceType_THRUST,
    ForceType_DRAG,
    ForceType_LIFT,
    ForceType_FRICTION,
    ForceType_SPRING,
    ForceType_DAMPER,
    ForceType_CONTACT,
    ForceType_MAGNETIC,
    ForceType_ELECTRIC,
    ForceType_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesForceType() {
  static const char * const names[12] = {
    "GRAVITY",
    "THRUST",
    "DRAG",
    "LIFT",
    "FRICTION",
    "SPRING",
    "DAMPER",
    "CONTACT",
    "MAGNETIC",
    "ELECTRIC",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameForceType(ForceType e) {
  if (::flatbuffers::IsOutRange(e, ForceType_GRAVITY, ForceType_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForceType()[index];
}

/// Physics and Rigid Body Dynamics
struct PHY FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PHYBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_SIMULATION_STEP = 6,
    VT_RIGID_BODY = 8,
    VT_INTEGRATION_CONFIG = 10,
    VT_COLLISION_QUERY_A = 12,
    VT_COLLISION_QUERY_B = 14,
    VT_TRANSFORM_A = 16,
    VT_TRANSFORM_B = 18,
    VT_POSITION_A = 20,
    VT_POSITION_B = 22,
    VT_FLUID = 24,
    VT_AERO_QUERY = 26,
    VT_DRAG_MODEL = 28,
    VT_THERMAL_STATE = 30
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *SIMULATION_STEP() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIMULATION_STEP);
  }
  const ::flatbuffers::String *RIGID_BODY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RIGID_BODY);
  }
  const ::flatbuffers::String *INTEGRATION_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTEGRATION_CONFIG);
  }
  const ::flatbuffers::String *COLLISION_QUERY_A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLISION_QUERY_A);
  }
  const ::flatbuffers::String *COLLISION_QUERY_B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLISION_QUERY_B);
  }
  const ::flatbuffers::String *TRANSFORM_A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSFORM_A);
  }
  const ::flatbuffers::String *TRANSFORM_B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSFORM_B);
  }
  const ::flatbuffers::String *POSITION_A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSITION_A);
  }
  const ::flatbuffers::String *POSITION_B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSITION_B);
  }
  const ::flatbuffers::String *FLUID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FLUID);
  }
  const ::flatbuffers::String *AERO_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AERO_QUERY);
  }
  const ::flatbuffers::String *DRAG_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DRAG_MODEL);
  }
  const ::flatbuffers::String *THERMAL_STATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THERMAL_STATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_SIMULATION_STEP) &&
           verifier.VerifyString(SIMULATION_STEP()) &&
           VerifyOffset(verifier, VT_RIGID_BODY) &&
           verifier.VerifyString(RIGID_BODY()) &&
           VerifyOffset(verifier, VT_INTEGRATION_CONFIG) &&
           verifier.VerifyString(INTEGRATION_CONFIG()) &&
           VerifyOffset(verifier, VT_COLLISION_QUERY_A) &&
           verifier.VerifyString(COLLISION_QUERY_A()) &&
           VerifyOffset(verifier, VT_COLLISION_QUERY_B) &&
           verifier.VerifyString(COLLISION_QUERY_B()) &&
           VerifyOffset(verifier, VT_TRANSFORM_A) &&
           verifier.VerifyString(TRANSFORM_A()) &&
           VerifyOffset(verifier, VT_TRANSFORM_B) &&
           verifier.VerifyString(TRANSFORM_B()) &&
           VerifyOffset(verifier, VT_POSITION_A) &&
           verifier.VerifyString(POSITION_A()) &&
           VerifyOffset(verifier, VT_POSITION_B) &&
           verifier.VerifyString(POSITION_B()) &&
           VerifyOffset(verifier, VT_FLUID) &&
           verifier.VerifyString(FLUID()) &&
           VerifyOffset(verifier, VT_AERO_QUERY) &&
           verifier.VerifyString(AERO_QUERY()) &&
           VerifyOffset(verifier, VT_DRAG_MODEL) &&
           verifier.VerifyString(DRAG_MODEL()) &&
           VerifyOffset(verifier, VT_THERMAL_STATE) &&
           verifier.VerifyString(THERMAL_STATE()) &&
           verifier.EndTable();
  }
};

struct PHYBuilder {
  typedef PHY Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(PHY::VT_COMMAND, COMMAND);
  }
  void add_SIMULATION_STEP(::flatbuffers::Offset<::flatbuffers::String> SIMULATION_STEP) {
    fbb_.AddOffset(PHY::VT_SIMULATION_STEP, SIMULATION_STEP);
  }
  void add_RIGID_BODY(::flatbuffers::Offset<::flatbuffers::String> RIGID_BODY) {
    fbb_.AddOffset(PHY::VT_RIGID_BODY, RIGID_BODY);
  }
  void add_INTEGRATION_CONFIG(::flatbuffers::Offset<::flatbuffers::String> INTEGRATION_CONFIG) {
    fbb_.AddOffset(PHY::VT_INTEGRATION_CONFIG, INTEGRATION_CONFIG);
  }
  void add_COLLISION_QUERY_A(::flatbuffers::Offset<::flatbuffers::String> COLLISION_QUERY_A) {
    fbb_.AddOffset(PHY::VT_COLLISION_QUERY_A, COLLISION_QUERY_A);
  }
  void add_COLLISION_QUERY_B(::flatbuffers::Offset<::flatbuffers::String> COLLISION_QUERY_B) {
    fbb_.AddOffset(PHY::VT_COLLISION_QUERY_B, COLLISION_QUERY_B);
  }
  void add_TRANSFORM_A(::flatbuffers::Offset<::flatbuffers::String> TRANSFORM_A) {
    fbb_.AddOffset(PHY::VT_TRANSFORM_A, TRANSFORM_A);
  }
  void add_TRANSFORM_B(::flatbuffers::Offset<::flatbuffers::String> TRANSFORM_B) {
    fbb_.AddOffset(PHY::VT_TRANSFORM_B, TRANSFORM_B);
  }
  void add_POSITION_A(::flatbuffers::Offset<::flatbuffers::String> POSITION_A) {
    fbb_.AddOffset(PHY::VT_POSITION_A, POSITION_A);
  }
  void add_POSITION_B(::flatbuffers::Offset<::flatbuffers::String> POSITION_B) {
    fbb_.AddOffset(PHY::VT_POSITION_B, POSITION_B);
  }
  void add_FLUID(::flatbuffers::Offset<::flatbuffers::String> FLUID) {
    fbb_.AddOffset(PHY::VT_FLUID, FLUID);
  }
  void add_AERO_QUERY(::flatbuffers::Offset<::flatbuffers::String> AERO_QUERY) {
    fbb_.AddOffset(PHY::VT_AERO_QUERY, AERO_QUERY);
  }
  void add_DRAG_MODEL(::flatbuffers::Offset<::flatbuffers::String> DRAG_MODEL) {
    fbb_.AddOffset(PHY::VT_DRAG_MODEL, DRAG_MODEL);
  }
  void add_THERMAL_STATE(::flatbuffers::Offset<::flatbuffers::String> THERMAL_STATE) {
    fbb_.AddOffset(PHY::VT_THERMAL_STATE, THERMAL_STATE);
  }
  explicit PHYBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PHY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PHY>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PHY> CreatePHY(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SIMULATION_STEP = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RIGID_BODY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INTEGRATION_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COLLISION_QUERY_A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COLLISION_QUERY_B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRANSFORM_A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRANSFORM_B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POSITION_A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POSITION_B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FLUID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AERO_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DRAG_MODEL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> THERMAL_STATE = 0) {
  PHYBuilder builder_(_fbb);
  builder_.add_THERMAL_STATE(THERMAL_STATE);
  builder_.add_DRAG_MODEL(DRAG_MODEL);
  builder_.add_AERO_QUERY(AERO_QUERY);
  builder_.add_FLUID(FLUID);
  builder_.add_POSITION_B(POSITION_B);
  builder_.add_POSITION_A(POSITION_A);
  builder_.add_TRANSFORM_B(TRANSFORM_B);
  builder_.add_TRANSFORM_A(TRANSFORM_A);
  builder_.add_COLLISION_QUERY_B(COLLISION_QUERY_B);
  builder_.add_COLLISION_QUERY_A(COLLISION_QUERY_A);
  builder_.add_INTEGRATION_CONFIG(INTEGRATION_CONFIG);
  builder_.add_RIGID_BODY(RIGID_BODY);
  builder_.add_SIMULATION_STEP(SIMULATION_STEP);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PHY> CreatePHYDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *SIMULATION_STEP = nullptr,
    const char *RIGID_BODY = nullptr,
    const char *INTEGRATION_CONFIG = nullptr,
    const char *COLLISION_QUERY_A = nullptr,
    const char *COLLISION_QUERY_B = nullptr,
    const char *TRANSFORM_A = nullptr,
    const char *TRANSFORM_B = nullptr,
    const char *POSITION_A = nullptr,
    const char *POSITION_B = nullptr,
    const char *FLUID = nullptr,
    const char *AERO_QUERY = nullptr,
    const char *DRAG_MODEL = nullptr,
    const char *THERMAL_STATE = nullptr) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto SIMULATION_STEP__ = SIMULATION_STEP ? _fbb.CreateString(SIMULATION_STEP) : 0;
  auto RIGID_BODY__ = RIGID_BODY ? _fbb.CreateString(RIGID_BODY) : 0;
  auto INTEGRATION_CONFIG__ = INTEGRATION_CONFIG ? _fbb.CreateString(INTEGRATION_CONFIG) : 0;
  auto COLLISION_QUERY_A__ = COLLISION_QUERY_A ? _fbb.CreateString(COLLISION_QUERY_A) : 0;
  auto COLLISION_QUERY_B__ = COLLISION_QUERY_B ? _fbb.CreateString(COLLISION_QUERY_B) : 0;
  auto TRANSFORM_A__ = TRANSFORM_A ? _fbb.CreateString(TRANSFORM_A) : 0;
  auto TRANSFORM_B__ = TRANSFORM_B ? _fbb.CreateString(TRANSFORM_B) : 0;
  auto POSITION_A__ = POSITION_A ? _fbb.CreateString(POSITION_A) : 0;
  auto POSITION_B__ = POSITION_B ? _fbb.CreateString(POSITION_B) : 0;
  auto FLUID__ = FLUID ? _fbb.CreateString(FLUID) : 0;
  auto AERO_QUERY__ = AERO_QUERY ? _fbb.CreateString(AERO_QUERY) : 0;
  auto DRAG_MODEL__ = DRAG_MODEL ? _fbb.CreateString(DRAG_MODEL) : 0;
  auto THERMAL_STATE__ = THERMAL_STATE ? _fbb.CreateString(THERMAL_STATE) : 0;
  return CreatePHY(
      _fbb,
      COMMAND__,
      SIMULATION_STEP__,
      RIGID_BODY__,
      INTEGRATION_CONFIG__,
      COLLISION_QUERY_A__,
      COLLISION_QUERY_B__,
      TRANSFORM_A__,
      TRANSFORM_B__,
      POSITION_A__,
      POSITION_B__,
      FLUID__,
      AERO_QUERY__,
      DRAG_MODEL__,
      THERMAL_STATE__);
}

inline const PHY *GetPHY(const void *buf) {
  return ::flatbuffers::GetRoot<PHY>(buf);
}

inline const PHY *GetSizePrefixedPHY(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PHY>(buf);
}

inline const char *PHYIdentifier() {
  return "$PHY";
}

inline bool PHYBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PHYIdentifier());
}

inline bool SizePrefixedPHYBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PHYIdentifier(), true);
}

inline bool VerifyPHYBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PHY>(PHYIdentifier());
}

inline bool VerifySizePrefixedPHYBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PHY>(PHYIdentifier());
}

inline void FinishPHYBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PHY> root) {
  fbb.Finish(root, PHYIdentifier());
}

inline void FinishSizePrefixedPHYBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PHY> root) {
  fbb.FinishSizePrefixed(root, PHYIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
