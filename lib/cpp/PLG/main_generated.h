// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct PluginCapability;
struct PluginCapabilityBuilder;

struct PluginDependency;
struct PluginDependencyBuilder;

struct EntryFunction;
struct EntryFunctionBuilder;

struct PLG;
struct PLGBuilder;

/// Plugin type category
enum pluginType : int8_t {
  /// Sensor simulation and analysis
  pluginType_Sensor = 0,
  /// Orbital propagation algorithms
  pluginType_Propagator = 1,
  /// Custom rendering/visualization
  pluginType_Renderer = 2,
  /// Data analysis and processing
  pluginType_Analysis = 3,
  /// External data source integration
  pluginType_DataSource = 4,
  /// Electronic warfare simulation
  pluginType_EW = 5,
  /// Communications modeling
  pluginType_Comms = 6,
  /// Physics simulation
  pluginType_Physics = 7,
  pluginType_MIN = pluginType_Sensor,
  pluginType_MAX = pluginType_Physics
};

inline const pluginType (&EnumValuespluginType())[8] {
  static const pluginType values[] = {
    pluginType_Sensor,
    pluginType_Propagator,
    pluginType_Renderer,
    pluginType_Analysis,
    pluginType_DataSource,
    pluginType_EW,
    pluginType_Comms,
    pluginType_Physics
  };
  return values;
}

inline const char * const *EnumNamespluginType() {
  static const char * const names[9] = {
    "Sensor",
    "Propagator",
    "Renderer",
    "Analysis",
    "DataSource",
    "EW",
    "Comms",
    "Physics",
    nullptr
  };
  return names;
}

inline const char *EnumNamepluginType(pluginType e) {
  if (::flatbuffers::IsOutRange(e, pluginType_Sensor, pluginType_Physics)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamespluginType()[index];
}

/// Plugin capability declaration
struct PluginCapability FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PluginCapabilityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_REQUIRED = 8
  };
  /// Capability name, e.g., "gpu_compute", "wasm_simd"
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Capability version
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Whether this capability is required
  bool REQUIRED() const {
    return GetField<uint8_t>(VT_REQUIRED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRED, 1) &&
           verifier.EndTable();
  }
};

struct PluginCapabilityBuilder {
  typedef PluginCapability Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(PluginCapability::VT_NAME, NAME);
  }
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(PluginCapability::VT_VERSION, VERSION);
  }
  void add_REQUIRED(bool REQUIRED) {
    fbb_.AddElement<uint8_t>(PluginCapability::VT_REQUIRED, static_cast<uint8_t>(REQUIRED), 0);
  }
  explicit PluginCapabilityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PluginCapability> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PluginCapability>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PluginCapability> CreatePluginCapability(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    bool REQUIRED = false) {
  PluginCapabilityBuilder builder_(_fbb);
  builder_.add_VERSION(VERSION);
  builder_.add_NAME(NAME);
  builder_.add_REQUIRED(REQUIRED);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PluginCapability> CreatePluginCapabilityDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *VERSION = nullptr,
    bool REQUIRED = false) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  return CreatePluginCapability(
      _fbb,
      NAME__,
      VERSION__,
      REQUIRED);
}

/// Plugin dependency on another plugin
struct PluginDependency FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PluginDependencyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLUGIN_ID = 4,
    VT_MIN_VERSION = 6,
    VT_MAX_VERSION = 8
  };
  /// Plugin ID of the dependency
  const ::flatbuffers::String *PLUGIN_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLUGIN_ID);
  }
  /// Minimum version required (semver)
  const ::flatbuffers::String *MIN_VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MIN_VERSION);
  }
  /// Maximum version allowed (optional)
  const ::flatbuffers::String *MAX_VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAX_VERSION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLUGIN_ID) &&
           verifier.VerifyString(PLUGIN_ID()) &&
           VerifyOffset(verifier, VT_MIN_VERSION) &&
           verifier.VerifyString(MIN_VERSION()) &&
           VerifyOffset(verifier, VT_MAX_VERSION) &&
           verifier.VerifyString(MAX_VERSION()) &&
           verifier.EndTable();
  }
};

struct PluginDependencyBuilder {
  typedef PluginDependency Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PLUGIN_ID(::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID) {
    fbb_.AddOffset(PluginDependency::VT_PLUGIN_ID, PLUGIN_ID);
  }
  void add_MIN_VERSION(::flatbuffers::Offset<::flatbuffers::String> MIN_VERSION) {
    fbb_.AddOffset(PluginDependency::VT_MIN_VERSION, MIN_VERSION);
  }
  void add_MAX_VERSION(::flatbuffers::Offset<::flatbuffers::String> MAX_VERSION) {
    fbb_.AddOffset(PluginDependency::VT_MAX_VERSION, MAX_VERSION);
  }
  explicit PluginDependencyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PluginDependency> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PluginDependency>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PluginDependency> CreatePluginDependency(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MIN_VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MAX_VERSION = 0) {
  PluginDependencyBuilder builder_(_fbb);
  builder_.add_MAX_VERSION(MAX_VERSION);
  builder_.add_MIN_VERSION(MIN_VERSION);
  builder_.add_PLUGIN_ID(PLUGIN_ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PluginDependency> CreatePluginDependencyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PLUGIN_ID = nullptr,
    const char *MIN_VERSION = nullptr,
    const char *MAX_VERSION = nullptr) {
  auto PLUGIN_ID__ = PLUGIN_ID ? _fbb.CreateString(PLUGIN_ID) : 0;
  auto MIN_VERSION__ = MIN_VERSION ? _fbb.CreateString(MIN_VERSION) : 0;
  auto MAX_VERSION__ = MAX_VERSION ? _fbb.CreateString(MAX_VERSION) : 0;
  return CreatePluginDependency(
      _fbb,
      PLUGIN_ID__,
      MIN_VERSION__,
      MAX_VERSION__);
}

/// Plugin entry point function definition
struct EntryFunction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EntryFunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_INPUT_SCHEMAS = 8,
    VT_OUTPUT_SCHEMA = 10
  };
  /// Function name as exported from WASM
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Human-readable description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Input parameter types (FlatBuffer schema names)
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *INPUT_SCHEMAS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUT_SCHEMAS);
  }
  /// Output type (FlatBuffer schema name)
  const ::flatbuffers::String *OUTPUT_SCHEMA() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OUTPUT_SCHEMA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_INPUT_SCHEMAS) &&
           verifier.VerifyVector(INPUT_SCHEMAS()) &&
           verifier.VerifyVectorOfStrings(INPUT_SCHEMAS()) &&
           VerifyOffset(verifier, VT_OUTPUT_SCHEMA) &&
           verifier.VerifyString(OUTPUT_SCHEMA()) &&
           verifier.EndTable();
  }
};

struct EntryFunctionBuilder {
  typedef EntryFunction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(EntryFunction::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(EntryFunction::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_INPUT_SCHEMAS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> INPUT_SCHEMAS) {
    fbb_.AddOffset(EntryFunction::VT_INPUT_SCHEMAS, INPUT_SCHEMAS);
  }
  void add_OUTPUT_SCHEMA(::flatbuffers::Offset<::flatbuffers::String> OUTPUT_SCHEMA) {
    fbb_.AddOffset(EntryFunction::VT_OUTPUT_SCHEMA, OUTPUT_SCHEMA);
  }
  explicit EntryFunctionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EntryFunction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EntryFunction>(end);
    fbb_.Required(o, EntryFunction::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<EntryFunction> CreateEntryFunction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> INPUT_SCHEMAS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OUTPUT_SCHEMA = 0) {
  EntryFunctionBuilder builder_(_fbb);
  builder_.add_OUTPUT_SCHEMA(OUTPUT_SCHEMA);
  builder_.add_INPUT_SCHEMAS(INPUT_SCHEMAS);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EntryFunction> CreateEntryFunctionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *INPUT_SCHEMAS = nullptr,
    const char *OUTPUT_SCHEMA = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto INPUT_SCHEMAS__ = INPUT_SCHEMAS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*INPUT_SCHEMAS) : 0;
  auto OUTPUT_SCHEMA__ = OUTPUT_SCHEMA ? _fbb.CreateString(OUTPUT_SCHEMA) : 0;
  return CreateEntryFunction(
      _fbb,
      NAME__,
      DESCRIPTION__,
      INPUT_SCHEMAS__,
      OUTPUT_SCHEMA__);
}

/// Plugin Manifest - WASM plugin distribution
struct PLG FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PLGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLUGIN_ID = 4,
    VT_NAME = 6,
    VT_VERSION = 8,
    VT_DESCRIPTION = 10,
    VT_PLUGIN_TYPE = 12,
    VT_ABI_VERSION = 14,
    VT_WASM_HASH = 16,
    VT_WASM_SIZE = 18,
    VT_WASM_CID = 20,
    VT_ENTRY_FUNCTIONS = 22,
    VT_REQUIRED_SCHEMAS = 24,
    VT_DEPENDENCIES = 26,
    VT_CAPABILITIES = 28,
    VT_PROVIDER_PEER_ID = 30,
    VT_PROVIDER_EPM_CID = 32,
    VT_ENCRYPTED = 34,
    VT_MIN_PERMISSIONS = 36,
    VT_CREATED_AT = 38,
    VT_UPDATED_AT = 40,
    VT_DOCUMENTATION_URL = 42,
    VT_ICON_URL = 44,
    VT_LICENSE = 46,
    VT_SIGNATURE = 48
  };
  /// Unique identifier for the plugin
  const ::flatbuffers::String *PLUGIN_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLUGIN_ID);
  }
  /// Human-readable plugin name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Plugin version (semver format)
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Detailed description of plugin functionality
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Type/category of the plugin
  pluginType PLUGIN_TYPE() const {
    return static_cast<pluginType>(GetField<int8_t>(VT_PLUGIN_TYPE, 0));
  }
  /// ABI version for compatibility checking
  uint32_t ABI_VERSION() const {
    return GetField<uint32_t>(VT_ABI_VERSION, 1);
  }
  /// SHA256 hash of the decrypted WASM binary
  const ::flatbuffers::Vector<uint8_t> *WASM_HASH() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WASM_HASH);
  }
  /// Size of WASM binary in bytes
  uint64_t WASM_SIZE() const {
    return GetField<uint64_t>(VT_WASM_SIZE, 0);
  }
  /// IPFS CID of the encrypted WASM binary
  const ::flatbuffers::String *WASM_CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WASM_CID);
  }
  /// Entry point functions exported by the plugin
  const ::flatbuffers::Vector<::flatbuffers::Offset<EntryFunction>> *ENTRY_FUNCTIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EntryFunction>> *>(VT_ENTRY_FUNCTIONS);
  }
  /// FlatBuffer schemas required by this plugin
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *REQUIRED_SCHEMAS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_REQUIRED_SCHEMAS);
  }
  /// Other plugins this depends on
  const ::flatbuffers::Vector<::flatbuffers::Offset<PluginDependency>> *DEPENDENCIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PluginDependency>> *>(VT_DEPENDENCIES);
  }
  /// Capabilities provided by this plugin
  const ::flatbuffers::Vector<::flatbuffers::Offset<PluginCapability>> *CAPABILITIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PluginCapability>> *>(VT_CAPABILITIES);
  }
  /// Peer ID of the plugin provider
  const ::flatbuffers::String *PROVIDER_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROVIDER_PEER_ID);
  }
  /// IPFS CID of provider's EPM (Entity Profile Message)
  const ::flatbuffers::String *PROVIDER_EPM_CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROVIDER_EPM_CID);
  }
  /// Whether the WASM binary is encrypted
  bool ENCRYPTED() const {
    return GetField<uint8_t>(VT_ENCRYPTED, 1) != 0;
  }
  /// Minimum permissions required to run
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MIN_PERMISSIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MIN_PERMISSIONS);
  }
  /// Unix timestamp when plugin was created
  uint64_t CREATED_AT() const {
    return GetField<uint64_t>(VT_CREATED_AT, 0);
  }
  /// Unix timestamp when plugin was last updated
  uint64_t UPDATED_AT() const {
    return GetField<uint64_t>(VT_UPDATED_AT, 0);
  }
  /// URL to plugin documentation
  const ::flatbuffers::String *DOCUMENTATION_URL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DOCUMENTATION_URL);
  }
  /// URL to plugin icon/logo
  const ::flatbuffers::String *ICON_URL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICON_URL);
  }
  /// License identifier (SPDX format)
  const ::flatbuffers::String *LICENSE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LICENSE);
  }
  /// Ed25519 signature from provider over manifest
  const ::flatbuffers::Vector<uint8_t> *SIGNATURE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PLUGIN_ID) &&
           verifier.VerifyString(PLUGIN_ID()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyField<int8_t>(verifier, VT_PLUGIN_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_ABI_VERSION, 4) &&
           VerifyOffset(verifier, VT_WASM_HASH) &&
           verifier.VerifyVector(WASM_HASH()) &&
           VerifyField<uint64_t>(verifier, VT_WASM_SIZE, 8) &&
           VerifyOffset(verifier, VT_WASM_CID) &&
           verifier.VerifyString(WASM_CID()) &&
           VerifyOffset(verifier, VT_ENTRY_FUNCTIONS) &&
           verifier.VerifyVector(ENTRY_FUNCTIONS()) &&
           verifier.VerifyVectorOfTables(ENTRY_FUNCTIONS()) &&
           VerifyOffset(verifier, VT_REQUIRED_SCHEMAS) &&
           verifier.VerifyVector(REQUIRED_SCHEMAS()) &&
           verifier.VerifyVectorOfStrings(REQUIRED_SCHEMAS()) &&
           VerifyOffset(verifier, VT_DEPENDENCIES) &&
           verifier.VerifyVector(DEPENDENCIES()) &&
           verifier.VerifyVectorOfTables(DEPENDENCIES()) &&
           VerifyOffset(verifier, VT_CAPABILITIES) &&
           verifier.VerifyVector(CAPABILITIES()) &&
           verifier.VerifyVectorOfTables(CAPABILITIES()) &&
           VerifyOffset(verifier, VT_PROVIDER_PEER_ID) &&
           verifier.VerifyString(PROVIDER_PEER_ID()) &&
           VerifyOffset(verifier, VT_PROVIDER_EPM_CID) &&
           verifier.VerifyString(PROVIDER_EPM_CID()) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPTED, 1) &&
           VerifyOffset(verifier, VT_MIN_PERMISSIONS) &&
           verifier.VerifyVector(MIN_PERMISSIONS()) &&
           verifier.VerifyVectorOfStrings(MIN_PERMISSIONS()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED_AT, 8) &&
           VerifyField<uint64_t>(verifier, VT_UPDATED_AT, 8) &&
           VerifyOffset(verifier, VT_DOCUMENTATION_URL) &&
           verifier.VerifyString(DOCUMENTATION_URL()) &&
           VerifyOffset(verifier, VT_ICON_URL) &&
           verifier.VerifyString(ICON_URL()) &&
           VerifyOffset(verifier, VT_LICENSE) &&
           verifier.VerifyString(LICENSE()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(SIGNATURE()) &&
           verifier.EndTable();
  }
};

struct PLGBuilder {
  typedef PLG Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PLUGIN_ID(::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID) {
    fbb_.AddOffset(PLG::VT_PLUGIN_ID, PLUGIN_ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(PLG::VT_NAME, NAME);
  }
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(PLG::VT_VERSION, VERSION);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(PLG::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_PLUGIN_TYPE(pluginType PLUGIN_TYPE) {
    fbb_.AddElement<int8_t>(PLG::VT_PLUGIN_TYPE, static_cast<int8_t>(PLUGIN_TYPE), 0);
  }
  void add_ABI_VERSION(uint32_t ABI_VERSION) {
    fbb_.AddElement<uint32_t>(PLG::VT_ABI_VERSION, ABI_VERSION, 1);
  }
  void add_WASM_HASH(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> WASM_HASH) {
    fbb_.AddOffset(PLG::VT_WASM_HASH, WASM_HASH);
  }
  void add_WASM_SIZE(uint64_t WASM_SIZE) {
    fbb_.AddElement<uint64_t>(PLG::VT_WASM_SIZE, WASM_SIZE, 0);
  }
  void add_WASM_CID(::flatbuffers::Offset<::flatbuffers::String> WASM_CID) {
    fbb_.AddOffset(PLG::VT_WASM_CID, WASM_CID);
  }
  void add_ENTRY_FUNCTIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EntryFunction>>> ENTRY_FUNCTIONS) {
    fbb_.AddOffset(PLG::VT_ENTRY_FUNCTIONS, ENTRY_FUNCTIONS);
  }
  void add_REQUIRED_SCHEMAS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> REQUIRED_SCHEMAS) {
    fbb_.AddOffset(PLG::VT_REQUIRED_SCHEMAS, REQUIRED_SCHEMAS);
  }
  void add_DEPENDENCIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PluginDependency>>> DEPENDENCIES) {
    fbb_.AddOffset(PLG::VT_DEPENDENCIES, DEPENDENCIES);
  }
  void add_CAPABILITIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PluginCapability>>> CAPABILITIES) {
    fbb_.AddOffset(PLG::VT_CAPABILITIES, CAPABILITIES);
  }
  void add_PROVIDER_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> PROVIDER_PEER_ID) {
    fbb_.AddOffset(PLG::VT_PROVIDER_PEER_ID, PROVIDER_PEER_ID);
  }
  void add_PROVIDER_EPM_CID(::flatbuffers::Offset<::flatbuffers::String> PROVIDER_EPM_CID) {
    fbb_.AddOffset(PLG::VT_PROVIDER_EPM_CID, PROVIDER_EPM_CID);
  }
  void add_ENCRYPTED(bool ENCRYPTED) {
    fbb_.AddElement<uint8_t>(PLG::VT_ENCRYPTED, static_cast<uint8_t>(ENCRYPTED), 1);
  }
  void add_MIN_PERMISSIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MIN_PERMISSIONS) {
    fbb_.AddOffset(PLG::VT_MIN_PERMISSIONS, MIN_PERMISSIONS);
  }
  void add_CREATED_AT(uint64_t CREATED_AT) {
    fbb_.AddElement<uint64_t>(PLG::VT_CREATED_AT, CREATED_AT, 0);
  }
  void add_UPDATED_AT(uint64_t UPDATED_AT) {
    fbb_.AddElement<uint64_t>(PLG::VT_UPDATED_AT, UPDATED_AT, 0);
  }
  void add_DOCUMENTATION_URL(::flatbuffers::Offset<::flatbuffers::String> DOCUMENTATION_URL) {
    fbb_.AddOffset(PLG::VT_DOCUMENTATION_URL, DOCUMENTATION_URL);
  }
  void add_ICON_URL(::flatbuffers::Offset<::flatbuffers::String> ICON_URL) {
    fbb_.AddOffset(PLG::VT_ICON_URL, ICON_URL);
  }
  void add_LICENSE(::flatbuffers::Offset<::flatbuffers::String> LICENSE) {
    fbb_.AddOffset(PLG::VT_LICENSE, LICENSE);
  }
  void add_SIGNATURE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE) {
    fbb_.AddOffset(PLG::VT_SIGNATURE, SIGNATURE);
  }
  explicit PLGBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PLG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PLG>(end);
    fbb_.Required(o, PLG::VT_PLUGIN_ID);
    fbb_.Required(o, PLG::VT_NAME);
    fbb_.Required(o, PLG::VT_VERSION);
    return o;
  }
};

inline ::flatbuffers::Offset<PLG> CreatePLG(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> PLUGIN_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    pluginType PLUGIN_TYPE = pluginType_Sensor,
    uint32_t ABI_VERSION = 1,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> WASM_HASH = 0,
    uint64_t WASM_SIZE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> WASM_CID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EntryFunction>>> ENTRY_FUNCTIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> REQUIRED_SCHEMAS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PluginDependency>>> DEPENDENCIES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PluginCapability>>> CAPABILITIES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROVIDER_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROVIDER_EPM_CID = 0,
    bool ENCRYPTED = true,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MIN_PERMISSIONS = 0,
    uint64_t CREATED_AT = 0,
    uint64_t UPDATED_AT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DOCUMENTATION_URL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ICON_URL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LICENSE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE = 0) {
  PLGBuilder builder_(_fbb);
  builder_.add_UPDATED_AT(UPDATED_AT);
  builder_.add_CREATED_AT(CREATED_AT);
  builder_.add_WASM_SIZE(WASM_SIZE);
  builder_.add_SIGNATURE(SIGNATURE);
  builder_.add_LICENSE(LICENSE);
  builder_.add_ICON_URL(ICON_URL);
  builder_.add_DOCUMENTATION_URL(DOCUMENTATION_URL);
  builder_.add_MIN_PERMISSIONS(MIN_PERMISSIONS);
  builder_.add_PROVIDER_EPM_CID(PROVIDER_EPM_CID);
  builder_.add_PROVIDER_PEER_ID(PROVIDER_PEER_ID);
  builder_.add_CAPABILITIES(CAPABILITIES);
  builder_.add_DEPENDENCIES(DEPENDENCIES);
  builder_.add_REQUIRED_SCHEMAS(REQUIRED_SCHEMAS);
  builder_.add_ENTRY_FUNCTIONS(ENTRY_FUNCTIONS);
  builder_.add_WASM_CID(WASM_CID);
  builder_.add_WASM_HASH(WASM_HASH);
  builder_.add_ABI_VERSION(ABI_VERSION);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_VERSION(VERSION);
  builder_.add_NAME(NAME);
  builder_.add_PLUGIN_ID(PLUGIN_ID);
  builder_.add_ENCRYPTED(ENCRYPTED);
  builder_.add_PLUGIN_TYPE(PLUGIN_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PLG> CreatePLGDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *PLUGIN_ID = nullptr,
    const char *NAME = nullptr,
    const char *VERSION = nullptr,
    const char *DESCRIPTION = nullptr,
    pluginType PLUGIN_TYPE = pluginType_Sensor,
    uint32_t ABI_VERSION = 1,
    const std::vector<uint8_t> *WASM_HASH = nullptr,
    uint64_t WASM_SIZE = 0,
    const char *WASM_CID = nullptr,
    const std::vector<::flatbuffers::Offset<EntryFunction>> *ENTRY_FUNCTIONS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *REQUIRED_SCHEMAS = nullptr,
    const std::vector<::flatbuffers::Offset<PluginDependency>> *DEPENDENCIES = nullptr,
    const std::vector<::flatbuffers::Offset<PluginCapability>> *CAPABILITIES = nullptr,
    const char *PROVIDER_PEER_ID = nullptr,
    const char *PROVIDER_EPM_CID = nullptr,
    bool ENCRYPTED = true,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MIN_PERMISSIONS = nullptr,
    uint64_t CREATED_AT = 0,
    uint64_t UPDATED_AT = 0,
    const char *DOCUMENTATION_URL = nullptr,
    const char *ICON_URL = nullptr,
    const char *LICENSE = nullptr,
    const std::vector<uint8_t> *SIGNATURE = nullptr) {
  auto PLUGIN_ID__ = PLUGIN_ID ? _fbb.CreateString(PLUGIN_ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto WASM_HASH__ = WASM_HASH ? _fbb.CreateVector<uint8_t>(*WASM_HASH) : 0;
  auto WASM_CID__ = WASM_CID ? _fbb.CreateString(WASM_CID) : 0;
  auto ENTRY_FUNCTIONS__ = ENTRY_FUNCTIONS ? _fbb.CreateVector<::flatbuffers::Offset<EntryFunction>>(*ENTRY_FUNCTIONS) : 0;
  auto REQUIRED_SCHEMAS__ = REQUIRED_SCHEMAS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*REQUIRED_SCHEMAS) : 0;
  auto DEPENDENCIES__ = DEPENDENCIES ? _fbb.CreateVector<::flatbuffers::Offset<PluginDependency>>(*DEPENDENCIES) : 0;
  auto CAPABILITIES__ = CAPABILITIES ? _fbb.CreateVector<::flatbuffers::Offset<PluginCapability>>(*CAPABILITIES) : 0;
  auto PROVIDER_PEER_ID__ = PROVIDER_PEER_ID ? _fbb.CreateString(PROVIDER_PEER_ID) : 0;
  auto PROVIDER_EPM_CID__ = PROVIDER_EPM_CID ? _fbb.CreateString(PROVIDER_EPM_CID) : 0;
  auto MIN_PERMISSIONS__ = MIN_PERMISSIONS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MIN_PERMISSIONS) : 0;
  auto DOCUMENTATION_URL__ = DOCUMENTATION_URL ? _fbb.CreateString(DOCUMENTATION_URL) : 0;
  auto ICON_URL__ = ICON_URL ? _fbb.CreateString(ICON_URL) : 0;
  auto LICENSE__ = LICENSE ? _fbb.CreateString(LICENSE) : 0;
  auto SIGNATURE__ = SIGNATURE ? _fbb.CreateVector<uint8_t>(*SIGNATURE) : 0;
  return CreatePLG(
      _fbb,
      PLUGIN_ID__,
      NAME__,
      VERSION__,
      DESCRIPTION__,
      PLUGIN_TYPE,
      ABI_VERSION,
      WASM_HASH__,
      WASM_SIZE,
      WASM_CID__,
      ENTRY_FUNCTIONS__,
      REQUIRED_SCHEMAS__,
      DEPENDENCIES__,
      CAPABILITIES__,
      PROVIDER_PEER_ID__,
      PROVIDER_EPM_CID__,
      ENCRYPTED,
      MIN_PERMISSIONS__,
      CREATED_AT,
      UPDATED_AT,
      DOCUMENTATION_URL__,
      ICON_URL__,
      LICENSE__,
      SIGNATURE__);
}

inline const PLG *GetPLG(const void *buf) {
  return ::flatbuffers::GetRoot<PLG>(buf);
}

inline const PLG *GetSizePrefixedPLG(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PLG>(buf);
}

inline const char *PLGIdentifier() {
  return "$PLG";
}

inline bool PLGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLGIdentifier());
}

inline bool SizePrefixedPLGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLGIdentifier(), true);
}

inline bool VerifyPLGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PLG>(PLGIdentifier());
}

inline bool VerifySizePrefixedPLGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PLG>(PLGIdentifier());
}

inline void FinishPLGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLG> root) {
  fbb.Finish(root, PLGIdentifier());
}

inline void FinishSizePrefixedPLGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PLG> root) {
  fbb.FinishSizePrefixed(root, PLGIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
