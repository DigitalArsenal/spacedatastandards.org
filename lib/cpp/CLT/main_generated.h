// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CLT;
struct CLTBuilder;

enum cltuPduType : int8_t {
  cltuPduType_BIND_INVOCATION = 0,
  cltuPduType_BIND_RETURN = 1,
  cltuPduType_UNBIND_INVOCATION = 2,
  cltuPduType_UNBIND_RETURN = 3,
  cltuPduType_START_INVOCATION = 4,
  cltuPduType_START_RETURN = 5,
  cltuPduType_STOP_INVOCATION = 6,
  cltuPduType_STOP_RETURN = 7,
  cltuPduType_TRANSFER_DATA_INVOCATION = 8,
  cltuPduType_TRANSFER_DATA_RETURN = 9,
  cltuPduType_PEER_ABORT = 10,
  cltuPduType_MIN = cltuPduType_BIND_INVOCATION,
  cltuPduType_MAX = cltuPduType_PEER_ABORT
};

inline const cltuPduType (&EnumValuescltuPduType())[11] {
  static const cltuPduType values[] = {
    cltuPduType_BIND_INVOCATION,
    cltuPduType_BIND_RETURN,
    cltuPduType_UNBIND_INVOCATION,
    cltuPduType_UNBIND_RETURN,
    cltuPduType_START_INVOCATION,
    cltuPduType_START_RETURN,
    cltuPduType_STOP_INVOCATION,
    cltuPduType_STOP_RETURN,
    cltuPduType_TRANSFER_DATA_INVOCATION,
    cltuPduType_TRANSFER_DATA_RETURN,
    cltuPduType_PEER_ABORT
  };
  return values;
}

inline const char * const *EnumNamescltuPduType() {
  static const char * const names[12] = {
    "BIND_INVOCATION",
    "BIND_RETURN",
    "UNBIND_INVOCATION",
    "UNBIND_RETURN",
    "START_INVOCATION",
    "START_RETURN",
    "STOP_INVOCATION",
    "STOP_RETURN",
    "TRANSFER_DATA_INVOCATION",
    "TRANSFER_DATA_RETURN",
    "PEER_ABORT",
    nullptr
  };
  return names;
}

inline const char *EnumNamecltuPduType(cltuPduType e) {
  if (::flatbuffers::IsOutRange(e, cltuPduType_BIND_INVOCATION, cltuPduType_PEER_ABORT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamescltuPduType()[index];
}

/// Command Link Transmission Unit Service (CCSDS 912.3-B-2)
struct CLT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CLTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PDU_TYPE = 4,
    VT_INITIATOR_ID = 6,
    VT_RESPONDER_PORT_ID = 8,
    VT_SERVICE_TYPE = 10,
    VT_VERSION = 12,
    VT_INVOKE_ID = 14,
    VT_DATA = 16
  };
  /// PDU type
  cltuPduType PDU_TYPE() const {
    return static_cast<cltuPduType>(GetField<int8_t>(VT_PDU_TYPE, 0));
  }
  /// Initiator identifier
  const ::flatbuffers::String *INITIATOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIATOR_ID);
  }
  /// Responder port identifier
  const ::flatbuffers::String *RESPONDER_PORT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESPONDER_PORT_ID);
  }
  /// Service type
  uint8_t SERVICE_TYPE() const {
    return GetField<uint8_t>(VT_SERVICE_TYPE, 0);
  }
  /// Version number
  uint16_t VERSION() const {
    return GetField<uint16_t>(VT_VERSION, 0);
  }
  /// Invoke ID
  uint32_t INVOKE_ID() const {
    return GetField<uint32_t>(VT_INVOKE_ID, 0);
  }
  /// CLTU data
  const ::flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PDU_TYPE, 1) &&
           VerifyOffset(verifier, VT_INITIATOR_ID) &&
           verifier.VerifyString(INITIATOR_ID()) &&
           VerifyOffset(verifier, VT_RESPONDER_PORT_ID) &&
           verifier.VerifyString(RESPONDER_PORT_ID()) &&
           VerifyField<uint8_t>(verifier, VT_SERVICE_TYPE, 1) &&
           VerifyField<uint16_t>(verifier, VT_VERSION, 2) &&
           VerifyField<uint32_t>(verifier, VT_INVOKE_ID, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           verifier.EndTable();
  }
};

struct CLTBuilder {
  typedef CLT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_PDU_TYPE(cltuPduType PDU_TYPE) {
    fbb_.AddElement<int8_t>(CLT::VT_PDU_TYPE, static_cast<int8_t>(PDU_TYPE), 0);
  }
  void add_INITIATOR_ID(::flatbuffers::Offset<::flatbuffers::String> INITIATOR_ID) {
    fbb_.AddOffset(CLT::VT_INITIATOR_ID, INITIATOR_ID);
  }
  void add_RESPONDER_PORT_ID(::flatbuffers::Offset<::flatbuffers::String> RESPONDER_PORT_ID) {
    fbb_.AddOffset(CLT::VT_RESPONDER_PORT_ID, RESPONDER_PORT_ID);
  }
  void add_SERVICE_TYPE(uint8_t SERVICE_TYPE) {
    fbb_.AddElement<uint8_t>(CLT::VT_SERVICE_TYPE, SERVICE_TYPE, 0);
  }
  void add_VERSION(uint16_t VERSION) {
    fbb_.AddElement<uint16_t>(CLT::VT_VERSION, VERSION, 0);
  }
  void add_INVOKE_ID(uint32_t INVOKE_ID) {
    fbb_.AddElement<uint32_t>(CLT::VT_INVOKE_ID, INVOKE_ID, 0);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(CLT::VT_DATA, DATA);
  }
  explicit CLTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CLT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CLT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CLT> CreateCLT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    cltuPduType PDU_TYPE = cltuPduType_BIND_INVOCATION,
    ::flatbuffers::Offset<::flatbuffers::String> INITIATOR_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> RESPONDER_PORT_ID = 0,
    uint8_t SERVICE_TYPE = 0,
    uint16_t VERSION = 0,
    uint32_t INVOKE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA = 0) {
  CLTBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_INVOKE_ID(INVOKE_ID);
  builder_.add_RESPONDER_PORT_ID(RESPONDER_PORT_ID);
  builder_.add_INITIATOR_ID(INITIATOR_ID);
  builder_.add_VERSION(VERSION);
  builder_.add_SERVICE_TYPE(SERVICE_TYPE);
  builder_.add_PDU_TYPE(PDU_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CLT> CreateCLTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    cltuPduType PDU_TYPE = cltuPduType_BIND_INVOCATION,
    const char *INITIATOR_ID = nullptr,
    const char *RESPONDER_PORT_ID = nullptr,
    uint8_t SERVICE_TYPE = 0,
    uint16_t VERSION = 0,
    uint32_t INVOKE_ID = 0,
    const std::vector<uint8_t> *DATA = nullptr) {
  auto INITIATOR_ID__ = INITIATOR_ID ? _fbb.CreateString(INITIATOR_ID) : 0;
  auto RESPONDER_PORT_ID__ = RESPONDER_PORT_ID ? _fbb.CreateString(RESPONDER_PORT_ID) : 0;
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  return CreateCLT(
      _fbb,
      PDU_TYPE,
      INITIATOR_ID__,
      RESPONDER_PORT_ID__,
      SERVICE_TYPE,
      VERSION,
      INVOKE_ID,
      DATA__);
}

inline const CLT *GetCLT(const void *buf) {
  return ::flatbuffers::GetRoot<CLT>(buf);
}

inline const CLT *GetSizePrefixedCLT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CLT>(buf);
}

inline const char *CLTIdentifier() {
  return "$CLT";
}

inline bool CLTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CLTIdentifier());
}

inline bool SizePrefixedCLTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CLTIdentifier(), true);
}

inline bool VerifyCLTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CLT>(CLTIdentifier());
}

inline bool VerifySizePrefixedCLTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CLT>(CLTIdentifier());
}

inline void FinishCLTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CLT> root) {
  fbb.Finish(root, CLTIdentifier());
}

inline void FinishSizePrefixedCLTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CLT> root) {
  fbb.FinishSizePrefixed(root, CLTIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
