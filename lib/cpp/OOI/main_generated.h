// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OOI;
struct OOIBuilder;

enum ooiStatus : int8_t {
  ooiStatus_ACTIVE = 0,
  ooiStatus_PENDING = 1,
  ooiStatus_CLOSED = 2,
  ooiStatus_MONITORING = 3,
  ooiStatus_URGENT = 4,
  ooiStatus_ARCHIVED = 5,
  ooiStatus_MIN = ooiStatus_ACTIVE,
  ooiStatus_MAX = ooiStatus_ARCHIVED
};

inline const ooiStatus (&EnumValuesooiStatus())[6] {
  static const ooiStatus values[] = {
    ooiStatus_ACTIVE,
    ooiStatus_PENDING,
    ooiStatus_CLOSED,
    ooiStatus_MONITORING,
    ooiStatus_URGENT,
    ooiStatus_ARCHIVED
  };
  return values;
}

inline const char * const *EnumNamesooiStatus() {
  static const char * const names[7] = {
    "ACTIVE",
    "PENDING",
    "CLOSED",
    "MONITORING",
    "URGENT",
    "ARCHIVED",
    nullptr
  };
  return names;
}

inline const char *EnumNameooiStatus(ooiStatus e) {
  if (::flatbuffers::IsOutRange(e, ooiStatus_ACTIVE, ooiStatus_ARCHIVED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesooiStatus()[index];
}

enum ooiPriority : int8_t {
  ooiPriority_CRITICAL = 0,
  ooiPriority_HIGH = 1,
  ooiPriority_MEDIUM = 2,
  ooiPriority_LOW = 3,
  ooiPriority_ROUTINE = 4,
  ooiPriority_MIN = ooiPriority_CRITICAL,
  ooiPriority_MAX = ooiPriority_ROUTINE
};

inline const ooiPriority (&EnumValuesooiPriority())[5] {
  static const ooiPriority values[] = {
    ooiPriority_CRITICAL,
    ooiPriority_HIGH,
    ooiPriority_MEDIUM,
    ooiPriority_LOW,
    ooiPriority_ROUTINE
  };
  return values;
}

inline const char * const *EnumNamesooiPriority() {
  static const char * const names[6] = {
    "CRITICAL",
    "HIGH",
    "MEDIUM",
    "LOW",
    "ROUTINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameooiPriority(ooiPriority e) {
  if (::flatbuffers::IsOutRange(e, ooiPriority_CRITICAL, ooiPriority_ROUTINE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesooiPriority()[index];
}

/// Object of Interest
struct OOI FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OOIBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SAT_NO = 6,
    VT_NAME = 8,
    VT_ON_ORBIT = 10,
    VT_STATUS = 12,
    VT_STATUS_DATE = 14,
    VT_PRIORITY = 16,
    VT_DESCRIPTION = 18,
    VT_SENSOR_TASKING_START_TIME = 20,
    VT_SENSOR_TASKING_STOP_TIME = 22,
    VT_LAST_OB_TIME = 24,
    VT_MISSED_OB_TIME = 26,
    VT_SV_EPOCH = 28,
    VT_X = 30,
    VT_Y = 32,
    VT_Z = 34,
    VT_XVEL = 36,
    VT_YVEL = 38,
    VT_ZVEL = 40,
    VT_ELSET_EPOCH = 42,
    VT_MEAN_MOTION = 44,
    VT_ECCENTRICITY = 46,
    VT_INCLINATION = 48,
    VT_RAAN = 50,
    VT_ARG_OF_PERIGEE = 52,
    VT_MEAN_ANOMALY = 54,
    VT_REV_NO = 56,
    VT_B_STAR = 58,
    VT_MEAN_MOTION_DOT = 60,
    VT_MEAN_MOTION_DDOT = 62,
    VT_SEMI_MAJOR_AXIS = 64,
    VT_PERIOD = 66,
    VT_APOGEE = 68,
    VT_PERIGEE = 70,
    VT_DELTA_VS = 72,
    VT_DELTA_TS = 74,
    VT_AFFECTED_OBJECTS = 76,
    VT_MANIFOLDS = 78
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Satellite catalog number
  uint32_t SAT_NO() const {
    return GetField<uint32_t>(VT_SAT_NO, 0);
  }
  /// Object name or designator
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// On-orbit reference
  const ::flatbuffers::String *ON_ORBIT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ON_ORBIT);
  }
  /// Tasking status
  ooiStatus STATUS() const {
    return static_cast<ooiStatus>(GetField<int8_t>(VT_STATUS, 0));
  }
  /// Status update date (ISO 8601)
  const ::flatbuffers::String *STATUS_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS_DATE);
  }
  /// Collection priority
  ooiPriority PRIORITY() const {
    return static_cast<ooiPriority>(GetField<int8_t>(VT_PRIORITY, 0));
  }
  /// Description of why object is of interest
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Sensor tasking start time (ISO 8601)
  const ::flatbuffers::String *SENSOR_TASKING_START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_TASKING_START_TIME);
  }
  /// Sensor tasking stop time (ISO 8601)
  const ::flatbuffers::String *SENSOR_TASKING_STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSOR_TASKING_STOP_TIME);
  }
  /// Last observation time (ISO 8601)
  const ::flatbuffers::String *LAST_OB_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAST_OB_TIME);
  }
  /// Last missed observation time (ISO 8601)
  const ::flatbuffers::String *MISSED_OB_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSED_OB_TIME);
  }
  /// State vector epoch (ISO 8601)
  const ::flatbuffers::String *SV_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SV_EPOCH);
  }
  /// Position X (km, TEME)
  double X() const {
    return GetField<double>(VT_X, 0.0);
  }
  /// Position Y (km, TEME)
  double Y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  /// Position Z (km, TEME)
  double Z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  /// Velocity X (km/s, TEME)
  double XVEL() const {
    return GetField<double>(VT_XVEL, 0.0);
  }
  /// Velocity Y (km/s, TEME)
  double YVEL() const {
    return GetField<double>(VT_YVEL, 0.0);
  }
  /// Velocity Z (km/s, TEME)
  double ZVEL() const {
    return GetField<double>(VT_ZVEL, 0.0);
  }
  /// Element set epoch (ISO 8601)
  const ::flatbuffers::String *ELSET_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELSET_EPOCH);
  }
  /// Mean motion (rev/day)
  double MEAN_MOTION() const {
    return GetField<double>(VT_MEAN_MOTION, 0.0);
  }
  /// Eccentricity
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  /// Inclination (degrees)
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Right ascension of ascending node (degrees)
  double RAAN() const {
    return GetField<double>(VT_RAAN, 0.0);
  }
  /// Argument of perigee (degrees)
  double ARG_OF_PERIGEE() const {
    return GetField<double>(VT_ARG_OF_PERIGEE, 0.0);
  }
  /// Mean anomaly (degrees)
  double MEAN_ANOMALY() const {
    return GetField<double>(VT_MEAN_ANOMALY, 0.0);
  }
  /// Revolution number at epoch
  uint32_t REV_NO() const {
    return GetField<uint32_t>(VT_REV_NO, 0);
  }
  /// BSTAR drag term (1/Earth radii)
  double B_STAR() const {
    return GetField<double>(VT_B_STAR, 0.0);
  }
  /// Mean motion first derivative (rev/day^2)
  double MEAN_MOTION_DOT() const {
    return GetField<double>(VT_MEAN_MOTION_DOT, 0.0);
  }
  /// Mean motion second derivative (rev/day^3)
  double MEAN_MOTION_DDOT() const {
    return GetField<double>(VT_MEAN_MOTION_DDOT, 0.0);
  }
  /// Semi-major axis (km)
  double SEMI_MAJOR_AXIS() const {
    return GetField<double>(VT_SEMI_MAJOR_AXIS, 0.0);
  }
  /// Orbital period (minutes)
  double PERIOD() const {
    return GetField<double>(VT_PERIOD, 0.0);
  }
  /// Apogee altitude (km)
  double APOGEE() const {
    return GetField<double>(VT_APOGEE, 0.0);
  }
  /// Perigee altitude (km)
  double PERIGEE() const {
    return GetField<double>(VT_PERIGEE, 0.0);
  }
  /// Delta-V estimates for maneuver hypotheses (m/s)
  const ::flatbuffers::Vector<double> *DELTA_VS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DELTA_VS);
  }
  /// Delta-T estimates for maneuver timing (seconds)
  const ::flatbuffers::Vector<double> *DELTA_TS() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_DELTA_TS);
  }
  /// Other affected satellite catalog numbers
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *AFFECTED_OBJECTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AFFECTED_OBJECTS);
  }
  /// Associated orbit manifold identifiers
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *MANIFOLDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MANIFOLDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyField<uint32_t>(verifier, VT_SAT_NO, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_ON_ORBIT) &&
           verifier.VerifyString(ON_ORBIT()) &&
           VerifyField<int8_t>(verifier, VT_STATUS, 1) &&
           VerifyOffset(verifier, VT_STATUS_DATE) &&
           verifier.VerifyString(STATUS_DATE()) &&
           VerifyField<int8_t>(verifier, VT_PRIORITY, 1) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_SENSOR_TASKING_START_TIME) &&
           verifier.VerifyString(SENSOR_TASKING_START_TIME()) &&
           VerifyOffset(verifier, VT_SENSOR_TASKING_STOP_TIME) &&
           verifier.VerifyString(SENSOR_TASKING_STOP_TIME()) &&
           VerifyOffset(verifier, VT_LAST_OB_TIME) &&
           verifier.VerifyString(LAST_OB_TIME()) &&
           VerifyOffset(verifier, VT_MISSED_OB_TIME) &&
           verifier.VerifyString(MISSED_OB_TIME()) &&
           VerifyOffset(verifier, VT_SV_EPOCH) &&
           verifier.VerifyString(SV_EPOCH()) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_XVEL, 8) &&
           VerifyField<double>(verifier, VT_YVEL, 8) &&
           VerifyField<double>(verifier, VT_ZVEL, 8) &&
           VerifyOffset(verifier, VT_ELSET_EPOCH) &&
           verifier.VerifyString(ELSET_EPOCH()) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION, 8) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_RAAN, 8) &&
           VerifyField<double>(verifier, VT_ARG_OF_PERIGEE, 8) &&
           VerifyField<double>(verifier, VT_MEAN_ANOMALY, 8) &&
           VerifyField<uint32_t>(verifier, VT_REV_NO, 4) &&
           VerifyField<double>(verifier, VT_B_STAR, 8) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION_DOT, 8) &&
           VerifyField<double>(verifier, VT_MEAN_MOTION_DDOT, 8) &&
           VerifyField<double>(verifier, VT_SEMI_MAJOR_AXIS, 8) &&
           VerifyField<double>(verifier, VT_PERIOD, 8) &&
           VerifyField<double>(verifier, VT_APOGEE, 8) &&
           VerifyField<double>(verifier, VT_PERIGEE, 8) &&
           VerifyOffset(verifier, VT_DELTA_VS) &&
           verifier.VerifyVector(DELTA_VS()) &&
           VerifyOffset(verifier, VT_DELTA_TS) &&
           verifier.VerifyVector(DELTA_TS()) &&
           VerifyOffset(verifier, VT_AFFECTED_OBJECTS) &&
           verifier.VerifyVector(AFFECTED_OBJECTS()) &&
           verifier.VerifyVectorOfStrings(AFFECTED_OBJECTS()) &&
           VerifyOffset(verifier, VT_MANIFOLDS) &&
           verifier.VerifyVector(MANIFOLDS()) &&
           verifier.VerifyVectorOfStrings(MANIFOLDS()) &&
           verifier.EndTable();
  }
};

struct OOIBuilder {
  typedef OOI Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(OOI::VT_ID, ID);
  }
  void add_SAT_NO(uint32_t SAT_NO) {
    fbb_.AddElement<uint32_t>(OOI::VT_SAT_NO, SAT_NO, 0);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(OOI::VT_NAME, NAME);
  }
  void add_ON_ORBIT(::flatbuffers::Offset<::flatbuffers::String> ON_ORBIT) {
    fbb_.AddOffset(OOI::VT_ON_ORBIT, ON_ORBIT);
  }
  void add_STATUS(ooiStatus STATUS) {
    fbb_.AddElement<int8_t>(OOI::VT_STATUS, static_cast<int8_t>(STATUS), 0);
  }
  void add_STATUS_DATE(::flatbuffers::Offset<::flatbuffers::String> STATUS_DATE) {
    fbb_.AddOffset(OOI::VT_STATUS_DATE, STATUS_DATE);
  }
  void add_PRIORITY(ooiPriority PRIORITY) {
    fbb_.AddElement<int8_t>(OOI::VT_PRIORITY, static_cast<int8_t>(PRIORITY), 0);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(OOI::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_SENSOR_TASKING_START_TIME(::flatbuffers::Offset<::flatbuffers::String> SENSOR_TASKING_START_TIME) {
    fbb_.AddOffset(OOI::VT_SENSOR_TASKING_START_TIME, SENSOR_TASKING_START_TIME);
  }
  void add_SENSOR_TASKING_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> SENSOR_TASKING_STOP_TIME) {
    fbb_.AddOffset(OOI::VT_SENSOR_TASKING_STOP_TIME, SENSOR_TASKING_STOP_TIME);
  }
  void add_LAST_OB_TIME(::flatbuffers::Offset<::flatbuffers::String> LAST_OB_TIME) {
    fbb_.AddOffset(OOI::VT_LAST_OB_TIME, LAST_OB_TIME);
  }
  void add_MISSED_OB_TIME(::flatbuffers::Offset<::flatbuffers::String> MISSED_OB_TIME) {
    fbb_.AddOffset(OOI::VT_MISSED_OB_TIME, MISSED_OB_TIME);
  }
  void add_SV_EPOCH(::flatbuffers::Offset<::flatbuffers::String> SV_EPOCH) {
    fbb_.AddOffset(OOI::VT_SV_EPOCH, SV_EPOCH);
  }
  void add_X(double X) {
    fbb_.AddElement<double>(OOI::VT_X, X, 0.0);
  }
  void add_Y(double Y) {
    fbb_.AddElement<double>(OOI::VT_Y, Y, 0.0);
  }
  void add_Z(double Z) {
    fbb_.AddElement<double>(OOI::VT_Z, Z, 0.0);
  }
  void add_XVEL(double XVEL) {
    fbb_.AddElement<double>(OOI::VT_XVEL, XVEL, 0.0);
  }
  void add_YVEL(double YVEL) {
    fbb_.AddElement<double>(OOI::VT_YVEL, YVEL, 0.0);
  }
  void add_ZVEL(double ZVEL) {
    fbb_.AddElement<double>(OOI::VT_ZVEL, ZVEL, 0.0);
  }
  void add_ELSET_EPOCH(::flatbuffers::Offset<::flatbuffers::String> ELSET_EPOCH) {
    fbb_.AddOffset(OOI::VT_ELSET_EPOCH, ELSET_EPOCH);
  }
  void add_MEAN_MOTION(double MEAN_MOTION) {
    fbb_.AddElement<double>(OOI::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(OOI::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(OOI::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_RAAN(double RAAN) {
    fbb_.AddElement<double>(OOI::VT_RAAN, RAAN, 0.0);
  }
  void add_ARG_OF_PERIGEE(double ARG_OF_PERIGEE) {
    fbb_.AddElement<double>(OOI::VT_ARG_OF_PERIGEE, ARG_OF_PERIGEE, 0.0);
  }
  void add_MEAN_ANOMALY(double MEAN_ANOMALY) {
    fbb_.AddElement<double>(OOI::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  void add_REV_NO(uint32_t REV_NO) {
    fbb_.AddElement<uint32_t>(OOI::VT_REV_NO, REV_NO, 0);
  }
  void add_B_STAR(double B_STAR) {
    fbb_.AddElement<double>(OOI::VT_B_STAR, B_STAR, 0.0);
  }
  void add_MEAN_MOTION_DOT(double MEAN_MOTION_DOT) {
    fbb_.AddElement<double>(OOI::VT_MEAN_MOTION_DOT, MEAN_MOTION_DOT, 0.0);
  }
  void add_MEAN_MOTION_DDOT(double MEAN_MOTION_DDOT) {
    fbb_.AddElement<double>(OOI::VT_MEAN_MOTION_DDOT, MEAN_MOTION_DDOT, 0.0);
  }
  void add_SEMI_MAJOR_AXIS(double SEMI_MAJOR_AXIS) {
    fbb_.AddElement<double>(OOI::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  void add_PERIOD(double PERIOD) {
    fbb_.AddElement<double>(OOI::VT_PERIOD, PERIOD, 0.0);
  }
  void add_APOGEE(double APOGEE) {
    fbb_.AddElement<double>(OOI::VT_APOGEE, APOGEE, 0.0);
  }
  void add_PERIGEE(double PERIGEE) {
    fbb_.AddElement<double>(OOI::VT_PERIGEE, PERIGEE, 0.0);
  }
  void add_DELTA_VS(::flatbuffers::Offset<::flatbuffers::Vector<double>> DELTA_VS) {
    fbb_.AddOffset(OOI::VT_DELTA_VS, DELTA_VS);
  }
  void add_DELTA_TS(::flatbuffers::Offset<::flatbuffers::Vector<double>> DELTA_TS) {
    fbb_.AddOffset(OOI::VT_DELTA_TS, DELTA_TS);
  }
  void add_AFFECTED_OBJECTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> AFFECTED_OBJECTS) {
    fbb_.AddOffset(OOI::VT_AFFECTED_OBJECTS, AFFECTED_OBJECTS);
  }
  void add_MANIFOLDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MANIFOLDS) {
    fbb_.AddOffset(OOI::VT_MANIFOLDS, MANIFOLDS);
  }
  explicit OOIBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OOI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OOI>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OOI> CreateOOI(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    uint32_t SAT_NO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ON_ORBIT = 0,
    ooiStatus STATUS = ooiStatus_ACTIVE,
    ::flatbuffers::Offset<::flatbuffers::String> STATUS_DATE = 0,
    ooiPriority PRIORITY = ooiPriority_CRITICAL,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SENSOR_TASKING_START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SENSOR_TASKING_STOP_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LAST_OB_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MISSED_OB_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SV_EPOCH = 0,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double XVEL = 0.0,
    double YVEL = 0.0,
    double ZVEL = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> ELSET_EPOCH = 0,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RAAN = 0.0,
    double ARG_OF_PERIGEE = 0.0,
    double MEAN_ANOMALY = 0.0,
    uint32_t REV_NO = 0,
    double B_STAR = 0.0,
    double MEAN_MOTION_DOT = 0.0,
    double MEAN_MOTION_DDOT = 0.0,
    double SEMI_MAJOR_AXIS = 0.0,
    double PERIOD = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> DELTA_VS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> DELTA_TS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> AFFECTED_OBJECTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> MANIFOLDS = 0) {
  OOIBuilder builder_(_fbb);
  builder_.add_PERIGEE(PERIGEE);
  builder_.add_APOGEE(APOGEE);
  builder_.add_PERIOD(PERIOD);
  builder_.add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS);
  builder_.add_MEAN_MOTION_DDOT(MEAN_MOTION_DDOT);
  builder_.add_MEAN_MOTION_DOT(MEAN_MOTION_DOT);
  builder_.add_B_STAR(B_STAR);
  builder_.add_MEAN_ANOMALY(MEAN_ANOMALY);
  builder_.add_ARG_OF_PERIGEE(ARG_OF_PERIGEE);
  builder_.add_RAAN(RAAN);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_MEAN_MOTION(MEAN_MOTION);
  builder_.add_ZVEL(ZVEL);
  builder_.add_YVEL(YVEL);
  builder_.add_XVEL(XVEL);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_MANIFOLDS(MANIFOLDS);
  builder_.add_AFFECTED_OBJECTS(AFFECTED_OBJECTS);
  builder_.add_DELTA_TS(DELTA_TS);
  builder_.add_DELTA_VS(DELTA_VS);
  builder_.add_REV_NO(REV_NO);
  builder_.add_ELSET_EPOCH(ELSET_EPOCH);
  builder_.add_SV_EPOCH(SV_EPOCH);
  builder_.add_MISSED_OB_TIME(MISSED_OB_TIME);
  builder_.add_LAST_OB_TIME(LAST_OB_TIME);
  builder_.add_SENSOR_TASKING_STOP_TIME(SENSOR_TASKING_STOP_TIME);
  builder_.add_SENSOR_TASKING_START_TIME(SENSOR_TASKING_START_TIME);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_STATUS_DATE(STATUS_DATE);
  builder_.add_ON_ORBIT(ON_ORBIT);
  builder_.add_NAME(NAME);
  builder_.add_SAT_NO(SAT_NO);
  builder_.add_ID(ID);
  builder_.add_PRIORITY(PRIORITY);
  builder_.add_STATUS(STATUS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OOI> CreateOOIDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    uint32_t SAT_NO = 0,
    const char *NAME = nullptr,
    const char *ON_ORBIT = nullptr,
    ooiStatus STATUS = ooiStatus_ACTIVE,
    const char *STATUS_DATE = nullptr,
    ooiPriority PRIORITY = ooiPriority_CRITICAL,
    const char *DESCRIPTION = nullptr,
    const char *SENSOR_TASKING_START_TIME = nullptr,
    const char *SENSOR_TASKING_STOP_TIME = nullptr,
    const char *LAST_OB_TIME = nullptr,
    const char *MISSED_OB_TIME = nullptr,
    const char *SV_EPOCH = nullptr,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0,
    double XVEL = 0.0,
    double YVEL = 0.0,
    double ZVEL = 0.0,
    const char *ELSET_EPOCH = nullptr,
    double MEAN_MOTION = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RAAN = 0.0,
    double ARG_OF_PERIGEE = 0.0,
    double MEAN_ANOMALY = 0.0,
    uint32_t REV_NO = 0,
    double B_STAR = 0.0,
    double MEAN_MOTION_DOT = 0.0,
    double MEAN_MOTION_DDOT = 0.0,
    double SEMI_MAJOR_AXIS = 0.0,
    double PERIOD = 0.0,
    double APOGEE = 0.0,
    double PERIGEE = 0.0,
    const std::vector<double> *DELTA_VS = nullptr,
    const std::vector<double> *DELTA_TS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *AFFECTED_OBJECTS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *MANIFOLDS = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto ON_ORBIT__ = ON_ORBIT ? _fbb.CreateString(ON_ORBIT) : 0;
  auto STATUS_DATE__ = STATUS_DATE ? _fbb.CreateString(STATUS_DATE) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto SENSOR_TASKING_START_TIME__ = SENSOR_TASKING_START_TIME ? _fbb.CreateString(SENSOR_TASKING_START_TIME) : 0;
  auto SENSOR_TASKING_STOP_TIME__ = SENSOR_TASKING_STOP_TIME ? _fbb.CreateString(SENSOR_TASKING_STOP_TIME) : 0;
  auto LAST_OB_TIME__ = LAST_OB_TIME ? _fbb.CreateString(LAST_OB_TIME) : 0;
  auto MISSED_OB_TIME__ = MISSED_OB_TIME ? _fbb.CreateString(MISSED_OB_TIME) : 0;
  auto SV_EPOCH__ = SV_EPOCH ? _fbb.CreateString(SV_EPOCH) : 0;
  auto ELSET_EPOCH__ = ELSET_EPOCH ? _fbb.CreateString(ELSET_EPOCH) : 0;
  auto DELTA_VS__ = DELTA_VS ? _fbb.CreateVector<double>(*DELTA_VS) : 0;
  auto DELTA_TS__ = DELTA_TS ? _fbb.CreateVector<double>(*DELTA_TS) : 0;
  auto AFFECTED_OBJECTS__ = AFFECTED_OBJECTS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*AFFECTED_OBJECTS) : 0;
  auto MANIFOLDS__ = MANIFOLDS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*MANIFOLDS) : 0;
  return CreateOOI(
      _fbb,
      ID__,
      SAT_NO,
      NAME__,
      ON_ORBIT__,
      STATUS,
      STATUS_DATE__,
      PRIORITY,
      DESCRIPTION__,
      SENSOR_TASKING_START_TIME__,
      SENSOR_TASKING_STOP_TIME__,
      LAST_OB_TIME__,
      MISSED_OB_TIME__,
      SV_EPOCH__,
      X,
      Y,
      Z,
      XVEL,
      YVEL,
      ZVEL,
      ELSET_EPOCH__,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      REV_NO,
      B_STAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      SEMI_MAJOR_AXIS,
      PERIOD,
      APOGEE,
      PERIGEE,
      DELTA_VS__,
      DELTA_TS__,
      AFFECTED_OBJECTS__,
      MANIFOLDS__);
}

inline const OOI *GetOOI(const void *buf) {
  return ::flatbuffers::GetRoot<OOI>(buf);
}

inline const OOI *GetSizePrefixedOOI(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OOI>(buf);
}

inline const char *OOIIdentifier() {
  return "$OOI";
}

inline bool OOIBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOIIdentifier());
}

inline bool SizePrefixedOOIBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OOIIdentifier(), true);
}

inline bool VerifyOOIBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OOI>(OOIIdentifier());
}

inline bool VerifySizePrefixedOOIBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OOI>(OOIIdentifier());
}

inline void FinishOOIBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOI> root) {
  fbb.Finish(root, OOIIdentifier());
}

inline void FinishSizePrefixedOOIBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OOI> root) {
  fbb.FinishSizePrefixed(root, OOIIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
