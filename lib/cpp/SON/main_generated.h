// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SON;
struct SONBuilder;

enum SonarType : int8_t {
  SonarType_ACTIVE_HULL = 0,
  SonarType_ACTIVE_VDS = 1,
  SonarType_ACTIVE_DIPPING = 2,
  SonarType_PASSIVE_HULL = 3,
  SonarType_PASSIVE_TOWED = 4,
  SonarType_PASSIVE_SONOBUOY = 5,
  SonarType_MINE_HUNTING = 6,
  SonarType_SIDESCAN = 7,
  SonarType_BOTTOM_PROFILER = 8,
  SonarType_INTERCEPT = 9,
  SonarType_TORPEDO = 10,
  SonarType_MIN = SonarType_ACTIVE_HULL,
  SonarType_MAX = SonarType_TORPEDO
};

inline const SonarType (&EnumValuesSonarType())[11] {
  static const SonarType values[] = {
    SonarType_ACTIVE_HULL,
    SonarType_ACTIVE_VDS,
    SonarType_ACTIVE_DIPPING,
    SonarType_PASSIVE_HULL,
    SonarType_PASSIVE_TOWED,
    SonarType_PASSIVE_SONOBUOY,
    SonarType_MINE_HUNTING,
    SonarType_SIDESCAN,
    SonarType_BOTTOM_PROFILER,
    SonarType_INTERCEPT,
    SonarType_TORPEDO
  };
  return values;
}

inline const char * const *EnumNamesSonarType() {
  static const char * const names[12] = {
    "ACTIVE_HULL",
    "ACTIVE_VDS",
    "ACTIVE_DIPPING",
    "PASSIVE_HULL",
    "PASSIVE_TOWED",
    "PASSIVE_SONOBUOY",
    "MINE_HUNTING",
    "SIDESCAN",
    "BOTTOM_PROFILER",
    "INTERCEPT",
    "TORPEDO",
    nullptr
  };
  return names;
}

inline const char *EnumNameSonarType(SonarType e) {
  if (::flatbuffers::IsOutRange(e, SonarType_ACTIVE_HULL, SonarType_TORPEDO)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSonarType()[index];
}

enum SONPropagationModel : int8_t {
  SONPropagationModel_RAY_TRACING = 0,
  SONPropagationModel_PARABOLIC_EQUATION = 1,
  SONPropagationModel_NORMAL_MODES = 2,
  SONPropagationModel_ISOVELOCITY = 3,
  SONPropagationModel_RANGE_DEPENDENT = 4,
  SONPropagationModel_FAST_FIELD = 5,
  SONPropagationModel_MIN = SONPropagationModel_RAY_TRACING,
  SONPropagationModel_MAX = SONPropagationModel_FAST_FIELD
};

inline const SONPropagationModel (&EnumValuesSONPropagationModel())[6] {
  static const SONPropagationModel values[] = {
    SONPropagationModel_RAY_TRACING,
    SONPropagationModel_PARABOLIC_EQUATION,
    SONPropagationModel_NORMAL_MODES,
    SONPropagationModel_ISOVELOCITY,
    SONPropagationModel_RANGE_DEPENDENT,
    SONPropagationModel_FAST_FIELD
  };
  return values;
}

inline const char * const *EnumNamesSONPropagationModel() {
  static const char * const names[7] = {
    "RAY_TRACING",
    "PARABOLIC_EQUATION",
    "NORMAL_MODES",
    "ISOVELOCITY",
    "RANGE_DEPENDENT",
    "FAST_FIELD",
    nullptr
  };
  return names;
}

inline const char *EnumNameSONPropagationModel(SONPropagationModel e) {
  if (::flatbuffers::IsOutRange(e, SONPropagationModel_RAY_TRACING, SONPropagationModel_FAST_FIELD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSONPropagationModel()[index];
}

enum BottomType : int8_t {
  BottomType_HARD_ROCK = 0,
  BottomType_SOFT_ROCK = 1,
  BottomType_SAND = 2,
  BottomType_SILT = 3,
  BottomType_CLAY = 4,
  BottomType_MUD = 5,
  BottomType_GRAVEL = 6,
  BottomType_CORAL = 7,
  BottomType_MIXED = 8,
  BottomType_MIN = BottomType_HARD_ROCK,
  BottomType_MAX = BottomType_MIXED
};

inline const BottomType (&EnumValuesBottomType())[9] {
  static const BottomType values[] = {
    BottomType_HARD_ROCK,
    BottomType_SOFT_ROCK,
    BottomType_SAND,
    BottomType_SILT,
    BottomType_CLAY,
    BottomType_MUD,
    BottomType_GRAVEL,
    BottomType_CORAL,
    BottomType_MIXED
  };
  return values;
}

inline const char * const *EnumNamesBottomType() {
  static const char * const names[10] = {
    "HARD_ROCK",
    "SOFT_ROCK",
    "SAND",
    "SILT",
    "CLAY",
    "MUD",
    "GRAVEL",
    "CORAL",
    "MIXED",
    nullptr
  };
  return names;
}

inline const char *EnumNameBottomType(BottomType e) {
  if (::flatbuffers::IsOutRange(e, BottomType_HARD_ROCK, BottomType_MIXED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBottomType()[index];
}

enum SeaState : int8_t {
  SeaState_SS0 = 0,
  SeaState_SS1 = 1,
  SeaState_SS2 = 2,
  SeaState_SS3 = 3,
  SeaState_SS4 = 4,
  SeaState_SS5 = 5,
  SeaState_SS6 = 6,
  SeaState_SS7 = 7,
  SeaState_SS8 = 8,
  SeaState_SS9 = 9,
  SeaState_MIN = SeaState_SS0,
  SeaState_MAX = SeaState_SS9
};

inline const SeaState (&EnumValuesSeaState())[10] {
  static const SeaState values[] = {
    SeaState_SS0,
    SeaState_SS1,
    SeaState_SS2,
    SeaState_SS3,
    SeaState_SS4,
    SeaState_SS5,
    SeaState_SS6,
    SeaState_SS7,
    SeaState_SS8,
    SeaState_SS9
  };
  return values;
}

inline const char * const *EnumNamesSeaState() {
  static const char * const names[11] = {
    "SS0",
    "SS1",
    "SS2",
    "SS3",
    "SS4",
    "SS5",
    "SS6",
    "SS7",
    "SS8",
    "SS9",
    nullptr
  };
  return names;
}

inline const char *EnumNameSeaState(SeaState e) {
  if (::flatbuffers::IsOutRange(e, SeaState_SS0, SeaState_SS9)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSeaState()[index];
}

enum NoiseSource : int8_t {
  NoiseSource_AMBIENT = 0,
  NoiseSource_SHIPPING = 1,
  NoiseSource_BIOLOGICAL = 2,
  NoiseSource_WIND = 3,
  NoiseSource_RAIN = 4,
  NoiseSource_ICE = 5,
  NoiseSource_SEISMIC = 6,
  NoiseSource_MACHINERY = 7,
  NoiseSource_FLOW = 8,
  NoiseSource_SELF_NOISE = 9,
  NoiseSource_MIN = NoiseSource_AMBIENT,
  NoiseSource_MAX = NoiseSource_SELF_NOISE
};

inline const NoiseSource (&EnumValuesNoiseSource())[10] {
  static const NoiseSource values[] = {
    NoiseSource_AMBIENT,
    NoiseSource_SHIPPING,
    NoiseSource_BIOLOGICAL,
    NoiseSource_WIND,
    NoiseSource_RAIN,
    NoiseSource_ICE,
    NoiseSource_SEISMIC,
    NoiseSource_MACHINERY,
    NoiseSource_FLOW,
    NoiseSource_SELF_NOISE
  };
  return values;
}

inline const char * const *EnumNamesNoiseSource() {
  static const char * const names[11] = {
    "AMBIENT",
    "SHIPPING",
    "BIOLOGICAL",
    "WIND",
    "RAIN",
    "ICE",
    "SEISMIC",
    "MACHINERY",
    "FLOW",
    "SELF_NOISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameNoiseSource(NoiseSource e) {
  if (::flatbuffers::IsOutRange(e, NoiseSource_AMBIENT, NoiseSource_SELF_NOISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNoiseSource()[index];
}

enum TargetType : int8_t {
  TargetType_SUBMARINE = 0,
  TargetType_SURFACE_SHIP = 1,
  TargetType_TORPEDO = 2,
  TargetType_MINE = 3,
  TargetType_BIOLOGICAL = 4,
  TargetType_WRECK = 5,
  TargetType_UNKNOWN = 6,
  TargetType_MIN = TargetType_SUBMARINE,
  TargetType_MAX = TargetType_UNKNOWN
};

inline const TargetType (&EnumValuesTargetType())[7] {
  static const TargetType values[] = {
    TargetType_SUBMARINE,
    TargetType_SURFACE_SHIP,
    TargetType_TORPEDO,
    TargetType_MINE,
    TargetType_BIOLOGICAL,
    TargetType_WRECK,
    TargetType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesTargetType() {
  static const char * const names[8] = {
    "SUBMARINE",
    "SURFACE_SHIP",
    "TORPEDO",
    "MINE",
    "BIOLOGICAL",
    "WRECK",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTargetType(TargetType e) {
  if (::flatbuffers::IsOutRange(e, TargetType_SUBMARINE, TargetType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTargetType()[index];
}

enum TorpedoGuidanceMode : int8_t {
  TorpedoGuidanceMode_WIRE_GUIDED = 0,
  TorpedoGuidanceMode_ACTIVE_HOMING = 1,
  TorpedoGuidanceMode_PASSIVE_HOMING = 2,
  TorpedoGuidanceMode_WAKE_HOMING = 3,
  TorpedoGuidanceMode_PATTERN_SEARCH = 4,
  TorpedoGuidanceMode_SNAKE_SEARCH = 5,
  TorpedoGuidanceMode_CEILING_BOUNCE = 6,
  TorpedoGuidanceMode_MIN = TorpedoGuidanceMode_WIRE_GUIDED,
  TorpedoGuidanceMode_MAX = TorpedoGuidanceMode_CEILING_BOUNCE
};

inline const TorpedoGuidanceMode (&EnumValuesTorpedoGuidanceMode())[7] {
  static const TorpedoGuidanceMode values[] = {
    TorpedoGuidanceMode_WIRE_GUIDED,
    TorpedoGuidanceMode_ACTIVE_HOMING,
    TorpedoGuidanceMode_PASSIVE_HOMING,
    TorpedoGuidanceMode_WAKE_HOMING,
    TorpedoGuidanceMode_PATTERN_SEARCH,
    TorpedoGuidanceMode_SNAKE_SEARCH,
    TorpedoGuidanceMode_CEILING_BOUNCE
  };
  return values;
}

inline const char * const *EnumNamesTorpedoGuidanceMode() {
  static const char * const names[8] = {
    "WIRE_GUIDED",
    "ACTIVE_HOMING",
    "PASSIVE_HOMING",
    "WAKE_HOMING",
    "PATTERN_SEARCH",
    "SNAKE_SEARCH",
    "CEILING_BOUNCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTorpedoGuidanceMode(TorpedoGuidanceMode e) {
  if (::flatbuffers::IsOutRange(e, TorpedoGuidanceMode_WIRE_GUIDED, TorpedoGuidanceMode_CEILING_BOUNCE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTorpedoGuidanceMode()[index];
}

/// Sonar and Underwater Acoustics
struct SON FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_ACTIVE_CONFIG = 6,
    VT_PASSIVE_CONFIG = 8,
    VT_TL_REQUEST = 10,
    VT_ENVIRONMENT = 12,
    VT_TARGET_SIGNATURE = 14,
    VT_TMA_INPUT = 16,
    VT_TORPEDO_SEEKER = 18
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *ACTIVE_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTIVE_CONFIG);
  }
  const ::flatbuffers::String *PASSIVE_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSIVE_CONFIG);
  }
  const ::flatbuffers::String *TL_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TL_REQUEST);
  }
  const ::flatbuffers::String *ENVIRONMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENVIRONMENT);
  }
  const ::flatbuffers::String *TARGET_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_SIGNATURE);
  }
  const ::flatbuffers::String *TMA_INPUT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TMA_INPUT);
  }
  const ::flatbuffers::String *TORPEDO_SEEKER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TORPEDO_SEEKER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_ACTIVE_CONFIG) &&
           verifier.VerifyString(ACTIVE_CONFIG()) &&
           VerifyOffset(verifier, VT_PASSIVE_CONFIG) &&
           verifier.VerifyString(PASSIVE_CONFIG()) &&
           VerifyOffset(verifier, VT_TL_REQUEST) &&
           verifier.VerifyString(TL_REQUEST()) &&
           VerifyOffset(verifier, VT_ENVIRONMENT) &&
           verifier.VerifyString(ENVIRONMENT()) &&
           VerifyOffset(verifier, VT_TARGET_SIGNATURE) &&
           verifier.VerifyString(TARGET_SIGNATURE()) &&
           VerifyOffset(verifier, VT_TMA_INPUT) &&
           verifier.VerifyString(TMA_INPUT()) &&
           VerifyOffset(verifier, VT_TORPEDO_SEEKER) &&
           verifier.VerifyString(TORPEDO_SEEKER()) &&
           verifier.EndTable();
  }
};

struct SONBuilder {
  typedef SON Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(SON::VT_COMMAND, COMMAND);
  }
  void add_ACTIVE_CONFIG(::flatbuffers::Offset<::flatbuffers::String> ACTIVE_CONFIG) {
    fbb_.AddOffset(SON::VT_ACTIVE_CONFIG, ACTIVE_CONFIG);
  }
  void add_PASSIVE_CONFIG(::flatbuffers::Offset<::flatbuffers::String> PASSIVE_CONFIG) {
    fbb_.AddOffset(SON::VT_PASSIVE_CONFIG, PASSIVE_CONFIG);
  }
  void add_TL_REQUEST(::flatbuffers::Offset<::flatbuffers::String> TL_REQUEST) {
    fbb_.AddOffset(SON::VT_TL_REQUEST, TL_REQUEST);
  }
  void add_ENVIRONMENT(::flatbuffers::Offset<::flatbuffers::String> ENVIRONMENT) {
    fbb_.AddOffset(SON::VT_ENVIRONMENT, ENVIRONMENT);
  }
  void add_TARGET_SIGNATURE(::flatbuffers::Offset<::flatbuffers::String> TARGET_SIGNATURE) {
    fbb_.AddOffset(SON::VT_TARGET_SIGNATURE, TARGET_SIGNATURE);
  }
  void add_TMA_INPUT(::flatbuffers::Offset<::flatbuffers::String> TMA_INPUT) {
    fbb_.AddOffset(SON::VT_TMA_INPUT, TMA_INPUT);
  }
  void add_TORPEDO_SEEKER(::flatbuffers::Offset<::flatbuffers::String> TORPEDO_SEEKER) {
    fbb_.AddOffset(SON::VT_TORPEDO_SEEKER, TORPEDO_SEEKER);
  }
  explicit SONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SON> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SON>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SON> CreateSON(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ACTIVE_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PASSIVE_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TL_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ENVIRONMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TARGET_SIGNATURE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TMA_INPUT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TORPEDO_SEEKER = 0) {
  SONBuilder builder_(_fbb);
  builder_.add_TORPEDO_SEEKER(TORPEDO_SEEKER);
  builder_.add_TMA_INPUT(TMA_INPUT);
  builder_.add_TARGET_SIGNATURE(TARGET_SIGNATURE);
  builder_.add_ENVIRONMENT(ENVIRONMENT);
  builder_.add_TL_REQUEST(TL_REQUEST);
  builder_.add_PASSIVE_CONFIG(PASSIVE_CONFIG);
  builder_.add_ACTIVE_CONFIG(ACTIVE_CONFIG);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SON> CreateSONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *ACTIVE_CONFIG = nullptr,
    const char *PASSIVE_CONFIG = nullptr,
    const char *TL_REQUEST = nullptr,
    const char *ENVIRONMENT = nullptr,
    const char *TARGET_SIGNATURE = nullptr,
    const char *TMA_INPUT = nullptr,
    const char *TORPEDO_SEEKER = nullptr) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto ACTIVE_CONFIG__ = ACTIVE_CONFIG ? _fbb.CreateString(ACTIVE_CONFIG) : 0;
  auto PASSIVE_CONFIG__ = PASSIVE_CONFIG ? _fbb.CreateString(PASSIVE_CONFIG) : 0;
  auto TL_REQUEST__ = TL_REQUEST ? _fbb.CreateString(TL_REQUEST) : 0;
  auto ENVIRONMENT__ = ENVIRONMENT ? _fbb.CreateString(ENVIRONMENT) : 0;
  auto TARGET_SIGNATURE__ = TARGET_SIGNATURE ? _fbb.CreateString(TARGET_SIGNATURE) : 0;
  auto TMA_INPUT__ = TMA_INPUT ? _fbb.CreateString(TMA_INPUT) : 0;
  auto TORPEDO_SEEKER__ = TORPEDO_SEEKER ? _fbb.CreateString(TORPEDO_SEEKER) : 0;
  return CreateSON(
      _fbb,
      COMMAND__,
      ACTIVE_CONFIG__,
      PASSIVE_CONFIG__,
      TL_REQUEST__,
      ENVIRONMENT__,
      TARGET_SIGNATURE__,
      TMA_INPUT__,
      TORPEDO_SEEKER__);
}

inline const SON *GetSON(const void *buf) {
  return ::flatbuffers::GetRoot<SON>(buf);
}

inline const SON *GetSizePrefixedSON(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SON>(buf);
}

inline const char *SONIdentifier() {
  return "$SON";
}

inline bool SONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SONIdentifier());
}

inline bool SizePrefixedSONBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SONIdentifier(), true);
}

inline bool VerifySONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SON>(SONIdentifier());
}

inline bool VerifySizePrefixedSONBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SON>(SONIdentifier());
}

inline void FinishSONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SON> root) {
  fbb.Finish(root, SONIdentifier());
}

inline void FinishSizePrefixedSONBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SON> root) {
  fbb.FinishSizePrefixed(root, SONIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
