// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

struct CRM;
struct CRMBuilder;

struct CRMCOLLECTION;
struct CRMCOLLECTIONBuilder;

/// Collection Request Message
struct CRM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CRMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATION = 6,
    VT_TYPE = 8,
    VT_ID_PLAN = 10,
    VT_PLAN_INDEX = 12,
    VT_TASK_ID = 14,
    VT_DWELL_ID = 16,
    VT_EXTERNAL_ID = 18,
    VT_ID_SENSOR = 20,
    VT_ORIG_SENSOR_ID = 22,
    VT_OB_TYPE = 24,
    VT_PRIORITY = 26,
    VT_TASK_CATEGORY = 28,
    VT_SUFFIX = 30,
    VT_UCT_FOLLOW_UP = 32,
    VT_START_TIME = 34,
    VT_END_TIME = 36,
    VT_NORAD_CAT_ID = 38,
    VT_ORIG_OBJECT_ID = 40,
    VT_TASK_GROUP = 42,
    VT_IRON = 44,
    VT_ORBIT_REGIME = 46,
    VT_TARGET_SIZE = 48,
    VT_RCS_MIN = 50,
    VT_RCS = 52,
    VT_RCS_MAX = 54,
    VT_FREQ_MIN = 56,
    VT_FREQ = 58,
    VT_FREQ_MAX = 60,
    VT_POLARIZATION = 62,
    VT_VIS_MAG_MIN = 64,
    VT_VIS_MAG = 66,
    VT_VIS_MAG_MAX = 68,
    VT_SPECTRAL_MODEL = 70,
    VT_REFLECTANCE = 72,
    VT_IRRADIANCE = 74,
    VT_NUM_FRAMES = 76,
    VT_FRAME_RATE = 78,
    VT_INTEGRATION_TIME = 80,
    VT_NUM_TRACKS = 82,
    VT_NUM_OBS = 84,
    VT_DURATION = 86,
    VT_SRCH_PATTERN = 88,
    VT_SCENARIO = 90,
    VT_ID_ELSET = 92,
    VT_ID_MANIFOLD = 94,
    VT_ID_STATE_VECTOR = 96,
    VT_ES_ID = 98,
    VT_EPOCH = 100,
    VT_SEMI_MAJOR_AXIS = 102,
    VT_ECCENTRICITY = 104,
    VT_INCLINATION = 106,
    VT_RAAN = 108,
    VT_ARG_OF_PERIGEE = 110,
    VT_MEAN_ANOMALY = 112,
    VT_RA = 114,
    VT_DEC = 116,
    VT_AZ = 118,
    VT_EL = 120,
    VT_RANGE = 122,
    VT_EXTENT_AZ = 124,
    VT_EXTENT_EL = 126,
    VT_EXTENT_RANGE = 128,
    VT_LAT = 130,
    VT_LON = 132,
    VT_ALT = 134,
    VT_STOP_LAT = 136,
    VT_STOP_LON = 138,
    VT_STOP_ALT = 140,
    VT_SRCH_INC = 142,
    VT_X_ANGLE = 144,
    VT_Y_ANGLE = 146,
    VT_ORIENT_ANGLE = 148,
    VT_CUSTOMER = 150,
    VT_NOTES = 152,
    VT_SOURCE = 154,
    VT_ORIGIN = 156,
    VT_DATA_MODE = 158
  };
  /// Unique identifier of the record, auto-generated by the system.
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  const ::flatbuffers::String *CLASSIFICATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATION);
  }
  /// The type of this collect or contact request.
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Unique identifier of the parent plan or schedule associated with this request.
  const ::flatbuffers::String *ID_PLAN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_PLAN);
  }
  /// Index number for records within a collection plan or schedule.
  int32_t PLAN_INDEX() const {
    return GetField<int32_t>(VT_PLAN_INDEX, 0);
  }
  /// Task ID associated with this request.
  const ::flatbuffers::String *TASK_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_ID);
  }
  /// The dwell ID associated with this request.
  const ::flatbuffers::String *DWELL_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DWELL_ID);
  }
  /// Optional ID from external systems.
  const ::flatbuffers::String *EXTERNAL_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNAL_ID);
  }
  /// Unique identifier of the requested/scheduled/planned sensor associated with this request.
  const ::flatbuffers::String *ID_SENSOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_SENSOR);
  }
  /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
  const ::flatbuffers::String *ORIG_SENSOR_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_SENSOR_ID);
  }
  /// Optional type of observation requested.
  const ::flatbuffers::String *OB_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OB_TYPE);
  }
  /// The priority of the collect request.
  const ::flatbuffers::String *PRIORITY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIORITY);
  }
  /// The tasking category associated with this request.
  int32_t TASK_CATEGORY() const {
    return GetField<int32_t>(VT_TASK_CATEGORY, 0);
  }
  /// The tasking suffix associated with this request.
  const ::flatbuffers::String *SUFFIX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUFFIX);
  }
  /// Boolean indicating that this collect request is UCT follow-up.
  bool UCT_FOLLOW_UP() const {
    return GetField<uint8_t>(VT_UCT_FOLLOW_UP, 0) != 0;
  }
  /// The start time of the collect or contact request window, in ISO 8601 UTC format.
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  /// The end time of the collect or contact request window, in ISO 8601 UTC format.
  const ::flatbuffers::String *END_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_TIME);
  }
  /// Satellite/catalog number of the target on-orbit object for this request.
  uint32_t NORAD_CAT_ID() const {
    return GetField<uint32_t>(VT_NORAD_CAT_ID, 0);
  }
  /// Optional identifier provided by the data source to indicate the target object of this request.
  const ::flatbuffers::String *ORIG_OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIG_OBJECT_ID);
  }
  /// The tasking group to which the target object is assigned.
  const ::flatbuffers::String *TASK_GROUP() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASK_GROUP);
  }
  /// Inter-Range Operations Number.
  int32_t IRON() const {
    return GetField<int32_t>(VT_IRON, 0);
  }
  /// The orbit regime of the target.
  const ::flatbuffers::String *ORBIT_REGIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBIT_REGIME);
  }
  /// The minimum object (diameter) size, in meters, to be reported.
  double TARGET_SIZE() const {
    return GetField<double>(VT_TARGET_SIZE, 0.0);
  }
  /// The minimum Radar Cross-Section of the target, in m^2.
  double RCS_MIN() const {
    return GetField<double>(VT_RCS_MIN, 0.0);
  }
  /// The Radar Cross-Section of the target, in m^2.
  double RCS() const {
    return GetField<double>(VT_RCS, 0.0);
  }
  /// The maximum Radar Cross-Section of the target, in m^2.
  double RCS_MAX() const {
    return GetField<double>(VT_RCS_MAX, 0.0);
  }
  /// The minimum frequency of interest, in MHz.
  double FREQ_MIN() const {
    return GetField<double>(VT_FREQ_MIN, 0.0);
  }
  /// The estimated or expected emission frequency of the target, in MHz.
  double FREQ() const {
    return GetField<double>(VT_FREQ, 0.0);
  }
  /// The maximum frequency of interest, in MHz.
  double FREQ_MAX() const {
    return GetField<double>(VT_FREQ_MAX, 0.0);
  }
  /// The RF polarization.
  const ::flatbuffers::String *POLARIZATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POLARIZATION);
  }
  /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
  double VIS_MAG_MIN() const {
    return GetField<double>(VT_VIS_MAG_MIN, 0.0);
  }
  /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
  double VIS_MAG() const {
    return GetField<double>(VT_VIS_MAG, 0.0);
  }
  /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
  double VIS_MAG_MAX() const {
    return GetField<double>(VT_VIS_MAG_MAX, 0.0);
  }
  /// The spectral model used for the irradiance calculation.
  const ::flatbuffers::String *SPECTRAL_MODEL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECTRAL_MODEL);
  }
  /// The fraction of solar energy reflected from target.
  double REFLECTANCE() const {
    return GetField<double>(VT_REFLECTANCE, 0.0);
  }
  /// The target object irradiance value.
  double IRRADIANCE() const {
    return GetField<double>(VT_IRRADIANCE, 0.0);
  }
  /// For optical sensors, the requested number of frames to capture at each sensor step.
  int32_t NUM_FRAMES() const {
    return GetField<int32_t>(VT_NUM_FRAMES, 0);
  }
  /// For optical sensors, the frame rate of the camera, in Hz.
  double FRAME_RATE() const {
    return GetField<double>(VT_FRAME_RATE, 0.0);
  }
  /// For optical sensors, the integration time per camera frame, in milliseconds.
  double INTEGRATION_TIME() const {
    return GetField<double>(VT_INTEGRATION_TIME, 0.0);
  }
  /// The number of requested tracks on the target.
  int32_t NUM_TRACKS() const {
    return GetField<int32_t>(VT_NUM_TRACKS, 0);
  }
  /// The number of requested observations on the target.
  int32_t NUM_OBS() const {
    return GetField<int32_t>(VT_NUM_OBS, 0);
  }
  /// The duration of the collect request, in seconds.
  int32_t DURATION() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  /// The search pattern to be executed for this request.
  const ::flatbuffers::String *SRCH_PATTERN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SRCH_PATTERN);
  }
  /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
  const ::flatbuffers::String *SCENARIO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCENARIO);
  }
  /// ID of the Elset of the object associated with this request.
  const ::flatbuffers::String *ID_ELSET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_ELSET);
  }
  /// ID of the Manifold Elset of the object associated with this request.
  const ::flatbuffers::String *ID_MANIFOLD() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_MANIFOLD);
  }
  /// ID of the State Vector of the object or central vector associated with this request.
  const ::flatbuffers::String *ID_STATE_VECTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID_STATE_VECTOR);
  }
  /// ID of the Ephemeris Set of the object associated with this request.
  const ::flatbuffers::String *ES_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ES_ID);
  }
  /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// The average of the periapsis and apoapsis distances, in kilometers.
  double SEMI_MAJOR_AXIS() const {
    return GetField<double>(VT_SEMI_MAJOR_AXIS, 0.0);
  }
  /// The orbital eccentricity of an astronomical object.
  double ECCENTRICITY() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  /// The angle, in degrees, between the equator and the orbit plane.
  double INCLINATION() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Right ascension of the ascending node, in degrees.
  double RAAN() const {
    return GetField<double>(VT_RAAN, 0.0);
  }
  /// The argument of perigee, in degrees.
  double ARG_OF_PERIGEE() const {
    return GetField<double>(VT_ARG_OF_PERIGEE, 0.0);
  }
  /// The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
  double MEAN_ANOMALY() const {
    return GetField<double>(VT_MEAN_ANOMALY, 0.0);
  }
  /// The expected or directed right ascension angle, in degrees.
  double RA() const {
    return GetField<double>(VT_RA, 0.0);
  }
  /// The expected or directed declination angle, in degrees.
  double DEC() const {
    return GetField<double>(VT_DEC, 0.0);
  }
  /// The expected or directed azimuth angle, in degrees.
  double AZ() const {
    return GetField<double>(VT_AZ, 0.0);
  }
  /// The expected or directed elevation angle, in degrees.
  double EL() const {
    return GetField<double>(VT_EL, 0.0);
  }
  /// The expected acquisition range or defined center range, in km.
  double RANGE() const {
    return GetField<double>(VT_RANGE, 0.0);
  }
  /// The extent of the azimuth angle, in degrees, from center azimuth.
  double EXTENT_AZ() const {
    return GetField<double>(VT_EXTENT_AZ, 0.0);
  }
  /// The extent of the elevation angle, in degrees, from center elevation.
  double EXTENT_EL() const {
    return GetField<double>(VT_EXTENT_EL, 0.0);
  }
  /// The extent of the range, in km, from center range.
  double EXTENT_RANGE() const {
    return GetField<double>(VT_EXTENT_RANGE, 0.0);
  }
  /// WGS-84 latitude, in degrees.
  double LAT() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// WGS-84 longitude, in degrees.
  double LON() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// Height above WGS-84 ellipsoid (HAE), in kilometers.
  double ALT() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  /// The stopping WGS-84 latitude of a volume definition, in degrees.
  double STOP_LAT() const {
    return GetField<double>(VT_STOP_LAT, 0.0);
  }
  /// The stopping WGS-84 longitude of a volume definition, in degrees.
  double STOP_LON() const {
    return GetField<double>(VT_STOP_LON, 0.0);
  }
  /// The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
  double STOP_ALT() const {
    return GetField<double>(VT_STOP_ALT, 0.0);
  }
  /// The maximum inclination, in degrees, to be used in search operations.
  double SRCH_INC() const {
    return GetField<double>(VT_SRCH_INC, 0.0);
  }
  /// The angular distance, in degrees, in the sensor-x direction from scan center.
  double X_ANGLE() const {
    return GetField<double>(VT_X_ANGLE, 0.0);
  }
  /// The angular distance, in degrees, in the sensor-y direction from scan center.
  double Y_ANGLE() const {
    return GetField<double>(VT_Y_ANGLE, 0.0);
  }
  /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
  double ORIENT_ANGLE() const {
    return GetField<double>(VT_ORIENT_ANGLE, 0.0);
  }
  /// The customer for this request.
  const ::flatbuffers::String *CUSTOMER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOMER);
  }
  /// Notes or comments associated with this request.
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  ///  Source of the data.
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  ///  Originating system or organization which produced the data, if different from the source.
  const ::flatbuffers::String *ORIGIN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
  const ::flatbuffers::String *DATA_MODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATA_MODE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_CLASSIFICATION) &&
           verifier.VerifyString(CLASSIFICATION()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyOffset(verifier, VT_ID_PLAN) &&
           verifier.VerifyString(ID_PLAN()) &&
           VerifyField<int32_t>(verifier, VT_PLAN_INDEX, 4) &&
           VerifyOffset(verifier, VT_TASK_ID) &&
           verifier.VerifyString(TASK_ID()) &&
           VerifyOffset(verifier, VT_DWELL_ID) &&
           verifier.VerifyString(DWELL_ID()) &&
           VerifyOffset(verifier, VT_EXTERNAL_ID) &&
           verifier.VerifyString(EXTERNAL_ID()) &&
           VerifyOffset(verifier, VT_ID_SENSOR) &&
           verifier.VerifyString(ID_SENSOR()) &&
           VerifyOffset(verifier, VT_ORIG_SENSOR_ID) &&
           verifier.VerifyString(ORIG_SENSOR_ID()) &&
           VerifyOffset(verifier, VT_OB_TYPE) &&
           verifier.VerifyString(OB_TYPE()) &&
           VerifyOffset(verifier, VT_PRIORITY) &&
           verifier.VerifyString(PRIORITY()) &&
           VerifyField<int32_t>(verifier, VT_TASK_CATEGORY, 4) &&
           VerifyOffset(verifier, VT_SUFFIX) &&
           verifier.VerifyString(SUFFIX()) &&
           VerifyField<uint8_t>(verifier, VT_UCT_FOLLOW_UP, 1) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_END_TIME) &&
           verifier.VerifyString(END_TIME()) &&
           VerifyField<uint32_t>(verifier, VT_NORAD_CAT_ID, 4) &&
           VerifyOffset(verifier, VT_ORIG_OBJECT_ID) &&
           verifier.VerifyString(ORIG_OBJECT_ID()) &&
           VerifyOffset(verifier, VT_TASK_GROUP) &&
           verifier.VerifyString(TASK_GROUP()) &&
           VerifyField<int32_t>(verifier, VT_IRON, 4) &&
           VerifyOffset(verifier, VT_ORBIT_REGIME) &&
           verifier.VerifyString(ORBIT_REGIME()) &&
           VerifyField<double>(verifier, VT_TARGET_SIZE, 8) &&
           VerifyField<double>(verifier, VT_RCS_MIN, 8) &&
           VerifyField<double>(verifier, VT_RCS, 8) &&
           VerifyField<double>(verifier, VT_RCS_MAX, 8) &&
           VerifyField<double>(verifier, VT_FREQ_MIN, 8) &&
           VerifyField<double>(verifier, VT_FREQ, 8) &&
           VerifyField<double>(verifier, VT_FREQ_MAX, 8) &&
           VerifyOffset(verifier, VT_POLARIZATION) &&
           verifier.VerifyString(POLARIZATION()) &&
           VerifyField<double>(verifier, VT_VIS_MAG_MIN, 8) &&
           VerifyField<double>(verifier, VT_VIS_MAG, 8) &&
           VerifyField<double>(verifier, VT_VIS_MAG_MAX, 8) &&
           VerifyOffset(verifier, VT_SPECTRAL_MODEL) &&
           verifier.VerifyString(SPECTRAL_MODEL()) &&
           VerifyField<double>(verifier, VT_REFLECTANCE, 8) &&
           VerifyField<double>(verifier, VT_IRRADIANCE, 8) &&
           VerifyField<int32_t>(verifier, VT_NUM_FRAMES, 4) &&
           VerifyField<double>(verifier, VT_FRAME_RATE, 8) &&
           VerifyField<double>(verifier, VT_INTEGRATION_TIME, 8) &&
           VerifyField<int32_t>(verifier, VT_NUM_TRACKS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUM_OBS, 4) &&
           VerifyField<int32_t>(verifier, VT_DURATION, 4) &&
           VerifyOffset(verifier, VT_SRCH_PATTERN) &&
           verifier.VerifyString(SRCH_PATTERN()) &&
           VerifyOffset(verifier, VT_SCENARIO) &&
           verifier.VerifyString(SCENARIO()) &&
           VerifyOffset(verifier, VT_ID_ELSET) &&
           verifier.VerifyString(ID_ELSET()) &&
           VerifyOffset(verifier, VT_ID_MANIFOLD) &&
           verifier.VerifyString(ID_MANIFOLD()) &&
           VerifyOffset(verifier, VT_ID_STATE_VECTOR) &&
           verifier.VerifyString(ID_STATE_VECTOR()) &&
           VerifyOffset(verifier, VT_ES_ID) &&
           verifier.VerifyString(ES_ID()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_SEMI_MAJOR_AXIS, 8) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_RAAN, 8) &&
           VerifyField<double>(verifier, VT_ARG_OF_PERIGEE, 8) &&
           VerifyField<double>(verifier, VT_MEAN_ANOMALY, 8) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_DEC, 8) &&
           VerifyField<double>(verifier, VT_AZ, 8) &&
           VerifyField<double>(verifier, VT_EL, 8) &&
           VerifyField<double>(verifier, VT_RANGE, 8) &&
           VerifyField<double>(verifier, VT_EXTENT_AZ, 8) &&
           VerifyField<double>(verifier, VT_EXTENT_EL, 8) &&
           VerifyField<double>(verifier, VT_EXTENT_RANGE, 8) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_ALT, 8) &&
           VerifyField<double>(verifier, VT_STOP_LAT, 8) &&
           VerifyField<double>(verifier, VT_STOP_LON, 8) &&
           VerifyField<double>(verifier, VT_STOP_ALT, 8) &&
           VerifyField<double>(verifier, VT_SRCH_INC, 8) &&
           VerifyField<double>(verifier, VT_X_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_Y_ANGLE, 8) &&
           VerifyField<double>(verifier, VT_ORIENT_ANGLE, 8) &&
           VerifyOffset(verifier, VT_CUSTOMER) &&
           verifier.VerifyString(CUSTOMER()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(ORIGIN()) &&
           VerifyOffset(verifier, VT_DATA_MODE) &&
           verifier.VerifyString(DATA_MODE()) &&
           verifier.EndTable();
  }
};

struct CRMBuilder {
  typedef CRM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(CRM::VT_ID, ID);
  }
  void add_CLASSIFICATION(::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION) {
    fbb_.AddOffset(CRM::VT_CLASSIFICATION, CLASSIFICATION);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(CRM::VT_TYPE, TYPE);
  }
  void add_ID_PLAN(::flatbuffers::Offset<::flatbuffers::String> ID_PLAN) {
    fbb_.AddOffset(CRM::VT_ID_PLAN, ID_PLAN);
  }
  void add_PLAN_INDEX(int32_t PLAN_INDEX) {
    fbb_.AddElement<int32_t>(CRM::VT_PLAN_INDEX, PLAN_INDEX, 0);
  }
  void add_TASK_ID(::flatbuffers::Offset<::flatbuffers::String> TASK_ID) {
    fbb_.AddOffset(CRM::VT_TASK_ID, TASK_ID);
  }
  void add_DWELL_ID(::flatbuffers::Offset<::flatbuffers::String> DWELL_ID) {
    fbb_.AddOffset(CRM::VT_DWELL_ID, DWELL_ID);
  }
  void add_EXTERNAL_ID(::flatbuffers::Offset<::flatbuffers::String> EXTERNAL_ID) {
    fbb_.AddOffset(CRM::VT_EXTERNAL_ID, EXTERNAL_ID);
  }
  void add_ID_SENSOR(::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR) {
    fbb_.AddOffset(CRM::VT_ID_SENSOR, ID_SENSOR);
  }
  void add_ORIG_SENSOR_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID) {
    fbb_.AddOffset(CRM::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  void add_OB_TYPE(::flatbuffers::Offset<::flatbuffers::String> OB_TYPE) {
    fbb_.AddOffset(CRM::VT_OB_TYPE, OB_TYPE);
  }
  void add_PRIORITY(::flatbuffers::Offset<::flatbuffers::String> PRIORITY) {
    fbb_.AddOffset(CRM::VT_PRIORITY, PRIORITY);
  }
  void add_TASK_CATEGORY(int32_t TASK_CATEGORY) {
    fbb_.AddElement<int32_t>(CRM::VT_TASK_CATEGORY, TASK_CATEGORY, 0);
  }
  void add_SUFFIX(::flatbuffers::Offset<::flatbuffers::String> SUFFIX) {
    fbb_.AddOffset(CRM::VT_SUFFIX, SUFFIX);
  }
  void add_UCT_FOLLOW_UP(bool UCT_FOLLOW_UP) {
    fbb_.AddElement<uint8_t>(CRM::VT_UCT_FOLLOW_UP, static_cast<uint8_t>(UCT_FOLLOW_UP), 0);
  }
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(CRM::VT_START_TIME, START_TIME);
  }
  void add_END_TIME(::flatbuffers::Offset<::flatbuffers::String> END_TIME) {
    fbb_.AddOffset(CRM::VT_END_TIME, END_TIME);
  }
  void add_NORAD_CAT_ID(uint32_t NORAD_CAT_ID) {
    fbb_.AddElement<uint32_t>(CRM::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  void add_ORIG_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID) {
    fbb_.AddOffset(CRM::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  void add_TASK_GROUP(::flatbuffers::Offset<::flatbuffers::String> TASK_GROUP) {
    fbb_.AddOffset(CRM::VT_TASK_GROUP, TASK_GROUP);
  }
  void add_IRON(int32_t IRON) {
    fbb_.AddElement<int32_t>(CRM::VT_IRON, IRON, 0);
  }
  void add_ORBIT_REGIME(::flatbuffers::Offset<::flatbuffers::String> ORBIT_REGIME) {
    fbb_.AddOffset(CRM::VT_ORBIT_REGIME, ORBIT_REGIME);
  }
  void add_TARGET_SIZE(double TARGET_SIZE) {
    fbb_.AddElement<double>(CRM::VT_TARGET_SIZE, TARGET_SIZE, 0.0);
  }
  void add_RCS_MIN(double RCS_MIN) {
    fbb_.AddElement<double>(CRM::VT_RCS_MIN, RCS_MIN, 0.0);
  }
  void add_RCS(double RCS) {
    fbb_.AddElement<double>(CRM::VT_RCS, RCS, 0.0);
  }
  void add_RCS_MAX(double RCS_MAX) {
    fbb_.AddElement<double>(CRM::VT_RCS_MAX, RCS_MAX, 0.0);
  }
  void add_FREQ_MIN(double FREQ_MIN) {
    fbb_.AddElement<double>(CRM::VT_FREQ_MIN, FREQ_MIN, 0.0);
  }
  void add_FREQ(double FREQ) {
    fbb_.AddElement<double>(CRM::VT_FREQ, FREQ, 0.0);
  }
  void add_FREQ_MAX(double FREQ_MAX) {
    fbb_.AddElement<double>(CRM::VT_FREQ_MAX, FREQ_MAX, 0.0);
  }
  void add_POLARIZATION(::flatbuffers::Offset<::flatbuffers::String> POLARIZATION) {
    fbb_.AddOffset(CRM::VT_POLARIZATION, POLARIZATION);
  }
  void add_VIS_MAG_MIN(double VIS_MAG_MIN) {
    fbb_.AddElement<double>(CRM::VT_VIS_MAG_MIN, VIS_MAG_MIN, 0.0);
  }
  void add_VIS_MAG(double VIS_MAG) {
    fbb_.AddElement<double>(CRM::VT_VIS_MAG, VIS_MAG, 0.0);
  }
  void add_VIS_MAG_MAX(double VIS_MAG_MAX) {
    fbb_.AddElement<double>(CRM::VT_VIS_MAG_MAX, VIS_MAG_MAX, 0.0);
  }
  void add_SPECTRAL_MODEL(::flatbuffers::Offset<::flatbuffers::String> SPECTRAL_MODEL) {
    fbb_.AddOffset(CRM::VT_SPECTRAL_MODEL, SPECTRAL_MODEL);
  }
  void add_REFLECTANCE(double REFLECTANCE) {
    fbb_.AddElement<double>(CRM::VT_REFLECTANCE, REFLECTANCE, 0.0);
  }
  void add_IRRADIANCE(double IRRADIANCE) {
    fbb_.AddElement<double>(CRM::VT_IRRADIANCE, IRRADIANCE, 0.0);
  }
  void add_NUM_FRAMES(int32_t NUM_FRAMES) {
    fbb_.AddElement<int32_t>(CRM::VT_NUM_FRAMES, NUM_FRAMES, 0);
  }
  void add_FRAME_RATE(double FRAME_RATE) {
    fbb_.AddElement<double>(CRM::VT_FRAME_RATE, FRAME_RATE, 0.0);
  }
  void add_INTEGRATION_TIME(double INTEGRATION_TIME) {
    fbb_.AddElement<double>(CRM::VT_INTEGRATION_TIME, INTEGRATION_TIME, 0.0);
  }
  void add_NUM_TRACKS(int32_t NUM_TRACKS) {
    fbb_.AddElement<int32_t>(CRM::VT_NUM_TRACKS, NUM_TRACKS, 0);
  }
  void add_NUM_OBS(int32_t NUM_OBS) {
    fbb_.AddElement<int32_t>(CRM::VT_NUM_OBS, NUM_OBS, 0);
  }
  void add_DURATION(int32_t DURATION) {
    fbb_.AddElement<int32_t>(CRM::VT_DURATION, DURATION, 0);
  }
  void add_SRCH_PATTERN(::flatbuffers::Offset<::flatbuffers::String> SRCH_PATTERN) {
    fbb_.AddOffset(CRM::VT_SRCH_PATTERN, SRCH_PATTERN);
  }
  void add_SCENARIO(::flatbuffers::Offset<::flatbuffers::String> SCENARIO) {
    fbb_.AddOffset(CRM::VT_SCENARIO, SCENARIO);
  }
  void add_ID_ELSET(::flatbuffers::Offset<::flatbuffers::String> ID_ELSET) {
    fbb_.AddOffset(CRM::VT_ID_ELSET, ID_ELSET);
  }
  void add_ID_MANIFOLD(::flatbuffers::Offset<::flatbuffers::String> ID_MANIFOLD) {
    fbb_.AddOffset(CRM::VT_ID_MANIFOLD, ID_MANIFOLD);
  }
  void add_ID_STATE_VECTOR(::flatbuffers::Offset<::flatbuffers::String> ID_STATE_VECTOR) {
    fbb_.AddOffset(CRM::VT_ID_STATE_VECTOR, ID_STATE_VECTOR);
  }
  void add_ES_ID(::flatbuffers::Offset<::flatbuffers::String> ES_ID) {
    fbb_.AddOffset(CRM::VT_ES_ID, ES_ID);
  }
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(CRM::VT_EPOCH, EPOCH);
  }
  void add_SEMI_MAJOR_AXIS(double SEMI_MAJOR_AXIS) {
    fbb_.AddElement<double>(CRM::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  void add_ECCENTRICITY(double ECCENTRICITY) {
    fbb_.AddElement<double>(CRM::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  void add_INCLINATION(double INCLINATION) {
    fbb_.AddElement<double>(CRM::VT_INCLINATION, INCLINATION, 0.0);
  }
  void add_RAAN(double RAAN) {
    fbb_.AddElement<double>(CRM::VT_RAAN, RAAN, 0.0);
  }
  void add_ARG_OF_PERIGEE(double ARG_OF_PERIGEE) {
    fbb_.AddElement<double>(CRM::VT_ARG_OF_PERIGEE, ARG_OF_PERIGEE, 0.0);
  }
  void add_MEAN_ANOMALY(double MEAN_ANOMALY) {
    fbb_.AddElement<double>(CRM::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  void add_RA(double RA) {
    fbb_.AddElement<double>(CRM::VT_RA, RA, 0.0);
  }
  void add_DEC(double DEC) {
    fbb_.AddElement<double>(CRM::VT_DEC, DEC, 0.0);
  }
  void add_AZ(double AZ) {
    fbb_.AddElement<double>(CRM::VT_AZ, AZ, 0.0);
  }
  void add_EL(double EL) {
    fbb_.AddElement<double>(CRM::VT_EL, EL, 0.0);
  }
  void add_RANGE(double RANGE) {
    fbb_.AddElement<double>(CRM::VT_RANGE, RANGE, 0.0);
  }
  void add_EXTENT_AZ(double EXTENT_AZ) {
    fbb_.AddElement<double>(CRM::VT_EXTENT_AZ, EXTENT_AZ, 0.0);
  }
  void add_EXTENT_EL(double EXTENT_EL) {
    fbb_.AddElement<double>(CRM::VT_EXTENT_EL, EXTENT_EL, 0.0);
  }
  void add_EXTENT_RANGE(double EXTENT_RANGE) {
    fbb_.AddElement<double>(CRM::VT_EXTENT_RANGE, EXTENT_RANGE, 0.0);
  }
  void add_LAT(double LAT) {
    fbb_.AddElement<double>(CRM::VT_LAT, LAT, 0.0);
  }
  void add_LON(double LON) {
    fbb_.AddElement<double>(CRM::VT_LON, LON, 0.0);
  }
  void add_ALT(double ALT) {
    fbb_.AddElement<double>(CRM::VT_ALT, ALT, 0.0);
  }
  void add_STOP_LAT(double STOP_LAT) {
    fbb_.AddElement<double>(CRM::VT_STOP_LAT, STOP_LAT, 0.0);
  }
  void add_STOP_LON(double STOP_LON) {
    fbb_.AddElement<double>(CRM::VT_STOP_LON, STOP_LON, 0.0);
  }
  void add_STOP_ALT(double STOP_ALT) {
    fbb_.AddElement<double>(CRM::VT_STOP_ALT, STOP_ALT, 0.0);
  }
  void add_SRCH_INC(double SRCH_INC) {
    fbb_.AddElement<double>(CRM::VT_SRCH_INC, SRCH_INC, 0.0);
  }
  void add_X_ANGLE(double X_ANGLE) {
    fbb_.AddElement<double>(CRM::VT_X_ANGLE, X_ANGLE, 0.0);
  }
  void add_Y_ANGLE(double Y_ANGLE) {
    fbb_.AddElement<double>(CRM::VT_Y_ANGLE, Y_ANGLE, 0.0);
  }
  void add_ORIENT_ANGLE(double ORIENT_ANGLE) {
    fbb_.AddElement<double>(CRM::VT_ORIENT_ANGLE, ORIENT_ANGLE, 0.0);
  }
  void add_CUSTOMER(::flatbuffers::Offset<::flatbuffers::String> CUSTOMER) {
    fbb_.AddOffset(CRM::VT_CUSTOMER, CUSTOMER);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(CRM::VT_NOTES, NOTES);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(CRM::VT_SOURCE, SOURCE);
  }
  void add_ORIGIN(::flatbuffers::Offset<::flatbuffers::String> ORIGIN) {
    fbb_.AddOffset(CRM::VT_ORIGIN, ORIGIN);
  }
  void add_DATA_MODE(::flatbuffers::Offset<::flatbuffers::String> DATA_MODE) {
    fbb_.AddOffset(CRM::VT_DATA_MODE, DATA_MODE);
  }
  explicit CRMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CRM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CRM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CRM> CreateCRM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLASSIFICATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_PLAN = 0,
    int32_t PLAN_INDEX = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TASK_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DWELL_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EXTERNAL_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_SENSOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_SENSOR_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OB_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PRIORITY = 0,
    int32_t TASK_CATEGORY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SUFFIX = 0,
    bool UCT_FOLLOW_UP = false,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> END_TIME = 0,
    uint32_t NORAD_CAT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIG_OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TASK_GROUP = 0,
    int32_t IRON = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORBIT_REGIME = 0,
    double TARGET_SIZE = 0.0,
    double RCS_MIN = 0.0,
    double RCS = 0.0,
    double RCS_MAX = 0.0,
    double FREQ_MIN = 0.0,
    double FREQ = 0.0,
    double FREQ_MAX = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> POLARIZATION = 0,
    double VIS_MAG_MIN = 0.0,
    double VIS_MAG = 0.0,
    double VIS_MAG_MAX = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> SPECTRAL_MODEL = 0,
    double REFLECTANCE = 0.0,
    double IRRADIANCE = 0.0,
    int32_t NUM_FRAMES = 0,
    double FRAME_RATE = 0.0,
    double INTEGRATION_TIME = 0.0,
    int32_t NUM_TRACKS = 0,
    int32_t NUM_OBS = 0,
    int32_t DURATION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SRCH_PATTERN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SCENARIO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_ELSET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_MANIFOLD = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ID_STATE_VECTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ES_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    double SEMI_MAJOR_AXIS = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RAAN = 0.0,
    double ARG_OF_PERIGEE = 0.0,
    double MEAN_ANOMALY = 0.0,
    double RA = 0.0,
    double DEC = 0.0,
    double AZ = 0.0,
    double EL = 0.0,
    double RANGE = 0.0,
    double EXTENT_AZ = 0.0,
    double EXTENT_EL = 0.0,
    double EXTENT_RANGE = 0.0,
    double LAT = 0.0,
    double LON = 0.0,
    double ALT = 0.0,
    double STOP_LAT = 0.0,
    double STOP_LON = 0.0,
    double STOP_ALT = 0.0,
    double SRCH_INC = 0.0,
    double X_ANGLE = 0.0,
    double Y_ANGLE = 0.0,
    double ORIENT_ANGLE = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> CUSTOMER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGIN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DATA_MODE = 0) {
  CRMBuilder builder_(_fbb);
  builder_.add_ORIENT_ANGLE(ORIENT_ANGLE);
  builder_.add_Y_ANGLE(Y_ANGLE);
  builder_.add_X_ANGLE(X_ANGLE);
  builder_.add_SRCH_INC(SRCH_INC);
  builder_.add_STOP_ALT(STOP_ALT);
  builder_.add_STOP_LON(STOP_LON);
  builder_.add_STOP_LAT(STOP_LAT);
  builder_.add_ALT(ALT);
  builder_.add_LON(LON);
  builder_.add_LAT(LAT);
  builder_.add_EXTENT_RANGE(EXTENT_RANGE);
  builder_.add_EXTENT_EL(EXTENT_EL);
  builder_.add_EXTENT_AZ(EXTENT_AZ);
  builder_.add_RANGE(RANGE);
  builder_.add_EL(EL);
  builder_.add_AZ(AZ);
  builder_.add_DEC(DEC);
  builder_.add_RA(RA);
  builder_.add_MEAN_ANOMALY(MEAN_ANOMALY);
  builder_.add_ARG_OF_PERIGEE(ARG_OF_PERIGEE);
  builder_.add_RAAN(RAAN);
  builder_.add_INCLINATION(INCLINATION);
  builder_.add_ECCENTRICITY(ECCENTRICITY);
  builder_.add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS);
  builder_.add_INTEGRATION_TIME(INTEGRATION_TIME);
  builder_.add_FRAME_RATE(FRAME_RATE);
  builder_.add_IRRADIANCE(IRRADIANCE);
  builder_.add_REFLECTANCE(REFLECTANCE);
  builder_.add_VIS_MAG_MAX(VIS_MAG_MAX);
  builder_.add_VIS_MAG(VIS_MAG);
  builder_.add_VIS_MAG_MIN(VIS_MAG_MIN);
  builder_.add_FREQ_MAX(FREQ_MAX);
  builder_.add_FREQ(FREQ);
  builder_.add_FREQ_MIN(FREQ_MIN);
  builder_.add_RCS_MAX(RCS_MAX);
  builder_.add_RCS(RCS);
  builder_.add_RCS_MIN(RCS_MIN);
  builder_.add_TARGET_SIZE(TARGET_SIZE);
  builder_.add_DATA_MODE(DATA_MODE);
  builder_.add_ORIGIN(ORIGIN);
  builder_.add_SOURCE(SOURCE);
  builder_.add_NOTES(NOTES);
  builder_.add_CUSTOMER(CUSTOMER);
  builder_.add_EPOCH(EPOCH);
  builder_.add_ES_ID(ES_ID);
  builder_.add_ID_STATE_VECTOR(ID_STATE_VECTOR);
  builder_.add_ID_MANIFOLD(ID_MANIFOLD);
  builder_.add_ID_ELSET(ID_ELSET);
  builder_.add_SCENARIO(SCENARIO);
  builder_.add_SRCH_PATTERN(SRCH_PATTERN);
  builder_.add_DURATION(DURATION);
  builder_.add_NUM_OBS(NUM_OBS);
  builder_.add_NUM_TRACKS(NUM_TRACKS);
  builder_.add_NUM_FRAMES(NUM_FRAMES);
  builder_.add_SPECTRAL_MODEL(SPECTRAL_MODEL);
  builder_.add_POLARIZATION(POLARIZATION);
  builder_.add_ORBIT_REGIME(ORBIT_REGIME);
  builder_.add_IRON(IRON);
  builder_.add_TASK_GROUP(TASK_GROUP);
  builder_.add_ORIG_OBJECT_ID(ORIG_OBJECT_ID);
  builder_.add_NORAD_CAT_ID(NORAD_CAT_ID);
  builder_.add_END_TIME(END_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_SUFFIX(SUFFIX);
  builder_.add_TASK_CATEGORY(TASK_CATEGORY);
  builder_.add_PRIORITY(PRIORITY);
  builder_.add_OB_TYPE(OB_TYPE);
  builder_.add_ORIG_SENSOR_ID(ORIG_SENSOR_ID);
  builder_.add_ID_SENSOR(ID_SENSOR);
  builder_.add_EXTERNAL_ID(EXTERNAL_ID);
  builder_.add_DWELL_ID(DWELL_ID);
  builder_.add_TASK_ID(TASK_ID);
  builder_.add_PLAN_INDEX(PLAN_INDEX);
  builder_.add_ID_PLAN(ID_PLAN);
  builder_.add_TYPE(TYPE);
  builder_.add_CLASSIFICATION(CLASSIFICATION);
  builder_.add_ID(ID);
  builder_.add_UCT_FOLLOW_UP(UCT_FOLLOW_UP);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CRM> CreateCRMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *CLASSIFICATION = nullptr,
    const char *TYPE = nullptr,
    const char *ID_PLAN = nullptr,
    int32_t PLAN_INDEX = 0,
    const char *TASK_ID = nullptr,
    const char *DWELL_ID = nullptr,
    const char *EXTERNAL_ID = nullptr,
    const char *ID_SENSOR = nullptr,
    const char *ORIG_SENSOR_ID = nullptr,
    const char *OB_TYPE = nullptr,
    const char *PRIORITY = nullptr,
    int32_t TASK_CATEGORY = 0,
    const char *SUFFIX = nullptr,
    bool UCT_FOLLOW_UP = false,
    const char *START_TIME = nullptr,
    const char *END_TIME = nullptr,
    uint32_t NORAD_CAT_ID = 0,
    const char *ORIG_OBJECT_ID = nullptr,
    const char *TASK_GROUP = nullptr,
    int32_t IRON = 0,
    const char *ORBIT_REGIME = nullptr,
    double TARGET_SIZE = 0.0,
    double RCS_MIN = 0.0,
    double RCS = 0.0,
    double RCS_MAX = 0.0,
    double FREQ_MIN = 0.0,
    double FREQ = 0.0,
    double FREQ_MAX = 0.0,
    const char *POLARIZATION = nullptr,
    double VIS_MAG_MIN = 0.0,
    double VIS_MAG = 0.0,
    double VIS_MAG_MAX = 0.0,
    const char *SPECTRAL_MODEL = nullptr,
    double REFLECTANCE = 0.0,
    double IRRADIANCE = 0.0,
    int32_t NUM_FRAMES = 0,
    double FRAME_RATE = 0.0,
    double INTEGRATION_TIME = 0.0,
    int32_t NUM_TRACKS = 0,
    int32_t NUM_OBS = 0,
    int32_t DURATION = 0,
    const char *SRCH_PATTERN = nullptr,
    const char *SCENARIO = nullptr,
    const char *ID_ELSET = nullptr,
    const char *ID_MANIFOLD = nullptr,
    const char *ID_STATE_VECTOR = nullptr,
    const char *ES_ID = nullptr,
    const char *EPOCH = nullptr,
    double SEMI_MAJOR_AXIS = 0.0,
    double ECCENTRICITY = 0.0,
    double INCLINATION = 0.0,
    double RAAN = 0.0,
    double ARG_OF_PERIGEE = 0.0,
    double MEAN_ANOMALY = 0.0,
    double RA = 0.0,
    double DEC = 0.0,
    double AZ = 0.0,
    double EL = 0.0,
    double RANGE = 0.0,
    double EXTENT_AZ = 0.0,
    double EXTENT_EL = 0.0,
    double EXTENT_RANGE = 0.0,
    double LAT = 0.0,
    double LON = 0.0,
    double ALT = 0.0,
    double STOP_LAT = 0.0,
    double STOP_LON = 0.0,
    double STOP_ALT = 0.0,
    double SRCH_INC = 0.0,
    double X_ANGLE = 0.0,
    double Y_ANGLE = 0.0,
    double ORIENT_ANGLE = 0.0,
    const char *CUSTOMER = nullptr,
    const char *NOTES = nullptr,
    const char *SOURCE = nullptr,
    const char *ORIGIN = nullptr,
    const char *DATA_MODE = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto CLASSIFICATION__ = CLASSIFICATION ? _fbb.CreateString(CLASSIFICATION) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto ID_PLAN__ = ID_PLAN ? _fbb.CreateString(ID_PLAN) : 0;
  auto TASK_ID__ = TASK_ID ? _fbb.CreateString(TASK_ID) : 0;
  auto DWELL_ID__ = DWELL_ID ? _fbb.CreateString(DWELL_ID) : 0;
  auto EXTERNAL_ID__ = EXTERNAL_ID ? _fbb.CreateString(EXTERNAL_ID) : 0;
  auto ID_SENSOR__ = ID_SENSOR ? _fbb.CreateString(ID_SENSOR) : 0;
  auto ORIG_SENSOR_ID__ = ORIG_SENSOR_ID ? _fbb.CreateString(ORIG_SENSOR_ID) : 0;
  auto OB_TYPE__ = OB_TYPE ? _fbb.CreateString(OB_TYPE) : 0;
  auto PRIORITY__ = PRIORITY ? _fbb.CreateString(PRIORITY) : 0;
  auto SUFFIX__ = SUFFIX ? _fbb.CreateString(SUFFIX) : 0;
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto END_TIME__ = END_TIME ? _fbb.CreateString(END_TIME) : 0;
  auto ORIG_OBJECT_ID__ = ORIG_OBJECT_ID ? _fbb.CreateString(ORIG_OBJECT_ID) : 0;
  auto TASK_GROUP__ = TASK_GROUP ? _fbb.CreateString(TASK_GROUP) : 0;
  auto ORBIT_REGIME__ = ORBIT_REGIME ? _fbb.CreateString(ORBIT_REGIME) : 0;
  auto POLARIZATION__ = POLARIZATION ? _fbb.CreateString(POLARIZATION) : 0;
  auto SPECTRAL_MODEL__ = SPECTRAL_MODEL ? _fbb.CreateString(SPECTRAL_MODEL) : 0;
  auto SRCH_PATTERN__ = SRCH_PATTERN ? _fbb.CreateString(SRCH_PATTERN) : 0;
  auto SCENARIO__ = SCENARIO ? _fbb.CreateString(SCENARIO) : 0;
  auto ID_ELSET__ = ID_ELSET ? _fbb.CreateString(ID_ELSET) : 0;
  auto ID_MANIFOLD__ = ID_MANIFOLD ? _fbb.CreateString(ID_MANIFOLD) : 0;
  auto ID_STATE_VECTOR__ = ID_STATE_VECTOR ? _fbb.CreateString(ID_STATE_VECTOR) : 0;
  auto ES_ID__ = ES_ID ? _fbb.CreateString(ES_ID) : 0;
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  auto CUSTOMER__ = CUSTOMER ? _fbb.CreateString(CUSTOMER) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto ORIGIN__ = ORIGIN ? _fbb.CreateString(ORIGIN) : 0;
  auto DATA_MODE__ = DATA_MODE ? _fbb.CreateString(DATA_MODE) : 0;
  return CreateCRM(
      _fbb,
      ID__,
      CLASSIFICATION__,
      TYPE__,
      ID_PLAN__,
      PLAN_INDEX,
      TASK_ID__,
      DWELL_ID__,
      EXTERNAL_ID__,
      ID_SENSOR__,
      ORIG_SENSOR_ID__,
      OB_TYPE__,
      PRIORITY__,
      TASK_CATEGORY,
      SUFFIX__,
      UCT_FOLLOW_UP,
      START_TIME__,
      END_TIME__,
      NORAD_CAT_ID,
      ORIG_OBJECT_ID__,
      TASK_GROUP__,
      IRON,
      ORBIT_REGIME__,
      TARGET_SIZE,
      RCS_MIN,
      RCS,
      RCS_MAX,
      FREQ_MIN,
      FREQ,
      FREQ_MAX,
      POLARIZATION__,
      VIS_MAG_MIN,
      VIS_MAG,
      VIS_MAG_MAX,
      SPECTRAL_MODEL__,
      REFLECTANCE,
      IRRADIANCE,
      NUM_FRAMES,
      FRAME_RATE,
      INTEGRATION_TIME,
      NUM_TRACKS,
      NUM_OBS,
      DURATION,
      SRCH_PATTERN__,
      SCENARIO__,
      ID_ELSET__,
      ID_MANIFOLD__,
      ID_STATE_VECTOR__,
      ES_ID__,
      EPOCH__,
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      RA,
      DEC,
      AZ,
      EL,
      RANGE,
      EXTENT_AZ,
      EXTENT_EL,
      EXTENT_RANGE,
      LAT,
      LON,
      ALT,
      STOP_LAT,
      STOP_LON,
      STOP_ALT,
      SRCH_INC,
      X_ANGLE,
      Y_ANGLE,
      ORIENT_ANGLE,
      CUSTOMER__,
      NOTES__,
      SOURCE__,
      ORIGIN__,
      DATA_MODE__);
}

struct CRMCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CRMCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<CRM>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CRM>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct CRMCOLLECTIONBuilder {
  typedef CRMCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CRM>>> RECORDS) {
    fbb_.AddOffset(CRMCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit CRMCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CRMCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CRMCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CRMCOLLECTION> CreateCRMCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CRM>>> RECORDS = 0) {
  CRMCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CRMCOLLECTION> CreateCRMCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<CRM>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<CRM>>(*RECORDS) : 0;
  return CreateCRMCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const CRM *GetCRM(const void *buf) {
  return ::flatbuffers::GetRoot<CRM>(buf);
}

inline const CRM *GetSizePrefixedCRM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CRM>(buf);
}

inline const char *CRMIdentifier() {
  return "$CRM";
}

inline bool CRMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CRMIdentifier());
}

inline bool SizePrefixedCRMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CRMIdentifier(), true);
}

inline bool VerifyCRMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CRM>(CRMIdentifier());
}

inline bool VerifySizePrefixedCRMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CRM>(CRMIdentifier());
}

inline void FinishCRMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CRM> root) {
  fbb.Finish(root, CRMIdentifier());
}

inline void FinishSizePrefixedCRMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CRM> root) {
  fbb.FinishSizePrefixed(root, CRMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
