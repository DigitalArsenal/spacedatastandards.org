// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct HEL;
struct HELBuilder;

enum RotorType : int8_t {
  RotorType_MAIN = 0,
  RotorType_TAIL = 1,
  RotorType_TANDEM_FRONT = 2,
  RotorType_TANDEM_REAR = 3,
  RotorType_COAXIAL_UPPER = 4,
  RotorType_COAXIAL_LOWER = 5,
  RotorType_MIN = RotorType_MAIN,
  RotorType_MAX = RotorType_COAXIAL_LOWER
};

inline const RotorType (&EnumValuesRotorType())[6] {
  static const RotorType values[] = {
    RotorType_MAIN,
    RotorType_TAIL,
    RotorType_TANDEM_FRONT,
    RotorType_TANDEM_REAR,
    RotorType_COAXIAL_UPPER,
    RotorType_COAXIAL_LOWER
  };
  return values;
}

inline const char * const *EnumNamesRotorType() {
  static const char * const names[7] = {
    "MAIN",
    "TAIL",
    "TANDEM_FRONT",
    "TANDEM_REAR",
    "COAXIAL_UPPER",
    "COAXIAL_LOWER",
    nullptr
  };
  return names;
}

inline const char *EnumNameRotorType(RotorType e) {
  if (::flatbuffers::IsOutRange(e, RotorType_MAIN, RotorType_COAXIAL_LOWER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRotorType()[index];
}

enum RotorFlags : int8_t {
  RotorFlags_NORMAL = 0,
  RotorFlags_VRS_WARNING = 1,
  RotorFlags_VRS_ACTIVE = 2,
  RotorFlags_RBS_WARNING = 3,
  RotorFlags_RBS_ACTIVE = 4,
  RotorFlags_OVERSPEED = 5,
  RotorFlags_UNDERSPEED = 6,
  RotorFlags_MIN = RotorFlags_NORMAL,
  RotorFlags_MAX = RotorFlags_UNDERSPEED
};

inline const RotorFlags (&EnumValuesRotorFlags())[7] {
  static const RotorFlags values[] = {
    RotorFlags_NORMAL,
    RotorFlags_VRS_WARNING,
    RotorFlags_VRS_ACTIVE,
    RotorFlags_RBS_WARNING,
    RotorFlags_RBS_ACTIVE,
    RotorFlags_OVERSPEED,
    RotorFlags_UNDERSPEED
  };
  return values;
}

inline const char * const *EnumNamesRotorFlags() {
  static const char * const names[8] = {
    "NORMAL",
    "VRS_WARNING",
    "VRS_ACTIVE",
    "RBS_WARNING",
    "RBS_ACTIVE",
    "OVERSPEED",
    "UNDERSPEED",
    nullptr
  };
  return names;
}

inline const char *EnumNameRotorFlags(RotorFlags e) {
  if (::flatbuffers::IsOutRange(e, RotorFlags_NORMAL, RotorFlags_UNDERSPEED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRotorFlags()[index];
}

/// Helicopter Dynamics
struct HEL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HELBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POSITION_Z = 8,
    VT_VELOCITY_X = 10,
    VT_VELOCITY_Y = 12,
    VT_VELOCITY_Z = 14,
    VT_QUAT_W = 16,
    VT_QUAT_X = 18,
    VT_QUAT_Y = 20,
    VT_QUAT_Z = 22,
    VT_OMEGA_BODY_X = 24,
    VT_OMEGA_BODY_Y = 26,
    VT_OMEGA_BODY_Z = 28,
    VT_MAIN_ROTOR = 30,
    VT_TAIL_ROTOR = 32,
    VT_ENGINE_N1 = 34,
    VT_ENGINE_TORQUE = 36,
    VT_FLAGS = 38,
    VT_FUEL_REMAINING = 40
  };
  double POSITION_X() const {
    return GetField<double>(VT_POSITION_X, 0.0);
  }
  double POSITION_Y() const {
    return GetField<double>(VT_POSITION_Y, 0.0);
  }
  double POSITION_Z() const {
    return GetField<double>(VT_POSITION_Z, 0.0);
  }
  double VELOCITY_X() const {
    return GetField<double>(VT_VELOCITY_X, 0.0);
  }
  double VELOCITY_Y() const {
    return GetField<double>(VT_VELOCITY_Y, 0.0);
  }
  double VELOCITY_Z() const {
    return GetField<double>(VT_VELOCITY_Z, 0.0);
  }
  double QUAT_W() const {
    return GetField<double>(VT_QUAT_W, 0.0);
  }
  double QUAT_X() const {
    return GetField<double>(VT_QUAT_X, 0.0);
  }
  double QUAT_Y() const {
    return GetField<double>(VT_QUAT_Y, 0.0);
  }
  double QUAT_Z() const {
    return GetField<double>(VT_QUAT_Z, 0.0);
  }
  double OMEGA_BODY_X() const {
    return GetField<double>(VT_OMEGA_BODY_X, 0.0);
  }
  double OMEGA_BODY_Y() const {
    return GetField<double>(VT_OMEGA_BODY_Y, 0.0);
  }
  double OMEGA_BODY_Z() const {
    return GetField<double>(VT_OMEGA_BODY_Z, 0.0);
  }
  const ::flatbuffers::String *MAIN_ROTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAIN_ROTOR);
  }
  const ::flatbuffers::String *TAIL_ROTOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAIL_ROTOR);
  }
  double ENGINE_N1() const {
    return GetField<double>(VT_ENGINE_N1, 0.0);
  }
  double ENGINE_TORQUE() const {
    return GetField<double>(VT_ENGINE_TORQUE, 0.0);
  }
  uint32_t FLAGS() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  float FUEL_REMAINING() const {
    return GetField<float>(VT_FUEL_REMAINING, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_QUAT_W, 8) &&
           VerifyField<double>(verifier, VT_QUAT_X, 8) &&
           VerifyField<double>(verifier, VT_QUAT_Y, 8) &&
           VerifyField<double>(verifier, VT_QUAT_Z, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_BODY_X, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_BODY_Y, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_BODY_Z, 8) &&
           VerifyOffset(verifier, VT_MAIN_ROTOR) &&
           verifier.VerifyString(MAIN_ROTOR()) &&
           VerifyOffset(verifier, VT_TAIL_ROTOR) &&
           verifier.VerifyString(TAIL_ROTOR()) &&
           VerifyField<double>(verifier, VT_ENGINE_N1, 8) &&
           VerifyField<double>(verifier, VT_ENGINE_TORQUE, 8) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<float>(verifier, VT_FUEL_REMAINING, 4) &&
           verifier.EndTable();
  }
};

struct HELBuilder {
  typedef HEL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITION_X(double POSITION_X) {
    fbb_.AddElement<double>(HEL::VT_POSITION_X, POSITION_X, 0.0);
  }
  void add_POSITION_Y(double POSITION_Y) {
    fbb_.AddElement<double>(HEL::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  void add_POSITION_Z(double POSITION_Z) {
    fbb_.AddElement<double>(HEL::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  void add_VELOCITY_X(double VELOCITY_X) {
    fbb_.AddElement<double>(HEL::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  void add_VELOCITY_Y(double VELOCITY_Y) {
    fbb_.AddElement<double>(HEL::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  void add_VELOCITY_Z(double VELOCITY_Z) {
    fbb_.AddElement<double>(HEL::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  void add_QUAT_W(double QUAT_W) {
    fbb_.AddElement<double>(HEL::VT_QUAT_W, QUAT_W, 0.0);
  }
  void add_QUAT_X(double QUAT_X) {
    fbb_.AddElement<double>(HEL::VT_QUAT_X, QUAT_X, 0.0);
  }
  void add_QUAT_Y(double QUAT_Y) {
    fbb_.AddElement<double>(HEL::VT_QUAT_Y, QUAT_Y, 0.0);
  }
  void add_QUAT_Z(double QUAT_Z) {
    fbb_.AddElement<double>(HEL::VT_QUAT_Z, QUAT_Z, 0.0);
  }
  void add_OMEGA_BODY_X(double OMEGA_BODY_X) {
    fbb_.AddElement<double>(HEL::VT_OMEGA_BODY_X, OMEGA_BODY_X, 0.0);
  }
  void add_OMEGA_BODY_Y(double OMEGA_BODY_Y) {
    fbb_.AddElement<double>(HEL::VT_OMEGA_BODY_Y, OMEGA_BODY_Y, 0.0);
  }
  void add_OMEGA_BODY_Z(double OMEGA_BODY_Z) {
    fbb_.AddElement<double>(HEL::VT_OMEGA_BODY_Z, OMEGA_BODY_Z, 0.0);
  }
  void add_MAIN_ROTOR(::flatbuffers::Offset<::flatbuffers::String> MAIN_ROTOR) {
    fbb_.AddOffset(HEL::VT_MAIN_ROTOR, MAIN_ROTOR);
  }
  void add_TAIL_ROTOR(::flatbuffers::Offset<::flatbuffers::String> TAIL_ROTOR) {
    fbb_.AddOffset(HEL::VT_TAIL_ROTOR, TAIL_ROTOR);
  }
  void add_ENGINE_N1(double ENGINE_N1) {
    fbb_.AddElement<double>(HEL::VT_ENGINE_N1, ENGINE_N1, 0.0);
  }
  void add_ENGINE_TORQUE(double ENGINE_TORQUE) {
    fbb_.AddElement<double>(HEL::VT_ENGINE_TORQUE, ENGINE_TORQUE, 0.0);
  }
  void add_FLAGS(uint32_t FLAGS) {
    fbb_.AddElement<uint32_t>(HEL::VT_FLAGS, FLAGS, 0);
  }
  void add_FUEL_REMAINING(float FUEL_REMAINING) {
    fbb_.AddElement<float>(HEL::VT_FUEL_REMAINING, FUEL_REMAINING, 0.0f);
  }
  explicit HELBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HEL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HEL> CreateHEL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double QUAT_W = 0.0,
    double QUAT_X = 0.0,
    double QUAT_Y = 0.0,
    double QUAT_Z = 0.0,
    double OMEGA_BODY_X = 0.0,
    double OMEGA_BODY_Y = 0.0,
    double OMEGA_BODY_Z = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> MAIN_ROTOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TAIL_ROTOR = 0,
    double ENGINE_N1 = 0.0,
    double ENGINE_TORQUE = 0.0,
    uint32_t FLAGS = 0,
    float FUEL_REMAINING = 0.0f) {
  HELBuilder builder_(_fbb);
  builder_.add_ENGINE_TORQUE(ENGINE_TORQUE);
  builder_.add_ENGINE_N1(ENGINE_N1);
  builder_.add_OMEGA_BODY_Z(OMEGA_BODY_Z);
  builder_.add_OMEGA_BODY_Y(OMEGA_BODY_Y);
  builder_.add_OMEGA_BODY_X(OMEGA_BODY_X);
  builder_.add_QUAT_Z(QUAT_Z);
  builder_.add_QUAT_Y(QUAT_Y);
  builder_.add_QUAT_X(QUAT_X);
  builder_.add_QUAT_W(QUAT_W);
  builder_.add_VELOCITY_Z(VELOCITY_Z);
  builder_.add_VELOCITY_Y(VELOCITY_Y);
  builder_.add_VELOCITY_X(VELOCITY_X);
  builder_.add_POSITION_Z(POSITION_Z);
  builder_.add_POSITION_Y(POSITION_Y);
  builder_.add_POSITION_X(POSITION_X);
  builder_.add_FUEL_REMAINING(FUEL_REMAINING);
  builder_.add_FLAGS(FLAGS);
  builder_.add_TAIL_ROTOR(TAIL_ROTOR);
  builder_.add_MAIN_ROTOR(MAIN_ROTOR);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<HEL> CreateHELDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double QUAT_W = 0.0,
    double QUAT_X = 0.0,
    double QUAT_Y = 0.0,
    double QUAT_Z = 0.0,
    double OMEGA_BODY_X = 0.0,
    double OMEGA_BODY_Y = 0.0,
    double OMEGA_BODY_Z = 0.0,
    const char *MAIN_ROTOR = nullptr,
    const char *TAIL_ROTOR = nullptr,
    double ENGINE_N1 = 0.0,
    double ENGINE_TORQUE = 0.0,
    uint32_t FLAGS = 0,
    float FUEL_REMAINING = 0.0f) {
  auto MAIN_ROTOR__ = MAIN_ROTOR ? _fbb.CreateString(MAIN_ROTOR) : 0;
  auto TAIL_ROTOR__ = TAIL_ROTOR ? _fbb.CreateString(TAIL_ROTOR) : 0;
  return CreateHEL(
      _fbb,
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      QUAT_W,
      QUAT_X,
      QUAT_Y,
      QUAT_Z,
      OMEGA_BODY_X,
      OMEGA_BODY_Y,
      OMEGA_BODY_Z,
      MAIN_ROTOR__,
      TAIL_ROTOR__,
      ENGINE_N1,
      ENGINE_TORQUE,
      FLAGS,
      FUEL_REMAINING);
}

inline const HEL *GetHEL(const void *buf) {
  return ::flatbuffers::GetRoot<HEL>(buf);
}

inline const HEL *GetSizePrefixedHEL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<HEL>(buf);
}

inline const char *HELIdentifier() {
  return "$HEL";
}

inline bool HELBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HELIdentifier());
}

inline bool SizePrefixedHELBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, HELIdentifier(), true);
}

inline bool VerifyHELBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<HEL>(HELIdentifier());
}

inline bool VerifySizePrefixedHELBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<HEL>(HELIdentifier());
}

inline void FinishHELBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HEL> root) {
  fbb.Finish(root, HELIdentifier());
}

inline void FinishSizePrefixedHELBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<HEL> root) {
  fbb.FinishSizePrefixed(root, HELIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
