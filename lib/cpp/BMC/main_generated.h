// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct BMC;
struct BMCBuilder;

/// Beam Contour
struct BMC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BMCBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_CONTOUR_IDX = 8,
    VT_GAIN = 10,
    VT_REGION_NAME = 12,
    VT_GEOGRAPHY = 14,
    VT_GEOGRAPHY_TEXT = 16,
    VT_GEOGRAPHY_JSON = 18,
    VT_GEOGRAPHY_TYPE = 20,
    VT_GEOGRAPHY_NDIMS = 22,
    VT_GEOGRAPHY_SRID = 24
  };
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  int32_t CONTOUR_IDX() const {
    return GetField<int32_t>(VT_CONTOUR_IDX, 0);
  }
  double GAIN() const {
    return GetField<double>(VT_GAIN, 0.0);
  }
  const ::flatbuffers::String *REGION_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGION_NAME);
  }
  const ::flatbuffers::String *GEOGRAPHY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOGRAPHY);
  }
  const ::flatbuffers::String *GEOGRAPHY_TEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOGRAPHY_TEXT);
  }
  const ::flatbuffers::String *GEOGRAPHY_JSON() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOGRAPHY_JSON);
  }
  const ::flatbuffers::String *GEOGRAPHY_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOGRAPHY_TYPE);
  }
  int32_t GEOGRAPHY_NDIMS() const {
    return GetField<int32_t>(VT_GEOGRAPHY_NDIMS, 0);
  }
  int32_t GEOGRAPHY_SRID() const {
    return GetField<int32_t>(VT_GEOGRAPHY_SRID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyField<int32_t>(verifier, VT_CONTOUR_IDX, 4) &&
           VerifyField<double>(verifier, VT_GAIN, 8) &&
           VerifyOffset(verifier, VT_REGION_NAME) &&
           verifier.VerifyString(REGION_NAME()) &&
           VerifyOffset(verifier, VT_GEOGRAPHY) &&
           verifier.VerifyString(GEOGRAPHY()) &&
           VerifyOffset(verifier, VT_GEOGRAPHY_TEXT) &&
           verifier.VerifyString(GEOGRAPHY_TEXT()) &&
           VerifyOffset(verifier, VT_GEOGRAPHY_JSON) &&
           verifier.VerifyString(GEOGRAPHY_JSON()) &&
           VerifyOffset(verifier, VT_GEOGRAPHY_TYPE) &&
           verifier.VerifyString(GEOGRAPHY_TYPE()) &&
           VerifyField<int32_t>(verifier, VT_GEOGRAPHY_NDIMS, 4) &&
           VerifyField<int32_t>(verifier, VT_GEOGRAPHY_SRID, 4) &&
           verifier.EndTable();
  }
};

struct BMCBuilder {
  typedef BMC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(BMC::VT_ID, ID);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(BMC::VT_TYPE, TYPE);
  }
  void add_CONTOUR_IDX(int32_t CONTOUR_IDX) {
    fbb_.AddElement<int32_t>(BMC::VT_CONTOUR_IDX, CONTOUR_IDX, 0);
  }
  void add_GAIN(double GAIN) {
    fbb_.AddElement<double>(BMC::VT_GAIN, GAIN, 0.0);
  }
  void add_REGION_NAME(::flatbuffers::Offset<::flatbuffers::String> REGION_NAME) {
    fbb_.AddOffset(BMC::VT_REGION_NAME, REGION_NAME);
  }
  void add_GEOGRAPHY(::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY) {
    fbb_.AddOffset(BMC::VT_GEOGRAPHY, GEOGRAPHY);
  }
  void add_GEOGRAPHY_TEXT(::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_TEXT) {
    fbb_.AddOffset(BMC::VT_GEOGRAPHY_TEXT, GEOGRAPHY_TEXT);
  }
  void add_GEOGRAPHY_JSON(::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_JSON) {
    fbb_.AddOffset(BMC::VT_GEOGRAPHY_JSON, GEOGRAPHY_JSON);
  }
  void add_GEOGRAPHY_TYPE(::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_TYPE) {
    fbb_.AddOffset(BMC::VT_GEOGRAPHY_TYPE, GEOGRAPHY_TYPE);
  }
  void add_GEOGRAPHY_NDIMS(int32_t GEOGRAPHY_NDIMS) {
    fbb_.AddElement<int32_t>(BMC::VT_GEOGRAPHY_NDIMS, GEOGRAPHY_NDIMS, 0);
  }
  void add_GEOGRAPHY_SRID(int32_t GEOGRAPHY_SRID) {
    fbb_.AddElement<int32_t>(BMC::VT_GEOGRAPHY_SRID, GEOGRAPHY_SRID, 0);
  }
  explicit BMCBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BMC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BMC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BMC> CreateBMC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    int32_t CONTOUR_IDX = 0,
    double GAIN = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> REGION_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_TEXT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_JSON = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GEOGRAPHY_TYPE = 0,
    int32_t GEOGRAPHY_NDIMS = 0,
    int32_t GEOGRAPHY_SRID = 0) {
  BMCBuilder builder_(_fbb);
  builder_.add_GAIN(GAIN);
  builder_.add_GEOGRAPHY_SRID(GEOGRAPHY_SRID);
  builder_.add_GEOGRAPHY_NDIMS(GEOGRAPHY_NDIMS);
  builder_.add_GEOGRAPHY_TYPE(GEOGRAPHY_TYPE);
  builder_.add_GEOGRAPHY_JSON(GEOGRAPHY_JSON);
  builder_.add_GEOGRAPHY_TEXT(GEOGRAPHY_TEXT);
  builder_.add_GEOGRAPHY(GEOGRAPHY);
  builder_.add_REGION_NAME(REGION_NAME);
  builder_.add_CONTOUR_IDX(CONTOUR_IDX);
  builder_.add_TYPE(TYPE);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BMC> CreateBMCDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *TYPE = nullptr,
    int32_t CONTOUR_IDX = 0,
    double GAIN = 0.0,
    const char *REGION_NAME = nullptr,
    const char *GEOGRAPHY = nullptr,
    const char *GEOGRAPHY_TEXT = nullptr,
    const char *GEOGRAPHY_JSON = nullptr,
    const char *GEOGRAPHY_TYPE = nullptr,
    int32_t GEOGRAPHY_NDIMS = 0,
    int32_t GEOGRAPHY_SRID = 0) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto REGION_NAME__ = REGION_NAME ? _fbb.CreateString(REGION_NAME) : 0;
  auto GEOGRAPHY__ = GEOGRAPHY ? _fbb.CreateString(GEOGRAPHY) : 0;
  auto GEOGRAPHY_TEXT__ = GEOGRAPHY_TEXT ? _fbb.CreateString(GEOGRAPHY_TEXT) : 0;
  auto GEOGRAPHY_JSON__ = GEOGRAPHY_JSON ? _fbb.CreateString(GEOGRAPHY_JSON) : 0;
  auto GEOGRAPHY_TYPE__ = GEOGRAPHY_TYPE ? _fbb.CreateString(GEOGRAPHY_TYPE) : 0;
  return CreateBMC(
      _fbb,
      ID__,
      TYPE__,
      CONTOUR_IDX,
      GAIN,
      REGION_NAME__,
      GEOGRAPHY__,
      GEOGRAPHY_TEXT__,
      GEOGRAPHY_JSON__,
      GEOGRAPHY_TYPE__,
      GEOGRAPHY_NDIMS,
      GEOGRAPHY_SRID);
}

inline const BMC *GetBMC(const void *buf) {
  return ::flatbuffers::GetRoot<BMC>(buf);
}

inline const BMC *GetSizePrefixedBMC(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<BMC>(buf);
}

inline const char *BMCIdentifier() {
  return "$BMC";
}

inline bool BMCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BMCIdentifier());
}

inline bool SizePrefixedBMCBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BMCIdentifier(), true);
}

inline bool VerifyBMCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BMC>(BMCIdentifier());
}

inline bool VerifySizePrefixedBMCBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BMC>(BMCIdentifier());
}

inline void FinishBMCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BMC> root) {
  fbb.Finish(root, BMCIdentifier());
}

inline void FinishSizePrefixedBMCBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BMC> root) {
  fbb.FinishSizePrefixed(root, BMCIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
