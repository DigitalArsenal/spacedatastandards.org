// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MET;
struct METBuilder;

struct METCOLLECTION;
struct METCOLLECTIONBuilder;

enum meanElementTheory : int8_t {
  /// Simplified General Perturbation Model 4
  meanElementTheory_SGP4 = 0,
  /// Simplified General Perturbation Model 4 eXtended Perturbations (https://amostech.com/TechnicalPapers/2022/Astrodynamics/Payne_2.pdf)
  meanElementTheory_SGP4XP = 1,
  /// Draper Semi-analytical Satellite Theory
  meanElementTheory_DSST = 2,
  /// Universal Semianalytical Method
  meanElementTheory_USM = 3,
  meanElementTheory_MIN = meanElementTheory_SGP4,
  meanElementTheory_MAX = meanElementTheory_USM
};

inline const meanElementTheory (&EnumValuesmeanElementTheory())[4] {
  static const meanElementTheory values[] = {
    meanElementTheory_SGP4,
    meanElementTheory_SGP4XP,
    meanElementTheory_DSST,
    meanElementTheory_USM
  };
  return values;
}

inline const char * const *EnumNamesmeanElementTheory() {
  static const char * const names[5] = {
    "SGP4",
    "SGP4XP",
    "DSST",
    "USM",
    nullptr
  };
  return names;
}

inline const char *EnumNamemeanElementTheory(meanElementTheory e) {
  if (::flatbuffers::IsOutRange(e, meanElementTheory_SGP4, meanElementTheory_USM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesmeanElementTheory()[index];
}

/// Mean Element Theory
struct MET FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef METBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN_ELEMENT_THEORY = 4
  };
  meanElementTheory MEAN_ELEMENT_THEORY() const {
    return static_cast<meanElementTheory>(GetField<int8_t>(VT_MEAN_ELEMENT_THEORY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MEAN_ELEMENT_THEORY, 1) &&
           verifier.EndTable();
  }
};

struct METBuilder {
  typedef MET Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_MEAN_ELEMENT_THEORY(meanElementTheory MEAN_ELEMENT_THEORY) {
    fbb_.AddElement<int8_t>(MET::VT_MEAN_ELEMENT_THEORY, static_cast<int8_t>(MEAN_ELEMENT_THEORY), 0);
  }
  explicit METBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MET>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MET> CreateMET(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    meanElementTheory MEAN_ELEMENT_THEORY = meanElementTheory_SGP4) {
  METBuilder builder_(_fbb);
  builder_.add_MEAN_ELEMENT_THEORY(MEAN_ELEMENT_THEORY);
  return builder_.Finish();
}

struct METCOLLECTION FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef METCOLLECTIONBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<MET>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MET>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct METCOLLECTIONBuilder {
  typedef METCOLLECTION Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MET>>> RECORDS) {
    fbb_.AddOffset(METCOLLECTION::VT_RECORDS, RECORDS);
  }
  explicit METCOLLECTIONBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<METCOLLECTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<METCOLLECTION>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<METCOLLECTION> CreateMETCOLLECTION(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MET>>> RECORDS = 0) {
  METCOLLECTIONBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<METCOLLECTION> CreateMETCOLLECTIONDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<MET>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<MET>>(*RECORDS) : 0;
  return CreateMETCOLLECTION(
      _fbb,
      RECORDS__);
}

inline const MET *GetMET(const void *buf) {
  return ::flatbuffers::GetRoot<MET>(buf);
}

inline const MET *GetSizePrefixedMET(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MET>(buf);
}

inline const char *METIdentifier() {
  return "$MET";
}

inline bool METBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, METIdentifier());
}

inline bool SizePrefixedMETBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, METIdentifier(), true);
}

inline bool VerifyMETBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MET>(METIdentifier());
}

inline bool VerifySizePrefixedMETBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MET>(METIdentifier());
}

inline void FinishMETBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MET> root) {
  fbb.Finish(root, METIdentifier());
}

inline void FinishSizePrefixedMETBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MET> root) {
  fbb.FinishSizePrefixed(root, METIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
