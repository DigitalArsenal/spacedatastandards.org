// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TKG;
struct TKGBuilder;

enum FilterType : int8_t {
  FilterType_ALPHA_BETA = 0,
  FilterType_ALPHA_BETA_GAMMA = 1,
  FilterType_KALMAN = 2,
  FilterType_EXTENDED_KALMAN = 3,
  FilterType_UNSCENTED_KALMAN = 4,
  FilterType_PARTICLE = 5,
  FilterType_IMM = 6,
  FilterType_JPDA = 7,
  FilterType_MHT = 8,
  FilterType_GNN = 9,
  FilterType_NNKF = 10,
  FilterType_MIN = FilterType_ALPHA_BETA,
  FilterType_MAX = FilterType_NNKF
};

inline const FilterType (&EnumValuesFilterType())[11] {
  static const FilterType values[] = {
    FilterType_ALPHA_BETA,
    FilterType_ALPHA_BETA_GAMMA,
    FilterType_KALMAN,
    FilterType_EXTENDED_KALMAN,
    FilterType_UNSCENTED_KALMAN,
    FilterType_PARTICLE,
    FilterType_IMM,
    FilterType_JPDA,
    FilterType_MHT,
    FilterType_GNN,
    FilterType_NNKF
  };
  return values;
}

inline const char * const *EnumNamesFilterType() {
  static const char * const names[12] = {
    "ALPHA_BETA",
    "ALPHA_BETA_GAMMA",
    "KALMAN",
    "EXTENDED_KALMAN",
    "UNSCENTED_KALMAN",
    "PARTICLE",
    "IMM",
    "JPDA",
    "MHT",
    "GNN",
    "NNKF",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilterType(FilterType e) {
  if (::flatbuffers::IsOutRange(e, FilterType_ALPHA_BETA, FilterType_NNKF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilterType()[index];
}

enum MotionModel : int8_t {
  MotionModel_CONSTANT_VELOCITY = 0,
  MotionModel_CONSTANT_ACCELERATION = 1,
  MotionModel_COORDINATED_TURN = 2,
  MotionModel_SINGER_ACCELERATION = 3,
  MotionModel_JUMP_MARKOV = 4,
  MotionModel_BALLISTIC = 5,
  MotionModel_ORBITAL = 6,
  MotionModel_SURFACE_VEHICLE = 7,
  MotionModel_CURVILINEAR = 8,
  MotionModel_MIN = MotionModel_CONSTANT_VELOCITY,
  MotionModel_MAX = MotionModel_CURVILINEAR
};

inline const MotionModel (&EnumValuesMotionModel())[9] {
  static const MotionModel values[] = {
    MotionModel_CONSTANT_VELOCITY,
    MotionModel_CONSTANT_ACCELERATION,
    MotionModel_COORDINATED_TURN,
    MotionModel_SINGER_ACCELERATION,
    MotionModel_JUMP_MARKOV,
    MotionModel_BALLISTIC,
    MotionModel_ORBITAL,
    MotionModel_SURFACE_VEHICLE,
    MotionModel_CURVILINEAR
  };
  return values;
}

inline const char * const *EnumNamesMotionModel() {
  static const char * const names[10] = {
    "CONSTANT_VELOCITY",
    "CONSTANT_ACCELERATION",
    "COORDINATED_TURN",
    "SINGER_ACCELERATION",
    "JUMP_MARKOV",
    "BALLISTIC",
    "ORBITAL",
    "SURFACE_VEHICLE",
    "CURVILINEAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameMotionModel(MotionModel e) {
  if (::flatbuffers::IsOutRange(e, MotionModel_CONSTANT_VELOCITY, MotionModel_CURVILINEAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMotionModel()[index];
}

enum MeasurementType : int8_t {
  MeasurementType_POSITION_3D = 0,
  MeasurementType_POSITION_2D = 1,
  MeasurementType_RANGE_BEARING = 2,
  MeasurementType_RANGE_BEARING_ELEVATION = 3,
  MeasurementType_RANGE_ONLY = 4,
  MeasurementType_BEARING_ONLY = 5,
  MeasurementType_RANGE_RATE = 6,
  MeasurementType_ANGLES_ONLY = 7,
  MeasurementType_TLE = 8,
  MeasurementType_GPS = 9,
  MeasurementType_RADAR = 10,
  MeasurementType_ADSB = 11,
  MeasurementType_SONAR = 12,
  MeasurementType_MIN = MeasurementType_POSITION_3D,
  MeasurementType_MAX = MeasurementType_SONAR
};

inline const MeasurementType (&EnumValuesMeasurementType())[13] {
  static const MeasurementType values[] = {
    MeasurementType_POSITION_3D,
    MeasurementType_POSITION_2D,
    MeasurementType_RANGE_BEARING,
    MeasurementType_RANGE_BEARING_ELEVATION,
    MeasurementType_RANGE_ONLY,
    MeasurementType_BEARING_ONLY,
    MeasurementType_RANGE_RATE,
    MeasurementType_ANGLES_ONLY,
    MeasurementType_TLE,
    MeasurementType_GPS,
    MeasurementType_RADAR,
    MeasurementType_ADSB,
    MeasurementType_SONAR
  };
  return values;
}

inline const char * const *EnumNamesMeasurementType() {
  static const char * const names[14] = {
    "POSITION_3D",
    "POSITION_2D",
    "RANGE_BEARING",
    "RANGE_BEARING_ELEVATION",
    "RANGE_ONLY",
    "BEARING_ONLY",
    "RANGE_RATE",
    "ANGLES_ONLY",
    "TLE",
    "GPS",
    "RADAR",
    "ADSB",
    "SONAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameMeasurementType(MeasurementType e) {
  if (::flatbuffers::IsOutRange(e, MeasurementType_POSITION_3D, MeasurementType_SONAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMeasurementType()[index];
}

enum TrackStatus : int8_t {
  TrackStatus_TENTATIVE = 0,
  TrackStatus_CONFIRMED = 1,
  TrackStatus_COASTING = 2,
  TrackStatus_LOST = 3,
  TrackStatus_DELETED = 4,
  TrackStatus_MIN = TrackStatus_TENTATIVE,
  TrackStatus_MAX = TrackStatus_DELETED
};

inline const TrackStatus (&EnumValuesTrackStatus())[5] {
  static const TrackStatus values[] = {
    TrackStatus_TENTATIVE,
    TrackStatus_CONFIRMED,
    TrackStatus_COASTING,
    TrackStatus_LOST,
    TrackStatus_DELETED
  };
  return values;
}

inline const char * const *EnumNamesTrackStatus() {
  static const char * const names[6] = {
    "TENTATIVE",
    "CONFIRMED",
    "COASTING",
    "LOST",
    "DELETED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackStatus(TrackStatus e) {
  if (::flatbuffers::IsOutRange(e, TrackStatus_TENTATIVE, TrackStatus_DELETED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackStatus()[index];
}

enum AssociationMethod : int8_t {
  AssociationMethod_NEAREST_NEIGHBOR = 0,
  AssociationMethod_GLOBAL_NEAREST_NEIGHBOR = 1,
  AssociationMethod_PROBABILISTIC_DATA = 2,
  AssociationMethod_JOINT_PROBABILISTIC = 3,
  AssociationMethod_AUCTION = 4,
  AssociationMethod_HUNGARIAN = 5,
  AssociationMethod_MUNKRES = 6,
  AssociationMethod_MIN = AssociationMethod_NEAREST_NEIGHBOR,
  AssociationMethod_MAX = AssociationMethod_MUNKRES
};

inline const AssociationMethod (&EnumValuesAssociationMethod())[7] {
  static const AssociationMethod values[] = {
    AssociationMethod_NEAREST_NEIGHBOR,
    AssociationMethod_GLOBAL_NEAREST_NEIGHBOR,
    AssociationMethod_PROBABILISTIC_DATA,
    AssociationMethod_JOINT_PROBABILISTIC,
    AssociationMethod_AUCTION,
    AssociationMethod_HUNGARIAN,
    AssociationMethod_MUNKRES
  };
  return values;
}

inline const char * const *EnumNamesAssociationMethod() {
  static const char * const names[8] = {
    "NEAREST_NEIGHBOR",
    "GLOBAL_NEAREST_NEIGHBOR",
    "PROBABILISTIC_DATA",
    "JOINT_PROBABILISTIC",
    "AUCTION",
    "HUNGARIAN",
    "MUNKRES",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssociationMethod(AssociationMethod e) {
  if (::flatbuffers::IsOutRange(e, AssociationMethod_NEAREST_NEIGHBOR, AssociationMethod_MUNKRES)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssociationMethod()[index];
}

enum FusionMethod : int8_t {
  FusionMethod_SIMPLE_AVERAGE = 0,
  FusionMethod_WEIGHTED_AVERAGE = 1,
  FusionMethod_COVARIANCE_INTERSECTION = 2,
  FusionMethod_BAR_SHALOM_CAMPO = 3,
  FusionMethod_FEDERATED = 4,
  FusionMethod_SEQUENTIAL = 5,
  FusionMethod_MIN = FusionMethod_SIMPLE_AVERAGE,
  FusionMethod_MAX = FusionMethod_SEQUENTIAL
};

inline const FusionMethod (&EnumValuesFusionMethod())[6] {
  static const FusionMethod values[] = {
    FusionMethod_SIMPLE_AVERAGE,
    FusionMethod_WEIGHTED_AVERAGE,
    FusionMethod_COVARIANCE_INTERSECTION,
    FusionMethod_BAR_SHALOM_CAMPO,
    FusionMethod_FEDERATED,
    FusionMethod_SEQUENTIAL
  };
  return values;
}

inline const char * const *EnumNamesFusionMethod() {
  static const char * const names[7] = {
    "SIMPLE_AVERAGE",
    "WEIGHTED_AVERAGE",
    "COVARIANCE_INTERSECTION",
    "BAR_SHALOM_CAMPO",
    "FEDERATED",
    "SEQUENTIAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameFusionMethod(FusionMethod e) {
  if (::flatbuffers::IsOutRange(e, FusionMethod_SIMPLE_AVERAGE, FusionMethod_SEQUENTIAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFusionMethod()[index];
}

/// Tracking and Data Fusion
struct TKG FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TKGBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_FILTER_CONFIG = 6,
    VT_IMM_CONFIG = 8,
    VT_MHT_CONFIG = 10,
    VT_JPDA_CONFIG = 12,
    VT_FUSION_CONFIG = 14,
    VT_MEASUREMENTS = 16,
    VT_INITIAL_STATE = 18,
    VT_TRACK_TO_UPDATE = 20,
    VT_TRACKS_TO_CORRELATE = 22
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *FILTER_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILTER_CONFIG);
  }
  const ::flatbuffers::String *IMM_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMM_CONFIG);
  }
  const ::flatbuffers::String *MHT_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MHT_CONFIG);
  }
  const ::flatbuffers::String *JPDA_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JPDA_CONFIG);
  }
  const ::flatbuffers::String *FUSION_CONFIG() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUSION_CONFIG);
  }
  const ::flatbuffers::String *MEASUREMENTS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MEASUREMENTS);
  }
  const ::flatbuffers::String *INITIAL_STATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INITIAL_STATE);
  }
  const ::flatbuffers::String *TRACK_TO_UPDATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACK_TO_UPDATE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *TRACKS_TO_CORRELATE() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TRACKS_TO_CORRELATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_FILTER_CONFIG) &&
           verifier.VerifyString(FILTER_CONFIG()) &&
           VerifyOffset(verifier, VT_IMM_CONFIG) &&
           verifier.VerifyString(IMM_CONFIG()) &&
           VerifyOffset(verifier, VT_MHT_CONFIG) &&
           verifier.VerifyString(MHT_CONFIG()) &&
           VerifyOffset(verifier, VT_JPDA_CONFIG) &&
           verifier.VerifyString(JPDA_CONFIG()) &&
           VerifyOffset(verifier, VT_FUSION_CONFIG) &&
           verifier.VerifyString(FUSION_CONFIG()) &&
           VerifyOffset(verifier, VT_MEASUREMENTS) &&
           verifier.VerifyString(MEASUREMENTS()) &&
           VerifyOffset(verifier, VT_INITIAL_STATE) &&
           verifier.VerifyString(INITIAL_STATE()) &&
           VerifyOffset(verifier, VT_TRACK_TO_UPDATE) &&
           verifier.VerifyString(TRACK_TO_UPDATE()) &&
           VerifyOffset(verifier, VT_TRACKS_TO_CORRELATE) &&
           verifier.VerifyVector(TRACKS_TO_CORRELATE()) &&
           verifier.VerifyVectorOfStrings(TRACKS_TO_CORRELATE()) &&
           verifier.EndTable();
  }
};

struct TKGBuilder {
  typedef TKG Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(TKG::VT_COMMAND, COMMAND);
  }
  void add_FILTER_CONFIG(::flatbuffers::Offset<::flatbuffers::String> FILTER_CONFIG) {
    fbb_.AddOffset(TKG::VT_FILTER_CONFIG, FILTER_CONFIG);
  }
  void add_IMM_CONFIG(::flatbuffers::Offset<::flatbuffers::String> IMM_CONFIG) {
    fbb_.AddOffset(TKG::VT_IMM_CONFIG, IMM_CONFIG);
  }
  void add_MHT_CONFIG(::flatbuffers::Offset<::flatbuffers::String> MHT_CONFIG) {
    fbb_.AddOffset(TKG::VT_MHT_CONFIG, MHT_CONFIG);
  }
  void add_JPDA_CONFIG(::flatbuffers::Offset<::flatbuffers::String> JPDA_CONFIG) {
    fbb_.AddOffset(TKG::VT_JPDA_CONFIG, JPDA_CONFIG);
  }
  void add_FUSION_CONFIG(::flatbuffers::Offset<::flatbuffers::String> FUSION_CONFIG) {
    fbb_.AddOffset(TKG::VT_FUSION_CONFIG, FUSION_CONFIG);
  }
  void add_MEASUREMENTS(::flatbuffers::Offset<::flatbuffers::String> MEASUREMENTS) {
    fbb_.AddOffset(TKG::VT_MEASUREMENTS, MEASUREMENTS);
  }
  void add_INITIAL_STATE(::flatbuffers::Offset<::flatbuffers::String> INITIAL_STATE) {
    fbb_.AddOffset(TKG::VT_INITIAL_STATE, INITIAL_STATE);
  }
  void add_TRACK_TO_UPDATE(::flatbuffers::Offset<::flatbuffers::String> TRACK_TO_UPDATE) {
    fbb_.AddOffset(TKG::VT_TRACK_TO_UPDATE, TRACK_TO_UPDATE);
  }
  void add_TRACKS_TO_CORRELATE(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TRACKS_TO_CORRELATE) {
    fbb_.AddOffset(TKG::VT_TRACKS_TO_CORRELATE, TRACKS_TO_CORRELATE);
  }
  explicit TKGBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TKG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TKG>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TKG> CreateTKG(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FILTER_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> IMM_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MHT_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> JPDA_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FUSION_CONFIG = 0,
    ::flatbuffers::Offset<::flatbuffers::String> MEASUREMENTS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INITIAL_STATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRACK_TO_UPDATE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> TRACKS_TO_CORRELATE = 0) {
  TKGBuilder builder_(_fbb);
  builder_.add_TRACKS_TO_CORRELATE(TRACKS_TO_CORRELATE);
  builder_.add_TRACK_TO_UPDATE(TRACK_TO_UPDATE);
  builder_.add_INITIAL_STATE(INITIAL_STATE);
  builder_.add_MEASUREMENTS(MEASUREMENTS);
  builder_.add_FUSION_CONFIG(FUSION_CONFIG);
  builder_.add_JPDA_CONFIG(JPDA_CONFIG);
  builder_.add_MHT_CONFIG(MHT_CONFIG);
  builder_.add_IMM_CONFIG(IMM_CONFIG);
  builder_.add_FILTER_CONFIG(FILTER_CONFIG);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TKG> CreateTKGDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *FILTER_CONFIG = nullptr,
    const char *IMM_CONFIG = nullptr,
    const char *MHT_CONFIG = nullptr,
    const char *JPDA_CONFIG = nullptr,
    const char *FUSION_CONFIG = nullptr,
    const char *MEASUREMENTS = nullptr,
    const char *INITIAL_STATE = nullptr,
    const char *TRACK_TO_UPDATE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *TRACKS_TO_CORRELATE = nullptr) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto FILTER_CONFIG__ = FILTER_CONFIG ? _fbb.CreateString(FILTER_CONFIG) : 0;
  auto IMM_CONFIG__ = IMM_CONFIG ? _fbb.CreateString(IMM_CONFIG) : 0;
  auto MHT_CONFIG__ = MHT_CONFIG ? _fbb.CreateString(MHT_CONFIG) : 0;
  auto JPDA_CONFIG__ = JPDA_CONFIG ? _fbb.CreateString(JPDA_CONFIG) : 0;
  auto FUSION_CONFIG__ = FUSION_CONFIG ? _fbb.CreateString(FUSION_CONFIG) : 0;
  auto MEASUREMENTS__ = MEASUREMENTS ? _fbb.CreateString(MEASUREMENTS) : 0;
  auto INITIAL_STATE__ = INITIAL_STATE ? _fbb.CreateString(INITIAL_STATE) : 0;
  auto TRACK_TO_UPDATE__ = TRACK_TO_UPDATE ? _fbb.CreateString(TRACK_TO_UPDATE) : 0;
  auto TRACKS_TO_CORRELATE__ = TRACKS_TO_CORRELATE ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*TRACKS_TO_CORRELATE) : 0;
  return CreateTKG(
      _fbb,
      COMMAND__,
      FILTER_CONFIG__,
      IMM_CONFIG__,
      MHT_CONFIG__,
      JPDA_CONFIG__,
      FUSION_CONFIG__,
      MEASUREMENTS__,
      INITIAL_STATE__,
      TRACK_TO_UPDATE__,
      TRACKS_TO_CORRELATE__);
}

inline const TKG *GetTKG(const void *buf) {
  return ::flatbuffers::GetRoot<TKG>(buf);
}

inline const TKG *GetSizePrefixedTKG(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TKG>(buf);
}

inline const char *TKGIdentifier() {
  return "$TKG";
}

inline bool TKGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TKGIdentifier());
}

inline bool SizePrefixedTKGBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TKGIdentifier(), true);
}

inline bool VerifyTKGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TKG>(TKGIdentifier());
}

inline bool VerifySizePrefixedTKGBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TKG>(TKGIdentifier());
}

inline void FinishTKGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TKG> root) {
  fbb.Finish(root, TKGIdentifier());
}

inline void FinishSizePrefixedTKGBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TKG> root) {
  fbb.FinishSizePrefixed(root, TKGIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
