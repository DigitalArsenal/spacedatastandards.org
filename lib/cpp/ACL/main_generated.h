// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"

struct ACL;
struct ACLBuilder;

/// Access Control Grant - Permission to access purchased data
struct ACL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ACLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRANT_ID = 4,
    VT_LISTING_ID = 6,
    VT_BUYER_PEER_ID = 8,
    VT_BUYER_ENCRYPTION_PUBKEY = 10,
    VT_ACCESS_TYPE = 12,
    VT_TIER_NAME = 14,
    VT_GRANTED_AT = 16,
    VT_EXPIRES_AT = 18,
    VT_PAYMENT_TX_HASH = 20,
    VT_PAYMENT_METHOD = 22,
    VT_PROVIDER_SIGNATURE = 24
  };
  /// Unique identifier for this grant
  const ::flatbuffers::String *GRANT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GRANT_ID);
  }
  /// ID of the listing this grant applies to
  const ::flatbuffers::String *LISTING_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LISTING_ID);
  }
  /// Peer ID of the buyer/grantee
  const ::flatbuffers::String *BUYER_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BUYER_PEER_ID);
  }
  /// Buyer's encryption public key for encrypted delivery
  const ::flatbuffers::Vector<uint8_t> *BUYER_ENCRYPTION_PUBKEY() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_BUYER_ENCRYPTION_PUBKEY);
  }
  /// Type of access granted
  accessType ACCESS_TYPE() const {
    return static_cast<accessType>(GetField<int8_t>(VT_ACCESS_TYPE, 0));
  }
  /// Name of the pricing tier purchased
  const ::flatbuffers::String *TIER_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIER_NAME);
  }
  /// Unix timestamp when access was granted
  uint64_t GRANTED_AT() const {
    return GetField<uint64_t>(VT_GRANTED_AT, 0);
  }
  /// Unix timestamp when access expires (0 = never expires)
  uint64_t EXPIRES_AT() const {
    return GetField<uint64_t>(VT_EXPIRES_AT, 0);
  }
  /// Transaction hash or reference proving payment
  const ::flatbuffers::String *PAYMENT_TX_HASH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PAYMENT_TX_HASH);
  }
  /// Payment method used
  paymentMethod PAYMENT_METHOD() const {
    return static_cast<paymentMethod>(GetField<int8_t>(VT_PAYMENT_METHOD, 0));
  }
  /// Ed25519 signature from provider
  const ::flatbuffers::Vector<uint8_t> *PROVIDER_SIGNATURE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PROVIDER_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_GRANT_ID) &&
           verifier.VerifyString(GRANT_ID()) &&
           VerifyOffsetRequired(verifier, VT_LISTING_ID) &&
           verifier.VerifyString(LISTING_ID()) &&
           VerifyOffsetRequired(verifier, VT_BUYER_PEER_ID) &&
           verifier.VerifyString(BUYER_PEER_ID()) &&
           VerifyOffset(verifier, VT_BUYER_ENCRYPTION_PUBKEY) &&
           verifier.VerifyVector(BUYER_ENCRYPTION_PUBKEY()) &&
           VerifyField<int8_t>(verifier, VT_ACCESS_TYPE, 1) &&
           VerifyOffset(verifier, VT_TIER_NAME) &&
           verifier.VerifyString(TIER_NAME()) &&
           VerifyField<uint64_t>(verifier, VT_GRANTED_AT, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXPIRES_AT, 8) &&
           VerifyOffset(verifier, VT_PAYMENT_TX_HASH) &&
           verifier.VerifyString(PAYMENT_TX_HASH()) &&
           VerifyField<int8_t>(verifier, VT_PAYMENT_METHOD, 1) &&
           VerifyOffset(verifier, VT_PROVIDER_SIGNATURE) &&
           verifier.VerifyVector(PROVIDER_SIGNATURE()) &&
           verifier.EndTable();
  }
};

struct ACLBuilder {
  typedef ACL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_GRANT_ID(::flatbuffers::Offset<::flatbuffers::String> GRANT_ID) {
    fbb_.AddOffset(ACL::VT_GRANT_ID, GRANT_ID);
  }
  void add_LISTING_ID(::flatbuffers::Offset<::flatbuffers::String> LISTING_ID) {
    fbb_.AddOffset(ACL::VT_LISTING_ID, LISTING_ID);
  }
  void add_BUYER_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> BUYER_PEER_ID) {
    fbb_.AddOffset(ACL::VT_BUYER_PEER_ID, BUYER_PEER_ID);
  }
  void add_BUYER_ENCRYPTION_PUBKEY(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_ENCRYPTION_PUBKEY) {
    fbb_.AddOffset(ACL::VT_BUYER_ENCRYPTION_PUBKEY, BUYER_ENCRYPTION_PUBKEY);
  }
  void add_ACCESS_TYPE(accessType ACCESS_TYPE) {
    fbb_.AddElement<int8_t>(ACL::VT_ACCESS_TYPE, static_cast<int8_t>(ACCESS_TYPE), 0);
  }
  void add_TIER_NAME(::flatbuffers::Offset<::flatbuffers::String> TIER_NAME) {
    fbb_.AddOffset(ACL::VT_TIER_NAME, TIER_NAME);
  }
  void add_GRANTED_AT(uint64_t GRANTED_AT) {
    fbb_.AddElement<uint64_t>(ACL::VT_GRANTED_AT, GRANTED_AT, 0);
  }
  void add_EXPIRES_AT(uint64_t EXPIRES_AT) {
    fbb_.AddElement<uint64_t>(ACL::VT_EXPIRES_AT, EXPIRES_AT, 0);
  }
  void add_PAYMENT_TX_HASH(::flatbuffers::Offset<::flatbuffers::String> PAYMENT_TX_HASH) {
    fbb_.AddOffset(ACL::VT_PAYMENT_TX_HASH, PAYMENT_TX_HASH);
  }
  void add_PAYMENT_METHOD(paymentMethod PAYMENT_METHOD) {
    fbb_.AddElement<int8_t>(ACL::VT_PAYMENT_METHOD, static_cast<int8_t>(PAYMENT_METHOD), 0);
  }
  void add_PROVIDER_SIGNATURE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> PROVIDER_SIGNATURE) {
    fbb_.AddOffset(ACL::VT_PROVIDER_SIGNATURE, PROVIDER_SIGNATURE);
  }
  explicit ACLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ACL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ACL>(end);
    fbb_.Required(o, ACL::VT_GRANT_ID);
    fbb_.Required(o, ACL::VT_LISTING_ID);
    fbb_.Required(o, ACL::VT_BUYER_PEER_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ACL> CreateACL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> GRANT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LISTING_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> BUYER_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> BUYER_ENCRYPTION_PUBKEY = 0,
    accessType ACCESS_TYPE = accessType_OneTime,
    ::flatbuffers::Offset<::flatbuffers::String> TIER_NAME = 0,
    uint64_t GRANTED_AT = 0,
    uint64_t EXPIRES_AT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PAYMENT_TX_HASH = 0,
    paymentMethod PAYMENT_METHOD = paymentMethod_Crypto_ETH,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> PROVIDER_SIGNATURE = 0) {
  ACLBuilder builder_(_fbb);
  builder_.add_EXPIRES_AT(EXPIRES_AT);
  builder_.add_GRANTED_AT(GRANTED_AT);
  builder_.add_PROVIDER_SIGNATURE(PROVIDER_SIGNATURE);
  builder_.add_PAYMENT_TX_HASH(PAYMENT_TX_HASH);
  builder_.add_TIER_NAME(TIER_NAME);
  builder_.add_BUYER_ENCRYPTION_PUBKEY(BUYER_ENCRYPTION_PUBKEY);
  builder_.add_BUYER_PEER_ID(BUYER_PEER_ID);
  builder_.add_LISTING_ID(LISTING_ID);
  builder_.add_GRANT_ID(GRANT_ID);
  builder_.add_PAYMENT_METHOD(PAYMENT_METHOD);
  builder_.add_ACCESS_TYPE(ACCESS_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ACL> CreateACLDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *GRANT_ID = nullptr,
    const char *LISTING_ID = nullptr,
    const char *BUYER_PEER_ID = nullptr,
    const std::vector<uint8_t> *BUYER_ENCRYPTION_PUBKEY = nullptr,
    accessType ACCESS_TYPE = accessType_OneTime,
    const char *TIER_NAME = nullptr,
    uint64_t GRANTED_AT = 0,
    uint64_t EXPIRES_AT = 0,
    const char *PAYMENT_TX_HASH = nullptr,
    paymentMethod PAYMENT_METHOD = paymentMethod_Crypto_ETH,
    const std::vector<uint8_t> *PROVIDER_SIGNATURE = nullptr) {
  auto GRANT_ID__ = GRANT_ID ? _fbb.CreateString(GRANT_ID) : 0;
  auto LISTING_ID__ = LISTING_ID ? _fbb.CreateString(LISTING_ID) : 0;
  auto BUYER_PEER_ID__ = BUYER_PEER_ID ? _fbb.CreateString(BUYER_PEER_ID) : 0;
  auto BUYER_ENCRYPTION_PUBKEY__ = BUYER_ENCRYPTION_PUBKEY ? _fbb.CreateVector<uint8_t>(*BUYER_ENCRYPTION_PUBKEY) : 0;
  auto TIER_NAME__ = TIER_NAME ? _fbb.CreateString(TIER_NAME) : 0;
  auto PAYMENT_TX_HASH__ = PAYMENT_TX_HASH ? _fbb.CreateString(PAYMENT_TX_HASH) : 0;
  auto PROVIDER_SIGNATURE__ = PROVIDER_SIGNATURE ? _fbb.CreateVector<uint8_t>(*PROVIDER_SIGNATURE) : 0;
  return CreateACL(
      _fbb,
      GRANT_ID__,
      LISTING_ID__,
      BUYER_PEER_ID__,
      BUYER_ENCRYPTION_PUBKEY__,
      ACCESS_TYPE,
      TIER_NAME__,
      GRANTED_AT,
      EXPIRES_AT,
      PAYMENT_TX_HASH__,
      PAYMENT_METHOD,
      PROVIDER_SIGNATURE__);
}

inline const ACL *GetACL(const void *buf) {
  return ::flatbuffers::GetRoot<ACL>(buf);
}

inline const ACL *GetSizePrefixedACL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ACL>(buf);
}

inline const char *ACLIdentifier() {
  return "$ACL";
}

inline bool ACLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ACLIdentifier());
}

inline bool SizePrefixedACLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ACLIdentifier(), true);
}

inline bool VerifyACLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ACL>(ACLIdentifier());
}

inline bool VerifySizePrefixedACLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ACL>(ACLIdentifier());
}

inline void FinishACLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ACL> root) {
  fbb.Finish(root, ACLIdentifier());
}

inline void FinishSizePrefixedACLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ACL> root) {
  fbb.FinishSizePrefixed(root, ACLIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
