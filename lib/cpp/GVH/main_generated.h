// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct GVH;
struct GVHBuilder;

enum VehicleType : int8_t {
  VehicleType_MBT = 0,
  VehicleType_LIGHT_TANK = 1,
  VehicleType_IFV = 2,
  VehicleType_APC = 3,
  VehicleType_SPAA = 4,
  VehicleType_SPG = 5,
  VehicleType_MLRS = 6,
  VehicleType_RECON = 7,
  VehicleType_TRUCK = 8,
  VehicleType_JEEP = 9,
  VehicleType_MRAP = 10,
  VehicleType_ENGINEERING = 11,
  VehicleType_RECOVERY = 12,
  VehicleType_AAA = 13,
  VehicleType_SAM = 14,
  VehicleType_RADAR = 15,
  VehicleType_MIN = VehicleType_MBT,
  VehicleType_MAX = VehicleType_RADAR
};

inline const VehicleType (&EnumValuesVehicleType())[16] {
  static const VehicleType values[] = {
    VehicleType_MBT,
    VehicleType_LIGHT_TANK,
    VehicleType_IFV,
    VehicleType_APC,
    VehicleType_SPAA,
    VehicleType_SPG,
    VehicleType_MLRS,
    VehicleType_RECON,
    VehicleType_TRUCK,
    VehicleType_JEEP,
    VehicleType_MRAP,
    VehicleType_ENGINEERING,
    VehicleType_RECOVERY,
    VehicleType_AAA,
    VehicleType_SAM,
    VehicleType_RADAR
  };
  return values;
}

inline const char * const *EnumNamesVehicleType() {
  static const char * const names[17] = {
    "MBT",
    "LIGHT_TANK",
    "IFV",
    "APC",
    "SPAA",
    "SPG",
    "MLRS",
    "RECON",
    "TRUCK",
    "JEEP",
    "MRAP",
    "ENGINEERING",
    "RECOVERY",
    "AAA",
    "SAM",
    "RADAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameVehicleType(VehicleType e) {
  if (::flatbuffers::IsOutRange(e, VehicleType_MBT, VehicleType_RADAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVehicleType()[index];
}

enum DriveType : int8_t {
  DriveType_TRACKED = 0,
  DriveType_WHEELED_4X4 = 1,
  DriveType_WHEELED_6X6 = 2,
  DriveType_WHEELED_8X8 = 3,
  DriveType_HALF_TRACK = 4,
  DriveType_MIN = DriveType_TRACKED,
  DriveType_MAX = DriveType_HALF_TRACK
};

inline const DriveType (&EnumValuesDriveType())[5] {
  static const DriveType values[] = {
    DriveType_TRACKED,
    DriveType_WHEELED_4X4,
    DriveType_WHEELED_6X6,
    DriveType_WHEELED_8X8,
    DriveType_HALF_TRACK
  };
  return values;
}

inline const char * const *EnumNamesDriveType() {
  static const char * const names[6] = {
    "TRACKED",
    "WHEELED_4X4",
    "WHEELED_6X6",
    "WHEELED_8X8",
    "HALF_TRACK",
    nullptr
  };
  return names;
}

inline const char *EnumNameDriveType(DriveType e) {
  if (::flatbuffers::IsOutRange(e, DriveType_TRACKED, DriveType_HALF_TRACK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDriveType()[index];
}

enum GVHEngineType : int8_t {
  GVHEngineType_DIESEL = 0,
  GVHEngineType_GASOLINE = 1,
  GVHEngineType_GAS_TURBINE = 2,
  GVHEngineType_MULTIFUEL = 3,
  GVHEngineType_HYBRID = 4,
  GVHEngineType_ELECTRIC = 5,
  GVHEngineType_MIN = GVHEngineType_DIESEL,
  GVHEngineType_MAX = GVHEngineType_ELECTRIC
};

inline const GVHEngineType (&EnumValuesGVHEngineType())[6] {
  static const GVHEngineType values[] = {
    GVHEngineType_DIESEL,
    GVHEngineType_GASOLINE,
    GVHEngineType_GAS_TURBINE,
    GVHEngineType_MULTIFUEL,
    GVHEngineType_HYBRID,
    GVHEngineType_ELECTRIC
  };
  return values;
}

inline const char * const *EnumNamesGVHEngineType() {
  static const char * const names[7] = {
    "DIESEL",
    "GASOLINE",
    "GAS_TURBINE",
    "MULTIFUEL",
    "HYBRID",
    "ELECTRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameGVHEngineType(GVHEngineType e) {
  if (::flatbuffers::IsOutRange(e, GVHEngineType_DIESEL, GVHEngineType_ELECTRIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGVHEngineType()[index];
}

/// Ground Vehicles
struct GVH FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GVHBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POSITION_Z = 8,
    VT_VELOCITY_X = 10,
    VT_VELOCITY_Y = 12,
    VT_VELOCITY_Z = 14,
    VT_ATTITUDE_X = 16,
    VT_ATTITUDE_Y = 18,
    VT_ATTITUDE_Z = 20,
    VT_ATTITUDE_W = 22,
    VT_OMEGA_X = 24,
    VT_OMEGA_Y = 26,
    VT_OMEGA_Z = 28,
    VT_SPEED = 30,
    VT_HEADING = 32,
    VT_LATERAL_G = 34,
    VT_LONGITUDINAL_G = 36,
    VT_TURRET = 38,
    VT_DRIVETRAIN = 40,
    VT_SUSPENSION_LF = 42,
    VT_SUSPENSION_RF = 44,
    VT_SUSPENSION_LR = 46,
    VT_SUSPENSION_RR = 48,
    VT_VEHICLE_TYPE = 50,
    VT_DRIVE_TYPE = 52,
    VT_ENGINE_RUNNING = 54,
    VT_LIGHTS = 56,
    VT_FUEL_LEVEL = 58
  };
  double POSITION_X() const {
    return GetField<double>(VT_POSITION_X, 0.0);
  }
  double POSITION_Y() const {
    return GetField<double>(VT_POSITION_Y, 0.0);
  }
  double POSITION_Z() const {
    return GetField<double>(VT_POSITION_Z, 0.0);
  }
  double VELOCITY_X() const {
    return GetField<double>(VT_VELOCITY_X, 0.0);
  }
  double VELOCITY_Y() const {
    return GetField<double>(VT_VELOCITY_Y, 0.0);
  }
  double VELOCITY_Z() const {
    return GetField<double>(VT_VELOCITY_Z, 0.0);
  }
  double ATTITUDE_X() const {
    return GetField<double>(VT_ATTITUDE_X, 0.0);
  }
  double ATTITUDE_Y() const {
    return GetField<double>(VT_ATTITUDE_Y, 0.0);
  }
  double ATTITUDE_Z() const {
    return GetField<double>(VT_ATTITUDE_Z, 0.0);
  }
  double ATTITUDE_W() const {
    return GetField<double>(VT_ATTITUDE_W, 0.0);
  }
  double OMEGA_X() const {
    return GetField<double>(VT_OMEGA_X, 0.0);
  }
  double OMEGA_Y() const {
    return GetField<double>(VT_OMEGA_Y, 0.0);
  }
  double OMEGA_Z() const {
    return GetField<double>(VT_OMEGA_Z, 0.0);
  }
  float SPEED() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  float HEADING() const {
    return GetField<float>(VT_HEADING, 0.0f);
  }
  float LATERAL_G() const {
    return GetField<float>(VT_LATERAL_G, 0.0f);
  }
  float LONGITUDINAL_G() const {
    return GetField<float>(VT_LONGITUDINAL_G, 0.0f);
  }
  const ::flatbuffers::String *TURRET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TURRET);
  }
  const ::flatbuffers::String *DRIVETRAIN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DRIVETRAIN);
  }
  const ::flatbuffers::String *SUSPENSION_LF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUSPENSION_LF);
  }
  const ::flatbuffers::String *SUSPENSION_RF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUSPENSION_RF);
  }
  const ::flatbuffers::String *SUSPENSION_LR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUSPENSION_LR);
  }
  const ::flatbuffers::String *SUSPENSION_RR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUSPENSION_RR);
  }
  uint8_t VEHICLE_TYPE() const {
    return GetField<uint8_t>(VT_VEHICLE_TYPE, 0);
  }
  uint8_t DRIVE_TYPE() const {
    return GetField<uint8_t>(VT_DRIVE_TYPE, 0);
  }
  uint8_t ENGINE_RUNNING() const {
    return GetField<uint8_t>(VT_ENGINE_RUNNING, 0);
  }
  uint8_t LIGHTS() const {
    return GetField<uint8_t>(VT_LIGHTS, 0);
  }
  float FUEL_LEVEL() const {
    return GetField<float>(VT_FUEL_LEVEL, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_POSITION_X, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Y, 8) &&
           VerifyField<double>(verifier, VT_POSITION_Z, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_X, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Y, 8) &&
           VerifyField<double>(verifier, VT_VELOCITY_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_X, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Y, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_Z, 8) &&
           VerifyField<double>(verifier, VT_ATTITUDE_W, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_X, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Y, 8) &&
           VerifyField<double>(verifier, VT_OMEGA_Z, 8) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyField<float>(verifier, VT_HEADING, 4) &&
           VerifyField<float>(verifier, VT_LATERAL_G, 4) &&
           VerifyField<float>(verifier, VT_LONGITUDINAL_G, 4) &&
           VerifyOffset(verifier, VT_TURRET) &&
           verifier.VerifyString(TURRET()) &&
           VerifyOffset(verifier, VT_DRIVETRAIN) &&
           verifier.VerifyString(DRIVETRAIN()) &&
           VerifyOffset(verifier, VT_SUSPENSION_LF) &&
           verifier.VerifyString(SUSPENSION_LF()) &&
           VerifyOffset(verifier, VT_SUSPENSION_RF) &&
           verifier.VerifyString(SUSPENSION_RF()) &&
           VerifyOffset(verifier, VT_SUSPENSION_LR) &&
           verifier.VerifyString(SUSPENSION_LR()) &&
           VerifyOffset(verifier, VT_SUSPENSION_RR) &&
           verifier.VerifyString(SUSPENSION_RR()) &&
           VerifyField<uint8_t>(verifier, VT_VEHICLE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DRIVE_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENGINE_RUNNING, 1) &&
           VerifyField<uint8_t>(verifier, VT_LIGHTS, 1) &&
           VerifyField<float>(verifier, VT_FUEL_LEVEL, 4) &&
           verifier.EndTable();
  }
};

struct GVHBuilder {
  typedef GVH Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POSITION_X(double POSITION_X) {
    fbb_.AddElement<double>(GVH::VT_POSITION_X, POSITION_X, 0.0);
  }
  void add_POSITION_Y(double POSITION_Y) {
    fbb_.AddElement<double>(GVH::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  void add_POSITION_Z(double POSITION_Z) {
    fbb_.AddElement<double>(GVH::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  void add_VELOCITY_X(double VELOCITY_X) {
    fbb_.AddElement<double>(GVH::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  void add_VELOCITY_Y(double VELOCITY_Y) {
    fbb_.AddElement<double>(GVH::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  void add_VELOCITY_Z(double VELOCITY_Z) {
    fbb_.AddElement<double>(GVH::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  void add_ATTITUDE_X(double ATTITUDE_X) {
    fbb_.AddElement<double>(GVH::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  void add_ATTITUDE_Y(double ATTITUDE_Y) {
    fbb_.AddElement<double>(GVH::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  void add_ATTITUDE_Z(double ATTITUDE_Z) {
    fbb_.AddElement<double>(GVH::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  void add_ATTITUDE_W(double ATTITUDE_W) {
    fbb_.AddElement<double>(GVH::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  void add_OMEGA_X(double OMEGA_X) {
    fbb_.AddElement<double>(GVH::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  void add_OMEGA_Y(double OMEGA_Y) {
    fbb_.AddElement<double>(GVH::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  void add_OMEGA_Z(double OMEGA_Z) {
    fbb_.AddElement<double>(GVH::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  void add_SPEED(float SPEED) {
    fbb_.AddElement<float>(GVH::VT_SPEED, SPEED, 0.0f);
  }
  void add_HEADING(float HEADING) {
    fbb_.AddElement<float>(GVH::VT_HEADING, HEADING, 0.0f);
  }
  void add_LATERAL_G(float LATERAL_G) {
    fbb_.AddElement<float>(GVH::VT_LATERAL_G, LATERAL_G, 0.0f);
  }
  void add_LONGITUDINAL_G(float LONGITUDINAL_G) {
    fbb_.AddElement<float>(GVH::VT_LONGITUDINAL_G, LONGITUDINAL_G, 0.0f);
  }
  void add_TURRET(::flatbuffers::Offset<::flatbuffers::String> TURRET) {
    fbb_.AddOffset(GVH::VT_TURRET, TURRET);
  }
  void add_DRIVETRAIN(::flatbuffers::Offset<::flatbuffers::String> DRIVETRAIN) {
    fbb_.AddOffset(GVH::VT_DRIVETRAIN, DRIVETRAIN);
  }
  void add_SUSPENSION_LF(::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_LF) {
    fbb_.AddOffset(GVH::VT_SUSPENSION_LF, SUSPENSION_LF);
  }
  void add_SUSPENSION_RF(::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_RF) {
    fbb_.AddOffset(GVH::VT_SUSPENSION_RF, SUSPENSION_RF);
  }
  void add_SUSPENSION_LR(::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_LR) {
    fbb_.AddOffset(GVH::VT_SUSPENSION_LR, SUSPENSION_LR);
  }
  void add_SUSPENSION_RR(::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_RR) {
    fbb_.AddOffset(GVH::VT_SUSPENSION_RR, SUSPENSION_RR);
  }
  void add_VEHICLE_TYPE(uint8_t VEHICLE_TYPE) {
    fbb_.AddElement<uint8_t>(GVH::VT_VEHICLE_TYPE, VEHICLE_TYPE, 0);
  }
  void add_DRIVE_TYPE(uint8_t DRIVE_TYPE) {
    fbb_.AddElement<uint8_t>(GVH::VT_DRIVE_TYPE, DRIVE_TYPE, 0);
  }
  void add_ENGINE_RUNNING(uint8_t ENGINE_RUNNING) {
    fbb_.AddElement<uint8_t>(GVH::VT_ENGINE_RUNNING, ENGINE_RUNNING, 0);
  }
  void add_LIGHTS(uint8_t LIGHTS) {
    fbb_.AddElement<uint8_t>(GVH::VT_LIGHTS, LIGHTS, 0);
  }
  void add_FUEL_LEVEL(float FUEL_LEVEL) {
    fbb_.AddElement<float>(GVH::VT_FUEL_LEVEL, FUEL_LEVEL, 0.0f);
  }
  explicit GVHBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GVH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GVH>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GVH> CreateGVH(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    float SPEED = 0.0f,
    float HEADING = 0.0f,
    float LATERAL_G = 0.0f,
    float LONGITUDINAL_G = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> TURRET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DRIVETRAIN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_LF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_RF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_LR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SUSPENSION_RR = 0,
    uint8_t VEHICLE_TYPE = 0,
    uint8_t DRIVE_TYPE = 0,
    uint8_t ENGINE_RUNNING = 0,
    uint8_t LIGHTS = 0,
    float FUEL_LEVEL = 0.0f) {
  GVHBuilder builder_(_fbb);
  builder_.add_OMEGA_Z(OMEGA_Z);
  builder_.add_OMEGA_Y(OMEGA_Y);
  builder_.add_OMEGA_X(OMEGA_X);
  builder_.add_ATTITUDE_W(ATTITUDE_W);
  builder_.add_ATTITUDE_Z(ATTITUDE_Z);
  builder_.add_ATTITUDE_Y(ATTITUDE_Y);
  builder_.add_ATTITUDE_X(ATTITUDE_X);
  builder_.add_VELOCITY_Z(VELOCITY_Z);
  builder_.add_VELOCITY_Y(VELOCITY_Y);
  builder_.add_VELOCITY_X(VELOCITY_X);
  builder_.add_POSITION_Z(POSITION_Z);
  builder_.add_POSITION_Y(POSITION_Y);
  builder_.add_POSITION_X(POSITION_X);
  builder_.add_FUEL_LEVEL(FUEL_LEVEL);
  builder_.add_SUSPENSION_RR(SUSPENSION_RR);
  builder_.add_SUSPENSION_LR(SUSPENSION_LR);
  builder_.add_SUSPENSION_RF(SUSPENSION_RF);
  builder_.add_SUSPENSION_LF(SUSPENSION_LF);
  builder_.add_DRIVETRAIN(DRIVETRAIN);
  builder_.add_TURRET(TURRET);
  builder_.add_LONGITUDINAL_G(LONGITUDINAL_G);
  builder_.add_LATERAL_G(LATERAL_G);
  builder_.add_HEADING(HEADING);
  builder_.add_SPEED(SPEED);
  builder_.add_LIGHTS(LIGHTS);
  builder_.add_ENGINE_RUNNING(ENGINE_RUNNING);
  builder_.add_DRIVE_TYPE(DRIVE_TYPE);
  builder_.add_VEHICLE_TYPE(VEHICLE_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GVH> CreateGVHDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double POSITION_X = 0.0,
    double POSITION_Y = 0.0,
    double POSITION_Z = 0.0,
    double VELOCITY_X = 0.0,
    double VELOCITY_Y = 0.0,
    double VELOCITY_Z = 0.0,
    double ATTITUDE_X = 0.0,
    double ATTITUDE_Y = 0.0,
    double ATTITUDE_Z = 0.0,
    double ATTITUDE_W = 0.0,
    double OMEGA_X = 0.0,
    double OMEGA_Y = 0.0,
    double OMEGA_Z = 0.0,
    float SPEED = 0.0f,
    float HEADING = 0.0f,
    float LATERAL_G = 0.0f,
    float LONGITUDINAL_G = 0.0f,
    const char *TURRET = nullptr,
    const char *DRIVETRAIN = nullptr,
    const char *SUSPENSION_LF = nullptr,
    const char *SUSPENSION_RF = nullptr,
    const char *SUSPENSION_LR = nullptr,
    const char *SUSPENSION_RR = nullptr,
    uint8_t VEHICLE_TYPE = 0,
    uint8_t DRIVE_TYPE = 0,
    uint8_t ENGINE_RUNNING = 0,
    uint8_t LIGHTS = 0,
    float FUEL_LEVEL = 0.0f) {
  auto TURRET__ = TURRET ? _fbb.CreateString(TURRET) : 0;
  auto DRIVETRAIN__ = DRIVETRAIN ? _fbb.CreateString(DRIVETRAIN) : 0;
  auto SUSPENSION_LF__ = SUSPENSION_LF ? _fbb.CreateString(SUSPENSION_LF) : 0;
  auto SUSPENSION_RF__ = SUSPENSION_RF ? _fbb.CreateString(SUSPENSION_RF) : 0;
  auto SUSPENSION_LR__ = SUSPENSION_LR ? _fbb.CreateString(SUSPENSION_LR) : 0;
  auto SUSPENSION_RR__ = SUSPENSION_RR ? _fbb.CreateString(SUSPENSION_RR) : 0;
  return CreateGVH(
      _fbb,
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED,
      HEADING,
      LATERAL_G,
      LONGITUDINAL_G,
      TURRET__,
      DRIVETRAIN__,
      SUSPENSION_LF__,
      SUSPENSION_RF__,
      SUSPENSION_LR__,
      SUSPENSION_RR__,
      VEHICLE_TYPE,
      DRIVE_TYPE,
      ENGINE_RUNNING,
      LIGHTS,
      FUEL_LEVEL);
}

inline const GVH *GetGVH(const void *buf) {
  return ::flatbuffers::GetRoot<GVH>(buf);
}

inline const GVH *GetSizePrefixedGVH(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GVH>(buf);
}

inline const char *GVHIdentifier() {
  return "$GVH";
}

inline bool GVHBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GVHIdentifier());
}

inline bool SizePrefixedGVHBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GVHIdentifier(), true);
}

inline bool VerifyGVHBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GVH>(GVHIdentifier());
}

inline bool VerifySizePrefixedGVHBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GVH>(GVHIdentifier());
}

inline void FinishGVHBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GVH> root) {
  fbb.Finish(root, GVHIdentifier());
}

inline void FinishSizePrefixedGVHBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GVH> root) {
  fbb.FinishSizePrefixed(root, GVHIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
