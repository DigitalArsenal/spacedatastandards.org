// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SpatialCoverage;
struct SpatialCoverageBuilder;

struct TemporalCoverage;
struct TemporalCoverageBuilder;

struct DataCoverage;
struct DataCoverageBuilder;

struct PricingTier;
struct PricingTierBuilder;

struct STF;
struct STFBuilder;

/// Access type for data listings
enum accessType : int8_t {
  /// One-time purchase
  accessType_OneTime = 0,
  /// Recurring subscription
  accessType_Subscription = 1,
  /// Real-time streaming access
  accessType_Streaming = 2,
  /// Query-based access
  accessType_Query = 3,
  accessType_MIN = accessType_OneTime,
  accessType_MAX = accessType_Query
};

inline const accessType (&EnumValuesaccessType())[4] {
  static const accessType values[] = {
    accessType_OneTime,
    accessType_Subscription,
    accessType_Streaming,
    accessType_Query
  };
  return values;
}

inline const char * const *EnumNamesaccessType() {
  static const char * const names[5] = {
    "OneTime",
    "Subscription",
    "Streaming",
    "Query",
    nullptr
  };
  return names;
}

inline const char *EnumNameaccessType(accessType e) {
  if (::flatbuffers::IsOutRange(e, accessType_OneTime, accessType_Query)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesaccessType()[index];
}

/// Payment method accepted
enum paymentMethod : int8_t {
  /// Ethereum cryptocurrency
  paymentMethod_Crypto_ETH = 0,
  /// Solana cryptocurrency
  paymentMethod_Crypto_SOL = 1,
  /// Bitcoin cryptocurrency
  paymentMethod_Crypto_BTC = 2,
  /// Internal SDN credits system
  paymentMethod_SDN_Credits = 3,
  /// Fiat payment via Stripe
  paymentMethod_Fiat_Stripe = 4,
  /// Free/open data
  paymentMethod_Free = 5,
  paymentMethod_MIN = paymentMethod_Crypto_ETH,
  paymentMethod_MAX = paymentMethod_Free
};

inline const paymentMethod (&EnumValuespaymentMethod())[6] {
  static const paymentMethod values[] = {
    paymentMethod_Crypto_ETH,
    paymentMethod_Crypto_SOL,
    paymentMethod_Crypto_BTC,
    paymentMethod_SDN_Credits,
    paymentMethod_Fiat_Stripe,
    paymentMethod_Free
  };
  return values;
}

inline const char * const *EnumNamespaymentMethod() {
  static const char * const names[7] = {
    "Crypto_ETH",
    "Crypto_SOL",
    "Crypto_BTC",
    "SDN_Credits",
    "Fiat_Stripe",
    "Free",
    nullptr
  };
  return names;
}

inline const char *EnumNamepaymentMethod(paymentMethod e) {
  if (::flatbuffers::IsOutRange(e, paymentMethod_Crypto_ETH, paymentMethod_Free)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamespaymentMethod()[index];
}

/// Spatial coverage definition
struct SpatialCoverage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpatialCoverageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_REGIONS = 6,
    VT_OBJECT_IDS = 8
  };
  /// Type of coverage: "global", "region", "object_list"
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Regions covered, e.g., ["LEO", "GEO", "MEO"]
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *REGIONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_REGIONS);
  }
  /// Specific NORAD IDs or catalog numbers
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *OBJECT_IDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OBJECT_IDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyOffset(verifier, VT_REGIONS) &&
           verifier.VerifyVector(REGIONS()) &&
           verifier.VerifyVectorOfStrings(REGIONS()) &&
           VerifyOffset(verifier, VT_OBJECT_IDS) &&
           verifier.VerifyVector(OBJECT_IDS()) &&
           verifier.VerifyVectorOfStrings(OBJECT_IDS()) &&
           verifier.EndTable();
  }
};

struct SpatialCoverageBuilder {
  typedef SpatialCoverage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(SpatialCoverage::VT_TYPE, TYPE);
  }
  void add_REGIONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> REGIONS) {
    fbb_.AddOffset(SpatialCoverage::VT_REGIONS, REGIONS);
  }
  void add_OBJECT_IDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OBJECT_IDS) {
    fbb_.AddOffset(SpatialCoverage::VT_OBJECT_IDS, OBJECT_IDS);
  }
  explicit SpatialCoverageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpatialCoverage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpatialCoverage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpatialCoverage> CreateSpatialCoverage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> REGIONS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> OBJECT_IDS = 0) {
  SpatialCoverageBuilder builder_(_fbb);
  builder_.add_OBJECT_IDS(OBJECT_IDS);
  builder_.add_REGIONS(REGIONS);
  builder_.add_TYPE(TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SpatialCoverage> CreateSpatialCoverageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *TYPE = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *REGIONS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *OBJECT_IDS = nullptr) {
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto REGIONS__ = REGIONS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*REGIONS) : 0;
  auto OBJECT_IDS__ = OBJECT_IDS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*OBJECT_IDS) : 0;
  return CreateSpatialCoverage(
      _fbb,
      TYPE__,
      REGIONS__,
      OBJECT_IDS__);
}

/// Temporal coverage definition
struct TemporalCoverage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TemporalCoverageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_EPOCH = 4,
    VT_END_EPOCH = 6,
    VT_UPDATE_FREQUENCY = 8,
    VT_HISTORICAL_DEPTH = 10
  };
  /// Start epoch in ISO 8601 format
  const ::flatbuffers::String *START_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_EPOCH);
  }
  /// End epoch in ISO 8601 format
  const ::flatbuffers::String *END_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END_EPOCH);
  }
  /// Update frequency: "realtime", "hourly", "daily"
  const ::flatbuffers::String *UPDATE_FREQUENCY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATE_FREQUENCY);
  }
  /// Days of historical data available
  uint32_t HISTORICAL_DEPTH() const {
    return GetField<uint32_t>(VT_HISTORICAL_DEPTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_EPOCH) &&
           verifier.VerifyString(START_EPOCH()) &&
           VerifyOffset(verifier, VT_END_EPOCH) &&
           verifier.VerifyString(END_EPOCH()) &&
           VerifyOffset(verifier, VT_UPDATE_FREQUENCY) &&
           verifier.VerifyString(UPDATE_FREQUENCY()) &&
           VerifyField<uint32_t>(verifier, VT_HISTORICAL_DEPTH, 4) &&
           verifier.EndTable();
  }
};

struct TemporalCoverageBuilder {
  typedef TemporalCoverage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_START_EPOCH(::flatbuffers::Offset<::flatbuffers::String> START_EPOCH) {
    fbb_.AddOffset(TemporalCoverage::VT_START_EPOCH, START_EPOCH);
  }
  void add_END_EPOCH(::flatbuffers::Offset<::flatbuffers::String> END_EPOCH) {
    fbb_.AddOffset(TemporalCoverage::VT_END_EPOCH, END_EPOCH);
  }
  void add_UPDATE_FREQUENCY(::flatbuffers::Offset<::flatbuffers::String> UPDATE_FREQUENCY) {
    fbb_.AddOffset(TemporalCoverage::VT_UPDATE_FREQUENCY, UPDATE_FREQUENCY);
  }
  void add_HISTORICAL_DEPTH(uint32_t HISTORICAL_DEPTH) {
    fbb_.AddElement<uint32_t>(TemporalCoverage::VT_HISTORICAL_DEPTH, HISTORICAL_DEPTH, 0);
  }
  explicit TemporalCoverageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TemporalCoverage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TemporalCoverage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TemporalCoverage> CreateTemporalCoverage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> START_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> END_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::String> UPDATE_FREQUENCY = 0,
    uint32_t HISTORICAL_DEPTH = 0) {
  TemporalCoverageBuilder builder_(_fbb);
  builder_.add_HISTORICAL_DEPTH(HISTORICAL_DEPTH);
  builder_.add_UPDATE_FREQUENCY(UPDATE_FREQUENCY);
  builder_.add_END_EPOCH(END_EPOCH);
  builder_.add_START_EPOCH(START_EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TemporalCoverage> CreateTemporalCoverageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *START_EPOCH = nullptr,
    const char *END_EPOCH = nullptr,
    const char *UPDATE_FREQUENCY = nullptr,
    uint32_t HISTORICAL_DEPTH = 0) {
  auto START_EPOCH__ = START_EPOCH ? _fbb.CreateString(START_EPOCH) : 0;
  auto END_EPOCH__ = END_EPOCH ? _fbb.CreateString(END_EPOCH) : 0;
  auto UPDATE_FREQUENCY__ = UPDATE_FREQUENCY ? _fbb.CreateString(UPDATE_FREQUENCY) : 0;
  return CreateTemporalCoverage(
      _fbb,
      START_EPOCH__,
      END_EPOCH__,
      UPDATE_FREQUENCY__,
      HISTORICAL_DEPTH);
}

/// Data coverage combining spatial and temporal
struct DataCoverage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataCoverageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPATIAL = 4,
    VT_TEMPORAL = 6
  };
  /// Spatial coverage definition
  const SpatialCoverage *SPATIAL() const {
    return GetPointer<const SpatialCoverage *>(VT_SPATIAL);
  }
  /// Temporal coverage definition
  const TemporalCoverage *TEMPORAL() const {
    return GetPointer<const TemporalCoverage *>(VT_TEMPORAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPATIAL) &&
           verifier.VerifyTable(SPATIAL()) &&
           VerifyOffset(verifier, VT_TEMPORAL) &&
           verifier.VerifyTable(TEMPORAL()) &&
           verifier.EndTable();
  }
};

struct DataCoverageBuilder {
  typedef DataCoverage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SPATIAL(::flatbuffers::Offset<SpatialCoverage> SPATIAL) {
    fbb_.AddOffset(DataCoverage::VT_SPATIAL, SPATIAL);
  }
  void add_TEMPORAL(::flatbuffers::Offset<TemporalCoverage> TEMPORAL) {
    fbb_.AddOffset(DataCoverage::VT_TEMPORAL, TEMPORAL);
  }
  explicit DataCoverageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataCoverage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataCoverage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataCoverage> CreateDataCoverage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<SpatialCoverage> SPATIAL = 0,
    ::flatbuffers::Offset<TemporalCoverage> TEMPORAL = 0) {
  DataCoverageBuilder builder_(_fbb);
  builder_.add_TEMPORAL(TEMPORAL);
  builder_.add_SPATIAL(SPATIAL);
  return builder_.Finish();
}

/// Pricing tier for a listing
struct PricingTier FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PricingTierBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PRICE_AMOUNT = 6,
    VT_PRICE_CURRENCY = 8,
    VT_DURATION_DAYS = 10,
    VT_RATE_LIMIT = 12,
    VT_FEATURES = 14
  };
  /// Tier name, e.g., "Basic", "Pro", "Enterprise"
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Price in smallest unit (cents, satoshis, etc.)
  uint64_t PRICE_AMOUNT() const {
    return GetField<uint64_t>(VT_PRICE_AMOUNT, 0);
  }
  /// Currency code: "USD", "ETH", "SOL", "SDN_CREDITS"
  const ::flatbuffers::String *PRICE_CURRENCY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRICE_CURRENCY);
  }
  /// Duration in days (0 = one-time purchase)
  uint32_t DURATION_DAYS() const {
    return GetField<uint32_t>(VT_DURATION_DAYS, 0);
  }
  /// Rate limit in requests per hour
  uint32_t RATE_LIMIT() const {
    return GetField<uint32_t>(VT_RATE_LIMIT, 0);
  }
  /// List of features included in this tier
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *FEATURES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_FEATURES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint64_t>(verifier, VT_PRICE_AMOUNT, 8) &&
           VerifyOffset(verifier, VT_PRICE_CURRENCY) &&
           verifier.VerifyString(PRICE_CURRENCY()) &&
           VerifyField<uint32_t>(verifier, VT_DURATION_DAYS, 4) &&
           VerifyField<uint32_t>(verifier, VT_RATE_LIMIT, 4) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(FEATURES()) &&
           verifier.VerifyVectorOfStrings(FEATURES()) &&
           verifier.EndTable();
  }
};

struct PricingTierBuilder {
  typedef PricingTier Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(PricingTier::VT_NAME, NAME);
  }
  void add_PRICE_AMOUNT(uint64_t PRICE_AMOUNT) {
    fbb_.AddElement<uint64_t>(PricingTier::VT_PRICE_AMOUNT, PRICE_AMOUNT, 0);
  }
  void add_PRICE_CURRENCY(::flatbuffers::Offset<::flatbuffers::String> PRICE_CURRENCY) {
    fbb_.AddOffset(PricingTier::VT_PRICE_CURRENCY, PRICE_CURRENCY);
  }
  void add_DURATION_DAYS(uint32_t DURATION_DAYS) {
    fbb_.AddElement<uint32_t>(PricingTier::VT_DURATION_DAYS, DURATION_DAYS, 0);
  }
  void add_RATE_LIMIT(uint32_t RATE_LIMIT) {
    fbb_.AddElement<uint32_t>(PricingTier::VT_RATE_LIMIT, RATE_LIMIT, 0);
  }
  void add_FEATURES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> FEATURES) {
    fbb_.AddOffset(PricingTier::VT_FEATURES, FEATURES);
  }
  explicit PricingTierBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PricingTier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PricingTier>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PricingTier> CreatePricingTier(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    uint64_t PRICE_AMOUNT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PRICE_CURRENCY = 0,
    uint32_t DURATION_DAYS = 0,
    uint32_t RATE_LIMIT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> FEATURES = 0) {
  PricingTierBuilder builder_(_fbb);
  builder_.add_PRICE_AMOUNT(PRICE_AMOUNT);
  builder_.add_FEATURES(FEATURES);
  builder_.add_RATE_LIMIT(RATE_LIMIT);
  builder_.add_DURATION_DAYS(DURATION_DAYS);
  builder_.add_PRICE_CURRENCY(PRICE_CURRENCY);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PricingTier> CreatePricingTierDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    uint64_t PRICE_AMOUNT = 0,
    const char *PRICE_CURRENCY = nullptr,
    uint32_t DURATION_DAYS = 0,
    uint32_t RATE_LIMIT = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *FEATURES = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto PRICE_CURRENCY__ = PRICE_CURRENCY ? _fbb.CreateString(PRICE_CURRENCY) : 0;
  auto FEATURES__ = FEATURES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*FEATURES) : 0;
  return CreatePricingTier(
      _fbb,
      NAME__,
      PRICE_AMOUNT,
      PRICE_CURRENCY__,
      DURATION_DAYS,
      RATE_LIMIT,
      FEATURES__);
}

/// Storefront Listing - Data marketplace listing
struct STF FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef STFBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LISTING_ID = 4,
    VT_PROVIDER_PEER_ID = 6,
    VT_PROVIDER_EPM_CID = 8,
    VT_TITLE = 10,
    VT_DESCRIPTION = 12,
    VT_DATA_TYPES = 14,
    VT_COVERAGE = 16,
    VT_SAMPLE_CID = 18,
    VT_ACCESS_TYPE = 20,
    VT_ENCRYPTION_REQUIRED = 22,
    VT_PRICING = 24,
    VT_ACCEPTED_PAYMENTS = 26,
    VT_CREATED_AT = 28,
    VT_UPDATED_AT = 30,
    VT_ACTIVE = 32,
    VT_SIGNATURE = 34
  };
  /// Unique identifier for the listing
  const ::flatbuffers::String *LISTING_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LISTING_ID);
  }
  /// Peer ID of the data provider
  const ::flatbuffers::String *PROVIDER_PEER_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROVIDER_PEER_ID);
  }
  /// IPFS CID of provider's EPM (Entity Profile Message)
  const ::flatbuffers::String *PROVIDER_EPM_CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROVIDER_EPM_CID);
  }
  /// Title of the data listing
  const ::flatbuffers::String *TITLE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  /// Detailed description of the data offering
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *DATA_TYPES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATA_TYPES);
  }
  /// Coverage information (spatial and temporal)
  const DataCoverage *COVERAGE() const {
    return GetPointer<const DataCoverage *>(VT_COVERAGE);
  }
  /// IPFS CID of sample data
  const ::flatbuffers::String *SAMPLE_CID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SAMPLE_CID);
  }
  /// Type of access offered
  accessType ACCESS_TYPE() const {
    return static_cast<accessType>(GetField<int8_t>(VT_ACCESS_TYPE, 0));
  }
  /// Whether encryption is required for data delivery
  bool ENCRYPTION_REQUIRED() const {
    return GetField<uint8_t>(VT_ENCRYPTION_REQUIRED, 0) != 0;
  }
  /// Available pricing tiers
  const ::flatbuffers::Vector<::flatbuffers::Offset<PricingTier>> *PRICING() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PricingTier>> *>(VT_PRICING);
  }
  /// Payment methods accepted
  const ::flatbuffers::Vector<int8_t> *ACCEPTED_PAYMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_ACCEPTED_PAYMENTS);
  }
  /// Unix timestamp when listing was created
  uint64_t CREATED_AT() const {
    return GetField<uint64_t>(VT_CREATED_AT, 0);
  }
  /// Unix timestamp when listing was last updated
  uint64_t UPDATED_AT() const {
    return GetField<uint64_t>(VT_UPDATED_AT, 0);
  }
  /// Whether the listing is currently active
  bool ACTIVE() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  /// Ed25519 signature from provider
  const ::flatbuffers::Vector<uint8_t> *SIGNATURE() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LISTING_ID) &&
           verifier.VerifyString(LISTING_ID()) &&
           VerifyOffsetRequired(verifier, VT_PROVIDER_PEER_ID) &&
           verifier.VerifyString(PROVIDER_PEER_ID()) &&
           VerifyOffset(verifier, VT_PROVIDER_EPM_CID) &&
           verifier.VerifyString(PROVIDER_EPM_CID()) &&
           VerifyOffsetRequired(verifier, VT_TITLE) &&
           verifier.VerifyString(TITLE()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_DATA_TYPES) &&
           verifier.VerifyVector(DATA_TYPES()) &&
           verifier.VerifyVectorOfStrings(DATA_TYPES()) &&
           VerifyOffset(verifier, VT_COVERAGE) &&
           verifier.VerifyTable(COVERAGE()) &&
           VerifyOffset(verifier, VT_SAMPLE_CID) &&
           verifier.VerifyString(SAMPLE_CID()) &&
           VerifyField<int8_t>(verifier, VT_ACCESS_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ENCRYPTION_REQUIRED, 1) &&
           VerifyOffset(verifier, VT_PRICING) &&
           verifier.VerifyVector(PRICING()) &&
           verifier.VerifyVectorOfTables(PRICING()) &&
           VerifyOffset(verifier, VT_ACCEPTED_PAYMENTS) &&
           verifier.VerifyVector(ACCEPTED_PAYMENTS()) &&
           VerifyField<uint64_t>(verifier, VT_CREATED_AT, 8) &&
           VerifyField<uint64_t>(verifier, VT_UPDATED_AT, 8) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE, 1) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(SIGNATURE()) &&
           verifier.EndTable();
  }
};

struct STFBuilder {
  typedef STF Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LISTING_ID(::flatbuffers::Offset<::flatbuffers::String> LISTING_ID) {
    fbb_.AddOffset(STF::VT_LISTING_ID, LISTING_ID);
  }
  void add_PROVIDER_PEER_ID(::flatbuffers::Offset<::flatbuffers::String> PROVIDER_PEER_ID) {
    fbb_.AddOffset(STF::VT_PROVIDER_PEER_ID, PROVIDER_PEER_ID);
  }
  void add_PROVIDER_EPM_CID(::flatbuffers::Offset<::flatbuffers::String> PROVIDER_EPM_CID) {
    fbb_.AddOffset(STF::VT_PROVIDER_EPM_CID, PROVIDER_EPM_CID);
  }
  void add_TITLE(::flatbuffers::Offset<::flatbuffers::String> TITLE) {
    fbb_.AddOffset(STF::VT_TITLE, TITLE);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(STF::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_DATA_TYPES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> DATA_TYPES) {
    fbb_.AddOffset(STF::VT_DATA_TYPES, DATA_TYPES);
  }
  void add_COVERAGE(::flatbuffers::Offset<DataCoverage> COVERAGE) {
    fbb_.AddOffset(STF::VT_COVERAGE, COVERAGE);
  }
  void add_SAMPLE_CID(::flatbuffers::Offset<::flatbuffers::String> SAMPLE_CID) {
    fbb_.AddOffset(STF::VT_SAMPLE_CID, SAMPLE_CID);
  }
  void add_ACCESS_TYPE(accessType ACCESS_TYPE) {
    fbb_.AddElement<int8_t>(STF::VT_ACCESS_TYPE, static_cast<int8_t>(ACCESS_TYPE), 0);
  }
  void add_ENCRYPTION_REQUIRED(bool ENCRYPTION_REQUIRED) {
    fbb_.AddElement<uint8_t>(STF::VT_ENCRYPTION_REQUIRED, static_cast<uint8_t>(ENCRYPTION_REQUIRED), 0);
  }
  void add_PRICING(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PricingTier>>> PRICING) {
    fbb_.AddOffset(STF::VT_PRICING, PRICING);
  }
  void add_ACCEPTED_PAYMENTS(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> ACCEPTED_PAYMENTS) {
    fbb_.AddOffset(STF::VT_ACCEPTED_PAYMENTS, ACCEPTED_PAYMENTS);
  }
  void add_CREATED_AT(uint64_t CREATED_AT) {
    fbb_.AddElement<uint64_t>(STF::VT_CREATED_AT, CREATED_AT, 0);
  }
  void add_UPDATED_AT(uint64_t UPDATED_AT) {
    fbb_.AddElement<uint64_t>(STF::VT_UPDATED_AT, UPDATED_AT, 0);
  }
  void add_ACTIVE(bool ACTIVE) {
    fbb_.AddElement<uint8_t>(STF::VT_ACTIVE, static_cast<uint8_t>(ACTIVE), 0);
  }
  void add_SIGNATURE(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE) {
    fbb_.AddOffset(STF::VT_SIGNATURE, SIGNATURE);
  }
  explicit STFBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<STF> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<STF>(end);
    fbb_.Required(o, STF::VT_LISTING_ID);
    fbb_.Required(o, STF::VT_PROVIDER_PEER_ID);
    fbb_.Required(o, STF::VT_TITLE);
    return o;
  }
};

inline ::flatbuffers::Offset<STF> CreateSTF(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> LISTING_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROVIDER_PEER_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROVIDER_EPM_CID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TITLE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> DATA_TYPES = 0,
    ::flatbuffers::Offset<DataCoverage> COVERAGE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SAMPLE_CID = 0,
    accessType ACCESS_TYPE = accessType_OneTime,
    bool ENCRYPTION_REQUIRED = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PricingTier>>> PRICING = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> ACCEPTED_PAYMENTS = 0,
    uint64_t CREATED_AT = 0,
    uint64_t UPDATED_AT = 0,
    bool ACTIVE = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> SIGNATURE = 0) {
  STFBuilder builder_(_fbb);
  builder_.add_UPDATED_AT(UPDATED_AT);
  builder_.add_CREATED_AT(CREATED_AT);
  builder_.add_SIGNATURE(SIGNATURE);
  builder_.add_ACCEPTED_PAYMENTS(ACCEPTED_PAYMENTS);
  builder_.add_PRICING(PRICING);
  builder_.add_SAMPLE_CID(SAMPLE_CID);
  builder_.add_COVERAGE(COVERAGE);
  builder_.add_DATA_TYPES(DATA_TYPES);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_TITLE(TITLE);
  builder_.add_PROVIDER_EPM_CID(PROVIDER_EPM_CID);
  builder_.add_PROVIDER_PEER_ID(PROVIDER_PEER_ID);
  builder_.add_LISTING_ID(LISTING_ID);
  builder_.add_ACTIVE(ACTIVE);
  builder_.add_ENCRYPTION_REQUIRED(ENCRYPTION_REQUIRED);
  builder_.add_ACCESS_TYPE(ACCESS_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<STF> CreateSTFDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *LISTING_ID = nullptr,
    const char *PROVIDER_PEER_ID = nullptr,
    const char *PROVIDER_EPM_CID = nullptr,
    const char *TITLE = nullptr,
    const char *DESCRIPTION = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *DATA_TYPES = nullptr,
    ::flatbuffers::Offset<DataCoverage> COVERAGE = 0,
    const char *SAMPLE_CID = nullptr,
    accessType ACCESS_TYPE = accessType_OneTime,
    bool ENCRYPTION_REQUIRED = false,
    const std::vector<::flatbuffers::Offset<PricingTier>> *PRICING = nullptr,
    const std::vector<int8_t> *ACCEPTED_PAYMENTS = nullptr,
    uint64_t CREATED_AT = 0,
    uint64_t UPDATED_AT = 0,
    bool ACTIVE = false,
    const std::vector<uint8_t> *SIGNATURE = nullptr) {
  auto LISTING_ID__ = LISTING_ID ? _fbb.CreateString(LISTING_ID) : 0;
  auto PROVIDER_PEER_ID__ = PROVIDER_PEER_ID ? _fbb.CreateString(PROVIDER_PEER_ID) : 0;
  auto PROVIDER_EPM_CID__ = PROVIDER_EPM_CID ? _fbb.CreateString(PROVIDER_EPM_CID) : 0;
  auto TITLE__ = TITLE ? _fbb.CreateString(TITLE) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto DATA_TYPES__ = DATA_TYPES ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*DATA_TYPES) : 0;
  auto SAMPLE_CID__ = SAMPLE_CID ? _fbb.CreateString(SAMPLE_CID) : 0;
  auto PRICING__ = PRICING ? _fbb.CreateVector<::flatbuffers::Offset<PricingTier>>(*PRICING) : 0;
  auto ACCEPTED_PAYMENTS__ = ACCEPTED_PAYMENTS ? _fbb.CreateVector<int8_t>(*ACCEPTED_PAYMENTS) : 0;
  auto SIGNATURE__ = SIGNATURE ? _fbb.CreateVector<uint8_t>(*SIGNATURE) : 0;
  return CreateSTF(
      _fbb,
      LISTING_ID__,
      PROVIDER_PEER_ID__,
      PROVIDER_EPM_CID__,
      TITLE__,
      DESCRIPTION__,
      DATA_TYPES__,
      COVERAGE,
      SAMPLE_CID__,
      ACCESS_TYPE,
      ENCRYPTION_REQUIRED,
      PRICING__,
      ACCEPTED_PAYMENTS__,
      CREATED_AT,
      UPDATED_AT,
      ACTIVE,
      SIGNATURE__);
}

inline const STF *GetSTF(const void *buf) {
  return ::flatbuffers::GetRoot<STF>(buf);
}

inline const STF *GetSizePrefixedSTF(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<STF>(buf);
}

inline const char *STFIdentifier() {
  return "$STF";
}

inline bool STFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, STFIdentifier());
}

inline bool SizePrefixedSTFBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, STFIdentifier(), true);
}

inline bool VerifySTFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<STF>(STFIdentifier());
}

inline bool VerifySizePrefixedSTFBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<STF>(STFIdentifier());
}

inline void FinishSTFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<STF> root) {
  fbb.Finish(root, STFIdentifier());
}

inline void FinishSizePrefixedSTFBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<STF> root) {
  fbb.FinishSizePrefixed(root, STFIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
