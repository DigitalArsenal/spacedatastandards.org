// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct KMLCoordinate;
struct KMLCoordinateBuilder;

struct KMLLookAt;
struct KMLLookAtBuilder;

struct KMLCamera;
struct KMLCameraBuilder;

struct KMLIconStyle;
struct KMLIconStyleBuilder;

struct KMLLineStyle;
struct KMLLineStyleBuilder;

struct KMLPolyStyle;
struct KMLPolyStyleBuilder;

struct KMLLabelStyle;
struct KMLLabelStyleBuilder;

struct KMLBalloonStyle;
struct KMLBalloonStyleBuilder;

struct KMLStyle;
struct KMLStyleBuilder;

struct KMLStyleMapPair;
struct KMLStyleMapPairBuilder;

struct KMLStyleMap;
struct KMLStyleMapBuilder;

struct KMLPoint;
struct KMLPointBuilder;

struct KMLLineString;
struct KMLLineStringBuilder;

struct KMLLinearRing;
struct KMLLinearRingBuilder;

struct KMLPolygon;
struct KMLPolygonBuilder;

struct KMLMultiGeometry;
struct KMLMultiGeometryBuilder;

struct KMLTimeSpan;
struct KMLTimeSpanBuilder;

struct KMLTimeStamp;
struct KMLTimeStampBuilder;

struct KMLData;
struct KMLDataBuilder;

struct KMLNetworkLink;
struct KMLNetworkLinkBuilder;

struct KMLGroundOverlay;
struct KMLGroundOverlayBuilder;

struct KMLPlacemark;
struct KMLPlacemarkBuilder;

struct KMLFolder;
struct KMLFolderBuilder;

struct KML;
struct KMLBuilder;

enum KMLAltitudeMode : int8_t {
  /// Altitude relative to ground surface
  KMLAltitudeMode_CLAMP_TO_GROUND = 0,
  /// Altitude relative to ground elevation
  KMLAltitudeMode_RELATIVE_TO_GROUND = 1,
  /// Altitude as absolute meters above WGS84 ellipsoid
  KMLAltitudeMode_ABSOLUTE = 2,
  /// Clamp to sea floor
  KMLAltitudeMode_CLAMP_TO_SEA_FLOOR = 3,
  /// Relative to sea floor
  KMLAltitudeMode_RELATIVE_TO_SEA_FLOOR = 4,
  KMLAltitudeMode_MIN = KMLAltitudeMode_CLAMP_TO_GROUND,
  KMLAltitudeMode_MAX = KMLAltitudeMode_RELATIVE_TO_SEA_FLOOR
};

inline const KMLAltitudeMode (&EnumValuesKMLAltitudeMode())[5] {
  static const KMLAltitudeMode values[] = {
    KMLAltitudeMode_CLAMP_TO_GROUND,
    KMLAltitudeMode_RELATIVE_TO_GROUND,
    KMLAltitudeMode_ABSOLUTE,
    KMLAltitudeMode_CLAMP_TO_SEA_FLOOR,
    KMLAltitudeMode_RELATIVE_TO_SEA_FLOOR
  };
  return values;
}

inline const char * const *EnumNamesKMLAltitudeMode() {
  static const char * const names[6] = {
    "CLAMP_TO_GROUND",
    "RELATIVE_TO_GROUND",
    "ABSOLUTE",
    "CLAMP_TO_SEA_FLOOR",
    "RELATIVE_TO_SEA_FLOOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLAltitudeMode(KMLAltitudeMode e) {
  if (::flatbuffers::IsOutRange(e, KMLAltitudeMode_CLAMP_TO_GROUND, KMLAltitudeMode_RELATIVE_TO_SEA_FLOOR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLAltitudeMode()[index];
}

enum KMLColorMode : int8_t {
  KMLColorMode_NORMAL = 0,
  KMLColorMode_RANDOM = 1,
  KMLColorMode_MIN = KMLColorMode_NORMAL,
  KMLColorMode_MAX = KMLColorMode_RANDOM
};

inline const KMLColorMode (&EnumValuesKMLColorMode())[2] {
  static const KMLColorMode values[] = {
    KMLColorMode_NORMAL,
    KMLColorMode_RANDOM
  };
  return values;
}

inline const char * const *EnumNamesKMLColorMode() {
  static const char * const names[3] = {
    "NORMAL",
    "RANDOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLColorMode(KMLColorMode e) {
  if (::flatbuffers::IsOutRange(e, KMLColorMode_NORMAL, KMLColorMode_RANDOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLColorMode()[index];
}

enum KMLStyleState : int8_t {
  KMLStyleState_NORMAL = 0,
  KMLStyleState_HIGHLIGHT = 1,
  KMLStyleState_MIN = KMLStyleState_NORMAL,
  KMLStyleState_MAX = KMLStyleState_HIGHLIGHT
};

inline const KMLStyleState (&EnumValuesKMLStyleState())[2] {
  static const KMLStyleState values[] = {
    KMLStyleState_NORMAL,
    KMLStyleState_HIGHLIGHT
  };
  return values;
}

inline const char * const *EnumNamesKMLStyleState() {
  static const char * const names[3] = {
    "NORMAL",
    "HIGHLIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLStyleState(KMLStyleState e) {
  if (::flatbuffers::IsOutRange(e, KMLStyleState_NORMAL, KMLStyleState_HIGHLIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLStyleState()[index];
}

enum KMLUnits : int8_t {
  KMLUnits_PIXELS = 0,
  KMLUnits_FRACTION = 1,
  KMLUnits_INSET_PIXELS = 2,
  KMLUnits_MIN = KMLUnits_PIXELS,
  KMLUnits_MAX = KMLUnits_INSET_PIXELS
};

inline const KMLUnits (&EnumValuesKMLUnits())[3] {
  static const KMLUnits values[] = {
    KMLUnits_PIXELS,
    KMLUnits_FRACTION,
    KMLUnits_INSET_PIXELS
  };
  return values;
}

inline const char * const *EnumNamesKMLUnits() {
  static const char * const names[4] = {
    "PIXELS",
    "FRACTION",
    "INSET_PIXELS",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLUnits(KMLUnits e) {
  if (::flatbuffers::IsOutRange(e, KMLUnits_PIXELS, KMLUnits_INSET_PIXELS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLUnits()[index];
}

enum KMLRefreshMode : int8_t {
  KMLRefreshMode_ON_CHANGE = 0,
  KMLRefreshMode_ON_INTERVAL = 1,
  KMLRefreshMode_ON_EXPIRE = 2,
  KMLRefreshMode_MIN = KMLRefreshMode_ON_CHANGE,
  KMLRefreshMode_MAX = KMLRefreshMode_ON_EXPIRE
};

inline const KMLRefreshMode (&EnumValuesKMLRefreshMode())[3] {
  static const KMLRefreshMode values[] = {
    KMLRefreshMode_ON_CHANGE,
    KMLRefreshMode_ON_INTERVAL,
    KMLRefreshMode_ON_EXPIRE
  };
  return values;
}

inline const char * const *EnumNamesKMLRefreshMode() {
  static const char * const names[4] = {
    "ON_CHANGE",
    "ON_INTERVAL",
    "ON_EXPIRE",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLRefreshMode(KMLRefreshMode e) {
  if (::flatbuffers::IsOutRange(e, KMLRefreshMode_ON_CHANGE, KMLRefreshMode_ON_EXPIRE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLRefreshMode()[index];
}

enum KMLViewRefreshMode : int8_t {
  KMLViewRefreshMode_NEVER = 0,
  KMLViewRefreshMode_ON_STOP = 1,
  KMLViewRefreshMode_ON_REQUEST = 2,
  KMLViewRefreshMode_ON_REGION = 3,
  KMLViewRefreshMode_MIN = KMLViewRefreshMode_NEVER,
  KMLViewRefreshMode_MAX = KMLViewRefreshMode_ON_REGION
};

inline const KMLViewRefreshMode (&EnumValuesKMLViewRefreshMode())[4] {
  static const KMLViewRefreshMode values[] = {
    KMLViewRefreshMode_NEVER,
    KMLViewRefreshMode_ON_STOP,
    KMLViewRefreshMode_ON_REQUEST,
    KMLViewRefreshMode_ON_REGION
  };
  return values;
}

inline const char * const *EnumNamesKMLViewRefreshMode() {
  static const char * const names[5] = {
    "NEVER",
    "ON_STOP",
    "ON_REQUEST",
    "ON_REGION",
    nullptr
  };
  return names;
}

inline const char *EnumNameKMLViewRefreshMode(KMLViewRefreshMode e) {
  if (::flatbuffers::IsOutRange(e, KMLViewRefreshMode_NEVER, KMLViewRefreshMode_ON_REGION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKMLViewRefreshMode()[index];
}

/// KML coordinate (longitude, latitude, optional altitude)
struct KMLCoordinate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLCoordinateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  /// Longitude in decimal degrees
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Latitude in decimal degrees
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Altitude in meters
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           verifier.EndTable();
  }
};

struct KMLCoordinateBuilder {
  typedef KMLCoordinate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(KMLCoordinate::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(KMLCoordinate::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(KMLCoordinate::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  explicit KMLCoordinateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLCoordinate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLCoordinate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLCoordinate> CreateKMLCoordinate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LONGITUDE = 0.0,
    double LATITUDE = 0.0,
    double ALTITUDE = 0.0) {
  KMLCoordinateBuilder builder_(_fbb);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  return builder_.Finish();
}

/// LookAt viewpoint
struct KMLLookAt FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLLookAtBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8,
    VT_HEADING = 10,
    VT_TILT = 12,
    VT_RANGE = 14,
    VT_ALTITUDE_MODE = 16
  };
  /// Longitude of the point being looked at
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Latitude of the point being looked at
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Altitude of the point being looked at
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  /// Heading in degrees (0=North)
  double HEADING() const {
    return GetField<double>(VT_HEADING, 0.0);
  }
  /// Tilt in degrees from vertical (0=straight down)
  double TILT() const {
    return GetField<double>(VT_TILT, 0.0);
  }
  /// Range in meters from the point
  double RANGE() const {
    return GetField<double>(VT_RANGE, 0.0);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyField<double>(verifier, VT_HEADING, 8) &&
           VerifyField<double>(verifier, VT_TILT, 8) &&
           VerifyField<double>(verifier, VT_RANGE, 8) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           verifier.EndTable();
  }
};

struct KMLLookAtBuilder {
  typedef KMLLookAt Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(KMLLookAt::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(KMLLookAt::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(KMLLookAt::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  void add_HEADING(double HEADING) {
    fbb_.AddElement<double>(KMLLookAt::VT_HEADING, HEADING, 0.0);
  }
  void add_TILT(double TILT) {
    fbb_.AddElement<double>(KMLLookAt::VT_TILT, TILT, 0.0);
  }
  void add_RANGE(double RANGE) {
    fbb_.AddElement<double>(KMLLookAt::VT_RANGE, RANGE, 0.0);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLLookAt::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  explicit KMLLookAtBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLLookAt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLLookAt>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLLookAt> CreateKMLLookAt(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LONGITUDE = 0.0,
    double LATITUDE = 0.0,
    double ALTITUDE = 0.0,
    double HEADING = 0.0,
    double TILT = 0.0,
    double RANGE = 0.0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND) {
  KMLLookAtBuilder builder_(_fbb);
  builder_.add_RANGE(RANGE);
  builder_.add_TILT(TILT);
  builder_.add_HEADING(HEADING);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  return builder_.Finish();
}

/// Camera viewpoint
struct KMLCamera FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLCameraBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8,
    VT_HEADING = 10,
    VT_TILT = 12,
    VT_ROLL = 14,
    VT_ALTITUDE_MODE = 16
  };
  /// Camera longitude
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Camera latitude
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Camera altitude
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  /// Heading in degrees (0=North)
  double HEADING() const {
    return GetField<double>(VT_HEADING, 0.0);
  }
  /// Tilt in degrees from vertical
  double TILT() const {
    return GetField<double>(VT_TILT, 0.0);
  }
  /// Roll in degrees
  double ROLL() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyField<double>(verifier, VT_HEADING, 8) &&
           VerifyField<double>(verifier, VT_TILT, 8) &&
           VerifyField<double>(verifier, VT_ROLL, 8) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           verifier.EndTable();
  }
};

struct KMLCameraBuilder {
  typedef KMLCamera Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(KMLCamera::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(KMLCamera::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(KMLCamera::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  void add_HEADING(double HEADING) {
    fbb_.AddElement<double>(KMLCamera::VT_HEADING, HEADING, 0.0);
  }
  void add_TILT(double TILT) {
    fbb_.AddElement<double>(KMLCamera::VT_TILT, TILT, 0.0);
  }
  void add_ROLL(double ROLL) {
    fbb_.AddElement<double>(KMLCamera::VT_ROLL, ROLL, 0.0);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLCamera::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  explicit KMLCameraBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLCamera> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLCamera>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLCamera> CreateKMLCamera(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LONGITUDE = 0.0,
    double LATITUDE = 0.0,
    double ALTITUDE = 0.0,
    double HEADING = 0.0,
    double TILT = 0.0,
    double ROLL = 0.0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND) {
  KMLCameraBuilder builder_(_fbb);
  builder_.add_ROLL(ROLL);
  builder_.add_TILT(TILT);
  builder_.add_HEADING(HEADING);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  return builder_.Finish();
}

/// Icon style
struct KMLIconStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLIconStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_COLOR_MODE = 6,
    VT_SCALE = 8,
    VT_HEADING = 10,
    VT_ICON_HREF = 12,
    VT_HOTSPOT_X = 14,
    VT_HOTSPOT_Y = 16,
    VT_HOTSPOT_X_UNITS = 18,
    VT_HOTSPOT_Y_UNITS = 20
  };
  /// KML color in aabbggrr hex format
  const ::flatbuffers::String *COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  /// Color mode
  KMLColorMode COLOR_MODE() const {
    return static_cast<KMLColorMode>(GetField<int8_t>(VT_COLOR_MODE, 0));
  }
  /// Scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  /// Heading in degrees
  double HEADING() const {
    return GetField<double>(VT_HEADING, 0.0);
  }
  /// Icon href (URL)
  const ::flatbuffers::String *ICON_HREF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICON_HREF);
  }
  /// Hot spot X value
  double HOTSPOT_X() const {
    return GetField<double>(VT_HOTSPOT_X, 0.0);
  }
  /// Hot spot Y value
  double HOTSPOT_Y() const {
    return GetField<double>(VT_HOTSPOT_Y, 0.0);
  }
  /// Hot spot X units
  KMLUnits HOTSPOT_X_UNITS() const {
    return static_cast<KMLUnits>(GetField<int8_t>(VT_HOTSPOT_X_UNITS, 0));
  }
  /// Hot spot Y units
  KMLUnits HOTSPOT_Y_UNITS() const {
    return static_cast<KMLUnits>(GetField<int8_t>(VT_HOTSPOT_Y_UNITS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(COLOR()) &&
           VerifyField<int8_t>(verifier, VT_COLOR_MODE, 1) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<double>(verifier, VT_HEADING, 8) &&
           VerifyOffset(verifier, VT_ICON_HREF) &&
           verifier.VerifyString(ICON_HREF()) &&
           VerifyField<double>(verifier, VT_HOTSPOT_X, 8) &&
           VerifyField<double>(verifier, VT_HOTSPOT_Y, 8) &&
           VerifyField<int8_t>(verifier, VT_HOTSPOT_X_UNITS, 1) &&
           VerifyField<int8_t>(verifier, VT_HOTSPOT_Y_UNITS, 1) &&
           verifier.EndTable();
  }
};

struct KMLIconStyleBuilder {
  typedef KMLIconStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COLOR(::flatbuffers::Offset<::flatbuffers::String> COLOR) {
    fbb_.AddOffset(KMLIconStyle::VT_COLOR, COLOR);
  }
  void add_COLOR_MODE(KMLColorMode COLOR_MODE) {
    fbb_.AddElement<int8_t>(KMLIconStyle::VT_COLOR_MODE, static_cast<int8_t>(COLOR_MODE), 0);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(KMLIconStyle::VT_SCALE, SCALE, 0.0);
  }
  void add_HEADING(double HEADING) {
    fbb_.AddElement<double>(KMLIconStyle::VT_HEADING, HEADING, 0.0);
  }
  void add_ICON_HREF(::flatbuffers::Offset<::flatbuffers::String> ICON_HREF) {
    fbb_.AddOffset(KMLIconStyle::VT_ICON_HREF, ICON_HREF);
  }
  void add_HOTSPOT_X(double HOTSPOT_X) {
    fbb_.AddElement<double>(KMLIconStyle::VT_HOTSPOT_X, HOTSPOT_X, 0.0);
  }
  void add_HOTSPOT_Y(double HOTSPOT_Y) {
    fbb_.AddElement<double>(KMLIconStyle::VT_HOTSPOT_Y, HOTSPOT_Y, 0.0);
  }
  void add_HOTSPOT_X_UNITS(KMLUnits HOTSPOT_X_UNITS) {
    fbb_.AddElement<int8_t>(KMLIconStyle::VT_HOTSPOT_X_UNITS, static_cast<int8_t>(HOTSPOT_X_UNITS), 0);
  }
  void add_HOTSPOT_Y_UNITS(KMLUnits HOTSPOT_Y_UNITS) {
    fbb_.AddElement<int8_t>(KMLIconStyle::VT_HOTSPOT_Y_UNITS, static_cast<int8_t>(HOTSPOT_Y_UNITS), 0);
  }
  explicit KMLIconStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLIconStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLIconStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLIconStyle> CreateKMLIconStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COLOR = 0,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double SCALE = 0.0,
    double HEADING = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> ICON_HREF = 0,
    double HOTSPOT_X = 0.0,
    double HOTSPOT_Y = 0.0,
    KMLUnits HOTSPOT_X_UNITS = KMLUnits_PIXELS,
    KMLUnits HOTSPOT_Y_UNITS = KMLUnits_PIXELS) {
  KMLIconStyleBuilder builder_(_fbb);
  builder_.add_HOTSPOT_Y(HOTSPOT_Y);
  builder_.add_HOTSPOT_X(HOTSPOT_X);
  builder_.add_HEADING(HEADING);
  builder_.add_SCALE(SCALE);
  builder_.add_ICON_HREF(ICON_HREF);
  builder_.add_COLOR(COLOR);
  builder_.add_HOTSPOT_Y_UNITS(HOTSPOT_Y_UNITS);
  builder_.add_HOTSPOT_X_UNITS(HOTSPOT_X_UNITS);
  builder_.add_COLOR_MODE(COLOR_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLIconStyle> CreateKMLIconStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COLOR = nullptr,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double SCALE = 0.0,
    double HEADING = 0.0,
    const char *ICON_HREF = nullptr,
    double HOTSPOT_X = 0.0,
    double HOTSPOT_Y = 0.0,
    KMLUnits HOTSPOT_X_UNITS = KMLUnits_PIXELS,
    KMLUnits HOTSPOT_Y_UNITS = KMLUnits_PIXELS) {
  auto COLOR__ = COLOR ? _fbb.CreateString(COLOR) : 0;
  auto ICON_HREF__ = ICON_HREF ? _fbb.CreateString(ICON_HREF) : 0;
  return CreateKMLIconStyle(
      _fbb,
      COLOR__,
      COLOR_MODE,
      SCALE,
      HEADING,
      ICON_HREF__,
      HOTSPOT_X,
      HOTSPOT_Y,
      HOTSPOT_X_UNITS,
      HOTSPOT_Y_UNITS);
}

/// Line style
struct KMLLineStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLLineStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_COLOR_MODE = 6,
    VT_WIDTH = 8
  };
  /// KML color in aabbggrr hex format
  const ::flatbuffers::String *COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  /// Color mode
  KMLColorMode COLOR_MODE() const {
    return static_cast<KMLColorMode>(GetField<int8_t>(VT_COLOR_MODE, 0));
  }
  /// Width in pixels
  double WIDTH() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(COLOR()) &&
           VerifyField<int8_t>(verifier, VT_COLOR_MODE, 1) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           verifier.EndTable();
  }
};

struct KMLLineStyleBuilder {
  typedef KMLLineStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COLOR(::flatbuffers::Offset<::flatbuffers::String> COLOR) {
    fbb_.AddOffset(KMLLineStyle::VT_COLOR, COLOR);
  }
  void add_COLOR_MODE(KMLColorMode COLOR_MODE) {
    fbb_.AddElement<int8_t>(KMLLineStyle::VT_COLOR_MODE, static_cast<int8_t>(COLOR_MODE), 0);
  }
  void add_WIDTH(double WIDTH) {
    fbb_.AddElement<double>(KMLLineStyle::VT_WIDTH, WIDTH, 0.0);
  }
  explicit KMLLineStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLLineStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLLineStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLLineStyle> CreateKMLLineStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COLOR = 0,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double WIDTH = 0.0) {
  KMLLineStyleBuilder builder_(_fbb);
  builder_.add_WIDTH(WIDTH);
  builder_.add_COLOR(COLOR);
  builder_.add_COLOR_MODE(COLOR_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLLineStyle> CreateKMLLineStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COLOR = nullptr,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double WIDTH = 0.0) {
  auto COLOR__ = COLOR ? _fbb.CreateString(COLOR) : 0;
  return CreateKMLLineStyle(
      _fbb,
      COLOR__,
      COLOR_MODE,
      WIDTH);
}

/// Polygon style
struct KMLPolyStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLPolyStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_COLOR_MODE = 6,
    VT_FILL = 8,
    VT_OUTLINE = 10
  };
  /// KML color in aabbggrr hex format
  const ::flatbuffers::String *COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  /// Color mode
  KMLColorMode COLOR_MODE() const {
    return static_cast<KMLColorMode>(GetField<int8_t>(VT_COLOR_MODE, 0));
  }
  /// Whether to fill
  bool FILL() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  /// Whether to outline
  bool OUTLINE() const {
    return GetField<uint8_t>(VT_OUTLINE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(COLOR()) &&
           VerifyField<int8_t>(verifier, VT_COLOR_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTLINE, 1) &&
           verifier.EndTable();
  }
};

struct KMLPolyStyleBuilder {
  typedef KMLPolyStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COLOR(::flatbuffers::Offset<::flatbuffers::String> COLOR) {
    fbb_.AddOffset(KMLPolyStyle::VT_COLOR, COLOR);
  }
  void add_COLOR_MODE(KMLColorMode COLOR_MODE) {
    fbb_.AddElement<int8_t>(KMLPolyStyle::VT_COLOR_MODE, static_cast<int8_t>(COLOR_MODE), 0);
  }
  void add_FILL(bool FILL) {
    fbb_.AddElement<uint8_t>(KMLPolyStyle::VT_FILL, static_cast<uint8_t>(FILL), 0);
  }
  void add_OUTLINE(bool OUTLINE) {
    fbb_.AddElement<uint8_t>(KMLPolyStyle::VT_OUTLINE, static_cast<uint8_t>(OUTLINE), 0);
  }
  explicit KMLPolyStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLPolyStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLPolyStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLPolyStyle> CreateKMLPolyStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COLOR = 0,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    bool FILL = false,
    bool OUTLINE = false) {
  KMLPolyStyleBuilder builder_(_fbb);
  builder_.add_COLOR(COLOR);
  builder_.add_OUTLINE(OUTLINE);
  builder_.add_FILL(FILL);
  builder_.add_COLOR_MODE(COLOR_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLPolyStyle> CreateKMLPolyStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COLOR = nullptr,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    bool FILL = false,
    bool OUTLINE = false) {
  auto COLOR__ = COLOR ? _fbb.CreateString(COLOR) : 0;
  return CreateKMLPolyStyle(
      _fbb,
      COLOR__,
      COLOR_MODE,
      FILL,
      OUTLINE);
}

/// Label style
struct KMLLabelStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLLabelStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_COLOR_MODE = 6,
    VT_SCALE = 8
  };
  /// KML color in aabbggrr hex format
  const ::flatbuffers::String *COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  /// Color mode
  KMLColorMode COLOR_MODE() const {
    return static_cast<KMLColorMode>(GetField<int8_t>(VT_COLOR_MODE, 0));
  }
  /// Scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(COLOR()) &&
           VerifyField<int8_t>(verifier, VT_COLOR_MODE, 1) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           verifier.EndTable();
  }
};

struct KMLLabelStyleBuilder {
  typedef KMLLabelStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COLOR(::flatbuffers::Offset<::flatbuffers::String> COLOR) {
    fbb_.AddOffset(KMLLabelStyle::VT_COLOR, COLOR);
  }
  void add_COLOR_MODE(KMLColorMode COLOR_MODE) {
    fbb_.AddElement<int8_t>(KMLLabelStyle::VT_COLOR_MODE, static_cast<int8_t>(COLOR_MODE), 0);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(KMLLabelStyle::VT_SCALE, SCALE, 0.0);
  }
  explicit KMLLabelStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLLabelStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLLabelStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLLabelStyle> CreateKMLLabelStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COLOR = 0,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double SCALE = 0.0) {
  KMLLabelStyleBuilder builder_(_fbb);
  builder_.add_SCALE(SCALE);
  builder_.add_COLOR(COLOR);
  builder_.add_COLOR_MODE(COLOR_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLLabelStyle> CreateKMLLabelStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COLOR = nullptr,
    KMLColorMode COLOR_MODE = KMLColorMode_NORMAL,
    double SCALE = 0.0) {
  auto COLOR__ = COLOR ? _fbb.CreateString(COLOR) : 0;
  return CreateKMLLabelStyle(
      _fbb,
      COLOR__,
      COLOR_MODE,
      SCALE);
}

/// Balloon style
struct KMLBalloonStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLBalloonStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BG_COLOR = 4,
    VT_TEXT_COLOR = 6,
    VT_TEXT = 8
  };
  /// Background color in aabbggrr hex format
  const ::flatbuffers::String *BG_COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BG_COLOR);
  }
  /// Text color in aabbggrr hex format
  const ::flatbuffers::String *TEXT_COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT_COLOR);
  }
  /// Balloon text template (supports $[name], $[description])
  const ::flatbuffers::String *TEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BG_COLOR) &&
           verifier.VerifyString(BG_COLOR()) &&
           VerifyOffset(verifier, VT_TEXT_COLOR) &&
           verifier.VerifyString(TEXT_COLOR()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(TEXT()) &&
           verifier.EndTable();
  }
};

struct KMLBalloonStyleBuilder {
  typedef KMLBalloonStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_BG_COLOR(::flatbuffers::Offset<::flatbuffers::String> BG_COLOR) {
    fbb_.AddOffset(KMLBalloonStyle::VT_BG_COLOR, BG_COLOR);
  }
  void add_TEXT_COLOR(::flatbuffers::Offset<::flatbuffers::String> TEXT_COLOR) {
    fbb_.AddOffset(KMLBalloonStyle::VT_TEXT_COLOR, TEXT_COLOR);
  }
  void add_TEXT(::flatbuffers::Offset<::flatbuffers::String> TEXT) {
    fbb_.AddOffset(KMLBalloonStyle::VT_TEXT, TEXT);
  }
  explicit KMLBalloonStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLBalloonStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLBalloonStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLBalloonStyle> CreateKMLBalloonStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> BG_COLOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TEXT_COLOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TEXT = 0) {
  KMLBalloonStyleBuilder builder_(_fbb);
  builder_.add_TEXT(TEXT);
  builder_.add_TEXT_COLOR(TEXT_COLOR);
  builder_.add_BG_COLOR(BG_COLOR);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLBalloonStyle> CreateKMLBalloonStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *BG_COLOR = nullptr,
    const char *TEXT_COLOR = nullptr,
    const char *TEXT = nullptr) {
  auto BG_COLOR__ = BG_COLOR ? _fbb.CreateString(BG_COLOR) : 0;
  auto TEXT_COLOR__ = TEXT_COLOR ? _fbb.CreateString(TEXT_COLOR) : 0;
  auto TEXT__ = TEXT ? _fbb.CreateString(TEXT) : 0;
  return CreateKMLBalloonStyle(
      _fbb,
      BG_COLOR__,
      TEXT_COLOR__,
      TEXT__);
}

/// Style definition
struct KMLStyle FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_ICON_STYLE = 6,
    VT_LABEL_STYLE = 8,
    VT_LINE_STYLE = 10,
    VT_POLY_STYLE = 12,
    VT_BALLOON_STYLE = 14
  };
  /// Style identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Icon style
  const KMLIconStyle *ICON_STYLE() const {
    return GetPointer<const KMLIconStyle *>(VT_ICON_STYLE);
  }
  /// Label style
  const KMLLabelStyle *LABEL_STYLE() const {
    return GetPointer<const KMLLabelStyle *>(VT_LABEL_STYLE);
  }
  /// Line style
  const KMLLineStyle *LINE_STYLE() const {
    return GetPointer<const KMLLineStyle *>(VT_LINE_STYLE);
  }
  /// Polygon style
  const KMLPolyStyle *POLY_STYLE() const {
    return GetPointer<const KMLPolyStyle *>(VT_POLY_STYLE);
  }
  /// Balloon style
  const KMLBalloonStyle *BALLOON_STYLE() const {
    return GetPointer<const KMLBalloonStyle *>(VT_BALLOON_STYLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_ICON_STYLE) &&
           verifier.VerifyTable(ICON_STYLE()) &&
           VerifyOffset(verifier, VT_LABEL_STYLE) &&
           verifier.VerifyTable(LABEL_STYLE()) &&
           VerifyOffset(verifier, VT_LINE_STYLE) &&
           verifier.VerifyTable(LINE_STYLE()) &&
           VerifyOffset(verifier, VT_POLY_STYLE) &&
           verifier.VerifyTable(POLY_STYLE()) &&
           VerifyOffset(verifier, VT_BALLOON_STYLE) &&
           verifier.VerifyTable(BALLOON_STYLE()) &&
           verifier.EndTable();
  }
};

struct KMLStyleBuilder {
  typedef KMLStyle Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(KMLStyle::VT_ID, ID);
  }
  void add_ICON_STYLE(::flatbuffers::Offset<KMLIconStyle> ICON_STYLE) {
    fbb_.AddOffset(KMLStyle::VT_ICON_STYLE, ICON_STYLE);
  }
  void add_LABEL_STYLE(::flatbuffers::Offset<KMLLabelStyle> LABEL_STYLE) {
    fbb_.AddOffset(KMLStyle::VT_LABEL_STYLE, LABEL_STYLE);
  }
  void add_LINE_STYLE(::flatbuffers::Offset<KMLLineStyle> LINE_STYLE) {
    fbb_.AddOffset(KMLStyle::VT_LINE_STYLE, LINE_STYLE);
  }
  void add_POLY_STYLE(::flatbuffers::Offset<KMLPolyStyle> POLY_STYLE) {
    fbb_.AddOffset(KMLStyle::VT_POLY_STYLE, POLY_STYLE);
  }
  void add_BALLOON_STYLE(::flatbuffers::Offset<KMLBalloonStyle> BALLOON_STYLE) {
    fbb_.AddOffset(KMLStyle::VT_BALLOON_STYLE, BALLOON_STYLE);
  }
  explicit KMLStyleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLStyle>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLStyle> CreateKMLStyle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<KMLIconStyle> ICON_STYLE = 0,
    ::flatbuffers::Offset<KMLLabelStyle> LABEL_STYLE = 0,
    ::flatbuffers::Offset<KMLLineStyle> LINE_STYLE = 0,
    ::flatbuffers::Offset<KMLPolyStyle> POLY_STYLE = 0,
    ::flatbuffers::Offset<KMLBalloonStyle> BALLOON_STYLE = 0) {
  KMLStyleBuilder builder_(_fbb);
  builder_.add_BALLOON_STYLE(BALLOON_STYLE);
  builder_.add_POLY_STYLE(POLY_STYLE);
  builder_.add_LINE_STYLE(LINE_STYLE);
  builder_.add_LABEL_STYLE(LABEL_STYLE);
  builder_.add_ICON_STYLE(ICON_STYLE);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLStyle> CreateKMLStyleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    ::flatbuffers::Offset<KMLIconStyle> ICON_STYLE = 0,
    ::flatbuffers::Offset<KMLLabelStyle> LABEL_STYLE = 0,
    ::flatbuffers::Offset<KMLLineStyle> LINE_STYLE = 0,
    ::flatbuffers::Offset<KMLPolyStyle> POLY_STYLE = 0,
    ::flatbuffers::Offset<KMLBalloonStyle> BALLOON_STYLE = 0) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  return CreateKMLStyle(
      _fbb,
      ID__,
      ICON_STYLE,
      LABEL_STYLE,
      LINE_STYLE,
      POLY_STYLE,
      BALLOON_STYLE);
}

/// Style map pair
struct KMLStyleMapPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLStyleMapPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4,
    VT_STYLE_URL = 6
  };
  /// State (normal or highlight)
  KMLStyleState STATE() const {
    return static_cast<KMLStyleState>(GetField<int8_t>(VT_STATE, 0));
  }
  /// Style URL or inline style ID
  const ::flatbuffers::String *STYLE_URL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STYLE_URL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyOffset(verifier, VT_STYLE_URL) &&
           verifier.VerifyString(STYLE_URL()) &&
           verifier.EndTable();
  }
};

struct KMLStyleMapPairBuilder {
  typedef KMLStyleMapPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_STATE(KMLStyleState STATE) {
    fbb_.AddElement<int8_t>(KMLStyleMapPair::VT_STATE, static_cast<int8_t>(STATE), 0);
  }
  void add_STYLE_URL(::flatbuffers::Offset<::flatbuffers::String> STYLE_URL) {
    fbb_.AddOffset(KMLStyleMapPair::VT_STYLE_URL, STYLE_URL);
  }
  explicit KMLStyleMapPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLStyleMapPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLStyleMapPair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLStyleMapPair> CreateKMLStyleMapPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    KMLStyleState STATE = KMLStyleState_NORMAL,
    ::flatbuffers::Offset<::flatbuffers::String> STYLE_URL = 0) {
  KMLStyleMapPairBuilder builder_(_fbb);
  builder_.add_STYLE_URL(STYLE_URL);
  builder_.add_STATE(STATE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLStyleMapPair> CreateKMLStyleMapPairDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    KMLStyleState STATE = KMLStyleState_NORMAL,
    const char *STYLE_URL = nullptr) {
  auto STYLE_URL__ = STYLE_URL ? _fbb.CreateString(STYLE_URL) : 0;
  return CreateKMLStyleMapPair(
      _fbb,
      STATE,
      STYLE_URL__);
}

/// Style map (normal/highlight pair)
struct KMLStyleMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLStyleMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PAIRS = 6
  };
  /// Style map identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Pairs
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMapPair>> *PAIRS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMapPair>> *>(VT_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_PAIRS) &&
           verifier.VerifyVector(PAIRS()) &&
           verifier.VerifyVectorOfTables(PAIRS()) &&
           verifier.EndTable();
  }
};

struct KMLStyleMapBuilder {
  typedef KMLStyleMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(KMLStyleMap::VT_ID, ID);
  }
  void add_PAIRS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMapPair>>> PAIRS) {
    fbb_.AddOffset(KMLStyleMap::VT_PAIRS, PAIRS);
  }
  explicit KMLStyleMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLStyleMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLStyleMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLStyleMap> CreateKMLStyleMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMapPair>>> PAIRS = 0) {
  KMLStyleMapBuilder builder_(_fbb);
  builder_.add_PAIRS(PAIRS);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLStyleMap> CreateKMLStyleMapDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const std::vector<::flatbuffers::Offset<KMLStyleMapPair>> *PAIRS = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto PAIRS__ = PAIRS ? _fbb.CreateVector<::flatbuffers::Offset<KMLStyleMapPair>>(*PAIRS) : 0;
  return CreateKMLStyleMap(
      _fbb,
      ID__,
      PAIRS__);
}

/// Point geometry
struct KMLPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDINATES = 4,
    VT_ALTITUDE_MODE = 6,
    VT_EXTRUDE = 8
  };
  /// Coordinate
  const KMLCoordinate *COORDINATES() const {
    return GetPointer<const KMLCoordinate *>(VT_COORDINATES);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  /// Whether to extrude to ground
  bool EXTRUDE() const {
    return GetField<uint8_t>(VT_EXTRUDE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDINATES) &&
           verifier.VerifyTable(COORDINATES()) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTRUDE, 1) &&
           verifier.EndTable();
  }
};

struct KMLPointBuilder {
  typedef KMLPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COORDINATES(::flatbuffers::Offset<KMLCoordinate> COORDINATES) {
    fbb_.AddOffset(KMLPoint::VT_COORDINATES, COORDINATES);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLPoint::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  void add_EXTRUDE(bool EXTRUDE) {
    fbb_.AddElement<uint8_t>(KMLPoint::VT_EXTRUDE, static_cast<uint8_t>(EXTRUDE), 0);
  }
  explicit KMLPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLPoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLPoint> CreateKMLPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<KMLCoordinate> COORDINATES = 0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND,
    bool EXTRUDE = false) {
  KMLPointBuilder builder_(_fbb);
  builder_.add_COORDINATES(COORDINATES);
  builder_.add_EXTRUDE(EXTRUDE);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  return builder_.Finish();
}

/// LineString geometry
struct KMLLineString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLLineStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDINATES = 4,
    VT_ALTITUDE_MODE = 6,
    VT_EXTRUDE = 8,
    VT_TESSELLATE = 10
  };
  /// Coordinates
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>> *COORDINATES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>> *>(VT_COORDINATES);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  /// Whether to extrude to ground
  bool EXTRUDE() const {
    return GetField<uint8_t>(VT_EXTRUDE, 0) != 0;
  }
  /// Whether to tessellate (follow terrain)
  bool TESSELLATE() const {
    return GetField<uint8_t>(VT_TESSELLATE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDINATES) &&
           verifier.VerifyVector(COORDINATES()) &&
           verifier.VerifyVectorOfTables(COORDINATES()) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTRUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TESSELLATE, 1) &&
           verifier.EndTable();
  }
};

struct KMLLineStringBuilder {
  typedef KMLLineString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COORDINATES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>>> COORDINATES) {
    fbb_.AddOffset(KMLLineString::VT_COORDINATES, COORDINATES);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLLineString::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  void add_EXTRUDE(bool EXTRUDE) {
    fbb_.AddElement<uint8_t>(KMLLineString::VT_EXTRUDE, static_cast<uint8_t>(EXTRUDE), 0);
  }
  void add_TESSELLATE(bool TESSELLATE) {
    fbb_.AddElement<uint8_t>(KMLLineString::VT_TESSELLATE, static_cast<uint8_t>(TESSELLATE), 0);
  }
  explicit KMLLineStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLLineString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLLineString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLLineString> CreateKMLLineString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>>> COORDINATES = 0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND,
    bool EXTRUDE = false,
    bool TESSELLATE = false) {
  KMLLineStringBuilder builder_(_fbb);
  builder_.add_COORDINATES(COORDINATES);
  builder_.add_TESSELLATE(TESSELLATE);
  builder_.add_EXTRUDE(EXTRUDE);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLLineString> CreateKMLLineStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<KMLCoordinate>> *COORDINATES = nullptr,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND,
    bool EXTRUDE = false,
    bool TESSELLATE = false) {
  auto COORDINATES__ = COORDINATES ? _fbb.CreateVector<::flatbuffers::Offset<KMLCoordinate>>(*COORDINATES) : 0;
  return CreateKMLLineString(
      _fbb,
      COORDINATES__,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE);
}

/// LinearRing geometry
struct KMLLinearRing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLLinearRingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDINATES = 4
  };
  /// Coordinates (first = last to close the ring)
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>> *COORDINATES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>> *>(VT_COORDINATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDINATES) &&
           verifier.VerifyVector(COORDINATES()) &&
           verifier.VerifyVectorOfTables(COORDINATES()) &&
           verifier.EndTable();
  }
};

struct KMLLinearRingBuilder {
  typedef KMLLinearRing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COORDINATES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>>> COORDINATES) {
    fbb_.AddOffset(KMLLinearRing::VT_COORDINATES, COORDINATES);
  }
  explicit KMLLinearRingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLLinearRing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLLinearRing>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLLinearRing> CreateKMLLinearRing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLCoordinate>>> COORDINATES = 0) {
  KMLLinearRingBuilder builder_(_fbb);
  builder_.add_COORDINATES(COORDINATES);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLLinearRing> CreateKMLLinearRingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<KMLCoordinate>> *COORDINATES = nullptr) {
  auto COORDINATES__ = COORDINATES ? _fbb.CreateVector<::flatbuffers::Offset<KMLCoordinate>>(*COORDINATES) : 0;
  return CreateKMLLinearRing(
      _fbb,
      COORDINATES__);
}

/// Polygon geometry
struct KMLPolygon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLPolygonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTER_BOUNDARY = 4,
    VT_INNER_BOUNDARIES = 6,
    VT_ALTITUDE_MODE = 8,
    VT_EXTRUDE = 10,
    VT_TESSELLATE = 12
  };
  /// Outer boundary
  const KMLLinearRing *OUTER_BOUNDARY() const {
    return GetPointer<const KMLLinearRing *>(VT_OUTER_BOUNDARY);
  }
  /// Inner boundaries (holes)
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLLinearRing>> *INNER_BOUNDARIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLLinearRing>> *>(VT_INNER_BOUNDARIES);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  /// Whether to extrude to ground
  bool EXTRUDE() const {
    return GetField<uint8_t>(VT_EXTRUDE, 0) != 0;
  }
  /// Whether to tessellate
  bool TESSELLATE() const {
    return GetField<uint8_t>(VT_TESSELLATE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTER_BOUNDARY) &&
           verifier.VerifyTable(OUTER_BOUNDARY()) &&
           VerifyOffset(verifier, VT_INNER_BOUNDARIES) &&
           verifier.VerifyVector(INNER_BOUNDARIES()) &&
           verifier.VerifyVectorOfTables(INNER_BOUNDARIES()) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_EXTRUDE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TESSELLATE, 1) &&
           verifier.EndTable();
  }
};

struct KMLPolygonBuilder {
  typedef KMLPolygon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OUTER_BOUNDARY(::flatbuffers::Offset<KMLLinearRing> OUTER_BOUNDARY) {
    fbb_.AddOffset(KMLPolygon::VT_OUTER_BOUNDARY, OUTER_BOUNDARY);
  }
  void add_INNER_BOUNDARIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLLinearRing>>> INNER_BOUNDARIES) {
    fbb_.AddOffset(KMLPolygon::VT_INNER_BOUNDARIES, INNER_BOUNDARIES);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLPolygon::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  void add_EXTRUDE(bool EXTRUDE) {
    fbb_.AddElement<uint8_t>(KMLPolygon::VT_EXTRUDE, static_cast<uint8_t>(EXTRUDE), 0);
  }
  void add_TESSELLATE(bool TESSELLATE) {
    fbb_.AddElement<uint8_t>(KMLPolygon::VT_TESSELLATE, static_cast<uint8_t>(TESSELLATE), 0);
  }
  explicit KMLPolygonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLPolygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLPolygon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLPolygon> CreateKMLPolygon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<KMLLinearRing> OUTER_BOUNDARY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLLinearRing>>> INNER_BOUNDARIES = 0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND,
    bool EXTRUDE = false,
    bool TESSELLATE = false) {
  KMLPolygonBuilder builder_(_fbb);
  builder_.add_INNER_BOUNDARIES(INNER_BOUNDARIES);
  builder_.add_OUTER_BOUNDARY(OUTER_BOUNDARY);
  builder_.add_TESSELLATE(TESSELLATE);
  builder_.add_EXTRUDE(EXTRUDE);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLPolygon> CreateKMLPolygonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<KMLLinearRing> OUTER_BOUNDARY = 0,
    const std::vector<::flatbuffers::Offset<KMLLinearRing>> *INNER_BOUNDARIES = nullptr,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND,
    bool EXTRUDE = false,
    bool TESSELLATE = false) {
  auto INNER_BOUNDARIES__ = INNER_BOUNDARIES ? _fbb.CreateVector<::flatbuffers::Offset<KMLLinearRing>>(*INNER_BOUNDARIES) : 0;
  return CreateKMLPolygon(
      _fbb,
      OUTER_BOUNDARY,
      INNER_BOUNDARIES__,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE);
}

/// MultiGeometry
struct KMLMultiGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLMultiGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4,
    VT_LINE_STRINGS = 6,
    VT_POLYGONS = 8,
    VT_MULTI_GEOMETRIES = 10
  };
  /// Child points
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPoint>> *POINTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPoint>> *>(VT_POINTS);
  }
  /// Child line strings
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLLineString>> *LINE_STRINGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLLineString>> *>(VT_LINE_STRINGS);
  }
  /// Child polygons
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPolygon>> *POLYGONS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPolygon>> *>(VT_POLYGONS);
  }
  /// Nested multi-geometries
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLMultiGeometry>> *MULTI_GEOMETRIES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLMultiGeometry>> *>(VT_MULTI_GEOMETRIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(POINTS()) &&
           verifier.VerifyVectorOfTables(POINTS()) &&
           VerifyOffset(verifier, VT_LINE_STRINGS) &&
           verifier.VerifyVector(LINE_STRINGS()) &&
           verifier.VerifyVectorOfTables(LINE_STRINGS()) &&
           VerifyOffset(verifier, VT_POLYGONS) &&
           verifier.VerifyVector(POLYGONS()) &&
           verifier.VerifyVectorOfTables(POLYGONS()) &&
           VerifyOffset(verifier, VT_MULTI_GEOMETRIES) &&
           verifier.VerifyVector(MULTI_GEOMETRIES()) &&
           verifier.VerifyVectorOfTables(MULTI_GEOMETRIES()) &&
           verifier.EndTable();
  }
};

struct KMLMultiGeometryBuilder {
  typedef KMLMultiGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POINTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPoint>>> POINTS) {
    fbb_.AddOffset(KMLMultiGeometry::VT_POINTS, POINTS);
  }
  void add_LINE_STRINGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLLineString>>> LINE_STRINGS) {
    fbb_.AddOffset(KMLMultiGeometry::VT_LINE_STRINGS, LINE_STRINGS);
  }
  void add_POLYGONS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPolygon>>> POLYGONS) {
    fbb_.AddOffset(KMLMultiGeometry::VT_POLYGONS, POLYGONS);
  }
  void add_MULTI_GEOMETRIES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLMultiGeometry>>> MULTI_GEOMETRIES) {
    fbb_.AddOffset(KMLMultiGeometry::VT_MULTI_GEOMETRIES, MULTI_GEOMETRIES);
  }
  explicit KMLMultiGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLMultiGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLMultiGeometry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLMultiGeometry> CreateKMLMultiGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPoint>>> POINTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLLineString>>> LINE_STRINGS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPolygon>>> POLYGONS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLMultiGeometry>>> MULTI_GEOMETRIES = 0) {
  KMLMultiGeometryBuilder builder_(_fbb);
  builder_.add_MULTI_GEOMETRIES(MULTI_GEOMETRIES);
  builder_.add_POLYGONS(POLYGONS);
  builder_.add_LINE_STRINGS(LINE_STRINGS);
  builder_.add_POINTS(POINTS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLMultiGeometry> CreateKMLMultiGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<KMLPoint>> *POINTS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLLineString>> *LINE_STRINGS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLPolygon>> *POLYGONS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLMultiGeometry>> *MULTI_GEOMETRIES = nullptr) {
  auto POINTS__ = POINTS ? _fbb.CreateVector<::flatbuffers::Offset<KMLPoint>>(*POINTS) : 0;
  auto LINE_STRINGS__ = LINE_STRINGS ? _fbb.CreateVector<::flatbuffers::Offset<KMLLineString>>(*LINE_STRINGS) : 0;
  auto POLYGONS__ = POLYGONS ? _fbb.CreateVector<::flatbuffers::Offset<KMLPolygon>>(*POLYGONS) : 0;
  auto MULTI_GEOMETRIES__ = MULTI_GEOMETRIES ? _fbb.CreateVector<::flatbuffers::Offset<KMLMultiGeometry>>(*MULTI_GEOMETRIES) : 0;
  return CreateKMLMultiGeometry(
      _fbb,
      POINTS__,
      LINE_STRINGS__,
      POLYGONS__,
      MULTI_GEOMETRIES__);
}

/// TimeSpan
struct KMLTimeSpan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLTimeSpanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN = 4,
    VT_END = 6
  };
  /// Begin time (ISO 8601)
  const ::flatbuffers::String *BEGIN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BEGIN);
  }
  /// End time (ISO 8601)
  const ::flatbuffers::String *END() const {
    return GetPointer<const ::flatbuffers::String *>(VT_END);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyString(BEGIN()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyString(END()) &&
           verifier.EndTable();
  }
};

struct KMLTimeSpanBuilder {
  typedef KMLTimeSpan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_BEGIN(::flatbuffers::Offset<::flatbuffers::String> BEGIN) {
    fbb_.AddOffset(KMLTimeSpan::VT_BEGIN, BEGIN);
  }
  void add_END(::flatbuffers::Offset<::flatbuffers::String> END) {
    fbb_.AddOffset(KMLTimeSpan::VT_END, END);
  }
  explicit KMLTimeSpanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLTimeSpan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLTimeSpan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLTimeSpan> CreateKMLTimeSpan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> BEGIN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> END = 0) {
  KMLTimeSpanBuilder builder_(_fbb);
  builder_.add_END(END);
  builder_.add_BEGIN(BEGIN);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLTimeSpan> CreateKMLTimeSpanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *BEGIN = nullptr,
    const char *END = nullptr) {
  auto BEGIN__ = BEGIN ? _fbb.CreateString(BEGIN) : 0;
  auto END__ = END ? _fbb.CreateString(END) : 0;
  return CreateKMLTimeSpan(
      _fbb,
      BEGIN__,
      END__);
}

/// TimeStamp
struct KMLTimeStamp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLTimeStampBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WHEN = 4
  };
  /// Time (ISO 8601)
  const ::flatbuffers::String *WHEN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WHEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WHEN) &&
           verifier.VerifyString(WHEN()) &&
           verifier.EndTable();
  }
};

struct KMLTimeStampBuilder {
  typedef KMLTimeStamp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_WHEN(::flatbuffers::Offset<::flatbuffers::String> WHEN) {
    fbb_.AddOffset(KMLTimeStamp::VT_WHEN, WHEN);
  }
  explicit KMLTimeStampBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLTimeStamp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLTimeStamp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLTimeStamp> CreateKMLTimeStamp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> WHEN = 0) {
  KMLTimeStampBuilder builder_(_fbb);
  builder_.add_WHEN(WHEN);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLTimeStamp> CreateKMLTimeStampDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *WHEN = nullptr) {
  auto WHEN__ = WHEN ? _fbb.CreateString(WHEN) : 0;
  return CreateKMLTimeStamp(
      _fbb,
      WHEN__);
}

/// Extended data key-value pair
struct KMLData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DISPLAY_NAME = 6,
    VT_VALUE = 8
  };
  /// Data name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Display name
  const ::flatbuffers::String *DISPLAY_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  /// Data value
  const ::flatbuffers::String *VALUE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(DISPLAY_NAME()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(VALUE()) &&
           verifier.EndTable();
  }
};

struct KMLDataBuilder {
  typedef KMLData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KMLData::VT_NAME, NAME);
  }
  void add_DISPLAY_NAME(::flatbuffers::Offset<::flatbuffers::String> DISPLAY_NAME) {
    fbb_.AddOffset(KMLData::VT_DISPLAY_NAME, DISPLAY_NAME);
  }
  void add_VALUE(::flatbuffers::Offset<::flatbuffers::String> VALUE) {
    fbb_.AddOffset(KMLData::VT_VALUE, VALUE);
  }
  explicit KMLDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLData> CreateKMLData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DISPLAY_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VALUE = 0) {
  KMLDataBuilder builder_(_fbb);
  builder_.add_VALUE(VALUE);
  builder_.add_DISPLAY_NAME(DISPLAY_NAME);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLData> CreateKMLDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DISPLAY_NAME = nullptr,
    const char *VALUE = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DISPLAY_NAME__ = DISPLAY_NAME ? _fbb.CreateString(DISPLAY_NAME) : 0;
  auto VALUE__ = VALUE ? _fbb.CreateString(VALUE) : 0;
  return CreateKMLData(
      _fbb,
      NAME__,
      DISPLAY_NAME__,
      VALUE__);
}

/// Network link
struct KMLNetworkLink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLNetworkLinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VISIBILITY = 6,
    VT_HREF = 8,
    VT_REFRESH_MODE = 10,
    VT_REFRESH_INTERVAL = 12,
    VT_VIEW_REFRESH_MODE = 14,
    VT_VIEW_REFRESH_TIME = 16
  };
  /// Name of the network link
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Whether the link is visible
  bool VISIBILITY() const {
    return GetField<uint8_t>(VT_VISIBILITY, 0) != 0;
  }
  /// Link URL
  const ::flatbuffers::String *HREF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HREF);
  }
  /// Refresh mode
  KMLRefreshMode REFRESH_MODE() const {
    return static_cast<KMLRefreshMode>(GetField<int8_t>(VT_REFRESH_MODE, 0));
  }
  /// Refresh interval in seconds
  double REFRESH_INTERVAL() const {
    return GetField<double>(VT_REFRESH_INTERVAL, 0.0);
  }
  /// View refresh mode
  KMLViewRefreshMode VIEW_REFRESH_MODE() const {
    return static_cast<KMLViewRefreshMode>(GetField<int8_t>(VT_VIEW_REFRESH_MODE, 0));
  }
  /// View refresh time in seconds
  double VIEW_REFRESH_TIME() const {
    return GetField<double>(VT_VIEW_REFRESH_TIME, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyOffset(verifier, VT_HREF) &&
           verifier.VerifyString(HREF()) &&
           VerifyField<int8_t>(verifier, VT_REFRESH_MODE, 1) &&
           VerifyField<double>(verifier, VT_REFRESH_INTERVAL, 8) &&
           VerifyField<int8_t>(verifier, VT_VIEW_REFRESH_MODE, 1) &&
           VerifyField<double>(verifier, VT_VIEW_REFRESH_TIME, 8) &&
           verifier.EndTable();
  }
};

struct KMLNetworkLinkBuilder {
  typedef KMLNetworkLink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KMLNetworkLink::VT_NAME, NAME);
  }
  void add_VISIBILITY(bool VISIBILITY) {
    fbb_.AddElement<uint8_t>(KMLNetworkLink::VT_VISIBILITY, static_cast<uint8_t>(VISIBILITY), 0);
  }
  void add_HREF(::flatbuffers::Offset<::flatbuffers::String> HREF) {
    fbb_.AddOffset(KMLNetworkLink::VT_HREF, HREF);
  }
  void add_REFRESH_MODE(KMLRefreshMode REFRESH_MODE) {
    fbb_.AddElement<int8_t>(KMLNetworkLink::VT_REFRESH_MODE, static_cast<int8_t>(REFRESH_MODE), 0);
  }
  void add_REFRESH_INTERVAL(double REFRESH_INTERVAL) {
    fbb_.AddElement<double>(KMLNetworkLink::VT_REFRESH_INTERVAL, REFRESH_INTERVAL, 0.0);
  }
  void add_VIEW_REFRESH_MODE(KMLViewRefreshMode VIEW_REFRESH_MODE) {
    fbb_.AddElement<int8_t>(KMLNetworkLink::VT_VIEW_REFRESH_MODE, static_cast<int8_t>(VIEW_REFRESH_MODE), 0);
  }
  void add_VIEW_REFRESH_TIME(double VIEW_REFRESH_TIME) {
    fbb_.AddElement<double>(KMLNetworkLink::VT_VIEW_REFRESH_TIME, VIEW_REFRESH_TIME, 0.0);
  }
  explicit KMLNetworkLinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLNetworkLink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLNetworkLink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLNetworkLink> CreateKMLNetworkLink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    bool VISIBILITY = false,
    ::flatbuffers::Offset<::flatbuffers::String> HREF = 0,
    KMLRefreshMode REFRESH_MODE = KMLRefreshMode_ON_CHANGE,
    double REFRESH_INTERVAL = 0.0,
    KMLViewRefreshMode VIEW_REFRESH_MODE = KMLViewRefreshMode_NEVER,
    double VIEW_REFRESH_TIME = 0.0) {
  KMLNetworkLinkBuilder builder_(_fbb);
  builder_.add_VIEW_REFRESH_TIME(VIEW_REFRESH_TIME);
  builder_.add_REFRESH_INTERVAL(REFRESH_INTERVAL);
  builder_.add_HREF(HREF);
  builder_.add_NAME(NAME);
  builder_.add_VIEW_REFRESH_MODE(VIEW_REFRESH_MODE);
  builder_.add_REFRESH_MODE(REFRESH_MODE);
  builder_.add_VISIBILITY(VISIBILITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLNetworkLink> CreateKMLNetworkLinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    bool VISIBILITY = false,
    const char *HREF = nullptr,
    KMLRefreshMode REFRESH_MODE = KMLRefreshMode_ON_CHANGE,
    double REFRESH_INTERVAL = 0.0,
    KMLViewRefreshMode VIEW_REFRESH_MODE = KMLViewRefreshMode_NEVER,
    double VIEW_REFRESH_TIME = 0.0) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto HREF__ = HREF ? _fbb.CreateString(HREF) : 0;
  return CreateKMLNetworkLink(
      _fbb,
      NAME__,
      VISIBILITY,
      HREF__,
      REFRESH_MODE,
      REFRESH_INTERVAL,
      VIEW_REFRESH_MODE,
      VIEW_REFRESH_TIME);
}

/// Ground overlay
struct KMLGroundOverlay FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLGroundOverlayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VISIBILITY = 8,
    VT_ICON_HREF = 10,
    VT_COLOR = 12,
    VT_NORTH = 14,
    VT_SOUTH = 16,
    VT_EAST = 18,
    VT_WEST = 20,
    VT_ROTATION = 22,
    VT_ALTITUDE = 24,
    VT_ALTITUDE_MODE = 26
  };
  /// Name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Visibility
  bool VISIBILITY() const {
    return GetField<uint8_t>(VT_VISIBILITY, 0) != 0;
  }
  /// Icon/image URL
  const ::flatbuffers::String *ICON_HREF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICON_HREF);
  }
  /// Color in aabbggrr hex format
  const ::flatbuffers::String *COLOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  /// North latitude of bounding box
  double NORTH() const {
    return GetField<double>(VT_NORTH, 0.0);
  }
  /// South latitude of bounding box
  double SOUTH() const {
    return GetField<double>(VT_SOUTH, 0.0);
  }
  /// East longitude of bounding box
  double EAST() const {
    return GetField<double>(VT_EAST, 0.0);
  }
  /// West longitude of bounding box
  double WEST() const {
    return GetField<double>(VT_WEST, 0.0);
  }
  /// Rotation in degrees
  double ROTATION() const {
    return GetField<double>(VT_ROTATION, 0.0);
  }
  /// Altitude in meters
  double ALTITUDE() const {
    return GetField<double>(VT_ALTITUDE, 0.0);
  }
  /// Altitude mode
  KMLAltitudeMode ALTITUDE_MODE() const {
    return static_cast<KMLAltitudeMode>(GetField<int8_t>(VT_ALTITUDE_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyOffset(verifier, VT_ICON_HREF) &&
           verifier.VerifyString(ICON_HREF()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(COLOR()) &&
           VerifyField<double>(verifier, VT_NORTH, 8) &&
           VerifyField<double>(verifier, VT_SOUTH, 8) &&
           VerifyField<double>(verifier, VT_EAST, 8) &&
           VerifyField<double>(verifier, VT_WEST, 8) &&
           VerifyField<double>(verifier, VT_ROTATION, 8) &&
           VerifyField<double>(verifier, VT_ALTITUDE, 8) &&
           VerifyField<int8_t>(verifier, VT_ALTITUDE_MODE, 1) &&
           verifier.EndTable();
  }
};

struct KMLGroundOverlayBuilder {
  typedef KMLGroundOverlay Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KMLGroundOverlay::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(KMLGroundOverlay::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_VISIBILITY(bool VISIBILITY) {
    fbb_.AddElement<uint8_t>(KMLGroundOverlay::VT_VISIBILITY, static_cast<uint8_t>(VISIBILITY), 0);
  }
  void add_ICON_HREF(::flatbuffers::Offset<::flatbuffers::String> ICON_HREF) {
    fbb_.AddOffset(KMLGroundOverlay::VT_ICON_HREF, ICON_HREF);
  }
  void add_COLOR(::flatbuffers::Offset<::flatbuffers::String> COLOR) {
    fbb_.AddOffset(KMLGroundOverlay::VT_COLOR, COLOR);
  }
  void add_NORTH(double NORTH) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_NORTH, NORTH, 0.0);
  }
  void add_SOUTH(double SOUTH) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_SOUTH, SOUTH, 0.0);
  }
  void add_EAST(double EAST) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_EAST, EAST, 0.0);
  }
  void add_WEST(double WEST) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_WEST, WEST, 0.0);
  }
  void add_ROTATION(double ROTATION) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_ROTATION, ROTATION, 0.0);
  }
  void add_ALTITUDE(double ALTITUDE) {
    fbb_.AddElement<double>(KMLGroundOverlay::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  void add_ALTITUDE_MODE(KMLAltitudeMode ALTITUDE_MODE) {
    fbb_.AddElement<int8_t>(KMLGroundOverlay::VT_ALTITUDE_MODE, static_cast<int8_t>(ALTITUDE_MODE), 0);
  }
  explicit KMLGroundOverlayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLGroundOverlay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLGroundOverlay>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLGroundOverlay> CreateKMLGroundOverlay(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    bool VISIBILITY = false,
    ::flatbuffers::Offset<::flatbuffers::String> ICON_HREF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COLOR = 0,
    double NORTH = 0.0,
    double SOUTH = 0.0,
    double EAST = 0.0,
    double WEST = 0.0,
    double ROTATION = 0.0,
    double ALTITUDE = 0.0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND) {
  KMLGroundOverlayBuilder builder_(_fbb);
  builder_.add_ALTITUDE(ALTITUDE);
  builder_.add_ROTATION(ROTATION);
  builder_.add_WEST(WEST);
  builder_.add_EAST(EAST);
  builder_.add_SOUTH(SOUTH);
  builder_.add_NORTH(NORTH);
  builder_.add_COLOR(COLOR);
  builder_.add_ICON_HREF(ICON_HREF);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_ALTITUDE_MODE(ALTITUDE_MODE);
  builder_.add_VISIBILITY(VISIBILITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLGroundOverlay> CreateKMLGroundOverlayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    bool VISIBILITY = false,
    const char *ICON_HREF = nullptr,
    const char *COLOR = nullptr,
    double NORTH = 0.0,
    double SOUTH = 0.0,
    double EAST = 0.0,
    double WEST = 0.0,
    double ROTATION = 0.0,
    double ALTITUDE = 0.0,
    KMLAltitudeMode ALTITUDE_MODE = KMLAltitudeMode_CLAMP_TO_GROUND) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto ICON_HREF__ = ICON_HREF ? _fbb.CreateString(ICON_HREF) : 0;
  auto COLOR__ = COLOR ? _fbb.CreateString(COLOR) : 0;
  return CreateKMLGroundOverlay(
      _fbb,
      NAME__,
      DESCRIPTION__,
      VISIBILITY,
      ICON_HREF__,
      COLOR__,
      NORTH,
      SOUTH,
      EAST,
      WEST,
      ROTATION,
      ALTITUDE,
      ALTITUDE_MODE);
}

/// Placemark feature
struct KMLPlacemark FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLPlacemarkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VISIBILITY = 8,
    VT_STYLE_URL = 10,
    VT_STYLE = 12,
    VT_SNIPPET = 14,
    VT_POINT = 16,
    VT_LINE_STRING = 18,
    VT_POLYGON = 20,
    VT_MULTI_GEOMETRY = 22,
    VT_LOOK_AT = 24,
    VT_CAMERA = 26,
    VT_TIME_SPAN = 28,
    VT_TIME_STAMP = 30,
    VT_EXTENDED_DATA = 32
  };
  /// Placemark name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Description (may contain HTML)
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Visibility flag
  bool VISIBILITY() const {
    return GetField<uint8_t>(VT_VISIBILITY, 0) != 0;
  }
  /// Style URL reference
  const ::flatbuffers::String *STYLE_URL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STYLE_URL);
  }
  /// Inline style
  const KMLStyle *STYLE() const {
    return GetPointer<const KMLStyle *>(VT_STYLE);
  }
  /// Snippet (short description)
  const ::flatbuffers::String *SNIPPET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SNIPPET);
  }
  /// Point geometry
  const KMLPoint *POINT() const {
    return GetPointer<const KMLPoint *>(VT_POINT);
  }
  /// LineString geometry
  const KMLLineString *LINE_STRING() const {
    return GetPointer<const KMLLineString *>(VT_LINE_STRING);
  }
  /// Polygon geometry
  const KMLPolygon *POLYGON() const {
    return GetPointer<const KMLPolygon *>(VT_POLYGON);
  }
  /// MultiGeometry
  const KMLMultiGeometry *MULTI_GEOMETRY() const {
    return GetPointer<const KMLMultiGeometry *>(VT_MULTI_GEOMETRY);
  }
  /// LookAt viewpoint
  const KMLLookAt *LOOK_AT() const {
    return GetPointer<const KMLLookAt *>(VT_LOOK_AT);
  }
  /// Camera viewpoint
  const KMLCamera *CAMERA() const {
    return GetPointer<const KMLCamera *>(VT_CAMERA);
  }
  /// TimeSpan
  const KMLTimeSpan *TIME_SPAN() const {
    return GetPointer<const KMLTimeSpan *>(VT_TIME_SPAN);
  }
  /// TimeStamp
  const KMLTimeStamp *TIME_STAMP() const {
    return GetPointer<const KMLTimeStamp *>(VT_TIME_STAMP);
  }
  /// Extended data
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLData>> *EXTENDED_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLData>> *>(VT_EXTENDED_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyOffset(verifier, VT_STYLE_URL) &&
           verifier.VerifyString(STYLE_URL()) &&
           VerifyOffset(verifier, VT_STYLE) &&
           verifier.VerifyTable(STYLE()) &&
           VerifyOffset(verifier, VT_SNIPPET) &&
           verifier.VerifyString(SNIPPET()) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyTable(POINT()) &&
           VerifyOffset(verifier, VT_LINE_STRING) &&
           verifier.VerifyTable(LINE_STRING()) &&
           VerifyOffset(verifier, VT_POLYGON) &&
           verifier.VerifyTable(POLYGON()) &&
           VerifyOffset(verifier, VT_MULTI_GEOMETRY) &&
           verifier.VerifyTable(MULTI_GEOMETRY()) &&
           VerifyOffset(verifier, VT_LOOK_AT) &&
           verifier.VerifyTable(LOOK_AT()) &&
           VerifyOffset(verifier, VT_CAMERA) &&
           verifier.VerifyTable(CAMERA()) &&
           VerifyOffset(verifier, VT_TIME_SPAN) &&
           verifier.VerifyTable(TIME_SPAN()) &&
           VerifyOffset(verifier, VT_TIME_STAMP) &&
           verifier.VerifyTable(TIME_STAMP()) &&
           VerifyOffset(verifier, VT_EXTENDED_DATA) &&
           verifier.VerifyVector(EXTENDED_DATA()) &&
           verifier.VerifyVectorOfTables(EXTENDED_DATA()) &&
           verifier.EndTable();
  }
};

struct KMLPlacemarkBuilder {
  typedef KMLPlacemark Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KMLPlacemark::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(KMLPlacemark::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_VISIBILITY(bool VISIBILITY) {
    fbb_.AddElement<uint8_t>(KMLPlacemark::VT_VISIBILITY, static_cast<uint8_t>(VISIBILITY), 0);
  }
  void add_STYLE_URL(::flatbuffers::Offset<::flatbuffers::String> STYLE_URL) {
    fbb_.AddOffset(KMLPlacemark::VT_STYLE_URL, STYLE_URL);
  }
  void add_STYLE(::flatbuffers::Offset<KMLStyle> STYLE) {
    fbb_.AddOffset(KMLPlacemark::VT_STYLE, STYLE);
  }
  void add_SNIPPET(::flatbuffers::Offset<::flatbuffers::String> SNIPPET) {
    fbb_.AddOffset(KMLPlacemark::VT_SNIPPET, SNIPPET);
  }
  void add_POINT(::flatbuffers::Offset<KMLPoint> POINT) {
    fbb_.AddOffset(KMLPlacemark::VT_POINT, POINT);
  }
  void add_LINE_STRING(::flatbuffers::Offset<KMLLineString> LINE_STRING) {
    fbb_.AddOffset(KMLPlacemark::VT_LINE_STRING, LINE_STRING);
  }
  void add_POLYGON(::flatbuffers::Offset<KMLPolygon> POLYGON) {
    fbb_.AddOffset(KMLPlacemark::VT_POLYGON, POLYGON);
  }
  void add_MULTI_GEOMETRY(::flatbuffers::Offset<KMLMultiGeometry> MULTI_GEOMETRY) {
    fbb_.AddOffset(KMLPlacemark::VT_MULTI_GEOMETRY, MULTI_GEOMETRY);
  }
  void add_LOOK_AT(::flatbuffers::Offset<KMLLookAt> LOOK_AT) {
    fbb_.AddOffset(KMLPlacemark::VT_LOOK_AT, LOOK_AT);
  }
  void add_CAMERA(::flatbuffers::Offset<KMLCamera> CAMERA) {
    fbb_.AddOffset(KMLPlacemark::VT_CAMERA, CAMERA);
  }
  void add_TIME_SPAN(::flatbuffers::Offset<KMLTimeSpan> TIME_SPAN) {
    fbb_.AddOffset(KMLPlacemark::VT_TIME_SPAN, TIME_SPAN);
  }
  void add_TIME_STAMP(::flatbuffers::Offset<KMLTimeStamp> TIME_STAMP) {
    fbb_.AddOffset(KMLPlacemark::VT_TIME_STAMP, TIME_STAMP);
  }
  void add_EXTENDED_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLData>>> EXTENDED_DATA) {
    fbb_.AddOffset(KMLPlacemark::VT_EXTENDED_DATA, EXTENDED_DATA);
  }
  explicit KMLPlacemarkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLPlacemark> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLPlacemark>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLPlacemark> CreateKMLPlacemark(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    bool VISIBILITY = false,
    ::flatbuffers::Offset<::flatbuffers::String> STYLE_URL = 0,
    ::flatbuffers::Offset<KMLStyle> STYLE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SNIPPET = 0,
    ::flatbuffers::Offset<KMLPoint> POINT = 0,
    ::flatbuffers::Offset<KMLLineString> LINE_STRING = 0,
    ::flatbuffers::Offset<KMLPolygon> POLYGON = 0,
    ::flatbuffers::Offset<KMLMultiGeometry> MULTI_GEOMETRY = 0,
    ::flatbuffers::Offset<KMLLookAt> LOOK_AT = 0,
    ::flatbuffers::Offset<KMLCamera> CAMERA = 0,
    ::flatbuffers::Offset<KMLTimeSpan> TIME_SPAN = 0,
    ::flatbuffers::Offset<KMLTimeStamp> TIME_STAMP = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLData>>> EXTENDED_DATA = 0) {
  KMLPlacemarkBuilder builder_(_fbb);
  builder_.add_EXTENDED_DATA(EXTENDED_DATA);
  builder_.add_TIME_STAMP(TIME_STAMP);
  builder_.add_TIME_SPAN(TIME_SPAN);
  builder_.add_CAMERA(CAMERA);
  builder_.add_LOOK_AT(LOOK_AT);
  builder_.add_MULTI_GEOMETRY(MULTI_GEOMETRY);
  builder_.add_POLYGON(POLYGON);
  builder_.add_LINE_STRING(LINE_STRING);
  builder_.add_POINT(POINT);
  builder_.add_SNIPPET(SNIPPET);
  builder_.add_STYLE(STYLE);
  builder_.add_STYLE_URL(STYLE_URL);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_VISIBILITY(VISIBILITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLPlacemark> CreateKMLPlacemarkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    bool VISIBILITY = false,
    const char *STYLE_URL = nullptr,
    ::flatbuffers::Offset<KMLStyle> STYLE = 0,
    const char *SNIPPET = nullptr,
    ::flatbuffers::Offset<KMLPoint> POINT = 0,
    ::flatbuffers::Offset<KMLLineString> LINE_STRING = 0,
    ::flatbuffers::Offset<KMLPolygon> POLYGON = 0,
    ::flatbuffers::Offset<KMLMultiGeometry> MULTI_GEOMETRY = 0,
    ::flatbuffers::Offset<KMLLookAt> LOOK_AT = 0,
    ::flatbuffers::Offset<KMLCamera> CAMERA = 0,
    ::flatbuffers::Offset<KMLTimeSpan> TIME_SPAN = 0,
    ::flatbuffers::Offset<KMLTimeStamp> TIME_STAMP = 0,
    const std::vector<::flatbuffers::Offset<KMLData>> *EXTENDED_DATA = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto STYLE_URL__ = STYLE_URL ? _fbb.CreateString(STYLE_URL) : 0;
  auto SNIPPET__ = SNIPPET ? _fbb.CreateString(SNIPPET) : 0;
  auto EXTENDED_DATA__ = EXTENDED_DATA ? _fbb.CreateVector<::flatbuffers::Offset<KMLData>>(*EXTENDED_DATA) : 0;
  return CreateKMLPlacemark(
      _fbb,
      NAME__,
      DESCRIPTION__,
      VISIBILITY,
      STYLE_URL__,
      STYLE,
      SNIPPET__,
      POINT,
      LINE_STRING,
      POLYGON,
      MULTI_GEOMETRY,
      LOOK_AT,
      CAMERA,
      TIME_SPAN,
      TIME_STAMP,
      EXTENDED_DATA__);
}

/// Folder container
struct KMLFolder FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLFolderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VISIBILITY = 8,
    VT_OPEN = 10,
    VT_PLACEMARKS = 12,
    VT_FOLDERS = 14,
    VT_NETWORK_LINKS = 16,
    VT_GROUND_OVERLAYS = 18
  };
  /// Folder name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Visibility flag
  bool VISIBILITY() const {
    return GetField<uint8_t>(VT_VISIBILITY, 0) != 0;
  }
  /// Whether folder is open in tree view
  bool OPEN() const {
    return GetField<uint8_t>(VT_OPEN, 0) != 0;
  }
  /// Placemarks in this folder
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>> *PLACEMARKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>> *>(VT_PLACEMARKS);
  }
  /// Sub-folders
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>> *FOLDERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>> *>(VT_FOLDERS);
  }
  /// Network links
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>> *NETWORK_LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>> *>(VT_NETWORK_LINKS);
  }
  /// Ground overlays
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>> *GROUND_OVERLAYS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>> *>(VT_GROUND_OVERLAYS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_OPEN, 1) &&
           VerifyOffset(verifier, VT_PLACEMARKS) &&
           verifier.VerifyVector(PLACEMARKS()) &&
           verifier.VerifyVectorOfTables(PLACEMARKS()) &&
           VerifyOffset(verifier, VT_FOLDERS) &&
           verifier.VerifyVector(FOLDERS()) &&
           verifier.VerifyVectorOfTables(FOLDERS()) &&
           VerifyOffset(verifier, VT_NETWORK_LINKS) &&
           verifier.VerifyVector(NETWORK_LINKS()) &&
           verifier.VerifyVectorOfTables(NETWORK_LINKS()) &&
           VerifyOffset(verifier, VT_GROUND_OVERLAYS) &&
           verifier.VerifyVector(GROUND_OVERLAYS()) &&
           verifier.VerifyVectorOfTables(GROUND_OVERLAYS()) &&
           verifier.EndTable();
  }
};

struct KMLFolderBuilder {
  typedef KMLFolder Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KMLFolder::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(KMLFolder::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_VISIBILITY(bool VISIBILITY) {
    fbb_.AddElement<uint8_t>(KMLFolder::VT_VISIBILITY, static_cast<uint8_t>(VISIBILITY), 0);
  }
  void add_OPEN(bool OPEN) {
    fbb_.AddElement<uint8_t>(KMLFolder::VT_OPEN, static_cast<uint8_t>(OPEN), 0);
  }
  void add_PLACEMARKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>>> PLACEMARKS) {
    fbb_.AddOffset(KMLFolder::VT_PLACEMARKS, PLACEMARKS);
  }
  void add_FOLDERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>>> FOLDERS) {
    fbb_.AddOffset(KMLFolder::VT_FOLDERS, FOLDERS);
  }
  void add_NETWORK_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>>> NETWORK_LINKS) {
    fbb_.AddOffset(KMLFolder::VT_NETWORK_LINKS, NETWORK_LINKS);
  }
  void add_GROUND_OVERLAYS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>>> GROUND_OVERLAYS) {
    fbb_.AddOffset(KMLFolder::VT_GROUND_OVERLAYS, GROUND_OVERLAYS);
  }
  explicit KMLFolderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KMLFolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KMLFolder>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KMLFolder> CreateKMLFolder(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    bool VISIBILITY = false,
    bool OPEN = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>>> PLACEMARKS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>>> FOLDERS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>>> NETWORK_LINKS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>>> GROUND_OVERLAYS = 0) {
  KMLFolderBuilder builder_(_fbb);
  builder_.add_GROUND_OVERLAYS(GROUND_OVERLAYS);
  builder_.add_NETWORK_LINKS(NETWORK_LINKS);
  builder_.add_FOLDERS(FOLDERS);
  builder_.add_PLACEMARKS(PLACEMARKS);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_OPEN(OPEN);
  builder_.add_VISIBILITY(VISIBILITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KMLFolder> CreateKMLFolderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    bool VISIBILITY = false,
    bool OPEN = false,
    const std::vector<::flatbuffers::Offset<KMLPlacemark>> *PLACEMARKS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLFolder>> *FOLDERS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLNetworkLink>> *NETWORK_LINKS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLGroundOverlay>> *GROUND_OVERLAYS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto PLACEMARKS__ = PLACEMARKS ? _fbb.CreateVector<::flatbuffers::Offset<KMLPlacemark>>(*PLACEMARKS) : 0;
  auto FOLDERS__ = FOLDERS ? _fbb.CreateVector<::flatbuffers::Offset<KMLFolder>>(*FOLDERS) : 0;
  auto NETWORK_LINKS__ = NETWORK_LINKS ? _fbb.CreateVector<::flatbuffers::Offset<KMLNetworkLink>>(*NETWORK_LINKS) : 0;
  auto GROUND_OVERLAYS__ = GROUND_OVERLAYS ? _fbb.CreateVector<::flatbuffers::Offset<KMLGroundOverlay>>(*GROUND_OVERLAYS) : 0;
  return CreateKMLFolder(
      _fbb,
      NAME__,
      DESCRIPTION__,
      VISIBILITY,
      OPEN,
      PLACEMARKS__,
      FOLDERS__,
      NETWORK_LINKS__,
      GROUND_OVERLAYS__);
}

/// KML Document
struct KML FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KMLBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_VISIBILITY = 8,
    VT_OPEN = 10,
    VT_STYLES = 12,
    VT_STYLE_MAPS = 14,
    VT_PLACEMARKS = 16,
    VT_FOLDERS = 18,
    VT_NETWORK_LINKS = 20,
    VT_GROUND_OVERLAYS = 22
  };
  /// Document name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Document description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Whether document is visible
  bool VISIBILITY() const {
    return GetField<uint8_t>(VT_VISIBILITY, 0) != 0;
  }
  /// Whether document is open in tree view
  bool OPEN() const {
    return GetField<uint8_t>(VT_OPEN, 0) != 0;
  }
  /// Shared styles
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyle>> *STYLES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyle>> *>(VT_STYLES);
  }
  /// Style maps
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMap>> *STYLE_MAPS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMap>> *>(VT_STYLE_MAPS);
  }
  /// Top-level placemarks
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>> *PLACEMARKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>> *>(VT_PLACEMARKS);
  }
  /// Top-level folders
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>> *FOLDERS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>> *>(VT_FOLDERS);
  }
  /// Network links
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>> *NETWORK_LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>> *>(VT_NETWORK_LINKS);
  }
  /// Ground overlays
  const ::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>> *GROUND_OVERLAYS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>> *>(VT_GROUND_OVERLAYS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyField<uint8_t>(verifier, VT_VISIBILITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_OPEN, 1) &&
           VerifyOffset(verifier, VT_STYLES) &&
           verifier.VerifyVector(STYLES()) &&
           verifier.VerifyVectorOfTables(STYLES()) &&
           VerifyOffset(verifier, VT_STYLE_MAPS) &&
           verifier.VerifyVector(STYLE_MAPS()) &&
           verifier.VerifyVectorOfTables(STYLE_MAPS()) &&
           VerifyOffset(verifier, VT_PLACEMARKS) &&
           verifier.VerifyVector(PLACEMARKS()) &&
           verifier.VerifyVectorOfTables(PLACEMARKS()) &&
           VerifyOffset(verifier, VT_FOLDERS) &&
           verifier.VerifyVector(FOLDERS()) &&
           verifier.VerifyVectorOfTables(FOLDERS()) &&
           VerifyOffset(verifier, VT_NETWORK_LINKS) &&
           verifier.VerifyVector(NETWORK_LINKS()) &&
           verifier.VerifyVectorOfTables(NETWORK_LINKS()) &&
           VerifyOffset(verifier, VT_GROUND_OVERLAYS) &&
           verifier.VerifyVector(GROUND_OVERLAYS()) &&
           verifier.VerifyVectorOfTables(GROUND_OVERLAYS()) &&
           verifier.EndTable();
  }
};

struct KMLBuilder {
  typedef KML Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(KML::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(KML::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_VISIBILITY(bool VISIBILITY) {
    fbb_.AddElement<uint8_t>(KML::VT_VISIBILITY, static_cast<uint8_t>(VISIBILITY), 0);
  }
  void add_OPEN(bool OPEN) {
    fbb_.AddElement<uint8_t>(KML::VT_OPEN, static_cast<uint8_t>(OPEN), 0);
  }
  void add_STYLES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyle>>> STYLES) {
    fbb_.AddOffset(KML::VT_STYLES, STYLES);
  }
  void add_STYLE_MAPS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMap>>> STYLE_MAPS) {
    fbb_.AddOffset(KML::VT_STYLE_MAPS, STYLE_MAPS);
  }
  void add_PLACEMARKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>>> PLACEMARKS) {
    fbb_.AddOffset(KML::VT_PLACEMARKS, PLACEMARKS);
  }
  void add_FOLDERS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>>> FOLDERS) {
    fbb_.AddOffset(KML::VT_FOLDERS, FOLDERS);
  }
  void add_NETWORK_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>>> NETWORK_LINKS) {
    fbb_.AddOffset(KML::VT_NETWORK_LINKS, NETWORK_LINKS);
  }
  void add_GROUND_OVERLAYS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>>> GROUND_OVERLAYS) {
    fbb_.AddOffset(KML::VT_GROUND_OVERLAYS, GROUND_OVERLAYS);
  }
  explicit KMLBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KML> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KML>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KML> CreateKML(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    bool VISIBILITY = false,
    bool OPEN = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyle>>> STYLES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLStyleMap>>> STYLE_MAPS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLPlacemark>>> PLACEMARKS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLFolder>>> FOLDERS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLNetworkLink>>> NETWORK_LINKS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KMLGroundOverlay>>> GROUND_OVERLAYS = 0) {
  KMLBuilder builder_(_fbb);
  builder_.add_GROUND_OVERLAYS(GROUND_OVERLAYS);
  builder_.add_NETWORK_LINKS(NETWORK_LINKS);
  builder_.add_FOLDERS(FOLDERS);
  builder_.add_PLACEMARKS(PLACEMARKS);
  builder_.add_STYLE_MAPS(STYLE_MAPS);
  builder_.add_STYLES(STYLES);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_OPEN(OPEN);
  builder_.add_VISIBILITY(VISIBILITY);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KML> CreateKMLDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    bool VISIBILITY = false,
    bool OPEN = false,
    const std::vector<::flatbuffers::Offset<KMLStyle>> *STYLES = nullptr,
    const std::vector<::flatbuffers::Offset<KMLStyleMap>> *STYLE_MAPS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLPlacemark>> *PLACEMARKS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLFolder>> *FOLDERS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLNetworkLink>> *NETWORK_LINKS = nullptr,
    const std::vector<::flatbuffers::Offset<KMLGroundOverlay>> *GROUND_OVERLAYS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto STYLES__ = STYLES ? _fbb.CreateVector<::flatbuffers::Offset<KMLStyle>>(*STYLES) : 0;
  auto STYLE_MAPS__ = STYLE_MAPS ? _fbb.CreateVector<::flatbuffers::Offset<KMLStyleMap>>(*STYLE_MAPS) : 0;
  auto PLACEMARKS__ = PLACEMARKS ? _fbb.CreateVector<::flatbuffers::Offset<KMLPlacemark>>(*PLACEMARKS) : 0;
  auto FOLDERS__ = FOLDERS ? _fbb.CreateVector<::flatbuffers::Offset<KMLFolder>>(*FOLDERS) : 0;
  auto NETWORK_LINKS__ = NETWORK_LINKS ? _fbb.CreateVector<::flatbuffers::Offset<KMLNetworkLink>>(*NETWORK_LINKS) : 0;
  auto GROUND_OVERLAYS__ = GROUND_OVERLAYS ? _fbb.CreateVector<::flatbuffers::Offset<KMLGroundOverlay>>(*GROUND_OVERLAYS) : 0;
  return CreateKML(
      _fbb,
      NAME__,
      DESCRIPTION__,
      VISIBILITY,
      OPEN,
      STYLES__,
      STYLE_MAPS__,
      PLACEMARKS__,
      FOLDERS__,
      NETWORK_LINKS__,
      GROUND_OVERLAYS__);
}

inline const KML *GetKML(const void *buf) {
  return ::flatbuffers::GetRoot<KML>(buf);
}

inline const KML *GetSizePrefixedKML(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<KML>(buf);
}

inline const char *KMLIdentifier() {
  return "$KML";
}

inline bool KMLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, KMLIdentifier());
}

inline bool SizePrefixedKMLBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, KMLIdentifier(), true);
}

inline bool VerifyKMLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<KML>(KMLIdentifier());
}

inline bool VerifySizePrefixedKMLBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<KML>(KMLIdentifier());
}

inline void FinishKMLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<KML> root) {
  fbb.Finish(root, KMLIdentifier());
}

inline void FinishSizePrefixedKMLBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<KML> root) {
  fbb.FinishSizePrefixed(root, KMLIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
