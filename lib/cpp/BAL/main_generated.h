// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct BAL;
struct BALBuilder;

enum DragModel : int8_t {
  DragModel_G1 = 0,
  DragModel_G2 = 1,
  DragModel_G5 = 2,
  DragModel_G6 = 3,
  DragModel_G7 = 4,
  DragModel_G8 = 5,
  DragModel_GI = 6,
  DragModel_GL = 7,
  DragModel_GS = 8,
  DragModel_RA4 = 9,
  DragModel_CUSTOM = 10,
  DragModel_MIN = DragModel_G1,
  DragModel_MAX = DragModel_CUSTOM
};

inline const DragModel (&EnumValuesDragModel())[11] {
  static const DragModel values[] = {
    DragModel_G1,
    DragModel_G2,
    DragModel_G5,
    DragModel_G6,
    DragModel_G7,
    DragModel_G8,
    DragModel_GI,
    DragModel_GL,
    DragModel_GS,
    DragModel_RA4,
    DragModel_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesDragModel() {
  static const char * const names[12] = {
    "G1",
    "G2",
    "G5",
    "G6",
    "G7",
    "G8",
    "GI",
    "GL",
    "GS",
    "RA4",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameDragModel(DragModel e) {
  if (::flatbuffers::IsOutRange(e, DragModel_G1, DragModel_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDragModel()[index];
}

enum BallisticModel : int8_t {
  BallisticModel_POINT_MASS_2D = 0,
  BallisticModel_POINT_MASS_3D = 1,
  BallisticModel_MODIFIED_POINT_MASS = 2,
  BallisticModel_SIX_DOF = 3,
  BallisticModel_MIN = BallisticModel_POINT_MASS_2D,
  BallisticModel_MAX = BallisticModel_SIX_DOF
};

inline const BallisticModel (&EnumValuesBallisticModel())[4] {
  static const BallisticModel values[] = {
    BallisticModel_POINT_MASS_2D,
    BallisticModel_POINT_MASS_3D,
    BallisticModel_MODIFIED_POINT_MASS,
    BallisticModel_SIX_DOF
  };
  return values;
}

inline const char * const *EnumNamesBallisticModel() {
  static const char * const names[5] = {
    "POINT_MASS_2D",
    "POINT_MASS_3D",
    "MODIFIED_POINT_MASS",
    "SIX_DOF",
    nullptr
  };
  return names;
}

inline const char *EnumNameBallisticModel(BallisticModel e) {
  if (::flatbuffers::IsOutRange(e, BallisticModel_POINT_MASS_2D, BallisticModel_SIX_DOF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBallisticModel()[index];
}

enum ProjectileType : int8_t {
  ProjectileType_BALL = 0,
  ProjectileType_HOLLOW_POINT = 1,
  ProjectileType_BOAT_TAIL = 2,
  ProjectileType_ARMOR_PIERCING = 3,
  ProjectileType_ARMOR_PIERCING_INCENDIARY = 4,
  ProjectileType_TRACER = 5,
  ProjectileType_SABOT = 6,
  ProjectileType_SUBCALIBER = 7,
  ProjectileType_HEAT = 8,
  ProjectileType_HESH = 9,
  ProjectileType_HE = 10,
  ProjectileType_APFSDS = 11,
  ProjectileType_ARTILLERY_HE = 12,
  ProjectileType_MORTAR = 13,
  ProjectileType_GRENADE = 14,
  ProjectileType_ROCKET = 15,
  ProjectileType_MIN = ProjectileType_BALL,
  ProjectileType_MAX = ProjectileType_ROCKET
};

inline const ProjectileType (&EnumValuesProjectileType())[16] {
  static const ProjectileType values[] = {
    ProjectileType_BALL,
    ProjectileType_HOLLOW_POINT,
    ProjectileType_BOAT_TAIL,
    ProjectileType_ARMOR_PIERCING,
    ProjectileType_ARMOR_PIERCING_INCENDIARY,
    ProjectileType_TRACER,
    ProjectileType_SABOT,
    ProjectileType_SUBCALIBER,
    ProjectileType_HEAT,
    ProjectileType_HESH,
    ProjectileType_HE,
    ProjectileType_APFSDS,
    ProjectileType_ARTILLERY_HE,
    ProjectileType_MORTAR,
    ProjectileType_GRENADE,
    ProjectileType_ROCKET
  };
  return values;
}

inline const char * const *EnumNamesProjectileType() {
  static const char * const names[17] = {
    "BALL",
    "HOLLOW_POINT",
    "BOAT_TAIL",
    "ARMOR_PIERCING",
    "ARMOR_PIERCING_INCENDIARY",
    "TRACER",
    "SABOT",
    "SUBCALIBER",
    "HEAT",
    "HESH",
    "HE",
    "APFSDS",
    "ARTILLERY_HE",
    "MORTAR",
    "GRENADE",
    "ROCKET",
    nullptr
  };
  return names;
}

inline const char *EnumNameProjectileType(ProjectileType e) {
  if (::flatbuffers::IsOutRange(e, ProjectileType_BALL, ProjectileType_ROCKET)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProjectileType()[index];
}

enum StabilizationType : int8_t {
  StabilizationType_SPIN = 0,
  StabilizationType_FIN = 1,
  StabilizationType_DUAL = 2,
  StabilizationType_MIN = StabilizationType_SPIN,
  StabilizationType_MAX = StabilizationType_DUAL
};

inline const StabilizationType (&EnumValuesStabilizationType())[3] {
  static const StabilizationType values[] = {
    StabilizationType_SPIN,
    StabilizationType_FIN,
    StabilizationType_DUAL
  };
  return values;
}

inline const char * const *EnumNamesStabilizationType() {
  static const char * const names[4] = {
    "SPIN",
    "FIN",
    "DUAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameStabilizationType(StabilizationType e) {
  if (::flatbuffers::IsOutRange(e, StabilizationType_SPIN, StabilizationType_DUAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStabilizationType()[index];
}

enum PenetrationModel : int8_t {
  PenetrationModel_DE_MARRE = 0,
  PenetrationModel_THOR = 1,
  PenetrationModel_ODERMATT = 2,
  PenetrationModel_ANDERSON = 3,
  PenetrationModel_BRL = 4,
  PenetrationModel_MIN = PenetrationModel_DE_MARRE,
  PenetrationModel_MAX = PenetrationModel_BRL
};

inline const PenetrationModel (&EnumValuesPenetrationModel())[5] {
  static const PenetrationModel values[] = {
    PenetrationModel_DE_MARRE,
    PenetrationModel_THOR,
    PenetrationModel_ODERMATT,
    PenetrationModel_ANDERSON,
    PenetrationModel_BRL
  };
  return values;
}

inline const char * const *EnumNamesPenetrationModel() {
  static const char * const names[6] = {
    "DE_MARRE",
    "THOR",
    "ODERMATT",
    "ANDERSON",
    "BRL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePenetrationModel(PenetrationModel e) {
  if (::flatbuffers::IsOutRange(e, PenetrationModel_DE_MARRE, PenetrationModel_BRL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPenetrationModel()[index];
}

/// Ballistics
struct BAL FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BALBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_TRAJECTORY_REQUEST = 6,
    VT_TABLE_REQUEST = 8,
    VT_FIRE_CONTROL = 10,
    VT_PENETRATION_PROJECTILE = 12,
    VT_PENETRATION_ARMOR = 14,
    VT_IMPACT_VELOCITY_MPS = 16,
    VT_IMPACT_ANGLE_DEG = 18
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *TRAJECTORY_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRAJECTORY_REQUEST);
  }
  const ::flatbuffers::String *TABLE_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TABLE_REQUEST);
  }
  const ::flatbuffers::String *FIRE_CONTROL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FIRE_CONTROL);
  }
  const ::flatbuffers::String *PENETRATION_PROJECTILE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PENETRATION_PROJECTILE);
  }
  const ::flatbuffers::String *PENETRATION_ARMOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PENETRATION_ARMOR);
  }
  double IMPACT_VELOCITY_MPS() const {
    return GetField<double>(VT_IMPACT_VELOCITY_MPS, 0.0);
  }
  double IMPACT_ANGLE_DEG() const {
    return GetField<double>(VT_IMPACT_ANGLE_DEG, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_TRAJECTORY_REQUEST) &&
           verifier.VerifyString(TRAJECTORY_REQUEST()) &&
           VerifyOffset(verifier, VT_TABLE_REQUEST) &&
           verifier.VerifyString(TABLE_REQUEST()) &&
           VerifyOffset(verifier, VT_FIRE_CONTROL) &&
           verifier.VerifyString(FIRE_CONTROL()) &&
           VerifyOffset(verifier, VT_PENETRATION_PROJECTILE) &&
           verifier.VerifyString(PENETRATION_PROJECTILE()) &&
           VerifyOffset(verifier, VT_PENETRATION_ARMOR) &&
           verifier.VerifyString(PENETRATION_ARMOR()) &&
           VerifyField<double>(verifier, VT_IMPACT_VELOCITY_MPS, 8) &&
           VerifyField<double>(verifier, VT_IMPACT_ANGLE_DEG, 8) &&
           verifier.EndTable();
  }
};

struct BALBuilder {
  typedef BAL Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(BAL::VT_COMMAND, COMMAND);
  }
  void add_TRAJECTORY_REQUEST(::flatbuffers::Offset<::flatbuffers::String> TRAJECTORY_REQUEST) {
    fbb_.AddOffset(BAL::VT_TRAJECTORY_REQUEST, TRAJECTORY_REQUEST);
  }
  void add_TABLE_REQUEST(::flatbuffers::Offset<::flatbuffers::String> TABLE_REQUEST) {
    fbb_.AddOffset(BAL::VT_TABLE_REQUEST, TABLE_REQUEST);
  }
  void add_FIRE_CONTROL(::flatbuffers::Offset<::flatbuffers::String> FIRE_CONTROL) {
    fbb_.AddOffset(BAL::VT_FIRE_CONTROL, FIRE_CONTROL);
  }
  void add_PENETRATION_PROJECTILE(::flatbuffers::Offset<::flatbuffers::String> PENETRATION_PROJECTILE) {
    fbb_.AddOffset(BAL::VT_PENETRATION_PROJECTILE, PENETRATION_PROJECTILE);
  }
  void add_PENETRATION_ARMOR(::flatbuffers::Offset<::flatbuffers::String> PENETRATION_ARMOR) {
    fbb_.AddOffset(BAL::VT_PENETRATION_ARMOR, PENETRATION_ARMOR);
  }
  void add_IMPACT_VELOCITY_MPS(double IMPACT_VELOCITY_MPS) {
    fbb_.AddElement<double>(BAL::VT_IMPACT_VELOCITY_MPS, IMPACT_VELOCITY_MPS, 0.0);
  }
  void add_IMPACT_ANGLE_DEG(double IMPACT_ANGLE_DEG) {
    fbb_.AddElement<double>(BAL::VT_IMPACT_ANGLE_DEG, IMPACT_ANGLE_DEG, 0.0);
  }
  explicit BALBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BAL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BAL>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BAL> CreateBAL(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TRAJECTORY_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TABLE_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FIRE_CONTROL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PENETRATION_PROJECTILE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PENETRATION_ARMOR = 0,
    double IMPACT_VELOCITY_MPS = 0.0,
    double IMPACT_ANGLE_DEG = 0.0) {
  BALBuilder builder_(_fbb);
  builder_.add_IMPACT_ANGLE_DEG(IMPACT_ANGLE_DEG);
  builder_.add_IMPACT_VELOCITY_MPS(IMPACT_VELOCITY_MPS);
  builder_.add_PENETRATION_ARMOR(PENETRATION_ARMOR);
  builder_.add_PENETRATION_PROJECTILE(PENETRATION_PROJECTILE);
  builder_.add_FIRE_CONTROL(FIRE_CONTROL);
  builder_.add_TABLE_REQUEST(TABLE_REQUEST);
  builder_.add_TRAJECTORY_REQUEST(TRAJECTORY_REQUEST);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BAL> CreateBALDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *TRAJECTORY_REQUEST = nullptr,
    const char *TABLE_REQUEST = nullptr,
    const char *FIRE_CONTROL = nullptr,
    const char *PENETRATION_PROJECTILE = nullptr,
    const char *PENETRATION_ARMOR = nullptr,
    double IMPACT_VELOCITY_MPS = 0.0,
    double IMPACT_ANGLE_DEG = 0.0) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto TRAJECTORY_REQUEST__ = TRAJECTORY_REQUEST ? _fbb.CreateString(TRAJECTORY_REQUEST) : 0;
  auto TABLE_REQUEST__ = TABLE_REQUEST ? _fbb.CreateString(TABLE_REQUEST) : 0;
  auto FIRE_CONTROL__ = FIRE_CONTROL ? _fbb.CreateString(FIRE_CONTROL) : 0;
  auto PENETRATION_PROJECTILE__ = PENETRATION_PROJECTILE ? _fbb.CreateString(PENETRATION_PROJECTILE) : 0;
  auto PENETRATION_ARMOR__ = PENETRATION_ARMOR ? _fbb.CreateString(PENETRATION_ARMOR) : 0;
  return CreateBAL(
      _fbb,
      COMMAND__,
      TRAJECTORY_REQUEST__,
      TABLE_REQUEST__,
      FIRE_CONTROL__,
      PENETRATION_PROJECTILE__,
      PENETRATION_ARMOR__,
      IMPACT_VELOCITY_MPS,
      IMPACT_ANGLE_DEG);
}

inline const BAL *GetBAL(const void *buf) {
  return ::flatbuffers::GetRoot<BAL>(buf);
}

inline const BAL *GetSizePrefixedBAL(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<BAL>(buf);
}

inline const char *BALIdentifier() {
  return "$BAL";
}

inline bool BALBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BALIdentifier());
}

inline bool SizePrefixedBALBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, BALIdentifier(), true);
}

inline bool VerifyBALBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BAL>(BALIdentifier());
}

inline bool VerifySizePrefixedBALBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BAL>(BALIdentifier());
}

inline void FinishBALBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BAL> root) {
  fbb.Finish(root, BALIdentifier());
}

inline void FinishSizePrefixedBALBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BAL> root) {
  fbb.FinishSizePrefixed(root, BALIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
