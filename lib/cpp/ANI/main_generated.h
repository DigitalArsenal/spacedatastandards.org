// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ANI;
struct ANIBuilder;

enum analyticType : int8_t {
  analyticType_SPECTRAL = 0,
  analyticType_PHOTOMETRIC = 1,
  analyticType_ASTROMETRIC = 2,
  analyticType_RADIOMETRIC = 3,
  analyticType_SIGNATURE = 4,
  analyticType_FEATURE_EXTRACTION = 5,
  analyticType_CHANGE_DETECTION = 6,
  analyticType_CLASSIFICATION = 7,
  analyticType_FUSION = 8,
  analyticType_MIN = analyticType_SPECTRAL,
  analyticType_MAX = analyticType_FUSION
};

inline const analyticType (&EnumValuesanalyticType())[9] {
  static const analyticType values[] = {
    analyticType_SPECTRAL,
    analyticType_PHOTOMETRIC,
    analyticType_ASTROMETRIC,
    analyticType_RADIOMETRIC,
    analyticType_SIGNATURE,
    analyticType_FEATURE_EXTRACTION,
    analyticType_CHANGE_DETECTION,
    analyticType_CLASSIFICATION,
    analyticType_FUSION
  };
  return values;
}

inline const char * const *EnumNamesanalyticType() {
  static const char * const names[10] = {
    "SPECTRAL",
    "PHOTOMETRIC",
    "ASTROMETRIC",
    "RADIOMETRIC",
    "SIGNATURE",
    "FEATURE_EXTRACTION",
    "CHANGE_DETECTION",
    "CLASSIFICATION",
    "FUSION",
    nullptr
  };
  return names;
}

inline const char *EnumNameanalyticType(analyticType e) {
  if (::flatbuffers::IsOutRange(e, analyticType_SPECTRAL, analyticType_FUSION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesanalyticType()[index];
}

/// Analytic Imagery Product
struct ANI FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ANIBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SOURCE_ID = 6,
    VT_SOURCE_TYPE = 8,
    VT_ANALYTIC_TYPE = 10,
    VT_ALGORITHM = 12,
    VT_ALGORITHM_VERSION = 14,
    VT_PROCESSING_TIME = 16,
    VT_OBS_TIME = 18,
    VT_SAT_NO = 20,
    VT_OBJECT_DESIGNATOR = 22,
    VT_RA = 24,
    VT_DEC = 26,
    VT_FOV = 28,
    VT_VISUAL_MAG = 30,
    VT_MAG_UNCERTAINTY = 32,
    VT_OBJECT_COUNT = 34,
    VT_LABELS = 36,
    VT_CONFIDENCE = 38,
    VT_FEATURES = 40,
    VT_QUALITY = 42,
    VT_NOTES = 44
  };
  /// Unique identifier
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Reference to source imagery (e.g., SKI, GDI, EOO)
  const ::flatbuffers::String *SOURCE_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_ID);
  }
  /// Source imagery type
  const ::flatbuffers::String *SOURCE_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_TYPE);
  }
  /// Analytic product type
  analyticType ANALYTIC_TYPE() const {
    return static_cast<analyticType>(GetField<int8_t>(VT_ANALYTIC_TYPE, 0));
  }
  /// Processing algorithm or pipeline name
  const ::flatbuffers::String *ALGORITHM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM);
  }
  /// Algorithm version
  const ::flatbuffers::String *ALGORITHM_VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGORITHM_VERSION);
  }
  /// Processing epoch (ISO 8601)
  const ::flatbuffers::String *PROCESSING_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROCESSING_TIME);
  }
  /// Original observation epoch (ISO 8601)
  const ::flatbuffers::String *OBS_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBS_TIME);
  }
  /// Target satellite number (if applicable)
  uint32_t SAT_NO() const {
    return GetField<uint32_t>(VT_SAT_NO, 0);
  }
  /// Target object designator
  const ::flatbuffers::String *OBJECT_DESIGNATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_DESIGNATOR);
  }
  /// Center right ascension in degrees
  double RA() const {
    return GetField<double>(VT_RA, 0.0);
  }
  /// Center declination in degrees
  double DEC() const {
    return GetField<double>(VT_DEC, 0.0);
  }
  /// Field of view in degrees
  double FOV() const {
    return GetField<double>(VT_FOV, 0.0);
  }
  /// Visual magnitude estimate
  double VISUAL_MAG() const {
    return GetField<double>(VT_VISUAL_MAG, 0.0);
  }
  /// Magnitude uncertainty
  double MAG_UNCERTAINTY() const {
    return GetField<double>(VT_MAG_UNCERTAINTY, 0.0);
  }
  /// Detected object count
  uint32_t OBJECT_COUNT() const {
    return GetField<uint32_t>(VT_OBJECT_COUNT, 0);
  }
  /// Classification labels
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *LABELS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LABELS);
  }
  /// Classification confidence scores (0.0-1.0)
  const ::flatbuffers::Vector<double> *CONFIDENCE() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_CONFIDENCE);
  }
  /// Feature vector or extracted parameters
  const ::flatbuffers::Vector<double> *FEATURES() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_FEATURES);
  }
  /// Quality score (0.0-1.0)
  double QUALITY() const {
    return GetField<double>(VT_QUALITY, 0.0);
  }
  /// Additional notes
  const ::flatbuffers::String *NOTES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_SOURCE_ID) &&
           verifier.VerifyString(SOURCE_ID()) &&
           VerifyOffset(verifier, VT_SOURCE_TYPE) &&
           verifier.VerifyString(SOURCE_TYPE()) &&
           VerifyField<int8_t>(verifier, VT_ANALYTIC_TYPE, 1) &&
           VerifyOffset(verifier, VT_ALGORITHM) &&
           verifier.VerifyString(ALGORITHM()) &&
           VerifyOffset(verifier, VT_ALGORITHM_VERSION) &&
           verifier.VerifyString(ALGORITHM_VERSION()) &&
           VerifyOffset(verifier, VT_PROCESSING_TIME) &&
           verifier.VerifyString(PROCESSING_TIME()) &&
           VerifyOffset(verifier, VT_OBS_TIME) &&
           verifier.VerifyString(OBS_TIME()) &&
           VerifyField<uint32_t>(verifier, VT_SAT_NO, 4) &&
           VerifyOffset(verifier, VT_OBJECT_DESIGNATOR) &&
           verifier.VerifyString(OBJECT_DESIGNATOR()) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_DEC, 8) &&
           VerifyField<double>(verifier, VT_FOV, 8) &&
           VerifyField<double>(verifier, VT_VISUAL_MAG, 8) &&
           VerifyField<double>(verifier, VT_MAG_UNCERTAINTY, 8) &&
           VerifyField<uint32_t>(verifier, VT_OBJECT_COUNT, 4) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(LABELS()) &&
           verifier.VerifyVectorOfStrings(LABELS()) &&
           VerifyOffset(verifier, VT_CONFIDENCE) &&
           verifier.VerifyVector(CONFIDENCE()) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(FEATURES()) &&
           VerifyField<double>(verifier, VT_QUALITY, 8) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(NOTES()) &&
           verifier.EndTable();
  }
};

struct ANIBuilder {
  typedef ANI Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(ANI::VT_ID, ID);
  }
  void add_SOURCE_ID(::flatbuffers::Offset<::flatbuffers::String> SOURCE_ID) {
    fbb_.AddOffset(ANI::VT_SOURCE_ID, SOURCE_ID);
  }
  void add_SOURCE_TYPE(::flatbuffers::Offset<::flatbuffers::String> SOURCE_TYPE) {
    fbb_.AddOffset(ANI::VT_SOURCE_TYPE, SOURCE_TYPE);
  }
  void add_ANALYTIC_TYPE(analyticType ANALYTIC_TYPE) {
    fbb_.AddElement<int8_t>(ANI::VT_ANALYTIC_TYPE, static_cast<int8_t>(ANALYTIC_TYPE), 0);
  }
  void add_ALGORITHM(::flatbuffers::Offset<::flatbuffers::String> ALGORITHM) {
    fbb_.AddOffset(ANI::VT_ALGORITHM, ALGORITHM);
  }
  void add_ALGORITHM_VERSION(::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_VERSION) {
    fbb_.AddOffset(ANI::VT_ALGORITHM_VERSION, ALGORITHM_VERSION);
  }
  void add_PROCESSING_TIME(::flatbuffers::Offset<::flatbuffers::String> PROCESSING_TIME) {
    fbb_.AddOffset(ANI::VT_PROCESSING_TIME, PROCESSING_TIME);
  }
  void add_OBS_TIME(::flatbuffers::Offset<::flatbuffers::String> OBS_TIME) {
    fbb_.AddOffset(ANI::VT_OBS_TIME, OBS_TIME);
  }
  void add_SAT_NO(uint32_t SAT_NO) {
    fbb_.AddElement<uint32_t>(ANI::VT_SAT_NO, SAT_NO, 0);
  }
  void add_OBJECT_DESIGNATOR(::flatbuffers::Offset<::flatbuffers::String> OBJECT_DESIGNATOR) {
    fbb_.AddOffset(ANI::VT_OBJECT_DESIGNATOR, OBJECT_DESIGNATOR);
  }
  void add_RA(double RA) {
    fbb_.AddElement<double>(ANI::VT_RA, RA, 0.0);
  }
  void add_DEC(double DEC) {
    fbb_.AddElement<double>(ANI::VT_DEC, DEC, 0.0);
  }
  void add_FOV(double FOV) {
    fbb_.AddElement<double>(ANI::VT_FOV, FOV, 0.0);
  }
  void add_VISUAL_MAG(double VISUAL_MAG) {
    fbb_.AddElement<double>(ANI::VT_VISUAL_MAG, VISUAL_MAG, 0.0);
  }
  void add_MAG_UNCERTAINTY(double MAG_UNCERTAINTY) {
    fbb_.AddElement<double>(ANI::VT_MAG_UNCERTAINTY, MAG_UNCERTAINTY, 0.0);
  }
  void add_OBJECT_COUNT(uint32_t OBJECT_COUNT) {
    fbb_.AddElement<uint32_t>(ANI::VT_OBJECT_COUNT, OBJECT_COUNT, 0);
  }
  void add_LABELS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LABELS) {
    fbb_.AddOffset(ANI::VT_LABELS, LABELS);
  }
  void add_CONFIDENCE(::flatbuffers::Offset<::flatbuffers::Vector<double>> CONFIDENCE) {
    fbb_.AddOffset(ANI::VT_CONFIDENCE, CONFIDENCE);
  }
  void add_FEATURES(::flatbuffers::Offset<::flatbuffers::Vector<double>> FEATURES) {
    fbb_.AddOffset(ANI::VT_FEATURES, FEATURES);
  }
  void add_QUALITY(double QUALITY) {
    fbb_.AddElement<double>(ANI::VT_QUALITY, QUALITY, 0.0);
  }
  void add_NOTES(::flatbuffers::Offset<::flatbuffers::String> NOTES) {
    fbb_.AddOffset(ANI::VT_NOTES, NOTES);
  }
  explicit ANIBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ANI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ANI>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ANI> CreateANI(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE_TYPE = 0,
    analyticType ANALYTIC_TYPE = analyticType_SPECTRAL,
    ::flatbuffers::Offset<::flatbuffers::String> ALGORITHM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ALGORITHM_VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PROCESSING_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBS_TIME = 0,
    uint32_t SAT_NO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_DESIGNATOR = 0,
    double RA = 0.0,
    double DEC = 0.0,
    double FOV = 0.0,
    double VISUAL_MAG = 0.0,
    double MAG_UNCERTAINTY = 0.0,
    uint32_t OBJECT_COUNT = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> LABELS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> CONFIDENCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> FEATURES = 0,
    double QUALITY = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> NOTES = 0) {
  ANIBuilder builder_(_fbb);
  builder_.add_QUALITY(QUALITY);
  builder_.add_MAG_UNCERTAINTY(MAG_UNCERTAINTY);
  builder_.add_VISUAL_MAG(VISUAL_MAG);
  builder_.add_FOV(FOV);
  builder_.add_DEC(DEC);
  builder_.add_RA(RA);
  builder_.add_NOTES(NOTES);
  builder_.add_FEATURES(FEATURES);
  builder_.add_CONFIDENCE(CONFIDENCE);
  builder_.add_LABELS(LABELS);
  builder_.add_OBJECT_COUNT(OBJECT_COUNT);
  builder_.add_OBJECT_DESIGNATOR(OBJECT_DESIGNATOR);
  builder_.add_SAT_NO(SAT_NO);
  builder_.add_OBS_TIME(OBS_TIME);
  builder_.add_PROCESSING_TIME(PROCESSING_TIME);
  builder_.add_ALGORITHM_VERSION(ALGORITHM_VERSION);
  builder_.add_ALGORITHM(ALGORITHM);
  builder_.add_SOURCE_TYPE(SOURCE_TYPE);
  builder_.add_SOURCE_ID(SOURCE_ID);
  builder_.add_ID(ID);
  builder_.add_ANALYTIC_TYPE(ANALYTIC_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ANI> CreateANIDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *SOURCE_ID = nullptr,
    const char *SOURCE_TYPE = nullptr,
    analyticType ANALYTIC_TYPE = analyticType_SPECTRAL,
    const char *ALGORITHM = nullptr,
    const char *ALGORITHM_VERSION = nullptr,
    const char *PROCESSING_TIME = nullptr,
    const char *OBS_TIME = nullptr,
    uint32_t SAT_NO = 0,
    const char *OBJECT_DESIGNATOR = nullptr,
    double RA = 0.0,
    double DEC = 0.0,
    double FOV = 0.0,
    double VISUAL_MAG = 0.0,
    double MAG_UNCERTAINTY = 0.0,
    uint32_t OBJECT_COUNT = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *LABELS = nullptr,
    const std::vector<double> *CONFIDENCE = nullptr,
    const std::vector<double> *FEATURES = nullptr,
    double QUALITY = 0.0,
    const char *NOTES = nullptr) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto SOURCE_ID__ = SOURCE_ID ? _fbb.CreateString(SOURCE_ID) : 0;
  auto SOURCE_TYPE__ = SOURCE_TYPE ? _fbb.CreateString(SOURCE_TYPE) : 0;
  auto ALGORITHM__ = ALGORITHM ? _fbb.CreateString(ALGORITHM) : 0;
  auto ALGORITHM_VERSION__ = ALGORITHM_VERSION ? _fbb.CreateString(ALGORITHM_VERSION) : 0;
  auto PROCESSING_TIME__ = PROCESSING_TIME ? _fbb.CreateString(PROCESSING_TIME) : 0;
  auto OBS_TIME__ = OBS_TIME ? _fbb.CreateString(OBS_TIME) : 0;
  auto OBJECT_DESIGNATOR__ = OBJECT_DESIGNATOR ? _fbb.CreateString(OBJECT_DESIGNATOR) : 0;
  auto LABELS__ = LABELS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*LABELS) : 0;
  auto CONFIDENCE__ = CONFIDENCE ? _fbb.CreateVector<double>(*CONFIDENCE) : 0;
  auto FEATURES__ = FEATURES ? _fbb.CreateVector<double>(*FEATURES) : 0;
  auto NOTES__ = NOTES ? _fbb.CreateString(NOTES) : 0;
  return CreateANI(
      _fbb,
      ID__,
      SOURCE_ID__,
      SOURCE_TYPE__,
      ANALYTIC_TYPE,
      ALGORITHM__,
      ALGORITHM_VERSION__,
      PROCESSING_TIME__,
      OBS_TIME__,
      SAT_NO,
      OBJECT_DESIGNATOR__,
      RA,
      DEC,
      FOV,
      VISUAL_MAG,
      MAG_UNCERTAINTY,
      OBJECT_COUNT,
      LABELS__,
      CONFIDENCE__,
      FEATURES__,
      QUALITY,
      NOTES__);
}

inline const ANI *GetANI(const void *buf) {
  return ::flatbuffers::GetRoot<ANI>(buf);
}

inline const ANI *GetSizePrefixedANI(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ANI>(buf);
}

inline const char *ANIIdentifier() {
  return "$ANI";
}

inline bool ANIBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ANIIdentifier());
}

inline bool SizePrefixedANIBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ANIIdentifier(), true);
}

inline bool VerifyANIBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ANI>(ANIIdentifier());
}

inline bool VerifySizePrefixedANIBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ANI>(ANIIdentifier());
}

inline void FinishANIBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ANI> root) {
  fbb.Finish(root, ANIIdentifier());
}

inline void FinishSizePrefixedANIBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ANI> root) {
  fbb.FinishSizePrefixed(root, ANIIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
