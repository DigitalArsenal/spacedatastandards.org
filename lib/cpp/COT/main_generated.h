// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct COTPoint;
struct COTPointBuilder;

struct COTDetail;
struct COTDetailBuilder;

struct COT;
struct COTBuilder;

enum COTHowType : int8_t {
  /// Human entered or generated
  COTHowType_HE = 0,
  /// Human estimated
  COTHowType_H_E = 1,
  /// Machine generated via GPS
  COTHowType_M_G = 2,
  /// Machine generated via sensor
  COTHowType_M_S = 3,
  /// Machine fused
  COTHowType_M_F = 4,
  /// Machine inferred
  COTHowType_M_I = 5,
  /// Configured
  COTHowType_M_C = 6,
  COTHowType_MIN = COTHowType_HE,
  COTHowType_MAX = COTHowType_M_C
};

inline const COTHowType (&EnumValuesCOTHowType())[7] {
  static const COTHowType values[] = {
    COTHowType_HE,
    COTHowType_H_E,
    COTHowType_M_G,
    COTHowType_M_S,
    COTHowType_M_F,
    COTHowType_M_I,
    COTHowType_M_C
  };
  return values;
}

inline const char * const *EnumNamesCOTHowType() {
  static const char * const names[8] = {
    "HE",
    "H_E",
    "M_G",
    "M_S",
    "M_F",
    "M_I",
    "M_C",
    nullptr
  };
  return names;
}

inline const char *EnumNameCOTHowType(COTHowType e) {
  if (::flatbuffers::IsOutRange(e, COTHowType_HE, COTHowType_M_C)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCOTHowType()[index];
}

/// CoT Point - geographical point with error estimates
struct COTPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COTPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6,
    VT_HAE = 8,
    VT_CE = 10,
    VT_LE = 12
  };
  /// Latitude in decimal degrees (WGS84)
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Longitude in decimal degrees (WGS84)
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Height above WGS84 ellipsoid in meters
  double HAE() const {
    return GetField<double>(VT_HAE, 0.0);
  }
  /// Circular error in meters (95% confidence)
  double CE() const {
    return GetField<double>(VT_CE, 0.0);
  }
  /// Linear error (vertical) in meters (95% confidence)
  double LE() const {
    return GetField<double>(VT_LE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_HAE, 8) &&
           VerifyField<double>(verifier, VT_CE, 8) &&
           VerifyField<double>(verifier, VT_LE, 8) &&
           verifier.EndTable();
  }
};

struct COTPointBuilder {
  typedef COTPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(COTPoint::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(COTPoint::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_HAE(double HAE) {
    fbb_.AddElement<double>(COTPoint::VT_HAE, HAE, 0.0);
  }
  void add_CE(double CE) {
    fbb_.AddElement<double>(COTPoint::VT_CE, CE, 0.0);
  }
  void add_LE(double LE) {
    fbb_.AddElement<double>(COTPoint::VT_LE, LE, 0.0);
  }
  explicit COTPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COTPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COTPoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COTPoint> CreateCOTPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    double HAE = 0.0,
    double CE = 0.0,
    double LE = 0.0) {
  COTPointBuilder builder_(_fbb);
  builder_.add_LE(LE);
  builder_.add_CE(CE);
  builder_.add_HAE(HAE);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_LATITUDE(LATITUDE);
  return builder_.Finish();
}

/// CoT Detail - extensible detail element
struct COTDetail FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COTDetailBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALLSIGN = 4,
    VT_ENDPOINT = 6,
    VT_PHONE = 8,
    VT_COURSE = 10,
    VT_SPEED = 12,
    VT_GROUP_NAME = 14,
    VT_GROUP_ROLE = 16,
    VT_STATUS_BATTERY = 18,
    VT_STATUS_READINESS = 20,
    VT_PREC_LOCATION_SOURCE = 22,
    VT_PREC_ALTSRC = 24,
    VT_UID_DROID = 26,
    VT_REMARKS = 28,
    VT_REMARKS_SOURCE = 30,
    VT_REMARKS_TIME = 32,
    VT_LINK_UID = 34,
    VT_LINK_TYPE = 36,
    VT_LINK_RELATION = 38,
    VT_COLOR = 40,
    VT_STROKE_WEIGHT = 42,
    VT_FILL_COLOR = 44,
    VT_LABELLED = 46,
    VT_ARCHIVE = 48,
    VT_RAW_XML = 50
  };
  /// Contact callsign
  const ::flatbuffers::String *CALLSIGN() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  /// Contact endpoint (e.g. IP:port)
  const ::flatbuffers::String *ENDPOINT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENDPOINT);
  }
  /// Contact phone number
  const ::flatbuffers::String *PHONE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PHONE);
  }
  /// Track course in degrees true
  double COURSE() const {
    return GetField<double>(VT_COURSE, 0.0);
  }
  /// Track speed in m/s
  double SPEED() const {
    return GetField<double>(VT_SPEED, 0.0);
  }
  /// Group name/team
  const ::flatbuffers::String *GROUP_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUP_NAME);
  }
  /// Group role
  const ::flatbuffers::String *GROUP_ROLE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUP_ROLE);
  }
  /// Status (battery percentage, etc.)
  double STATUS_BATTERY() const {
    return GetField<double>(VT_STATUS_BATTERY, 0.0);
  }
  /// Status readiness
  bool STATUS_READINESS() const {
    return GetField<uint8_t>(VT_STATUS_READINESS, 0) != 0;
  }
  /// Precision location source
  const ::flatbuffers::String *PREC_LOCATION_SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREC_LOCATION_SOURCE);
  }
  /// Precision location altitude source
  const ::flatbuffers::String *PREC_ALTSRC() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREC_ALTSRC);
  }
  /// UID of the device
  const ::flatbuffers::String *UID_DROID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UID_DROID);
  }
  /// Remarks text
  const ::flatbuffers::String *REMARKS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMARKS);
  }
  /// Remarks source
  const ::flatbuffers::String *REMARKS_SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMARKS_SOURCE);
  }
  /// Remarks timestamp (ISO 8601)
  const ::flatbuffers::String *REMARKS_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMARKS_TIME);
  }
  /// Link UID (for related events)
  const ::flatbuffers::String *LINK_UID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LINK_UID);
  }
  /// Link type
  const ::flatbuffers::String *LINK_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LINK_TYPE);
  }
  /// Link relation
  const ::flatbuffers::String *LINK_RELATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LINK_RELATION);
  }
  /// Color in ARGB integer format
  int32_t COLOR() const {
    return GetField<int32_t>(VT_COLOR, 0);
  }
  /// Stroke weight for drawing
  double STROKE_WEIGHT() const {
    return GetField<double>(VT_STROKE_WEIGHT, 0.0);
  }
  /// Fill color in ARGB integer format
  int32_t FILL_COLOR() const {
    return GetField<int32_t>(VT_FILL_COLOR, 0);
  }
  /// Labeled flag
  bool LABELLED() const {
    return GetField<uint8_t>(VT_LABELLED, 0) != 0;
  }
  /// Archive flag
  bool ARCHIVE() const {
    return GetField<uint8_t>(VT_ARCHIVE, 0) != 0;
  }
  /// Raw XML detail content (for extensions not covered above)
  const ::flatbuffers::String *RAW_XML() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAW_XML);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(CALLSIGN()) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyString(ENDPOINT()) &&
           VerifyOffset(verifier, VT_PHONE) &&
           verifier.VerifyString(PHONE()) &&
           VerifyField<double>(verifier, VT_COURSE, 8) &&
           VerifyField<double>(verifier, VT_SPEED, 8) &&
           VerifyOffset(verifier, VT_GROUP_NAME) &&
           verifier.VerifyString(GROUP_NAME()) &&
           VerifyOffset(verifier, VT_GROUP_ROLE) &&
           verifier.VerifyString(GROUP_ROLE()) &&
           VerifyField<double>(verifier, VT_STATUS_BATTERY, 8) &&
           VerifyField<uint8_t>(verifier, VT_STATUS_READINESS, 1) &&
           VerifyOffset(verifier, VT_PREC_LOCATION_SOURCE) &&
           verifier.VerifyString(PREC_LOCATION_SOURCE()) &&
           VerifyOffset(verifier, VT_PREC_ALTSRC) &&
           verifier.VerifyString(PREC_ALTSRC()) &&
           VerifyOffset(verifier, VT_UID_DROID) &&
           verifier.VerifyString(UID_DROID()) &&
           VerifyOffset(verifier, VT_REMARKS) &&
           verifier.VerifyString(REMARKS()) &&
           VerifyOffset(verifier, VT_REMARKS_SOURCE) &&
           verifier.VerifyString(REMARKS_SOURCE()) &&
           VerifyOffset(verifier, VT_REMARKS_TIME) &&
           verifier.VerifyString(REMARKS_TIME()) &&
           VerifyOffset(verifier, VT_LINK_UID) &&
           verifier.VerifyString(LINK_UID()) &&
           VerifyOffset(verifier, VT_LINK_TYPE) &&
           verifier.VerifyString(LINK_TYPE()) &&
           VerifyOffset(verifier, VT_LINK_RELATION) &&
           verifier.VerifyString(LINK_RELATION()) &&
           VerifyField<int32_t>(verifier, VT_COLOR, 4) &&
           VerifyField<double>(verifier, VT_STROKE_WEIGHT, 8) &&
           VerifyField<int32_t>(verifier, VT_FILL_COLOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_LABELLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ARCHIVE, 1) &&
           VerifyOffset(verifier, VT_RAW_XML) &&
           verifier.VerifyString(RAW_XML()) &&
           verifier.EndTable();
  }
};

struct COTDetailBuilder {
  typedef COTDetail Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CALLSIGN(::flatbuffers::Offset<::flatbuffers::String> CALLSIGN) {
    fbb_.AddOffset(COTDetail::VT_CALLSIGN, CALLSIGN);
  }
  void add_ENDPOINT(::flatbuffers::Offset<::flatbuffers::String> ENDPOINT) {
    fbb_.AddOffset(COTDetail::VT_ENDPOINT, ENDPOINT);
  }
  void add_PHONE(::flatbuffers::Offset<::flatbuffers::String> PHONE) {
    fbb_.AddOffset(COTDetail::VT_PHONE, PHONE);
  }
  void add_COURSE(double COURSE) {
    fbb_.AddElement<double>(COTDetail::VT_COURSE, COURSE, 0.0);
  }
  void add_SPEED(double SPEED) {
    fbb_.AddElement<double>(COTDetail::VT_SPEED, SPEED, 0.0);
  }
  void add_GROUP_NAME(::flatbuffers::Offset<::flatbuffers::String> GROUP_NAME) {
    fbb_.AddOffset(COTDetail::VT_GROUP_NAME, GROUP_NAME);
  }
  void add_GROUP_ROLE(::flatbuffers::Offset<::flatbuffers::String> GROUP_ROLE) {
    fbb_.AddOffset(COTDetail::VT_GROUP_ROLE, GROUP_ROLE);
  }
  void add_STATUS_BATTERY(double STATUS_BATTERY) {
    fbb_.AddElement<double>(COTDetail::VT_STATUS_BATTERY, STATUS_BATTERY, 0.0);
  }
  void add_STATUS_READINESS(bool STATUS_READINESS) {
    fbb_.AddElement<uint8_t>(COTDetail::VT_STATUS_READINESS, static_cast<uint8_t>(STATUS_READINESS), 0);
  }
  void add_PREC_LOCATION_SOURCE(::flatbuffers::Offset<::flatbuffers::String> PREC_LOCATION_SOURCE) {
    fbb_.AddOffset(COTDetail::VT_PREC_LOCATION_SOURCE, PREC_LOCATION_SOURCE);
  }
  void add_PREC_ALTSRC(::flatbuffers::Offset<::flatbuffers::String> PREC_ALTSRC) {
    fbb_.AddOffset(COTDetail::VT_PREC_ALTSRC, PREC_ALTSRC);
  }
  void add_UID_DROID(::flatbuffers::Offset<::flatbuffers::String> UID_DROID) {
    fbb_.AddOffset(COTDetail::VT_UID_DROID, UID_DROID);
  }
  void add_REMARKS(::flatbuffers::Offset<::flatbuffers::String> REMARKS) {
    fbb_.AddOffset(COTDetail::VT_REMARKS, REMARKS);
  }
  void add_REMARKS_SOURCE(::flatbuffers::Offset<::flatbuffers::String> REMARKS_SOURCE) {
    fbb_.AddOffset(COTDetail::VT_REMARKS_SOURCE, REMARKS_SOURCE);
  }
  void add_REMARKS_TIME(::flatbuffers::Offset<::flatbuffers::String> REMARKS_TIME) {
    fbb_.AddOffset(COTDetail::VT_REMARKS_TIME, REMARKS_TIME);
  }
  void add_LINK_UID(::flatbuffers::Offset<::flatbuffers::String> LINK_UID) {
    fbb_.AddOffset(COTDetail::VT_LINK_UID, LINK_UID);
  }
  void add_LINK_TYPE(::flatbuffers::Offset<::flatbuffers::String> LINK_TYPE) {
    fbb_.AddOffset(COTDetail::VT_LINK_TYPE, LINK_TYPE);
  }
  void add_LINK_RELATION(::flatbuffers::Offset<::flatbuffers::String> LINK_RELATION) {
    fbb_.AddOffset(COTDetail::VT_LINK_RELATION, LINK_RELATION);
  }
  void add_COLOR(int32_t COLOR) {
    fbb_.AddElement<int32_t>(COTDetail::VT_COLOR, COLOR, 0);
  }
  void add_STROKE_WEIGHT(double STROKE_WEIGHT) {
    fbb_.AddElement<double>(COTDetail::VT_STROKE_WEIGHT, STROKE_WEIGHT, 0.0);
  }
  void add_FILL_COLOR(int32_t FILL_COLOR) {
    fbb_.AddElement<int32_t>(COTDetail::VT_FILL_COLOR, FILL_COLOR, 0);
  }
  void add_LABELLED(bool LABELLED) {
    fbb_.AddElement<uint8_t>(COTDetail::VT_LABELLED, static_cast<uint8_t>(LABELLED), 0);
  }
  void add_ARCHIVE(bool ARCHIVE) {
    fbb_.AddElement<uint8_t>(COTDetail::VT_ARCHIVE, static_cast<uint8_t>(ARCHIVE), 0);
  }
  void add_RAW_XML(::flatbuffers::Offset<::flatbuffers::String> RAW_XML) {
    fbb_.AddOffset(COTDetail::VT_RAW_XML, RAW_XML);
  }
  explicit COTDetailBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COTDetail> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COTDetail>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COTDetail> CreateCOTDetail(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CALLSIGN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ENDPOINT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PHONE = 0,
    double COURSE = 0.0,
    double SPEED = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> GROUP_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> GROUP_ROLE = 0,
    double STATUS_BATTERY = 0.0,
    bool STATUS_READINESS = false,
    ::flatbuffers::Offset<::flatbuffers::String> PREC_LOCATION_SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PREC_ALTSRC = 0,
    ::flatbuffers::Offset<::flatbuffers::String> UID_DROID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REMARKS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REMARKS_SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REMARKS_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LINK_UID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LINK_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LINK_RELATION = 0,
    int32_t COLOR = 0,
    double STROKE_WEIGHT = 0.0,
    int32_t FILL_COLOR = 0,
    bool LABELLED = false,
    bool ARCHIVE = false,
    ::flatbuffers::Offset<::flatbuffers::String> RAW_XML = 0) {
  COTDetailBuilder builder_(_fbb);
  builder_.add_STROKE_WEIGHT(STROKE_WEIGHT);
  builder_.add_STATUS_BATTERY(STATUS_BATTERY);
  builder_.add_SPEED(SPEED);
  builder_.add_COURSE(COURSE);
  builder_.add_RAW_XML(RAW_XML);
  builder_.add_FILL_COLOR(FILL_COLOR);
  builder_.add_COLOR(COLOR);
  builder_.add_LINK_RELATION(LINK_RELATION);
  builder_.add_LINK_TYPE(LINK_TYPE);
  builder_.add_LINK_UID(LINK_UID);
  builder_.add_REMARKS_TIME(REMARKS_TIME);
  builder_.add_REMARKS_SOURCE(REMARKS_SOURCE);
  builder_.add_REMARKS(REMARKS);
  builder_.add_UID_DROID(UID_DROID);
  builder_.add_PREC_ALTSRC(PREC_ALTSRC);
  builder_.add_PREC_LOCATION_SOURCE(PREC_LOCATION_SOURCE);
  builder_.add_GROUP_ROLE(GROUP_ROLE);
  builder_.add_GROUP_NAME(GROUP_NAME);
  builder_.add_PHONE(PHONE);
  builder_.add_ENDPOINT(ENDPOINT);
  builder_.add_CALLSIGN(CALLSIGN);
  builder_.add_ARCHIVE(ARCHIVE);
  builder_.add_LABELLED(LABELLED);
  builder_.add_STATUS_READINESS(STATUS_READINESS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<COTDetail> CreateCOTDetailDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CALLSIGN = nullptr,
    const char *ENDPOINT = nullptr,
    const char *PHONE = nullptr,
    double COURSE = 0.0,
    double SPEED = 0.0,
    const char *GROUP_NAME = nullptr,
    const char *GROUP_ROLE = nullptr,
    double STATUS_BATTERY = 0.0,
    bool STATUS_READINESS = false,
    const char *PREC_LOCATION_SOURCE = nullptr,
    const char *PREC_ALTSRC = nullptr,
    const char *UID_DROID = nullptr,
    const char *REMARKS = nullptr,
    const char *REMARKS_SOURCE = nullptr,
    const char *REMARKS_TIME = nullptr,
    const char *LINK_UID = nullptr,
    const char *LINK_TYPE = nullptr,
    const char *LINK_RELATION = nullptr,
    int32_t COLOR = 0,
    double STROKE_WEIGHT = 0.0,
    int32_t FILL_COLOR = 0,
    bool LABELLED = false,
    bool ARCHIVE = false,
    const char *RAW_XML = nullptr) {
  auto CALLSIGN__ = CALLSIGN ? _fbb.CreateString(CALLSIGN) : 0;
  auto ENDPOINT__ = ENDPOINT ? _fbb.CreateString(ENDPOINT) : 0;
  auto PHONE__ = PHONE ? _fbb.CreateString(PHONE) : 0;
  auto GROUP_NAME__ = GROUP_NAME ? _fbb.CreateString(GROUP_NAME) : 0;
  auto GROUP_ROLE__ = GROUP_ROLE ? _fbb.CreateString(GROUP_ROLE) : 0;
  auto PREC_LOCATION_SOURCE__ = PREC_LOCATION_SOURCE ? _fbb.CreateString(PREC_LOCATION_SOURCE) : 0;
  auto PREC_ALTSRC__ = PREC_ALTSRC ? _fbb.CreateString(PREC_ALTSRC) : 0;
  auto UID_DROID__ = UID_DROID ? _fbb.CreateString(UID_DROID) : 0;
  auto REMARKS__ = REMARKS ? _fbb.CreateString(REMARKS) : 0;
  auto REMARKS_SOURCE__ = REMARKS_SOURCE ? _fbb.CreateString(REMARKS_SOURCE) : 0;
  auto REMARKS_TIME__ = REMARKS_TIME ? _fbb.CreateString(REMARKS_TIME) : 0;
  auto LINK_UID__ = LINK_UID ? _fbb.CreateString(LINK_UID) : 0;
  auto LINK_TYPE__ = LINK_TYPE ? _fbb.CreateString(LINK_TYPE) : 0;
  auto LINK_RELATION__ = LINK_RELATION ? _fbb.CreateString(LINK_RELATION) : 0;
  auto RAW_XML__ = RAW_XML ? _fbb.CreateString(RAW_XML) : 0;
  return CreateCOTDetail(
      _fbb,
      CALLSIGN__,
      ENDPOINT__,
      PHONE__,
      COURSE,
      SPEED,
      GROUP_NAME__,
      GROUP_ROLE__,
      STATUS_BATTERY,
      STATUS_READINESS,
      PREC_LOCATION_SOURCE__,
      PREC_ALTSRC__,
      UID_DROID__,
      REMARKS__,
      REMARKS_SOURCE__,
      REMARKS_TIME__,
      LINK_UID__,
      LINK_TYPE__,
      LINK_RELATION__,
      COLOR,
      STROKE_WEIGHT,
      FILL_COLOR,
      LABELLED,
      ARCHIVE,
      RAW_XML__);
}

/// Cursor on Target Event
struct COT FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef COTBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_UID = 6,
    VT_TYPE = 8,
    VT_HOW = 10,
    VT_TIME = 12,
    VT_START = 14,
    VT_STALE = 16,
    VT_ACCESS = 18,
    VT_QOS = 20,
    VT_OPEX = 22,
    VT_POINT = 24,
    VT_DETAIL = 26
  };
  /// Schema version
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Globally unique event identifier
  const ::flatbuffers::String *UID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UID);
  }
  /// CoT event type (dot-delimited MIL-STD-2525/APP-6 hierarchy)
  /// e.g. "a-f-G-U-C" = atom, friend, Ground, Unit, Combat
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// How the event was generated (e.g. "m-g" = machine GPS)
  COTHowType HOW() const {
    return static_cast<COTHowType>(GetField<int8_t>(VT_HOW, 0));
  }
  /// Time the event was generated (ISO 8601)
  const ::flatbuffers::String *TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME);
  }
  /// Time the event information was valid (ISO 8601)
  const ::flatbuffers::String *START() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START);
  }
  /// Time the event information is no longer valid (ISO 8601)
  const ::flatbuffers::String *STALE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STALE);
  }
  /// Access control marking
  const ::flatbuffers::String *ACCESS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACCESS);
  }
  /// Quality of service
  const ::flatbuffers::String *QOS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QOS);
  }
  /// Operational status
  const ::flatbuffers::String *OPEX() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPEX);
  }
  /// Point location
  const COTPoint *POINT() const {
    return GetPointer<const COTPoint *>(VT_POINT);
  }
  /// Detailed event information
  const COTDetail *DETAIL() const {
    return GetPointer<const COTDetail *>(VT_DETAIL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.VerifyString(UID()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyField<int8_t>(verifier, VT_HOW, 1) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyString(TIME()) &&
           VerifyOffset(verifier, VT_START) &&
           verifier.VerifyString(START()) &&
           VerifyOffset(verifier, VT_STALE) &&
           verifier.VerifyString(STALE()) &&
           VerifyOffset(verifier, VT_ACCESS) &&
           verifier.VerifyString(ACCESS()) &&
           VerifyOffset(verifier, VT_QOS) &&
           verifier.VerifyString(QOS()) &&
           VerifyOffset(verifier, VT_OPEX) &&
           verifier.VerifyString(OPEX()) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyTable(POINT()) &&
           VerifyOffset(verifier, VT_DETAIL) &&
           verifier.VerifyTable(DETAIL()) &&
           verifier.EndTable();
  }
};

struct COTBuilder {
  typedef COT Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(COT::VT_VERSION, VERSION);
  }
  void add_UID(::flatbuffers::Offset<::flatbuffers::String> UID) {
    fbb_.AddOffset(COT::VT_UID, UID);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(COT::VT_TYPE, TYPE);
  }
  void add_HOW(COTHowType HOW) {
    fbb_.AddElement<int8_t>(COT::VT_HOW, static_cast<int8_t>(HOW), 0);
  }
  void add_TIME(::flatbuffers::Offset<::flatbuffers::String> TIME) {
    fbb_.AddOffset(COT::VT_TIME, TIME);
  }
  void add_START(::flatbuffers::Offset<::flatbuffers::String> START) {
    fbb_.AddOffset(COT::VT_START, START);
  }
  void add_STALE(::flatbuffers::Offset<::flatbuffers::String> STALE) {
    fbb_.AddOffset(COT::VT_STALE, STALE);
  }
  void add_ACCESS(::flatbuffers::Offset<::flatbuffers::String> ACCESS) {
    fbb_.AddOffset(COT::VT_ACCESS, ACCESS);
  }
  void add_QOS(::flatbuffers::Offset<::flatbuffers::String> QOS) {
    fbb_.AddOffset(COT::VT_QOS, QOS);
  }
  void add_OPEX(::flatbuffers::Offset<::flatbuffers::String> OPEX) {
    fbb_.AddOffset(COT::VT_OPEX, OPEX);
  }
  void add_POINT(::flatbuffers::Offset<COTPoint> POINT) {
    fbb_.AddOffset(COT::VT_POINT, POINT);
  }
  void add_DETAIL(::flatbuffers::Offset<COTDetail> DETAIL) {
    fbb_.AddOffset(COT::VT_DETAIL, DETAIL);
  }
  explicit COTBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<COT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<COT>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<COT> CreateCOT(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> UID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    COTHowType HOW = COTHowType_HE,
    ::flatbuffers::Offset<::flatbuffers::String> TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> START = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STALE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ACCESS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> QOS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OPEX = 0,
    ::flatbuffers::Offset<COTPoint> POINT = 0,
    ::flatbuffers::Offset<COTDetail> DETAIL = 0) {
  COTBuilder builder_(_fbb);
  builder_.add_DETAIL(DETAIL);
  builder_.add_POINT(POINT);
  builder_.add_OPEX(OPEX);
  builder_.add_QOS(QOS);
  builder_.add_ACCESS(ACCESS);
  builder_.add_STALE(STALE);
  builder_.add_START(START);
  builder_.add_TIME(TIME);
  builder_.add_TYPE(TYPE);
  builder_.add_UID(UID);
  builder_.add_VERSION(VERSION);
  builder_.add_HOW(HOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<COT> CreateCOTDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *VERSION = nullptr,
    const char *UID = nullptr,
    const char *TYPE = nullptr,
    COTHowType HOW = COTHowType_HE,
    const char *TIME = nullptr,
    const char *START = nullptr,
    const char *STALE = nullptr,
    const char *ACCESS = nullptr,
    const char *QOS = nullptr,
    const char *OPEX = nullptr,
    ::flatbuffers::Offset<COTPoint> POINT = 0,
    ::flatbuffers::Offset<COTDetail> DETAIL = 0) {
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  auto UID__ = UID ? _fbb.CreateString(UID) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto TIME__ = TIME ? _fbb.CreateString(TIME) : 0;
  auto START__ = START ? _fbb.CreateString(START) : 0;
  auto STALE__ = STALE ? _fbb.CreateString(STALE) : 0;
  auto ACCESS__ = ACCESS ? _fbb.CreateString(ACCESS) : 0;
  auto QOS__ = QOS ? _fbb.CreateString(QOS) : 0;
  auto OPEX__ = OPEX ? _fbb.CreateString(OPEX) : 0;
  return CreateCOT(
      _fbb,
      VERSION__,
      UID__,
      TYPE__,
      HOW,
      TIME__,
      START__,
      STALE__,
      ACCESS__,
      QOS__,
      OPEX__,
      POINT,
      DETAIL);
}

inline const COT *GetCOT(const void *buf) {
  return ::flatbuffers::GetRoot<COT>(buf);
}

inline const COT *GetSizePrefixedCOT(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<COT>(buf);
}

inline const char *COTIdentifier() {
  return "$COT";
}

inline bool COTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, COTIdentifier());
}

inline bool SizePrefixedCOTBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, COTIdentifier(), true);
}

inline bool VerifyCOTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<COT>(COTIdentifier());
}

inline bool VerifySizePrefixedCOTBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<COT>(COTIdentifier());
}

inline void FinishCOTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<COT> root) {
  fbb.Finish(root, COTIdentifier());
}

inline void FinishSizePrefixedCOTBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<COT> root) {
  fbb.FinishSizePrefixed(root, COTIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
