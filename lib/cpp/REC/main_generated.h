// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"
#include "main_generated.h"

struct Record;
struct RecordBuilder;

struct REC;
struct RECBuilder;

enum RecordType : uint8_t {
  RecordType_NONE = 0,
  RecordType_ATM = 1,
  RecordType_BOV = 2,
  RecordType_CAT = 3,
  RecordType_CDM = 4,
  RecordType_CRM = 5,
  RecordType_CSM = 6,
  RecordType_CTR = 7,
  RecordType_EME = 8,
  RecordType_EOO = 9,
  RecordType_EOP = 10,
  RecordType_EPM = 11,
  RecordType_HYP = 12,
  RecordType_IDM = 13,
  RecordType_LCC = 14,
  RecordType_LDM = 15,
  RecordType_MET = 16,
  RecordType_MPE = 17,
  RecordType_OCM = 18,
  RecordType_OEM = 19,
  RecordType_OMM = 20,
  RecordType_OSM = 21,
  RecordType_PLD = 22,
  RecordType_PNM = 23,
  RecordType_PRG = 24,
  RecordType_RFM = 25,
  RecordType_ROC = 26,
  RecordType_SCM = 27,
  RecordType_SIT = 28,
  RecordType_TDM = 29,
  RecordType_TIM = 30,
  RecordType_VCM = 31,
  RecordType_MIN = RecordType_NONE,
  RecordType_MAX = RecordType_VCM
};

inline const RecordType (&EnumValuesRecordType())[32] {
  static const RecordType values[] = {
    RecordType_NONE,
    RecordType_ATM,
    RecordType_BOV,
    RecordType_CAT,
    RecordType_CDM,
    RecordType_CRM,
    RecordType_CSM,
    RecordType_CTR,
    RecordType_EME,
    RecordType_EOO,
    RecordType_EOP,
    RecordType_EPM,
    RecordType_HYP,
    RecordType_IDM,
    RecordType_LCC,
    RecordType_LDM,
    RecordType_MET,
    RecordType_MPE,
    RecordType_OCM,
    RecordType_OEM,
    RecordType_OMM,
    RecordType_OSM,
    RecordType_PLD,
    RecordType_PNM,
    RecordType_PRG,
    RecordType_RFM,
    RecordType_ROC,
    RecordType_SCM,
    RecordType_SIT,
    RecordType_TDM,
    RecordType_TIM,
    RecordType_VCM
  };
  return values;
}

inline const char * const *EnumNamesRecordType() {
  static const char * const names[33] = {
    "NONE",
    "ATM",
    "BOV",
    "CAT",
    "CDM",
    "CRM",
    "CSM",
    "CTR",
    "EME",
    "EOO",
    "EOP",
    "EPM",
    "HYP",
    "IDM",
    "LCC",
    "LDM",
    "MET",
    "MPE",
    "OCM",
    "OEM",
    "OMM",
    "OSM",
    "PLD",
    "PNM",
    "PRG",
    "RFM",
    "ROC",
    "SCM",
    "SIT",
    "TDM",
    "TIM",
    "VCM",
    nullptr
  };
  return names;
}

inline const char *EnumNameRecordType(RecordType e) {
  if (::flatbuffers::IsOutRange(e, RecordType_NONE, RecordType_VCM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRecordType()[index];
}

template<typename T> struct RecordTypeTraits {
  static const RecordType enum_value = RecordType_NONE;
};

template<> struct RecordTypeTraits<ATM> {
  static const RecordType enum_value = RecordType_ATM;
};

template<> struct RecordTypeTraits<BOV> {
  static const RecordType enum_value = RecordType_BOV;
};

template<> struct RecordTypeTraits<CAT> {
  static const RecordType enum_value = RecordType_CAT;
};

template<> struct RecordTypeTraits<CDM> {
  static const RecordType enum_value = RecordType_CDM;
};

template<> struct RecordTypeTraits<CRM> {
  static const RecordType enum_value = RecordType_CRM;
};

template<> struct RecordTypeTraits<CSM> {
  static const RecordType enum_value = RecordType_CSM;
};

template<> struct RecordTypeTraits<CTR> {
  static const RecordType enum_value = RecordType_CTR;
};

template<> struct RecordTypeTraits<EME> {
  static const RecordType enum_value = RecordType_EME;
};

template<> struct RecordTypeTraits<EOO> {
  static const RecordType enum_value = RecordType_EOO;
};

template<> struct RecordTypeTraits<EOP> {
  static const RecordType enum_value = RecordType_EOP;
};

template<> struct RecordTypeTraits<EPM> {
  static const RecordType enum_value = RecordType_EPM;
};

template<> struct RecordTypeTraits<HYP> {
  static const RecordType enum_value = RecordType_HYP;
};

template<> struct RecordTypeTraits<IDM> {
  static const RecordType enum_value = RecordType_IDM;
};

template<> struct RecordTypeTraits<LCC> {
  static const RecordType enum_value = RecordType_LCC;
};

template<> struct RecordTypeTraits<LDM> {
  static const RecordType enum_value = RecordType_LDM;
};

template<> struct RecordTypeTraits<MET> {
  static const RecordType enum_value = RecordType_MET;
};

template<> struct RecordTypeTraits<MPE> {
  static const RecordType enum_value = RecordType_MPE;
};

template<> struct RecordTypeTraits<OCM> {
  static const RecordType enum_value = RecordType_OCM;
};

template<> struct RecordTypeTraits<OEM> {
  static const RecordType enum_value = RecordType_OEM;
};

template<> struct RecordTypeTraits<OMM> {
  static const RecordType enum_value = RecordType_OMM;
};

template<> struct RecordTypeTraits<OSM> {
  static const RecordType enum_value = RecordType_OSM;
};

template<> struct RecordTypeTraits<PLD> {
  static const RecordType enum_value = RecordType_PLD;
};

template<> struct RecordTypeTraits<PNM> {
  static const RecordType enum_value = RecordType_PNM;
};

template<> struct RecordTypeTraits<PRG> {
  static const RecordType enum_value = RecordType_PRG;
};

template<> struct RecordTypeTraits<RFM> {
  static const RecordType enum_value = RecordType_RFM;
};

template<> struct RecordTypeTraits<ROC> {
  static const RecordType enum_value = RecordType_ROC;
};

template<> struct RecordTypeTraits<SCM> {
  static const RecordType enum_value = RecordType_SCM;
};

template<> struct RecordTypeTraits<SIT> {
  static const RecordType enum_value = RecordType_SIT;
};

template<> struct RecordTypeTraits<TDM> {
  static const RecordType enum_value = RecordType_TDM;
};

template<> struct RecordTypeTraits<TIM> {
  static const RecordType enum_value = RecordType_TIM;
};

template<> struct RecordTypeTraits<VCM> {
  static const RecordType enum_value = RecordType_VCM;
};

bool VerifyRecordType(::flatbuffers::Verifier &verifier, const void *obj, RecordType type);
bool VerifyRecordTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Record FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6,
    VT_STANDARD = 8
  };
  RecordType value_type() const {
    return static_cast<RecordType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ATM *value_as_ATM() const {
    return value_type() == RecordType_ATM ? static_cast<const ATM *>(value()) : nullptr;
  }
  const BOV *value_as_BOV() const {
    return value_type() == RecordType_BOV ? static_cast<const BOV *>(value()) : nullptr;
  }
  const CAT *value_as_CAT() const {
    return value_type() == RecordType_CAT ? static_cast<const CAT *>(value()) : nullptr;
  }
  const CDM *value_as_CDM() const {
    return value_type() == RecordType_CDM ? static_cast<const CDM *>(value()) : nullptr;
  }
  const CRM *value_as_CRM() const {
    return value_type() == RecordType_CRM ? static_cast<const CRM *>(value()) : nullptr;
  }
  const CSM *value_as_CSM() const {
    return value_type() == RecordType_CSM ? static_cast<const CSM *>(value()) : nullptr;
  }
  const CTR *value_as_CTR() const {
    return value_type() == RecordType_CTR ? static_cast<const CTR *>(value()) : nullptr;
  }
  const EME *value_as_EME() const {
    return value_type() == RecordType_EME ? static_cast<const EME *>(value()) : nullptr;
  }
  const EOO *value_as_EOO() const {
    return value_type() == RecordType_EOO ? static_cast<const EOO *>(value()) : nullptr;
  }
  const EOP *value_as_EOP() const {
    return value_type() == RecordType_EOP ? static_cast<const EOP *>(value()) : nullptr;
  }
  const EPM *value_as_EPM() const {
    return value_type() == RecordType_EPM ? static_cast<const EPM *>(value()) : nullptr;
  }
  const HYP *value_as_HYP() const {
    return value_type() == RecordType_HYP ? static_cast<const HYP *>(value()) : nullptr;
  }
  const IDM *value_as_IDM() const {
    return value_type() == RecordType_IDM ? static_cast<const IDM *>(value()) : nullptr;
  }
  const LCC *value_as_LCC() const {
    return value_type() == RecordType_LCC ? static_cast<const LCC *>(value()) : nullptr;
  }
  const LDM *value_as_LDM() const {
    return value_type() == RecordType_LDM ? static_cast<const LDM *>(value()) : nullptr;
  }
  const MET *value_as_MET() const {
    return value_type() == RecordType_MET ? static_cast<const MET *>(value()) : nullptr;
  }
  const MPE *value_as_MPE() const {
    return value_type() == RecordType_MPE ? static_cast<const MPE *>(value()) : nullptr;
  }
  const OCM *value_as_OCM() const {
    return value_type() == RecordType_OCM ? static_cast<const OCM *>(value()) : nullptr;
  }
  const OEM *value_as_OEM() const {
    return value_type() == RecordType_OEM ? static_cast<const OEM *>(value()) : nullptr;
  }
  const OMM *value_as_OMM() const {
    return value_type() == RecordType_OMM ? static_cast<const OMM *>(value()) : nullptr;
  }
  const OSM *value_as_OSM() const {
    return value_type() == RecordType_OSM ? static_cast<const OSM *>(value()) : nullptr;
  }
  const PLD *value_as_PLD() const {
    return value_type() == RecordType_PLD ? static_cast<const PLD *>(value()) : nullptr;
  }
  const PNM *value_as_PNM() const {
    return value_type() == RecordType_PNM ? static_cast<const PNM *>(value()) : nullptr;
  }
  const PRG *value_as_PRG() const {
    return value_type() == RecordType_PRG ? static_cast<const PRG *>(value()) : nullptr;
  }
  const RFM *value_as_RFM() const {
    return value_type() == RecordType_RFM ? static_cast<const RFM *>(value()) : nullptr;
  }
  const ROC *value_as_ROC() const {
    return value_type() == RecordType_ROC ? static_cast<const ROC *>(value()) : nullptr;
  }
  const SCM *value_as_SCM() const {
    return value_type() == RecordType_SCM ? static_cast<const SCM *>(value()) : nullptr;
  }
  const SIT *value_as_SIT() const {
    return value_type() == RecordType_SIT ? static_cast<const SIT *>(value()) : nullptr;
  }
  const TDM *value_as_TDM() const {
    return value_type() == RecordType_TDM ? static_cast<const TDM *>(value()) : nullptr;
  }
  const TIM *value_as_TIM() const {
    return value_type() == RecordType_TIM ? static_cast<const TIM *>(value()) : nullptr;
  }
  const VCM *value_as_VCM() const {
    return value_type() == RecordType_VCM ? static_cast<const VCM *>(value()) : nullptr;
  }
  const ::flatbuffers::String *standard() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STANDARD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyRecordType(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_STANDARD) &&
           verifier.VerifyString(standard()) &&
           verifier.EndTable();
  }
};

template<> inline const ATM *Record::value_as<ATM>() const {
  return value_as_ATM();
}

template<> inline const BOV *Record::value_as<BOV>() const {
  return value_as_BOV();
}

template<> inline const CAT *Record::value_as<CAT>() const {
  return value_as_CAT();
}

template<> inline const CDM *Record::value_as<CDM>() const {
  return value_as_CDM();
}

template<> inline const CRM *Record::value_as<CRM>() const {
  return value_as_CRM();
}

template<> inline const CSM *Record::value_as<CSM>() const {
  return value_as_CSM();
}

template<> inline const CTR *Record::value_as<CTR>() const {
  return value_as_CTR();
}

template<> inline const EME *Record::value_as<EME>() const {
  return value_as_EME();
}

template<> inline const EOO *Record::value_as<EOO>() const {
  return value_as_EOO();
}

template<> inline const EOP *Record::value_as<EOP>() const {
  return value_as_EOP();
}

template<> inline const EPM *Record::value_as<EPM>() const {
  return value_as_EPM();
}

template<> inline const HYP *Record::value_as<HYP>() const {
  return value_as_HYP();
}

template<> inline const IDM *Record::value_as<IDM>() const {
  return value_as_IDM();
}

template<> inline const LCC *Record::value_as<LCC>() const {
  return value_as_LCC();
}

template<> inline const LDM *Record::value_as<LDM>() const {
  return value_as_LDM();
}

template<> inline const MET *Record::value_as<MET>() const {
  return value_as_MET();
}

template<> inline const MPE *Record::value_as<MPE>() const {
  return value_as_MPE();
}

template<> inline const OCM *Record::value_as<OCM>() const {
  return value_as_OCM();
}

template<> inline const OEM *Record::value_as<OEM>() const {
  return value_as_OEM();
}

template<> inline const OMM *Record::value_as<OMM>() const {
  return value_as_OMM();
}

template<> inline const OSM *Record::value_as<OSM>() const {
  return value_as_OSM();
}

template<> inline const PLD *Record::value_as<PLD>() const {
  return value_as_PLD();
}

template<> inline const PNM *Record::value_as<PNM>() const {
  return value_as_PNM();
}

template<> inline const PRG *Record::value_as<PRG>() const {
  return value_as_PRG();
}

template<> inline const RFM *Record::value_as<RFM>() const {
  return value_as_RFM();
}

template<> inline const ROC *Record::value_as<ROC>() const {
  return value_as_ROC();
}

template<> inline const SCM *Record::value_as<SCM>() const {
  return value_as_SCM();
}

template<> inline const SIT *Record::value_as<SIT>() const {
  return value_as_SIT();
}

template<> inline const TDM *Record::value_as<TDM>() const {
  return value_as_TDM();
}

template<> inline const TIM *Record::value_as<TIM>() const {
  return value_as_TIM();
}

template<> inline const VCM *Record::value_as<VCM>() const {
  return value_as_VCM();
}

struct RecordBuilder {
  typedef Record Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(RecordType value_type) {
    fbb_.AddElement<uint8_t>(Record::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Record::VT_VALUE, value);
  }
  void add_standard(::flatbuffers::Offset<::flatbuffers::String> standard) {
    fbb_.AddOffset(Record::VT_STANDARD, standard);
  }
  explicit RecordBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Record> CreateRecord(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    RecordType value_type = RecordType_NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> standard = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_standard(standard);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Record> CreateRecordDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    RecordType value_type = RecordType_NONE,
    ::flatbuffers::Offset<void> value = 0,
    const char *standard = nullptr) {
  auto standard__ = standard ? _fbb.CreateString(standard) : 0;
  return CreateRecord(
      _fbb,
      value_type,
      value,
      standard__);
}

/// Collection of Standard Records
struct REC FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RECBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_RECORDS = 6
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Record>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Record>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct RECBuilder {
  typedef REC Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(REC::VT_VERSION, version);
  }
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Record>>> RECORDS) {
    fbb_.AddOffset(REC::VT_RECORDS, RECORDS);
  }
  explicit RECBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<REC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<REC>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<REC> CreateREC(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Record>>> RECORDS = 0) {
  RECBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  builder_.add_version(version);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<REC> CreateRECDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<Record>> *RECORDS = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<Record>>(*RECORDS) : 0;
  return CreateREC(
      _fbb,
      version__,
      RECORDS__);
}

inline bool VerifyRecordType(::flatbuffers::Verifier &verifier, const void *obj, RecordType type) {
  switch (type) {
    case RecordType_NONE: {
      return true;
    }
    case RecordType_ATM: {
      auto ptr = reinterpret_cast<const ATM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_BOV: {
      auto ptr = reinterpret_cast<const BOV *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_CAT: {
      auto ptr = reinterpret_cast<const CAT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_CDM: {
      auto ptr = reinterpret_cast<const CDM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_CRM: {
      auto ptr = reinterpret_cast<const CRM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_CSM: {
      auto ptr = reinterpret_cast<const CSM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_CTR: {
      auto ptr = reinterpret_cast<const CTR *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_EME: {
      auto ptr = reinterpret_cast<const EME *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_EOO: {
      auto ptr = reinterpret_cast<const EOO *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_EOP: {
      auto ptr = reinterpret_cast<const EOP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_EPM: {
      auto ptr = reinterpret_cast<const EPM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_HYP: {
      auto ptr = reinterpret_cast<const HYP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_IDM: {
      auto ptr = reinterpret_cast<const IDM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_LCC: {
      auto ptr = reinterpret_cast<const LCC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_LDM: {
      auto ptr = reinterpret_cast<const LDM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_MET: {
      auto ptr = reinterpret_cast<const MET *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_MPE: {
      auto ptr = reinterpret_cast<const MPE *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_OCM: {
      auto ptr = reinterpret_cast<const OCM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_OEM: {
      auto ptr = reinterpret_cast<const OEM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_OMM: {
      auto ptr = reinterpret_cast<const OMM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_OSM: {
      auto ptr = reinterpret_cast<const OSM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_PLD: {
      auto ptr = reinterpret_cast<const PLD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_PNM: {
      auto ptr = reinterpret_cast<const PNM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_PRG: {
      auto ptr = reinterpret_cast<const PRG *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_RFM: {
      auto ptr = reinterpret_cast<const RFM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_ROC: {
      auto ptr = reinterpret_cast<const ROC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_SCM: {
      auto ptr = reinterpret_cast<const SCM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_SIT: {
      auto ptr = reinterpret_cast<const SIT *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_TDM: {
      auto ptr = reinterpret_cast<const TDM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_TIM: {
      auto ptr = reinterpret_cast<const TIM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RecordType_VCM: {
      auto ptr = reinterpret_cast<const VCM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRecordTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRecordType(
        verifier,  values->Get(i), types->GetEnum<RecordType>(i))) {
      return false;
    }
  }
  return true;
}

inline const REC *GetREC(const void *buf) {
  return ::flatbuffers::GetRoot<REC>(buf);
}

inline const REC *GetSizePrefixedREC(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<REC>(buf);
}

inline const char *RECIdentifier() {
  return "$REC";
}

inline bool RECBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RECIdentifier());
}

inline bool SizePrefixedRECBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RECIdentifier(), true);
}

inline bool VerifyRECBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<REC>(RECIdentifier());
}

inline bool VerifySizePrefixedRECBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<REC>(RECIdentifier());
}

inline void FinishRECBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<REC> root) {
  fbb.Finish(root, RECIdentifier());
}

inline void FinishSizePrefixedRECBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<REC> root) {
  fbb.FinishSizePrefixed(root, RECIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
