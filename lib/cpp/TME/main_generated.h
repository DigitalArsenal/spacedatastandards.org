// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TME;
struct TMEBuilder;

enum TimeScale : int8_t {
  TimeScale_UTC = 0,
  TimeScale_TAI = 1,
  TimeScale_TT = 2,
  TimeScale_TDB = 3,
  TimeScale_TCG = 4,
  TimeScale_TCB = 5,
  TimeScale_GPS = 6,
  TimeScale_GLONASS = 7,
  TimeScale_GALILEO = 8,
  TimeScale_BEIDOU = 9,
  TimeScale_UT1 = 10,
  TimeScale_LOCAL_MEAN_SOLAR = 11,
  TimeScale_LOCAL_APPARENT_SOLAR = 12,
  TimeScale_SIDEREAL = 13,
  TimeScale_MIN = TimeScale_UTC,
  TimeScale_MAX = TimeScale_SIDEREAL
};

inline const TimeScale (&EnumValuesTimeScale())[14] {
  static const TimeScale values[] = {
    TimeScale_UTC,
    TimeScale_TAI,
    TimeScale_TT,
    TimeScale_TDB,
    TimeScale_TCG,
    TimeScale_TCB,
    TimeScale_GPS,
    TimeScale_GLONASS,
    TimeScale_GALILEO,
    TimeScale_BEIDOU,
    TimeScale_UT1,
    TimeScale_LOCAL_MEAN_SOLAR,
    TimeScale_LOCAL_APPARENT_SOLAR,
    TimeScale_SIDEREAL
  };
  return values;
}

inline const char * const *EnumNamesTimeScale() {
  static const char * const names[15] = {
    "UTC",
    "TAI",
    "TT",
    "TDB",
    "TCG",
    "TCB",
    "GPS",
    "GLONASS",
    "GALILEO",
    "BEIDOU",
    "UT1",
    "LOCAL_MEAN_SOLAR",
    "LOCAL_APPARENT_SOLAR",
    "SIDEREAL",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeScale(TimeScale e) {
  if (::flatbuffers::IsOutRange(e, TimeScale_UTC, TimeScale_SIDEREAL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeScale()[index];
}

enum DateFormat : int8_t {
  DateFormat_ISO8601 = 0,
  DateFormat_JULIAN_DATE = 1,
  DateFormat_MODIFIED_JULIAN_DATE = 2,
  DateFormat_GPS_WEEK_SOW = 3,
  DateFormat_YEAR_DOY = 4,
  DateFormat_UNIX_EPOCH = 5,
  DateFormat_MISSION_ELAPSED = 6,
  DateFormat_MIN = DateFormat_ISO8601,
  DateFormat_MAX = DateFormat_MISSION_ELAPSED
};

inline const DateFormat (&EnumValuesDateFormat())[7] {
  static const DateFormat values[] = {
    DateFormat_ISO8601,
    DateFormat_JULIAN_DATE,
    DateFormat_MODIFIED_JULIAN_DATE,
    DateFormat_GPS_WEEK_SOW,
    DateFormat_YEAR_DOY,
    DateFormat_UNIX_EPOCH,
    DateFormat_MISSION_ELAPSED
  };
  return values;
}

inline const char * const *EnumNamesDateFormat() {
  static const char * const names[8] = {
    "ISO8601",
    "JULIAN_DATE",
    "MODIFIED_JULIAN_DATE",
    "GPS_WEEK_SOW",
    "YEAR_DOY",
    "UNIX_EPOCH",
    "MISSION_ELAPSED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateFormat(DateFormat e) {
  if (::flatbuffers::IsOutRange(e, DateFormat_ISO8601, DateFormat_MISSION_ELAPSED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateFormat()[index];
}

enum ClockType : int8_t {
  ClockType_CESIUM = 0,
  ClockType_RUBIDIUM = 1,
  ClockType_QUARTZ_TCXO = 2,
  ClockType_QUARTZ_OCXO = 3,
  ClockType_HYDROGEN_MASER = 4,
  ClockType_GPS_DISCIPLINED = 5,
  ClockType_MIN = ClockType_CESIUM,
  ClockType_MAX = ClockType_GPS_DISCIPLINED
};

inline const ClockType (&EnumValuesClockType())[6] {
  static const ClockType values[] = {
    ClockType_CESIUM,
    ClockType_RUBIDIUM,
    ClockType_QUARTZ_TCXO,
    ClockType_QUARTZ_OCXO,
    ClockType_HYDROGEN_MASER,
    ClockType_GPS_DISCIPLINED
  };
  return values;
}

inline const char * const *EnumNamesClockType() {
  static const char * const names[7] = {
    "CESIUM",
    "RUBIDIUM",
    "QUARTZ_TCXO",
    "QUARTZ_OCXO",
    "HYDROGEN_MASER",
    "GPS_DISCIPLINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameClockType(ClockType e) {
  if (::flatbuffers::IsOutRange(e, ClockType_CESIUM, ClockType_GPS_DISCIPLINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClockType()[index];
}

/// Time Systems
struct TME FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TMEBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND = 4,
    VT_CONVERSION_REQUEST = 6,
    VT_LEAP_SECOND_QUERY = 8,
    VT_EOP_QUERY = 10,
    VT_SIDEREAL_QUERY = 12,
    VT_INTERVAL_REQUEST = 14,
    VT_SOLAR_POSITION_QUERY = 16,
    VT_LUNAR_POSITION_QUERY = 18,
    VT_SUNRISE_SUNSET_QUERY = 20,
    VT_CLOCK_PROPAGATION = 22
  };
  const ::flatbuffers::String *COMMAND() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMAND);
  }
  const ::flatbuffers::String *CONVERSION_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONVERSION_REQUEST);
  }
  const ::flatbuffers::String *LEAP_SECOND_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LEAP_SECOND_QUERY);
  }
  const ::flatbuffers::String *EOP_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EOP_QUERY);
  }
  const ::flatbuffers::String *SIDEREAL_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIDEREAL_QUERY);
  }
  const ::flatbuffers::String *INTERVAL_REQUEST() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERVAL_REQUEST);
  }
  const ::flatbuffers::String *SOLAR_POSITION_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOLAR_POSITION_QUERY);
  }
  const ::flatbuffers::String *LUNAR_POSITION_QUERY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LUNAR_POSITION_QUERY);
  }
  const ::flatbuffers::Vector<double> *SUNRISE_SUNSET_QUERY() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_SUNRISE_SUNSET_QUERY);
  }
  const ::flatbuffers::String *CLOCK_PROPAGATION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLOCK_PROPAGATION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyString(COMMAND()) &&
           VerifyOffset(verifier, VT_CONVERSION_REQUEST) &&
           verifier.VerifyString(CONVERSION_REQUEST()) &&
           VerifyOffset(verifier, VT_LEAP_SECOND_QUERY) &&
           verifier.VerifyString(LEAP_SECOND_QUERY()) &&
           VerifyOffset(verifier, VT_EOP_QUERY) &&
           verifier.VerifyString(EOP_QUERY()) &&
           VerifyOffset(verifier, VT_SIDEREAL_QUERY) &&
           verifier.VerifyString(SIDEREAL_QUERY()) &&
           VerifyOffset(verifier, VT_INTERVAL_REQUEST) &&
           verifier.VerifyString(INTERVAL_REQUEST()) &&
           VerifyOffset(verifier, VT_SOLAR_POSITION_QUERY) &&
           verifier.VerifyString(SOLAR_POSITION_QUERY()) &&
           VerifyOffset(verifier, VT_LUNAR_POSITION_QUERY) &&
           verifier.VerifyString(LUNAR_POSITION_QUERY()) &&
           VerifyOffset(verifier, VT_SUNRISE_SUNSET_QUERY) &&
           verifier.VerifyVector(SUNRISE_SUNSET_QUERY()) &&
           VerifyOffset(verifier, VT_CLOCK_PROPAGATION) &&
           verifier.VerifyString(CLOCK_PROPAGATION()) &&
           verifier.EndTable();
  }
};

struct TMEBuilder {
  typedef TME Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_COMMAND(::flatbuffers::Offset<::flatbuffers::String> COMMAND) {
    fbb_.AddOffset(TME::VT_COMMAND, COMMAND);
  }
  void add_CONVERSION_REQUEST(::flatbuffers::Offset<::flatbuffers::String> CONVERSION_REQUEST) {
    fbb_.AddOffset(TME::VT_CONVERSION_REQUEST, CONVERSION_REQUEST);
  }
  void add_LEAP_SECOND_QUERY(::flatbuffers::Offset<::flatbuffers::String> LEAP_SECOND_QUERY) {
    fbb_.AddOffset(TME::VT_LEAP_SECOND_QUERY, LEAP_SECOND_QUERY);
  }
  void add_EOP_QUERY(::flatbuffers::Offset<::flatbuffers::String> EOP_QUERY) {
    fbb_.AddOffset(TME::VT_EOP_QUERY, EOP_QUERY);
  }
  void add_SIDEREAL_QUERY(::flatbuffers::Offset<::flatbuffers::String> SIDEREAL_QUERY) {
    fbb_.AddOffset(TME::VT_SIDEREAL_QUERY, SIDEREAL_QUERY);
  }
  void add_INTERVAL_REQUEST(::flatbuffers::Offset<::flatbuffers::String> INTERVAL_REQUEST) {
    fbb_.AddOffset(TME::VT_INTERVAL_REQUEST, INTERVAL_REQUEST);
  }
  void add_SOLAR_POSITION_QUERY(::flatbuffers::Offset<::flatbuffers::String> SOLAR_POSITION_QUERY) {
    fbb_.AddOffset(TME::VT_SOLAR_POSITION_QUERY, SOLAR_POSITION_QUERY);
  }
  void add_LUNAR_POSITION_QUERY(::flatbuffers::Offset<::flatbuffers::String> LUNAR_POSITION_QUERY) {
    fbb_.AddOffset(TME::VT_LUNAR_POSITION_QUERY, LUNAR_POSITION_QUERY);
  }
  void add_SUNRISE_SUNSET_QUERY(::flatbuffers::Offset<::flatbuffers::Vector<double>> SUNRISE_SUNSET_QUERY) {
    fbb_.AddOffset(TME::VT_SUNRISE_SUNSET_QUERY, SUNRISE_SUNSET_QUERY);
  }
  void add_CLOCK_PROPAGATION(::flatbuffers::Offset<::flatbuffers::String> CLOCK_PROPAGATION) {
    fbb_.AddOffset(TME::VT_CLOCK_PROPAGATION, CLOCK_PROPAGATION);
  }
  explicit TMEBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TME>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TME> CreateTME(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> COMMAND = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CONVERSION_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LEAP_SECOND_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> EOP_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SIDEREAL_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> INTERVAL_REQUEST = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOLAR_POSITION_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> LUNAR_POSITION_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> SUNRISE_SUNSET_QUERY = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLOCK_PROPAGATION = 0) {
  TMEBuilder builder_(_fbb);
  builder_.add_CLOCK_PROPAGATION(CLOCK_PROPAGATION);
  builder_.add_SUNRISE_SUNSET_QUERY(SUNRISE_SUNSET_QUERY);
  builder_.add_LUNAR_POSITION_QUERY(LUNAR_POSITION_QUERY);
  builder_.add_SOLAR_POSITION_QUERY(SOLAR_POSITION_QUERY);
  builder_.add_INTERVAL_REQUEST(INTERVAL_REQUEST);
  builder_.add_SIDEREAL_QUERY(SIDEREAL_QUERY);
  builder_.add_EOP_QUERY(EOP_QUERY);
  builder_.add_LEAP_SECOND_QUERY(LEAP_SECOND_QUERY);
  builder_.add_CONVERSION_REQUEST(CONVERSION_REQUEST);
  builder_.add_COMMAND(COMMAND);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TME> CreateTMEDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *COMMAND = nullptr,
    const char *CONVERSION_REQUEST = nullptr,
    const char *LEAP_SECOND_QUERY = nullptr,
    const char *EOP_QUERY = nullptr,
    const char *SIDEREAL_QUERY = nullptr,
    const char *INTERVAL_REQUEST = nullptr,
    const char *SOLAR_POSITION_QUERY = nullptr,
    const char *LUNAR_POSITION_QUERY = nullptr,
    const std::vector<double> *SUNRISE_SUNSET_QUERY = nullptr,
    const char *CLOCK_PROPAGATION = nullptr) {
  auto COMMAND__ = COMMAND ? _fbb.CreateString(COMMAND) : 0;
  auto CONVERSION_REQUEST__ = CONVERSION_REQUEST ? _fbb.CreateString(CONVERSION_REQUEST) : 0;
  auto LEAP_SECOND_QUERY__ = LEAP_SECOND_QUERY ? _fbb.CreateString(LEAP_SECOND_QUERY) : 0;
  auto EOP_QUERY__ = EOP_QUERY ? _fbb.CreateString(EOP_QUERY) : 0;
  auto SIDEREAL_QUERY__ = SIDEREAL_QUERY ? _fbb.CreateString(SIDEREAL_QUERY) : 0;
  auto INTERVAL_REQUEST__ = INTERVAL_REQUEST ? _fbb.CreateString(INTERVAL_REQUEST) : 0;
  auto SOLAR_POSITION_QUERY__ = SOLAR_POSITION_QUERY ? _fbb.CreateString(SOLAR_POSITION_QUERY) : 0;
  auto LUNAR_POSITION_QUERY__ = LUNAR_POSITION_QUERY ? _fbb.CreateString(LUNAR_POSITION_QUERY) : 0;
  auto SUNRISE_SUNSET_QUERY__ = SUNRISE_SUNSET_QUERY ? _fbb.CreateVector<double>(*SUNRISE_SUNSET_QUERY) : 0;
  auto CLOCK_PROPAGATION__ = CLOCK_PROPAGATION ? _fbb.CreateString(CLOCK_PROPAGATION) : 0;
  return CreateTME(
      _fbb,
      COMMAND__,
      CONVERSION_REQUEST__,
      LEAP_SECOND_QUERY__,
      EOP_QUERY__,
      SIDEREAL_QUERY__,
      INTERVAL_REQUEST__,
      SOLAR_POSITION_QUERY__,
      LUNAR_POSITION_QUERY__,
      SUNRISE_SUNSET_QUERY__,
      CLOCK_PROPAGATION__);
}

inline const TME *GetTME(const void *buf) {
  return ::flatbuffers::GetRoot<TME>(buf);
}

inline const TME *GetSizePrefixedTME(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TME>(buf);
}

inline const char *TMEIdentifier() {
  return "$TME";
}

inline bool TMEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TMEIdentifier());
}

inline bool SizePrefixedTMEBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TMEIdentifier(), true);
}

inline bool VerifyTMEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TME>(TMEIdentifier());
}

inline bool VerifySizePrefixedTMEBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TME>(TMEIdentifier());
}

inline void FinishTMEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TME> root) {
  fbb.Finish(root, TMEIdentifier());
}

inline void FinishSizePrefixedTMEBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TME> root) {
  fbb.FinishSizePrefixed(root, TMEIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
