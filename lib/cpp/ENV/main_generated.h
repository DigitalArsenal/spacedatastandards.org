// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ENV;
struct ENVBuilder;

enum AtmosphereModel : int8_t {
  AtmosphereModel_ISA = 0,
  AtmosphereModel_US_STD_1976 = 1,
  AtmosphereModel_NRLMSISE_00 = 2,
  AtmosphereModel_SIMPLE = 3,
  AtmosphereModel_CUSTOM = 4,
  AtmosphereModel_MIN = AtmosphereModel_ISA,
  AtmosphereModel_MAX = AtmosphereModel_CUSTOM
};

inline const AtmosphereModel (&EnumValuesAtmosphereModel())[5] {
  static const AtmosphereModel values[] = {
    AtmosphereModel_ISA,
    AtmosphereModel_US_STD_1976,
    AtmosphereModel_NRLMSISE_00,
    AtmosphereModel_SIMPLE,
    AtmosphereModel_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesAtmosphereModel() {
  static const char * const names[6] = {
    "ISA",
    "US_STD_1976",
    "NRLMSISE_00",
    "SIMPLE",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameAtmosphereModel(AtmosphereModel e) {
  if (::flatbuffers::IsOutRange(e, AtmosphereModel_ISA, AtmosphereModel_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAtmosphereModel()[index];
}

enum WeatherCondition : int8_t {
  WeatherCondition_CLEAR = 0,
  WeatherCondition_FEW_CLOUDS = 1,
  WeatherCondition_SCATTERED = 2,
  WeatherCondition_BROKEN = 3,
  WeatherCondition_OVERCAST = 4,
  WeatherCondition_RAIN_LIGHT = 5,
  WeatherCondition_RAIN_MODERATE = 6,
  WeatherCondition_RAIN_HEAVY = 7,
  WeatherCondition_SNOW_LIGHT = 8,
  WeatherCondition_SNOW_MODERATE = 9,
  WeatherCondition_SNOW_HEAVY = 10,
  WeatherCondition_FOG = 11,
  WeatherCondition_MIST = 12,
  WeatherCondition_HAZE = 13,
  WeatherCondition_THUNDERSTORM = 14,
  WeatherCondition_SANDSTORM = 15,
  WeatherCondition_MIN = WeatherCondition_CLEAR,
  WeatherCondition_MAX = WeatherCondition_SANDSTORM
};

inline const WeatherCondition (&EnumValuesWeatherCondition())[16] {
  static const WeatherCondition values[] = {
    WeatherCondition_CLEAR,
    WeatherCondition_FEW_CLOUDS,
    WeatherCondition_SCATTERED,
    WeatherCondition_BROKEN,
    WeatherCondition_OVERCAST,
    WeatherCondition_RAIN_LIGHT,
    WeatherCondition_RAIN_MODERATE,
    WeatherCondition_RAIN_HEAVY,
    WeatherCondition_SNOW_LIGHT,
    WeatherCondition_SNOW_MODERATE,
    WeatherCondition_SNOW_HEAVY,
    WeatherCondition_FOG,
    WeatherCondition_MIST,
    WeatherCondition_HAZE,
    WeatherCondition_THUNDERSTORM,
    WeatherCondition_SANDSTORM
  };
  return values;
}

inline const char * const *EnumNamesWeatherCondition() {
  static const char * const names[17] = {
    "CLEAR",
    "FEW_CLOUDS",
    "SCATTERED",
    "BROKEN",
    "OVERCAST",
    "RAIN_LIGHT",
    "RAIN_MODERATE",
    "RAIN_HEAVY",
    "SNOW_LIGHT",
    "SNOW_MODERATE",
    "SNOW_HEAVY",
    "FOG",
    "MIST",
    "HAZE",
    "THUNDERSTORM",
    "SANDSTORM",
    nullptr
  };
  return names;
}

inline const char *EnumNameWeatherCondition(WeatherCondition e) {
  if (::flatbuffers::IsOutRange(e, WeatherCondition_CLEAR, WeatherCondition_SANDSTORM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWeatherCondition()[index];
}

enum TerrainType : int8_t {
  TerrainType_OCEAN = 0,
  TerrainType_WATER_FRESH = 1,
  TerrainType_SAND = 2,
  TerrainType_GRASS = 3,
  TerrainType_FOREST = 4,
  TerrainType_CONCRETE = 5,
  TerrainType_ASPHALT = 6,
  TerrainType_SNOW = 7,
  TerrainType_ICE = 8,
  TerrainType_ROCK = 9,
  TerrainType_MARSH = 10,
  TerrainType_URBAN = 11,
  TerrainType_MIN = TerrainType_OCEAN,
  TerrainType_MAX = TerrainType_URBAN
};

inline const TerrainType (&EnumValuesTerrainType())[12] {
  static const TerrainType values[] = {
    TerrainType_OCEAN,
    TerrainType_WATER_FRESH,
    TerrainType_SAND,
    TerrainType_GRASS,
    TerrainType_FOREST,
    TerrainType_CONCRETE,
    TerrainType_ASPHALT,
    TerrainType_SNOW,
    TerrainType_ICE,
    TerrainType_ROCK,
    TerrainType_MARSH,
    TerrainType_URBAN
  };
  return values;
}

inline const char * const *EnumNamesTerrainType() {
  static const char * const names[13] = {
    "OCEAN",
    "WATER_FRESH",
    "SAND",
    "GRASS",
    "FOREST",
    "CONCRETE",
    "ASPHALT",
    "SNOW",
    "ICE",
    "ROCK",
    "MARSH",
    "URBAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerrainType(TerrainType e) {
  if (::flatbuffers::IsOutRange(e, TerrainType_OCEAN, TerrainType_URBAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerrainType()[index];
}

/// Atmosphere and Environment
struct ENV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ENVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATMOSPHERE = 4,
    VT_WEATHER = 6,
    VT_TIME_UTC = 8,
    VT_LATITUDE = 10,
    VT_LONGITUDE = 12,
    VT_SUN_AZIMUTH = 14,
    VT_SUN_ELEVATION = 16,
    VT_MOON_PHASE = 18,
    VT_ILLUMINATION = 20,
    VT_MAGNETIC_DECLINATION = 22,
    VT_MAGNETIC_INCLINATION = 24,
    VT_RESERVED = 26
  };
  const ::flatbuffers::String *ATMOSPHERE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATMOSPHERE);
  }
  const ::flatbuffers::String *WEATHER() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEATHER);
  }
  double TIME_UTC() const {
    return GetField<double>(VT_TIME_UTC, 0.0);
  }
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  float SUN_AZIMUTH() const {
    return GetField<float>(VT_SUN_AZIMUTH, 0.0f);
  }
  float SUN_ELEVATION() const {
    return GetField<float>(VT_SUN_ELEVATION, 0.0f);
  }
  float MOON_PHASE() const {
    return GetField<float>(VT_MOON_PHASE, 0.0f);
  }
  float ILLUMINATION() const {
    return GetField<float>(VT_ILLUMINATION, 0.0f);
  }
  float MAGNETIC_DECLINATION() const {
    return GetField<float>(VT_MAGNETIC_DECLINATION, 0.0f);
  }
  float MAGNETIC_INCLINATION() const {
    return GetField<float>(VT_MAGNETIC_INCLINATION, 0.0f);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATMOSPHERE) &&
           verifier.VerifyString(ATMOSPHERE()) &&
           VerifyOffset(verifier, VT_WEATHER) &&
           verifier.VerifyString(WEATHER()) &&
           VerifyField<double>(verifier, VT_TIME_UTC, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<float>(verifier, VT_SUN_AZIMUTH, 4) &&
           VerifyField<float>(verifier, VT_SUN_ELEVATION, 4) &&
           VerifyField<float>(verifier, VT_MOON_PHASE, 4) &&
           VerifyField<float>(verifier, VT_ILLUMINATION, 4) &&
           VerifyField<float>(verifier, VT_MAGNETIC_DECLINATION, 4) &&
           VerifyField<float>(verifier, VT_MAGNETIC_INCLINATION, 4) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct ENVBuilder {
  typedef ENV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ATMOSPHERE(::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERE) {
    fbb_.AddOffset(ENV::VT_ATMOSPHERE, ATMOSPHERE);
  }
  void add_WEATHER(::flatbuffers::Offset<::flatbuffers::String> WEATHER) {
    fbb_.AddOffset(ENV::VT_WEATHER, WEATHER);
  }
  void add_TIME_UTC(double TIME_UTC) {
    fbb_.AddElement<double>(ENV::VT_TIME_UTC, TIME_UTC, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(ENV::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(ENV::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_SUN_AZIMUTH(float SUN_AZIMUTH) {
    fbb_.AddElement<float>(ENV::VT_SUN_AZIMUTH, SUN_AZIMUTH, 0.0f);
  }
  void add_SUN_ELEVATION(float SUN_ELEVATION) {
    fbb_.AddElement<float>(ENV::VT_SUN_ELEVATION, SUN_ELEVATION, 0.0f);
  }
  void add_MOON_PHASE(float MOON_PHASE) {
    fbb_.AddElement<float>(ENV::VT_MOON_PHASE, MOON_PHASE, 0.0f);
  }
  void add_ILLUMINATION(float ILLUMINATION) {
    fbb_.AddElement<float>(ENV::VT_ILLUMINATION, ILLUMINATION, 0.0f);
  }
  void add_MAGNETIC_DECLINATION(float MAGNETIC_DECLINATION) {
    fbb_.AddElement<float>(ENV::VT_MAGNETIC_DECLINATION, MAGNETIC_DECLINATION, 0.0f);
  }
  void add_MAGNETIC_INCLINATION(float MAGNETIC_INCLINATION) {
    fbb_.AddElement<float>(ENV::VT_MAGNETIC_INCLINATION, MAGNETIC_INCLINATION, 0.0f);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(ENV::VT_RESERVED, RESERVED);
  }
  explicit ENVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ENV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ENV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ENV> CreateENV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ATMOSPHERE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> WEATHER = 0,
    double TIME_UTC = 0.0,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    float SUN_AZIMUTH = 0.0f,
    float SUN_ELEVATION = 0.0f,
    float MOON_PHASE = 0.0f,
    float ILLUMINATION = 0.0f,
    float MAGNETIC_DECLINATION = 0.0f,
    float MAGNETIC_INCLINATION = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  ENVBuilder builder_(_fbb);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_TIME_UTC(TIME_UTC);
  builder_.add_RESERVED(RESERVED);
  builder_.add_MAGNETIC_INCLINATION(MAGNETIC_INCLINATION);
  builder_.add_MAGNETIC_DECLINATION(MAGNETIC_DECLINATION);
  builder_.add_ILLUMINATION(ILLUMINATION);
  builder_.add_MOON_PHASE(MOON_PHASE);
  builder_.add_SUN_ELEVATION(SUN_ELEVATION);
  builder_.add_SUN_AZIMUTH(SUN_AZIMUTH);
  builder_.add_WEATHER(WEATHER);
  builder_.add_ATMOSPHERE(ATMOSPHERE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ENV> CreateENVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ATMOSPHERE = nullptr,
    const char *WEATHER = nullptr,
    double TIME_UTC = 0.0,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    float SUN_AZIMUTH = 0.0f,
    float SUN_ELEVATION = 0.0f,
    float MOON_PHASE = 0.0f,
    float ILLUMINATION = 0.0f,
    float MAGNETIC_DECLINATION = 0.0f,
    float MAGNETIC_INCLINATION = 0.0f,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto ATMOSPHERE__ = ATMOSPHERE ? _fbb.CreateString(ATMOSPHERE) : 0;
  auto WEATHER__ = WEATHER ? _fbb.CreateString(WEATHER) : 0;
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateENV(
      _fbb,
      ATMOSPHERE__,
      WEATHER__,
      TIME_UTC,
      LATITUDE,
      LONGITUDE,
      SUN_AZIMUTH,
      SUN_ELEVATION,
      MOON_PHASE,
      ILLUMINATION,
      MAGNETIC_DECLINATION,
      MAGNETIC_INCLINATION,
      RESERVED__);
}

inline const ENV *GetENV(const void *buf) {
  return ::flatbuffers::GetRoot<ENV>(buf);
}

inline const ENV *GetSizePrefixedENV(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ENV>(buf);
}

inline const char *ENVIdentifier() {
  return "$ENV";
}

inline bool ENVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ENVIdentifier());
}

inline bool SizePrefixedENVBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ENVIdentifier(), true);
}

inline bool VerifyENVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ENV>(ENVIdentifier());
}

inline bool VerifySizePrefixedENVBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ENV>(ENVIdentifier());
}

inline void FinishENVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ENV> root) {
  fbb.Finish(root, ENVIdentifier());
}

inline void FinishSizePrefixedENVBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ENV> root) {
  fbb.FinishSizePrefixed(root, ENVIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
