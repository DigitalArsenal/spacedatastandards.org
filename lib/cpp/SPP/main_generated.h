// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SPP;
struct SPPBuilder;

enum packetType : int8_t {
  packetType_TM = 0,
  packetType_TC = 1,
  packetType_MIN = packetType_TM,
  packetType_MAX = packetType_TC
};

inline const packetType (&EnumValuespacketType())[2] {
  static const packetType values[] = {
    packetType_TM,
    packetType_TC
  };
  return values;
}

inline const char * const *EnumNamespacketType() {
  static const char * const names[3] = {
    "TM",
    "TC",
    nullptr
  };
  return names;
}

inline const char *EnumNamepacketType(packetType e) {
  if (::flatbuffers::IsOutRange(e, packetType_TM, packetType_TC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamespacketType()[index];
}

/// Space Packet Protocol (CCSDS 133.0-B-1)
struct SPP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SPPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_PACKET_TYPE = 6,
    VT_SEC_HDR_FLAG = 8,
    VT_APID = 10,
    VT_SEQUENCE_FLAGS = 12,
    VT_SEQUENCE_COUNT = 14,
    VT_DATA_LENGTH = 16,
    VT_DATA = 18
  };
  /// Packet version number
  uint8_t VERSION() const {
    return GetField<uint8_t>(VT_VERSION, 0);
  }
  /// Packet type (TM or TC)
  packetType PACKET_TYPE() const {
    return static_cast<packetType>(GetField<int8_t>(VT_PACKET_TYPE, 0));
  }
  /// Secondary header flag
  bool SEC_HDR_FLAG() const {
    return GetField<uint8_t>(VT_SEC_HDR_FLAG, 0) != 0;
  }
  /// Application Process Identifier
  uint16_t APID() const {
    return GetField<uint16_t>(VT_APID, 0);
  }
  /// Sequence flags (00=continuation, 01=first, 10=last, 11=standalone)
  uint8_t SEQUENCE_FLAGS() const {
    return GetField<uint8_t>(VT_SEQUENCE_FLAGS, 0);
  }
  /// Sequence count
  uint16_t SEQUENCE_COUNT() const {
    return GetField<uint16_t>(VT_SEQUENCE_COUNT, 0);
  }
  /// Data length minus 1
  uint16_t DATA_LENGTH() const {
    return GetField<uint16_t>(VT_DATA_LENGTH, 0);
  }
  /// Packet data zone
  const ::flatbuffers::Vector<uint8_t> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION, 1) &&
           VerifyField<int8_t>(verifier, VT_PACKET_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SEC_HDR_FLAG, 1) &&
           VerifyField<uint16_t>(verifier, VT_APID, 2) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE_FLAGS, 1) &&
           VerifyField<uint16_t>(verifier, VT_SEQUENCE_COUNT, 2) &&
           VerifyField<uint16_t>(verifier, VT_DATA_LENGTH, 2) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           verifier.EndTable();
  }
};

struct SPPBuilder {
  typedef SPP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(uint8_t VERSION) {
    fbb_.AddElement<uint8_t>(SPP::VT_VERSION, VERSION, 0);
  }
  void add_PACKET_TYPE(packetType PACKET_TYPE) {
    fbb_.AddElement<int8_t>(SPP::VT_PACKET_TYPE, static_cast<int8_t>(PACKET_TYPE), 0);
  }
  void add_SEC_HDR_FLAG(bool SEC_HDR_FLAG) {
    fbb_.AddElement<uint8_t>(SPP::VT_SEC_HDR_FLAG, static_cast<uint8_t>(SEC_HDR_FLAG), 0);
  }
  void add_APID(uint16_t APID) {
    fbb_.AddElement<uint16_t>(SPP::VT_APID, APID, 0);
  }
  void add_SEQUENCE_FLAGS(uint8_t SEQUENCE_FLAGS) {
    fbb_.AddElement<uint8_t>(SPP::VT_SEQUENCE_FLAGS, SEQUENCE_FLAGS, 0);
  }
  void add_SEQUENCE_COUNT(uint16_t SEQUENCE_COUNT) {
    fbb_.AddElement<uint16_t>(SPP::VT_SEQUENCE_COUNT, SEQUENCE_COUNT, 0);
  }
  void add_DATA_LENGTH(uint16_t DATA_LENGTH) {
    fbb_.AddElement<uint16_t>(SPP::VT_DATA_LENGTH, DATA_LENGTH, 0);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA) {
    fbb_.AddOffset(SPP::VT_DATA, DATA);
  }
  explicit SPPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SPP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SPP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SPP> CreateSPP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 0,
    packetType PACKET_TYPE = packetType_TM,
    bool SEC_HDR_FLAG = false,
    uint16_t APID = 0,
    uint8_t SEQUENCE_FLAGS = 0,
    uint16_t SEQUENCE_COUNT = 0,
    uint16_t DATA_LENGTH = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> DATA = 0) {
  SPPBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_DATA_LENGTH(DATA_LENGTH);
  builder_.add_SEQUENCE_COUNT(SEQUENCE_COUNT);
  builder_.add_APID(APID);
  builder_.add_SEQUENCE_FLAGS(SEQUENCE_FLAGS);
  builder_.add_SEC_HDR_FLAG(SEC_HDR_FLAG);
  builder_.add_PACKET_TYPE(PACKET_TYPE);
  builder_.add_VERSION(VERSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SPP> CreateSPPDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t VERSION = 0,
    packetType PACKET_TYPE = packetType_TM,
    bool SEC_HDR_FLAG = false,
    uint16_t APID = 0,
    uint8_t SEQUENCE_FLAGS = 0,
    uint16_t SEQUENCE_COUNT = 0,
    uint16_t DATA_LENGTH = 0,
    const std::vector<uint8_t> *DATA = nullptr) {
  auto DATA__ = DATA ? _fbb.CreateVector<uint8_t>(*DATA) : 0;
  return CreateSPP(
      _fbb,
      VERSION,
      PACKET_TYPE,
      SEC_HDR_FLAG,
      APID,
      SEQUENCE_FLAGS,
      SEQUENCE_COUNT,
      DATA_LENGTH,
      DATA__);
}

inline const SPP *GetSPP(const void *buf) {
  return ::flatbuffers::GetRoot<SPP>(buf);
}

inline const SPP *GetSizePrefixedSPP(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SPP>(buf);
}

inline const char *SPPIdentifier() {
  return "$SPP";
}

inline bool SPPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SPPIdentifier());
}

inline bool SizePrefixedSPPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SPPIdentifier(), true);
}

inline bool VerifySPPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SPP>(SPPIdentifier());
}

inline bool VerifySizePrefixedSPPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SPP>(SPPIdentifier());
}

inline void FinishSPPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SPP> root) {
  fbb.Finish(root, SPPIdentifier());
}

inline void FinishSizePrefixedSPPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SPP> root) {
  fbb.FinishSizePrefixed(root, SPPIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
