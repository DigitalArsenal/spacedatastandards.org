// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ARM;
struct ARMBuilder;

enum ArmorMaterial : int8_t {
  ArmorMaterial_RHA = 0,
  ArmorMaterial_CHA = 1,
  ArmorMaterial_FHA = 2,
  ArmorMaterial_HHA = 3,
  ArmorMaterial_ALUMINUM = 4,
  ArmorMaterial_COMPOSITE = 5,
  ArmorMaterial_CERAMIC = 6,
  ArmorMaterial_ERA = 7,
  ArmorMaterial_NERA = 8,
  ArmorMaterial_SPACED = 9,
  ArmorMaterial_RUBBER = 10,
  ArmorMaterial_STRUCTURAL = 11,
  ArmorMaterial_TITANIUM = 12,
  ArmorMaterial_KEVLAR = 13,
  ArmorMaterial_GLASS = 14,
  ArmorMaterial_MIN = ArmorMaterial_RHA,
  ArmorMaterial_MAX = ArmorMaterial_GLASS
};

inline const ArmorMaterial (&EnumValuesArmorMaterial())[15] {
  static const ArmorMaterial values[] = {
    ArmorMaterial_RHA,
    ArmorMaterial_CHA,
    ArmorMaterial_FHA,
    ArmorMaterial_HHA,
    ArmorMaterial_ALUMINUM,
    ArmorMaterial_COMPOSITE,
    ArmorMaterial_CERAMIC,
    ArmorMaterial_ERA,
    ArmorMaterial_NERA,
    ArmorMaterial_SPACED,
    ArmorMaterial_RUBBER,
    ArmorMaterial_STRUCTURAL,
    ArmorMaterial_TITANIUM,
    ArmorMaterial_KEVLAR,
    ArmorMaterial_GLASS
  };
  return values;
}

inline const char * const *EnumNamesArmorMaterial() {
  static const char * const names[16] = {
    "RHA",
    "CHA",
    "FHA",
    "HHA",
    "ALUMINUM",
    "COMPOSITE",
    "CERAMIC",
    "ERA",
    "NERA",
    "SPACED",
    "RUBBER",
    "STRUCTURAL",
    "TITANIUM",
    "KEVLAR",
    "GLASS",
    nullptr
  };
  return names;
}

inline const char *EnumNameArmorMaterial(ArmorMaterial e) {
  if (::flatbuffers::IsOutRange(e, ArmorMaterial_RHA, ArmorMaterial_GLASS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArmorMaterial()[index];
}

enum AmmoType : int8_t {
  AmmoType_AP = 0,
  AmmoType_APC = 1,
  AmmoType_APCBC = 2,
  AmmoType_APCR = 3,
  AmmoType_APDS = 4,
  AmmoType_APFSDS = 5,
  AmmoType_HEAT = 6,
  AmmoType_HEAT_FS = 7,
  AmmoType_HESH = 8,
  AmmoType_HE = 9,
  AmmoType_HE_FRAG = 10,
  AmmoType_HEDP = 11,
  AmmoType_APHE = 12,
  AmmoType_SAP = 13,
  AmmoType_ATGM = 14,
  AmmoType_TANDEM_HEAT = 15,
  AmmoType_TOP_ATTACK = 16,
  AmmoType_EFP = 17,
  AmmoType_MIN = AmmoType_AP,
  AmmoType_MAX = AmmoType_EFP
};

inline const AmmoType (&EnumValuesAmmoType())[18] {
  static const AmmoType values[] = {
    AmmoType_AP,
    AmmoType_APC,
    AmmoType_APCBC,
    AmmoType_APCR,
    AmmoType_APDS,
    AmmoType_APFSDS,
    AmmoType_HEAT,
    AmmoType_HEAT_FS,
    AmmoType_HESH,
    AmmoType_HE,
    AmmoType_HE_FRAG,
    AmmoType_HEDP,
    AmmoType_APHE,
    AmmoType_SAP,
    AmmoType_ATGM,
    AmmoType_TANDEM_HEAT,
    AmmoType_TOP_ATTACK,
    AmmoType_EFP
  };
  return values;
}

inline const char * const *EnumNamesAmmoType() {
  static const char * const names[19] = {
    "AP",
    "APC",
    "APCBC",
    "APCR",
    "APDS",
    "APFSDS",
    "HEAT",
    "HEAT_FS",
    "HESH",
    "HE",
    "HE_FRAG",
    "HEDP",
    "APHE",
    "SAP",
    "ATGM",
    "TANDEM_HEAT",
    "TOP_ATTACK",
    "EFP",
    nullptr
  };
  return names;
}

inline const char *EnumNameAmmoType(AmmoType e) {
  if (::flatbuffers::IsOutRange(e, AmmoType_AP, AmmoType_EFP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAmmoType()[index];
}

enum PenResult : int8_t {
  PenResult_NO_PENETRATION = 0,
  PenResult_PARTIAL_PEN = 1,
  PenResult_FULL_PEN = 2,
  PenResult_RICOCHET = 3,
  PenResult_SHATTERED = 4,
  PenResult_OVER_MATCH = 5,
  PenResult_MIN = PenResult_NO_PENETRATION,
  PenResult_MAX = PenResult_OVER_MATCH
};

inline const PenResult (&EnumValuesPenResult())[6] {
  static const PenResult values[] = {
    PenResult_NO_PENETRATION,
    PenResult_PARTIAL_PEN,
    PenResult_FULL_PEN,
    PenResult_RICOCHET,
    PenResult_SHATTERED,
    PenResult_OVER_MATCH
  };
  return values;
}

inline const char * const *EnumNamesPenResult() {
  static const char * const names[7] = {
    "NO_PENETRATION",
    "PARTIAL_PEN",
    "FULL_PEN",
    "RICOCHET",
    "SHATTERED",
    "OVER_MATCH",
    nullptr
  };
  return names;
}

inline const char *EnumNamePenResult(PenResult e) {
  if (::flatbuffers::IsOutRange(e, PenResult_NO_PENETRATION, PenResult_OVER_MATCH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPenResult()[index];
}

/// Armor and Protection
struct ARM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ARMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THICKNESS = 4,
    VT_ANGLE = 6,
    VT_MATERIAL = 8,
    VT_HARDNESS = 10,
    VT_QUALITY = 12,
    VT_ERA_TYPE = 14,
    VT_ERA_EFFECTIVENESS = 16,
    VT_ERA_VS_KE = 18,
    VT_RHA_EQUIVALENT = 20,
    VT_NORMAL_X = 22,
    VT_NORMAL_Y = 24,
    VT_NORMAL_Z = 26,
    VT_RESERVED = 28
  };
  double THICKNESS() const {
    return GetField<double>(VT_THICKNESS, 0.0);
  }
  double ANGLE() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  uint8_t MATERIAL() const {
    return GetField<uint8_t>(VT_MATERIAL, 0);
  }
  uint8_t HARDNESS() const {
    return GetField<uint8_t>(VT_HARDNESS, 0);
  }
  uint8_t QUALITY() const {
    return GetField<uint8_t>(VT_QUALITY, 0);
  }
  uint8_t ERA_TYPE() const {
    return GetField<uint8_t>(VT_ERA_TYPE, 0);
  }
  float ERA_EFFECTIVENESS() const {
    return GetField<float>(VT_ERA_EFFECTIVENESS, 0.0f);
  }
  float ERA_VS_KE() const {
    return GetField<float>(VT_ERA_VS_KE, 0.0f);
  }
  float RHA_EQUIVALENT() const {
    return GetField<float>(VT_RHA_EQUIVALENT, 0.0f);
  }
  double NORMAL_X() const {
    return GetField<double>(VT_NORMAL_X, 0.0);
  }
  double NORMAL_Y() const {
    return GetField<double>(VT_NORMAL_Y, 0.0);
  }
  double NORMAL_Z() const {
    return GetField<double>(VT_NORMAL_Z, 0.0);
  }
  const ::flatbuffers::Vector<uint8_t> *RESERVED() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RESERVED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_THICKNESS, 8) &&
           VerifyField<double>(verifier, VT_ANGLE, 8) &&
           VerifyField<uint8_t>(verifier, VT_MATERIAL, 1) &&
           VerifyField<uint8_t>(verifier, VT_HARDNESS, 1) &&
           VerifyField<uint8_t>(verifier, VT_QUALITY, 1) &&
           VerifyField<uint8_t>(verifier, VT_ERA_TYPE, 1) &&
           VerifyField<float>(verifier, VT_ERA_EFFECTIVENESS, 4) &&
           VerifyField<float>(verifier, VT_ERA_VS_KE, 4) &&
           VerifyField<float>(verifier, VT_RHA_EQUIVALENT, 4) &&
           VerifyField<double>(verifier, VT_NORMAL_X, 8) &&
           VerifyField<double>(verifier, VT_NORMAL_Y, 8) &&
           VerifyField<double>(verifier, VT_NORMAL_Z, 8) &&
           VerifyOffset(verifier, VT_RESERVED) &&
           verifier.VerifyVector(RESERVED()) &&
           verifier.EndTable();
  }
};

struct ARMBuilder {
  typedef ARM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_THICKNESS(double THICKNESS) {
    fbb_.AddElement<double>(ARM::VT_THICKNESS, THICKNESS, 0.0);
  }
  void add_ANGLE(double ANGLE) {
    fbb_.AddElement<double>(ARM::VT_ANGLE, ANGLE, 0.0);
  }
  void add_MATERIAL(uint8_t MATERIAL) {
    fbb_.AddElement<uint8_t>(ARM::VT_MATERIAL, MATERIAL, 0);
  }
  void add_HARDNESS(uint8_t HARDNESS) {
    fbb_.AddElement<uint8_t>(ARM::VT_HARDNESS, HARDNESS, 0);
  }
  void add_QUALITY(uint8_t QUALITY) {
    fbb_.AddElement<uint8_t>(ARM::VT_QUALITY, QUALITY, 0);
  }
  void add_ERA_TYPE(uint8_t ERA_TYPE) {
    fbb_.AddElement<uint8_t>(ARM::VT_ERA_TYPE, ERA_TYPE, 0);
  }
  void add_ERA_EFFECTIVENESS(float ERA_EFFECTIVENESS) {
    fbb_.AddElement<float>(ARM::VT_ERA_EFFECTIVENESS, ERA_EFFECTIVENESS, 0.0f);
  }
  void add_ERA_VS_KE(float ERA_VS_KE) {
    fbb_.AddElement<float>(ARM::VT_ERA_VS_KE, ERA_VS_KE, 0.0f);
  }
  void add_RHA_EQUIVALENT(float RHA_EQUIVALENT) {
    fbb_.AddElement<float>(ARM::VT_RHA_EQUIVALENT, RHA_EQUIVALENT, 0.0f);
  }
  void add_NORMAL_X(double NORMAL_X) {
    fbb_.AddElement<double>(ARM::VT_NORMAL_X, NORMAL_X, 0.0);
  }
  void add_NORMAL_Y(double NORMAL_Y) {
    fbb_.AddElement<double>(ARM::VT_NORMAL_Y, NORMAL_Y, 0.0);
  }
  void add_NORMAL_Z(double NORMAL_Z) {
    fbb_.AddElement<double>(ARM::VT_NORMAL_Z, NORMAL_Z, 0.0);
  }
  void add_RESERVED(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED) {
    fbb_.AddOffset(ARM::VT_RESERVED, RESERVED);
  }
  explicit ARMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ARM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ARM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ARM> CreateARM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double THICKNESS = 0.0,
    double ANGLE = 0.0,
    uint8_t MATERIAL = 0,
    uint8_t HARDNESS = 0,
    uint8_t QUALITY = 0,
    uint8_t ERA_TYPE = 0,
    float ERA_EFFECTIVENESS = 0.0f,
    float ERA_VS_KE = 0.0f,
    float RHA_EQUIVALENT = 0.0f,
    double NORMAL_X = 0.0,
    double NORMAL_Y = 0.0,
    double NORMAL_Z = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> RESERVED = 0) {
  ARMBuilder builder_(_fbb);
  builder_.add_NORMAL_Z(NORMAL_Z);
  builder_.add_NORMAL_Y(NORMAL_Y);
  builder_.add_NORMAL_X(NORMAL_X);
  builder_.add_ANGLE(ANGLE);
  builder_.add_THICKNESS(THICKNESS);
  builder_.add_RESERVED(RESERVED);
  builder_.add_RHA_EQUIVALENT(RHA_EQUIVALENT);
  builder_.add_ERA_VS_KE(ERA_VS_KE);
  builder_.add_ERA_EFFECTIVENESS(ERA_EFFECTIVENESS);
  builder_.add_ERA_TYPE(ERA_TYPE);
  builder_.add_QUALITY(QUALITY);
  builder_.add_HARDNESS(HARDNESS);
  builder_.add_MATERIAL(MATERIAL);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ARM> CreateARMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double THICKNESS = 0.0,
    double ANGLE = 0.0,
    uint8_t MATERIAL = 0,
    uint8_t HARDNESS = 0,
    uint8_t QUALITY = 0,
    uint8_t ERA_TYPE = 0,
    float ERA_EFFECTIVENESS = 0.0f,
    float ERA_VS_KE = 0.0f,
    float RHA_EQUIVALENT = 0.0f,
    double NORMAL_X = 0.0,
    double NORMAL_Y = 0.0,
    double NORMAL_Z = 0.0,
    const std::vector<uint8_t> *RESERVED = nullptr) {
  auto RESERVED__ = RESERVED ? _fbb.CreateVector<uint8_t>(*RESERVED) : 0;
  return CreateARM(
      _fbb,
      THICKNESS,
      ANGLE,
      MATERIAL,
      HARDNESS,
      QUALITY,
      ERA_TYPE,
      ERA_EFFECTIVENESS,
      ERA_VS_KE,
      RHA_EQUIVALENT,
      NORMAL_X,
      NORMAL_Y,
      NORMAL_Z,
      RESERVED__);
}

inline const ARM *GetARM(const void *buf) {
  return ::flatbuffers::GetRoot<ARM>(buf);
}

inline const ARM *GetSizePrefixedARM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ARM>(buf);
}

inline const char *ARMIdentifier() {
  return "$ARM";
}

inline bool ARMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ARMIdentifier());
}

inline bool SizePrefixedARMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ARMIdentifier(), true);
}

inline bool VerifyARMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ARM>(ARMIdentifier());
}

inline bool VerifySizePrefixedARMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ARM>(ARMIdentifier());
}

inline void FinishARMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ARM> root) {
  fbb.Finish(root, ARMIdentifier());
}

inline void FinishSizePrefixedARMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ARM> root) {
  fbb.FinishSizePrefixed(root, ARMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
