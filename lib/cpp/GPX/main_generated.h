// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct GPXLink;
struct GPXLinkBuilder;

struct GPXWaypoint;
struct GPXWaypointBuilder;

struct GPXTrackSegment;
struct GPXTrackSegmentBuilder;

struct GPXTrack;
struct GPXTrackBuilder;

struct GPXRoute;
struct GPXRouteBuilder;

struct GPX;
struct GPXBuilder;

enum GPXFixType : int8_t {
  GPXFixType_NONE = 0,
  /// 2D fix
  GPXFixType_FIX_2D = 1,
  /// 3D fix
  GPXFixType_FIX_3D = 2,
  /// Differential GPS fix
  GPXFixType_DGPS = 3,
  /// PPP fix
  GPXFixType_PPS = 4,
  GPXFixType_MIN = GPXFixType_NONE,
  GPXFixType_MAX = GPXFixType_PPS
};

inline const GPXFixType (&EnumValuesGPXFixType())[5] {
  static const GPXFixType values[] = {
    GPXFixType_NONE,
    GPXFixType_FIX_2D,
    GPXFixType_FIX_3D,
    GPXFixType_DGPS,
    GPXFixType_PPS
  };
  return values;
}

inline const char * const *EnumNamesGPXFixType() {
  static const char * const names[6] = {
    "NONE",
    "FIX_2D",
    "FIX_3D",
    "DGPS",
    "PPS",
    nullptr
  };
  return names;
}

inline const char *EnumNameGPXFixType(GPXFixType e) {
  if (::flatbuffers::IsOutRange(e, GPXFixType_NONE, GPXFixType_PPS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGPXFixType()[index];
}

/// GPX link to an external resource
struct GPXLink FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXLinkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HREF = 4,
    VT_TEXT = 6,
    VT_TYPE = 8
  };
  /// URL
  const ::flatbuffers::String *HREF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HREF);
  }
  /// Link text
  const ::flatbuffers::String *TEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  /// MIME type
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HREF) &&
           verifier.VerifyString(HREF()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(TEXT()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           verifier.EndTable();
  }
};

struct GPXLinkBuilder {
  typedef GPXLink Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_HREF(::flatbuffers::Offset<::flatbuffers::String> HREF) {
    fbb_.AddOffset(GPXLink::VT_HREF, HREF);
  }
  void add_TEXT(::flatbuffers::Offset<::flatbuffers::String> TEXT) {
    fbb_.AddOffset(GPXLink::VT_TEXT, TEXT);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(GPXLink::VT_TYPE, TYPE);
  }
  explicit GPXLinkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPXLink> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPXLink>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPXLink> CreateGPXLink(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> HREF = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TEXT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0) {
  GPXLinkBuilder builder_(_fbb);
  builder_.add_TYPE(TYPE);
  builder_.add_TEXT(TEXT);
  builder_.add_HREF(HREF);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPXLink> CreateGPXLinkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *HREF = nullptr,
    const char *TEXT = nullptr,
    const char *TYPE = nullptr) {
  auto HREF__ = HREF ? _fbb.CreateString(HREF) : 0;
  auto TEXT__ = TEXT ? _fbb.CreateString(TEXT) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  return CreateGPXLink(
      _fbb,
      HREF__,
      TEXT__,
      TYPE__);
}

/// A waypoint, point of interest, or named feature
struct GPXWaypoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXWaypointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6,
    VT_ELEVATION = 8,
    VT_TIME = 10,
    VT_MAGVAR = 12,
    VT_GEOID_HEIGHT = 14,
    VT_NAME = 16,
    VT_COMMENT = 18,
    VT_DESCRIPTION = 20,
    VT_SOURCE = 22,
    VT_LINKS = 24,
    VT_SYMBOL = 26,
    VT_TYPE = 28,
    VT_FIX = 30,
    VT_SAT = 32,
    VT_HDOP = 34,
    VT_VDOP = 36,
    VT_PDOP = 38,
    VT_AGE_OF_DGPS_DATA = 40,
    VT_DGPS_ID = 42,
    VT_SPEED = 44,
    VT_COURSE = 46
  };
  /// Latitude in decimal degrees (WGS84)
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Longitude in decimal degrees (WGS84)
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Elevation in meters above WGS84 ellipsoid
  double ELEVATION() const {
    return GetField<double>(VT_ELEVATION, 0.0);
  }
  /// UTC timestamp (ISO 8601)
  const ::flatbuffers::String *TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME);
  }
  /// Magnetic variation in degrees
  double MAGVAR() const {
    return GetField<double>(VT_MAGVAR, 0.0);
  }
  /// Height of geoid above WGS84 ellipsoid in meters
  double GEOID_HEIGHT() const {
    return GetField<double>(VT_GEOID_HEIGHT, 0.0);
  }
  /// Waypoint name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Comment
  const ::flatbuffers::String *COMMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Source of data
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Links to additional information
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *>(VT_LINKS);
  }
  /// Symbol name
  const ::flatbuffers::String *SYMBOL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SYMBOL);
  }
  /// Type/category
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Type of GPS fix
  GPXFixType FIX() const {
    return static_cast<GPXFixType>(GetField<int8_t>(VT_FIX, 0));
  }
  /// Number of satellites used for fix
  uint16_t SAT() const {
    return GetField<uint16_t>(VT_SAT, 0);
  }
  /// Horizontal dilution of precision
  double HDOP() const {
    return GetField<double>(VT_HDOP, 0.0);
  }
  /// Vertical dilution of precision
  double VDOP() const {
    return GetField<double>(VT_VDOP, 0.0);
  }
  /// Position dilution of precision
  double PDOP() const {
    return GetField<double>(VT_PDOP, 0.0);
  }
  /// Age of DGPS data in seconds
  double AGE_OF_DGPS_DATA() const {
    return GetField<double>(VT_AGE_OF_DGPS_DATA, 0.0);
  }
  /// DGPS station ID
  uint16_t DGPS_ID() const {
    return GetField<uint16_t>(VT_DGPS_ID, 0);
  }
  /// Speed in meters per second
  double SPEED() const {
    return GetField<double>(VT_SPEED, 0.0);
  }
  /// Course/heading in degrees true
  double COURSE() const {
    return GetField<double>(VT_COURSE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_ELEVATION, 8) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyString(TIME()) &&
           VerifyField<double>(verifier, VT_MAGVAR, 8) &&
           VerifyField<double>(verifier, VT_GEOID_HEIGHT, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(LINKS()) &&
           verifier.VerifyVectorOfTables(LINKS()) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(SYMBOL()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyField<int8_t>(verifier, VT_FIX, 1) &&
           VerifyField<uint16_t>(verifier, VT_SAT, 2) &&
           VerifyField<double>(verifier, VT_HDOP, 8) &&
           VerifyField<double>(verifier, VT_VDOP, 8) &&
           VerifyField<double>(verifier, VT_PDOP, 8) &&
           VerifyField<double>(verifier, VT_AGE_OF_DGPS_DATA, 8) &&
           VerifyField<uint16_t>(verifier, VT_DGPS_ID, 2) &&
           VerifyField<double>(verifier, VT_SPEED, 8) &&
           VerifyField<double>(verifier, VT_COURSE, 8) &&
           verifier.EndTable();
  }
};

struct GPXWaypointBuilder {
  typedef GPXWaypoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(GPXWaypoint::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(GPXWaypoint::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_ELEVATION(double ELEVATION) {
    fbb_.AddElement<double>(GPXWaypoint::VT_ELEVATION, ELEVATION, 0.0);
  }
  void add_TIME(::flatbuffers::Offset<::flatbuffers::String> TIME) {
    fbb_.AddOffset(GPXWaypoint::VT_TIME, TIME);
  }
  void add_MAGVAR(double MAGVAR) {
    fbb_.AddElement<double>(GPXWaypoint::VT_MAGVAR, MAGVAR, 0.0);
  }
  void add_GEOID_HEIGHT(double GEOID_HEIGHT) {
    fbb_.AddElement<double>(GPXWaypoint::VT_GEOID_HEIGHT, GEOID_HEIGHT, 0.0);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(GPXWaypoint::VT_NAME, NAME);
  }
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::String> COMMENT) {
    fbb_.AddOffset(GPXWaypoint::VT_COMMENT, COMMENT);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(GPXWaypoint::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(GPXWaypoint::VT_SOURCE, SOURCE);
  }
  void add_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS) {
    fbb_.AddOffset(GPXWaypoint::VT_LINKS, LINKS);
  }
  void add_SYMBOL(::flatbuffers::Offset<::flatbuffers::String> SYMBOL) {
    fbb_.AddOffset(GPXWaypoint::VT_SYMBOL, SYMBOL);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(GPXWaypoint::VT_TYPE, TYPE);
  }
  void add_FIX(GPXFixType FIX) {
    fbb_.AddElement<int8_t>(GPXWaypoint::VT_FIX, static_cast<int8_t>(FIX), 0);
  }
  void add_SAT(uint16_t SAT) {
    fbb_.AddElement<uint16_t>(GPXWaypoint::VT_SAT, SAT, 0);
  }
  void add_HDOP(double HDOP) {
    fbb_.AddElement<double>(GPXWaypoint::VT_HDOP, HDOP, 0.0);
  }
  void add_VDOP(double VDOP) {
    fbb_.AddElement<double>(GPXWaypoint::VT_VDOP, VDOP, 0.0);
  }
  void add_PDOP(double PDOP) {
    fbb_.AddElement<double>(GPXWaypoint::VT_PDOP, PDOP, 0.0);
  }
  void add_AGE_OF_DGPS_DATA(double AGE_OF_DGPS_DATA) {
    fbb_.AddElement<double>(GPXWaypoint::VT_AGE_OF_DGPS_DATA, AGE_OF_DGPS_DATA, 0.0);
  }
  void add_DGPS_ID(uint16_t DGPS_ID) {
    fbb_.AddElement<uint16_t>(GPXWaypoint::VT_DGPS_ID, DGPS_ID, 0);
  }
  void add_SPEED(double SPEED) {
    fbb_.AddElement<double>(GPXWaypoint::VT_SPEED, SPEED, 0.0);
  }
  void add_COURSE(double COURSE) {
    fbb_.AddElement<double>(GPXWaypoint::VT_COURSE, COURSE, 0.0);
  }
  explicit GPXWaypointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPXWaypoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPXWaypoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPXWaypoint> CreateGPXWaypoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    double ELEVATION = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> TIME = 0,
    double MAGVAR = 0.0,
    double GEOID_HEIGHT = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COMMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SYMBOL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    GPXFixType FIX = GPXFixType_NONE,
    uint16_t SAT = 0,
    double HDOP = 0.0,
    double VDOP = 0.0,
    double PDOP = 0.0,
    double AGE_OF_DGPS_DATA = 0.0,
    uint16_t DGPS_ID = 0,
    double SPEED = 0.0,
    double COURSE = 0.0) {
  GPXWaypointBuilder builder_(_fbb);
  builder_.add_COURSE(COURSE);
  builder_.add_SPEED(SPEED);
  builder_.add_AGE_OF_DGPS_DATA(AGE_OF_DGPS_DATA);
  builder_.add_PDOP(PDOP);
  builder_.add_VDOP(VDOP);
  builder_.add_HDOP(HDOP);
  builder_.add_GEOID_HEIGHT(GEOID_HEIGHT);
  builder_.add_MAGVAR(MAGVAR);
  builder_.add_ELEVATION(ELEVATION);
  builder_.add_LONGITUDE(LONGITUDE);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_TYPE(TYPE);
  builder_.add_SYMBOL(SYMBOL);
  builder_.add_LINKS(LINKS);
  builder_.add_SOURCE(SOURCE);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_COMMENT(COMMENT);
  builder_.add_NAME(NAME);
  builder_.add_TIME(TIME);
  builder_.add_DGPS_ID(DGPS_ID);
  builder_.add_SAT(SAT);
  builder_.add_FIX(FIX);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPXWaypoint> CreateGPXWaypointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LATITUDE = 0.0,
    double LONGITUDE = 0.0,
    double ELEVATION = 0.0,
    const char *TIME = nullptr,
    double MAGVAR = 0.0,
    double GEOID_HEIGHT = 0.0,
    const char *NAME = nullptr,
    const char *COMMENT = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *SOURCE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXLink>> *LINKS = nullptr,
    const char *SYMBOL = nullptr,
    const char *TYPE = nullptr,
    GPXFixType FIX = GPXFixType_NONE,
    uint16_t SAT = 0,
    double HDOP = 0.0,
    double VDOP = 0.0,
    double PDOP = 0.0,
    double AGE_OF_DGPS_DATA = 0.0,
    uint16_t DGPS_ID = 0,
    double SPEED = 0.0,
    double COURSE = 0.0) {
  auto TIME__ = TIME ? _fbb.CreateString(TIME) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto LINKS__ = LINKS ? _fbb.CreateVector<::flatbuffers::Offset<GPXLink>>(*LINKS) : 0;
  auto SYMBOL__ = SYMBOL ? _fbb.CreateString(SYMBOL) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  return CreateGPXWaypoint(
      _fbb,
      LATITUDE,
      LONGITUDE,
      ELEVATION,
      TIME__,
      MAGVAR,
      GEOID_HEIGHT,
      NAME__,
      COMMENT__,
      DESCRIPTION__,
      SOURCE__,
      LINKS__,
      SYMBOL__,
      TYPE__,
      FIX,
      SAT,
      HDOP,
      VDOP,
      PDOP,
      AGE_OF_DGPS_DATA,
      DGPS_ID,
      SPEED,
      COURSE);
}

/// Track segment (continuous span of track points)
struct GPXTrackSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXTrackSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  /// Ordered track points in this segment
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *POINTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(POINTS()) &&
           verifier.VerifyVectorOfTables(POINTS()) &&
           verifier.EndTable();
  }
};

struct GPXTrackSegmentBuilder {
  typedef GPXTrackSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_POINTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> POINTS) {
    fbb_.AddOffset(GPXTrackSegment::VT_POINTS, POINTS);
  }
  explicit GPXTrackSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPXTrackSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPXTrackSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPXTrackSegment> CreateGPXTrackSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> POINTS = 0) {
  GPXTrackSegmentBuilder builder_(_fbb);
  builder_.add_POINTS(POINTS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPXTrackSegment> CreateGPXTrackSegmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<GPXWaypoint>> *POINTS = nullptr) {
  auto POINTS__ = POINTS ? _fbb.CreateVector<::flatbuffers::Offset<GPXWaypoint>>(*POINTS) : 0;
  return CreateGPXTrackSegment(
      _fbb,
      POINTS__);
}

/// Track (ordered list of track segments)
struct GPXTrack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXTrackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMMENT = 6,
    VT_DESCRIPTION = 8,
    VT_SOURCE = 10,
    VT_LINKS = 12,
    VT_NUMBER = 14,
    VT_TYPE = 16,
    VT_SEGMENTS = 18
  };
  /// Track name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Comment
  const ::flatbuffers::String *COMMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Source of data
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Links to additional information
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *>(VT_LINKS);
  }
  /// Track number
  uint32_t NUMBER() const {
    return GetField<uint32_t>(VT_NUMBER, 0);
  }
  /// Type/category
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Track segments
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXTrackSegment>> *SEGMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXTrackSegment>> *>(VT_SEGMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(LINKS()) &&
           verifier.VerifyVectorOfTables(LINKS()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(SEGMENTS()) &&
           verifier.VerifyVectorOfTables(SEGMENTS()) &&
           verifier.EndTable();
  }
};

struct GPXTrackBuilder {
  typedef GPXTrack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(GPXTrack::VT_NAME, NAME);
  }
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::String> COMMENT) {
    fbb_.AddOffset(GPXTrack::VT_COMMENT, COMMENT);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(GPXTrack::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(GPXTrack::VT_SOURCE, SOURCE);
  }
  void add_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS) {
    fbb_.AddOffset(GPXTrack::VT_LINKS, LINKS);
  }
  void add_NUMBER(uint32_t NUMBER) {
    fbb_.AddElement<uint32_t>(GPXTrack::VT_NUMBER, NUMBER, 0);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(GPXTrack::VT_TYPE, TYPE);
  }
  void add_SEGMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXTrackSegment>>> SEGMENTS) {
    fbb_.AddOffset(GPXTrack::VT_SEGMENTS, SEGMENTS);
  }
  explicit GPXTrackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPXTrack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPXTrack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPXTrack> CreateGPXTrack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COMMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS = 0,
    uint32_t NUMBER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXTrackSegment>>> SEGMENTS = 0) {
  GPXTrackBuilder builder_(_fbb);
  builder_.add_SEGMENTS(SEGMENTS);
  builder_.add_TYPE(TYPE);
  builder_.add_NUMBER(NUMBER);
  builder_.add_LINKS(LINKS);
  builder_.add_SOURCE(SOURCE);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_COMMENT(COMMENT);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPXTrack> CreateGPXTrackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *COMMENT = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *SOURCE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXLink>> *LINKS = nullptr,
    uint32_t NUMBER = 0,
    const char *TYPE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXTrackSegment>> *SEGMENTS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto LINKS__ = LINKS ? _fbb.CreateVector<::flatbuffers::Offset<GPXLink>>(*LINKS) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto SEGMENTS__ = SEGMENTS ? _fbb.CreateVector<::flatbuffers::Offset<GPXTrackSegment>>(*SEGMENTS) : 0;
  return CreateGPXTrack(
      _fbb,
      NAME__,
      COMMENT__,
      DESCRIPTION__,
      SOURCE__,
      LINKS__,
      NUMBER,
      TYPE__,
      SEGMENTS__);
}

/// Route (ordered list of waypoints for navigation)
struct GPXRoute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXRouteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COMMENT = 6,
    VT_DESCRIPTION = 8,
    VT_SOURCE = 10,
    VT_LINKS = 12,
    VT_NUMBER = 14,
    VT_TYPE = 16,
    VT_POINTS = 18
  };
  /// Route name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Comment
  const ::flatbuffers::String *COMMENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENT);
  }
  /// Description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Source of data
  const ::flatbuffers::String *SOURCE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Links to additional information
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *>(VT_LINKS);
  }
  /// Route number
  uint32_t NUMBER() const {
    return GetField<uint32_t>(VT_NUMBER, 0);
  }
  /// Type/category
  const ::flatbuffers::String *TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Route points (ordered waypoints)
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *POINTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_COMMENT) &&
           verifier.VerifyString(COMMENT()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(SOURCE()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(LINKS()) &&
           verifier.VerifyVectorOfTables(LINKS()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(TYPE()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(POINTS()) &&
           verifier.VerifyVectorOfTables(POINTS()) &&
           verifier.EndTable();
  }
};

struct GPXRouteBuilder {
  typedef GPXRoute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(GPXRoute::VT_NAME, NAME);
  }
  void add_COMMENT(::flatbuffers::Offset<::flatbuffers::String> COMMENT) {
    fbb_.AddOffset(GPXRoute::VT_COMMENT, COMMENT);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(GPXRoute::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_SOURCE(::flatbuffers::Offset<::flatbuffers::String> SOURCE) {
    fbb_.AddOffset(GPXRoute::VT_SOURCE, SOURCE);
  }
  void add_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS) {
    fbb_.AddOffset(GPXRoute::VT_LINKS, LINKS);
  }
  void add_NUMBER(uint32_t NUMBER) {
    fbb_.AddElement<uint32_t>(GPXRoute::VT_NUMBER, NUMBER, 0);
  }
  void add_TYPE(::flatbuffers::Offset<::flatbuffers::String> TYPE) {
    fbb_.AddOffset(GPXRoute::VT_TYPE, TYPE);
  }
  void add_POINTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> POINTS) {
    fbb_.AddOffset(GPXRoute::VT_POINTS, POINTS);
  }
  explicit GPXRouteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPXRoute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPXRoute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPXRoute> CreateGPXRoute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COMMENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> SOURCE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS = 0,
    uint32_t NUMBER = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> POINTS = 0) {
  GPXRouteBuilder builder_(_fbb);
  builder_.add_POINTS(POINTS);
  builder_.add_TYPE(TYPE);
  builder_.add_NUMBER(NUMBER);
  builder_.add_LINKS(LINKS);
  builder_.add_SOURCE(SOURCE);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_COMMENT(COMMENT);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPXRoute> CreateGPXRouteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *COMMENT = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *SOURCE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXLink>> *LINKS = nullptr,
    uint32_t NUMBER = 0,
    const char *TYPE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXWaypoint>> *POINTS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto COMMENT__ = COMMENT ? _fbb.CreateString(COMMENT) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto SOURCE__ = SOURCE ? _fbb.CreateString(SOURCE) : 0;
  auto LINKS__ = LINKS ? _fbb.CreateVector<::flatbuffers::Offset<GPXLink>>(*LINKS) : 0;
  auto TYPE__ = TYPE ? _fbb.CreateString(TYPE) : 0;
  auto POINTS__ = POINTS ? _fbb.CreateVector<::flatbuffers::Offset<GPXWaypoint>>(*POINTS) : 0;
  return CreateGPXRoute(
      _fbb,
      NAME__,
      COMMENT__,
      DESCRIPTION__,
      SOURCE__,
      LINKS__,
      NUMBER,
      TYPE__,
      POINTS__);
}

/// GPX Document
struct GPX FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GPXBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_CREATOR = 6,
    VT_NAME = 8,
    VT_DESCRIPTION = 10,
    VT_AUTHOR_NAME = 12,
    VT_AUTHOR_EMAIL = 14,
    VT_AUTHOR_LINK = 16,
    VT_COPYRIGHT_AUTHOR = 18,
    VT_COPYRIGHT_YEAR = 20,
    VT_COPYRIGHT_LICENSE = 22,
    VT_LINKS = 24,
    VT_TIME = 26,
    VT_KEYWORDS = 28,
    VT_BOUNDS_MIN_LAT = 30,
    VT_BOUNDS_MIN_LON = 32,
    VT_BOUNDS_MAX_LAT = 34,
    VT_BOUNDS_MAX_LON = 36,
    VT_WAYPOINTS = 38,
    VT_ROUTES = 40,
    VT_TRACKS = 42
  };
  /// GPX schema version
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Creator software/organization
  const ::flatbuffers::String *CREATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATOR);
  }
  /// File name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// File description
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Person or organization who created the file
  const ::flatbuffers::String *AUTHOR_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTHOR_NAME);
  }
  /// Author email
  const ::flatbuffers::String *AUTHOR_EMAIL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTHOR_EMAIL);
  }
  /// Author link
  const GPXLink *AUTHOR_LINK() const {
    return GetPointer<const GPXLink *>(VT_AUTHOR_LINK);
  }
  /// Copyright holder
  const ::flatbuffers::String *COPYRIGHT_AUTHOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COPYRIGHT_AUTHOR);
  }
  /// Copyright year
  const ::flatbuffers::String *COPYRIGHT_YEAR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COPYRIGHT_YEAR);
  }
  /// Copyright license URL
  const ::flatbuffers::String *COPYRIGHT_LICENSE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COPYRIGHT_LICENSE);
  }
  /// Links to additional information
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *LINKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>> *>(VT_LINKS);
  }
  /// Creation timestamp (ISO 8601)
  const ::flatbuffers::String *TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME);
  }
  /// Keywords
  const ::flatbuffers::String *KEYWORDS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEYWORDS);
  }
  /// Minimum latitude of bounding box
  double BOUNDS_MIN_LAT() const {
    return GetField<double>(VT_BOUNDS_MIN_LAT, 0.0);
  }
  /// Minimum longitude of bounding box
  double BOUNDS_MIN_LON() const {
    return GetField<double>(VT_BOUNDS_MIN_LON, 0.0);
  }
  /// Maximum latitude of bounding box
  double BOUNDS_MAX_LAT() const {
    return GetField<double>(VT_BOUNDS_MAX_LAT, 0.0);
  }
  /// Maximum longitude of bounding box
  double BOUNDS_MAX_LON() const {
    return GetField<double>(VT_BOUNDS_MAX_LON, 0.0);
  }
  /// Waypoints
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *WAYPOINTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>> *>(VT_WAYPOINTS);
  }
  /// Routes
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXRoute>> *ROUTES() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXRoute>> *>(VT_ROUTES);
  }
  /// Tracks
  const ::flatbuffers::Vector<::flatbuffers::Offset<GPXTrack>> *TRACKS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GPXTrack>> *>(VT_TRACKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyOffset(verifier, VT_CREATOR) &&
           verifier.VerifyString(CREATOR()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_AUTHOR_NAME) &&
           verifier.VerifyString(AUTHOR_NAME()) &&
           VerifyOffset(verifier, VT_AUTHOR_EMAIL) &&
           verifier.VerifyString(AUTHOR_EMAIL()) &&
           VerifyOffset(verifier, VT_AUTHOR_LINK) &&
           verifier.VerifyTable(AUTHOR_LINK()) &&
           VerifyOffset(verifier, VT_COPYRIGHT_AUTHOR) &&
           verifier.VerifyString(COPYRIGHT_AUTHOR()) &&
           VerifyOffset(verifier, VT_COPYRIGHT_YEAR) &&
           verifier.VerifyString(COPYRIGHT_YEAR()) &&
           VerifyOffset(verifier, VT_COPYRIGHT_LICENSE) &&
           verifier.VerifyString(COPYRIGHT_LICENSE()) &&
           VerifyOffset(verifier, VT_LINKS) &&
           verifier.VerifyVector(LINKS()) &&
           verifier.VerifyVectorOfTables(LINKS()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.VerifyString(TIME()) &&
           VerifyOffset(verifier, VT_KEYWORDS) &&
           verifier.VerifyString(KEYWORDS()) &&
           VerifyField<double>(verifier, VT_BOUNDS_MIN_LAT, 8) &&
           VerifyField<double>(verifier, VT_BOUNDS_MIN_LON, 8) &&
           VerifyField<double>(verifier, VT_BOUNDS_MAX_LAT, 8) &&
           VerifyField<double>(verifier, VT_BOUNDS_MAX_LON, 8) &&
           VerifyOffset(verifier, VT_WAYPOINTS) &&
           verifier.VerifyVector(WAYPOINTS()) &&
           verifier.VerifyVectorOfTables(WAYPOINTS()) &&
           VerifyOffset(verifier, VT_ROUTES) &&
           verifier.VerifyVector(ROUTES()) &&
           verifier.VerifyVectorOfTables(ROUTES()) &&
           VerifyOffset(verifier, VT_TRACKS) &&
           verifier.VerifyVector(TRACKS()) &&
           verifier.VerifyVectorOfTables(TRACKS()) &&
           verifier.EndTable();
  }
};

struct GPXBuilder {
  typedef GPX Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(GPX::VT_VERSION, VERSION);
  }
  void add_CREATOR(::flatbuffers::Offset<::flatbuffers::String> CREATOR) {
    fbb_.AddOffset(GPX::VT_CREATOR, CREATOR);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(GPX::VT_NAME, NAME);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(GPX::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_AUTHOR_NAME(::flatbuffers::Offset<::flatbuffers::String> AUTHOR_NAME) {
    fbb_.AddOffset(GPX::VT_AUTHOR_NAME, AUTHOR_NAME);
  }
  void add_AUTHOR_EMAIL(::flatbuffers::Offset<::flatbuffers::String> AUTHOR_EMAIL) {
    fbb_.AddOffset(GPX::VT_AUTHOR_EMAIL, AUTHOR_EMAIL);
  }
  void add_AUTHOR_LINK(::flatbuffers::Offset<GPXLink> AUTHOR_LINK) {
    fbb_.AddOffset(GPX::VT_AUTHOR_LINK, AUTHOR_LINK);
  }
  void add_COPYRIGHT_AUTHOR(::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_AUTHOR) {
    fbb_.AddOffset(GPX::VT_COPYRIGHT_AUTHOR, COPYRIGHT_AUTHOR);
  }
  void add_COPYRIGHT_YEAR(::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_YEAR) {
    fbb_.AddOffset(GPX::VT_COPYRIGHT_YEAR, COPYRIGHT_YEAR);
  }
  void add_COPYRIGHT_LICENSE(::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_LICENSE) {
    fbb_.AddOffset(GPX::VT_COPYRIGHT_LICENSE, COPYRIGHT_LICENSE);
  }
  void add_LINKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS) {
    fbb_.AddOffset(GPX::VT_LINKS, LINKS);
  }
  void add_TIME(::flatbuffers::Offset<::flatbuffers::String> TIME) {
    fbb_.AddOffset(GPX::VT_TIME, TIME);
  }
  void add_KEYWORDS(::flatbuffers::Offset<::flatbuffers::String> KEYWORDS) {
    fbb_.AddOffset(GPX::VT_KEYWORDS, KEYWORDS);
  }
  void add_BOUNDS_MIN_LAT(double BOUNDS_MIN_LAT) {
    fbb_.AddElement<double>(GPX::VT_BOUNDS_MIN_LAT, BOUNDS_MIN_LAT, 0.0);
  }
  void add_BOUNDS_MIN_LON(double BOUNDS_MIN_LON) {
    fbb_.AddElement<double>(GPX::VT_BOUNDS_MIN_LON, BOUNDS_MIN_LON, 0.0);
  }
  void add_BOUNDS_MAX_LAT(double BOUNDS_MAX_LAT) {
    fbb_.AddElement<double>(GPX::VT_BOUNDS_MAX_LAT, BOUNDS_MAX_LAT, 0.0);
  }
  void add_BOUNDS_MAX_LON(double BOUNDS_MAX_LON) {
    fbb_.AddElement<double>(GPX::VT_BOUNDS_MAX_LON, BOUNDS_MAX_LON, 0.0);
  }
  void add_WAYPOINTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> WAYPOINTS) {
    fbb_.AddOffset(GPX::VT_WAYPOINTS, WAYPOINTS);
  }
  void add_ROUTES(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXRoute>>> ROUTES) {
    fbb_.AddOffset(GPX::VT_ROUTES, ROUTES);
  }
  void add_TRACKS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXTrack>>> TRACKS) {
    fbb_.AddOffset(GPX::VT_TRACKS, TRACKS);
  }
  explicit GPXBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GPX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GPX>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GPX> CreateGPX(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AUTHOR_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AUTHOR_EMAIL = 0,
    ::flatbuffers::Offset<GPXLink> AUTHOR_LINK = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_AUTHOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_YEAR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COPYRIGHT_LICENSE = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXLink>>> LINKS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> KEYWORDS = 0,
    double BOUNDS_MIN_LAT = 0.0,
    double BOUNDS_MIN_LON = 0.0,
    double BOUNDS_MAX_LAT = 0.0,
    double BOUNDS_MAX_LON = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXWaypoint>>> WAYPOINTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXRoute>>> ROUTES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GPXTrack>>> TRACKS = 0) {
  GPXBuilder builder_(_fbb);
  builder_.add_BOUNDS_MAX_LON(BOUNDS_MAX_LON);
  builder_.add_BOUNDS_MAX_LAT(BOUNDS_MAX_LAT);
  builder_.add_BOUNDS_MIN_LON(BOUNDS_MIN_LON);
  builder_.add_BOUNDS_MIN_LAT(BOUNDS_MIN_LAT);
  builder_.add_TRACKS(TRACKS);
  builder_.add_ROUTES(ROUTES);
  builder_.add_WAYPOINTS(WAYPOINTS);
  builder_.add_KEYWORDS(KEYWORDS);
  builder_.add_TIME(TIME);
  builder_.add_LINKS(LINKS);
  builder_.add_COPYRIGHT_LICENSE(COPYRIGHT_LICENSE);
  builder_.add_COPYRIGHT_YEAR(COPYRIGHT_YEAR);
  builder_.add_COPYRIGHT_AUTHOR(COPYRIGHT_AUTHOR);
  builder_.add_AUTHOR_LINK(AUTHOR_LINK);
  builder_.add_AUTHOR_EMAIL(AUTHOR_EMAIL);
  builder_.add_AUTHOR_NAME(AUTHOR_NAME);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_NAME(NAME);
  builder_.add_CREATOR(CREATOR);
  builder_.add_VERSION(VERSION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GPX> CreateGPXDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *VERSION = nullptr,
    const char *CREATOR = nullptr,
    const char *NAME = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *AUTHOR_NAME = nullptr,
    const char *AUTHOR_EMAIL = nullptr,
    ::flatbuffers::Offset<GPXLink> AUTHOR_LINK = 0,
    const char *COPYRIGHT_AUTHOR = nullptr,
    const char *COPYRIGHT_YEAR = nullptr,
    const char *COPYRIGHT_LICENSE = nullptr,
    const std::vector<::flatbuffers::Offset<GPXLink>> *LINKS = nullptr,
    const char *TIME = nullptr,
    const char *KEYWORDS = nullptr,
    double BOUNDS_MIN_LAT = 0.0,
    double BOUNDS_MIN_LON = 0.0,
    double BOUNDS_MAX_LAT = 0.0,
    double BOUNDS_MAX_LON = 0.0,
    const std::vector<::flatbuffers::Offset<GPXWaypoint>> *WAYPOINTS = nullptr,
    const std::vector<::flatbuffers::Offset<GPXRoute>> *ROUTES = nullptr,
    const std::vector<::flatbuffers::Offset<GPXTrack>> *TRACKS = nullptr) {
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  auto CREATOR__ = CREATOR ? _fbb.CreateString(CREATOR) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto AUTHOR_NAME__ = AUTHOR_NAME ? _fbb.CreateString(AUTHOR_NAME) : 0;
  auto AUTHOR_EMAIL__ = AUTHOR_EMAIL ? _fbb.CreateString(AUTHOR_EMAIL) : 0;
  auto COPYRIGHT_AUTHOR__ = COPYRIGHT_AUTHOR ? _fbb.CreateString(COPYRIGHT_AUTHOR) : 0;
  auto COPYRIGHT_YEAR__ = COPYRIGHT_YEAR ? _fbb.CreateString(COPYRIGHT_YEAR) : 0;
  auto COPYRIGHT_LICENSE__ = COPYRIGHT_LICENSE ? _fbb.CreateString(COPYRIGHT_LICENSE) : 0;
  auto LINKS__ = LINKS ? _fbb.CreateVector<::flatbuffers::Offset<GPXLink>>(*LINKS) : 0;
  auto TIME__ = TIME ? _fbb.CreateString(TIME) : 0;
  auto KEYWORDS__ = KEYWORDS ? _fbb.CreateString(KEYWORDS) : 0;
  auto WAYPOINTS__ = WAYPOINTS ? _fbb.CreateVector<::flatbuffers::Offset<GPXWaypoint>>(*WAYPOINTS) : 0;
  auto ROUTES__ = ROUTES ? _fbb.CreateVector<::flatbuffers::Offset<GPXRoute>>(*ROUTES) : 0;
  auto TRACKS__ = TRACKS ? _fbb.CreateVector<::flatbuffers::Offset<GPXTrack>>(*TRACKS) : 0;
  return CreateGPX(
      _fbb,
      VERSION__,
      CREATOR__,
      NAME__,
      DESCRIPTION__,
      AUTHOR_NAME__,
      AUTHOR_EMAIL__,
      AUTHOR_LINK,
      COPYRIGHT_AUTHOR__,
      COPYRIGHT_YEAR__,
      COPYRIGHT_LICENSE__,
      LINKS__,
      TIME__,
      KEYWORDS__,
      BOUNDS_MIN_LAT,
      BOUNDS_MIN_LON,
      BOUNDS_MAX_LAT,
      BOUNDS_MAX_LON,
      WAYPOINTS__,
      ROUTES__,
      TRACKS__);
}

inline const GPX *GetGPX(const void *buf) {
  return ::flatbuffers::GetRoot<GPX>(buf);
}

inline const GPX *GetSizePrefixedGPX(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GPX>(buf);
}

inline const char *GPXIdentifier() {
  return "$GPX";
}

inline bool GPXBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GPXIdentifier());
}

inline bool SizePrefixedGPXBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, GPXIdentifier(), true);
}

inline bool VerifyGPXBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<GPX>(GPXIdentifier());
}

inline bool VerifySizePrefixedGPXBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<GPX>(GPXIdentifier());
}

inline void FinishGPXBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GPX> root) {
  fbb.Finish(root, GPXIdentifier());
}

inline void FinishSizePrefixedGPXBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GPX> root) {
  fbb.FinishSizePrefixed(root, GPXIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
