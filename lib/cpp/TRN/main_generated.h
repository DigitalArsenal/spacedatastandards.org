// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TRN;
struct TRNBuilder;

enum TerrainDataSource : int8_t {
  TerrainDataSource_SRTM = 0,
  TerrainDataSource_ASTER = 1,
  TerrainDataSource_DTED_0 = 2,
  TerrainDataSource_DTED_1 = 3,
  TerrainDataSource_DTED_2 = 4,
  TerrainDataSource_NED = 5,
  TerrainDataSource_LIDAR = 6,
  TerrainDataSource_CUSTOM = 7,
  TerrainDataSource_MIN = TerrainDataSource_SRTM,
  TerrainDataSource_MAX = TerrainDataSource_CUSTOM
};

inline const TerrainDataSource (&EnumValuesTerrainDataSource())[8] {
  static const TerrainDataSource values[] = {
    TerrainDataSource_SRTM,
    TerrainDataSource_ASTER,
    TerrainDataSource_DTED_0,
    TerrainDataSource_DTED_1,
    TerrainDataSource_DTED_2,
    TerrainDataSource_NED,
    TerrainDataSource_LIDAR,
    TerrainDataSource_CUSTOM
  };
  return values;
}

inline const char * const *EnumNamesTerrainDataSource() {
  static const char * const names[9] = {
    "SRTM",
    "ASTER",
    "DTED_0",
    "DTED_1",
    "DTED_2",
    "NED",
    "LIDAR",
    "CUSTOM",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerrainDataSource(TerrainDataSource e) {
  if (::flatbuffers::IsOutRange(e, TerrainDataSource_SRTM, TerrainDataSource_CUSTOM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerrainDataSource()[index];
}

enum LandCoverType : int8_t {
  LandCoverType_WATER = 0,
  LandCoverType_URBAN = 1,
  LandCoverType_SUBURBAN = 2,
  LandCoverType_FOREST_DECIDUOUS = 3,
  LandCoverType_FOREST_CONIFEROUS = 4,
  LandCoverType_FOREST_MIXED = 5,
  LandCoverType_GRASSLAND = 6,
  LandCoverType_SHRUBLAND = 7,
  LandCoverType_CROPLAND = 8,
  LandCoverType_BARREN = 9,
  LandCoverType_WETLAND = 10,
  LandCoverType_SNOW_ICE = 11,
  LandCoverType_DESERT = 12,
  LandCoverType_ROCK = 13,
  LandCoverType_ROAD = 14,
  LandCoverType_RUNWAY = 15,
  LandCoverType_BUILDING = 16,
  LandCoverType_MIN = LandCoverType_WATER,
  LandCoverType_MAX = LandCoverType_BUILDING
};

inline const LandCoverType (&EnumValuesLandCoverType())[17] {
  static const LandCoverType values[] = {
    LandCoverType_WATER,
    LandCoverType_URBAN,
    LandCoverType_SUBURBAN,
    LandCoverType_FOREST_DECIDUOUS,
    LandCoverType_FOREST_CONIFEROUS,
    LandCoverType_FOREST_MIXED,
    LandCoverType_GRASSLAND,
    LandCoverType_SHRUBLAND,
    LandCoverType_CROPLAND,
    LandCoverType_BARREN,
    LandCoverType_WETLAND,
    LandCoverType_SNOW_ICE,
    LandCoverType_DESERT,
    LandCoverType_ROCK,
    LandCoverType_ROAD,
    LandCoverType_RUNWAY,
    LandCoverType_BUILDING
  };
  return values;
}

inline const char * const *EnumNamesLandCoverType() {
  static const char * const names[18] = {
    "WATER",
    "URBAN",
    "SUBURBAN",
    "FOREST_DECIDUOUS",
    "FOREST_CONIFEROUS",
    "FOREST_MIXED",
    "GRASSLAND",
    "SHRUBLAND",
    "CROPLAND",
    "BARREN",
    "WETLAND",
    "SNOW_ICE",
    "DESERT",
    "ROCK",
    "ROAD",
    "RUNWAY",
    "BUILDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameLandCoverType(LandCoverType e) {
  if (::flatbuffers::IsOutRange(e, LandCoverType_WATER, LandCoverType_BUILDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLandCoverType()[index];
}

enum TerrainInterpolation : int8_t {
  TerrainInterpolation_NEAREST = 0,
  TerrainInterpolation_BILINEAR = 1,
  TerrainInterpolation_BICUBIC = 2,
  TerrainInterpolation_KRIGING = 3,
  TerrainInterpolation_MIN = TerrainInterpolation_NEAREST,
  TerrainInterpolation_MAX = TerrainInterpolation_KRIGING
};

inline const TerrainInterpolation (&EnumValuesTerrainInterpolation())[4] {
  static const TerrainInterpolation values[] = {
    TerrainInterpolation_NEAREST,
    TerrainInterpolation_BILINEAR,
    TerrainInterpolation_BICUBIC,
    TerrainInterpolation_KRIGING
  };
  return values;
}

inline const char * const *EnumNamesTerrainInterpolation() {
  static const char * const names[5] = {
    "NEAREST",
    "BILINEAR",
    "BICUBIC",
    "KRIGING",
    nullptr
  };
  return names;
}

inline const char *EnumNameTerrainInterpolation(TerrainInterpolation e) {
  if (::flatbuffers::IsOutRange(e, TerrainInterpolation_NEAREST, TerrainInterpolation_KRIGING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTerrainInterpolation()[index];
}

/// Terrain Models
struct TRN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TRNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCES = 4,
    VT_INTERPOLATION = 6,
    VT_CACHE_ENABLED = 8,
    VT_MAX_CACHE_TILES = 10,
    VT_VERTICAL_EXAGGERATION = 12
  };
  const ::flatbuffers::Vector<int8_t> *SOURCES() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_SOURCES);
  }
  TerrainInterpolation INTERPOLATION() const {
    return static_cast<TerrainInterpolation>(GetField<int8_t>(VT_INTERPOLATION, 1));
  }
  bool CACHE_ENABLED() const {
    return GetField<uint8_t>(VT_CACHE_ENABLED, 1) != 0;
  }
  uint16_t MAX_CACHE_TILES() const {
    return GetField<uint16_t>(VT_MAX_CACHE_TILES, 100);
  }
  double VERTICAL_EXAGGERATION() const {
    return GetField<double>(VT_VERTICAL_EXAGGERATION, 1.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SOURCES) &&
           verifier.VerifyVector(SOURCES()) &&
           VerifyField<int8_t>(verifier, VT_INTERPOLATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_CACHE_ENABLED, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_CACHE_TILES, 2) &&
           VerifyField<double>(verifier, VT_VERTICAL_EXAGGERATION, 8) &&
           verifier.EndTable();
  }
};

struct TRNBuilder {
  typedef TRN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SOURCES(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> SOURCES) {
    fbb_.AddOffset(TRN::VT_SOURCES, SOURCES);
  }
  void add_INTERPOLATION(TerrainInterpolation INTERPOLATION) {
    fbb_.AddElement<int8_t>(TRN::VT_INTERPOLATION, static_cast<int8_t>(INTERPOLATION), 1);
  }
  void add_CACHE_ENABLED(bool CACHE_ENABLED) {
    fbb_.AddElement<uint8_t>(TRN::VT_CACHE_ENABLED, static_cast<uint8_t>(CACHE_ENABLED), 1);
  }
  void add_MAX_CACHE_TILES(uint16_t MAX_CACHE_TILES) {
    fbb_.AddElement<uint16_t>(TRN::VT_MAX_CACHE_TILES, MAX_CACHE_TILES, 100);
  }
  void add_VERTICAL_EXAGGERATION(double VERTICAL_EXAGGERATION) {
    fbb_.AddElement<double>(TRN::VT_VERTICAL_EXAGGERATION, VERTICAL_EXAGGERATION, 1.0);
  }
  explicit TRNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TRN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TRN> CreateTRN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> SOURCES = 0,
    TerrainInterpolation INTERPOLATION = TerrainInterpolation_BILINEAR,
    bool CACHE_ENABLED = true,
    uint16_t MAX_CACHE_TILES = 100,
    double VERTICAL_EXAGGERATION = 1.0) {
  TRNBuilder builder_(_fbb);
  builder_.add_VERTICAL_EXAGGERATION(VERTICAL_EXAGGERATION);
  builder_.add_SOURCES(SOURCES);
  builder_.add_MAX_CACHE_TILES(MAX_CACHE_TILES);
  builder_.add_CACHE_ENABLED(CACHE_ENABLED);
  builder_.add_INTERPOLATION(INTERPOLATION);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TRN> CreateTRNDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *SOURCES = nullptr,
    TerrainInterpolation INTERPOLATION = TerrainInterpolation_BILINEAR,
    bool CACHE_ENABLED = true,
    uint16_t MAX_CACHE_TILES = 100,
    double VERTICAL_EXAGGERATION = 1.0) {
  auto SOURCES__ = SOURCES ? _fbb.CreateVector<int8_t>(*SOURCES) : 0;
  return CreateTRN(
      _fbb,
      SOURCES__,
      INTERPOLATION,
      CACHE_ENABLED,
      MAX_CACHE_TILES,
      VERTICAL_EXAGGERATION);
}

inline const TRN *GetTRN(const void *buf) {
  return ::flatbuffers::GetRoot<TRN>(buf);
}

inline const TRN *GetSizePrefixedTRN(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TRN>(buf);
}

inline const char *TRNIdentifier() {
  return "$TRN";
}

inline bool TRNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TRNIdentifier());
}

inline bool SizePrefixedTRNBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TRNIdentifier(), true);
}

inline bool VerifyTRNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TRN>(TRNIdentifier());
}

inline bool VerifySizePrefixedTRNBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TRN>(TRNIdentifier());
}

inline void FinishTRNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TRN> root) {
  fbb.Finish(root, TRNIdentifier());
}

inline void FinishSizePrefixedTRNBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TRN> root) {
  fbb.FinishSizePrefixed(root, TRNIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
