// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CZMInterval;
struct CZMIntervalBuilder;

struct CZMCartographicDegrees;
struct CZMCartographicDegreesBuilder;

struct CZMCartesian;
struct CZMCartesianBuilder;

struct CZMColor;
struct CZMColorBuilder;

struct CZMNearFarScalar;
struct CZMNearFarScalarBuilder;

struct CZMBillboard;
struct CZMBillboardBuilder;

struct CZMLabel;
struct CZMLabelBuilder;

struct CZMPoint;
struct CZMPointBuilder;

struct CZMPolyline;
struct CZMPolylineBuilder;

struct CZMPolygon;
struct CZMPolygonBuilder;

struct CZMModel;
struct CZMModelBuilder;

struct CZMPath;
struct CZMPathBuilder;

struct CZMEllipse;
struct CZMEllipseBuilder;

struct CZMPacket;
struct CZMPacketBuilder;

struct CZM;
struct CZMBuilder;

enum CZMHeightReference : int8_t {
  CZMHeightReference_NONE = 0,
  CZMHeightReference_CLAMP_TO_GROUND = 1,
  CZMHeightReference_RELATIVE_TO_GROUND = 2,
  CZMHeightReference_MIN = CZMHeightReference_NONE,
  CZMHeightReference_MAX = CZMHeightReference_RELATIVE_TO_GROUND
};

inline const CZMHeightReference (&EnumValuesCZMHeightReference())[3] {
  static const CZMHeightReference values[] = {
    CZMHeightReference_NONE,
    CZMHeightReference_CLAMP_TO_GROUND,
    CZMHeightReference_RELATIVE_TO_GROUND
  };
  return values;
}

inline const char * const *EnumNamesCZMHeightReference() {
  static const char * const names[4] = {
    "NONE",
    "CLAMP_TO_GROUND",
    "RELATIVE_TO_GROUND",
    nullptr
  };
  return names;
}

inline const char *EnumNameCZMHeightReference(CZMHeightReference e) {
  if (::flatbuffers::IsOutRange(e, CZMHeightReference_NONE, CZMHeightReference_RELATIVE_TO_GROUND)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCZMHeightReference()[index];
}

enum CZMClassificationType : int8_t {
  CZMClassificationType_TERRAIN = 0,
  CZMClassificationType_CESIUM_3D_TILE = 1,
  CZMClassificationType_BOTH = 2,
  CZMClassificationType_MIN = CZMClassificationType_TERRAIN,
  CZMClassificationType_MAX = CZMClassificationType_BOTH
};

inline const CZMClassificationType (&EnumValuesCZMClassificationType())[3] {
  static const CZMClassificationType values[] = {
    CZMClassificationType_TERRAIN,
    CZMClassificationType_CESIUM_3D_TILE,
    CZMClassificationType_BOTH
  };
  return values;
}

inline const char * const *EnumNamesCZMClassificationType() {
  static const char * const names[4] = {
    "TERRAIN",
    "CESIUM_3D_TILE",
    "BOTH",
    nullptr
  };
  return names;
}

inline const char *EnumNameCZMClassificationType(CZMClassificationType e) {
  if (::flatbuffers::IsOutRange(e, CZMClassificationType_TERRAIN, CZMClassificationType_BOTH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCZMClassificationType()[index];
}

enum CZMLabelStyle : int8_t {
  CZMLabelStyle_FILL = 0,
  CZMLabelStyle_OUTLINE = 1,
  CZMLabelStyle_FILL_AND_OUTLINE = 2,
  CZMLabelStyle_MIN = CZMLabelStyle_FILL,
  CZMLabelStyle_MAX = CZMLabelStyle_FILL_AND_OUTLINE
};

inline const CZMLabelStyle (&EnumValuesCZMLabelStyle())[3] {
  static const CZMLabelStyle values[] = {
    CZMLabelStyle_FILL,
    CZMLabelStyle_OUTLINE,
    CZMLabelStyle_FILL_AND_OUTLINE
  };
  return values;
}

inline const char * const *EnumNamesCZMLabelStyle() {
  static const char * const names[4] = {
    "FILL",
    "OUTLINE",
    "FILL_AND_OUTLINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCZMLabelStyle(CZMLabelStyle e) {
  if (::flatbuffers::IsOutRange(e, CZMLabelStyle_FILL, CZMLabelStyle_FILL_AND_OUTLINE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCZMLabelStyle()[index];
}

enum CZMHorizontalOrigin : int8_t {
  CZMHorizontalOrigin_LEFT = 0,
  CZMHorizontalOrigin_CENTER = 1,
  CZMHorizontalOrigin_RIGHT = 2,
  CZMHorizontalOrigin_MIN = CZMHorizontalOrigin_LEFT,
  CZMHorizontalOrigin_MAX = CZMHorizontalOrigin_RIGHT
};

inline const CZMHorizontalOrigin (&EnumValuesCZMHorizontalOrigin())[3] {
  static const CZMHorizontalOrigin values[] = {
    CZMHorizontalOrigin_LEFT,
    CZMHorizontalOrigin_CENTER,
    CZMHorizontalOrigin_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesCZMHorizontalOrigin() {
  static const char * const names[4] = {
    "LEFT",
    "CENTER",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameCZMHorizontalOrigin(CZMHorizontalOrigin e) {
  if (::flatbuffers::IsOutRange(e, CZMHorizontalOrigin_LEFT, CZMHorizontalOrigin_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCZMHorizontalOrigin()[index];
}

enum CZMVerticalOrigin : int8_t {
  CZMVerticalOrigin_BASELINE = 0,
  CZMVerticalOrigin_BOTTOM = 1,
  CZMVerticalOrigin_CENTER = 2,
  CZMVerticalOrigin_TOP = 3,
  CZMVerticalOrigin_MIN = CZMVerticalOrigin_BASELINE,
  CZMVerticalOrigin_MAX = CZMVerticalOrigin_TOP
};

inline const CZMVerticalOrigin (&EnumValuesCZMVerticalOrigin())[4] {
  static const CZMVerticalOrigin values[] = {
    CZMVerticalOrigin_BASELINE,
    CZMVerticalOrigin_BOTTOM,
    CZMVerticalOrigin_CENTER,
    CZMVerticalOrigin_TOP
  };
  return values;
}

inline const char * const *EnumNamesCZMVerticalOrigin() {
  static const char * const names[5] = {
    "BASELINE",
    "BOTTOM",
    "CENTER",
    "TOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameCZMVerticalOrigin(CZMVerticalOrigin e) {
  if (::flatbuffers::IsOutRange(e, CZMVerticalOrigin_BASELINE, CZMVerticalOrigin_TOP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCZMVerticalOrigin()[index];
}

/// Time interval for time-dynamic properties
struct CZMInterval FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMIntervalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERVAL = 4
  };
  /// ISO 8601 interval string (e.g. "2012-03-15T10:00:00Z/2012-03-16T10:00:00Z")
  const ::flatbuffers::String *INTERVAL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERVAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTERVAL) &&
           verifier.VerifyString(INTERVAL()) &&
           verifier.EndTable();
  }
};

struct CZMIntervalBuilder {
  typedef CZMInterval Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_INTERVAL(::flatbuffers::Offset<::flatbuffers::String> INTERVAL) {
    fbb_.AddOffset(CZMInterval::VT_INTERVAL, INTERVAL);
  }
  explicit CZMIntervalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMInterval> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMInterval>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMInterval> CreateCZMInterval(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> INTERVAL = 0) {
  CZMIntervalBuilder builder_(_fbb);
  builder_.add_INTERVAL(INTERVAL);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMInterval> CreateCZMIntervalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *INTERVAL = nullptr) {
  auto INTERVAL__ = INTERVAL ? _fbb.CreateString(INTERVAL) : 0;
  return CreateCZMInterval(
      _fbb,
      INTERVAL__);
}

/// Cartographic position (longitude, latitude, height in radians/meters)
struct CZMCartographicDegrees FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMCartographicDegreesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_HEIGHT = 8
  };
  /// Longitude in degrees
  double LONGITUDE() const {
    return GetField<double>(VT_LONGITUDE, 0.0);
  }
  /// Latitude in degrees
  double LATITUDE() const {
    return GetField<double>(VT_LATITUDE, 0.0);
  }
  /// Height in meters above WGS84 ellipsoid
  double HEIGHT() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_LONGITUDE, 8) &&
           VerifyField<double>(verifier, VT_LATITUDE, 8) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           verifier.EndTable();
  }
};

struct CZMCartographicDegreesBuilder {
  typedef CZMCartographicDegrees Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_LONGITUDE(double LONGITUDE) {
    fbb_.AddElement<double>(CZMCartographicDegrees::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  void add_LATITUDE(double LATITUDE) {
    fbb_.AddElement<double>(CZMCartographicDegrees::VT_LATITUDE, LATITUDE, 0.0);
  }
  void add_HEIGHT(double HEIGHT) {
    fbb_.AddElement<double>(CZMCartographicDegrees::VT_HEIGHT, HEIGHT, 0.0);
  }
  explicit CZMCartographicDegreesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMCartographicDegrees> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMCartographicDegrees>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMCartographicDegrees> CreateCZMCartographicDegrees(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double LONGITUDE = 0.0,
    double LATITUDE = 0.0,
    double HEIGHT = 0.0) {
  CZMCartographicDegreesBuilder builder_(_fbb);
  builder_.add_HEIGHT(HEIGHT);
  builder_.add_LATITUDE(LATITUDE);
  builder_.add_LONGITUDE(LONGITUDE);
  return builder_.Finish();
}

/// Cartesian position (X, Y, Z in meters)
struct CZMCartesian FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMCartesianBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  /// X component in meters (Earth-fixed)
  double X() const {
    return GetField<double>(VT_X, 0.0);
  }
  /// Y component in meters (Earth-fixed)
  double Y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  /// Z component in meters (Earth-fixed)
  double Z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           verifier.EndTable();
  }
};

struct CZMCartesianBuilder {
  typedef CZMCartesian Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_X(double X) {
    fbb_.AddElement<double>(CZMCartesian::VT_X, X, 0.0);
  }
  void add_Y(double Y) {
    fbb_.AddElement<double>(CZMCartesian::VT_Y, Y, 0.0);
  }
  void add_Z(double Z) {
    fbb_.AddElement<double>(CZMCartesian::VT_Z, Z, 0.0);
  }
  explicit CZMCartesianBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMCartesian> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMCartesian>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMCartesian> CreateCZMCartesian(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double X = 0.0,
    double Y = 0.0,
    double Z = 0.0) {
  CZMCartesianBuilder builder_(_fbb);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  return builder_.Finish();
}

/// RGBA color
struct CZMColor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  /// Red component (0-255)
  uint8_t RED() const {
    return GetField<uint8_t>(VT_RED, 0);
  }
  /// Green component (0-255)
  uint8_t GREEN() const {
    return GetField<uint8_t>(VT_GREEN, 0);
  }
  /// Blue component (0-255)
  uint8_t BLUE() const {
    return GetField<uint8_t>(VT_BLUE, 0);
  }
  /// Alpha component (0-255)
  uint8_t ALPHA() const {
    return GetField<uint8_t>(VT_ALPHA, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RED, 1) &&
           VerifyField<uint8_t>(verifier, VT_GREEN, 1) &&
           VerifyField<uint8_t>(verifier, VT_BLUE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALPHA, 1) &&
           verifier.EndTable();
  }
};

struct CZMColorBuilder {
  typedef CZMColor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RED(uint8_t RED) {
    fbb_.AddElement<uint8_t>(CZMColor::VT_RED, RED, 0);
  }
  void add_GREEN(uint8_t GREEN) {
    fbb_.AddElement<uint8_t>(CZMColor::VT_GREEN, GREEN, 0);
  }
  void add_BLUE(uint8_t BLUE) {
    fbb_.AddElement<uint8_t>(CZMColor::VT_BLUE, BLUE, 0);
  }
  void add_ALPHA(uint8_t ALPHA) {
    fbb_.AddElement<uint8_t>(CZMColor::VT_ALPHA, ALPHA, 0);
  }
  explicit CZMColorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMColor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMColor> CreateCZMColor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t RED = 0,
    uint8_t GREEN = 0,
    uint8_t BLUE = 0,
    uint8_t ALPHA = 0) {
  CZMColorBuilder builder_(_fbb);
  builder_.add_ALPHA(ALPHA);
  builder_.add_BLUE(BLUE);
  builder_.add_GREEN(GREEN);
  builder_.add_RED(RED);
  return builder_.Finish();
}

/// Near/Far scalar for distance-based display
struct CZMNearFarScalar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMNearFarScalarBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEAR_DISTANCE = 4,
    VT_NEAR_VALUE = 6,
    VT_FAR_DISTANCE = 8,
    VT_FAR_VALUE = 10
  };
  /// Near distance in meters
  double NEAR_DISTANCE() const {
    return GetField<double>(VT_NEAR_DISTANCE, 0.0);
  }
  /// Value at near distance
  double NEAR_VALUE() const {
    return GetField<double>(VT_NEAR_VALUE, 0.0);
  }
  /// Far distance in meters
  double FAR_DISTANCE() const {
    return GetField<double>(VT_FAR_DISTANCE, 0.0);
  }
  /// Value at far distance
  double FAR_VALUE() const {
    return GetField<double>(VT_FAR_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_NEAR_DISTANCE, 8) &&
           VerifyField<double>(verifier, VT_NEAR_VALUE, 8) &&
           VerifyField<double>(verifier, VT_FAR_DISTANCE, 8) &&
           VerifyField<double>(verifier, VT_FAR_VALUE, 8) &&
           verifier.EndTable();
  }
};

struct CZMNearFarScalarBuilder {
  typedef CZMNearFarScalar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NEAR_DISTANCE(double NEAR_DISTANCE) {
    fbb_.AddElement<double>(CZMNearFarScalar::VT_NEAR_DISTANCE, NEAR_DISTANCE, 0.0);
  }
  void add_NEAR_VALUE(double NEAR_VALUE) {
    fbb_.AddElement<double>(CZMNearFarScalar::VT_NEAR_VALUE, NEAR_VALUE, 0.0);
  }
  void add_FAR_DISTANCE(double FAR_DISTANCE) {
    fbb_.AddElement<double>(CZMNearFarScalar::VT_FAR_DISTANCE, FAR_DISTANCE, 0.0);
  }
  void add_FAR_VALUE(double FAR_VALUE) {
    fbb_.AddElement<double>(CZMNearFarScalar::VT_FAR_VALUE, FAR_VALUE, 0.0);
  }
  explicit CZMNearFarScalarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMNearFarScalar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMNearFarScalar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMNearFarScalar> CreateCZMNearFarScalar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double NEAR_DISTANCE = 0.0,
    double NEAR_VALUE = 0.0,
    double FAR_DISTANCE = 0.0,
    double FAR_VALUE = 0.0) {
  CZMNearFarScalarBuilder builder_(_fbb);
  builder_.add_FAR_VALUE(FAR_VALUE);
  builder_.add_FAR_DISTANCE(FAR_DISTANCE);
  builder_.add_NEAR_VALUE(NEAR_VALUE);
  builder_.add_NEAR_DISTANCE(NEAR_DISTANCE);
  return builder_.Finish();
}

/// Billboard (icon) properties
struct CZMBillboard FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMBillboardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_IMAGE = 6,
    VT_SCALE = 8,
    VT_COLOR = 10,
    VT_HEIGHT_REFERENCE = 12,
    VT_PIXEL_OFFSET_X = 14,
    VT_PIXEL_OFFSET_Y = 16,
    VT_HORIZONTAL_ORIGIN = 18,
    VT_VERTICAL_ORIGIN = 20,
    VT_TRANSLUCENCY_BY_DISTANCE = 22
  };
  /// Whether the billboard is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// URI of the billboard image
  const ::flatbuffers::String *IMAGE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGE);
  }
  /// Scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  /// Billboard color tint
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  /// Pixel offset X
  double PIXEL_OFFSET_X() const {
    return GetField<double>(VT_PIXEL_OFFSET_X, 0.0);
  }
  /// Pixel offset Y
  double PIXEL_OFFSET_Y() const {
    return GetField<double>(VT_PIXEL_OFFSET_Y, 0.0);
  }
  /// Horizontal origin
  CZMHorizontalOrigin HORIZONTAL_ORIGIN() const {
    return static_cast<CZMHorizontalOrigin>(GetField<int8_t>(VT_HORIZONTAL_ORIGIN, 0));
  }
  /// Vertical origin
  CZMVerticalOrigin VERTICAL_ORIGIN() const {
    return static_cast<CZMVerticalOrigin>(GetField<int8_t>(VT_VERTICAL_ORIGIN, 0));
  }
  /// Translucency by distance
  const CZMNearFarScalar *TRANSLUCENCY_BY_DISTANCE() const {
    return GetPointer<const CZMNearFarScalar *>(VT_TRANSLUCENCY_BY_DISTANCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           verifier.VerifyString(IMAGE()) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           VerifyField<double>(verifier, VT_PIXEL_OFFSET_X, 8) &&
           VerifyField<double>(verifier, VT_PIXEL_OFFSET_Y, 8) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTAL_ORIGIN, 1) &&
           VerifyField<int8_t>(verifier, VT_VERTICAL_ORIGIN, 1) &&
           VerifyOffset(verifier, VT_TRANSLUCENCY_BY_DISTANCE) &&
           verifier.VerifyTable(TRANSLUCENCY_BY_DISTANCE()) &&
           verifier.EndTable();
  }
};

struct CZMBillboardBuilder {
  typedef CZMBillboard Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMBillboard::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_IMAGE(::flatbuffers::Offset<::flatbuffers::String> IMAGE) {
    fbb_.AddOffset(CZMBillboard::VT_IMAGE, IMAGE);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(CZMBillboard::VT_SCALE, SCALE, 0.0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMBillboard::VT_COLOR, COLOR);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMBillboard::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  void add_PIXEL_OFFSET_X(double PIXEL_OFFSET_X) {
    fbb_.AddElement<double>(CZMBillboard::VT_PIXEL_OFFSET_X, PIXEL_OFFSET_X, 0.0);
  }
  void add_PIXEL_OFFSET_Y(double PIXEL_OFFSET_Y) {
    fbb_.AddElement<double>(CZMBillboard::VT_PIXEL_OFFSET_Y, PIXEL_OFFSET_Y, 0.0);
  }
  void add_HORIZONTAL_ORIGIN(CZMHorizontalOrigin HORIZONTAL_ORIGIN) {
    fbb_.AddElement<int8_t>(CZMBillboard::VT_HORIZONTAL_ORIGIN, static_cast<int8_t>(HORIZONTAL_ORIGIN), 0);
  }
  void add_VERTICAL_ORIGIN(CZMVerticalOrigin VERTICAL_ORIGIN) {
    fbb_.AddElement<int8_t>(CZMBillboard::VT_VERTICAL_ORIGIN, static_cast<int8_t>(VERTICAL_ORIGIN), 0);
  }
  void add_TRANSLUCENCY_BY_DISTANCE(::flatbuffers::Offset<CZMNearFarScalar> TRANSLUCENCY_BY_DISTANCE) {
    fbb_.AddOffset(CZMBillboard::VT_TRANSLUCENCY_BY_DISTANCE, TRANSLUCENCY_BY_DISTANCE);
  }
  explicit CZMBillboardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMBillboard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMBillboard>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMBillboard> CreateCZMBillboard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<::flatbuffers::String> IMAGE = 0,
    double SCALE = 0.0,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    double PIXEL_OFFSET_X = 0.0,
    double PIXEL_OFFSET_Y = 0.0,
    CZMHorizontalOrigin HORIZONTAL_ORIGIN = CZMHorizontalOrigin_LEFT,
    CZMVerticalOrigin VERTICAL_ORIGIN = CZMVerticalOrigin_BASELINE,
    ::flatbuffers::Offset<CZMNearFarScalar> TRANSLUCENCY_BY_DISTANCE = 0) {
  CZMBillboardBuilder builder_(_fbb);
  builder_.add_PIXEL_OFFSET_Y(PIXEL_OFFSET_Y);
  builder_.add_PIXEL_OFFSET_X(PIXEL_OFFSET_X);
  builder_.add_SCALE(SCALE);
  builder_.add_TRANSLUCENCY_BY_DISTANCE(TRANSLUCENCY_BY_DISTANCE);
  builder_.add_COLOR(COLOR);
  builder_.add_IMAGE(IMAGE);
  builder_.add_VERTICAL_ORIGIN(VERTICAL_ORIGIN);
  builder_.add_HORIZONTAL_ORIGIN(HORIZONTAL_ORIGIN);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMBillboard> CreateCZMBillboardDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    const char *IMAGE = nullptr,
    double SCALE = 0.0,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    double PIXEL_OFFSET_X = 0.0,
    double PIXEL_OFFSET_Y = 0.0,
    CZMHorizontalOrigin HORIZONTAL_ORIGIN = CZMHorizontalOrigin_LEFT,
    CZMVerticalOrigin VERTICAL_ORIGIN = CZMVerticalOrigin_BASELINE,
    ::flatbuffers::Offset<CZMNearFarScalar> TRANSLUCENCY_BY_DISTANCE = 0) {
  auto IMAGE__ = IMAGE ? _fbb.CreateString(IMAGE) : 0;
  return CreateCZMBillboard(
      _fbb,
      SHOW,
      IMAGE__,
      SCALE,
      COLOR,
      HEIGHT_REFERENCE,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      TRANSLUCENCY_BY_DISTANCE);
}

/// Label properties
struct CZMLabel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMLabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_TEXT = 6,
    VT_FONT = 8,
    VT_STYLE = 10,
    VT_FILL_COLOR = 12,
    VT_OUTLINE_COLOR = 14,
    VT_OUTLINE_WIDTH = 16,
    VT_PIXEL_OFFSET_X = 18,
    VT_PIXEL_OFFSET_Y = 20,
    VT_SCALE = 22,
    VT_HORIZONTAL_ORIGIN = 24,
    VT_VERTICAL_ORIGIN = 26,
    VT_HEIGHT_REFERENCE = 28
  };
  /// Whether the label is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Label text
  const ::flatbuffers::String *TEXT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  /// Font CSS string (e.g. "12pt Lucida Console")
  const ::flatbuffers::String *FONT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONT);
  }
  /// Label style
  CZMLabelStyle STYLE() const {
    return static_cast<CZMLabelStyle>(GetField<int8_t>(VT_STYLE, 0));
  }
  /// Fill color
  const CZMColor *FILL_COLOR() const {
    return GetPointer<const CZMColor *>(VT_FILL_COLOR);
  }
  /// Outline color
  const CZMColor *OUTLINE_COLOR() const {
    return GetPointer<const CZMColor *>(VT_OUTLINE_COLOR);
  }
  /// Outline width in pixels
  double OUTLINE_WIDTH() const {
    return GetField<double>(VT_OUTLINE_WIDTH, 0.0);
  }
  /// Pixel offset X
  double PIXEL_OFFSET_X() const {
    return GetField<double>(VT_PIXEL_OFFSET_X, 0.0);
  }
  /// Pixel offset Y
  double PIXEL_OFFSET_Y() const {
    return GetField<double>(VT_PIXEL_OFFSET_Y, 0.0);
  }
  /// Scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  /// Horizontal origin
  CZMHorizontalOrigin HORIZONTAL_ORIGIN() const {
    return static_cast<CZMHorizontalOrigin>(GetField<int8_t>(VT_HORIZONTAL_ORIGIN, 0));
  }
  /// Vertical origin
  CZMVerticalOrigin VERTICAL_ORIGIN() const {
    return static_cast<CZMVerticalOrigin>(GetField<int8_t>(VT_VERTICAL_ORIGIN, 0));
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(TEXT()) &&
           VerifyOffset(verifier, VT_FONT) &&
           verifier.VerifyString(FONT()) &&
           VerifyField<int8_t>(verifier, VT_STYLE, 1) &&
           VerifyOffset(verifier, VT_FILL_COLOR) &&
           verifier.VerifyTable(FILL_COLOR()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(OUTLINE_COLOR()) &&
           VerifyField<double>(verifier, VT_OUTLINE_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_PIXEL_OFFSET_X, 8) &&
           VerifyField<double>(verifier, VT_PIXEL_OFFSET_Y, 8) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTAL_ORIGIN, 1) &&
           VerifyField<int8_t>(verifier, VT_VERTICAL_ORIGIN, 1) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           verifier.EndTable();
  }
};

struct CZMLabelBuilder {
  typedef CZMLabel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMLabel::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_TEXT(::flatbuffers::Offset<::flatbuffers::String> TEXT) {
    fbb_.AddOffset(CZMLabel::VT_TEXT, TEXT);
  }
  void add_FONT(::flatbuffers::Offset<::flatbuffers::String> FONT) {
    fbb_.AddOffset(CZMLabel::VT_FONT, FONT);
  }
  void add_STYLE(CZMLabelStyle STYLE) {
    fbb_.AddElement<int8_t>(CZMLabel::VT_STYLE, static_cast<int8_t>(STYLE), 0);
  }
  void add_FILL_COLOR(::flatbuffers::Offset<CZMColor> FILL_COLOR) {
    fbb_.AddOffset(CZMLabel::VT_FILL_COLOR, FILL_COLOR);
  }
  void add_OUTLINE_COLOR(::flatbuffers::Offset<CZMColor> OUTLINE_COLOR) {
    fbb_.AddOffset(CZMLabel::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  void add_OUTLINE_WIDTH(double OUTLINE_WIDTH) {
    fbb_.AddElement<double>(CZMLabel::VT_OUTLINE_WIDTH, OUTLINE_WIDTH, 0.0);
  }
  void add_PIXEL_OFFSET_X(double PIXEL_OFFSET_X) {
    fbb_.AddElement<double>(CZMLabel::VT_PIXEL_OFFSET_X, PIXEL_OFFSET_X, 0.0);
  }
  void add_PIXEL_OFFSET_Y(double PIXEL_OFFSET_Y) {
    fbb_.AddElement<double>(CZMLabel::VT_PIXEL_OFFSET_Y, PIXEL_OFFSET_Y, 0.0);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(CZMLabel::VT_SCALE, SCALE, 0.0);
  }
  void add_HORIZONTAL_ORIGIN(CZMHorizontalOrigin HORIZONTAL_ORIGIN) {
    fbb_.AddElement<int8_t>(CZMLabel::VT_HORIZONTAL_ORIGIN, static_cast<int8_t>(HORIZONTAL_ORIGIN), 0);
  }
  void add_VERTICAL_ORIGIN(CZMVerticalOrigin VERTICAL_ORIGIN) {
    fbb_.AddElement<int8_t>(CZMLabel::VT_VERTICAL_ORIGIN, static_cast<int8_t>(VERTICAL_ORIGIN), 0);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMLabel::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  explicit CZMLabelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMLabel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMLabel> CreateCZMLabel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<::flatbuffers::String> TEXT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> FONT = 0,
    CZMLabelStyle STYLE = CZMLabelStyle_FILL,
    ::flatbuffers::Offset<CZMColor> FILL_COLOR = 0,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double OUTLINE_WIDTH = 0.0,
    double PIXEL_OFFSET_X = 0.0,
    double PIXEL_OFFSET_Y = 0.0,
    double SCALE = 0.0,
    CZMHorizontalOrigin HORIZONTAL_ORIGIN = CZMHorizontalOrigin_LEFT,
    CZMVerticalOrigin VERTICAL_ORIGIN = CZMVerticalOrigin_BASELINE,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE) {
  CZMLabelBuilder builder_(_fbb);
  builder_.add_SCALE(SCALE);
  builder_.add_PIXEL_OFFSET_Y(PIXEL_OFFSET_Y);
  builder_.add_PIXEL_OFFSET_X(PIXEL_OFFSET_X);
  builder_.add_OUTLINE_WIDTH(OUTLINE_WIDTH);
  builder_.add_OUTLINE_COLOR(OUTLINE_COLOR);
  builder_.add_FILL_COLOR(FILL_COLOR);
  builder_.add_FONT(FONT);
  builder_.add_TEXT(TEXT);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_VERTICAL_ORIGIN(VERTICAL_ORIGIN);
  builder_.add_HORIZONTAL_ORIGIN(HORIZONTAL_ORIGIN);
  builder_.add_STYLE(STYLE);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMLabel> CreateCZMLabelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    const char *TEXT = nullptr,
    const char *FONT = nullptr,
    CZMLabelStyle STYLE = CZMLabelStyle_FILL,
    ::flatbuffers::Offset<CZMColor> FILL_COLOR = 0,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double OUTLINE_WIDTH = 0.0,
    double PIXEL_OFFSET_X = 0.0,
    double PIXEL_OFFSET_Y = 0.0,
    double SCALE = 0.0,
    CZMHorizontalOrigin HORIZONTAL_ORIGIN = CZMHorizontalOrigin_LEFT,
    CZMVerticalOrigin VERTICAL_ORIGIN = CZMVerticalOrigin_BASELINE,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE) {
  auto TEXT__ = TEXT ? _fbb.CreateString(TEXT) : 0;
  auto FONT__ = FONT ? _fbb.CreateString(FONT) : 0;
  return CreateCZMLabel(
      _fbb,
      SHOW,
      TEXT__,
      FONT__,
      STYLE,
      FILL_COLOR,
      OUTLINE_COLOR,
      OUTLINE_WIDTH,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      SCALE,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      HEIGHT_REFERENCE);
}

/// Point properties
struct CZMPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_COLOR = 6,
    VT_OUTLINE_COLOR = 8,
    VT_OUTLINE_WIDTH = 10,
    VT_PIXEL_SIZE = 12,
    VT_HEIGHT_REFERENCE = 14
  };
  /// Whether the point is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Point color
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Outline color
  const CZMColor *OUTLINE_COLOR() const {
    return GetPointer<const CZMColor *>(VT_OUTLINE_COLOR);
  }
  /// Outline width in pixels
  double OUTLINE_WIDTH() const {
    return GetField<double>(VT_OUTLINE_WIDTH, 0.0);
  }
  /// Pixel size
  double PIXEL_SIZE() const {
    return GetField<double>(VT_PIXEL_SIZE, 0.0);
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(OUTLINE_COLOR()) &&
           VerifyField<double>(verifier, VT_OUTLINE_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_PIXEL_SIZE, 8) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           verifier.EndTable();
  }
};

struct CZMPointBuilder {
  typedef CZMPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMPoint::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMPoint::VT_COLOR, COLOR);
  }
  void add_OUTLINE_COLOR(::flatbuffers::Offset<CZMColor> OUTLINE_COLOR) {
    fbb_.AddOffset(CZMPoint::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  void add_OUTLINE_WIDTH(double OUTLINE_WIDTH) {
    fbb_.AddElement<double>(CZMPoint::VT_OUTLINE_WIDTH, OUTLINE_WIDTH, 0.0);
  }
  void add_PIXEL_SIZE(double PIXEL_SIZE) {
    fbb_.AddElement<double>(CZMPoint::VT_PIXEL_SIZE, PIXEL_SIZE, 0.0);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMPoint::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  explicit CZMPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMPoint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMPoint> CreateCZMPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double OUTLINE_WIDTH = 0.0,
    double PIXEL_SIZE = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE) {
  CZMPointBuilder builder_(_fbb);
  builder_.add_PIXEL_SIZE(PIXEL_SIZE);
  builder_.add_OUTLINE_WIDTH(OUTLINE_WIDTH);
  builder_.add_OUTLINE_COLOR(OUTLINE_COLOR);
  builder_.add_COLOR(COLOR);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

/// Polyline properties
struct CZMPolyline FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMPolylineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_POSITIONS_CARTOGRAPHIC_DEGREES = 6,
    VT_POSITIONS_CARTESIAN = 8,
    VT_WIDTH = 10,
    VT_COLOR = 12,
    VT_CLAMP_TO_GROUND = 14
  };
  /// Whether the polyline is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Positions as cartographic degrees [lon, lat, height, lon, lat, height, ...]
  const ::flatbuffers::Vector<double> *POSITIONS_CARTOGRAPHIC_DEGREES() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  /// Positions as Cartesian [X, Y, Z, X, Y, Z, ...]
  const ::flatbuffers::Vector<double> *POSITIONS_CARTESIAN() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITIONS_CARTESIAN);
  }
  /// Line width in pixels
  double WIDTH() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  /// Line color (solid color material)
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Whether to clamp to ground
  bool CLAMP_TO_GROUND() const {
    return GetField<uint8_t>(VT_CLAMP_TO_GROUND, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_POSITIONS_CARTOGRAPHIC_DEGREES) &&
           verifier.VerifyVector(POSITIONS_CARTOGRAPHIC_DEGREES()) &&
           VerifyOffset(verifier, VT_POSITIONS_CARTESIAN) &&
           verifier.VerifyVector(POSITIONS_CARTESIAN()) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyField<uint8_t>(verifier, VT_CLAMP_TO_GROUND, 1) &&
           verifier.EndTable();
  }
};

struct CZMPolylineBuilder {
  typedef CZMPolyline Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMPolyline::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_POSITIONS_CARTOGRAPHIC_DEGREES(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTOGRAPHIC_DEGREES) {
    fbb_.AddOffset(CZMPolyline::VT_POSITIONS_CARTOGRAPHIC_DEGREES, POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  void add_POSITIONS_CARTESIAN(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTESIAN) {
    fbb_.AddOffset(CZMPolyline::VT_POSITIONS_CARTESIAN, POSITIONS_CARTESIAN);
  }
  void add_WIDTH(double WIDTH) {
    fbb_.AddElement<double>(CZMPolyline::VT_WIDTH, WIDTH, 0.0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMPolyline::VT_COLOR, COLOR);
  }
  void add_CLAMP_TO_GROUND(bool CLAMP_TO_GROUND) {
    fbb_.AddElement<uint8_t>(CZMPolyline::VT_CLAMP_TO_GROUND, static_cast<uint8_t>(CLAMP_TO_GROUND), 0);
  }
  explicit CZMPolylineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMPolyline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMPolyline>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMPolyline> CreateCZMPolyline(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTOGRAPHIC_DEGREES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTESIAN = 0,
    double WIDTH = 0.0,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    bool CLAMP_TO_GROUND = false) {
  CZMPolylineBuilder builder_(_fbb);
  builder_.add_WIDTH(WIDTH);
  builder_.add_COLOR(COLOR);
  builder_.add_POSITIONS_CARTESIAN(POSITIONS_CARTESIAN);
  builder_.add_POSITIONS_CARTOGRAPHIC_DEGREES(POSITIONS_CARTOGRAPHIC_DEGREES);
  builder_.add_CLAMP_TO_GROUND(CLAMP_TO_GROUND);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMPolyline> CreateCZMPolylineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    const std::vector<double> *POSITIONS_CARTOGRAPHIC_DEGREES = nullptr,
    const std::vector<double> *POSITIONS_CARTESIAN = nullptr,
    double WIDTH = 0.0,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    bool CLAMP_TO_GROUND = false) {
  auto POSITIONS_CARTOGRAPHIC_DEGREES__ = POSITIONS_CARTOGRAPHIC_DEGREES ? _fbb.CreateVector<double>(*POSITIONS_CARTOGRAPHIC_DEGREES) : 0;
  auto POSITIONS_CARTESIAN__ = POSITIONS_CARTESIAN ? _fbb.CreateVector<double>(*POSITIONS_CARTESIAN) : 0;
  return CreateCZMPolyline(
      _fbb,
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES__,
      POSITIONS_CARTESIAN__,
      WIDTH,
      COLOR,
      CLAMP_TO_GROUND);
}

/// Polygon properties
struct CZMPolygon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMPolygonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_POSITIONS_CARTOGRAPHIC_DEGREES = 6,
    VT_POSITIONS_CARTESIAN = 8,
    VT_FILL = 10,
    VT_COLOR = 12,
    VT_OUTLINE = 14,
    VT_OUTLINE_COLOR = 16,
    VT_EXTRUDED_HEIGHT = 18,
    VT_HEIGHT_REFERENCE = 20,
    VT_CLASSIFICATION_TYPE = 22
  };
  /// Whether the polygon is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Positions as cartographic degrees [lon, lat, height, ...]
  const ::flatbuffers::Vector<double> *POSITIONS_CARTOGRAPHIC_DEGREES() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  /// Positions as Cartesian [X, Y, Z, ...]
  const ::flatbuffers::Vector<double> *POSITIONS_CARTESIAN() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITIONS_CARTESIAN);
  }
  /// Fill flag
  bool FILL() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  /// Fill color (solid color material)
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Outline flag
  bool OUTLINE() const {
    return GetField<uint8_t>(VT_OUTLINE, 0) != 0;
  }
  /// Outline color
  const CZMColor *OUTLINE_COLOR() const {
    return GetPointer<const CZMColor *>(VT_OUTLINE_COLOR);
  }
  /// Extruded height in meters
  double EXTRUDED_HEIGHT() const {
    return GetField<double>(VT_EXTRUDED_HEIGHT, 0.0);
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  /// Classification type
  CZMClassificationType CLASSIFICATION_TYPE() const {
    return static_cast<CZMClassificationType>(GetField<int8_t>(VT_CLASSIFICATION_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_POSITIONS_CARTOGRAPHIC_DEGREES) &&
           verifier.VerifyVector(POSITIONS_CARTOGRAPHIC_DEGREES()) &&
           VerifyOffset(verifier, VT_POSITIONS_CARTESIAN) &&
           verifier.VerifyVector(POSITIONS_CARTESIAN()) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyField<uint8_t>(verifier, VT_OUTLINE, 1) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(OUTLINE_COLOR()) &&
           VerifyField<double>(verifier, VT_EXTRUDED_HEIGHT, 8) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           VerifyField<int8_t>(verifier, VT_CLASSIFICATION_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct CZMPolygonBuilder {
  typedef CZMPolygon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMPolygon::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_POSITIONS_CARTOGRAPHIC_DEGREES(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTOGRAPHIC_DEGREES) {
    fbb_.AddOffset(CZMPolygon::VT_POSITIONS_CARTOGRAPHIC_DEGREES, POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  void add_POSITIONS_CARTESIAN(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTESIAN) {
    fbb_.AddOffset(CZMPolygon::VT_POSITIONS_CARTESIAN, POSITIONS_CARTESIAN);
  }
  void add_FILL(bool FILL) {
    fbb_.AddElement<uint8_t>(CZMPolygon::VT_FILL, static_cast<uint8_t>(FILL), 0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMPolygon::VT_COLOR, COLOR);
  }
  void add_OUTLINE(bool OUTLINE) {
    fbb_.AddElement<uint8_t>(CZMPolygon::VT_OUTLINE, static_cast<uint8_t>(OUTLINE), 0);
  }
  void add_OUTLINE_COLOR(::flatbuffers::Offset<CZMColor> OUTLINE_COLOR) {
    fbb_.AddOffset(CZMPolygon::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  void add_EXTRUDED_HEIGHT(double EXTRUDED_HEIGHT) {
    fbb_.AddElement<double>(CZMPolygon::VT_EXTRUDED_HEIGHT, EXTRUDED_HEIGHT, 0.0);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMPolygon::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  void add_CLASSIFICATION_TYPE(CZMClassificationType CLASSIFICATION_TYPE) {
    fbb_.AddElement<int8_t>(CZMPolygon::VT_CLASSIFICATION_TYPE, static_cast<int8_t>(CLASSIFICATION_TYPE), 0);
  }
  explicit CZMPolygonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMPolygon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMPolygon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMPolygon> CreateCZMPolygon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTOGRAPHIC_DEGREES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITIONS_CARTESIAN = 0,
    bool FILL = false,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    bool OUTLINE = false,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double EXTRUDED_HEIGHT = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    CZMClassificationType CLASSIFICATION_TYPE = CZMClassificationType_TERRAIN) {
  CZMPolygonBuilder builder_(_fbb);
  builder_.add_EXTRUDED_HEIGHT(EXTRUDED_HEIGHT);
  builder_.add_OUTLINE_COLOR(OUTLINE_COLOR);
  builder_.add_COLOR(COLOR);
  builder_.add_POSITIONS_CARTESIAN(POSITIONS_CARTESIAN);
  builder_.add_POSITIONS_CARTOGRAPHIC_DEGREES(POSITIONS_CARTOGRAPHIC_DEGREES);
  builder_.add_CLASSIFICATION_TYPE(CLASSIFICATION_TYPE);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_OUTLINE(OUTLINE);
  builder_.add_FILL(FILL);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMPolygon> CreateCZMPolygonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    const std::vector<double> *POSITIONS_CARTOGRAPHIC_DEGREES = nullptr,
    const std::vector<double> *POSITIONS_CARTESIAN = nullptr,
    bool FILL = false,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    bool OUTLINE = false,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double EXTRUDED_HEIGHT = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    CZMClassificationType CLASSIFICATION_TYPE = CZMClassificationType_TERRAIN) {
  auto POSITIONS_CARTOGRAPHIC_DEGREES__ = POSITIONS_CARTOGRAPHIC_DEGREES ? _fbb.CreateVector<double>(*POSITIONS_CARTOGRAPHIC_DEGREES) : 0;
  auto POSITIONS_CARTESIAN__ = POSITIONS_CARTESIAN ? _fbb.CreateVector<double>(*POSITIONS_CARTESIAN) : 0;
  return CreateCZMPolygon(
      _fbb,
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES__,
      POSITIONS_CARTESIAN__,
      FILL,
      COLOR,
      OUTLINE,
      OUTLINE_COLOR,
      EXTRUDED_HEIGHT,
      HEIGHT_REFERENCE,
      CLASSIFICATION_TYPE);
}

/// Model properties (glTF)
struct CZMModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_GLTF = 6,
    VT_SCALE = 8,
    VT_MINIMUM_PIXEL_SIZE = 10,
    VT_MAXIMUM_SCALE = 12,
    VT_HEIGHT_REFERENCE = 14,
    VT_COLOR = 16
  };
  /// Whether the model is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// URI to the glTF model
  const ::flatbuffers::String *GLTF() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GLTF);
  }
  /// Scale factor
  double SCALE() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  /// Minimum pixel size
  double MINIMUM_PIXEL_SIZE() const {
    return GetField<double>(VT_MINIMUM_PIXEL_SIZE, 0.0);
  }
  /// Maximum scale
  double MAXIMUM_SCALE() const {
    return GetField<double>(VT_MAXIMUM_SCALE, 0.0);
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  /// Color tint
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyOffset(verifier, VT_GLTF) &&
           verifier.VerifyString(GLTF()) &&
           VerifyField<double>(verifier, VT_SCALE, 8) &&
           VerifyField<double>(verifier, VT_MINIMUM_PIXEL_SIZE, 8) &&
           VerifyField<double>(verifier, VT_MAXIMUM_SCALE, 8) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           verifier.EndTable();
  }
};

struct CZMModelBuilder {
  typedef CZMModel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMModel::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_GLTF(::flatbuffers::Offset<::flatbuffers::String> GLTF) {
    fbb_.AddOffset(CZMModel::VT_GLTF, GLTF);
  }
  void add_SCALE(double SCALE) {
    fbb_.AddElement<double>(CZMModel::VT_SCALE, SCALE, 0.0);
  }
  void add_MINIMUM_PIXEL_SIZE(double MINIMUM_PIXEL_SIZE) {
    fbb_.AddElement<double>(CZMModel::VT_MINIMUM_PIXEL_SIZE, MINIMUM_PIXEL_SIZE, 0.0);
  }
  void add_MAXIMUM_SCALE(double MAXIMUM_SCALE) {
    fbb_.AddElement<double>(CZMModel::VT_MAXIMUM_SCALE, MAXIMUM_SCALE, 0.0);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMModel::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMModel::VT_COLOR, COLOR);
  }
  explicit CZMModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMModel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMModel> CreateCZMModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    ::flatbuffers::Offset<::flatbuffers::String> GLTF = 0,
    double SCALE = 0.0,
    double MINIMUM_PIXEL_SIZE = 0.0,
    double MAXIMUM_SCALE = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    ::flatbuffers::Offset<CZMColor> COLOR = 0) {
  CZMModelBuilder builder_(_fbb);
  builder_.add_MAXIMUM_SCALE(MAXIMUM_SCALE);
  builder_.add_MINIMUM_PIXEL_SIZE(MINIMUM_PIXEL_SIZE);
  builder_.add_SCALE(SCALE);
  builder_.add_COLOR(COLOR);
  builder_.add_GLTF(GLTF);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMModel> CreateCZMModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    const char *GLTF = nullptr,
    double SCALE = 0.0,
    double MINIMUM_PIXEL_SIZE = 0.0,
    double MAXIMUM_SCALE = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE,
    ::flatbuffers::Offset<CZMColor> COLOR = 0) {
  auto GLTF__ = GLTF ? _fbb.CreateString(GLTF) : 0;
  return CreateCZMModel(
      _fbb,
      SHOW,
      GLTF__,
      SCALE,
      MINIMUM_PIXEL_SIZE,
      MAXIMUM_SCALE,
      HEIGHT_REFERENCE,
      COLOR);
}

/// Path properties (orbit trail)
struct CZMPath FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMPathBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_LEAD_TIME = 6,
    VT_TRAIL_TIME = 8,
    VT_WIDTH = 10,
    VT_COLOR = 12,
    VT_RESOLUTION = 14
  };
  /// Whether the path is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Trail time in seconds (how far behind)
  double LEAD_TIME() const {
    return GetField<double>(VT_LEAD_TIME, 0.0);
  }
  /// Lead time in seconds (how far ahead)
  double TRAIL_TIME() const {
    return GetField<double>(VT_TRAIL_TIME, 0.0);
  }
  /// Line width in pixels
  double WIDTH() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  /// Path color
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Resolution in seconds
  double RESOLUTION() const {
    return GetField<double>(VT_RESOLUTION, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyField<double>(verifier, VT_LEAD_TIME, 8) &&
           VerifyField<double>(verifier, VT_TRAIL_TIME, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyField<double>(verifier, VT_RESOLUTION, 8) &&
           verifier.EndTable();
  }
};

struct CZMPathBuilder {
  typedef CZMPath Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMPath::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_LEAD_TIME(double LEAD_TIME) {
    fbb_.AddElement<double>(CZMPath::VT_LEAD_TIME, LEAD_TIME, 0.0);
  }
  void add_TRAIL_TIME(double TRAIL_TIME) {
    fbb_.AddElement<double>(CZMPath::VT_TRAIL_TIME, TRAIL_TIME, 0.0);
  }
  void add_WIDTH(double WIDTH) {
    fbb_.AddElement<double>(CZMPath::VT_WIDTH, WIDTH, 0.0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMPath::VT_COLOR, COLOR);
  }
  void add_RESOLUTION(double RESOLUTION) {
    fbb_.AddElement<double>(CZMPath::VT_RESOLUTION, RESOLUTION, 0.0);
  }
  explicit CZMPathBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMPath> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMPath>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMPath> CreateCZMPath(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    double LEAD_TIME = 0.0,
    double TRAIL_TIME = 0.0,
    double WIDTH = 0.0,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    double RESOLUTION = 0.0) {
  CZMPathBuilder builder_(_fbb);
  builder_.add_RESOLUTION(RESOLUTION);
  builder_.add_WIDTH(WIDTH);
  builder_.add_TRAIL_TIME(TRAIL_TIME);
  builder_.add_LEAD_TIME(LEAD_TIME);
  builder_.add_COLOR(COLOR);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

/// Ellipse properties (for ground circles/ellipses)
struct CZMEllipse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMEllipseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHOW = 4,
    VT_SEMI_MAJOR_AXIS = 6,
    VT_SEMI_MINOR_AXIS = 8,
    VT_ROTATION = 10,
    VT_FILL = 12,
    VT_COLOR = 14,
    VT_OUTLINE = 16,
    VT_OUTLINE_COLOR = 18,
    VT_HEIGHT = 20,
    VT_HEIGHT_REFERENCE = 22
  };
  /// Whether the ellipse is displayed
  bool SHOW() const {
    return GetField<uint8_t>(VT_SHOW, 0) != 0;
  }
  /// Semi-major axis in meters
  double SEMI_MAJOR_AXIS() const {
    return GetField<double>(VT_SEMI_MAJOR_AXIS, 0.0);
  }
  /// Semi-minor axis in meters
  double SEMI_MINOR_AXIS() const {
    return GetField<double>(VT_SEMI_MINOR_AXIS, 0.0);
  }
  /// Rotation from north in radians
  double ROTATION() const {
    return GetField<double>(VT_ROTATION, 0.0);
  }
  /// Fill flag
  bool FILL() const {
    return GetField<uint8_t>(VT_FILL, 0) != 0;
  }
  /// Fill color
  const CZMColor *COLOR() const {
    return GetPointer<const CZMColor *>(VT_COLOR);
  }
  /// Outline flag
  bool OUTLINE() const {
    return GetField<uint8_t>(VT_OUTLINE, 0) != 0;
  }
  /// Outline color
  const CZMColor *OUTLINE_COLOR() const {
    return GetPointer<const CZMColor *>(VT_OUTLINE_COLOR);
  }
  /// Height in meters
  double HEIGHT() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  /// Height reference
  CZMHeightReference HEIGHT_REFERENCE() const {
    return static_cast<CZMHeightReference>(GetField<int8_t>(VT_HEIGHT_REFERENCE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SHOW, 1) &&
           VerifyField<double>(verifier, VT_SEMI_MAJOR_AXIS, 8) &&
           VerifyField<double>(verifier, VT_SEMI_MINOR_AXIS, 8) &&
           VerifyField<double>(verifier, VT_ROTATION, 8) &&
           VerifyField<uint8_t>(verifier, VT_FILL, 1) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(COLOR()) &&
           VerifyField<uint8_t>(verifier, VT_OUTLINE, 1) &&
           VerifyOffset(verifier, VT_OUTLINE_COLOR) &&
           verifier.VerifyTable(OUTLINE_COLOR()) &&
           VerifyField<double>(verifier, VT_HEIGHT, 8) &&
           VerifyField<int8_t>(verifier, VT_HEIGHT_REFERENCE, 1) &&
           verifier.EndTable();
  }
};

struct CZMEllipseBuilder {
  typedef CZMEllipse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SHOW(bool SHOW) {
    fbb_.AddElement<uint8_t>(CZMEllipse::VT_SHOW, static_cast<uint8_t>(SHOW), 0);
  }
  void add_SEMI_MAJOR_AXIS(double SEMI_MAJOR_AXIS) {
    fbb_.AddElement<double>(CZMEllipse::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  void add_SEMI_MINOR_AXIS(double SEMI_MINOR_AXIS) {
    fbb_.AddElement<double>(CZMEllipse::VT_SEMI_MINOR_AXIS, SEMI_MINOR_AXIS, 0.0);
  }
  void add_ROTATION(double ROTATION) {
    fbb_.AddElement<double>(CZMEllipse::VT_ROTATION, ROTATION, 0.0);
  }
  void add_FILL(bool FILL) {
    fbb_.AddElement<uint8_t>(CZMEllipse::VT_FILL, static_cast<uint8_t>(FILL), 0);
  }
  void add_COLOR(::flatbuffers::Offset<CZMColor> COLOR) {
    fbb_.AddOffset(CZMEllipse::VT_COLOR, COLOR);
  }
  void add_OUTLINE(bool OUTLINE) {
    fbb_.AddElement<uint8_t>(CZMEllipse::VT_OUTLINE, static_cast<uint8_t>(OUTLINE), 0);
  }
  void add_OUTLINE_COLOR(::flatbuffers::Offset<CZMColor> OUTLINE_COLOR) {
    fbb_.AddOffset(CZMEllipse::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  void add_HEIGHT(double HEIGHT) {
    fbb_.AddElement<double>(CZMEllipse::VT_HEIGHT, HEIGHT, 0.0);
  }
  void add_HEIGHT_REFERENCE(CZMHeightReference HEIGHT_REFERENCE) {
    fbb_.AddElement<int8_t>(CZMEllipse::VT_HEIGHT_REFERENCE, static_cast<int8_t>(HEIGHT_REFERENCE), 0);
  }
  explicit CZMEllipseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMEllipse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMEllipse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMEllipse> CreateCZMEllipse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool SHOW = false,
    double SEMI_MAJOR_AXIS = 0.0,
    double SEMI_MINOR_AXIS = 0.0,
    double ROTATION = 0.0,
    bool FILL = false,
    ::flatbuffers::Offset<CZMColor> COLOR = 0,
    bool OUTLINE = false,
    ::flatbuffers::Offset<CZMColor> OUTLINE_COLOR = 0,
    double HEIGHT = 0.0,
    CZMHeightReference HEIGHT_REFERENCE = CZMHeightReference_NONE) {
  CZMEllipseBuilder builder_(_fbb);
  builder_.add_HEIGHT(HEIGHT);
  builder_.add_ROTATION(ROTATION);
  builder_.add_SEMI_MINOR_AXIS(SEMI_MINOR_AXIS);
  builder_.add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS);
  builder_.add_OUTLINE_COLOR(OUTLINE_COLOR);
  builder_.add_COLOR(COLOR);
  builder_.add_HEIGHT_REFERENCE(HEIGHT_REFERENCE);
  builder_.add_OUTLINE(OUTLINE);
  builder_.add_FILL(FILL);
  builder_.add_SHOW(SHOW);
  return builder_.Finish();
}

/// A CZML Packet describing an entity and its properties
struct CZMPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMPacketBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_PARENT = 8,
    VT_DESCRIPTION = 10,
    VT_AVAILABILITY = 12,
    VT_POSITION_CARTOGRAPHIC_DEGREES = 14,
    VT_POSITION_CARTESIAN = 16,
    VT_POSITION_EPOCH = 18,
    VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY = 20,
    VT_POSITION_CARTESIAN_ARRAY = 22,
    VT_BILLBOARD = 24,
    VT_LABEL = 26,
    VT_POINT = 28,
    VT_POLYLINE = 30,
    VT_POLYGON = 32,
    VT_MODEL = 34,
    VT_PATH = 36,
    VT_ELLIPSE = 38
  };
  /// Unique identifier for this object
  const ::flatbuffers::String *ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Human-readable name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Parent packet ID
  const ::flatbuffers::String *PARENT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARENT);
  }
  /// Description (HTML allowed)
  const ::flatbuffers::String *DESCRIPTION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Availability interval (ISO 8601 interval)
  const ::flatbuffers::String *AVAILABILITY() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AVAILABILITY);
  }
  /// Position as cartographic degrees
  const CZMCartographicDegrees *POSITION_CARTOGRAPHIC_DEGREES() const {
    return GetPointer<const CZMCartographicDegrees *>(VT_POSITION_CARTOGRAPHIC_DEGREES);
  }
  /// Position as Cartesian
  const CZMCartesian *POSITION_CARTESIAN() const {
    return GetPointer<const CZMCartesian *>(VT_POSITION_CARTESIAN);
  }
  /// Time-tagged positions [time, lon, lat, height, time, lon, lat, height, ...]
  const ::flatbuffers::String *POSITION_EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSITION_EPOCH);
  }
  /// Time-tagged cartographic degree values
  const ::flatbuffers::Vector<double> *POSITION_CARTOGRAPHIC_DEGREES_ARRAY() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY);
  }
  /// Time-tagged Cartesian values
  const ::flatbuffers::Vector<double> *POSITION_CARTESIAN_ARRAY() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_POSITION_CARTESIAN_ARRAY);
  }
  /// Billboard properties
  const CZMBillboard *BILLBOARD() const {
    return GetPointer<const CZMBillboard *>(VT_BILLBOARD);
  }
  /// Label properties
  const CZMLabel *LABEL() const {
    return GetPointer<const CZMLabel *>(VT_LABEL);
  }
  /// Point properties
  const CZMPoint *POINT() const {
    return GetPointer<const CZMPoint *>(VT_POINT);
  }
  /// Polyline properties
  const CZMPolyline *POLYLINE() const {
    return GetPointer<const CZMPolyline *>(VT_POLYLINE);
  }
  /// Polygon properties
  const CZMPolygon *POLYGON() const {
    return GetPointer<const CZMPolygon *>(VT_POLYGON);
  }
  /// Model properties
  const CZMModel *MODEL() const {
    return GetPointer<const CZMModel *>(VT_MODEL);
  }
  /// Path properties
  const CZMPath *PATH() const {
    return GetPointer<const CZMPath *>(VT_PATH);
  }
  /// Ellipse properties
  const CZMEllipse *ELLIPSE() const {
    return GetPointer<const CZMEllipse *>(VT_ELLIPSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(ID()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_PARENT) &&
           verifier.VerifyString(PARENT()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(DESCRIPTION()) &&
           VerifyOffset(verifier, VT_AVAILABILITY) &&
           verifier.VerifyString(AVAILABILITY()) &&
           VerifyOffset(verifier, VT_POSITION_CARTOGRAPHIC_DEGREES) &&
           verifier.VerifyTable(POSITION_CARTOGRAPHIC_DEGREES()) &&
           VerifyOffset(verifier, VT_POSITION_CARTESIAN) &&
           verifier.VerifyTable(POSITION_CARTESIAN()) &&
           VerifyOffset(verifier, VT_POSITION_EPOCH) &&
           verifier.VerifyString(POSITION_EPOCH()) &&
           VerifyOffset(verifier, VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY) &&
           verifier.VerifyVector(POSITION_CARTOGRAPHIC_DEGREES_ARRAY()) &&
           VerifyOffset(verifier, VT_POSITION_CARTESIAN_ARRAY) &&
           verifier.VerifyVector(POSITION_CARTESIAN_ARRAY()) &&
           VerifyOffset(verifier, VT_BILLBOARD) &&
           verifier.VerifyTable(BILLBOARD()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyTable(LABEL()) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyTable(POINT()) &&
           VerifyOffset(verifier, VT_POLYLINE) &&
           verifier.VerifyTable(POLYLINE()) &&
           VerifyOffset(verifier, VT_POLYGON) &&
           verifier.VerifyTable(POLYGON()) &&
           VerifyOffset(verifier, VT_MODEL) &&
           verifier.VerifyTable(MODEL()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyTable(PATH()) &&
           VerifyOffset(verifier, VT_ELLIPSE) &&
           verifier.VerifyTable(ELLIPSE()) &&
           verifier.EndTable();
  }
};

struct CZMPacketBuilder {
  typedef CZMPacket Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ID(::flatbuffers::Offset<::flatbuffers::String> ID) {
    fbb_.AddOffset(CZMPacket::VT_ID, ID);
  }
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CZMPacket::VT_NAME, NAME);
  }
  void add_PARENT(::flatbuffers::Offset<::flatbuffers::String> PARENT) {
    fbb_.AddOffset(CZMPacket::VT_PARENT, PARENT);
  }
  void add_DESCRIPTION(::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION) {
    fbb_.AddOffset(CZMPacket::VT_DESCRIPTION, DESCRIPTION);
  }
  void add_AVAILABILITY(::flatbuffers::Offset<::flatbuffers::String> AVAILABILITY) {
    fbb_.AddOffset(CZMPacket::VT_AVAILABILITY, AVAILABILITY);
  }
  void add_POSITION_CARTOGRAPHIC_DEGREES(::flatbuffers::Offset<CZMCartographicDegrees> POSITION_CARTOGRAPHIC_DEGREES) {
    fbb_.AddOffset(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES, POSITION_CARTOGRAPHIC_DEGREES);
  }
  void add_POSITION_CARTESIAN(::flatbuffers::Offset<CZMCartesian> POSITION_CARTESIAN) {
    fbb_.AddOffset(CZMPacket::VT_POSITION_CARTESIAN, POSITION_CARTESIAN);
  }
  void add_POSITION_EPOCH(::flatbuffers::Offset<::flatbuffers::String> POSITION_EPOCH) {
    fbb_.AddOffset(CZMPacket::VT_POSITION_EPOCH, POSITION_EPOCH);
  }
  void add_POSITION_CARTOGRAPHIC_DEGREES_ARRAY(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITION_CARTOGRAPHIC_DEGREES_ARRAY) {
    fbb_.AddOffset(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY, POSITION_CARTOGRAPHIC_DEGREES_ARRAY);
  }
  void add_POSITION_CARTESIAN_ARRAY(::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITION_CARTESIAN_ARRAY) {
    fbb_.AddOffset(CZMPacket::VT_POSITION_CARTESIAN_ARRAY, POSITION_CARTESIAN_ARRAY);
  }
  void add_BILLBOARD(::flatbuffers::Offset<CZMBillboard> BILLBOARD) {
    fbb_.AddOffset(CZMPacket::VT_BILLBOARD, BILLBOARD);
  }
  void add_LABEL(::flatbuffers::Offset<CZMLabel> LABEL) {
    fbb_.AddOffset(CZMPacket::VT_LABEL, LABEL);
  }
  void add_POINT(::flatbuffers::Offset<CZMPoint> POINT) {
    fbb_.AddOffset(CZMPacket::VT_POINT, POINT);
  }
  void add_POLYLINE(::flatbuffers::Offset<CZMPolyline> POLYLINE) {
    fbb_.AddOffset(CZMPacket::VT_POLYLINE, POLYLINE);
  }
  void add_POLYGON(::flatbuffers::Offset<CZMPolygon> POLYGON) {
    fbb_.AddOffset(CZMPacket::VT_POLYGON, POLYGON);
  }
  void add_MODEL(::flatbuffers::Offset<CZMModel> MODEL) {
    fbb_.AddOffset(CZMPacket::VT_MODEL, MODEL);
  }
  void add_PATH(::flatbuffers::Offset<CZMPath> PATH) {
    fbb_.AddOffset(CZMPacket::VT_PATH, PATH);
  }
  void add_ELLIPSE(::flatbuffers::Offset<CZMEllipse> ELLIPSE) {
    fbb_.AddOffset(CZMPacket::VT_ELLIPSE, ELLIPSE);
  }
  explicit CZMPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZMPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZMPacket>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZMPacket> CreateCZMPacket(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> PARENT = 0,
    ::flatbuffers::Offset<::flatbuffers::String> DESCRIPTION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> AVAILABILITY = 0,
    ::flatbuffers::Offset<CZMCartographicDegrees> POSITION_CARTOGRAPHIC_DEGREES = 0,
    ::flatbuffers::Offset<CZMCartesian> POSITION_CARTESIAN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> POSITION_EPOCH = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITION_CARTOGRAPHIC_DEGREES_ARRAY = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> POSITION_CARTESIAN_ARRAY = 0,
    ::flatbuffers::Offset<CZMBillboard> BILLBOARD = 0,
    ::flatbuffers::Offset<CZMLabel> LABEL = 0,
    ::flatbuffers::Offset<CZMPoint> POINT = 0,
    ::flatbuffers::Offset<CZMPolyline> POLYLINE = 0,
    ::flatbuffers::Offset<CZMPolygon> POLYGON = 0,
    ::flatbuffers::Offset<CZMModel> MODEL = 0,
    ::flatbuffers::Offset<CZMPath> PATH = 0,
    ::flatbuffers::Offset<CZMEllipse> ELLIPSE = 0) {
  CZMPacketBuilder builder_(_fbb);
  builder_.add_ELLIPSE(ELLIPSE);
  builder_.add_PATH(PATH);
  builder_.add_MODEL(MODEL);
  builder_.add_POLYGON(POLYGON);
  builder_.add_POLYLINE(POLYLINE);
  builder_.add_POINT(POINT);
  builder_.add_LABEL(LABEL);
  builder_.add_BILLBOARD(BILLBOARD);
  builder_.add_POSITION_CARTESIAN_ARRAY(POSITION_CARTESIAN_ARRAY);
  builder_.add_POSITION_CARTOGRAPHIC_DEGREES_ARRAY(POSITION_CARTOGRAPHIC_DEGREES_ARRAY);
  builder_.add_POSITION_EPOCH(POSITION_EPOCH);
  builder_.add_POSITION_CARTESIAN(POSITION_CARTESIAN);
  builder_.add_POSITION_CARTOGRAPHIC_DEGREES(POSITION_CARTOGRAPHIC_DEGREES);
  builder_.add_AVAILABILITY(AVAILABILITY);
  builder_.add_DESCRIPTION(DESCRIPTION);
  builder_.add_PARENT(PARENT);
  builder_.add_NAME(NAME);
  builder_.add_ID(ID);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZMPacket> CreateCZMPacketDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ID = nullptr,
    const char *NAME = nullptr,
    const char *PARENT = nullptr,
    const char *DESCRIPTION = nullptr,
    const char *AVAILABILITY = nullptr,
    ::flatbuffers::Offset<CZMCartographicDegrees> POSITION_CARTOGRAPHIC_DEGREES = 0,
    ::flatbuffers::Offset<CZMCartesian> POSITION_CARTESIAN = 0,
    const char *POSITION_EPOCH = nullptr,
    const std::vector<double> *POSITION_CARTOGRAPHIC_DEGREES_ARRAY = nullptr,
    const std::vector<double> *POSITION_CARTESIAN_ARRAY = nullptr,
    ::flatbuffers::Offset<CZMBillboard> BILLBOARD = 0,
    ::flatbuffers::Offset<CZMLabel> LABEL = 0,
    ::flatbuffers::Offset<CZMPoint> POINT = 0,
    ::flatbuffers::Offset<CZMPolyline> POLYLINE = 0,
    ::flatbuffers::Offset<CZMPolygon> POLYGON = 0,
    ::flatbuffers::Offset<CZMModel> MODEL = 0,
    ::flatbuffers::Offset<CZMPath> PATH = 0,
    ::flatbuffers::Offset<CZMEllipse> ELLIPSE = 0) {
  auto ID__ = ID ? _fbb.CreateString(ID) : 0;
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto PARENT__ = PARENT ? _fbb.CreateString(PARENT) : 0;
  auto DESCRIPTION__ = DESCRIPTION ? _fbb.CreateString(DESCRIPTION) : 0;
  auto AVAILABILITY__ = AVAILABILITY ? _fbb.CreateString(AVAILABILITY) : 0;
  auto POSITION_EPOCH__ = POSITION_EPOCH ? _fbb.CreateString(POSITION_EPOCH) : 0;
  auto POSITION_CARTOGRAPHIC_DEGREES_ARRAY__ = POSITION_CARTOGRAPHIC_DEGREES_ARRAY ? _fbb.CreateVector<double>(*POSITION_CARTOGRAPHIC_DEGREES_ARRAY) : 0;
  auto POSITION_CARTESIAN_ARRAY__ = POSITION_CARTESIAN_ARRAY ? _fbb.CreateVector<double>(*POSITION_CARTESIAN_ARRAY) : 0;
  return CreateCZMPacket(
      _fbb,
      ID__,
      NAME__,
      PARENT__,
      DESCRIPTION__,
      AVAILABILITY__,
      POSITION_CARTOGRAPHIC_DEGREES,
      POSITION_CARTESIAN,
      POSITION_EPOCH__,
      POSITION_CARTOGRAPHIC_DEGREES_ARRAY__,
      POSITION_CARTESIAN_ARRAY__,
      BILLBOARD,
      LABEL,
      POINT,
      POLYLINE,
      POLYGON,
      MODEL,
      PATH,
      ELLIPSE);
}

/// CZML Document
struct CZM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CZMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_CLOCK_CURRENT_TIME = 8,
    VT_CLOCK_INTERVAL = 10,
    VT_CLOCK_MULTIPLIER = 12,
    VT_PACKETS = 14
  };
  /// Document-level name
  const ::flatbuffers::String *NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Document-level version
  const ::flatbuffers::String *VERSION() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  /// Clock settings - current time (ISO 8601)
  const ::flatbuffers::String *CLOCK_CURRENT_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLOCK_CURRENT_TIME);
  }
  /// Clock settings - interval (ISO 8601 interval)
  const ::flatbuffers::String *CLOCK_INTERVAL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLOCK_INTERVAL);
  }
  /// Clock settings - multiplier
  double CLOCK_MULTIPLIER() const {
    return GetField<double>(VT_CLOCK_MULTIPLIER, 0.0);
  }
  /// All packets in the document
  const ::flatbuffers::Vector<::flatbuffers::Offset<CZMPacket>> *PACKETS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<CZMPacket>> *>(VT_PACKETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(NAME()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(VERSION()) &&
           VerifyOffset(verifier, VT_CLOCK_CURRENT_TIME) &&
           verifier.VerifyString(CLOCK_CURRENT_TIME()) &&
           VerifyOffset(verifier, VT_CLOCK_INTERVAL) &&
           verifier.VerifyString(CLOCK_INTERVAL()) &&
           VerifyField<double>(verifier, VT_CLOCK_MULTIPLIER, 8) &&
           VerifyOffset(verifier, VT_PACKETS) &&
           verifier.VerifyVector(PACKETS()) &&
           verifier.VerifyVectorOfTables(PACKETS()) &&
           verifier.EndTable();
  }
};

struct CZMBuilder {
  typedef CZM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_NAME(::flatbuffers::Offset<::flatbuffers::String> NAME) {
    fbb_.AddOffset(CZM::VT_NAME, NAME);
  }
  void add_VERSION(::flatbuffers::Offset<::flatbuffers::String> VERSION) {
    fbb_.AddOffset(CZM::VT_VERSION, VERSION);
  }
  void add_CLOCK_CURRENT_TIME(::flatbuffers::Offset<::flatbuffers::String> CLOCK_CURRENT_TIME) {
    fbb_.AddOffset(CZM::VT_CLOCK_CURRENT_TIME, CLOCK_CURRENT_TIME);
  }
  void add_CLOCK_INTERVAL(::flatbuffers::Offset<::flatbuffers::String> CLOCK_INTERVAL) {
    fbb_.AddOffset(CZM::VT_CLOCK_INTERVAL, CLOCK_INTERVAL);
  }
  void add_CLOCK_MULTIPLIER(double CLOCK_MULTIPLIER) {
    fbb_.AddElement<double>(CZM::VT_CLOCK_MULTIPLIER, CLOCK_MULTIPLIER, 0.0);
  }
  void add_PACKETS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CZMPacket>>> PACKETS) {
    fbb_.AddOffset(CZM::VT_PACKETS, PACKETS);
  }
  explicit CZMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CZM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CZM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CZM> CreateCZM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> VERSION = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLOCK_CURRENT_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CLOCK_INTERVAL = 0,
    double CLOCK_MULTIPLIER = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<CZMPacket>>> PACKETS = 0) {
  CZMBuilder builder_(_fbb);
  builder_.add_CLOCK_MULTIPLIER(CLOCK_MULTIPLIER);
  builder_.add_PACKETS(PACKETS);
  builder_.add_CLOCK_INTERVAL(CLOCK_INTERVAL);
  builder_.add_CLOCK_CURRENT_TIME(CLOCK_CURRENT_TIME);
  builder_.add_VERSION(VERSION);
  builder_.add_NAME(NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CZM> CreateCZMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *NAME = nullptr,
    const char *VERSION = nullptr,
    const char *CLOCK_CURRENT_TIME = nullptr,
    const char *CLOCK_INTERVAL = nullptr,
    double CLOCK_MULTIPLIER = 0.0,
    const std::vector<::flatbuffers::Offset<CZMPacket>> *PACKETS = nullptr) {
  auto NAME__ = NAME ? _fbb.CreateString(NAME) : 0;
  auto VERSION__ = VERSION ? _fbb.CreateString(VERSION) : 0;
  auto CLOCK_CURRENT_TIME__ = CLOCK_CURRENT_TIME ? _fbb.CreateString(CLOCK_CURRENT_TIME) : 0;
  auto CLOCK_INTERVAL__ = CLOCK_INTERVAL ? _fbb.CreateString(CLOCK_INTERVAL) : 0;
  auto PACKETS__ = PACKETS ? _fbb.CreateVector<::flatbuffers::Offset<CZMPacket>>(*PACKETS) : 0;
  return CreateCZM(
      _fbb,
      NAME__,
      VERSION__,
      CLOCK_CURRENT_TIME__,
      CLOCK_INTERVAL__,
      CLOCK_MULTIPLIER,
      PACKETS__);
}

inline const CZM *GetCZM(const void *buf) {
  return ::flatbuffers::GetRoot<CZM>(buf);
}

inline const CZM *GetSizePrefixedCZM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CZM>(buf);
}

inline const char *CZMIdentifier() {
  return "$CZM";
}

inline bool CZMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CZMIdentifier());
}

inline bool SizePrefixedCZMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CZMIdentifier(), true);
}

inline bool VerifyCZMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CZM>(CZMIdentifier());
}

inline bool VerifySizePrefixedCZMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CZM>(CZMIdentifier());
}

inline void FinishCZMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CZM> root) {
  fbb.Finish(root, CZMIdentifier());
}

inline void FinishSizePrefixedCZMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CZM> root) {
  fbb.FinishSizePrefixed(root, CZMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
