// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EOP;
struct EOPBuilder;

enum DataType : int8_t {
  DataType_OBSERVED = 0,
  DataType_PREDICTED = 1,
  DataType_MIN = DataType_OBSERVED,
  DataType_MAX = DataType_PREDICTED
};

inline const DataType (&EnumValuesDataType())[2] {
  static const DataType values[] = {
    DataType_OBSERVED,
    DataType_PREDICTED
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[3] = {
    "OBSERVED",
    "PREDICTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType_OBSERVED, DataType_PREDICTED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

/// Earth Orientation Parameters
struct EOP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_MJD = 6,
    VT_X_POLE_WANDER_RADIANS = 8,
    VT_Y_POLE_WANDER_RADIANS = 10,
    VT_X_CELESTIAL_POLE_OFFSET_RADIANS = 12,
    VT_Y_CELESTIAL_POLE_OFFSET_RADIANS = 14,
    VT_UT1_MINUS_UTC_SECONDS = 16,
    VT_TAI_MINUS_UTC_SECONDS = 18,
    VT_LENGTH_OF_DAY_CORRECTION_SECONDS = 20,
    VT_DATA_TYPE = 22
  };
  ///  Date in ISO 8601 format, e.g., "2018-01-01T00:00:00Z"
  const ::flatbuffers::String *DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  ///  Modified Julian Date in UTC, e.g., 58119
  uint32_t MJD() const {
    return GetField<uint32_t>(VT_MJD, 0);
  }
  ///  x component of Pole Wander in radians, e.g., 2.872908911518888E-7
  float X_POLE_WANDER_RADIANS() const {
    return GetField<float>(VT_X_POLE_WANDER_RADIANS, 0.0f);
  }
  ///  y component of Pole Wander in radians, e.g., 1.2003259523750447E-6
  float Y_POLE_WANDER_RADIANS() const {
    return GetField<float>(VT_Y_POLE_WANDER_RADIANS, 0.0f);
  }
  ///  x component of Celestial Pole Offset in radians, e.g., 5.720801437092525E-10
  float X_CELESTIAL_POLE_OFFSET_RADIANS() const {
    return GetField<float>(VT_X_CELESTIAL_POLE_OFFSET_RADIANS, 0.0f);
  }
  ///  y component of Celestial Pole Offset in radians, e.g., -8.484239419416879E-10
  float Y_CELESTIAL_POLE_OFFSET_RADIANS() const {
    return GetField<float>(VT_Y_CELESTIAL_POLE_OFFSET_RADIANS, 0.0f);
  }
  ///  UT1 minus UTC in seconds, e.g., 0.2163567
  float UT1_MINUS_UTC_SECONDS() const {
    return GetField<float>(VT_UT1_MINUS_UTC_SECONDS, 0.0f);
  }
  ///  TAI minus UTC in seconds, e.g., 37
  uint16_t TAI_MINUS_UTC_SECONDS() const {
    return GetField<uint16_t>(VT_TAI_MINUS_UTC_SECONDS, 0);
  }
  ///  Correction to Length of Day in seconds, e.g., 8.094E-4
  float LENGTH_OF_DAY_CORRECTION_SECONDS() const {
    return GetField<float>(VT_LENGTH_OF_DAY_CORRECTION_SECONDS, 0.0f);
  }
  ///  Data type (O = Observed, P = Predicted)
  DataType DATA_TYPE() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(DATE()) &&
           VerifyField<uint32_t>(verifier, VT_MJD, 4) &&
           VerifyField<float>(verifier, VT_X_POLE_WANDER_RADIANS, 4) &&
           VerifyField<float>(verifier, VT_Y_POLE_WANDER_RADIANS, 4) &&
           VerifyField<float>(verifier, VT_X_CELESTIAL_POLE_OFFSET_RADIANS, 4) &&
           VerifyField<float>(verifier, VT_Y_CELESTIAL_POLE_OFFSET_RADIANS, 4) &&
           VerifyField<float>(verifier, VT_UT1_MINUS_UTC_SECONDS, 4) &&
           VerifyField<uint16_t>(verifier, VT_TAI_MINUS_UTC_SECONDS, 2) &&
           VerifyField<float>(verifier, VT_LENGTH_OF_DAY_CORRECTION_SECONDS, 4) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EOPBuilder {
  typedef EOP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DATE(::flatbuffers::Offset<::flatbuffers::String> DATE) {
    fbb_.AddOffset(EOP::VT_DATE, DATE);
  }
  void add_MJD(uint32_t MJD) {
    fbb_.AddElement<uint32_t>(EOP::VT_MJD, MJD, 0);
  }
  void add_X_POLE_WANDER_RADIANS(float X_POLE_WANDER_RADIANS) {
    fbb_.AddElement<float>(EOP::VT_X_POLE_WANDER_RADIANS, X_POLE_WANDER_RADIANS, 0.0f);
  }
  void add_Y_POLE_WANDER_RADIANS(float Y_POLE_WANDER_RADIANS) {
    fbb_.AddElement<float>(EOP::VT_Y_POLE_WANDER_RADIANS, Y_POLE_WANDER_RADIANS, 0.0f);
  }
  void add_X_CELESTIAL_POLE_OFFSET_RADIANS(float X_CELESTIAL_POLE_OFFSET_RADIANS) {
    fbb_.AddElement<float>(EOP::VT_X_CELESTIAL_POLE_OFFSET_RADIANS, X_CELESTIAL_POLE_OFFSET_RADIANS, 0.0f);
  }
  void add_Y_CELESTIAL_POLE_OFFSET_RADIANS(float Y_CELESTIAL_POLE_OFFSET_RADIANS) {
    fbb_.AddElement<float>(EOP::VT_Y_CELESTIAL_POLE_OFFSET_RADIANS, Y_CELESTIAL_POLE_OFFSET_RADIANS, 0.0f);
  }
  void add_UT1_MINUS_UTC_SECONDS(float UT1_MINUS_UTC_SECONDS) {
    fbb_.AddElement<float>(EOP::VT_UT1_MINUS_UTC_SECONDS, UT1_MINUS_UTC_SECONDS, 0.0f);
  }
  void add_TAI_MINUS_UTC_SECONDS(uint16_t TAI_MINUS_UTC_SECONDS) {
    fbb_.AddElement<uint16_t>(EOP::VT_TAI_MINUS_UTC_SECONDS, TAI_MINUS_UTC_SECONDS, 0);
  }
  void add_LENGTH_OF_DAY_CORRECTION_SECONDS(float LENGTH_OF_DAY_CORRECTION_SECONDS) {
    fbb_.AddElement<float>(EOP::VT_LENGTH_OF_DAY_CORRECTION_SECONDS, LENGTH_OF_DAY_CORRECTION_SECONDS, 0.0f);
  }
  void add_DATA_TYPE(DataType DATA_TYPE) {
    fbb_.AddElement<int8_t>(EOP::VT_DATA_TYPE, static_cast<int8_t>(DATA_TYPE), 0);
  }
  explicit EOPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOP> CreateEOP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> DATE = 0,
    uint32_t MJD = 0,
    float X_POLE_WANDER_RADIANS = 0.0f,
    float Y_POLE_WANDER_RADIANS = 0.0f,
    float X_CELESTIAL_POLE_OFFSET_RADIANS = 0.0f,
    float Y_CELESTIAL_POLE_OFFSET_RADIANS = 0.0f,
    float UT1_MINUS_UTC_SECONDS = 0.0f,
    uint16_t TAI_MINUS_UTC_SECONDS = 0,
    float LENGTH_OF_DAY_CORRECTION_SECONDS = 0.0f,
    DataType DATA_TYPE = DataType_OBSERVED) {
  EOPBuilder builder_(_fbb);
  builder_.add_LENGTH_OF_DAY_CORRECTION_SECONDS(LENGTH_OF_DAY_CORRECTION_SECONDS);
  builder_.add_UT1_MINUS_UTC_SECONDS(UT1_MINUS_UTC_SECONDS);
  builder_.add_Y_CELESTIAL_POLE_OFFSET_RADIANS(Y_CELESTIAL_POLE_OFFSET_RADIANS);
  builder_.add_X_CELESTIAL_POLE_OFFSET_RADIANS(X_CELESTIAL_POLE_OFFSET_RADIANS);
  builder_.add_Y_POLE_WANDER_RADIANS(Y_POLE_WANDER_RADIANS);
  builder_.add_X_POLE_WANDER_RADIANS(X_POLE_WANDER_RADIANS);
  builder_.add_MJD(MJD);
  builder_.add_DATE(DATE);
  builder_.add_TAI_MINUS_UTC_SECONDS(TAI_MINUS_UTC_SECONDS);
  builder_.add_DATA_TYPE(DATA_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOP> CreateEOPDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *DATE = nullptr,
    uint32_t MJD = 0,
    float X_POLE_WANDER_RADIANS = 0.0f,
    float Y_POLE_WANDER_RADIANS = 0.0f,
    float X_CELESTIAL_POLE_OFFSET_RADIANS = 0.0f,
    float Y_CELESTIAL_POLE_OFFSET_RADIANS = 0.0f,
    float UT1_MINUS_UTC_SECONDS = 0.0f,
    uint16_t TAI_MINUS_UTC_SECONDS = 0,
    float LENGTH_OF_DAY_CORRECTION_SECONDS = 0.0f,
    DataType DATA_TYPE = DataType_OBSERVED) {
  auto DATE__ = DATE ? _fbb.CreateString(DATE) : 0;
  return CreateEOP(
      _fbb,
      DATE__,
      MJD,
      X_POLE_WANDER_RADIANS,
      Y_POLE_WANDER_RADIANS,
      X_CELESTIAL_POLE_OFFSET_RADIANS,
      Y_CELESTIAL_POLE_OFFSET_RADIANS,
      UT1_MINUS_UTC_SECONDS,
      TAI_MINUS_UTC_SECONDS,
      LENGTH_OF_DAY_CORRECTION_SECONDS,
      DATA_TYPE);
}

inline const EOP *GetEOP(const void *buf) {
  return ::flatbuffers::GetRoot<EOP>(buf);
}

inline const EOP *GetSizePrefixedEOP(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EOP>(buf);
}

inline const char *EOPIdentifier() {
  return "$EOP";
}

inline bool EOPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOPIdentifier());
}

inline bool SizePrefixedEOPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOPIdentifier(), true);
}

inline bool VerifyEOPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EOP>(EOPIdentifier());
}

inline bool VerifySizePrefixedEOPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EOP>(EOPIdentifier());
}

inline void FinishEOPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOP> root) {
  fbb.Finish(root, EOPIdentifier());
}

inline void FinishSizePrefixedEOPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOP> root) {
  fbb.FinishSizePrefixed(root, EOPIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
