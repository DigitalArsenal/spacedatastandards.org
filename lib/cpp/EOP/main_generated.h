// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EOP;
struct EOPBuilder;

struct EOPCollection;
struct EOPCollectionBuilder;

enum DataType : int8_t {
  DataType_OBSERVED = 0,
  DataType_PREDICTED = 1,
  DataType_MIN = DataType_OBSERVED,
  DataType_MAX = DataType_PREDICTED
};

inline const DataType (&EnumValuesDataType())[2] {
  static const DataType values[] = {
    DataType_OBSERVED,
    DataType_PREDICTED
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[3] = {
    "OBSERVED",
    "PREDICTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType_OBSERVED, DataType_PREDICTED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

/// Earth Orientation Parameters
struct EOP FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATE = 4,
    VT_MJD = 6,
    VT_X = 8,
    VT_Y = 10,
    VT_UT1_MINUS_UTC = 12,
    VT_LOD = 14,
    VT_DPSI = 16,
    VT_DEPS = 18,
    VT_DX = 20,
    VT_DY = 22,
    VT_DAT = 24,
    VT_DATA_TYPE = 26
  };
  /// Date in ISO 8601 format
  const ::flatbuffers::String *DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATE);
  }
  /// Modified Julian Date
  uint32_t MJD() const {
    return GetField<uint32_t>(VT_MJD, 0);
  }
  /// x pole coordinate in arcseconds
  float X() const {
    return GetField<float>(VT_X, 0.0f);
  }
  /// y pole coordinate in arcseconds
  float Y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  /// UT1-UTC in seconds
  float UT1_MINUS_UTC() const {
    return GetField<float>(VT_UT1_MINUS_UTC, 0.0f);
  }
  /// Length of Day correction in seconds
  float LOD() const {
    return GetField<float>(VT_LOD, 0.0f);
  }
  /// Nutation correction in longitude (δΔψ) in arcseconds
  float DPSI() const {
    return GetField<float>(VT_DPSI, 0.0f);
  }
  /// Nutation correction in obliquity (δΔε) in arcseconds
  float DEPS() const {
    return GetField<float>(VT_DEPS, 0.0f);
  }
  /// Celestial pole offset in x (δX) in arcseconds
  float DX() const {
    return GetField<float>(VT_DX, 0.0f);
  }
  /// Celestial pole offset in y (δY) in arcseconds
  float DY() const {
    return GetField<float>(VT_DY, 0.0f);
  }
  /// Delta Atomic Time (TAI-UTC) in seconds
  uint16_t DAT() const {
    return GetField<uint16_t>(VT_DAT, 0);
  }
  /// Data type (O = Observed, P = Predicted)
  DataType DATA_TYPE() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATE) &&
           verifier.VerifyString(DATE()) &&
           VerifyField<uint32_t>(verifier, VT_MJD, 4) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_UT1_MINUS_UTC, 4) &&
           VerifyField<float>(verifier, VT_LOD, 4) &&
           VerifyField<float>(verifier, VT_DPSI, 4) &&
           VerifyField<float>(verifier, VT_DEPS, 4) &&
           VerifyField<float>(verifier, VT_DX, 4) &&
           VerifyField<float>(verifier, VT_DY, 4) &&
           VerifyField<uint16_t>(verifier, VT_DAT, 2) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EOPBuilder {
  typedef EOP Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_DATE(::flatbuffers::Offset<::flatbuffers::String> DATE) {
    fbb_.AddOffset(EOP::VT_DATE, DATE);
  }
  void add_MJD(uint32_t MJD) {
    fbb_.AddElement<uint32_t>(EOP::VT_MJD, MJD, 0);
  }
  void add_X(float X) {
    fbb_.AddElement<float>(EOP::VT_X, X, 0.0f);
  }
  void add_Y(float Y) {
    fbb_.AddElement<float>(EOP::VT_Y, Y, 0.0f);
  }
  void add_UT1_MINUS_UTC(float UT1_MINUS_UTC) {
    fbb_.AddElement<float>(EOP::VT_UT1_MINUS_UTC, UT1_MINUS_UTC, 0.0f);
  }
  void add_LOD(float LOD) {
    fbb_.AddElement<float>(EOP::VT_LOD, LOD, 0.0f);
  }
  void add_DPSI(float DPSI) {
    fbb_.AddElement<float>(EOP::VT_DPSI, DPSI, 0.0f);
  }
  void add_DEPS(float DEPS) {
    fbb_.AddElement<float>(EOP::VT_DEPS, DEPS, 0.0f);
  }
  void add_DX(float DX) {
    fbb_.AddElement<float>(EOP::VT_DX, DX, 0.0f);
  }
  void add_DY(float DY) {
    fbb_.AddElement<float>(EOP::VT_DY, DY, 0.0f);
  }
  void add_DAT(uint16_t DAT) {
    fbb_.AddElement<uint16_t>(EOP::VT_DAT, DAT, 0);
  }
  void add_DATA_TYPE(DataType DATA_TYPE) {
    fbb_.AddElement<int8_t>(EOP::VT_DATA_TYPE, static_cast<int8_t>(DATA_TYPE), 0);
  }
  explicit EOPBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOP>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOP> CreateEOP(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> DATE = 0,
    uint32_t MJD = 0,
    float X = 0.0f,
    float Y = 0.0f,
    float UT1_MINUS_UTC = 0.0f,
    float LOD = 0.0f,
    float DPSI = 0.0f,
    float DEPS = 0.0f,
    float DX = 0.0f,
    float DY = 0.0f,
    uint16_t DAT = 0,
    DataType DATA_TYPE = DataType_OBSERVED) {
  EOPBuilder builder_(_fbb);
  builder_.add_DY(DY);
  builder_.add_DX(DX);
  builder_.add_DEPS(DEPS);
  builder_.add_DPSI(DPSI);
  builder_.add_LOD(LOD);
  builder_.add_UT1_MINUS_UTC(UT1_MINUS_UTC);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_MJD(MJD);
  builder_.add_DATE(DATE);
  builder_.add_DAT(DAT);
  builder_.add_DATA_TYPE(DATA_TYPE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOP> CreateEOPDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *DATE = nullptr,
    uint32_t MJD = 0,
    float X = 0.0f,
    float Y = 0.0f,
    float UT1_MINUS_UTC = 0.0f,
    float LOD = 0.0f,
    float DPSI = 0.0f,
    float DEPS = 0.0f,
    float DX = 0.0f,
    float DY = 0.0f,
    uint16_t DAT = 0,
    DataType DATA_TYPE = DataType_OBSERVED) {
  auto DATE__ = DATE ? _fbb.CreateString(DATE) : 0;
  return CreateEOP(
      _fbb,
      DATE__,
      MJD,
      X,
      Y,
      UT1_MINUS_UTC,
      LOD,
      DPSI,
      DEPS,
      DX,
      DY,
      DAT,
      DATA_TYPE);
}

struct EOPCollection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOPCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECORDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<EOP>> *RECORDS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EOP>> *>(VT_RECORDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(RECORDS()) &&
           verifier.VerifyVectorOfTables(RECORDS()) &&
           verifier.EndTable();
  }
};

struct EOPCollectionBuilder {
  typedef EOPCollection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_RECORDS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EOP>>> RECORDS) {
    fbb_.AddOffset(EOPCollection::VT_RECORDS, RECORDS);
  }
  explicit EOPCollectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOPCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOPCollection>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOPCollection> CreateEOPCollection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EOP>>> RECORDS = 0) {
  EOPCollectionBuilder builder_(_fbb);
  builder_.add_RECORDS(RECORDS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOPCollection> CreateEOPCollectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<EOP>> *RECORDS = nullptr) {
  auto RECORDS__ = RECORDS ? _fbb.CreateVector<::flatbuffers::Offset<EOP>>(*RECORDS) : 0;
  return CreateEOPCollection(
      _fbb,
      RECORDS__);
}

inline const EOP *GetEOP(const void *buf) {
  return ::flatbuffers::GetRoot<EOP>(buf);
}

inline const EOP *GetSizePrefixedEOP(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EOP>(buf);
}

inline const char *EOPIdentifier() {
  return "$EOP";
}

inline bool EOPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOPIdentifier());
}

inline bool SizePrefixedEOPBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOPIdentifier(), true);
}

inline bool VerifyEOPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EOP>(EOPIdentifier());
}

inline bool VerifySizePrefixedEOPBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EOP>(EOPIdentifier());
}

inline void FinishEOPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOP> root) {
  fbb.Finish(root, EOPIdentifier());
}

inline void FinishSizePrefixedEOPBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOP> root) {
  fbb.FinishSizePrefixed(root, EOPIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
