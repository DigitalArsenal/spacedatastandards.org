// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EWR;
struct EWRBuilder;

enum JammingType : int8_t {
  JammingType_NOISE_BARRAGE = 0,
  JammingType_NOISE_SPOT = 1,
  JammingType_NOISE_SWEPT = 2,
  JammingType_DECEPTION_RANGE_GATE = 3,
  JammingType_DECEPTION_VELOCITY_GATE = 4,
  JammingType_DECEPTION_ANGLE = 5,
  JammingType_DECEPTION_FALSE_TARGET = 6,
  JammingType_DRFM = 7,
  JammingType_REPEATER = 8,
  JammingType_CROSS_EYE = 9,
  JammingType_CROSS_POLARIZATION = 10,
  JammingType_CHAFF = 11,
  JammingType_FLARE = 12,
  JammingType_TOWED_DECOY = 13,
  JammingType_MIN = JammingType_NOISE_BARRAGE,
  JammingType_MAX = JammingType_TOWED_DECOY
};

inline const JammingType (&EnumValuesJammingType())[14] {
  static const JammingType values[] = {
    JammingType_NOISE_BARRAGE,
    JammingType_NOISE_SPOT,
    JammingType_NOISE_SWEPT,
    JammingType_DECEPTION_RANGE_GATE,
    JammingType_DECEPTION_VELOCITY_GATE,
    JammingType_DECEPTION_ANGLE,
    JammingType_DECEPTION_FALSE_TARGET,
    JammingType_DRFM,
    JammingType_REPEATER,
    JammingType_CROSS_EYE,
    JammingType_CROSS_POLARIZATION,
    JammingType_CHAFF,
    JammingType_FLARE,
    JammingType_TOWED_DECOY
  };
  return values;
}

inline const char * const *EnumNamesJammingType() {
  static const char * const names[15] = {
    "NOISE_BARRAGE",
    "NOISE_SPOT",
    "NOISE_SWEPT",
    "DECEPTION_RANGE_GATE",
    "DECEPTION_VELOCITY_GATE",
    "DECEPTION_ANGLE",
    "DECEPTION_FALSE_TARGET",
    "DRFM",
    "REPEATER",
    "CROSS_EYE",
    "CROSS_POLARIZATION",
    "CHAFF",
    "FLARE",
    "TOWED_DECOY",
    nullptr
  };
  return names;
}

inline const char *EnumNameJammingType(JammingType e) {
  if (::flatbuffers::IsOutRange(e, JammingType_NOISE_BARRAGE, JammingType_TOWED_DECOY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJammingType()[index];
}

enum ThreatCategory : int8_t {
  ThreatCategory_UNKNOWN = 0,
  ThreatCategory_EARLY_WARNING = 1,
  ThreatCategory_ACQUISITION = 2,
  ThreatCategory_TRACKING = 3,
  ThreatCategory_GUIDANCE = 4,
  ThreatCategory_HEIGHT_FINDER = 5,
  ThreatCategory_GCI = 6,
  ThreatCategory_AIRBORNE_INTERCEPT = 7,
  ThreatCategory_SURFACE_SEARCH = 8,
  ThreatCategory_AIR_SEARCH = 9,
  ThreatCategory_NAVIGATION = 10,
  ThreatCategory_WEATHER = 11,
  ThreatCategory_CIVIL = 12,
  ThreatCategory_FRIENDLY = 13,
  ThreatCategory_IFF = 14,
  ThreatCategory_MIN = ThreatCategory_UNKNOWN,
  ThreatCategory_MAX = ThreatCategory_IFF
};

inline const ThreatCategory (&EnumValuesThreatCategory())[15] {
  static const ThreatCategory values[] = {
    ThreatCategory_UNKNOWN,
    ThreatCategory_EARLY_WARNING,
    ThreatCategory_ACQUISITION,
    ThreatCategory_TRACKING,
    ThreatCategory_GUIDANCE,
    ThreatCategory_HEIGHT_FINDER,
    ThreatCategory_GCI,
    ThreatCategory_AIRBORNE_INTERCEPT,
    ThreatCategory_SURFACE_SEARCH,
    ThreatCategory_AIR_SEARCH,
    ThreatCategory_NAVIGATION,
    ThreatCategory_WEATHER,
    ThreatCategory_CIVIL,
    ThreatCategory_FRIENDLY,
    ThreatCategory_IFF
  };
  return values;
}

inline const char * const *EnumNamesThreatCategory() {
  static const char * const names[16] = {
    "UNKNOWN",
    "EARLY_WARNING",
    "ACQUISITION",
    "TRACKING",
    "GUIDANCE",
    "HEIGHT_FINDER",
    "GCI",
    "AIRBORNE_INTERCEPT",
    "SURFACE_SEARCH",
    "AIR_SEARCH",
    "NAVIGATION",
    "WEATHER",
    "CIVIL",
    "FRIENDLY",
    "IFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameThreatCategory(ThreatCategory e) {
  if (::flatbuffers::IsOutRange(e, ThreatCategory_UNKNOWN, ThreatCategory_IFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesThreatCategory()[index];
}

enum ESMFunction : int8_t {
  ESMFunction_SEARCH = 0,
  ESMFunction_CLASSIFICATION = 1,
  ESMFunction_IDENTIFICATION = 2,
  ESMFunction_DIRECTION_FINDING = 3,
  ESMFunction_LOCATION = 4,
  ESMFunction_RECORDING = 5,
  ESMFunction_SITUATIONAL_AWARENESS = 6,
  ESMFunction_MIN = ESMFunction_SEARCH,
  ESMFunction_MAX = ESMFunction_SITUATIONAL_AWARENESS
};

inline const ESMFunction (&EnumValuesESMFunction())[7] {
  static const ESMFunction values[] = {
    ESMFunction_SEARCH,
    ESMFunction_CLASSIFICATION,
    ESMFunction_IDENTIFICATION,
    ESMFunction_DIRECTION_FINDING,
    ESMFunction_LOCATION,
    ESMFunction_RECORDING,
    ESMFunction_SITUATIONAL_AWARENESS
  };
  return values;
}

inline const char * const *EnumNamesESMFunction() {
  static const char * const names[8] = {
    "SEARCH",
    "CLASSIFICATION",
    "IDENTIFICATION",
    "DIRECTION_FINDING",
    "LOCATION",
    "RECORDING",
    "SITUATIONAL_AWARENESS",
    nullptr
  };
  return names;
}

inline const char *EnumNameESMFunction(ESMFunction e) {
  if (::flatbuffers::IsOutRange(e, ESMFunction_SEARCH, ESMFunction_SITUATIONAL_AWARENESS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesESMFunction()[index];
}

enum CountermeasureStatus : int8_t {
  CountermeasureStatus_READY = 0,
  CountermeasureStatus_DEPLOYING = 1,
  CountermeasureStatus_ACTIVE = 2,
  CountermeasureStatus_EXPENDED = 3,
  CountermeasureStatus_RELOADING = 4,
  CountermeasureStatus_FAILED = 5,
  CountermeasureStatus_MIN = CountermeasureStatus_READY,
  CountermeasureStatus_MAX = CountermeasureStatus_FAILED
};

inline const CountermeasureStatus (&EnumValuesCountermeasureStatus())[6] {
  static const CountermeasureStatus values[] = {
    CountermeasureStatus_READY,
    CountermeasureStatus_DEPLOYING,
    CountermeasureStatus_ACTIVE,
    CountermeasureStatus_EXPENDED,
    CountermeasureStatus_RELOADING,
    CountermeasureStatus_FAILED
  };
  return values;
}

inline const char * const *EnumNamesCountermeasureStatus() {
  static const char * const names[7] = {
    "READY",
    "DEPLOYING",
    "ACTIVE",
    "EXPENDED",
    "RELOADING",
    "FAILED",
    nullptr
  };
  return names;
}

inline const char *EnumNameCountermeasureStatus(CountermeasureStatus e) {
  if (::flatbuffers::IsOutRange(e, CountermeasureStatus_READY, CountermeasureStatus_FAILED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCountermeasureStatus()[index];
}

enum WaveformType : int8_t {
  WaveformType_CW = 0,
  WaveformType_PULSED = 1,
  WaveformType_PULSE_DOPPLER = 2,
  WaveformType_FM_CW = 3,
  WaveformType_CHIRP = 4,
  WaveformType_PHASE_CODED = 5,
  WaveformType_FREQUENCY_AGILE = 6,
  WaveformType_PRI_AGILE = 7,
  WaveformType_COMPLEX = 8,
  WaveformType_LPI = 9,
  WaveformType_MIN = WaveformType_CW,
  WaveformType_MAX = WaveformType_LPI
};

inline const WaveformType (&EnumValuesWaveformType())[10] {
  static const WaveformType values[] = {
    WaveformType_CW,
    WaveformType_PULSED,
    WaveformType_PULSE_DOPPLER,
    WaveformType_FM_CW,
    WaveformType_CHIRP,
    WaveformType_PHASE_CODED,
    WaveformType_FREQUENCY_AGILE,
    WaveformType_PRI_AGILE,
    WaveformType_COMPLEX,
    WaveformType_LPI
  };
  return values;
}

inline const char * const *EnumNamesWaveformType() {
  static const char * const names[11] = {
    "CW",
    "PULSED",
    "PULSE_DOPPLER",
    "FM_CW",
    "CHIRP",
    "PHASE_CODED",
    "FREQUENCY_AGILE",
    "PRI_AGILE",
    "COMPLEX",
    "LPI",
    nullptr
  };
  return names;
}

inline const char *EnumNameWaveformType(WaveformType e) {
  if (::flatbuffers::IsOutRange(e, WaveformType_CW, WaveformType_LPI)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWaveformType()[index];
}

/// Electronic Warfare
struct EWR FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EWRBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_ID = 4,
    VT_ENTITY_ID = 6,
    VT_ESM_ACTIVE = 8,
    VT_ECM_ACTIVE = 10,
    VT_RWR_ACTIVE = 12,
    VT_ESM_CONTACTS = 14,
    VT_ACTIVE_JAMMING = 16,
    VT_COUNTERMEASURES = 18,
    VT_THREAT_WARNINGS = 20,
    VT_EMCON_LEVEL = 22,
    VT_LAST_UPDATE_MS = 24
  };
  uint32_t SYSTEM_ID() const {
    return GetField<uint32_t>(VT_SYSTEM_ID, 0);
  }
  uint32_t ENTITY_ID() const {
    return GetField<uint32_t>(VT_ENTITY_ID, 0);
  }
  bool ESM_ACTIVE() const {
    return GetField<uint8_t>(VT_ESM_ACTIVE, 0) != 0;
  }
  bool ECM_ACTIVE() const {
    return GetField<uint8_t>(VT_ECM_ACTIVE, 0) != 0;
  }
  bool RWR_ACTIVE() const {
    return GetField<uint8_t>(VT_RWR_ACTIVE, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ESM_CONTACTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ESM_CONTACTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *ACTIVE_JAMMING() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ACTIVE_JAMMING);
  }
  const ::flatbuffers::String *COUNTERMEASURES() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTERMEASURES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *THREAT_WARNINGS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_THREAT_WARNINGS);
  }
  uint8_t EMCON_LEVEL() const {
    return GetField<uint8_t>(VT_EMCON_LEVEL, 0);
  }
  int64_t LAST_UPDATE_MS() const {
    return GetField<int64_t>(VT_LAST_UPDATE_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SYSTEM_ID, 4) &&
           VerifyField<uint32_t>(verifier, VT_ENTITY_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_ESM_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ECM_ACTIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RWR_ACTIVE, 1) &&
           VerifyOffset(verifier, VT_ESM_CONTACTS) &&
           verifier.VerifyVector(ESM_CONTACTS()) &&
           verifier.VerifyVectorOfStrings(ESM_CONTACTS()) &&
           VerifyOffset(verifier, VT_ACTIVE_JAMMING) &&
           verifier.VerifyVector(ACTIVE_JAMMING()) &&
           verifier.VerifyVectorOfStrings(ACTIVE_JAMMING()) &&
           VerifyOffset(verifier, VT_COUNTERMEASURES) &&
           verifier.VerifyString(COUNTERMEASURES()) &&
           VerifyOffset(verifier, VT_THREAT_WARNINGS) &&
           verifier.VerifyVector(THREAT_WARNINGS()) &&
           verifier.VerifyVectorOfStrings(THREAT_WARNINGS()) &&
           VerifyField<uint8_t>(verifier, VT_EMCON_LEVEL, 1) &&
           VerifyField<int64_t>(verifier, VT_LAST_UPDATE_MS, 8) &&
           verifier.EndTable();
  }
};

struct EWRBuilder {
  typedef EWR Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_SYSTEM_ID(uint32_t SYSTEM_ID) {
    fbb_.AddElement<uint32_t>(EWR::VT_SYSTEM_ID, SYSTEM_ID, 0);
  }
  void add_ENTITY_ID(uint32_t ENTITY_ID) {
    fbb_.AddElement<uint32_t>(EWR::VT_ENTITY_ID, ENTITY_ID, 0);
  }
  void add_ESM_ACTIVE(bool ESM_ACTIVE) {
    fbb_.AddElement<uint8_t>(EWR::VT_ESM_ACTIVE, static_cast<uint8_t>(ESM_ACTIVE), 0);
  }
  void add_ECM_ACTIVE(bool ECM_ACTIVE) {
    fbb_.AddElement<uint8_t>(EWR::VT_ECM_ACTIVE, static_cast<uint8_t>(ECM_ACTIVE), 0);
  }
  void add_RWR_ACTIVE(bool RWR_ACTIVE) {
    fbb_.AddElement<uint8_t>(EWR::VT_RWR_ACTIVE, static_cast<uint8_t>(RWR_ACTIVE), 0);
  }
  void add_ESM_CONTACTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ESM_CONTACTS) {
    fbb_.AddOffset(EWR::VT_ESM_CONTACTS, ESM_CONTACTS);
  }
  void add_ACTIVE_JAMMING(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ACTIVE_JAMMING) {
    fbb_.AddOffset(EWR::VT_ACTIVE_JAMMING, ACTIVE_JAMMING);
  }
  void add_COUNTERMEASURES(::flatbuffers::Offset<::flatbuffers::String> COUNTERMEASURES) {
    fbb_.AddOffset(EWR::VT_COUNTERMEASURES, COUNTERMEASURES);
  }
  void add_THREAT_WARNINGS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> THREAT_WARNINGS) {
    fbb_.AddOffset(EWR::VT_THREAT_WARNINGS, THREAT_WARNINGS);
  }
  void add_EMCON_LEVEL(uint8_t EMCON_LEVEL) {
    fbb_.AddElement<uint8_t>(EWR::VT_EMCON_LEVEL, EMCON_LEVEL, 0);
  }
  void add_LAST_UPDATE_MS(int64_t LAST_UPDATE_MS) {
    fbb_.AddElement<int64_t>(EWR::VT_LAST_UPDATE_MS, LAST_UPDATE_MS, 0);
  }
  explicit EWRBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EWR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EWR>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EWR> CreateEWR(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SYSTEM_ID = 0,
    uint32_t ENTITY_ID = 0,
    bool ESM_ACTIVE = false,
    bool ECM_ACTIVE = false,
    bool RWR_ACTIVE = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ESM_CONTACTS = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> ACTIVE_JAMMING = 0,
    ::flatbuffers::Offset<::flatbuffers::String> COUNTERMEASURES = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> THREAT_WARNINGS = 0,
    uint8_t EMCON_LEVEL = 0,
    int64_t LAST_UPDATE_MS = 0) {
  EWRBuilder builder_(_fbb);
  builder_.add_LAST_UPDATE_MS(LAST_UPDATE_MS);
  builder_.add_THREAT_WARNINGS(THREAT_WARNINGS);
  builder_.add_COUNTERMEASURES(COUNTERMEASURES);
  builder_.add_ACTIVE_JAMMING(ACTIVE_JAMMING);
  builder_.add_ESM_CONTACTS(ESM_CONTACTS);
  builder_.add_ENTITY_ID(ENTITY_ID);
  builder_.add_SYSTEM_ID(SYSTEM_ID);
  builder_.add_EMCON_LEVEL(EMCON_LEVEL);
  builder_.add_RWR_ACTIVE(RWR_ACTIVE);
  builder_.add_ECM_ACTIVE(ECM_ACTIVE);
  builder_.add_ESM_ACTIVE(ESM_ACTIVE);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EWR> CreateEWRDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t SYSTEM_ID = 0,
    uint32_t ENTITY_ID = 0,
    bool ESM_ACTIVE = false,
    bool ECM_ACTIVE = false,
    bool RWR_ACTIVE = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ESM_CONTACTS = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *ACTIVE_JAMMING = nullptr,
    const char *COUNTERMEASURES = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *THREAT_WARNINGS = nullptr,
    uint8_t EMCON_LEVEL = 0,
    int64_t LAST_UPDATE_MS = 0) {
  auto ESM_CONTACTS__ = ESM_CONTACTS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ESM_CONTACTS) : 0;
  auto ACTIVE_JAMMING__ = ACTIVE_JAMMING ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*ACTIVE_JAMMING) : 0;
  auto COUNTERMEASURES__ = COUNTERMEASURES ? _fbb.CreateString(COUNTERMEASURES) : 0;
  auto THREAT_WARNINGS__ = THREAT_WARNINGS ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*THREAT_WARNINGS) : 0;
  return CreateEWR(
      _fbb,
      SYSTEM_ID,
      ENTITY_ID,
      ESM_ACTIVE,
      ECM_ACTIVE,
      RWR_ACTIVE,
      ESM_CONTACTS__,
      ACTIVE_JAMMING__,
      COUNTERMEASURES__,
      THREAT_WARNINGS__,
      EMCON_LEVEL,
      LAST_UPDATE_MS);
}

inline const EWR *GetEWR(const void *buf) {
  return ::flatbuffers::GetRoot<EWR>(buf);
}

inline const EWR *GetSizePrefixedEWR(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EWR>(buf);
}

inline const char *EWRIdentifier() {
  return "$EWR";
}

inline bool EWRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EWRIdentifier());
}

inline bool SizePrefixedEWRBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EWRIdentifier(), true);
}

inline bool VerifyEWRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EWR>(EWRIdentifier());
}

inline bool VerifySizePrefixedEWRBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EWR>(EWRIdentifier());
}

inline void FinishEWRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EWR> root) {
  fbb.Finish(root, EWRIdentifier());
}

inline void FinishSizePrefixedEWRBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EWR> root) {
  fbb.FinishSizePrefixed(root, EWRIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
