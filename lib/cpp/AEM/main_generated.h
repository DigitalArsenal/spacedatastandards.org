// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AEMAttitudeEntry;
struct AEMAttitudeEntryBuilder;

struct AEMSegment;
struct AEMSegmentBuilder;

struct AEM;
struct AEMBuilder;

struct AEMAttitudeEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AEMAttitudeEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPOCH = 4,
    VT_Q1 = 6,
    VT_Q2 = 8,
    VT_Q3 = 10,
    VT_QC = 12,
    VT_RATE_X = 14,
    VT_RATE_Y = 16,
    VT_RATE_Z = 18
  };
  const ::flatbuffers::String *EPOCH() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  double Q1() const {
    return GetField<double>(VT_Q1, 0.0);
  }
  double Q2() const {
    return GetField<double>(VT_Q2, 0.0);
  }
  double Q3() const {
    return GetField<double>(VT_Q3, 0.0);
  }
  double QC() const {
    return GetField<double>(VT_QC, 0.0);
  }
  double RATE_X() const {
    return GetField<double>(VT_RATE_X, 0.0);
  }
  double RATE_Y() const {
    return GetField<double>(VT_RATE_Y, 0.0);
  }
  double RATE_Z() const {
    return GetField<double>(VT_RATE_Z, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(EPOCH()) &&
           VerifyField<double>(verifier, VT_Q1, 8) &&
           VerifyField<double>(verifier, VT_Q2, 8) &&
           VerifyField<double>(verifier, VT_Q3, 8) &&
           VerifyField<double>(verifier, VT_QC, 8) &&
           VerifyField<double>(verifier, VT_RATE_X, 8) &&
           VerifyField<double>(verifier, VT_RATE_Y, 8) &&
           VerifyField<double>(verifier, VT_RATE_Z, 8) &&
           verifier.EndTable();
  }
};

struct AEMAttitudeEntryBuilder {
  typedef AEMAttitudeEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_EPOCH(::flatbuffers::Offset<::flatbuffers::String> EPOCH) {
    fbb_.AddOffset(AEMAttitudeEntry::VT_EPOCH, EPOCH);
  }
  void add_Q1(double Q1) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_Q1, Q1, 0.0);
  }
  void add_Q2(double Q2) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_Q2, Q2, 0.0);
  }
  void add_Q3(double Q3) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_Q3, Q3, 0.0);
  }
  void add_QC(double QC) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_QC, QC, 0.0);
  }
  void add_RATE_X(double RATE_X) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_RATE_X, RATE_X, 0.0);
  }
  void add_RATE_Y(double RATE_Y) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_RATE_Y, RATE_Y, 0.0);
  }
  void add_RATE_Z(double RATE_Z) {
    fbb_.AddElement<double>(AEMAttitudeEntry::VT_RATE_Z, RATE_Z, 0.0);
  }
  explicit AEMAttitudeEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AEMAttitudeEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AEMAttitudeEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AEMAttitudeEntry> CreateAEMAttitudeEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> EPOCH = 0,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC = 0.0,
    double RATE_X = 0.0,
    double RATE_Y = 0.0,
    double RATE_Z = 0.0) {
  AEMAttitudeEntryBuilder builder_(_fbb);
  builder_.add_RATE_Z(RATE_Z);
  builder_.add_RATE_Y(RATE_Y);
  builder_.add_RATE_X(RATE_X);
  builder_.add_QC(QC);
  builder_.add_Q3(Q3);
  builder_.add_Q2(Q2);
  builder_.add_Q1(Q1);
  builder_.add_EPOCH(EPOCH);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AEMAttitudeEntry> CreateAEMAttitudeEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *EPOCH = nullptr,
    double Q1 = 0.0,
    double Q2 = 0.0,
    double Q3 = 0.0,
    double QC = 0.0,
    double RATE_X = 0.0,
    double RATE_Y = 0.0,
    double RATE_Z = 0.0) {
  auto EPOCH__ = EPOCH ? _fbb.CreateString(EPOCH) : 0;
  return CreateAEMAttitudeEntry(
      _fbb,
      EPOCH__,
      Q1,
      Q2,
      Q3,
      QC,
      RATE_X,
      RATE_Y,
      RATE_Z);
}

struct AEMSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AEMSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NAME = 4,
    VT_OBJECT_ID = 6,
    VT_REF_FRAME_A = 8,
    VT_REF_FRAME_B = 10,
    VT_ATTITUDE_DIR = 12,
    VT_TIME_SYSTEM = 14,
    VT_ATTITUDE_TYPE = 16,
    VT_START_TIME = 18,
    VT_STOP_TIME = 20,
    VT_DATA = 22
  };
  const ::flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  const ::flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_ID);
  }
  const ::flatbuffers::String *REF_FRAME_A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_FRAME_A);
  }
  const ::flatbuffers::String *REF_FRAME_B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_FRAME_B);
  }
  const ::flatbuffers::String *ATTITUDE_DIR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATTITUDE_DIR);
  }
  const ::flatbuffers::String *TIME_SYSTEM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_SYSTEM);
  }
  const ::flatbuffers::String *ATTITUDE_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATTITUDE_TYPE);
  }
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  const ::flatbuffers::String *STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOP_TIME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<AEMAttitudeEntry>> *DATA() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AEMAttitudeEntry>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyOffset(verifier, VT_REF_FRAME_A) &&
           verifier.VerifyString(REF_FRAME_A()) &&
           VerifyOffset(verifier, VT_REF_FRAME_B) &&
           verifier.VerifyString(REF_FRAME_B()) &&
           VerifyOffset(verifier, VT_ATTITUDE_DIR) &&
           verifier.VerifyString(ATTITUDE_DIR()) &&
           VerifyOffset(verifier, VT_TIME_SYSTEM) &&
           verifier.VerifyString(TIME_SYSTEM()) &&
           VerifyOffset(verifier, VT_ATTITUDE_TYPE) &&
           verifier.VerifyString(ATTITUDE_TYPE()) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_STOP_TIME) &&
           verifier.VerifyString(STOP_TIME()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(DATA()) &&
           verifier.VerifyVectorOfTables(DATA()) &&
           verifier.EndTable();
  }
};

struct AEMSegmentBuilder {
  typedef AEMSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OBJECT_NAME(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(AEMSegment::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(AEMSegment::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_REF_FRAME_A(::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_A) {
    fbb_.AddOffset(AEMSegment::VT_REF_FRAME_A, REF_FRAME_A);
  }
  void add_REF_FRAME_B(::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_B) {
    fbb_.AddOffset(AEMSegment::VT_REF_FRAME_B, REF_FRAME_B);
  }
  void add_ATTITUDE_DIR(::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_DIR) {
    fbb_.AddOffset(AEMSegment::VT_ATTITUDE_DIR, ATTITUDE_DIR);
  }
  void add_TIME_SYSTEM(::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM) {
    fbb_.AddOffset(AEMSegment::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  void add_ATTITUDE_TYPE(::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_TYPE) {
    fbb_.AddOffset(AEMSegment::VT_ATTITUDE_TYPE, ATTITUDE_TYPE);
  }
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(AEMSegment::VT_START_TIME, START_TIME);
  }
  void add_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> STOP_TIME) {
    fbb_.AddOffset(AEMSegment::VT_STOP_TIME, STOP_TIME);
  }
  void add_DATA(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMAttitudeEntry>>> DATA) {
    fbb_.AddOffset(AEMSegment::VT_DATA, DATA);
  }
  explicit AEMSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AEMSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AEMSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AEMSegment> CreateAEMSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_DIR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STOP_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMAttitudeEntry>>> DATA = 0) {
  AEMSegmentBuilder builder_(_fbb);
  builder_.add_DATA(DATA);
  builder_.add_STOP_TIME(STOP_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_ATTITUDE_TYPE(ATTITUDE_TYPE);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  builder_.add_ATTITUDE_DIR(ATTITUDE_DIR);
  builder_.add_REF_FRAME_B(REF_FRAME_B);
  builder_.add_REF_FRAME_A(REF_FRAME_A);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AEMSegment> CreateAEMSegmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *OBJECT_NAME = nullptr,
    const char *OBJECT_ID = nullptr,
    const char *REF_FRAME_A = nullptr,
    const char *REF_FRAME_B = nullptr,
    const char *ATTITUDE_DIR = nullptr,
    const char *TIME_SYSTEM = nullptr,
    const char *ATTITUDE_TYPE = nullptr,
    const char *START_TIME = nullptr,
    const char *STOP_TIME = nullptr,
    const std::vector<::flatbuffers::Offset<AEMAttitudeEntry>> *DATA = nullptr) {
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto REF_FRAME_A__ = REF_FRAME_A ? _fbb.CreateString(REF_FRAME_A) : 0;
  auto REF_FRAME_B__ = REF_FRAME_B ? _fbb.CreateString(REF_FRAME_B) : 0;
  auto ATTITUDE_DIR__ = ATTITUDE_DIR ? _fbb.CreateString(ATTITUDE_DIR) : 0;
  auto TIME_SYSTEM__ = TIME_SYSTEM ? _fbb.CreateString(TIME_SYSTEM) : 0;
  auto ATTITUDE_TYPE__ = ATTITUDE_TYPE ? _fbb.CreateString(ATTITUDE_TYPE) : 0;
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto STOP_TIME__ = STOP_TIME ? _fbb.CreateString(STOP_TIME) : 0;
  auto DATA__ = DATA ? _fbb.CreateVector<::flatbuffers::Offset<AEMAttitudeEntry>>(*DATA) : 0;
  return CreateAEMSegment(
      _fbb,
      OBJECT_NAME__,
      OBJECT_ID__,
      REF_FRAME_A__,
      REF_FRAME_B__,
      ATTITUDE_DIR__,
      TIME_SYSTEM__,
      ATTITUDE_TYPE__,
      START_TIME__,
      STOP_TIME__,
      DATA__);
}

/// Attitude Ephemeris Message
struct AEM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AEMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CCSDS_AEM_VERS = 4,
    VT_CREATION_DATE = 6,
    VT_ORIGINATOR = 8,
    VT_SEGMENTS = 10
  };
  const ::flatbuffers::String *CCSDS_AEM_VERS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CCSDS_AEM_VERS);
  }
  const ::flatbuffers::String *CREATION_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATION_DATE);
  }
  const ::flatbuffers::String *ORIGINATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>> *SEGMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>> *>(VT_SEGMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CCSDS_AEM_VERS) &&
           verifier.VerifyString(CCSDS_AEM_VERS()) &&
           VerifyOffset(verifier, VT_CREATION_DATE) &&
           verifier.VerifyString(CREATION_DATE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(ORIGINATOR()) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(SEGMENTS()) &&
           verifier.VerifyVectorOfTables(SEGMENTS()) &&
           verifier.EndTable();
  }
};

struct AEMBuilder {
  typedef AEM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CCSDS_AEM_VERS(::flatbuffers::Offset<::flatbuffers::String> CCSDS_AEM_VERS) {
    fbb_.AddOffset(AEM::VT_CCSDS_AEM_VERS, CCSDS_AEM_VERS);
  }
  void add_CREATION_DATE(::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE) {
    fbb_.AddOffset(AEM::VT_CREATION_DATE, CREATION_DATE);
  }
  void add_ORIGINATOR(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR) {
    fbb_.AddOffset(AEM::VT_ORIGINATOR, ORIGINATOR);
  }
  void add_SEGMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>>> SEGMENTS) {
    fbb_.AddOffset(AEM::VT_SEGMENTS, SEGMENTS);
  }
  explicit AEMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AEM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AEM> CreateAEM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CCSDS_AEM_VERS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>>> SEGMENTS = 0) {
  AEMBuilder builder_(_fbb);
  builder_.add_SEGMENTS(SEGMENTS);
  builder_.add_ORIGINATOR(ORIGINATOR);
  builder_.add_CREATION_DATE(CREATION_DATE);
  builder_.add_CCSDS_AEM_VERS(CCSDS_AEM_VERS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AEM> CreateAEMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CCSDS_AEM_VERS = nullptr,
    const char *CREATION_DATE = nullptr,
    const char *ORIGINATOR = nullptr,
    const std::vector<::flatbuffers::Offset<AEMSegment>> *SEGMENTS = nullptr) {
  auto CCSDS_AEM_VERS__ = CCSDS_AEM_VERS ? _fbb.CreateString(CCSDS_AEM_VERS) : 0;
  auto CREATION_DATE__ = CREATION_DATE ? _fbb.CreateString(CREATION_DATE) : 0;
  auto ORIGINATOR__ = ORIGINATOR ? _fbb.CreateString(ORIGINATOR) : 0;
  auto SEGMENTS__ = SEGMENTS ? _fbb.CreateVector<::flatbuffers::Offset<AEMSegment>>(*SEGMENTS) : 0;
  return CreateAEM(
      _fbb,
      CCSDS_AEM_VERS__,
      CREATION_DATE__,
      ORIGINATOR__,
      SEGMENTS__);
}

inline const AEM *GetAEM(const void *buf) {
  return ::flatbuffers::GetRoot<AEM>(buf);
}

inline const AEM *GetSizePrefixedAEM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AEM>(buf);
}

inline const char *AEMIdentifier() {
  return "$AEM";
}

inline bool AEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AEMIdentifier());
}

inline bool SizePrefixedAEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AEMIdentifier(), true);
}

inline bool VerifyAEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AEM>(AEMIdentifier());
}

inline bool VerifySizePrefixedAEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AEM>(AEMIdentifier());
}

inline void FinishAEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AEM> root) {
  fbb.Finish(root, AEMIdentifier());
}

inline void FinishSizePrefixedAEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AEM> root) {
  fbb.FinishSizePrefixed(root, AEMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
