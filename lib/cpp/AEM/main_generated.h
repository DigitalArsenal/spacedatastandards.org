// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AEMSegment;
struct AEMSegmentBuilder;

struct AEM;
struct AEMBuilder;

struct AEMSegment FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AEMSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_NAME = 4,
    VT_OBJECT_ID = 6,
    VT_REF_FRAME_A = 8,
    VT_REF_FRAME_B = 10,
    VT_ATTITUDE_DIR = 12,
    VT_TIME_SYSTEM = 14,
    VT_ATTITUDE_TYPE = 16,
    VT_START_TIME = 18,
    VT_STOP_TIME = 20,
    VT_STEP_SIZE = 22,
    VT_ATTITUDE_COMPONENTS = 24,
    VT_ATTITUDE_DATA = 26
  };
  const ::flatbuffers::String *OBJECT_NAME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_NAME);
  }
  const ::flatbuffers::String *OBJECT_ID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBJECT_ID);
  }
  const ::flatbuffers::String *REF_FRAME_A() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_FRAME_A);
  }
  const ::flatbuffers::String *REF_FRAME_B() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REF_FRAME_B);
  }
  const ::flatbuffers::String *ATTITUDE_DIR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATTITUDE_DIR);
  }
  const ::flatbuffers::String *TIME_SYSTEM() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TIME_SYSTEM);
  }
  const ::flatbuffers::String *ATTITUDE_TYPE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATTITUDE_TYPE);
  }
  const ::flatbuffers::String *START_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_TIME);
  }
  const ::flatbuffers::String *STOP_TIME() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOP_TIME);
  }
  /// Time interval between attitude states in seconds (required).
  double STEP_SIZE() const {
    return GetField<double>(VT_STEP_SIZE, 0.0);
  }
  /// Number of components per attitude state.
  /// 7 = quaternion + angular rates (Q1, Q2, Q3, QC, RATE_X, RATE_Y, RATE_Z)
  /// 4 = quaternion only (Q1, Q2, Q3, QC)
  uint8_t ATTITUDE_COMPONENTS() const {
    return GetField<uint8_t>(VT_ATTITUDE_COMPONENTS, 7);
  }
  /// Attitude data as row-major array of doubles.
  /// Layout: [Q1_0, Q2_0, Q3_0, QC_0, RATE_X_0, RATE_Y_0, RATE_Z_0, Q1_1, ...]
  /// Time reconstruction: epoch[i] = START_TIME + (i * STEP_SIZE)
  /// Length must be divisible by ATTITUDE_COMPONENTS.
  const ::flatbuffers::Vector<double> *ATTITUDE_DATA() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_ATTITUDE_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECT_NAME) &&
           verifier.VerifyString(OBJECT_NAME()) &&
           VerifyOffset(verifier, VT_OBJECT_ID) &&
           verifier.VerifyString(OBJECT_ID()) &&
           VerifyOffset(verifier, VT_REF_FRAME_A) &&
           verifier.VerifyString(REF_FRAME_A()) &&
           VerifyOffset(verifier, VT_REF_FRAME_B) &&
           verifier.VerifyString(REF_FRAME_B()) &&
           VerifyOffset(verifier, VT_ATTITUDE_DIR) &&
           verifier.VerifyString(ATTITUDE_DIR()) &&
           VerifyOffset(verifier, VT_TIME_SYSTEM) &&
           verifier.VerifyString(TIME_SYSTEM()) &&
           VerifyOffset(verifier, VT_ATTITUDE_TYPE) &&
           verifier.VerifyString(ATTITUDE_TYPE()) &&
           VerifyOffset(verifier, VT_START_TIME) &&
           verifier.VerifyString(START_TIME()) &&
           VerifyOffset(verifier, VT_STOP_TIME) &&
           verifier.VerifyString(STOP_TIME()) &&
           VerifyField<double>(verifier, VT_STEP_SIZE, 8) &&
           VerifyField<uint8_t>(verifier, VT_ATTITUDE_COMPONENTS, 1) &&
           VerifyOffset(verifier, VT_ATTITUDE_DATA) &&
           verifier.VerifyVector(ATTITUDE_DATA()) &&
           verifier.EndTable();
  }
};

struct AEMSegmentBuilder {
  typedef AEMSegment Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_OBJECT_NAME(::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME) {
    fbb_.AddOffset(AEMSegment::VT_OBJECT_NAME, OBJECT_NAME);
  }
  void add_OBJECT_ID(::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID) {
    fbb_.AddOffset(AEMSegment::VT_OBJECT_ID, OBJECT_ID);
  }
  void add_REF_FRAME_A(::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_A) {
    fbb_.AddOffset(AEMSegment::VT_REF_FRAME_A, REF_FRAME_A);
  }
  void add_REF_FRAME_B(::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_B) {
    fbb_.AddOffset(AEMSegment::VT_REF_FRAME_B, REF_FRAME_B);
  }
  void add_ATTITUDE_DIR(::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_DIR) {
    fbb_.AddOffset(AEMSegment::VT_ATTITUDE_DIR, ATTITUDE_DIR);
  }
  void add_TIME_SYSTEM(::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM) {
    fbb_.AddOffset(AEMSegment::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  void add_ATTITUDE_TYPE(::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_TYPE) {
    fbb_.AddOffset(AEMSegment::VT_ATTITUDE_TYPE, ATTITUDE_TYPE);
  }
  void add_START_TIME(::flatbuffers::Offset<::flatbuffers::String> START_TIME) {
    fbb_.AddOffset(AEMSegment::VT_START_TIME, START_TIME);
  }
  void add_STOP_TIME(::flatbuffers::Offset<::flatbuffers::String> STOP_TIME) {
    fbb_.AddOffset(AEMSegment::VT_STOP_TIME, STOP_TIME);
  }
  void add_STEP_SIZE(double STEP_SIZE) {
    fbb_.AddElement<double>(AEMSegment::VT_STEP_SIZE, STEP_SIZE, 0.0);
  }
  void add_ATTITUDE_COMPONENTS(uint8_t ATTITUDE_COMPONENTS) {
    fbb_.AddElement<uint8_t>(AEMSegment::VT_ATTITUDE_COMPONENTS, ATTITUDE_COMPONENTS, 7);
  }
  void add_ATTITUDE_DATA(::flatbuffers::Offset<::flatbuffers::Vector<double>> ATTITUDE_DATA) {
    fbb_.AddOffset(AEMSegment::VT_ATTITUDE_DATA, ATTITUDE_DATA);
  }
  explicit AEMSegmentBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AEMSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AEMSegment>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AEMSegment> CreateAEMSegment(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_NAME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> OBJECT_ID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_A = 0,
    ::flatbuffers::Offset<::flatbuffers::String> REF_FRAME_B = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_DIR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> TIME_SYSTEM = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ATTITUDE_TYPE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> START_TIME = 0,
    ::flatbuffers::Offset<::flatbuffers::String> STOP_TIME = 0,
    double STEP_SIZE = 0.0,
    uint8_t ATTITUDE_COMPONENTS = 7,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> ATTITUDE_DATA = 0) {
  AEMSegmentBuilder builder_(_fbb);
  builder_.add_STEP_SIZE(STEP_SIZE);
  builder_.add_ATTITUDE_DATA(ATTITUDE_DATA);
  builder_.add_STOP_TIME(STOP_TIME);
  builder_.add_START_TIME(START_TIME);
  builder_.add_ATTITUDE_TYPE(ATTITUDE_TYPE);
  builder_.add_TIME_SYSTEM(TIME_SYSTEM);
  builder_.add_ATTITUDE_DIR(ATTITUDE_DIR);
  builder_.add_REF_FRAME_B(REF_FRAME_B);
  builder_.add_REF_FRAME_A(REF_FRAME_A);
  builder_.add_OBJECT_ID(OBJECT_ID);
  builder_.add_OBJECT_NAME(OBJECT_NAME);
  builder_.add_ATTITUDE_COMPONENTS(ATTITUDE_COMPONENTS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AEMSegment> CreateAEMSegmentDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *OBJECT_NAME = nullptr,
    const char *OBJECT_ID = nullptr,
    const char *REF_FRAME_A = nullptr,
    const char *REF_FRAME_B = nullptr,
    const char *ATTITUDE_DIR = nullptr,
    const char *TIME_SYSTEM = nullptr,
    const char *ATTITUDE_TYPE = nullptr,
    const char *START_TIME = nullptr,
    const char *STOP_TIME = nullptr,
    double STEP_SIZE = 0.0,
    uint8_t ATTITUDE_COMPONENTS = 7,
    const std::vector<double> *ATTITUDE_DATA = nullptr) {
  auto OBJECT_NAME__ = OBJECT_NAME ? _fbb.CreateString(OBJECT_NAME) : 0;
  auto OBJECT_ID__ = OBJECT_ID ? _fbb.CreateString(OBJECT_ID) : 0;
  auto REF_FRAME_A__ = REF_FRAME_A ? _fbb.CreateString(REF_FRAME_A) : 0;
  auto REF_FRAME_B__ = REF_FRAME_B ? _fbb.CreateString(REF_FRAME_B) : 0;
  auto ATTITUDE_DIR__ = ATTITUDE_DIR ? _fbb.CreateString(ATTITUDE_DIR) : 0;
  auto TIME_SYSTEM__ = TIME_SYSTEM ? _fbb.CreateString(TIME_SYSTEM) : 0;
  auto ATTITUDE_TYPE__ = ATTITUDE_TYPE ? _fbb.CreateString(ATTITUDE_TYPE) : 0;
  auto START_TIME__ = START_TIME ? _fbb.CreateString(START_TIME) : 0;
  auto STOP_TIME__ = STOP_TIME ? _fbb.CreateString(STOP_TIME) : 0;
  auto ATTITUDE_DATA__ = ATTITUDE_DATA ? _fbb.CreateVector<double>(*ATTITUDE_DATA) : 0;
  return CreateAEMSegment(
      _fbb,
      OBJECT_NAME__,
      OBJECT_ID__,
      REF_FRAME_A__,
      REF_FRAME_B__,
      ATTITUDE_DIR__,
      TIME_SYSTEM__,
      ATTITUDE_TYPE__,
      START_TIME__,
      STOP_TIME__,
      STEP_SIZE,
      ATTITUDE_COMPONENTS,
      ATTITUDE_DATA__);
}

/// Attitude Ephemeris Message
struct AEM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AEMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CCSDS_AEM_VERS = 4,
    VT_CREATION_DATE = 6,
    VT_ORIGINATOR = 8,
    VT_SEGMENTS = 10
  };
  const ::flatbuffers::String *CCSDS_AEM_VERS() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CCSDS_AEM_VERS);
  }
  const ::flatbuffers::String *CREATION_DATE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATION_DATE);
  }
  const ::flatbuffers::String *ORIGINATOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>> *SEGMENTS() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>> *>(VT_SEGMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CCSDS_AEM_VERS) &&
           verifier.VerifyString(CCSDS_AEM_VERS()) &&
           VerifyOffset(verifier, VT_CREATION_DATE) &&
           verifier.VerifyString(CREATION_DATE()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(ORIGINATOR()) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(SEGMENTS()) &&
           verifier.VerifyVectorOfTables(SEGMENTS()) &&
           verifier.EndTable();
  }
};

struct AEMBuilder {
  typedef AEM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_CCSDS_AEM_VERS(::flatbuffers::Offset<::flatbuffers::String> CCSDS_AEM_VERS) {
    fbb_.AddOffset(AEM::VT_CCSDS_AEM_VERS, CCSDS_AEM_VERS);
  }
  void add_CREATION_DATE(::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE) {
    fbb_.AddOffset(AEM::VT_CREATION_DATE, CREATION_DATE);
  }
  void add_ORIGINATOR(::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR) {
    fbb_.AddOffset(AEM::VT_ORIGINATOR, ORIGINATOR);
  }
  void add_SEGMENTS(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>>> SEGMENTS) {
    fbb_.AddOffset(AEM::VT_SEGMENTS, SEGMENTS);
  }
  explicit AEMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AEM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AEM> CreateAEM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> CCSDS_AEM_VERS = 0,
    ::flatbuffers::Offset<::flatbuffers::String> CREATION_DATE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ORIGINATOR = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<AEMSegment>>> SEGMENTS = 0) {
  AEMBuilder builder_(_fbb);
  builder_.add_SEGMENTS(SEGMENTS);
  builder_.add_ORIGINATOR(ORIGINATOR);
  builder_.add_CREATION_DATE(CREATION_DATE);
  builder_.add_CCSDS_AEM_VERS(CCSDS_AEM_VERS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AEM> CreateAEMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *CCSDS_AEM_VERS = nullptr,
    const char *CREATION_DATE = nullptr,
    const char *ORIGINATOR = nullptr,
    const std::vector<::flatbuffers::Offset<AEMSegment>> *SEGMENTS = nullptr) {
  auto CCSDS_AEM_VERS__ = CCSDS_AEM_VERS ? _fbb.CreateString(CCSDS_AEM_VERS) : 0;
  auto CREATION_DATE__ = CREATION_DATE ? _fbb.CreateString(CREATION_DATE) : 0;
  auto ORIGINATOR__ = ORIGINATOR ? _fbb.CreateString(ORIGINATOR) : 0;
  auto SEGMENTS__ = SEGMENTS ? _fbb.CreateVector<::flatbuffers::Offset<AEMSegment>>(*SEGMENTS) : 0;
  return CreateAEM(
      _fbb,
      CCSDS_AEM_VERS__,
      CREATION_DATE__,
      ORIGINATOR__,
      SEGMENTS__);
}

inline const AEM *GetAEM(const void *buf) {
  return ::flatbuffers::GetRoot<AEM>(buf);
}

inline const AEM *GetSizePrefixedAEM(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AEM>(buf);
}

inline const char *AEMIdentifier() {
  return "$AEM";
}

inline bool AEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AEMIdentifier());
}

inline bool SizePrefixedAEMBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AEMIdentifier(), true);
}

inline bool VerifyAEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AEM>(AEMIdentifier());
}

inline bool VerifySizePrefixedAEMBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AEM>(AEMIdentifier());
}

inline void FinishAEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AEM> root) {
  fbb.Finish(root, AEMIdentifier());
}

inline void FinishSizePrefixedAEMBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AEM> root) {
  fbb.FinishSizePrefixed(root, AEMIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
