// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct PNM : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_3_3(); }
  public static PNM GetRootAsPNM(ByteBuffer _bb) { return GetRootAsPNM(_bb, new PNM()); }
  public static PNM GetRootAsPNM(ByteBuffer _bb, PNM obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool PNMBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$PNM"); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PNM __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Multiformat Address
  /// https://multiformats.io/multiaddr/
  /// A universal address format for representing multiple network protocols. Examples include:
  /// - /ip4/192.168.1.1/tcp/80 for an IPv4 address with TCP protocol
  /// - /ip6zone/x/ip6/::1 for an IPv6 address with a zone
  /// - /dns4/example.com for a domain name resolvable only to IPv4 addresses
  /// - /ipfs/bafybeiccfclkdtucu6y4yc5cpr6y3yuinr67svmii46v5cfcrkp47ihehy/README.txt -IPFS address w/CID and path to `README.txt`.
  public string MULTIFORMAT_ADDRESS { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMULTIFORMAT_ADDRESSBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetMULTIFORMAT_ADDRESSBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetMULTIFORMAT_ADDRESSArray() { return __p.__vector_as_array<byte>(4); }
  /// Publish Time OF THE Publish Notification Message
  public string PUBLISH_TIMESTAMP { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPUBLISH_TIMESTAMPBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetPUBLISH_TIMESTAMPBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetPUBLISH_TIMESTAMPArray() { return __p.__vector_as_array<byte>(6); }
  /// Concatenated Content Identifier (CID)
  /// This field is a unique ID for distributed systems (CID).
  /// The CID provides a unique identifier within distributed systems, as detailed at https://github.com/multiformats/cid. 
  public string CID { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCIDBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetCIDBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetCIDArray() { return __p.__vector_as_array<byte>(8); }
  /// File ID
  /// This field is the file ID / Name
  public string FID { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFIDBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetFIDBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetFIDArray() { return __p.__vector_as_array<byte>(10); }
  /// Digital Signature of the CID
  /// This is the digital signature of the CID, signed using the specified cryptographic method.
  public string SIGNATURE { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSIGNATUREBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetSIGNATUREBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetSIGNATUREArray() { return __p.__vector_as_array<byte>(12); }
  /// Timestamp Signature
  /// Digital signature of the publish timestamp, using the specified cryptographic method for timestamp verification.
  public string TIMESTAMP_SIGNATURE { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTIMESTAMP_SIGNATUREBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetTIMESTAMP_SIGNATUREBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetTIMESTAMP_SIGNATUREArray() { return __p.__vector_as_array<byte>(14); }
  /// Type of Cryptographic Signature Used
  /// Specifies the type of cryptographic signature used for the SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  public string SIGNATURE_TYPE { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSIGNATURE_TYPEBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetSIGNATURE_TYPEBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetSIGNATURE_TYPEArray() { return __p.__vector_as_array<byte>(16); }
  /// Type of Cryptographic Signature Used for Timestamp
  /// Specifies the type of cryptographic signature used for the TIMESTAMP_SIGNATURE field, indicating the specific blockchain technology, such as Ethereum or BTC.
  public string TIMESTAMP_SIGNATURE_TYPE { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTIMESTAMP_SIGNATURE_TYPEBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetTIMESTAMP_SIGNATURE_TYPEBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetTIMESTAMP_SIGNATURE_TYPEArray() { return __p.__vector_as_array<byte>(18); }

  public static Offset<PNM> CreatePNM(FlatBufferBuilder builder,
      StringOffset MULTIFORMAT_ADDRESSOffset = default(StringOffset),
      StringOffset PUBLISH_TIMESTAMPOffset = default(StringOffset),
      StringOffset CIDOffset = default(StringOffset),
      StringOffset FIDOffset = default(StringOffset),
      StringOffset SIGNATUREOffset = default(StringOffset),
      StringOffset TIMESTAMP_SIGNATUREOffset = default(StringOffset),
      StringOffset SIGNATURE_TYPEOffset = default(StringOffset),
      StringOffset TIMESTAMP_SIGNATURE_TYPEOffset = default(StringOffset)) {
    builder.StartTable(8);
    PNM.AddTIMESTAMP_SIGNATURE_TYPE(builder, TIMESTAMP_SIGNATURE_TYPEOffset);
    PNM.AddSIGNATURE_TYPE(builder, SIGNATURE_TYPEOffset);
    PNM.AddTIMESTAMP_SIGNATURE(builder, TIMESTAMP_SIGNATUREOffset);
    PNM.AddSIGNATURE(builder, SIGNATUREOffset);
    PNM.AddFID(builder, FIDOffset);
    PNM.AddCID(builder, CIDOffset);
    PNM.AddPUBLISH_TIMESTAMP(builder, PUBLISH_TIMESTAMPOffset);
    PNM.AddMULTIFORMAT_ADDRESS(builder, MULTIFORMAT_ADDRESSOffset);
    return PNM.EndPNM(builder);
  }

  public static void StartPNM(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddMULTIFORMAT_ADDRESS(FlatBufferBuilder builder, StringOffset MULTIFORMAT_ADDRESSOffset) { builder.AddOffset(0, MULTIFORMAT_ADDRESSOffset.Value, 0); }
  public static void AddPUBLISH_TIMESTAMP(FlatBufferBuilder builder, StringOffset PUBLISH_TIMESTAMPOffset) { builder.AddOffset(1, PUBLISH_TIMESTAMPOffset.Value, 0); }
  public static void AddCID(FlatBufferBuilder builder, StringOffset CIDOffset) { builder.AddOffset(2, CIDOffset.Value, 0); }
  public static void AddFID(FlatBufferBuilder builder, StringOffset FIDOffset) { builder.AddOffset(3, FIDOffset.Value, 0); }
  public static void AddSIGNATURE(FlatBufferBuilder builder, StringOffset SIGNATUREOffset) { builder.AddOffset(4, SIGNATUREOffset.Value, 0); }
  public static void AddTIMESTAMP_SIGNATURE(FlatBufferBuilder builder, StringOffset TIMESTAMP_SIGNATUREOffset) { builder.AddOffset(5, TIMESTAMP_SIGNATUREOffset.Value, 0); }
  public static void AddSIGNATURE_TYPE(FlatBufferBuilder builder, StringOffset SIGNATURE_TYPEOffset) { builder.AddOffset(6, SIGNATURE_TYPEOffset.Value, 0); }
  public static void AddTIMESTAMP_SIGNATURE_TYPE(FlatBufferBuilder builder, StringOffset TIMESTAMP_SIGNATURE_TYPEOffset) { builder.AddOffset(7, TIMESTAMP_SIGNATURE_TYPEOffset.Value, 0); }
  public static Offset<PNM> EndPNM(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<PNM>(o);
  }
  public static void FinishPNMBuffer(FlatBufferBuilder builder, Offset<PNM> offset) { builder.Finish(offset.Value, "$PNM"); }
  public static void FinishSizePrefixedPNMBuffer(FlatBufferBuilder builder, Offset<PNM> offset) { builder.FinishSizePrefixed(offset.Value, "$PNM"); }
  public PNMT UnPack() {
    var _o = new PNMT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PNMT _o) {
    _o.MULTIFORMAT_ADDRESS = this.MULTIFORMAT_ADDRESS;
    _o.PUBLISH_TIMESTAMP = this.PUBLISH_TIMESTAMP;
    _o.CID = this.CID;
    _o.FID = this.FID;
    _o.SIGNATURE = this.SIGNATURE;
    _o.TIMESTAMP_SIGNATURE = this.TIMESTAMP_SIGNATURE;
    _o.SIGNATURE_TYPE = this.SIGNATURE_TYPE;
    _o.TIMESTAMP_SIGNATURE_TYPE = this.TIMESTAMP_SIGNATURE_TYPE;
  }
  public static Offset<PNM> Pack(FlatBufferBuilder builder, PNMT _o) {
    if (_o == null) return default(Offset<PNM>);
    var _MULTIFORMAT_ADDRESS = _o.MULTIFORMAT_ADDRESS == null ? default(StringOffset) : builder.CreateString(_o.MULTIFORMAT_ADDRESS);
    var _PUBLISH_TIMESTAMP = _o.PUBLISH_TIMESTAMP == null ? default(StringOffset) : builder.CreateString(_o.PUBLISH_TIMESTAMP);
    var _CID = _o.CID == null ? default(StringOffset) : builder.CreateString(_o.CID);
    var _FID = _o.FID == null ? default(StringOffset) : builder.CreateString(_o.FID);
    var _SIGNATURE = _o.SIGNATURE == null ? default(StringOffset) : builder.CreateString(_o.SIGNATURE);
    var _TIMESTAMP_SIGNATURE = _o.TIMESTAMP_SIGNATURE == null ? default(StringOffset) : builder.CreateString(_o.TIMESTAMP_SIGNATURE);
    var _SIGNATURE_TYPE = _o.SIGNATURE_TYPE == null ? default(StringOffset) : builder.CreateString(_o.SIGNATURE_TYPE);
    var _TIMESTAMP_SIGNATURE_TYPE = _o.TIMESTAMP_SIGNATURE_TYPE == null ? default(StringOffset) : builder.CreateString(_o.TIMESTAMP_SIGNATURE_TYPE);
    return CreatePNM(
      builder,
      _MULTIFORMAT_ADDRESS,
      _PUBLISH_TIMESTAMP,
      _CID,
      _FID,
      _SIGNATURE,
      _TIMESTAMP_SIGNATURE,
      _SIGNATURE_TYPE,
      _TIMESTAMP_SIGNATURE_TYPE);
  }
}

public class PNMT
{
  public string MULTIFORMAT_ADDRESS { get; set; }
  public string PUBLISH_TIMESTAMP { get; set; }
  public string CID { get; set; }
  public string FID { get; set; }
  public string SIGNATURE { get; set; }
  public string TIMESTAMP_SIGNATURE { get; set; }
  public string SIGNATURE_TYPE { get; set; }
  public string TIMESTAMP_SIGNATURE_TYPE { get; set; }

  public PNMT() {
    this.MULTIFORMAT_ADDRESS = null;
    this.PUBLISH_TIMESTAMP = null;
    this.CID = null;
    this.FID = null;
    this.SIGNATURE = null;
    this.TIMESTAMP_SIGNATURE = null;
    this.SIGNATURE_TYPE = null;
    this.TIMESTAMP_SIGNATURE_TYPE = null;
  }
  public static PNMT DeserializeFromBinary(byte[] fbBuffer) {
    return PNM.GetRootAsPNM(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    PNM.FinishPNMBuffer(fbb, PNM.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}

