// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Encrypted Message Envelope
public struct EME : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static EME GetRootAsEME(ByteBuffer _bb) { return GetRootAsEME(_bb, new EME()); }
  public static EME GetRootAsEME(ByteBuffer _bb, EME obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool EMEBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$EME"); }
  public static bool VerifyEME(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$EME", false, EMEVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EME __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Encrypted data blob, containing the ciphertext of the original plaintext message.
  public byte ENCRYPTED_BLOB(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int ENCRYPTED_BLOBLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetENCRYPTED_BLOBBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetENCRYPTED_BLOBBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetENCRYPTED_BLOBArray() { return __p.__vector_as_array<byte>(4); }
  /// Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  public string EPHEMERAL_PUBLIC_KEY { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetEPHEMERAL_PUBLIC_KEYArray() { return __p.__vector_as_array<byte>(6); }
  /// Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  public string MAC { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMACBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetMACBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetMACArray() { return __p.__vector_as_array<byte>(8); }
  /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  public byte NONCE_START(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int NONCE_STARTLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNONCE_STARTBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetNONCE_STARTBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetNONCE_STARTArray() { return __p.__vector_as_array<byte>(10); }
  /// Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  public string TAG { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTAGBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetTAGBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetTAGArray() { return __p.__vector_as_array<byte>(12); }
  /// Initialization vector used to introduce randomness in the encryption process, enhancing security.
  public string IV { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIVBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetIVBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetIVArray() { return __p.__vector_as_array<byte>(14); }
  /// Cryptographic salt used in key derivation (e.g. HKDF) to ensure unique key material per session.
  public string SALT { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSALTBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetSALTBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetSALTArray() { return __p.__vector_as_array<byte>(16); }
  /// Identifier for the public key used, aiding in recipient key management and message decryption.
  public string PUBLIC_KEY_IDENTIFIER { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPUBLIC_KEY_IDENTIFIERBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetPUBLIC_KEY_IDENTIFIERBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetPUBLIC_KEY_IDENTIFIERArray() { return __p.__vector_as_array<byte>(18); }
  /// Specifies the set of cryptographic algorithms used in the encryption process.
  public string CIPHER_SUITE { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCIPHER_SUITEBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetCIPHER_SUITEBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetCIPHER_SUITEArray() { return __p.__vector_as_array<byte>(20); }
  /// Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  public string KDF_PARAMETERS { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetKDF_PARAMETERSBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetKDF_PARAMETERSBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetKDF_PARAMETERSArray() { return __p.__vector_as_array<byte>(22); }
  /// Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  public string ENCRYPTION_ALGORITHM_PARAMETERS { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetENCRYPTION_ALGORITHM_PARAMETERSBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetENCRYPTION_ALGORITHM_PARAMETERSBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetENCRYPTION_ALGORITHM_PARAMETERSArray() { return __p.__vector_as_array<byte>(24); }

  public static Offset<EME> CreateEME(FlatBufferBuilder builder,
      VectorOffset ENCRYPTED_BLOBOffset = default(VectorOffset),
      StringOffset EPHEMERAL_PUBLIC_KEYOffset = default(StringOffset),
      StringOffset MACOffset = default(StringOffset),
      VectorOffset NONCE_STARTOffset = default(VectorOffset),
      StringOffset TAGOffset = default(StringOffset),
      StringOffset IVOffset = default(StringOffset),
      StringOffset SALTOffset = default(StringOffset),
      StringOffset PUBLIC_KEY_IDENTIFIEROffset = default(StringOffset),
      StringOffset CIPHER_SUITEOffset = default(StringOffset),
      StringOffset KDF_PARAMETERSOffset = default(StringOffset),
      StringOffset ENCRYPTION_ALGORITHM_PARAMETERSOffset = default(StringOffset)) {
    builder.StartTable(11);
    EME.AddENCRYPTION_ALGORITHM_PARAMETERS(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset);
    EME.AddKDF_PARAMETERS(builder, KDF_PARAMETERSOffset);
    EME.AddCIPHER_SUITE(builder, CIPHER_SUITEOffset);
    EME.AddPUBLIC_KEY_IDENTIFIER(builder, PUBLIC_KEY_IDENTIFIEROffset);
    EME.AddSALT(builder, SALTOffset);
    EME.AddIV(builder, IVOffset);
    EME.AddTAG(builder, TAGOffset);
    EME.AddNONCE_START(builder, NONCE_STARTOffset);
    EME.AddMAC(builder, MACOffset);
    EME.AddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEYOffset);
    EME.AddENCRYPTED_BLOB(builder, ENCRYPTED_BLOBOffset);
    return EME.EndEME(builder);
  }

  public static void StartEME(FlatBufferBuilder builder) { builder.StartTable(11); }
  public static void AddENCRYPTED_BLOB(FlatBufferBuilder builder, VectorOffset ENCRYPTED_BLOBOffset) { builder.AddOffset(0, ENCRYPTED_BLOBOffset.Value, 0); }
  public static VectorOffset CreateENCRYPTED_BLOBVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartENCRYPTED_BLOBVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddEPHEMERAL_PUBLIC_KEY(FlatBufferBuilder builder, StringOffset EPHEMERAL_PUBLIC_KEYOffset) { builder.AddOffset(1, EPHEMERAL_PUBLIC_KEYOffset.Value, 0); }
  public static void AddMAC(FlatBufferBuilder builder, StringOffset MACOffset) { builder.AddOffset(2, MACOffset.Value, 0); }
  public static void AddNONCE_START(FlatBufferBuilder builder, VectorOffset NONCE_STARTOffset) { builder.AddOffset(3, NONCE_STARTOffset.Value, 0); }
  public static VectorOffset CreateNONCE_STARTVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNONCE_STARTVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTAG(FlatBufferBuilder builder, StringOffset TAGOffset) { builder.AddOffset(4, TAGOffset.Value, 0); }
  public static void AddIV(FlatBufferBuilder builder, StringOffset IVOffset) { builder.AddOffset(5, IVOffset.Value, 0); }
  public static void AddSALT(FlatBufferBuilder builder, StringOffset SALTOffset) { builder.AddOffset(6, SALTOffset.Value, 0); }
  public static void AddPUBLIC_KEY_IDENTIFIER(FlatBufferBuilder builder, StringOffset PUBLIC_KEY_IDENTIFIEROffset) { builder.AddOffset(7, PUBLIC_KEY_IDENTIFIEROffset.Value, 0); }
  public static void AddCIPHER_SUITE(FlatBufferBuilder builder, StringOffset CIPHER_SUITEOffset) { builder.AddOffset(8, CIPHER_SUITEOffset.Value, 0); }
  public static void AddKDF_PARAMETERS(FlatBufferBuilder builder, StringOffset KDF_PARAMETERSOffset) { builder.AddOffset(9, KDF_PARAMETERSOffset.Value, 0); }
  public static void AddENCRYPTION_ALGORITHM_PARAMETERS(FlatBufferBuilder builder, StringOffset ENCRYPTION_ALGORITHM_PARAMETERSOffset) { builder.AddOffset(10, ENCRYPTION_ALGORITHM_PARAMETERSOffset.Value, 0); }
  public static Offset<EME> EndEME(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<EME>(o);
  }
  public static void FinishEMEBuffer(FlatBufferBuilder builder, Offset<EME> offset) { builder.Finish(offset.Value, "$EME"); }
  public static void FinishSizePrefixedEMEBuffer(FlatBufferBuilder builder, Offset<EME> offset) { builder.FinishSizePrefixed(offset.Value, "$EME"); }
  public EMET UnPack() {
    var _o = new EMET();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(EMET _o) {
    _o.ENCRYPTED_BLOB = new List<byte>();
    for (var _j = 0; _j < this.ENCRYPTED_BLOBLength; ++_j) {_o.ENCRYPTED_BLOB.Add(this.ENCRYPTED_BLOB(_j));}
    _o.EPHEMERAL_PUBLIC_KEY = this.EPHEMERAL_PUBLIC_KEY;
    _o.MAC = this.MAC;
    _o.NONCE_START = new List<byte>();
    for (var _j = 0; _j < this.NONCE_STARTLength; ++_j) {_o.NONCE_START.Add(this.NONCE_START(_j));}
    _o.TAG = this.TAG;
    _o.IV = this.IV;
    _o.SALT = this.SALT;
    _o.PUBLIC_KEY_IDENTIFIER = this.PUBLIC_KEY_IDENTIFIER;
    _o.CIPHER_SUITE = this.CIPHER_SUITE;
    _o.KDF_PARAMETERS = this.KDF_PARAMETERS;
    _o.ENCRYPTION_ALGORITHM_PARAMETERS = this.ENCRYPTION_ALGORITHM_PARAMETERS;
  }
  public static Offset<EME> Pack(FlatBufferBuilder builder, EMET _o) {
    if (_o == null) return default(Offset<EME>);
    var _ENCRYPTED_BLOB = default(VectorOffset);
    if (_o.ENCRYPTED_BLOB != null) {
      var __ENCRYPTED_BLOB = _o.ENCRYPTED_BLOB.ToArray();
      _ENCRYPTED_BLOB = CreateENCRYPTED_BLOBVector(builder, __ENCRYPTED_BLOB);
    }
    var _EPHEMERAL_PUBLIC_KEY = _o.EPHEMERAL_PUBLIC_KEY == null ? default(StringOffset) : builder.CreateString(_o.EPHEMERAL_PUBLIC_KEY);
    var _MAC = _o.MAC == null ? default(StringOffset) : builder.CreateString(_o.MAC);
    var _NONCE_START = default(VectorOffset);
    if (_o.NONCE_START != null) {
      var __NONCE_START = _o.NONCE_START.ToArray();
      _NONCE_START = CreateNONCE_STARTVector(builder, __NONCE_START);
    }
    var _TAG = _o.TAG == null ? default(StringOffset) : builder.CreateString(_o.TAG);
    var _IV = _o.IV == null ? default(StringOffset) : builder.CreateString(_o.IV);
    var _SALT = _o.SALT == null ? default(StringOffset) : builder.CreateString(_o.SALT);
    var _PUBLIC_KEY_IDENTIFIER = _o.PUBLIC_KEY_IDENTIFIER == null ? default(StringOffset) : builder.CreateString(_o.PUBLIC_KEY_IDENTIFIER);
    var _CIPHER_SUITE = _o.CIPHER_SUITE == null ? default(StringOffset) : builder.CreateString(_o.CIPHER_SUITE);
    var _KDF_PARAMETERS = _o.KDF_PARAMETERS == null ? default(StringOffset) : builder.CreateString(_o.KDF_PARAMETERS);
    var _ENCRYPTION_ALGORITHM_PARAMETERS = _o.ENCRYPTION_ALGORITHM_PARAMETERS == null ? default(StringOffset) : builder.CreateString(_o.ENCRYPTION_ALGORITHM_PARAMETERS);
    return CreateEME(
      builder,
      _ENCRYPTED_BLOB,
      _EPHEMERAL_PUBLIC_KEY,
      _MAC,
      _NONCE_START,
      _TAG,
      _IV,
      _SALT,
      _PUBLIC_KEY_IDENTIFIER,
      _CIPHER_SUITE,
      _KDF_PARAMETERS,
      _ENCRYPTION_ALGORITHM_PARAMETERS);
  }
}

public class EMET
{
  public List<byte> ENCRYPTED_BLOB { get; set; }
  public string EPHEMERAL_PUBLIC_KEY { get; set; }
  public string MAC { get; set; }
  public List<byte> NONCE_START { get; set; }
  public string TAG { get; set; }
  public string IV { get; set; }
  public string SALT { get; set; }
  public string PUBLIC_KEY_IDENTIFIER { get; set; }
  public string CIPHER_SUITE { get; set; }
  public string KDF_PARAMETERS { get; set; }
  public string ENCRYPTION_ALGORITHM_PARAMETERS { get; set; }

  public EMET() {
    this.ENCRYPTED_BLOB = null;
    this.EPHEMERAL_PUBLIC_KEY = null;
    this.MAC = null;
    this.NONCE_START = null;
    this.TAG = null;
    this.IV = null;
    this.SALT = null;
    this.PUBLIC_KEY_IDENTIFIER = null;
    this.CIPHER_SUITE = null;
    this.KDF_PARAMETERS = null;
    this.ENCRYPTION_ALGORITHM_PARAMETERS = null;
  }
  public static EMET DeserializeFromBinary(byte[] fbBuffer) {
    return EME.GetRootAsEME(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    EME.FinishEMEBuffer(fbb, EME.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class EMEVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfData(tablePos, 4 /*ENCRYPTED_BLOB*/, 1 /*byte*/, false)
      && verifier.VerifyString(tablePos, 6 /*EPHEMERAL_PUBLIC_KEY*/, false)
      && verifier.VerifyString(tablePos, 8 /*MAC*/, false)
      && verifier.VerifyVectorOfData(tablePos, 10 /*NONCE_START*/, 1 /*byte*/, false)
      && verifier.VerifyString(tablePos, 12 /*TAG*/, false)
      && verifier.VerifyString(tablePos, 14 /*IV*/, false)
      && verifier.VerifyString(tablePos, 16 /*SALT*/, false)
      && verifier.VerifyString(tablePos, 18 /*PUBLIC_KEY_IDENTIFIER*/, false)
      && verifier.VerifyString(tablePos, 20 /*CIPHER_SUITE*/, false)
      && verifier.VerifyString(tablePos, 22 /*KDF_PARAMETERS*/, false)
      && verifier.VerifyString(tablePos, 24 /*ENCRYPTION_ALGORITHM_PARAMETERS*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
