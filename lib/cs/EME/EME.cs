// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Encrypted Message Envelope (EME)
/// Define a collection of Encrypted Message Envelopes with detailed ECIES encryption fields
/// Encrypted Message Envelope
public struct EME : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_3_3(); }
  public static EME GetRootAsEME(ByteBuffer _bb) { return GetRootAsEME(_bb, new EME()); }
  public static EME GetRootAsEME(ByteBuffer _bb, EME obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EME __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Encrypted data blob, containing the ciphertext of the original plaintext message.
  public byte ENCRYPTED_BLOB(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int ENCRYPTED_BLOBLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetENCRYPTED_BLOBBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetENCRYPTED_BLOBBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetENCRYPTED_BLOBArray() { return __p.__vector_as_array<byte>(4); }
  /// Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  public string EPHEMERAL_PUBLIC_KEY { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetEPHEMERAL_PUBLIC_KEYArray() { return __p.__vector_as_array<byte>(6); }
  /// Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  public string MAC { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMACBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetMACBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetMACArray() { return __p.__vector_as_array<byte>(8); }
  /// Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
  public string NONCE { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNONCEBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetNONCEBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetNONCEArray() { return __p.__vector_as_array<byte>(10); }
  /// Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  public string TAG { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTAGBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetTAGBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetTAGArray() { return __p.__vector_as_array<byte>(12); }
  /// Initialization vector used to introduce randomness in the encryption process, enhancing security.
  public string IV { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIVBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetIVBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetIVArray() { return __p.__vector_as_array<byte>(14); }
  /// Identifier for the public key used, aiding in recipient key management and message decryption.
  public string PUBLIC_KEY_IDENTIFIER { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPUBLIC_KEY_IDENTIFIERBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetPUBLIC_KEY_IDENTIFIERBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetPUBLIC_KEY_IDENTIFIERArray() { return __p.__vector_as_array<byte>(16); }
  /// Specifies the set of cryptographic algorithms used in the encryption process.
  public string CIPHER_SUITE { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCIPHER_SUITEBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetCIPHER_SUITEBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetCIPHER_SUITEArray() { return __p.__vector_as_array<byte>(18); }
  /// Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  public string KDF_PARAMETERS { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetKDF_PARAMETERSBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetKDF_PARAMETERSBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetKDF_PARAMETERSArray() { return __p.__vector_as_array<byte>(20); }
  /// Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  public string ENCRYPTION_ALGORITHM_PARAMETERS { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetENCRYPTION_ALGORITHM_PARAMETERSBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetENCRYPTION_ALGORITHM_PARAMETERSBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetENCRYPTION_ALGORITHM_PARAMETERSArray() { return __p.__vector_as_array<byte>(22); }

  public static Offset<EME> CreateEME(FlatBufferBuilder builder,
      VectorOffset ENCRYPTED_BLOBOffset = default(VectorOffset),
      StringOffset EPHEMERAL_PUBLIC_KEYOffset = default(StringOffset),
      StringOffset MACOffset = default(StringOffset),
      StringOffset NONCEOffset = default(StringOffset),
      StringOffset TAGOffset = default(StringOffset),
      StringOffset IVOffset = default(StringOffset),
      StringOffset PUBLIC_KEY_IDENTIFIEROffset = default(StringOffset),
      StringOffset CIPHER_SUITEOffset = default(StringOffset),
      StringOffset KDF_PARAMETERSOffset = default(StringOffset),
      StringOffset ENCRYPTION_ALGORITHM_PARAMETERSOffset = default(StringOffset)) {
    builder.StartTable(10);
    EME.AddENCRYPTION_ALGORITHM_PARAMETERS(builder, ENCRYPTION_ALGORITHM_PARAMETERSOffset);
    EME.AddKDF_PARAMETERS(builder, KDF_PARAMETERSOffset);
    EME.AddCIPHER_SUITE(builder, CIPHER_SUITEOffset);
    EME.AddPUBLIC_KEY_IDENTIFIER(builder, PUBLIC_KEY_IDENTIFIEROffset);
    EME.AddIV(builder, IVOffset);
    EME.AddTAG(builder, TAGOffset);
    EME.AddNONCE(builder, NONCEOffset);
    EME.AddMAC(builder, MACOffset);
    EME.AddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEYOffset);
    EME.AddENCRYPTED_BLOB(builder, ENCRYPTED_BLOBOffset);
    return EME.EndEME(builder);
  }

  public static void StartEME(FlatBufferBuilder builder) { builder.StartTable(10); }
  public static void AddENCRYPTED_BLOB(FlatBufferBuilder builder, VectorOffset ENCRYPTED_BLOBOffset) { builder.AddOffset(0, ENCRYPTED_BLOBOffset.Value, 0); }
  public static VectorOffset CreateENCRYPTED_BLOBVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENCRYPTED_BLOBVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartENCRYPTED_BLOBVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddEPHEMERAL_PUBLIC_KEY(FlatBufferBuilder builder, StringOffset EPHEMERAL_PUBLIC_KEYOffset) { builder.AddOffset(1, EPHEMERAL_PUBLIC_KEYOffset.Value, 0); }
  public static void AddMAC(FlatBufferBuilder builder, StringOffset MACOffset) { builder.AddOffset(2, MACOffset.Value, 0); }
  public static void AddNONCE(FlatBufferBuilder builder, StringOffset NONCEOffset) { builder.AddOffset(3, NONCEOffset.Value, 0); }
  public static void AddTAG(FlatBufferBuilder builder, StringOffset TAGOffset) { builder.AddOffset(4, TAGOffset.Value, 0); }
  public static void AddIV(FlatBufferBuilder builder, StringOffset IVOffset) { builder.AddOffset(5, IVOffset.Value, 0); }
  public static void AddPUBLIC_KEY_IDENTIFIER(FlatBufferBuilder builder, StringOffset PUBLIC_KEY_IDENTIFIEROffset) { builder.AddOffset(6, PUBLIC_KEY_IDENTIFIEROffset.Value, 0); }
  public static void AddCIPHER_SUITE(FlatBufferBuilder builder, StringOffset CIPHER_SUITEOffset) { builder.AddOffset(7, CIPHER_SUITEOffset.Value, 0); }
  public static void AddKDF_PARAMETERS(FlatBufferBuilder builder, StringOffset KDF_PARAMETERSOffset) { builder.AddOffset(8, KDF_PARAMETERSOffset.Value, 0); }
  public static void AddENCRYPTION_ALGORITHM_PARAMETERS(FlatBufferBuilder builder, StringOffset ENCRYPTION_ALGORITHM_PARAMETERSOffset) { builder.AddOffset(9, ENCRYPTION_ALGORITHM_PARAMETERSOffset.Value, 0); }
  public static Offset<EME> EndEME(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<EME>(o);
  }
  public EMET UnPack() {
    var _o = new EMET();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(EMET _o) {
    _o.ENCRYPTED_BLOB = new List<byte>();
    for (var _j = 0; _j < this.ENCRYPTED_BLOBLength; ++_j) {_o.ENCRYPTED_BLOB.Add(this.ENCRYPTED_BLOB(_j));}
    _o.EPHEMERAL_PUBLIC_KEY = this.EPHEMERAL_PUBLIC_KEY;
    _o.MAC = this.MAC;
    _o.NONCE = this.NONCE;
    _o.TAG = this.TAG;
    _o.IV = this.IV;
    _o.PUBLIC_KEY_IDENTIFIER = this.PUBLIC_KEY_IDENTIFIER;
    _o.CIPHER_SUITE = this.CIPHER_SUITE;
    _o.KDF_PARAMETERS = this.KDF_PARAMETERS;
    _o.ENCRYPTION_ALGORITHM_PARAMETERS = this.ENCRYPTION_ALGORITHM_PARAMETERS;
  }
  public static Offset<EME> Pack(FlatBufferBuilder builder, EMET _o) {
    if (_o == null) return default(Offset<EME>);
    var _ENCRYPTED_BLOB = default(VectorOffset);
    if (_o.ENCRYPTED_BLOB != null) {
      var __ENCRYPTED_BLOB = _o.ENCRYPTED_BLOB.ToArray();
      _ENCRYPTED_BLOB = CreateENCRYPTED_BLOBVector(builder, __ENCRYPTED_BLOB);
    }
    var _EPHEMERAL_PUBLIC_KEY = _o.EPHEMERAL_PUBLIC_KEY == null ? default(StringOffset) : builder.CreateString(_o.EPHEMERAL_PUBLIC_KEY);
    var _MAC = _o.MAC == null ? default(StringOffset) : builder.CreateString(_o.MAC);
    var _NONCE = _o.NONCE == null ? default(StringOffset) : builder.CreateString(_o.NONCE);
    var _TAG = _o.TAG == null ? default(StringOffset) : builder.CreateString(_o.TAG);
    var _IV = _o.IV == null ? default(StringOffset) : builder.CreateString(_o.IV);
    var _PUBLIC_KEY_IDENTIFIER = _o.PUBLIC_KEY_IDENTIFIER == null ? default(StringOffset) : builder.CreateString(_o.PUBLIC_KEY_IDENTIFIER);
    var _CIPHER_SUITE = _o.CIPHER_SUITE == null ? default(StringOffset) : builder.CreateString(_o.CIPHER_SUITE);
    var _KDF_PARAMETERS = _o.KDF_PARAMETERS == null ? default(StringOffset) : builder.CreateString(_o.KDF_PARAMETERS);
    var _ENCRYPTION_ALGORITHM_PARAMETERS = _o.ENCRYPTION_ALGORITHM_PARAMETERS == null ? default(StringOffset) : builder.CreateString(_o.ENCRYPTION_ALGORITHM_PARAMETERS);
    return CreateEME(
      builder,
      _ENCRYPTED_BLOB,
      _EPHEMERAL_PUBLIC_KEY,
      _MAC,
      _NONCE,
      _TAG,
      _IV,
      _PUBLIC_KEY_IDENTIFIER,
      _CIPHER_SUITE,
      _KDF_PARAMETERS,
      _ENCRYPTION_ALGORITHM_PARAMETERS);
  }
}

public class EMET
{
  public List<byte> ENCRYPTED_BLOB { get; set; }
  public string EPHEMERAL_PUBLIC_KEY { get; set; }
  public string MAC { get; set; }
  public string NONCE { get; set; }
  public string TAG { get; set; }
  public string IV { get; set; }
  public string PUBLIC_KEY_IDENTIFIER { get; set; }
  public string CIPHER_SUITE { get; set; }
  public string KDF_PARAMETERS { get; set; }
  public string ENCRYPTION_ALGORITHM_PARAMETERS { get; set; }

  public EMET() {
    this.ENCRYPTED_BLOB = null;
    this.EPHEMERAL_PUBLIC_KEY = null;
    this.MAC = null;
    this.NONCE = null;
    this.TAG = null;
    this.IV = null;
    this.PUBLIC_KEY_IDENTIFIER = null;
    this.CIPHER_SUITE = null;
    this.KDF_PARAMETERS = null;
    this.ENCRYPTION_ALGORITHM_PARAMETERS = null;
  }
}

