// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Access Control Grant - Permission to access purchased data
public struct ACL : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static ACL GetRootAsACL(ByteBuffer _bb) { return GetRootAsACL(_bb, new ACL()); }
  public static ACL GetRootAsACL(ByteBuffer _bb, ACL obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool ACLBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$ACL"); }
  public static bool VerifyACL(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$ACL", false, ACLVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ACL __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier for this grant
  public string GRANT_ID { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGRANT_IDBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetGRANT_IDBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetGRANT_IDArray() { return __p.__vector_as_array<byte>(4); }
  /// ID of the listing this grant applies to
  public string LISTING_ID { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLISTING_IDBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetLISTING_IDBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetLISTING_IDArray() { return __p.__vector_as_array<byte>(6); }
  /// Peer ID of the buyer/grantee
  public string BUYER_PEER_ID { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBUYER_PEER_IDBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetBUYER_PEER_IDBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetBUYER_PEER_IDArray() { return __p.__vector_as_array<byte>(8); }
  /// Buyer's encryption public key for encrypted delivery
  public byte BUYER_ENCRYPTION_PUBKEY(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int BUYER_ENCRYPTION_PUBKEYLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBUYER_ENCRYPTION_PUBKEYBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetBUYER_ENCRYPTION_PUBKEYBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetBUYER_ENCRYPTION_PUBKEYArray() { return __p.__vector_as_array<byte>(10); }
  /// Type of access granted
  public accessType ACCESS_TYPE { get { int o = __p.__offset(12); return o != 0 ? (accessType)__p.bb.GetSbyte(o + __p.bb_pos) : accessType.OneTime; } }
  /// Name of the pricing tier purchased
  public string TIER_NAME { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTIER_NAMEBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetTIER_NAMEBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetTIER_NAMEArray() { return __p.__vector_as_array<byte>(14); }
  /// Unix timestamp when access was granted
  public ulong GRANTED_AT { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  /// Unix timestamp when access expires (0 = never expires)
  public ulong EXPIRES_AT { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  /// Transaction hash or reference proving payment
  public string PAYMENT_TX_HASH { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYMENT_TX_HASHBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetPAYMENT_TX_HASHBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetPAYMENT_TX_HASHArray() { return __p.__vector_as_array<byte>(20); }
  /// Payment method used
  public paymentMethod PAYMENT_METHOD { get { int o = __p.__offset(22); return o != 0 ? (paymentMethod)__p.bb.GetSbyte(o + __p.bb_pos) : paymentMethod.Crypto_ETH; } }
  /// Ed25519 signature from provider
  public byte PROVIDER_SIGNATURE(int j) { int o = __p.__offset(24); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int PROVIDER_SIGNATURELength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPROVIDER_SIGNATUREBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetPROVIDER_SIGNATUREBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetPROVIDER_SIGNATUREArray() { return __p.__vector_as_array<byte>(24); }

  public static Offset<ACL> CreateACL(FlatBufferBuilder builder,
      StringOffset GRANT_IDOffset = default(StringOffset),
      StringOffset LISTING_IDOffset = default(StringOffset),
      StringOffset BUYER_PEER_IDOffset = default(StringOffset),
      VectorOffset BUYER_ENCRYPTION_PUBKEYOffset = default(VectorOffset),
      accessType ACCESS_TYPE = accessType.OneTime,
      StringOffset TIER_NAMEOffset = default(StringOffset),
      ulong GRANTED_AT = 0,
      ulong EXPIRES_AT = 0,
      StringOffset PAYMENT_TX_HASHOffset = default(StringOffset),
      paymentMethod PAYMENT_METHOD = paymentMethod.Crypto_ETH,
      VectorOffset PROVIDER_SIGNATUREOffset = default(VectorOffset)) {
    builder.StartTable(11);
    ACL.AddEXPIRES_AT(builder, EXPIRES_AT);
    ACL.AddGRANTED_AT(builder, GRANTED_AT);
    ACL.AddPROVIDER_SIGNATURE(builder, PROVIDER_SIGNATUREOffset);
    ACL.AddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASHOffset);
    ACL.AddTIER_NAME(builder, TIER_NAMEOffset);
    ACL.AddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEYOffset);
    ACL.AddBUYER_PEER_ID(builder, BUYER_PEER_IDOffset);
    ACL.AddLISTING_ID(builder, LISTING_IDOffset);
    ACL.AddGRANT_ID(builder, GRANT_IDOffset);
    ACL.AddPAYMENT_METHOD(builder, PAYMENT_METHOD);
    ACL.AddACCESS_TYPE(builder, ACCESS_TYPE);
    return ACL.EndACL(builder);
  }

  public static void StartACL(FlatBufferBuilder builder) { builder.StartTable(11); }
  public static void AddGRANT_ID(FlatBufferBuilder builder, StringOffset GRANT_IDOffset) { builder.AddOffset(0, GRANT_IDOffset.Value, 0); }
  public static void AddLISTING_ID(FlatBufferBuilder builder, StringOffset LISTING_IDOffset) { builder.AddOffset(1, LISTING_IDOffset.Value, 0); }
  public static void AddBUYER_PEER_ID(FlatBufferBuilder builder, StringOffset BUYER_PEER_IDOffset) { builder.AddOffset(2, BUYER_PEER_IDOffset.Value, 0); }
  public static void AddBUYER_ENCRYPTION_PUBKEY(FlatBufferBuilder builder, VectorOffset BUYER_ENCRYPTION_PUBKEYOffset) { builder.AddOffset(3, BUYER_ENCRYPTION_PUBKEYOffset.Value, 0); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBUYER_ENCRYPTION_PUBKEYVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddACCESS_TYPE(FlatBufferBuilder builder, accessType ACCESS_TYPE) { builder.AddSbyte(4, (sbyte)ACCESS_TYPE, 0); }
  public static void AddTIER_NAME(FlatBufferBuilder builder, StringOffset TIER_NAMEOffset) { builder.AddOffset(5, TIER_NAMEOffset.Value, 0); }
  public static void AddGRANTED_AT(FlatBufferBuilder builder, ulong GRANTED_AT) { builder.AddUlong(6, GRANTED_AT, 0); }
  public static void AddEXPIRES_AT(FlatBufferBuilder builder, ulong EXPIRES_AT) { builder.AddUlong(7, EXPIRES_AT, 0); }
  public static void AddPAYMENT_TX_HASH(FlatBufferBuilder builder, StringOffset PAYMENT_TX_HASHOffset) { builder.AddOffset(8, PAYMENT_TX_HASHOffset.Value, 0); }
  public static void AddPAYMENT_METHOD(FlatBufferBuilder builder, paymentMethod PAYMENT_METHOD) { builder.AddSbyte(9, (sbyte)PAYMENT_METHOD, 0); }
  public static void AddPROVIDER_SIGNATURE(FlatBufferBuilder builder, VectorOffset PROVIDER_SIGNATUREOffset) { builder.AddOffset(10, PROVIDER_SIGNATUREOffset.Value, 0); }
  public static VectorOffset CreatePROVIDER_SIGNATUREVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePROVIDER_SIGNATUREVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePROVIDER_SIGNATUREVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePROVIDER_SIGNATUREVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPROVIDER_SIGNATUREVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<ACL> EndACL(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // GRANT_ID
    builder.Required(o, 6);  // LISTING_ID
    builder.Required(o, 8);  // BUYER_PEER_ID
    return new Offset<ACL>(o);
  }
  public static void FinishACLBuffer(FlatBufferBuilder builder, Offset<ACL> offset) { builder.Finish(offset.Value, "$ACL"); }
  public static void FinishSizePrefixedACLBuffer(FlatBufferBuilder builder, Offset<ACL> offset) { builder.FinishSizePrefixed(offset.Value, "$ACL"); }
  public ACLT UnPack() {
    var _o = new ACLT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ACLT _o) {
    _o.GRANT_ID = this.GRANT_ID;
    _o.LISTING_ID = this.LISTING_ID;
    _o.BUYER_PEER_ID = this.BUYER_PEER_ID;
    _o.BUYER_ENCRYPTION_PUBKEY = new List<byte>();
    for (var _j = 0; _j < this.BUYER_ENCRYPTION_PUBKEYLength; ++_j) {_o.BUYER_ENCRYPTION_PUBKEY.Add(this.BUYER_ENCRYPTION_PUBKEY(_j));}
    _o.ACCESS_TYPE = this.ACCESS_TYPE;
    _o.TIER_NAME = this.TIER_NAME;
    _o.GRANTED_AT = this.GRANTED_AT;
    _o.EXPIRES_AT = this.EXPIRES_AT;
    _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH;
    _o.PAYMENT_METHOD = this.PAYMENT_METHOD;
    _o.PROVIDER_SIGNATURE = new List<byte>();
    for (var _j = 0; _j < this.PROVIDER_SIGNATURELength; ++_j) {_o.PROVIDER_SIGNATURE.Add(this.PROVIDER_SIGNATURE(_j));}
  }
  public static Offset<ACL> Pack(FlatBufferBuilder builder, ACLT _o) {
    if (_o == null) return default(Offset<ACL>);
    var _GRANT_ID = _o.GRANT_ID == null ? default(StringOffset) : builder.CreateString(_o.GRANT_ID);
    var _LISTING_ID = _o.LISTING_ID == null ? default(StringOffset) : builder.CreateString(_o.LISTING_ID);
    var _BUYER_PEER_ID = _o.BUYER_PEER_ID == null ? default(StringOffset) : builder.CreateString(_o.BUYER_PEER_ID);
    var _BUYER_ENCRYPTION_PUBKEY = default(VectorOffset);
    if (_o.BUYER_ENCRYPTION_PUBKEY != null) {
      var __BUYER_ENCRYPTION_PUBKEY = _o.BUYER_ENCRYPTION_PUBKEY.ToArray();
      _BUYER_ENCRYPTION_PUBKEY = CreateBUYER_ENCRYPTION_PUBKEYVector(builder, __BUYER_ENCRYPTION_PUBKEY);
    }
    var _TIER_NAME = _o.TIER_NAME == null ? default(StringOffset) : builder.CreateString(_o.TIER_NAME);
    var _PAYMENT_TX_HASH = _o.PAYMENT_TX_HASH == null ? default(StringOffset) : builder.CreateString(_o.PAYMENT_TX_HASH);
    var _PROVIDER_SIGNATURE = default(VectorOffset);
    if (_o.PROVIDER_SIGNATURE != null) {
      var __PROVIDER_SIGNATURE = _o.PROVIDER_SIGNATURE.ToArray();
      _PROVIDER_SIGNATURE = CreatePROVIDER_SIGNATUREVector(builder, __PROVIDER_SIGNATURE);
    }
    return CreateACL(
      builder,
      _GRANT_ID,
      _LISTING_ID,
      _BUYER_PEER_ID,
      _BUYER_ENCRYPTION_PUBKEY,
      _o.ACCESS_TYPE,
      _TIER_NAME,
      _o.GRANTED_AT,
      _o.EXPIRES_AT,
      _PAYMENT_TX_HASH,
      _o.PAYMENT_METHOD,
      _PROVIDER_SIGNATURE);
  }
}

public class ACLT
{
  public string GRANT_ID { get; set; }
  public string LISTING_ID { get; set; }
  public string BUYER_PEER_ID { get; set; }
  public List<byte> BUYER_ENCRYPTION_PUBKEY { get; set; }
  public accessType ACCESS_TYPE { get; set; }
  public string TIER_NAME { get; set; }
  public ulong GRANTED_AT { get; set; }
  public ulong EXPIRES_AT { get; set; }
  public string PAYMENT_TX_HASH { get; set; }
  public paymentMethod PAYMENT_METHOD { get; set; }
  public List<byte> PROVIDER_SIGNATURE { get; set; }

  public ACLT() {
    this.GRANT_ID = null;
    this.LISTING_ID = null;
    this.BUYER_PEER_ID = null;
    this.BUYER_ENCRYPTION_PUBKEY = null;
    this.ACCESS_TYPE = accessType.OneTime;
    this.TIER_NAME = null;
    this.GRANTED_AT = 0;
    this.EXPIRES_AT = 0;
    this.PAYMENT_TX_HASH = null;
    this.PAYMENT_METHOD = paymentMethod.Crypto_ETH;
    this.PROVIDER_SIGNATURE = null;
  }
  public static ACLT DeserializeFromBinary(byte[] fbBuffer) {
    return ACL.GetRootAsACL(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    ACL.FinishACLBuffer(fbb, ACL.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class ACLVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*GRANT_ID*/, true)
      && verifier.VerifyString(tablePos, 6 /*LISTING_ID*/, true)
      && verifier.VerifyString(tablePos, 8 /*BUYER_PEER_ID*/, true)
      && verifier.VerifyVectorOfData(tablePos, 10 /*BUYER_ENCRYPTION_PUBKEY*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 12 /*ACCESS_TYPE*/, 1 /*accessType*/, 1, false)
      && verifier.VerifyString(tablePos, 14 /*TIER_NAME*/, false)
      && verifier.VerifyField(tablePos, 16 /*GRANTED_AT*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 18 /*EXPIRES_AT*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyString(tablePos, 20 /*PAYMENT_TX_HASH*/, false)
      && verifier.VerifyField(tablePos, 22 /*PAYMENT_METHOD*/, 1 /*paymentMethod*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 24 /*PROVIDER_SIGNATURE*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
