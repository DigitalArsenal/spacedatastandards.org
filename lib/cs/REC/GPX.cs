// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// GPX Document
public struct GPX : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static GPX GetRootAsGPX(ByteBuffer _bb) { return GetRootAsGPX(_bb, new GPX()); }
  public static GPX GetRootAsGPX(ByteBuffer _bb, GPX obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool GPXBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$GPX"); }
  public static bool VerifyGPX(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$GPX", false, GPXVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GPX __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// GPX schema version
  public string VERSION { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVERSIONBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetVERSIONBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetVERSIONArray() { return __p.__vector_as_array<byte>(4); }
  /// Creator software/organization
  public string CREATOR { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCREATORBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetCREATORBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetCREATORArray() { return __p.__vector_as_array<byte>(6); }
  /// File name
  public string NAME { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNAMEBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetNAMEBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetNAMEArray() { return __p.__vector_as_array<byte>(8); }
  /// File description
  public string DESCRIPTION { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDESCRIPTIONBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetDESCRIPTIONBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetDESCRIPTIONArray() { return __p.__vector_as_array<byte>(10); }
  /// Person or organization who created the file
  public string AUTHOR_NAME { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAUTHOR_NAMEBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetAUTHOR_NAMEBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetAUTHOR_NAMEArray() { return __p.__vector_as_array<byte>(12); }
  /// Author email
  public string AUTHOR_EMAIL { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAUTHOR_EMAILBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetAUTHOR_EMAILBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetAUTHOR_EMAILArray() { return __p.__vector_as_array<byte>(14); }
  /// Author link
  public GPXLink? AUTHOR_LINK { get { int o = __p.__offset(16); return o != 0 ? (GPXLink?)(new GPXLink()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Copyright holder
  public string COPYRIGHT_AUTHOR { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCOPYRIGHT_AUTHORBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetCOPYRIGHT_AUTHORBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetCOPYRIGHT_AUTHORArray() { return __p.__vector_as_array<byte>(18); }
  /// Copyright year
  public string COPYRIGHT_YEAR { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCOPYRIGHT_YEARBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetCOPYRIGHT_YEARBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetCOPYRIGHT_YEARArray() { return __p.__vector_as_array<byte>(20); }
  /// Copyright license URL
  public string COPYRIGHT_LICENSE { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCOPYRIGHT_LICENSEBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetCOPYRIGHT_LICENSEBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetCOPYRIGHT_LICENSEArray() { return __p.__vector_as_array<byte>(22); }
  /// Links to additional information
  public GPXLink? LINKS(int j) { int o = __p.__offset(24); return o != 0 ? (GPXLink?)(new GPXLink()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int LINKSLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Creation timestamp (ISO 8601)
  public string TIME { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTIMEBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetTIMEBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetTIMEArray() { return __p.__vector_as_array<byte>(26); }
  /// Keywords
  public string KEYWORDS { get { int o = __p.__offset(28); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetKEYWORDSBytes() { return __p.__vector_as_span<byte>(28, 1); }
#else
  public ArraySegment<byte>? GetKEYWORDSBytes() { return __p.__vector_as_arraysegment(28); }
#endif
  public byte[] GetKEYWORDSArray() { return __p.__vector_as_array<byte>(28); }
  /// Minimum latitude of bounding box
  public double BOUNDS_MIN_LAT { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Minimum longitude of bounding box
  public double BOUNDS_MIN_LON { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Maximum latitude of bounding box
  public double BOUNDS_MAX_LAT { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Maximum longitude of bounding box
  public double BOUNDS_MAX_LON { get { int o = __p.__offset(36); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Waypoints
  public GPXWaypoint? WAYPOINTS(int j) { int o = __p.__offset(38); return o != 0 ? (GPXWaypoint?)(new GPXWaypoint()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int WAYPOINTSLength { get { int o = __p.__offset(38); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Routes
  public GPXRoute? ROUTES(int j) { int o = __p.__offset(40); return o != 0 ? (GPXRoute?)(new GPXRoute()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ROUTESLength { get { int o = __p.__offset(40); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Tracks
  public GPXTrack? TRACKS(int j) { int o = __p.__offset(42); return o != 0 ? (GPXTrack?)(new GPXTrack()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TRACKSLength { get { int o = __p.__offset(42); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<GPX> CreateGPX(FlatBufferBuilder builder,
      StringOffset VERSIONOffset = default(StringOffset),
      StringOffset CREATOROffset = default(StringOffset),
      StringOffset NAMEOffset = default(StringOffset),
      StringOffset DESCRIPTIONOffset = default(StringOffset),
      StringOffset AUTHOR_NAMEOffset = default(StringOffset),
      StringOffset AUTHOR_EMAILOffset = default(StringOffset),
      Offset<GPXLink> AUTHOR_LINKOffset = default(Offset<GPXLink>),
      StringOffset COPYRIGHT_AUTHOROffset = default(StringOffset),
      StringOffset COPYRIGHT_YEAROffset = default(StringOffset),
      StringOffset COPYRIGHT_LICENSEOffset = default(StringOffset),
      VectorOffset LINKSOffset = default(VectorOffset),
      StringOffset TIMEOffset = default(StringOffset),
      StringOffset KEYWORDSOffset = default(StringOffset),
      double BOUNDS_MIN_LAT = 0.0,
      double BOUNDS_MIN_LON = 0.0,
      double BOUNDS_MAX_LAT = 0.0,
      double BOUNDS_MAX_LON = 0.0,
      VectorOffset WAYPOINTSOffset = default(VectorOffset),
      VectorOffset ROUTESOffset = default(VectorOffset),
      VectorOffset TRACKSOffset = default(VectorOffset)) {
    builder.StartTable(20);
    GPX.AddBOUNDS_MAX_LON(builder, BOUNDS_MAX_LON);
    GPX.AddBOUNDS_MAX_LAT(builder, BOUNDS_MAX_LAT);
    GPX.AddBOUNDS_MIN_LON(builder, BOUNDS_MIN_LON);
    GPX.AddBOUNDS_MIN_LAT(builder, BOUNDS_MIN_LAT);
    GPX.AddTRACKS(builder, TRACKSOffset);
    GPX.AddROUTES(builder, ROUTESOffset);
    GPX.AddWAYPOINTS(builder, WAYPOINTSOffset);
    GPX.AddKEYWORDS(builder, KEYWORDSOffset);
    GPX.AddTIME(builder, TIMEOffset);
    GPX.AddLINKS(builder, LINKSOffset);
    GPX.AddCOPYRIGHT_LICENSE(builder, COPYRIGHT_LICENSEOffset);
    GPX.AddCOPYRIGHT_YEAR(builder, COPYRIGHT_YEAROffset);
    GPX.AddCOPYRIGHT_AUTHOR(builder, COPYRIGHT_AUTHOROffset);
    GPX.AddAUTHOR_LINK(builder, AUTHOR_LINKOffset);
    GPX.AddAUTHOR_EMAIL(builder, AUTHOR_EMAILOffset);
    GPX.AddAUTHOR_NAME(builder, AUTHOR_NAMEOffset);
    GPX.AddDESCRIPTION(builder, DESCRIPTIONOffset);
    GPX.AddNAME(builder, NAMEOffset);
    GPX.AddCREATOR(builder, CREATOROffset);
    GPX.AddVERSION(builder, VERSIONOffset);
    return GPX.EndGPX(builder);
  }

  public static void StartGPX(FlatBufferBuilder builder) { builder.StartTable(20); }
  public static void AddVERSION(FlatBufferBuilder builder, StringOffset VERSIONOffset) { builder.AddOffset(0, VERSIONOffset.Value, 0); }
  public static void AddCREATOR(FlatBufferBuilder builder, StringOffset CREATOROffset) { builder.AddOffset(1, CREATOROffset.Value, 0); }
  public static void AddNAME(FlatBufferBuilder builder, StringOffset NAMEOffset) { builder.AddOffset(2, NAMEOffset.Value, 0); }
  public static void AddDESCRIPTION(FlatBufferBuilder builder, StringOffset DESCRIPTIONOffset) { builder.AddOffset(3, DESCRIPTIONOffset.Value, 0); }
  public static void AddAUTHOR_NAME(FlatBufferBuilder builder, StringOffset AUTHOR_NAMEOffset) { builder.AddOffset(4, AUTHOR_NAMEOffset.Value, 0); }
  public static void AddAUTHOR_EMAIL(FlatBufferBuilder builder, StringOffset AUTHOR_EMAILOffset) { builder.AddOffset(5, AUTHOR_EMAILOffset.Value, 0); }
  public static void AddAUTHOR_LINK(FlatBufferBuilder builder, Offset<GPXLink> AUTHOR_LINKOffset) { builder.AddOffset(6, AUTHOR_LINKOffset.Value, 0); }
  public static void AddCOPYRIGHT_AUTHOR(FlatBufferBuilder builder, StringOffset COPYRIGHT_AUTHOROffset) { builder.AddOffset(7, COPYRIGHT_AUTHOROffset.Value, 0); }
  public static void AddCOPYRIGHT_YEAR(FlatBufferBuilder builder, StringOffset COPYRIGHT_YEAROffset) { builder.AddOffset(8, COPYRIGHT_YEAROffset.Value, 0); }
  public static void AddCOPYRIGHT_LICENSE(FlatBufferBuilder builder, StringOffset COPYRIGHT_LICENSEOffset) { builder.AddOffset(9, COPYRIGHT_LICENSEOffset.Value, 0); }
  public static void AddLINKS(FlatBufferBuilder builder, VectorOffset LINKSOffset) { builder.AddOffset(10, LINKSOffset.Value, 0); }
  public static VectorOffset CreateLINKSVector(FlatBufferBuilder builder, Offset<GPXLink>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLINKSVectorBlock(FlatBufferBuilder builder, Offset<GPXLink>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLINKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<GPXLink>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLINKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<GPXLink>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLINKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTIME(FlatBufferBuilder builder, StringOffset TIMEOffset) { builder.AddOffset(11, TIMEOffset.Value, 0); }
  public static void AddKEYWORDS(FlatBufferBuilder builder, StringOffset KEYWORDSOffset) { builder.AddOffset(12, KEYWORDSOffset.Value, 0); }
  public static void AddBOUNDS_MIN_LAT(FlatBufferBuilder builder, double BOUNDS_MIN_LAT) { builder.AddDouble(13, BOUNDS_MIN_LAT, 0.0); }
  public static void AddBOUNDS_MIN_LON(FlatBufferBuilder builder, double BOUNDS_MIN_LON) { builder.AddDouble(14, BOUNDS_MIN_LON, 0.0); }
  public static void AddBOUNDS_MAX_LAT(FlatBufferBuilder builder, double BOUNDS_MAX_LAT) { builder.AddDouble(15, BOUNDS_MAX_LAT, 0.0); }
  public static void AddBOUNDS_MAX_LON(FlatBufferBuilder builder, double BOUNDS_MAX_LON) { builder.AddDouble(16, BOUNDS_MAX_LON, 0.0); }
  public static void AddWAYPOINTS(FlatBufferBuilder builder, VectorOffset WAYPOINTSOffset) { builder.AddOffset(17, WAYPOINTSOffset.Value, 0); }
  public static VectorOffset CreateWAYPOINTSVector(FlatBufferBuilder builder, Offset<GPXWaypoint>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateWAYPOINTSVectorBlock(FlatBufferBuilder builder, Offset<GPXWaypoint>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWAYPOINTSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<GPXWaypoint>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateWAYPOINTSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<GPXWaypoint>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartWAYPOINTSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddROUTES(FlatBufferBuilder builder, VectorOffset ROUTESOffset) { builder.AddOffset(18, ROUTESOffset.Value, 0); }
  public static VectorOffset CreateROUTESVector(FlatBufferBuilder builder, Offset<GPXRoute>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateROUTESVectorBlock(FlatBufferBuilder builder, Offset<GPXRoute>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateROUTESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<GPXRoute>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateROUTESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<GPXRoute>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartROUTESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTRACKS(FlatBufferBuilder builder, VectorOffset TRACKSOffset) { builder.AddOffset(19, TRACKSOffset.Value, 0); }
  public static VectorOffset CreateTRACKSVector(FlatBufferBuilder builder, Offset<GPXTrack>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTRACKSVectorBlock(FlatBufferBuilder builder, Offset<GPXTrack>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTRACKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<GPXTrack>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTRACKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<GPXTrack>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTRACKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<GPX> EndGPX(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<GPX>(o);
  }
  public static void FinishGPXBuffer(FlatBufferBuilder builder, Offset<GPX> offset) { builder.Finish(offset.Value, "$GPX"); }
  public static void FinishSizePrefixedGPXBuffer(FlatBufferBuilder builder, Offset<GPX> offset) { builder.FinishSizePrefixed(offset.Value, "$GPX"); }
  public GPXT UnPack() {
    var _o = new GPXT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(GPXT _o) {
    _o.VERSION = this.VERSION;
    _o.CREATOR = this.CREATOR;
    _o.NAME = this.NAME;
    _o.DESCRIPTION = this.DESCRIPTION;
    _o.AUTHOR_NAME = this.AUTHOR_NAME;
    _o.AUTHOR_EMAIL = this.AUTHOR_EMAIL;
    _o.AUTHOR_LINK = this.AUTHOR_LINK.HasValue ? this.AUTHOR_LINK.Value.UnPack() : null;
    _o.COPYRIGHT_AUTHOR = this.COPYRIGHT_AUTHOR;
    _o.COPYRIGHT_YEAR = this.COPYRIGHT_YEAR;
    _o.COPYRIGHT_LICENSE = this.COPYRIGHT_LICENSE;
    _o.LINKS = new List<GPXLinkT>();
    for (var _j = 0; _j < this.LINKSLength; ++_j) {_o.LINKS.Add(this.LINKS(_j).HasValue ? this.LINKS(_j).Value.UnPack() : null);}
    _o.TIME = this.TIME;
    _o.KEYWORDS = this.KEYWORDS;
    _o.BOUNDS_MIN_LAT = this.BOUNDS_MIN_LAT;
    _o.BOUNDS_MIN_LON = this.BOUNDS_MIN_LON;
    _o.BOUNDS_MAX_LAT = this.BOUNDS_MAX_LAT;
    _o.BOUNDS_MAX_LON = this.BOUNDS_MAX_LON;
    _o.WAYPOINTS = new List<GPXWaypointT>();
    for (var _j = 0; _j < this.WAYPOINTSLength; ++_j) {_o.WAYPOINTS.Add(this.WAYPOINTS(_j).HasValue ? this.WAYPOINTS(_j).Value.UnPack() : null);}
    _o.ROUTES = new List<GPXRouteT>();
    for (var _j = 0; _j < this.ROUTESLength; ++_j) {_o.ROUTES.Add(this.ROUTES(_j).HasValue ? this.ROUTES(_j).Value.UnPack() : null);}
    _o.TRACKS = new List<GPXTrackT>();
    for (var _j = 0; _j < this.TRACKSLength; ++_j) {_o.TRACKS.Add(this.TRACKS(_j).HasValue ? this.TRACKS(_j).Value.UnPack() : null);}
  }
  public static Offset<GPX> Pack(FlatBufferBuilder builder, GPXT _o) {
    if (_o == null) return default(Offset<GPX>);
    var _VERSION = _o.VERSION == null ? default(StringOffset) : builder.CreateString(_o.VERSION);
    var _CREATOR = _o.CREATOR == null ? default(StringOffset) : builder.CreateString(_o.CREATOR);
    var _NAME = _o.NAME == null ? default(StringOffset) : builder.CreateString(_o.NAME);
    var _DESCRIPTION = _o.DESCRIPTION == null ? default(StringOffset) : builder.CreateString(_o.DESCRIPTION);
    var _AUTHOR_NAME = _o.AUTHOR_NAME == null ? default(StringOffset) : builder.CreateString(_o.AUTHOR_NAME);
    var _AUTHOR_EMAIL = _o.AUTHOR_EMAIL == null ? default(StringOffset) : builder.CreateString(_o.AUTHOR_EMAIL);
    var _AUTHOR_LINK = _o.AUTHOR_LINK == null ? default(Offset<GPXLink>) : GPXLink.Pack(builder, _o.AUTHOR_LINK);
    var _COPYRIGHT_AUTHOR = _o.COPYRIGHT_AUTHOR == null ? default(StringOffset) : builder.CreateString(_o.COPYRIGHT_AUTHOR);
    var _COPYRIGHT_YEAR = _o.COPYRIGHT_YEAR == null ? default(StringOffset) : builder.CreateString(_o.COPYRIGHT_YEAR);
    var _COPYRIGHT_LICENSE = _o.COPYRIGHT_LICENSE == null ? default(StringOffset) : builder.CreateString(_o.COPYRIGHT_LICENSE);
    var _LINKS = default(VectorOffset);
    if (_o.LINKS != null) {
      var __LINKS = new Offset<GPXLink>[_o.LINKS.Count];
      for (var _j = 0; _j < __LINKS.Length; ++_j) { __LINKS[_j] = GPXLink.Pack(builder, _o.LINKS[_j]); }
      _LINKS = CreateLINKSVector(builder, __LINKS);
    }
    var _TIME = _o.TIME == null ? default(StringOffset) : builder.CreateString(_o.TIME);
    var _KEYWORDS = _o.KEYWORDS == null ? default(StringOffset) : builder.CreateString(_o.KEYWORDS);
    var _WAYPOINTS = default(VectorOffset);
    if (_o.WAYPOINTS != null) {
      var __WAYPOINTS = new Offset<GPXWaypoint>[_o.WAYPOINTS.Count];
      for (var _j = 0; _j < __WAYPOINTS.Length; ++_j) { __WAYPOINTS[_j] = GPXWaypoint.Pack(builder, _o.WAYPOINTS[_j]); }
      _WAYPOINTS = CreateWAYPOINTSVector(builder, __WAYPOINTS);
    }
    var _ROUTES = default(VectorOffset);
    if (_o.ROUTES != null) {
      var __ROUTES = new Offset<GPXRoute>[_o.ROUTES.Count];
      for (var _j = 0; _j < __ROUTES.Length; ++_j) { __ROUTES[_j] = GPXRoute.Pack(builder, _o.ROUTES[_j]); }
      _ROUTES = CreateROUTESVector(builder, __ROUTES);
    }
    var _TRACKS = default(VectorOffset);
    if (_o.TRACKS != null) {
      var __TRACKS = new Offset<GPXTrack>[_o.TRACKS.Count];
      for (var _j = 0; _j < __TRACKS.Length; ++_j) { __TRACKS[_j] = GPXTrack.Pack(builder, _o.TRACKS[_j]); }
      _TRACKS = CreateTRACKSVector(builder, __TRACKS);
    }
    return CreateGPX(
      builder,
      _VERSION,
      _CREATOR,
      _NAME,
      _DESCRIPTION,
      _AUTHOR_NAME,
      _AUTHOR_EMAIL,
      _AUTHOR_LINK,
      _COPYRIGHT_AUTHOR,
      _COPYRIGHT_YEAR,
      _COPYRIGHT_LICENSE,
      _LINKS,
      _TIME,
      _KEYWORDS,
      _o.BOUNDS_MIN_LAT,
      _o.BOUNDS_MIN_LON,
      _o.BOUNDS_MAX_LAT,
      _o.BOUNDS_MAX_LON,
      _WAYPOINTS,
      _ROUTES,
      _TRACKS);
  }
}

public class GPXT
{
  public string VERSION { get; set; }
  public string CREATOR { get; set; }
  public string NAME { get; set; }
  public string DESCRIPTION { get; set; }
  public string AUTHOR_NAME { get; set; }
  public string AUTHOR_EMAIL { get; set; }
  public GPXLinkT AUTHOR_LINK { get; set; }
  public string COPYRIGHT_AUTHOR { get; set; }
  public string COPYRIGHT_YEAR { get; set; }
  public string COPYRIGHT_LICENSE { get; set; }
  public List<GPXLinkT> LINKS { get; set; }
  public string TIME { get; set; }
  public string KEYWORDS { get; set; }
  public double BOUNDS_MIN_LAT { get; set; }
  public double BOUNDS_MIN_LON { get; set; }
  public double BOUNDS_MAX_LAT { get; set; }
  public double BOUNDS_MAX_LON { get; set; }
  public List<GPXWaypointT> WAYPOINTS { get; set; }
  public List<GPXRouteT> ROUTES { get; set; }
  public List<GPXTrackT> TRACKS { get; set; }

  public GPXT() {
    this.VERSION = null;
    this.CREATOR = null;
    this.NAME = null;
    this.DESCRIPTION = null;
    this.AUTHOR_NAME = null;
    this.AUTHOR_EMAIL = null;
    this.AUTHOR_LINK = null;
    this.COPYRIGHT_AUTHOR = null;
    this.COPYRIGHT_YEAR = null;
    this.COPYRIGHT_LICENSE = null;
    this.LINKS = null;
    this.TIME = null;
    this.KEYWORDS = null;
    this.BOUNDS_MIN_LAT = 0.0;
    this.BOUNDS_MIN_LON = 0.0;
    this.BOUNDS_MAX_LAT = 0.0;
    this.BOUNDS_MAX_LON = 0.0;
    this.WAYPOINTS = null;
    this.ROUTES = null;
    this.TRACKS = null;
  }
  public static GPXT DeserializeFromBinary(byte[] fbBuffer) {
    return GPX.GetRootAsGPX(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    GPX.FinishGPXBuffer(fbb, GPX.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class GPXVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*VERSION*/, false)
      && verifier.VerifyString(tablePos, 6 /*CREATOR*/, false)
      && verifier.VerifyString(tablePos, 8 /*NAME*/, false)
      && verifier.VerifyString(tablePos, 10 /*DESCRIPTION*/, false)
      && verifier.VerifyString(tablePos, 12 /*AUTHOR_NAME*/, false)
      && verifier.VerifyString(tablePos, 14 /*AUTHOR_EMAIL*/, false)
      && verifier.VerifyTable(tablePos, 16 /*AUTHOR_LINK*/, GPXLinkVerify.Verify, false)
      && verifier.VerifyString(tablePos, 18 /*COPYRIGHT_AUTHOR*/, false)
      && verifier.VerifyString(tablePos, 20 /*COPYRIGHT_YEAR*/, false)
      && verifier.VerifyString(tablePos, 22 /*COPYRIGHT_LICENSE*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 24 /*LINKS*/, GPXLinkVerify.Verify, false)
      && verifier.VerifyString(tablePos, 26 /*TIME*/, false)
      && verifier.VerifyString(tablePos, 28 /*KEYWORDS*/, false)
      && verifier.VerifyField(tablePos, 30 /*BOUNDS_MIN_LAT*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 32 /*BOUNDS_MIN_LON*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 34 /*BOUNDS_MAX_LAT*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 36 /*BOUNDS_MAX_LON*/, 8 /*double*/, 8, false)
      && verifier.VerifyVectorOfTables(tablePos, 38 /*WAYPOINTS*/, GPXWaypointVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 40 /*ROUTES*/, GPXRouteVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 42 /*TRACKS*/, GPXTrackVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
