// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Analytic Imagery Product
public struct ANI : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static ANI GetRootAsANI(ByteBuffer _bb) { return GetRootAsANI(_bb, new ANI()); }
  public static ANI GetRootAsANI(ByteBuffer _bb, ANI obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool ANIBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$ANI"); }
  public static bool VerifyANI(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$ANI", false, ANIVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ANI __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier
  public string ID { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIDBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetIDBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetIDArray() { return __p.__vector_as_array<byte>(4); }
  /// Reference to source imagery (e.g., SKI, GDI, EOO)
  public string SOURCE_ID { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSOURCE_IDBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetSOURCE_IDBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetSOURCE_IDArray() { return __p.__vector_as_array<byte>(6); }
  /// Source imagery type
  public string SOURCE_TYPE { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSOURCE_TYPEBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetSOURCE_TYPEBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetSOURCE_TYPEArray() { return __p.__vector_as_array<byte>(8); }
  /// Analytic product type
  public analyticType ANALYTIC_TYPE { get { int o = __p.__offset(10); return o != 0 ? (analyticType)__p.bb.GetSbyte(o + __p.bb_pos) : analyticType.SPECTRAL; } }
  /// Processing algorithm or pipeline name
  public string ALGORITHM { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetALGORITHMBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetALGORITHMBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetALGORITHMArray() { return __p.__vector_as_array<byte>(12); }
  /// Algorithm version
  public string ALGORITHM_VERSION { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetALGORITHM_VERSIONBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetALGORITHM_VERSIONBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetALGORITHM_VERSIONArray() { return __p.__vector_as_array<byte>(14); }
  /// Processing epoch (ISO 8601)
  public string PROCESSING_TIME { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPROCESSING_TIMEBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetPROCESSING_TIMEBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetPROCESSING_TIMEArray() { return __p.__vector_as_array<byte>(16); }
  /// Original observation epoch (ISO 8601)
  public string OBS_TIME { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOBS_TIMEBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetOBS_TIMEBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetOBS_TIMEArray() { return __p.__vector_as_array<byte>(18); }
  /// Target satellite number (if applicable)
  public uint SAT_NO { get { int o = __p.__offset(20); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// Target object designator
  public string OBJECT_DESIGNATOR { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetOBJECT_DESIGNATORBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetOBJECT_DESIGNATORBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetOBJECT_DESIGNATORArray() { return __p.__vector_as_array<byte>(22); }
  /// Center right ascension in degrees
  public double RA { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Center declination in degrees
  public double DEC { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Field of view in degrees
  public double FOV { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Visual magnitude estimate
  public double VISUAL_MAG { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Magnitude uncertainty
  public double MAG_UNCERTAINTY { get { int o = __p.__offset(32); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Detected object count
  public uint OBJECT_COUNT { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  /// Classification labels
  public string LABELS(int j) { int o = __p.__offset(36); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int LABELSLength { get { int o = __p.__offset(36); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Classification confidence scores (0.0-1.0)
  public double CONFIDENCE(int j) { int o = __p.__offset(38); return o != 0 ? __p.bb.GetDouble(__p.__vector(o) + j * 8) : (double)0; }
  public int CONFIDENCELength { get { int o = __p.__offset(38); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<double> GetCONFIDENCEBytes() { return __p.__vector_as_span<double>(38, 8); }
#else
  public ArraySegment<byte>? GetCONFIDENCEBytes() { return __p.__vector_as_arraysegment(38); }
#endif
  public double[] GetCONFIDENCEArray() { return __p.__vector_as_array<double>(38); }
  /// Feature vector or extracted parameters
  public double FEATURES(int j) { int o = __p.__offset(40); return o != 0 ? __p.bb.GetDouble(__p.__vector(o) + j * 8) : (double)0; }
  public int FEATURESLength { get { int o = __p.__offset(40); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<double> GetFEATURESBytes() { return __p.__vector_as_span<double>(40, 8); }
#else
  public ArraySegment<byte>? GetFEATURESBytes() { return __p.__vector_as_arraysegment(40); }
#endif
  public double[] GetFEATURESArray() { return __p.__vector_as_array<double>(40); }
  /// Quality score (0.0-1.0)
  public double QUALITY { get { int o = __p.__offset(42); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  /// Additional notes
  public string NOTES { get { int o = __p.__offset(44); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNOTESBytes() { return __p.__vector_as_span<byte>(44, 1); }
#else
  public ArraySegment<byte>? GetNOTESBytes() { return __p.__vector_as_arraysegment(44); }
#endif
  public byte[] GetNOTESArray() { return __p.__vector_as_array<byte>(44); }

  public static Offset<ANI> CreateANI(FlatBufferBuilder builder,
      StringOffset IDOffset = default(StringOffset),
      StringOffset SOURCE_IDOffset = default(StringOffset),
      StringOffset SOURCE_TYPEOffset = default(StringOffset),
      analyticType ANALYTIC_TYPE = analyticType.SPECTRAL,
      StringOffset ALGORITHMOffset = default(StringOffset),
      StringOffset ALGORITHM_VERSIONOffset = default(StringOffset),
      StringOffset PROCESSING_TIMEOffset = default(StringOffset),
      StringOffset OBS_TIMEOffset = default(StringOffset),
      uint SAT_NO = 0,
      StringOffset OBJECT_DESIGNATOROffset = default(StringOffset),
      double RA = 0.0,
      double DEC = 0.0,
      double FOV = 0.0,
      double VISUAL_MAG = 0.0,
      double MAG_UNCERTAINTY = 0.0,
      uint OBJECT_COUNT = 0,
      VectorOffset LABELSOffset = default(VectorOffset),
      VectorOffset CONFIDENCEOffset = default(VectorOffset),
      VectorOffset FEATURESOffset = default(VectorOffset),
      double QUALITY = 0.0,
      StringOffset NOTESOffset = default(StringOffset)) {
    builder.StartTable(21);
    ANI.AddQUALITY(builder, QUALITY);
    ANI.AddMAG_UNCERTAINTY(builder, MAG_UNCERTAINTY);
    ANI.AddVISUAL_MAG(builder, VISUAL_MAG);
    ANI.AddFOV(builder, FOV);
    ANI.AddDEC(builder, DEC);
    ANI.AddRA(builder, RA);
    ANI.AddNOTES(builder, NOTESOffset);
    ANI.AddFEATURES(builder, FEATURESOffset);
    ANI.AddCONFIDENCE(builder, CONFIDENCEOffset);
    ANI.AddLABELS(builder, LABELSOffset);
    ANI.AddOBJECT_COUNT(builder, OBJECT_COUNT);
    ANI.AddOBJECT_DESIGNATOR(builder, OBJECT_DESIGNATOROffset);
    ANI.AddSAT_NO(builder, SAT_NO);
    ANI.AddOBS_TIME(builder, OBS_TIMEOffset);
    ANI.AddPROCESSING_TIME(builder, PROCESSING_TIMEOffset);
    ANI.AddALGORITHM_VERSION(builder, ALGORITHM_VERSIONOffset);
    ANI.AddALGORITHM(builder, ALGORITHMOffset);
    ANI.AddSOURCE_TYPE(builder, SOURCE_TYPEOffset);
    ANI.AddSOURCE_ID(builder, SOURCE_IDOffset);
    ANI.AddID(builder, IDOffset);
    ANI.AddANALYTIC_TYPE(builder, ANALYTIC_TYPE);
    return ANI.EndANI(builder);
  }

  public static void StartANI(FlatBufferBuilder builder) { builder.StartTable(21); }
  public static void AddID(FlatBufferBuilder builder, StringOffset IDOffset) { builder.AddOffset(0, IDOffset.Value, 0); }
  public static void AddSOURCE_ID(FlatBufferBuilder builder, StringOffset SOURCE_IDOffset) { builder.AddOffset(1, SOURCE_IDOffset.Value, 0); }
  public static void AddSOURCE_TYPE(FlatBufferBuilder builder, StringOffset SOURCE_TYPEOffset) { builder.AddOffset(2, SOURCE_TYPEOffset.Value, 0); }
  public static void AddANALYTIC_TYPE(FlatBufferBuilder builder, analyticType ANALYTIC_TYPE) { builder.AddSbyte(3, (sbyte)ANALYTIC_TYPE, 0); }
  public static void AddALGORITHM(FlatBufferBuilder builder, StringOffset ALGORITHMOffset) { builder.AddOffset(4, ALGORITHMOffset.Value, 0); }
  public static void AddALGORITHM_VERSION(FlatBufferBuilder builder, StringOffset ALGORITHM_VERSIONOffset) { builder.AddOffset(5, ALGORITHM_VERSIONOffset.Value, 0); }
  public static void AddPROCESSING_TIME(FlatBufferBuilder builder, StringOffset PROCESSING_TIMEOffset) { builder.AddOffset(6, PROCESSING_TIMEOffset.Value, 0); }
  public static void AddOBS_TIME(FlatBufferBuilder builder, StringOffset OBS_TIMEOffset) { builder.AddOffset(7, OBS_TIMEOffset.Value, 0); }
  public static void AddSAT_NO(FlatBufferBuilder builder, uint SAT_NO) { builder.AddUint(8, SAT_NO, 0); }
  public static void AddOBJECT_DESIGNATOR(FlatBufferBuilder builder, StringOffset OBJECT_DESIGNATOROffset) { builder.AddOffset(9, OBJECT_DESIGNATOROffset.Value, 0); }
  public static void AddRA(FlatBufferBuilder builder, double RA) { builder.AddDouble(10, RA, 0.0); }
  public static void AddDEC(FlatBufferBuilder builder, double DEC) { builder.AddDouble(11, DEC, 0.0); }
  public static void AddFOV(FlatBufferBuilder builder, double FOV) { builder.AddDouble(12, FOV, 0.0); }
  public static void AddVISUAL_MAG(FlatBufferBuilder builder, double VISUAL_MAG) { builder.AddDouble(13, VISUAL_MAG, 0.0); }
  public static void AddMAG_UNCERTAINTY(FlatBufferBuilder builder, double MAG_UNCERTAINTY) { builder.AddDouble(14, MAG_UNCERTAINTY, 0.0); }
  public static void AddOBJECT_COUNT(FlatBufferBuilder builder, uint OBJECT_COUNT) { builder.AddUint(15, OBJECT_COUNT, 0); }
  public static void AddLABELS(FlatBufferBuilder builder, VectorOffset LABELSOffset) { builder.AddOffset(16, LABELSOffset.Value, 0); }
  public static VectorOffset CreateLABELSVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLABELSVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLABELSVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLABELSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLABELSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCONFIDENCE(FlatBufferBuilder builder, VectorOffset CONFIDENCEOffset) { builder.AddOffset(17, CONFIDENCEOffset.Value, 0); }
  public static VectorOffset CreateCONFIDENCEVector(FlatBufferBuilder builder, double[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddDouble(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCONFIDENCEVectorBlock(FlatBufferBuilder builder, double[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCONFIDENCEVectorBlock(FlatBufferBuilder builder, ArraySegment<double> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCONFIDENCEVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<double>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCONFIDENCEVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddFEATURES(FlatBufferBuilder builder, VectorOffset FEATURESOffset) { builder.AddOffset(18, FEATURESOffset.Value, 0); }
  public static VectorOffset CreateFEATURESVector(FlatBufferBuilder builder, double[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddDouble(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateFEATURESVectorBlock(FlatBufferBuilder builder, double[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFEATURESVectorBlock(FlatBufferBuilder builder, ArraySegment<double> data) { builder.StartVector(8, data.Count, 8); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFEATURESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<double>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartFEATURESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
  public static void AddQUALITY(FlatBufferBuilder builder, double QUALITY) { builder.AddDouble(19, QUALITY, 0.0); }
  public static void AddNOTES(FlatBufferBuilder builder, StringOffset NOTESOffset) { builder.AddOffset(20, NOTESOffset.Value, 0); }
  public static Offset<ANI> EndANI(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<ANI>(o);
  }
  public static void FinishANIBuffer(FlatBufferBuilder builder, Offset<ANI> offset) { builder.Finish(offset.Value, "$ANI"); }
  public static void FinishSizePrefixedANIBuffer(FlatBufferBuilder builder, Offset<ANI> offset) { builder.FinishSizePrefixed(offset.Value, "$ANI"); }
  public ANIT UnPack() {
    var _o = new ANIT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ANIT _o) {
    _o.ID = this.ID;
    _o.SOURCE_ID = this.SOURCE_ID;
    _o.SOURCE_TYPE = this.SOURCE_TYPE;
    _o.ANALYTIC_TYPE = this.ANALYTIC_TYPE;
    _o.ALGORITHM = this.ALGORITHM;
    _o.ALGORITHM_VERSION = this.ALGORITHM_VERSION;
    _o.PROCESSING_TIME = this.PROCESSING_TIME;
    _o.OBS_TIME = this.OBS_TIME;
    _o.SAT_NO = this.SAT_NO;
    _o.OBJECT_DESIGNATOR = this.OBJECT_DESIGNATOR;
    _o.RA = this.RA;
    _o.DEC = this.DEC;
    _o.FOV = this.FOV;
    _o.VISUAL_MAG = this.VISUAL_MAG;
    _o.MAG_UNCERTAINTY = this.MAG_UNCERTAINTY;
    _o.OBJECT_COUNT = this.OBJECT_COUNT;
    _o.LABELS = new List<string>();
    for (var _j = 0; _j < this.LABELSLength; ++_j) {_o.LABELS.Add(this.LABELS(_j));}
    _o.CONFIDENCE = new List<double>();
    for (var _j = 0; _j < this.CONFIDENCELength; ++_j) {_o.CONFIDENCE.Add(this.CONFIDENCE(_j));}
    _o.FEATURES = new List<double>();
    for (var _j = 0; _j < this.FEATURESLength; ++_j) {_o.FEATURES.Add(this.FEATURES(_j));}
    _o.QUALITY = this.QUALITY;
    _o.NOTES = this.NOTES;
  }
  public static Offset<ANI> Pack(FlatBufferBuilder builder, ANIT _o) {
    if (_o == null) return default(Offset<ANI>);
    var _ID = _o.ID == null ? default(StringOffset) : builder.CreateString(_o.ID);
    var _SOURCE_ID = _o.SOURCE_ID == null ? default(StringOffset) : builder.CreateString(_o.SOURCE_ID);
    var _SOURCE_TYPE = _o.SOURCE_TYPE == null ? default(StringOffset) : builder.CreateString(_o.SOURCE_TYPE);
    var _ALGORITHM = _o.ALGORITHM == null ? default(StringOffset) : builder.CreateString(_o.ALGORITHM);
    var _ALGORITHM_VERSION = _o.ALGORITHM_VERSION == null ? default(StringOffset) : builder.CreateString(_o.ALGORITHM_VERSION);
    var _PROCESSING_TIME = _o.PROCESSING_TIME == null ? default(StringOffset) : builder.CreateString(_o.PROCESSING_TIME);
    var _OBS_TIME = _o.OBS_TIME == null ? default(StringOffset) : builder.CreateString(_o.OBS_TIME);
    var _OBJECT_DESIGNATOR = _o.OBJECT_DESIGNATOR == null ? default(StringOffset) : builder.CreateString(_o.OBJECT_DESIGNATOR);
    var _LABELS = default(VectorOffset);
    if (_o.LABELS != null) {
      var __LABELS = new StringOffset[_o.LABELS.Count];
      for (var _j = 0; _j < __LABELS.Length; ++_j) { __LABELS[_j] = builder.CreateString(_o.LABELS[_j]); }
      _LABELS = CreateLABELSVector(builder, __LABELS);
    }
    var _CONFIDENCE = default(VectorOffset);
    if (_o.CONFIDENCE != null) {
      var __CONFIDENCE = _o.CONFIDENCE.ToArray();
      _CONFIDENCE = CreateCONFIDENCEVector(builder, __CONFIDENCE);
    }
    var _FEATURES = default(VectorOffset);
    if (_o.FEATURES != null) {
      var __FEATURES = _o.FEATURES.ToArray();
      _FEATURES = CreateFEATURESVector(builder, __FEATURES);
    }
    var _NOTES = _o.NOTES == null ? default(StringOffset) : builder.CreateString(_o.NOTES);
    return CreateANI(
      builder,
      _ID,
      _SOURCE_ID,
      _SOURCE_TYPE,
      _o.ANALYTIC_TYPE,
      _ALGORITHM,
      _ALGORITHM_VERSION,
      _PROCESSING_TIME,
      _OBS_TIME,
      _o.SAT_NO,
      _OBJECT_DESIGNATOR,
      _o.RA,
      _o.DEC,
      _o.FOV,
      _o.VISUAL_MAG,
      _o.MAG_UNCERTAINTY,
      _o.OBJECT_COUNT,
      _LABELS,
      _CONFIDENCE,
      _FEATURES,
      _o.QUALITY,
      _NOTES);
  }
}

public class ANIT
{
  public string ID { get; set; }
  public string SOURCE_ID { get; set; }
  public string SOURCE_TYPE { get; set; }
  public analyticType ANALYTIC_TYPE { get; set; }
  public string ALGORITHM { get; set; }
  public string ALGORITHM_VERSION { get; set; }
  public string PROCESSING_TIME { get; set; }
  public string OBS_TIME { get; set; }
  public uint SAT_NO { get; set; }
  public string OBJECT_DESIGNATOR { get; set; }
  public double RA { get; set; }
  public double DEC { get; set; }
  public double FOV { get; set; }
  public double VISUAL_MAG { get; set; }
  public double MAG_UNCERTAINTY { get; set; }
  public uint OBJECT_COUNT { get; set; }
  public List<string> LABELS { get; set; }
  public List<double> CONFIDENCE { get; set; }
  public List<double> FEATURES { get; set; }
  public double QUALITY { get; set; }
  public string NOTES { get; set; }

  public ANIT() {
    this.ID = null;
    this.SOURCE_ID = null;
    this.SOURCE_TYPE = null;
    this.ANALYTIC_TYPE = analyticType.SPECTRAL;
    this.ALGORITHM = null;
    this.ALGORITHM_VERSION = null;
    this.PROCESSING_TIME = null;
    this.OBS_TIME = null;
    this.SAT_NO = 0;
    this.OBJECT_DESIGNATOR = null;
    this.RA = 0.0;
    this.DEC = 0.0;
    this.FOV = 0.0;
    this.VISUAL_MAG = 0.0;
    this.MAG_UNCERTAINTY = 0.0;
    this.OBJECT_COUNT = 0;
    this.LABELS = null;
    this.CONFIDENCE = null;
    this.FEATURES = null;
    this.QUALITY = 0.0;
    this.NOTES = null;
  }
  public static ANIT DeserializeFromBinary(byte[] fbBuffer) {
    return ANI.GetRootAsANI(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    ANI.FinishANIBuffer(fbb, ANI.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class ANIVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*ID*/, false)
      && verifier.VerifyString(tablePos, 6 /*SOURCE_ID*/, false)
      && verifier.VerifyString(tablePos, 8 /*SOURCE_TYPE*/, false)
      && verifier.VerifyField(tablePos, 10 /*ANALYTIC_TYPE*/, 1 /*analyticType*/, 1, false)
      && verifier.VerifyString(tablePos, 12 /*ALGORITHM*/, false)
      && verifier.VerifyString(tablePos, 14 /*ALGORITHM_VERSION*/, false)
      && verifier.VerifyString(tablePos, 16 /*PROCESSING_TIME*/, false)
      && verifier.VerifyString(tablePos, 18 /*OBS_TIME*/, false)
      && verifier.VerifyField(tablePos, 20 /*SAT_NO*/, 4 /*uint*/, 4, false)
      && verifier.VerifyString(tablePos, 22 /*OBJECT_DESIGNATOR*/, false)
      && verifier.VerifyField(tablePos, 24 /*RA*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 26 /*DEC*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 28 /*FOV*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 30 /*VISUAL_MAG*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 32 /*MAG_UNCERTAINTY*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 34 /*OBJECT_COUNT*/, 4 /*uint*/, 4, false)
      && verifier.VerifyVectorOfStrings(tablePos, 36 /*LABELS*/, false)
      && verifier.VerifyVectorOfData(tablePos, 38 /*CONFIDENCE*/, 8 /*double*/, false)
      && verifier.VerifyVectorOfData(tablePos, 40 /*FEATURES*/, 8 /*double*/, false)
      && verifier.VerifyField(tablePos, 42 /*QUALITY*/, 8 /*double*/, 8, false)
      && verifier.VerifyString(tablePos, 44 /*NOTES*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
