// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Propagator Configuration
public struct PCF : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static PCF GetRootAsPCF(ByteBuffer _bb) { return GetRootAsPCF(_bb, new PCF()); }
  public static PCF GetRootAsPCF(ByteBuffer _bb, PCF obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool PCFBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$PCF"); }
  public static bool VerifyPCF(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$PCF", false, PCFVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PCF __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public double STEP_SIZE { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  public double TOLERANCE { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  public double MIN_STEP { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  public double MAX_STEP { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetDouble(o + __p.bb_pos) : (double)0.0; } }
  public uint MAX_ITERATIONS { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public ushort GRAVITY_DEGREE { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  public ushort GRAVITY_ORDER { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  public byte INTEGRATOR { get { int o = __p.__offset(18); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  public byte OUTPUT_FRAME { get { int o = __p.__offset(20); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  public ushort FORCE_FLAGS { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  public float DRAG_COEFFICIENT { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float SRP_COEFFICIENT { get { int o = __p.__offset(26); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float AREA_MASS_RATIO { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public byte RESERVED(int j) { int o = __p.__offset(30); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int RESERVEDLength { get { int o = __p.__offset(30); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRESERVEDBytes() { return __p.__vector_as_span<byte>(30, 1); }
#else
  public ArraySegment<byte>? GetRESERVEDBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public byte[] GetRESERVEDArray() { return __p.__vector_as_array<byte>(30); }

  public static Offset<PCF> CreatePCF(FlatBufferBuilder builder,
      double STEP_SIZE = 0.0,
      double TOLERANCE = 0.0,
      double MIN_STEP = 0.0,
      double MAX_STEP = 0.0,
      uint MAX_ITERATIONS = 0,
      ushort GRAVITY_DEGREE = 0,
      ushort GRAVITY_ORDER = 0,
      byte INTEGRATOR = 0,
      byte OUTPUT_FRAME = 0,
      ushort FORCE_FLAGS = 0,
      float DRAG_COEFFICIENT = 0.0f,
      float SRP_COEFFICIENT = 0.0f,
      float AREA_MASS_RATIO = 0.0f,
      VectorOffset RESERVEDOffset = default(VectorOffset)) {
    builder.StartTable(14);
    PCF.AddMAX_STEP(builder, MAX_STEP);
    PCF.AddMIN_STEP(builder, MIN_STEP);
    PCF.AddTOLERANCE(builder, TOLERANCE);
    PCF.AddSTEP_SIZE(builder, STEP_SIZE);
    PCF.AddRESERVED(builder, RESERVEDOffset);
    PCF.AddAREA_MASS_RATIO(builder, AREA_MASS_RATIO);
    PCF.AddSRP_COEFFICIENT(builder, SRP_COEFFICIENT);
    PCF.AddDRAG_COEFFICIENT(builder, DRAG_COEFFICIENT);
    PCF.AddMAX_ITERATIONS(builder, MAX_ITERATIONS);
    PCF.AddFORCE_FLAGS(builder, FORCE_FLAGS);
    PCF.AddGRAVITY_ORDER(builder, GRAVITY_ORDER);
    PCF.AddGRAVITY_DEGREE(builder, GRAVITY_DEGREE);
    PCF.AddOUTPUT_FRAME(builder, OUTPUT_FRAME);
    PCF.AddINTEGRATOR(builder, INTEGRATOR);
    return PCF.EndPCF(builder);
  }

  public static void StartPCF(FlatBufferBuilder builder) { builder.StartTable(14); }
  public static void AddSTEP_SIZE(FlatBufferBuilder builder, double STEP_SIZE) { builder.AddDouble(0, STEP_SIZE, 0.0); }
  public static void AddTOLERANCE(FlatBufferBuilder builder, double TOLERANCE) { builder.AddDouble(1, TOLERANCE, 0.0); }
  public static void AddMIN_STEP(FlatBufferBuilder builder, double MIN_STEP) { builder.AddDouble(2, MIN_STEP, 0.0); }
  public static void AddMAX_STEP(FlatBufferBuilder builder, double MAX_STEP) { builder.AddDouble(3, MAX_STEP, 0.0); }
  public static void AddMAX_ITERATIONS(FlatBufferBuilder builder, uint MAX_ITERATIONS) { builder.AddUint(4, MAX_ITERATIONS, 0); }
  public static void AddGRAVITY_DEGREE(FlatBufferBuilder builder, ushort GRAVITY_DEGREE) { builder.AddUshort(5, GRAVITY_DEGREE, 0); }
  public static void AddGRAVITY_ORDER(FlatBufferBuilder builder, ushort GRAVITY_ORDER) { builder.AddUshort(6, GRAVITY_ORDER, 0); }
  public static void AddINTEGRATOR(FlatBufferBuilder builder, byte INTEGRATOR) { builder.AddByte(7, INTEGRATOR, 0); }
  public static void AddOUTPUT_FRAME(FlatBufferBuilder builder, byte OUTPUT_FRAME) { builder.AddByte(8, OUTPUT_FRAME, 0); }
  public static void AddFORCE_FLAGS(FlatBufferBuilder builder, ushort FORCE_FLAGS) { builder.AddUshort(9, FORCE_FLAGS, 0); }
  public static void AddDRAG_COEFFICIENT(FlatBufferBuilder builder, float DRAG_COEFFICIENT) { builder.AddFloat(10, DRAG_COEFFICIENT, 0.0f); }
  public static void AddSRP_COEFFICIENT(FlatBufferBuilder builder, float SRP_COEFFICIENT) { builder.AddFloat(11, SRP_COEFFICIENT, 0.0f); }
  public static void AddAREA_MASS_RATIO(FlatBufferBuilder builder, float AREA_MASS_RATIO) { builder.AddFloat(12, AREA_MASS_RATIO, 0.0f); }
  public static void AddRESERVED(FlatBufferBuilder builder, VectorOffset RESERVEDOffset) { builder.AddOffset(13, RESERVEDOffset.Value, 0); }
  public static VectorOffset CreateRESERVEDVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRESERVEDVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRESERVEDVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRESERVEDVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRESERVEDVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<PCF> EndPCF(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<PCF>(o);
  }
  public static void FinishPCFBuffer(FlatBufferBuilder builder, Offset<PCF> offset) { builder.Finish(offset.Value, "$PCF"); }
  public static void FinishSizePrefixedPCFBuffer(FlatBufferBuilder builder, Offset<PCF> offset) { builder.FinishSizePrefixed(offset.Value, "$PCF"); }
  public PCFT UnPack() {
    var _o = new PCFT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PCFT _o) {
    _o.STEP_SIZE = this.STEP_SIZE;
    _o.TOLERANCE = this.TOLERANCE;
    _o.MIN_STEP = this.MIN_STEP;
    _o.MAX_STEP = this.MAX_STEP;
    _o.MAX_ITERATIONS = this.MAX_ITERATIONS;
    _o.GRAVITY_DEGREE = this.GRAVITY_DEGREE;
    _o.GRAVITY_ORDER = this.GRAVITY_ORDER;
    _o.INTEGRATOR = this.INTEGRATOR;
    _o.OUTPUT_FRAME = this.OUTPUT_FRAME;
    _o.FORCE_FLAGS = this.FORCE_FLAGS;
    _o.DRAG_COEFFICIENT = this.DRAG_COEFFICIENT;
    _o.SRP_COEFFICIENT = this.SRP_COEFFICIENT;
    _o.AREA_MASS_RATIO = this.AREA_MASS_RATIO;
    _o.RESERVED = new List<byte>();
    for (var _j = 0; _j < this.RESERVEDLength; ++_j) {_o.RESERVED.Add(this.RESERVED(_j));}
  }
  public static Offset<PCF> Pack(FlatBufferBuilder builder, PCFT _o) {
    if (_o == null) return default(Offset<PCF>);
    var _RESERVED = default(VectorOffset);
    if (_o.RESERVED != null) {
      var __RESERVED = _o.RESERVED.ToArray();
      _RESERVED = CreateRESERVEDVector(builder, __RESERVED);
    }
    return CreatePCF(
      builder,
      _o.STEP_SIZE,
      _o.TOLERANCE,
      _o.MIN_STEP,
      _o.MAX_STEP,
      _o.MAX_ITERATIONS,
      _o.GRAVITY_DEGREE,
      _o.GRAVITY_ORDER,
      _o.INTEGRATOR,
      _o.OUTPUT_FRAME,
      _o.FORCE_FLAGS,
      _o.DRAG_COEFFICIENT,
      _o.SRP_COEFFICIENT,
      _o.AREA_MASS_RATIO,
      _RESERVED);
  }
}

public class PCFT
{
  public double STEP_SIZE { get; set; }
  public double TOLERANCE { get; set; }
  public double MIN_STEP { get; set; }
  public double MAX_STEP { get; set; }
  public uint MAX_ITERATIONS { get; set; }
  public ushort GRAVITY_DEGREE { get; set; }
  public ushort GRAVITY_ORDER { get; set; }
  public byte INTEGRATOR { get; set; }
  public byte OUTPUT_FRAME { get; set; }
  public ushort FORCE_FLAGS { get; set; }
  public float DRAG_COEFFICIENT { get; set; }
  public float SRP_COEFFICIENT { get; set; }
  public float AREA_MASS_RATIO { get; set; }
  public List<byte> RESERVED { get; set; }

  public PCFT() {
    this.STEP_SIZE = 0.0;
    this.TOLERANCE = 0.0;
    this.MIN_STEP = 0.0;
    this.MAX_STEP = 0.0;
    this.MAX_ITERATIONS = 0;
    this.GRAVITY_DEGREE = 0;
    this.GRAVITY_ORDER = 0;
    this.INTEGRATOR = 0;
    this.OUTPUT_FRAME = 0;
    this.FORCE_FLAGS = 0;
    this.DRAG_COEFFICIENT = 0.0f;
    this.SRP_COEFFICIENT = 0.0f;
    this.AREA_MASS_RATIO = 0.0f;
    this.RESERVED = null;
  }
  public static PCFT DeserializeFromBinary(byte[] fbBuffer) {
    return PCF.GetRootAsPCF(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    PCF.FinishPCFBuffer(fbb, PCF.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class PCFVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*STEP_SIZE*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 6 /*TOLERANCE*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 8 /*MIN_STEP*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 10 /*MAX_STEP*/, 8 /*double*/, 8, false)
      && verifier.VerifyField(tablePos, 12 /*MAX_ITERATIONS*/, 4 /*uint*/, 4, false)
      && verifier.VerifyField(tablePos, 14 /*GRAVITY_DEGREE*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 16 /*GRAVITY_ORDER*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 18 /*INTEGRATOR*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*OUTPUT_FRAME*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*FORCE_FLAGS*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 24 /*DRAG_COEFFICIENT*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 26 /*SRP_COEFFICIENT*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 28 /*AREA_MASS_RATIO*/, 4 /*float*/, 4, false)
      && verifier.VerifyVectorOfData(tablePos, 30 /*RESERVED*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
