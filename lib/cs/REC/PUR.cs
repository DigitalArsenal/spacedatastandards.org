// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Purchase Request - Request to purchase data from a storefront listing
public struct PUR : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static PUR GetRootAsPUR(ByteBuffer _bb) { return GetRootAsPUR(_bb, new PUR()); }
  public static PUR GetRootAsPUR(ByteBuffer _bb, PUR obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool PURBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$PUR"); }
  public static bool VerifyPUR(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$PUR", false, PURVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PUR __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier for this purchase request
  public string REQUEST_ID { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetREQUEST_IDBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetREQUEST_IDBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetREQUEST_IDArray() { return __p.__vector_as_array<byte>(4); }
  /// ID of the listing being purchased
  public string LISTING_ID { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLISTING_IDBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetLISTING_IDBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetLISTING_IDArray() { return __p.__vector_as_array<byte>(6); }
  /// Name of the pricing tier selected
  public string TIER_NAME { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTIER_NAMEBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetTIER_NAMEBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetTIER_NAMEArray() { return __p.__vector_as_array<byte>(8); }
  /// Peer ID of the buyer
  public string BUYER_PEER_ID { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBUYER_PEER_IDBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetBUYER_PEER_IDBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetBUYER_PEER_IDArray() { return __p.__vector_as_array<byte>(10); }
  /// Buyer's encryption public key for encrypted delivery
  public byte BUYER_ENCRYPTION_PUBKEY(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int BUYER_ENCRYPTION_PUBKEYLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBUYER_ENCRYPTION_PUBKEYBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetBUYER_ENCRYPTION_PUBKEYBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetBUYER_ENCRYPTION_PUBKEYArray() { return __p.__vector_as_array<byte>(12); }
  /// Payment method used
  public paymentMethod PAYMENT_METHOD { get { int o = __p.__offset(14); return o != 0 ? (paymentMethod)__p.bb.GetSbyte(o + __p.bb_pos) : paymentMethod.Crypto_ETH; } }
  /// Payment amount in smallest unit
  public ulong PAYMENT_AMOUNT { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  /// Currency of payment
  public string PAYMENT_CURRENCY { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYMENT_CURRENCYBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetPAYMENT_CURRENCYBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetPAYMENT_CURRENCYArray() { return __p.__vector_as_array<byte>(18); }
  /// Transaction hash for cryptocurrency payments
  public string PAYMENT_TX_HASH { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYMENT_TX_HASHBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetPAYMENT_TX_HASHBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetPAYMENT_TX_HASHArray() { return __p.__vector_as_array<byte>(20); }
  /// Blockchain network: "ethereum", "solana", "bitcoin"
  public string PAYMENT_CHAIN { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYMENT_CHAINBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetPAYMENT_CHAINBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetPAYMENT_CHAINArray() { return __p.__vector_as_array<byte>(22); }
  /// Reference ID for credit/fiat payments
  public string PAYMENT_REFERENCE { get { int o = __p.__offset(24); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYMENT_REFERENCEBytes() { return __p.__vector_as_span<byte>(24, 1); }
#else
  public ArraySegment<byte>? GetPAYMENT_REFERENCEBytes() { return __p.__vector_as_arraysegment(24); }
#endif
  public byte[] GetPAYMENT_REFERENCEArray() { return __p.__vector_as_array<byte>(24); }
  /// Ed25519 signature from buyer
  public byte BUYER_SIGNATURE(int j) { int o = __p.__offset(26); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int BUYER_SIGNATURELength { get { int o = __p.__offset(26); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBUYER_SIGNATUREBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetBUYER_SIGNATUREBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetBUYER_SIGNATUREArray() { return __p.__vector_as_array<byte>(26); }
  /// Unix timestamp of the request
  public ulong TIMESTAMP { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }

  public static Offset<PUR> CreatePUR(FlatBufferBuilder builder,
      StringOffset REQUEST_IDOffset = default(StringOffset),
      StringOffset LISTING_IDOffset = default(StringOffset),
      StringOffset TIER_NAMEOffset = default(StringOffset),
      StringOffset BUYER_PEER_IDOffset = default(StringOffset),
      VectorOffset BUYER_ENCRYPTION_PUBKEYOffset = default(VectorOffset),
      paymentMethod PAYMENT_METHOD = paymentMethod.Crypto_ETH,
      ulong PAYMENT_AMOUNT = 0,
      StringOffset PAYMENT_CURRENCYOffset = default(StringOffset),
      StringOffset PAYMENT_TX_HASHOffset = default(StringOffset),
      StringOffset PAYMENT_CHAINOffset = default(StringOffset),
      StringOffset PAYMENT_REFERENCEOffset = default(StringOffset),
      VectorOffset BUYER_SIGNATUREOffset = default(VectorOffset),
      ulong TIMESTAMP = 0) {
    builder.StartTable(13);
    PUR.AddTIMESTAMP(builder, TIMESTAMP);
    PUR.AddPAYMENT_AMOUNT(builder, PAYMENT_AMOUNT);
    PUR.AddBUYER_SIGNATURE(builder, BUYER_SIGNATUREOffset);
    PUR.AddPAYMENT_REFERENCE(builder, PAYMENT_REFERENCEOffset);
    PUR.AddPAYMENT_CHAIN(builder, PAYMENT_CHAINOffset);
    PUR.AddPAYMENT_TX_HASH(builder, PAYMENT_TX_HASHOffset);
    PUR.AddPAYMENT_CURRENCY(builder, PAYMENT_CURRENCYOffset);
    PUR.AddBUYER_ENCRYPTION_PUBKEY(builder, BUYER_ENCRYPTION_PUBKEYOffset);
    PUR.AddBUYER_PEER_ID(builder, BUYER_PEER_IDOffset);
    PUR.AddTIER_NAME(builder, TIER_NAMEOffset);
    PUR.AddLISTING_ID(builder, LISTING_IDOffset);
    PUR.AddREQUEST_ID(builder, REQUEST_IDOffset);
    PUR.AddPAYMENT_METHOD(builder, PAYMENT_METHOD);
    return PUR.EndPUR(builder);
  }

  public static void StartPUR(FlatBufferBuilder builder) { builder.StartTable(13); }
  public static void AddREQUEST_ID(FlatBufferBuilder builder, StringOffset REQUEST_IDOffset) { builder.AddOffset(0, REQUEST_IDOffset.Value, 0); }
  public static void AddLISTING_ID(FlatBufferBuilder builder, StringOffset LISTING_IDOffset) { builder.AddOffset(1, LISTING_IDOffset.Value, 0); }
  public static void AddTIER_NAME(FlatBufferBuilder builder, StringOffset TIER_NAMEOffset) { builder.AddOffset(2, TIER_NAMEOffset.Value, 0); }
  public static void AddBUYER_PEER_ID(FlatBufferBuilder builder, StringOffset BUYER_PEER_IDOffset) { builder.AddOffset(3, BUYER_PEER_IDOffset.Value, 0); }
  public static void AddBUYER_ENCRYPTION_PUBKEY(FlatBufferBuilder builder, VectorOffset BUYER_ENCRYPTION_PUBKEYOffset) { builder.AddOffset(4, BUYER_ENCRYPTION_PUBKEYOffset.Value, 0); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_ENCRYPTION_PUBKEYVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBUYER_ENCRYPTION_PUBKEYVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddPAYMENT_METHOD(FlatBufferBuilder builder, paymentMethod PAYMENT_METHOD) { builder.AddSbyte(5, (sbyte)PAYMENT_METHOD, 0); }
  public static void AddPAYMENT_AMOUNT(FlatBufferBuilder builder, ulong PAYMENT_AMOUNT) { builder.AddUlong(6, PAYMENT_AMOUNT, 0); }
  public static void AddPAYMENT_CURRENCY(FlatBufferBuilder builder, StringOffset PAYMENT_CURRENCYOffset) { builder.AddOffset(7, PAYMENT_CURRENCYOffset.Value, 0); }
  public static void AddPAYMENT_TX_HASH(FlatBufferBuilder builder, StringOffset PAYMENT_TX_HASHOffset) { builder.AddOffset(8, PAYMENT_TX_HASHOffset.Value, 0); }
  public static void AddPAYMENT_CHAIN(FlatBufferBuilder builder, StringOffset PAYMENT_CHAINOffset) { builder.AddOffset(9, PAYMENT_CHAINOffset.Value, 0); }
  public static void AddPAYMENT_REFERENCE(FlatBufferBuilder builder, StringOffset PAYMENT_REFERENCEOffset) { builder.AddOffset(10, PAYMENT_REFERENCEOffset.Value, 0); }
  public static void AddBUYER_SIGNATURE(FlatBufferBuilder builder, VectorOffset BUYER_SIGNATUREOffset) { builder.AddOffset(11, BUYER_SIGNATUREOffset.Value, 0); }
  public static VectorOffset CreateBUYER_SIGNATUREVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_SIGNATUREVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_SIGNATUREVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBUYER_SIGNATUREVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBUYER_SIGNATUREVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddTIMESTAMP(FlatBufferBuilder builder, ulong TIMESTAMP) { builder.AddUlong(12, TIMESTAMP, 0); }
  public static Offset<PUR> EndPUR(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // REQUEST_ID
    builder.Required(o, 6);  // LISTING_ID
    builder.Required(o, 8);  // TIER_NAME
    builder.Required(o, 10);  // BUYER_PEER_ID
    return new Offset<PUR>(o);
  }
  public static void FinishPURBuffer(FlatBufferBuilder builder, Offset<PUR> offset) { builder.Finish(offset.Value, "$PUR"); }
  public static void FinishSizePrefixedPURBuffer(FlatBufferBuilder builder, Offset<PUR> offset) { builder.FinishSizePrefixed(offset.Value, "$PUR"); }
  public PURT UnPack() {
    var _o = new PURT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PURT _o) {
    _o.REQUEST_ID = this.REQUEST_ID;
    _o.LISTING_ID = this.LISTING_ID;
    _o.TIER_NAME = this.TIER_NAME;
    _o.BUYER_PEER_ID = this.BUYER_PEER_ID;
    _o.BUYER_ENCRYPTION_PUBKEY = new List<byte>();
    for (var _j = 0; _j < this.BUYER_ENCRYPTION_PUBKEYLength; ++_j) {_o.BUYER_ENCRYPTION_PUBKEY.Add(this.BUYER_ENCRYPTION_PUBKEY(_j));}
    _o.PAYMENT_METHOD = this.PAYMENT_METHOD;
    _o.PAYMENT_AMOUNT = this.PAYMENT_AMOUNT;
    _o.PAYMENT_CURRENCY = this.PAYMENT_CURRENCY;
    _o.PAYMENT_TX_HASH = this.PAYMENT_TX_HASH;
    _o.PAYMENT_CHAIN = this.PAYMENT_CHAIN;
    _o.PAYMENT_REFERENCE = this.PAYMENT_REFERENCE;
    _o.BUYER_SIGNATURE = new List<byte>();
    for (var _j = 0; _j < this.BUYER_SIGNATURELength; ++_j) {_o.BUYER_SIGNATURE.Add(this.BUYER_SIGNATURE(_j));}
    _o.TIMESTAMP = this.TIMESTAMP;
  }
  public static Offset<PUR> Pack(FlatBufferBuilder builder, PURT _o) {
    if (_o == null) return default(Offset<PUR>);
    var _REQUEST_ID = _o.REQUEST_ID == null ? default(StringOffset) : builder.CreateString(_o.REQUEST_ID);
    var _LISTING_ID = _o.LISTING_ID == null ? default(StringOffset) : builder.CreateString(_o.LISTING_ID);
    var _TIER_NAME = _o.TIER_NAME == null ? default(StringOffset) : builder.CreateString(_o.TIER_NAME);
    var _BUYER_PEER_ID = _o.BUYER_PEER_ID == null ? default(StringOffset) : builder.CreateString(_o.BUYER_PEER_ID);
    var _BUYER_ENCRYPTION_PUBKEY = default(VectorOffset);
    if (_o.BUYER_ENCRYPTION_PUBKEY != null) {
      var __BUYER_ENCRYPTION_PUBKEY = _o.BUYER_ENCRYPTION_PUBKEY.ToArray();
      _BUYER_ENCRYPTION_PUBKEY = CreateBUYER_ENCRYPTION_PUBKEYVector(builder, __BUYER_ENCRYPTION_PUBKEY);
    }
    var _PAYMENT_CURRENCY = _o.PAYMENT_CURRENCY == null ? default(StringOffset) : builder.CreateString(_o.PAYMENT_CURRENCY);
    var _PAYMENT_TX_HASH = _o.PAYMENT_TX_HASH == null ? default(StringOffset) : builder.CreateString(_o.PAYMENT_TX_HASH);
    var _PAYMENT_CHAIN = _o.PAYMENT_CHAIN == null ? default(StringOffset) : builder.CreateString(_o.PAYMENT_CHAIN);
    var _PAYMENT_REFERENCE = _o.PAYMENT_REFERENCE == null ? default(StringOffset) : builder.CreateString(_o.PAYMENT_REFERENCE);
    var _BUYER_SIGNATURE = default(VectorOffset);
    if (_o.BUYER_SIGNATURE != null) {
      var __BUYER_SIGNATURE = _o.BUYER_SIGNATURE.ToArray();
      _BUYER_SIGNATURE = CreateBUYER_SIGNATUREVector(builder, __BUYER_SIGNATURE);
    }
    return CreatePUR(
      builder,
      _REQUEST_ID,
      _LISTING_ID,
      _TIER_NAME,
      _BUYER_PEER_ID,
      _BUYER_ENCRYPTION_PUBKEY,
      _o.PAYMENT_METHOD,
      _o.PAYMENT_AMOUNT,
      _PAYMENT_CURRENCY,
      _PAYMENT_TX_HASH,
      _PAYMENT_CHAIN,
      _PAYMENT_REFERENCE,
      _BUYER_SIGNATURE,
      _o.TIMESTAMP);
  }
}

public class PURT
{
  public string REQUEST_ID { get; set; }
  public string LISTING_ID { get; set; }
  public string TIER_NAME { get; set; }
  public string BUYER_PEER_ID { get; set; }
  public List<byte> BUYER_ENCRYPTION_PUBKEY { get; set; }
  public paymentMethod PAYMENT_METHOD { get; set; }
  public ulong PAYMENT_AMOUNT { get; set; }
  public string PAYMENT_CURRENCY { get; set; }
  public string PAYMENT_TX_HASH { get; set; }
  public string PAYMENT_CHAIN { get; set; }
  public string PAYMENT_REFERENCE { get; set; }
  public List<byte> BUYER_SIGNATURE { get; set; }
  public ulong TIMESTAMP { get; set; }

  public PURT() {
    this.REQUEST_ID = null;
    this.LISTING_ID = null;
    this.TIER_NAME = null;
    this.BUYER_PEER_ID = null;
    this.BUYER_ENCRYPTION_PUBKEY = null;
    this.PAYMENT_METHOD = paymentMethod.Crypto_ETH;
    this.PAYMENT_AMOUNT = 0;
    this.PAYMENT_CURRENCY = null;
    this.PAYMENT_TX_HASH = null;
    this.PAYMENT_CHAIN = null;
    this.PAYMENT_REFERENCE = null;
    this.BUYER_SIGNATURE = null;
    this.TIMESTAMP = 0;
  }
  public static PURT DeserializeFromBinary(byte[] fbBuffer) {
    return PUR.GetRootAsPUR(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    PUR.FinishPURBuffer(fbb, PUR.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class PURVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*REQUEST_ID*/, true)
      && verifier.VerifyString(tablePos, 6 /*LISTING_ID*/, true)
      && verifier.VerifyString(tablePos, 8 /*TIER_NAME*/, true)
      && verifier.VerifyString(tablePos, 10 /*BUYER_PEER_ID*/, true)
      && verifier.VerifyVectorOfData(tablePos, 12 /*BUYER_ENCRYPTION_PUBKEY*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 14 /*PAYMENT_METHOD*/, 1 /*paymentMethod*/, 1, false)
      && verifier.VerifyField(tablePos, 16 /*PAYMENT_AMOUNT*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyString(tablePos, 18 /*PAYMENT_CURRENCY*/, false)
      && verifier.VerifyString(tablePos, 20 /*PAYMENT_TX_HASH*/, false)
      && verifier.VerifyString(tablePos, 22 /*PAYMENT_CHAIN*/, false)
      && verifier.VerifyString(tablePos, 24 /*PAYMENT_REFERENCE*/, false)
      && verifier.VerifyVectorOfData(tablePos, 26 /*BUYER_SIGNATURE*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 28 /*TIMESTAMP*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
