// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Storefront Listing - Data marketplace listing
public struct STF : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static STF GetRootAsSTF(ByteBuffer _bb) { return GetRootAsSTF(_bb, new STF()); }
  public static STF GetRootAsSTF(ByteBuffer _bb, STF obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool STFBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$STF"); }
  public static bool VerifySTF(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$STF", false, STFVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public STF __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Unique identifier for the listing
  public string LISTING_ID { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetLISTING_IDBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetLISTING_IDBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetLISTING_IDArray() { return __p.__vector_as_array<byte>(4); }
  /// Peer ID of the data provider
  public string PROVIDER_PEER_ID { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPROVIDER_PEER_IDBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetPROVIDER_PEER_IDBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetPROVIDER_PEER_IDArray() { return __p.__vector_as_array<byte>(6); }
  /// IPFS CID of provider's EPM (Entity Profile Message)
  public string PROVIDER_EPM_CID { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPROVIDER_EPM_CIDBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetPROVIDER_EPM_CIDBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetPROVIDER_EPM_CIDArray() { return __p.__vector_as_array<byte>(8); }
  /// Title of the data listing
  public string TITLE { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTITLEBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetTITLEBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetTITLEArray() { return __p.__vector_as_array<byte>(10); }
  /// Detailed description of the data offering
  public string DESCRIPTION { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDESCRIPTIONBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetDESCRIPTIONBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetDESCRIPTIONArray() { return __p.__vector_as_array<byte>(12); }
  /// SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
  public string DATA_TYPES(int j) { int o = __p.__offset(14); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
  public int DATA_TYPESLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Coverage information (spatial and temporal)
  public DataCoverage? COVERAGE { get { int o = __p.__offset(16); return o != 0 ? (DataCoverage?)(new DataCoverage()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// IPFS CID of sample data
  public string SAMPLE_CID { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSAMPLE_CIDBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetSAMPLE_CIDBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetSAMPLE_CIDArray() { return __p.__vector_as_array<byte>(18); }
  /// Type of access offered
  public accessType ACCESS_TYPE { get { int o = __p.__offset(20); return o != 0 ? (accessType)__p.bb.GetSbyte(o + __p.bb_pos) : accessType.OneTime; } }
  /// Whether encryption is required for data delivery
  public bool ENCRYPTION_REQUIRED { get { int o = __p.__offset(22); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Available pricing tiers
  public PricingTier? PRICING(int j) { int o = __p.__offset(24); return o != 0 ? (PricingTier?)(new PricingTier()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PRICINGLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Payment methods accepted
  public paymentMethod ACCEPTED_PAYMENTS(int j) { int o = __p.__offset(26); return o != 0 ? (paymentMethod)__p.bb.GetSbyte(__p.__vector(o) + j * 1) : (paymentMethod)0; }
  public int ACCEPTED_PAYMENTSLength { get { int o = __p.__offset(26); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<paymentMethod> GetACCEPTED_PAYMENTSBytes() { return __p.__vector_as_span<paymentMethod>(26, 1); }
#else
  public ArraySegment<byte>? GetACCEPTED_PAYMENTSBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public paymentMethod[] GetACCEPTED_PAYMENTSArray() { int o = __p.__offset(26); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); paymentMethod[] a = new paymentMethod[l]; for (int i = 0; i < l; i++) { a[i] = (paymentMethod)__p.bb.GetSbyte(p + i * 1); } return a; }
  /// Unix timestamp when listing was created
  public ulong CREATED_AT { get { int o = __p.__offset(28); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  /// Unix timestamp when listing was last updated
  public ulong UPDATED_AT { get { int o = __p.__offset(30); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }
  /// Whether the listing is currently active
  public bool ACTIVE { get { int o = __p.__offset(32); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Ed25519 signature from provider
  public byte SIGNATURE(int j) { int o = __p.__offset(34); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int SIGNATURELength { get { int o = __p.__offset(34); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSIGNATUREBytes() { return __p.__vector_as_span<byte>(34, 1); }
#else
  public ArraySegment<byte>? GetSIGNATUREBytes() { return __p.__vector_as_arraysegment(34); }
#endif
  public byte[] GetSIGNATUREArray() { return __p.__vector_as_array<byte>(34); }

  public static Offset<STF> CreateSTF(FlatBufferBuilder builder,
      StringOffset LISTING_IDOffset = default(StringOffset),
      StringOffset PROVIDER_PEER_IDOffset = default(StringOffset),
      StringOffset PROVIDER_EPM_CIDOffset = default(StringOffset),
      StringOffset TITLEOffset = default(StringOffset),
      StringOffset DESCRIPTIONOffset = default(StringOffset),
      VectorOffset DATA_TYPESOffset = default(VectorOffset),
      Offset<DataCoverage> COVERAGEOffset = default(Offset<DataCoverage>),
      StringOffset SAMPLE_CIDOffset = default(StringOffset),
      accessType ACCESS_TYPE = accessType.OneTime,
      bool ENCRYPTION_REQUIRED = false,
      VectorOffset PRICINGOffset = default(VectorOffset),
      VectorOffset ACCEPTED_PAYMENTSOffset = default(VectorOffset),
      ulong CREATED_AT = 0,
      ulong UPDATED_AT = 0,
      bool ACTIVE = false,
      VectorOffset SIGNATUREOffset = default(VectorOffset)) {
    builder.StartTable(16);
    STF.AddUPDATED_AT(builder, UPDATED_AT);
    STF.AddCREATED_AT(builder, CREATED_AT);
    STF.AddSIGNATURE(builder, SIGNATUREOffset);
    STF.AddACCEPTED_PAYMENTS(builder, ACCEPTED_PAYMENTSOffset);
    STF.AddPRICING(builder, PRICINGOffset);
    STF.AddSAMPLE_CID(builder, SAMPLE_CIDOffset);
    STF.AddCOVERAGE(builder, COVERAGEOffset);
    STF.AddDATA_TYPES(builder, DATA_TYPESOffset);
    STF.AddDESCRIPTION(builder, DESCRIPTIONOffset);
    STF.AddTITLE(builder, TITLEOffset);
    STF.AddPROVIDER_EPM_CID(builder, PROVIDER_EPM_CIDOffset);
    STF.AddPROVIDER_PEER_ID(builder, PROVIDER_PEER_IDOffset);
    STF.AddLISTING_ID(builder, LISTING_IDOffset);
    STF.AddACTIVE(builder, ACTIVE);
    STF.AddENCRYPTION_REQUIRED(builder, ENCRYPTION_REQUIRED);
    STF.AddACCESS_TYPE(builder, ACCESS_TYPE);
    return STF.EndSTF(builder);
  }

  public static void StartSTF(FlatBufferBuilder builder) { builder.StartTable(16); }
  public static void AddLISTING_ID(FlatBufferBuilder builder, StringOffset LISTING_IDOffset) { builder.AddOffset(0, LISTING_IDOffset.Value, 0); }
  public static void AddPROVIDER_PEER_ID(FlatBufferBuilder builder, StringOffset PROVIDER_PEER_IDOffset) { builder.AddOffset(1, PROVIDER_PEER_IDOffset.Value, 0); }
  public static void AddPROVIDER_EPM_CID(FlatBufferBuilder builder, StringOffset PROVIDER_EPM_CIDOffset) { builder.AddOffset(2, PROVIDER_EPM_CIDOffset.Value, 0); }
  public static void AddTITLE(FlatBufferBuilder builder, StringOffset TITLEOffset) { builder.AddOffset(3, TITLEOffset.Value, 0); }
  public static void AddDESCRIPTION(FlatBufferBuilder builder, StringOffset DESCRIPTIONOffset) { builder.AddOffset(4, DESCRIPTIONOffset.Value, 0); }
  public static void AddDATA_TYPES(FlatBufferBuilder builder, VectorOffset DATA_TYPESOffset) { builder.AddOffset(5, DATA_TYPESOffset.Value, 0); }
  public static VectorOffset CreateDATA_TYPESVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateDATA_TYPESVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDATA_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDATA_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDATA_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCOVERAGE(FlatBufferBuilder builder, Offset<DataCoverage> COVERAGEOffset) { builder.AddOffset(6, COVERAGEOffset.Value, 0); }
  public static void AddSAMPLE_CID(FlatBufferBuilder builder, StringOffset SAMPLE_CIDOffset) { builder.AddOffset(7, SAMPLE_CIDOffset.Value, 0); }
  public static void AddACCESS_TYPE(FlatBufferBuilder builder, accessType ACCESS_TYPE) { builder.AddSbyte(8, (sbyte)ACCESS_TYPE, 0); }
  public static void AddENCRYPTION_REQUIRED(FlatBufferBuilder builder, bool ENCRYPTION_REQUIRED) { builder.AddBool(9, ENCRYPTION_REQUIRED, false); }
  public static void AddPRICING(FlatBufferBuilder builder, VectorOffset PRICINGOffset) { builder.AddOffset(10, PRICINGOffset.Value, 0); }
  public static VectorOffset CreatePRICINGVector(FlatBufferBuilder builder, Offset<PricingTier>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePRICINGVectorBlock(FlatBufferBuilder builder, Offset<PricingTier>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePRICINGVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<PricingTier>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePRICINGVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<PricingTier>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPRICINGVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddACCEPTED_PAYMENTS(FlatBufferBuilder builder, VectorOffset ACCEPTED_PAYMENTSOffset) { builder.AddOffset(11, ACCEPTED_PAYMENTSOffset.Value, 0); }
  public static VectorOffset CreateACCEPTED_PAYMENTSVector(FlatBufferBuilder builder, paymentMethod[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddSbyte((sbyte)data[i]); return builder.EndVector(); }
  public static VectorOffset CreateACCEPTED_PAYMENTSVectorBlock(FlatBufferBuilder builder, paymentMethod[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateACCEPTED_PAYMENTSVectorBlock(FlatBufferBuilder builder, ArraySegment<paymentMethod> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateACCEPTED_PAYMENTSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<paymentMethod>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartACCEPTED_PAYMENTSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddCREATED_AT(FlatBufferBuilder builder, ulong CREATED_AT) { builder.AddUlong(12, CREATED_AT, 0); }
  public static void AddUPDATED_AT(FlatBufferBuilder builder, ulong UPDATED_AT) { builder.AddUlong(13, UPDATED_AT, 0); }
  public static void AddACTIVE(FlatBufferBuilder builder, bool ACTIVE) { builder.AddBool(14, ACTIVE, false); }
  public static void AddSIGNATURE(FlatBufferBuilder builder, VectorOffset SIGNATUREOffset) { builder.AddOffset(15, SIGNATUREOffset.Value, 0); }
  public static VectorOffset CreateSIGNATUREVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSIGNATUREVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSIGNATUREVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSIGNATUREVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSIGNATUREVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<STF> EndSTF(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 4);  // LISTING_ID
    builder.Required(o, 6);  // PROVIDER_PEER_ID
    builder.Required(o, 10);  // TITLE
    return new Offset<STF>(o);
  }
  public static void FinishSTFBuffer(FlatBufferBuilder builder, Offset<STF> offset) { builder.Finish(offset.Value, "$STF"); }
  public static void FinishSizePrefixedSTFBuffer(FlatBufferBuilder builder, Offset<STF> offset) { builder.FinishSizePrefixed(offset.Value, "$STF"); }
  public STFT UnPack() {
    var _o = new STFT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(STFT _o) {
    _o.LISTING_ID = this.LISTING_ID;
    _o.PROVIDER_PEER_ID = this.PROVIDER_PEER_ID;
    _o.PROVIDER_EPM_CID = this.PROVIDER_EPM_CID;
    _o.TITLE = this.TITLE;
    _o.DESCRIPTION = this.DESCRIPTION;
    _o.DATA_TYPES = new List<string>();
    for (var _j = 0; _j < this.DATA_TYPESLength; ++_j) {_o.DATA_TYPES.Add(this.DATA_TYPES(_j));}
    _o.COVERAGE = this.COVERAGE.HasValue ? this.COVERAGE.Value.UnPack() : null;
    _o.SAMPLE_CID = this.SAMPLE_CID;
    _o.ACCESS_TYPE = this.ACCESS_TYPE;
    _o.ENCRYPTION_REQUIRED = this.ENCRYPTION_REQUIRED;
    _o.PRICING = new List<PricingTierT>();
    for (var _j = 0; _j < this.PRICINGLength; ++_j) {_o.PRICING.Add(this.PRICING(_j).HasValue ? this.PRICING(_j).Value.UnPack() : null);}
    _o.ACCEPTED_PAYMENTS = new List<paymentMethod>();
    for (var _j = 0; _j < this.ACCEPTED_PAYMENTSLength; ++_j) {_o.ACCEPTED_PAYMENTS.Add(this.ACCEPTED_PAYMENTS(_j));}
    _o.CREATED_AT = this.CREATED_AT;
    _o.UPDATED_AT = this.UPDATED_AT;
    _o.ACTIVE = this.ACTIVE;
    _o.SIGNATURE = new List<byte>();
    for (var _j = 0; _j < this.SIGNATURELength; ++_j) {_o.SIGNATURE.Add(this.SIGNATURE(_j));}
  }
  public static Offset<STF> Pack(FlatBufferBuilder builder, STFT _o) {
    if (_o == null) return default(Offset<STF>);
    var _LISTING_ID = _o.LISTING_ID == null ? default(StringOffset) : builder.CreateString(_o.LISTING_ID);
    var _PROVIDER_PEER_ID = _o.PROVIDER_PEER_ID == null ? default(StringOffset) : builder.CreateString(_o.PROVIDER_PEER_ID);
    var _PROVIDER_EPM_CID = _o.PROVIDER_EPM_CID == null ? default(StringOffset) : builder.CreateString(_o.PROVIDER_EPM_CID);
    var _TITLE = _o.TITLE == null ? default(StringOffset) : builder.CreateString(_o.TITLE);
    var _DESCRIPTION = _o.DESCRIPTION == null ? default(StringOffset) : builder.CreateString(_o.DESCRIPTION);
    var _DATA_TYPES = default(VectorOffset);
    if (_o.DATA_TYPES != null) {
      var __DATA_TYPES = new StringOffset[_o.DATA_TYPES.Count];
      for (var _j = 0; _j < __DATA_TYPES.Length; ++_j) { __DATA_TYPES[_j] = builder.CreateString(_o.DATA_TYPES[_j]); }
      _DATA_TYPES = CreateDATA_TYPESVector(builder, __DATA_TYPES);
    }
    var _COVERAGE = _o.COVERAGE == null ? default(Offset<DataCoverage>) : DataCoverage.Pack(builder, _o.COVERAGE);
    var _SAMPLE_CID = _o.SAMPLE_CID == null ? default(StringOffset) : builder.CreateString(_o.SAMPLE_CID);
    var _PRICING = default(VectorOffset);
    if (_o.PRICING != null) {
      var __PRICING = new Offset<PricingTier>[_o.PRICING.Count];
      for (var _j = 0; _j < __PRICING.Length; ++_j) { __PRICING[_j] = PricingTier.Pack(builder, _o.PRICING[_j]); }
      _PRICING = CreatePRICINGVector(builder, __PRICING);
    }
    var _ACCEPTED_PAYMENTS = default(VectorOffset);
    if (_o.ACCEPTED_PAYMENTS != null) {
      var __ACCEPTED_PAYMENTS = _o.ACCEPTED_PAYMENTS.ToArray();
      _ACCEPTED_PAYMENTS = CreateACCEPTED_PAYMENTSVector(builder, __ACCEPTED_PAYMENTS);
    }
    var _SIGNATURE = default(VectorOffset);
    if (_o.SIGNATURE != null) {
      var __SIGNATURE = _o.SIGNATURE.ToArray();
      _SIGNATURE = CreateSIGNATUREVector(builder, __SIGNATURE);
    }
    return CreateSTF(
      builder,
      _LISTING_ID,
      _PROVIDER_PEER_ID,
      _PROVIDER_EPM_CID,
      _TITLE,
      _DESCRIPTION,
      _DATA_TYPES,
      _COVERAGE,
      _SAMPLE_CID,
      _o.ACCESS_TYPE,
      _o.ENCRYPTION_REQUIRED,
      _PRICING,
      _ACCEPTED_PAYMENTS,
      _o.CREATED_AT,
      _o.UPDATED_AT,
      _o.ACTIVE,
      _SIGNATURE);
  }
}

public class STFT
{
  public string LISTING_ID { get; set; }
  public string PROVIDER_PEER_ID { get; set; }
  public string PROVIDER_EPM_CID { get; set; }
  public string TITLE { get; set; }
  public string DESCRIPTION { get; set; }
  public List<string> DATA_TYPES { get; set; }
  public DataCoverageT COVERAGE { get; set; }
  public string SAMPLE_CID { get; set; }
  public accessType ACCESS_TYPE { get; set; }
  public bool ENCRYPTION_REQUIRED { get; set; }
  public List<PricingTierT> PRICING { get; set; }
  public List<paymentMethod> ACCEPTED_PAYMENTS { get; set; }
  public ulong CREATED_AT { get; set; }
  public ulong UPDATED_AT { get; set; }
  public bool ACTIVE { get; set; }
  public List<byte> SIGNATURE { get; set; }

  public STFT() {
    this.LISTING_ID = null;
    this.PROVIDER_PEER_ID = null;
    this.PROVIDER_EPM_CID = null;
    this.TITLE = null;
    this.DESCRIPTION = null;
    this.DATA_TYPES = null;
    this.COVERAGE = null;
    this.SAMPLE_CID = null;
    this.ACCESS_TYPE = accessType.OneTime;
    this.ENCRYPTION_REQUIRED = false;
    this.PRICING = null;
    this.ACCEPTED_PAYMENTS = null;
    this.CREATED_AT = 0;
    this.UPDATED_AT = 0;
    this.ACTIVE = false;
    this.SIGNATURE = null;
  }
  public static STFT DeserializeFromBinary(byte[] fbBuffer) {
    return STF.GetRootAsSTF(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    STF.FinishSTFBuffer(fbb, STF.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class STFVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*LISTING_ID*/, true)
      && verifier.VerifyString(tablePos, 6 /*PROVIDER_PEER_ID*/, true)
      && verifier.VerifyString(tablePos, 8 /*PROVIDER_EPM_CID*/, false)
      && verifier.VerifyString(tablePos, 10 /*TITLE*/, true)
      && verifier.VerifyString(tablePos, 12 /*DESCRIPTION*/, false)
      && verifier.VerifyVectorOfStrings(tablePos, 14 /*DATA_TYPES*/, false)
      && verifier.VerifyTable(tablePos, 16 /*COVERAGE*/, DataCoverageVerify.Verify, false)
      && verifier.VerifyString(tablePos, 18 /*SAMPLE_CID*/, false)
      && verifier.VerifyField(tablePos, 20 /*ACCESS_TYPE*/, 1 /*accessType*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*ENCRYPTION_REQUIRED*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 24 /*PRICING*/, PricingTierVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 26 /*ACCEPTED_PAYMENTS*/, 1 /*paymentMethod*/, false)
      && verifier.VerifyField(tablePos, 28 /*CREATED_AT*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 30 /*UPDATED_AT*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyField(tablePos, 32 /*ACTIVE*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 34 /*SIGNATURE*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
