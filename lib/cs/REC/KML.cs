// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// KML Document
public struct KML : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static KML GetRootAsKML(ByteBuffer _bb) { return GetRootAsKML(_bb, new KML()); }
  public static KML GetRootAsKML(ByteBuffer _bb, KML obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool KMLBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$KML"); }
  public static bool VerifyKML(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$KML", false, KMLVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public KML __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Document name
  public string NAME { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNAMEBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNAMEBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNAMEArray() { return __p.__vector_as_array<byte>(4); }
  /// Document description
  public string DESCRIPTION { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDESCRIPTIONBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetDESCRIPTIONBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetDESCRIPTIONArray() { return __p.__vector_as_array<byte>(6); }
  /// Whether document is visible
  public bool VISIBILITY { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Whether document is open in tree view
  public bool OPEN { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Shared styles
  public KMLStyle? STYLES(int j) { int o = __p.__offset(12); return o != 0 ? (KMLStyle?)(new KMLStyle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int STYLESLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Style maps
  public KMLStyleMap? STYLE_MAPS(int j) { int o = __p.__offset(14); return o != 0 ? (KMLStyleMap?)(new KMLStyleMap()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int STYLE_MAPSLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Top-level placemarks
  public KMLPlacemark? PLACEMARKS(int j) { int o = __p.__offset(16); return o != 0 ? (KMLPlacemark?)(new KMLPlacemark()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PLACEMARKSLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Top-level folders
  public KMLFolder? FOLDERS(int j) { int o = __p.__offset(18); return o != 0 ? (KMLFolder?)(new KMLFolder()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FOLDERSLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Network links
  public KMLNetworkLink? NETWORK_LINKS(int j) { int o = __p.__offset(20); return o != 0 ? (KMLNetworkLink?)(new KMLNetworkLink()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int NETWORK_LINKSLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Ground overlays
  public KMLGroundOverlay? GROUND_OVERLAYS(int j) { int o = __p.__offset(22); return o != 0 ? (KMLGroundOverlay?)(new KMLGroundOverlay()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int GROUND_OVERLAYSLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Schemas
  public KMLSchema? SCHEMAS(int j) { int o = __p.__offset(24); return o != 0 ? (KMLSchema?)(new KMLSchema()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SCHEMASLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Screen overlays
  public KMLScreenOverlay? SCREEN_OVERLAYS(int j) { int o = __p.__offset(26); return o != 0 ? (KMLScreenOverlay?)(new KMLScreenOverlay()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SCREEN_OVERLAYSLength { get { int o = __p.__offset(26); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Photo overlays
  public KMLPhotoOverlay? PHOTO_OVERLAYS(int j) { int o = __p.__offset(28); return o != 0 ? (KMLPhotoOverlay?)(new KMLPhotoOverlay()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PHOTO_OVERLAYSLength { get { int o = __p.__offset(28); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Tours
  public KMLTour? TOURS(int j) { int o = __p.__offset(30); return o != 0 ? (KMLTour?)(new KMLTour()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TOURSLength { get { int o = __p.__offset(30); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// NetworkLinkControl
  public KMLNetworkLinkControl? NETWORK_LINK_CONTROL { get { int o = __p.__offset(32); return o != 0 ? (KMLNetworkLinkControl?)(new KMLNetworkLinkControl()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<KML> CreateKML(FlatBufferBuilder builder,
      StringOffset NAMEOffset = default(StringOffset),
      StringOffset DESCRIPTIONOffset = default(StringOffset),
      bool VISIBILITY = false,
      bool OPEN = false,
      VectorOffset STYLESOffset = default(VectorOffset),
      VectorOffset STYLE_MAPSOffset = default(VectorOffset),
      VectorOffset PLACEMARKSOffset = default(VectorOffset),
      VectorOffset FOLDERSOffset = default(VectorOffset),
      VectorOffset NETWORK_LINKSOffset = default(VectorOffset),
      VectorOffset GROUND_OVERLAYSOffset = default(VectorOffset),
      VectorOffset SCHEMASOffset = default(VectorOffset),
      VectorOffset SCREEN_OVERLAYSOffset = default(VectorOffset),
      VectorOffset PHOTO_OVERLAYSOffset = default(VectorOffset),
      VectorOffset TOURSOffset = default(VectorOffset),
      Offset<KMLNetworkLinkControl> NETWORK_LINK_CONTROLOffset = default(Offset<KMLNetworkLinkControl>)) {
    builder.StartTable(15);
    KML.AddNETWORK_LINK_CONTROL(builder, NETWORK_LINK_CONTROLOffset);
    KML.AddTOURS(builder, TOURSOffset);
    KML.AddPHOTO_OVERLAYS(builder, PHOTO_OVERLAYSOffset);
    KML.AddSCREEN_OVERLAYS(builder, SCREEN_OVERLAYSOffset);
    KML.AddSCHEMAS(builder, SCHEMASOffset);
    KML.AddGROUND_OVERLAYS(builder, GROUND_OVERLAYSOffset);
    KML.AddNETWORK_LINKS(builder, NETWORK_LINKSOffset);
    KML.AddFOLDERS(builder, FOLDERSOffset);
    KML.AddPLACEMARKS(builder, PLACEMARKSOffset);
    KML.AddSTYLE_MAPS(builder, STYLE_MAPSOffset);
    KML.AddSTYLES(builder, STYLESOffset);
    KML.AddDESCRIPTION(builder, DESCRIPTIONOffset);
    KML.AddNAME(builder, NAMEOffset);
    KML.AddOPEN(builder, OPEN);
    KML.AddVISIBILITY(builder, VISIBILITY);
    return KML.EndKML(builder);
  }

  public static void StartKML(FlatBufferBuilder builder) { builder.StartTable(15); }
  public static void AddNAME(FlatBufferBuilder builder, StringOffset NAMEOffset) { builder.AddOffset(0, NAMEOffset.Value, 0); }
  public static void AddDESCRIPTION(FlatBufferBuilder builder, StringOffset DESCRIPTIONOffset) { builder.AddOffset(1, DESCRIPTIONOffset.Value, 0); }
  public static void AddVISIBILITY(FlatBufferBuilder builder, bool VISIBILITY) { builder.AddBool(2, VISIBILITY, false); }
  public static void AddOPEN(FlatBufferBuilder builder, bool OPEN) { builder.AddBool(3, OPEN, false); }
  public static void AddSTYLES(FlatBufferBuilder builder, VectorOffset STYLESOffset) { builder.AddOffset(4, STYLESOffset.Value, 0); }
  public static VectorOffset CreateSTYLESVector(FlatBufferBuilder builder, Offset<KMLStyle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSTYLESVectorBlock(FlatBufferBuilder builder, Offset<KMLStyle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTYLESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLStyle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTYLESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLStyle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSTYLESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSTYLE_MAPS(FlatBufferBuilder builder, VectorOffset STYLE_MAPSOffset) { builder.AddOffset(5, STYLE_MAPSOffset.Value, 0); }
  public static VectorOffset CreateSTYLE_MAPSVector(FlatBufferBuilder builder, Offset<KMLStyleMap>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSTYLE_MAPSVectorBlock(FlatBufferBuilder builder, Offset<KMLStyleMap>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTYLE_MAPSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLStyleMap>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTYLE_MAPSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLStyleMap>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSTYLE_MAPSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPLACEMARKS(FlatBufferBuilder builder, VectorOffset PLACEMARKSOffset) { builder.AddOffset(6, PLACEMARKSOffset.Value, 0); }
  public static VectorOffset CreatePLACEMARKSVector(FlatBufferBuilder builder, Offset<KMLPlacemark>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, Offset<KMLPlacemark>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLPlacemark>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLPlacemark>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPLACEMARKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddFOLDERS(FlatBufferBuilder builder, VectorOffset FOLDERSOffset) { builder.AddOffset(7, FOLDERSOffset.Value, 0); }
  public static VectorOffset CreateFOLDERSVector(FlatBufferBuilder builder, Offset<KMLFolder>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, Offset<KMLFolder>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLFolder>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLFolder>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartFOLDERSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddNETWORK_LINKS(FlatBufferBuilder builder, VectorOffset NETWORK_LINKSOffset) { builder.AddOffset(8, NETWORK_LINKSOffset.Value, 0); }
  public static VectorOffset CreateNETWORK_LINKSVector(FlatBufferBuilder builder, Offset<KMLNetworkLink>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, Offset<KMLNetworkLink>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLNetworkLink>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLNetworkLink>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNETWORK_LINKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGROUND_OVERLAYS(FlatBufferBuilder builder, VectorOffset GROUND_OVERLAYSOffset) { builder.AddOffset(9, GROUND_OVERLAYSOffset.Value, 0); }
  public static VectorOffset CreateGROUND_OVERLAYSVector(FlatBufferBuilder builder, Offset<KMLGroundOverlay>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, Offset<KMLGroundOverlay>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLGroundOverlay>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLGroundOverlay>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartGROUND_OVERLAYSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSCHEMAS(FlatBufferBuilder builder, VectorOffset SCHEMASOffset) { builder.AddOffset(10, SCHEMASOffset.Value, 0); }
  public static VectorOffset CreateSCHEMASVector(FlatBufferBuilder builder, Offset<KMLSchema>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMASVectorBlock(FlatBufferBuilder builder, Offset<KMLSchema>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMASVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLSchema>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMASVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLSchema>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSCHEMASVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSCREEN_OVERLAYS(FlatBufferBuilder builder, VectorOffset SCREEN_OVERLAYSOffset) { builder.AddOffset(11, SCREEN_OVERLAYSOffset.Value, 0); }
  public static VectorOffset CreateSCREEN_OVERLAYSVector(FlatBufferBuilder builder, Offset<KMLScreenOverlay>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSCREEN_OVERLAYSVectorBlock(FlatBufferBuilder builder, Offset<KMLScreenOverlay>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCREEN_OVERLAYSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLScreenOverlay>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCREEN_OVERLAYSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLScreenOverlay>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSCREEN_OVERLAYSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPHOTO_OVERLAYS(FlatBufferBuilder builder, VectorOffset PHOTO_OVERLAYSOffset) { builder.AddOffset(12, PHOTO_OVERLAYSOffset.Value, 0); }
  public static VectorOffset CreatePHOTO_OVERLAYSVector(FlatBufferBuilder builder, Offset<KMLPhotoOverlay>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePHOTO_OVERLAYSVectorBlock(FlatBufferBuilder builder, Offset<KMLPhotoOverlay>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePHOTO_OVERLAYSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLPhotoOverlay>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePHOTO_OVERLAYSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLPhotoOverlay>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPHOTO_OVERLAYSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTOURS(FlatBufferBuilder builder, VectorOffset TOURSOffset) { builder.AddOffset(13, TOURSOffset.Value, 0); }
  public static VectorOffset CreateTOURSVector(FlatBufferBuilder builder, Offset<KMLTour>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTOURSVectorBlock(FlatBufferBuilder builder, Offset<KMLTour>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTOURSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLTour>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTOURSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLTour>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTOURSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddNETWORK_LINK_CONTROL(FlatBufferBuilder builder, Offset<KMLNetworkLinkControl> NETWORK_LINK_CONTROLOffset) { builder.AddOffset(14, NETWORK_LINK_CONTROLOffset.Value, 0); }
  public static Offset<KML> EndKML(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<KML>(o);
  }
  public static void FinishKMLBuffer(FlatBufferBuilder builder, Offset<KML> offset) { builder.Finish(offset.Value, "$KML"); }
  public static void FinishSizePrefixedKMLBuffer(FlatBufferBuilder builder, Offset<KML> offset) { builder.FinishSizePrefixed(offset.Value, "$KML"); }
  public KMLT UnPack() {
    var _o = new KMLT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(KMLT _o) {
    _o.NAME = this.NAME;
    _o.DESCRIPTION = this.DESCRIPTION;
    _o.VISIBILITY = this.VISIBILITY;
    _o.OPEN = this.OPEN;
    _o.STYLES = new List<KMLStyleT>();
    for (var _j = 0; _j < this.STYLESLength; ++_j) {_o.STYLES.Add(this.STYLES(_j).HasValue ? this.STYLES(_j).Value.UnPack() : null);}
    _o.STYLE_MAPS = new List<KMLStyleMapT>();
    for (var _j = 0; _j < this.STYLE_MAPSLength; ++_j) {_o.STYLE_MAPS.Add(this.STYLE_MAPS(_j).HasValue ? this.STYLE_MAPS(_j).Value.UnPack() : null);}
    _o.PLACEMARKS = new List<KMLPlacemarkT>();
    for (var _j = 0; _j < this.PLACEMARKSLength; ++_j) {_o.PLACEMARKS.Add(this.PLACEMARKS(_j).HasValue ? this.PLACEMARKS(_j).Value.UnPack() : null);}
    _o.FOLDERS = new List<KMLFolderT>();
    for (var _j = 0; _j < this.FOLDERSLength; ++_j) {_o.FOLDERS.Add(this.FOLDERS(_j).HasValue ? this.FOLDERS(_j).Value.UnPack() : null);}
    _o.NETWORK_LINKS = new List<KMLNetworkLinkT>();
    for (var _j = 0; _j < this.NETWORK_LINKSLength; ++_j) {_o.NETWORK_LINKS.Add(this.NETWORK_LINKS(_j).HasValue ? this.NETWORK_LINKS(_j).Value.UnPack() : null);}
    _o.GROUND_OVERLAYS = new List<KMLGroundOverlayT>();
    for (var _j = 0; _j < this.GROUND_OVERLAYSLength; ++_j) {_o.GROUND_OVERLAYS.Add(this.GROUND_OVERLAYS(_j).HasValue ? this.GROUND_OVERLAYS(_j).Value.UnPack() : null);}
    _o.SCHEMAS = new List<KMLSchemaT>();
    for (var _j = 0; _j < this.SCHEMASLength; ++_j) {_o.SCHEMAS.Add(this.SCHEMAS(_j).HasValue ? this.SCHEMAS(_j).Value.UnPack() : null);}
    _o.SCREEN_OVERLAYS = new List<KMLScreenOverlayT>();
    for (var _j = 0; _j < this.SCREEN_OVERLAYSLength; ++_j) {_o.SCREEN_OVERLAYS.Add(this.SCREEN_OVERLAYS(_j).HasValue ? this.SCREEN_OVERLAYS(_j).Value.UnPack() : null);}
    _o.PHOTO_OVERLAYS = new List<KMLPhotoOverlayT>();
    for (var _j = 0; _j < this.PHOTO_OVERLAYSLength; ++_j) {_o.PHOTO_OVERLAYS.Add(this.PHOTO_OVERLAYS(_j).HasValue ? this.PHOTO_OVERLAYS(_j).Value.UnPack() : null);}
    _o.TOURS = new List<KMLTourT>();
    for (var _j = 0; _j < this.TOURSLength; ++_j) {_o.TOURS.Add(this.TOURS(_j).HasValue ? this.TOURS(_j).Value.UnPack() : null);}
    _o.NETWORK_LINK_CONTROL = this.NETWORK_LINK_CONTROL.HasValue ? this.NETWORK_LINK_CONTROL.Value.UnPack() : null;
  }
  public static Offset<KML> Pack(FlatBufferBuilder builder, KMLT _o) {
    if (_o == null) return default(Offset<KML>);
    var _NAME = _o.NAME == null ? default(StringOffset) : builder.CreateString(_o.NAME);
    var _DESCRIPTION = _o.DESCRIPTION == null ? default(StringOffset) : builder.CreateString(_o.DESCRIPTION);
    var _STYLES = default(VectorOffset);
    if (_o.STYLES != null) {
      var __STYLES = new Offset<KMLStyle>[_o.STYLES.Count];
      for (var _j = 0; _j < __STYLES.Length; ++_j) { __STYLES[_j] = KMLStyle.Pack(builder, _o.STYLES[_j]); }
      _STYLES = CreateSTYLESVector(builder, __STYLES);
    }
    var _STYLE_MAPS = default(VectorOffset);
    if (_o.STYLE_MAPS != null) {
      var __STYLE_MAPS = new Offset<KMLStyleMap>[_o.STYLE_MAPS.Count];
      for (var _j = 0; _j < __STYLE_MAPS.Length; ++_j) { __STYLE_MAPS[_j] = KMLStyleMap.Pack(builder, _o.STYLE_MAPS[_j]); }
      _STYLE_MAPS = CreateSTYLE_MAPSVector(builder, __STYLE_MAPS);
    }
    var _PLACEMARKS = default(VectorOffset);
    if (_o.PLACEMARKS != null) {
      var __PLACEMARKS = new Offset<KMLPlacemark>[_o.PLACEMARKS.Count];
      for (var _j = 0; _j < __PLACEMARKS.Length; ++_j) { __PLACEMARKS[_j] = KMLPlacemark.Pack(builder, _o.PLACEMARKS[_j]); }
      _PLACEMARKS = CreatePLACEMARKSVector(builder, __PLACEMARKS);
    }
    var _FOLDERS = default(VectorOffset);
    if (_o.FOLDERS != null) {
      var __FOLDERS = new Offset<KMLFolder>[_o.FOLDERS.Count];
      for (var _j = 0; _j < __FOLDERS.Length; ++_j) { __FOLDERS[_j] = KMLFolder.Pack(builder, _o.FOLDERS[_j]); }
      _FOLDERS = CreateFOLDERSVector(builder, __FOLDERS);
    }
    var _NETWORK_LINKS = default(VectorOffset);
    if (_o.NETWORK_LINKS != null) {
      var __NETWORK_LINKS = new Offset<KMLNetworkLink>[_o.NETWORK_LINKS.Count];
      for (var _j = 0; _j < __NETWORK_LINKS.Length; ++_j) { __NETWORK_LINKS[_j] = KMLNetworkLink.Pack(builder, _o.NETWORK_LINKS[_j]); }
      _NETWORK_LINKS = CreateNETWORK_LINKSVector(builder, __NETWORK_LINKS);
    }
    var _GROUND_OVERLAYS = default(VectorOffset);
    if (_o.GROUND_OVERLAYS != null) {
      var __GROUND_OVERLAYS = new Offset<KMLGroundOverlay>[_o.GROUND_OVERLAYS.Count];
      for (var _j = 0; _j < __GROUND_OVERLAYS.Length; ++_j) { __GROUND_OVERLAYS[_j] = KMLGroundOverlay.Pack(builder, _o.GROUND_OVERLAYS[_j]); }
      _GROUND_OVERLAYS = CreateGROUND_OVERLAYSVector(builder, __GROUND_OVERLAYS);
    }
    var _SCHEMAS = default(VectorOffset);
    if (_o.SCHEMAS != null) {
      var __SCHEMAS = new Offset<KMLSchema>[_o.SCHEMAS.Count];
      for (var _j = 0; _j < __SCHEMAS.Length; ++_j) { __SCHEMAS[_j] = KMLSchema.Pack(builder, _o.SCHEMAS[_j]); }
      _SCHEMAS = CreateSCHEMASVector(builder, __SCHEMAS);
    }
    var _SCREEN_OVERLAYS = default(VectorOffset);
    if (_o.SCREEN_OVERLAYS != null) {
      var __SCREEN_OVERLAYS = new Offset<KMLScreenOverlay>[_o.SCREEN_OVERLAYS.Count];
      for (var _j = 0; _j < __SCREEN_OVERLAYS.Length; ++_j) { __SCREEN_OVERLAYS[_j] = KMLScreenOverlay.Pack(builder, _o.SCREEN_OVERLAYS[_j]); }
      _SCREEN_OVERLAYS = CreateSCREEN_OVERLAYSVector(builder, __SCREEN_OVERLAYS);
    }
    var _PHOTO_OVERLAYS = default(VectorOffset);
    if (_o.PHOTO_OVERLAYS != null) {
      var __PHOTO_OVERLAYS = new Offset<KMLPhotoOverlay>[_o.PHOTO_OVERLAYS.Count];
      for (var _j = 0; _j < __PHOTO_OVERLAYS.Length; ++_j) { __PHOTO_OVERLAYS[_j] = KMLPhotoOverlay.Pack(builder, _o.PHOTO_OVERLAYS[_j]); }
      _PHOTO_OVERLAYS = CreatePHOTO_OVERLAYSVector(builder, __PHOTO_OVERLAYS);
    }
    var _TOURS = default(VectorOffset);
    if (_o.TOURS != null) {
      var __TOURS = new Offset<KMLTour>[_o.TOURS.Count];
      for (var _j = 0; _j < __TOURS.Length; ++_j) { __TOURS[_j] = KMLTour.Pack(builder, _o.TOURS[_j]); }
      _TOURS = CreateTOURSVector(builder, __TOURS);
    }
    var _NETWORK_LINK_CONTROL = _o.NETWORK_LINK_CONTROL == null ? default(Offset<KMLNetworkLinkControl>) : KMLNetworkLinkControl.Pack(builder, _o.NETWORK_LINK_CONTROL);
    return CreateKML(
      builder,
      _NAME,
      _DESCRIPTION,
      _o.VISIBILITY,
      _o.OPEN,
      _STYLES,
      _STYLE_MAPS,
      _PLACEMARKS,
      _FOLDERS,
      _NETWORK_LINKS,
      _GROUND_OVERLAYS,
      _SCHEMAS,
      _SCREEN_OVERLAYS,
      _PHOTO_OVERLAYS,
      _TOURS,
      _NETWORK_LINK_CONTROL);
  }
}

public class KMLT
{
  public string NAME { get; set; }
  public string DESCRIPTION { get; set; }
  public bool VISIBILITY { get; set; }
  public bool OPEN { get; set; }
  public List<KMLStyleT> STYLES { get; set; }
  public List<KMLStyleMapT> STYLE_MAPS { get; set; }
  public List<KMLPlacemarkT> PLACEMARKS { get; set; }
  public List<KMLFolderT> FOLDERS { get; set; }
  public List<KMLNetworkLinkT> NETWORK_LINKS { get; set; }
  public List<KMLGroundOverlayT> GROUND_OVERLAYS { get; set; }
  public List<KMLSchemaT> SCHEMAS { get; set; }
  public List<KMLScreenOverlayT> SCREEN_OVERLAYS { get; set; }
  public List<KMLPhotoOverlayT> PHOTO_OVERLAYS { get; set; }
  public List<KMLTourT> TOURS { get; set; }
  public KMLNetworkLinkControlT NETWORK_LINK_CONTROL { get; set; }

  public KMLT() {
    this.NAME = null;
    this.DESCRIPTION = null;
    this.VISIBILITY = false;
    this.OPEN = false;
    this.STYLES = null;
    this.STYLE_MAPS = null;
    this.PLACEMARKS = null;
    this.FOLDERS = null;
    this.NETWORK_LINKS = null;
    this.GROUND_OVERLAYS = null;
    this.SCHEMAS = null;
    this.SCREEN_OVERLAYS = null;
    this.PHOTO_OVERLAYS = null;
    this.TOURS = null;
    this.NETWORK_LINK_CONTROL = null;
  }
  public static KMLT DeserializeFromBinary(byte[] fbBuffer) {
    return KML.GetRootAsKML(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    KML.FinishKMLBuffer(fbb, KML.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class KMLVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*NAME*/, false)
      && verifier.VerifyString(tablePos, 6 /*DESCRIPTION*/, false)
      && verifier.VerifyField(tablePos, 8 /*VISIBILITY*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*OPEN*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*STYLES*/, KMLStyleVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*STYLE_MAPS*/, KMLStyleMapVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*PLACEMARKS*/, KMLPlacemarkVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 18 /*FOLDERS*/, KMLFolderVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 20 /*NETWORK_LINKS*/, KMLNetworkLinkVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 22 /*GROUND_OVERLAYS*/, KMLGroundOverlayVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 24 /*SCHEMAS*/, KMLSchemaVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 26 /*SCREEN_OVERLAYS*/, KMLScreenOverlayVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 28 /*PHOTO_OVERLAYS*/, KMLPhotoOverlayVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 30 /*TOURS*/, KMLTourVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 32 /*NETWORK_LINK_CONTROL*/, KMLNetworkLinkControlVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
