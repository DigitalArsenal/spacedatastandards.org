// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Collection of argument types
public struct ArgumentTypeSet : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static ArgumentTypeSet GetRootAsArgumentTypeSet(ByteBuffer _bb) { return GetRootAsArgumentTypeSet(_bb, new ArgumentTypeSet()); }
  public static ArgumentTypeSet GetRootAsArgumentTypeSet(ByteBuffer _bb, ArgumentTypeSet obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ArgumentTypeSet __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Integer argument types
  public IntegerArgumentType? INTEGER_TYPES(int j) { int o = __p.__offset(4); return o != 0 ? (IntegerArgumentType?)(new IntegerArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int INTEGER_TYPESLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Float argument types
  public FloatArgumentType? FLOAT_TYPES(int j) { int o = __p.__offset(6); return o != 0 ? (FloatArgumentType?)(new FloatArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FLOAT_TYPESLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// String argument types
  public StringArgumentType? STRING_TYPES(int j) { int o = __p.__offset(8); return o != 0 ? (StringArgumentType?)(new StringArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int STRING_TYPESLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Boolean argument types
  public BooleanArgumentType? BOOLEAN_TYPES(int j) { int o = __p.__offset(10); return o != 0 ? (BooleanArgumentType?)(new BooleanArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BOOLEAN_TYPESLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Enumerated argument types
  public EnumeratedArgumentType? ENUMERATED_TYPES(int j) { int o = __p.__offset(12); return o != 0 ? (EnumeratedArgumentType?)(new EnumeratedArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ENUMERATED_TYPESLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Binary argument types
  public BinaryArgumentType? BINARY_TYPES(int j) { int o = __p.__offset(14); return o != 0 ? (BinaryArgumentType?)(new BinaryArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BINARY_TYPESLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Aggregate argument types
  public AggregateArgumentType? AGGREGATE_TYPES(int j) { int o = __p.__offset(16); return o != 0 ? (AggregateArgumentType?)(new AggregateArgumentType()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int AGGREGATE_TYPESLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<ArgumentTypeSet> CreateArgumentTypeSet(FlatBufferBuilder builder,
      VectorOffset INTEGER_TYPESOffset = default(VectorOffset),
      VectorOffset FLOAT_TYPESOffset = default(VectorOffset),
      VectorOffset STRING_TYPESOffset = default(VectorOffset),
      VectorOffset BOOLEAN_TYPESOffset = default(VectorOffset),
      VectorOffset ENUMERATED_TYPESOffset = default(VectorOffset),
      VectorOffset BINARY_TYPESOffset = default(VectorOffset),
      VectorOffset AGGREGATE_TYPESOffset = default(VectorOffset)) {
    builder.StartTable(7);
    ArgumentTypeSet.AddAGGREGATE_TYPES(builder, AGGREGATE_TYPESOffset);
    ArgumentTypeSet.AddBINARY_TYPES(builder, BINARY_TYPESOffset);
    ArgumentTypeSet.AddENUMERATED_TYPES(builder, ENUMERATED_TYPESOffset);
    ArgumentTypeSet.AddBOOLEAN_TYPES(builder, BOOLEAN_TYPESOffset);
    ArgumentTypeSet.AddSTRING_TYPES(builder, STRING_TYPESOffset);
    ArgumentTypeSet.AddFLOAT_TYPES(builder, FLOAT_TYPESOffset);
    ArgumentTypeSet.AddINTEGER_TYPES(builder, INTEGER_TYPESOffset);
    return ArgumentTypeSet.EndArgumentTypeSet(builder);
  }

  public static void StartArgumentTypeSet(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddINTEGER_TYPES(FlatBufferBuilder builder, VectorOffset INTEGER_TYPESOffset) { builder.AddOffset(0, INTEGER_TYPESOffset.Value, 0); }
  public static VectorOffset CreateINTEGER_TYPESVector(FlatBufferBuilder builder, Offset<IntegerArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateINTEGER_TYPESVectorBlock(FlatBufferBuilder builder, Offset<IntegerArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateINTEGER_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<IntegerArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateINTEGER_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<IntegerArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartINTEGER_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddFLOAT_TYPES(FlatBufferBuilder builder, VectorOffset FLOAT_TYPESOffset) { builder.AddOffset(1, FLOAT_TYPESOffset.Value, 0); }
  public static VectorOffset CreateFLOAT_TYPESVector(FlatBufferBuilder builder, Offset<FloatArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateFLOAT_TYPESVectorBlock(FlatBufferBuilder builder, Offset<FloatArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFLOAT_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<FloatArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFLOAT_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<FloatArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartFLOAT_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSTRING_TYPES(FlatBufferBuilder builder, VectorOffset STRING_TYPESOffset) { builder.AddOffset(2, STRING_TYPESOffset.Value, 0); }
  public static VectorOffset CreateSTRING_TYPESVector(FlatBufferBuilder builder, Offset<StringArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSTRING_TYPESVectorBlock(FlatBufferBuilder builder, Offset<StringArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTRING_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<StringArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSTRING_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<StringArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSTRING_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBOOLEAN_TYPES(FlatBufferBuilder builder, VectorOffset BOOLEAN_TYPESOffset) { builder.AddOffset(3, BOOLEAN_TYPESOffset.Value, 0); }
  public static VectorOffset CreateBOOLEAN_TYPESVector(FlatBufferBuilder builder, Offset<BooleanArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBOOLEAN_TYPESVectorBlock(FlatBufferBuilder builder, Offset<BooleanArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBOOLEAN_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<BooleanArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBOOLEAN_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<BooleanArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBOOLEAN_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddENUMERATED_TYPES(FlatBufferBuilder builder, VectorOffset ENUMERATED_TYPESOffset) { builder.AddOffset(4, ENUMERATED_TYPESOffset.Value, 0); }
  public static VectorOffset CreateENUMERATED_TYPESVector(FlatBufferBuilder builder, Offset<EnumeratedArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateENUMERATED_TYPESVectorBlock(FlatBufferBuilder builder, Offset<EnumeratedArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENUMERATED_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<EnumeratedArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateENUMERATED_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<EnumeratedArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartENUMERATED_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBINARY_TYPES(FlatBufferBuilder builder, VectorOffset BINARY_TYPESOffset) { builder.AddOffset(5, BINARY_TYPESOffset.Value, 0); }
  public static VectorOffset CreateBINARY_TYPESVector(FlatBufferBuilder builder, Offset<BinaryArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBINARY_TYPESVectorBlock(FlatBufferBuilder builder, Offset<BinaryArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBINARY_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<BinaryArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBINARY_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<BinaryArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBINARY_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddAGGREGATE_TYPES(FlatBufferBuilder builder, VectorOffset AGGREGATE_TYPESOffset) { builder.AddOffset(6, AGGREGATE_TYPESOffset.Value, 0); }
  public static VectorOffset CreateAGGREGATE_TYPESVector(FlatBufferBuilder builder, Offset<AggregateArgumentType>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAGGREGATE_TYPESVectorBlock(FlatBufferBuilder builder, Offset<AggregateArgumentType>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAGGREGATE_TYPESVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<AggregateArgumentType>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAGGREGATE_TYPESVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<AggregateArgumentType>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAGGREGATE_TYPESVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<ArgumentTypeSet> EndArgumentTypeSet(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<ArgumentTypeSet>(o);
  }
  public ArgumentTypeSetT UnPack() {
    var _o = new ArgumentTypeSetT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ArgumentTypeSetT _o) {
    _o.INTEGER_TYPES = new List<IntegerArgumentTypeT>();
    for (var _j = 0; _j < this.INTEGER_TYPESLength; ++_j) {_o.INTEGER_TYPES.Add(this.INTEGER_TYPES(_j).HasValue ? this.INTEGER_TYPES(_j).Value.UnPack() : null);}
    _o.FLOAT_TYPES = new List<FloatArgumentTypeT>();
    for (var _j = 0; _j < this.FLOAT_TYPESLength; ++_j) {_o.FLOAT_TYPES.Add(this.FLOAT_TYPES(_j).HasValue ? this.FLOAT_TYPES(_j).Value.UnPack() : null);}
    _o.STRING_TYPES = new List<StringArgumentTypeT>();
    for (var _j = 0; _j < this.STRING_TYPESLength; ++_j) {_o.STRING_TYPES.Add(this.STRING_TYPES(_j).HasValue ? this.STRING_TYPES(_j).Value.UnPack() : null);}
    _o.BOOLEAN_TYPES = new List<BooleanArgumentTypeT>();
    for (var _j = 0; _j < this.BOOLEAN_TYPESLength; ++_j) {_o.BOOLEAN_TYPES.Add(this.BOOLEAN_TYPES(_j).HasValue ? this.BOOLEAN_TYPES(_j).Value.UnPack() : null);}
    _o.ENUMERATED_TYPES = new List<EnumeratedArgumentTypeT>();
    for (var _j = 0; _j < this.ENUMERATED_TYPESLength; ++_j) {_o.ENUMERATED_TYPES.Add(this.ENUMERATED_TYPES(_j).HasValue ? this.ENUMERATED_TYPES(_j).Value.UnPack() : null);}
    _o.BINARY_TYPES = new List<BinaryArgumentTypeT>();
    for (var _j = 0; _j < this.BINARY_TYPESLength; ++_j) {_o.BINARY_TYPES.Add(this.BINARY_TYPES(_j).HasValue ? this.BINARY_TYPES(_j).Value.UnPack() : null);}
    _o.AGGREGATE_TYPES = new List<AggregateArgumentTypeT>();
    for (var _j = 0; _j < this.AGGREGATE_TYPESLength; ++_j) {_o.AGGREGATE_TYPES.Add(this.AGGREGATE_TYPES(_j).HasValue ? this.AGGREGATE_TYPES(_j).Value.UnPack() : null);}
  }
  public static Offset<ArgumentTypeSet> Pack(FlatBufferBuilder builder, ArgumentTypeSetT _o) {
    if (_o == null) return default(Offset<ArgumentTypeSet>);
    var _INTEGER_TYPES = default(VectorOffset);
    if (_o.INTEGER_TYPES != null) {
      var __INTEGER_TYPES = new Offset<IntegerArgumentType>[_o.INTEGER_TYPES.Count];
      for (var _j = 0; _j < __INTEGER_TYPES.Length; ++_j) { __INTEGER_TYPES[_j] = IntegerArgumentType.Pack(builder, _o.INTEGER_TYPES[_j]); }
      _INTEGER_TYPES = CreateINTEGER_TYPESVector(builder, __INTEGER_TYPES);
    }
    var _FLOAT_TYPES = default(VectorOffset);
    if (_o.FLOAT_TYPES != null) {
      var __FLOAT_TYPES = new Offset<FloatArgumentType>[_o.FLOAT_TYPES.Count];
      for (var _j = 0; _j < __FLOAT_TYPES.Length; ++_j) { __FLOAT_TYPES[_j] = FloatArgumentType.Pack(builder, _o.FLOAT_TYPES[_j]); }
      _FLOAT_TYPES = CreateFLOAT_TYPESVector(builder, __FLOAT_TYPES);
    }
    var _STRING_TYPES = default(VectorOffset);
    if (_o.STRING_TYPES != null) {
      var __STRING_TYPES = new Offset<StringArgumentType>[_o.STRING_TYPES.Count];
      for (var _j = 0; _j < __STRING_TYPES.Length; ++_j) { __STRING_TYPES[_j] = StringArgumentType.Pack(builder, _o.STRING_TYPES[_j]); }
      _STRING_TYPES = CreateSTRING_TYPESVector(builder, __STRING_TYPES);
    }
    var _BOOLEAN_TYPES = default(VectorOffset);
    if (_o.BOOLEAN_TYPES != null) {
      var __BOOLEAN_TYPES = new Offset<BooleanArgumentType>[_o.BOOLEAN_TYPES.Count];
      for (var _j = 0; _j < __BOOLEAN_TYPES.Length; ++_j) { __BOOLEAN_TYPES[_j] = BooleanArgumentType.Pack(builder, _o.BOOLEAN_TYPES[_j]); }
      _BOOLEAN_TYPES = CreateBOOLEAN_TYPESVector(builder, __BOOLEAN_TYPES);
    }
    var _ENUMERATED_TYPES = default(VectorOffset);
    if (_o.ENUMERATED_TYPES != null) {
      var __ENUMERATED_TYPES = new Offset<EnumeratedArgumentType>[_o.ENUMERATED_TYPES.Count];
      for (var _j = 0; _j < __ENUMERATED_TYPES.Length; ++_j) { __ENUMERATED_TYPES[_j] = EnumeratedArgumentType.Pack(builder, _o.ENUMERATED_TYPES[_j]); }
      _ENUMERATED_TYPES = CreateENUMERATED_TYPESVector(builder, __ENUMERATED_TYPES);
    }
    var _BINARY_TYPES = default(VectorOffset);
    if (_o.BINARY_TYPES != null) {
      var __BINARY_TYPES = new Offset<BinaryArgumentType>[_o.BINARY_TYPES.Count];
      for (var _j = 0; _j < __BINARY_TYPES.Length; ++_j) { __BINARY_TYPES[_j] = BinaryArgumentType.Pack(builder, _o.BINARY_TYPES[_j]); }
      _BINARY_TYPES = CreateBINARY_TYPESVector(builder, __BINARY_TYPES);
    }
    var _AGGREGATE_TYPES = default(VectorOffset);
    if (_o.AGGREGATE_TYPES != null) {
      var __AGGREGATE_TYPES = new Offset<AggregateArgumentType>[_o.AGGREGATE_TYPES.Count];
      for (var _j = 0; _j < __AGGREGATE_TYPES.Length; ++_j) { __AGGREGATE_TYPES[_j] = AggregateArgumentType.Pack(builder, _o.AGGREGATE_TYPES[_j]); }
      _AGGREGATE_TYPES = CreateAGGREGATE_TYPESVector(builder, __AGGREGATE_TYPES);
    }
    return CreateArgumentTypeSet(
      builder,
      _INTEGER_TYPES,
      _FLOAT_TYPES,
      _STRING_TYPES,
      _BOOLEAN_TYPES,
      _ENUMERATED_TYPES,
      _BINARY_TYPES,
      _AGGREGATE_TYPES);
  }
}

public class ArgumentTypeSetT
{
  public List<IntegerArgumentTypeT> INTEGER_TYPES { get; set; }
  public List<FloatArgumentTypeT> FLOAT_TYPES { get; set; }
  public List<StringArgumentTypeT> STRING_TYPES { get; set; }
  public List<BooleanArgumentTypeT> BOOLEAN_TYPES { get; set; }
  public List<EnumeratedArgumentTypeT> ENUMERATED_TYPES { get; set; }
  public List<BinaryArgumentTypeT> BINARY_TYPES { get; set; }
  public List<AggregateArgumentTypeT> AGGREGATE_TYPES { get; set; }

  public ArgumentTypeSetT() {
    this.INTEGER_TYPES = null;
    this.FLOAT_TYPES = null;
    this.STRING_TYPES = null;
    this.BOOLEAN_TYPES = null;
    this.ENUMERATED_TYPES = null;
    this.BINARY_TYPES = null;
    this.AGGREGATE_TYPES = null;
  }
}


static public class ArgumentTypeSetVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyVectorOfTables(tablePos, 4 /*INTEGER_TYPES*/, IntegerArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 6 /*FLOAT_TYPES*/, FloatArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*STRING_TYPES*/, StringArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 10 /*BOOLEAN_TYPES*/, BooleanArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*ENUMERATED_TYPES*/, EnumeratedArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*BINARY_TYPES*/, BinaryArgumentTypeVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*AGGREGATE_TYPES*/, AggregateArgumentTypeVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
