// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Space Data Link Security (CCSDS 355.0-B-1)
public struct SDL : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static SDL GetRootAsSDL(ByteBuffer _bb) { return GetRootAsSDL(_bb, new SDL()); }
  public static SDL GetRootAsSDL(ByteBuffer _bb, SDL obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool SDLBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$SDL"); }
  public static bool VerifySDL(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$SDL", false, SDLVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public SDL __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Security Parameter Index
  public ushort SPI { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)0; } }
  /// Initialization vector length in bytes
  public byte IV_LENGTH { get { int o = __p.__offset(6); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  /// Initialization vector
  public byte IV(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int IVLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetIVBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetIVBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetIVArray() { return __p.__vector_as_array<byte>(8); }
  /// MAC length in bytes
  public byte MAC_LENGTH { get { int o = __p.__offset(10); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  /// Message authentication code
  public byte MAC(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int MACLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMACBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetMACBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetMACArray() { return __p.__vector_as_array<byte>(12); }
  /// Pad length
  public byte PAD_LENGTH { get { int o = __p.__offset(14); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
  /// Security payload
  public byte PAYLOAD(int j) { int o = __p.__offset(16); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int PAYLOADLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPAYLOADBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetPAYLOADBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetPAYLOADArray() { return __p.__vector_as_array<byte>(16); }

  public static Offset<SDL> CreateSDL(FlatBufferBuilder builder,
      ushort SPI = 0,
      byte IV_LENGTH = 0,
      VectorOffset IVOffset = default(VectorOffset),
      byte MAC_LENGTH = 0,
      VectorOffset MACOffset = default(VectorOffset),
      byte PAD_LENGTH = 0,
      VectorOffset PAYLOADOffset = default(VectorOffset)) {
    builder.StartTable(7);
    SDL.AddPAYLOAD(builder, PAYLOADOffset);
    SDL.AddMAC(builder, MACOffset);
    SDL.AddIV(builder, IVOffset);
    SDL.AddSPI(builder, SPI);
    SDL.AddPAD_LENGTH(builder, PAD_LENGTH);
    SDL.AddMAC_LENGTH(builder, MAC_LENGTH);
    SDL.AddIV_LENGTH(builder, IV_LENGTH);
    return SDL.EndSDL(builder);
  }

  public static void StartSDL(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddSPI(FlatBufferBuilder builder, ushort SPI) { builder.AddUshort(0, SPI, 0); }
  public static void AddIV_LENGTH(FlatBufferBuilder builder, byte IV_LENGTH) { builder.AddByte(1, IV_LENGTH, 0); }
  public static void AddIV(FlatBufferBuilder builder, VectorOffset IVOffset) { builder.AddOffset(2, IVOffset.Value, 0); }
  public static VectorOffset CreateIVVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateIVVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIVVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIVVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartIVVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddMAC_LENGTH(FlatBufferBuilder builder, byte MAC_LENGTH) { builder.AddByte(3, MAC_LENGTH, 0); }
  public static void AddMAC(FlatBufferBuilder builder, VectorOffset MACOffset) { builder.AddOffset(4, MACOffset.Value, 0); }
  public static VectorOffset CreateMACVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateMACVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMACVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMACVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMACVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddPAD_LENGTH(FlatBufferBuilder builder, byte PAD_LENGTH) { builder.AddByte(5, PAD_LENGTH, 0); }
  public static void AddPAYLOAD(FlatBufferBuilder builder, VectorOffset PAYLOADOffset) { builder.AddOffset(6, PAYLOADOffset.Value, 0); }
  public static VectorOffset CreatePAYLOADVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreatePAYLOADVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePAYLOADVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePAYLOADVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPAYLOADVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<SDL> EndSDL(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<SDL>(o);
  }
  public static void FinishSDLBuffer(FlatBufferBuilder builder, Offset<SDL> offset) { builder.Finish(offset.Value, "$SDL"); }
  public static void FinishSizePrefixedSDLBuffer(FlatBufferBuilder builder, Offset<SDL> offset) { builder.FinishSizePrefixed(offset.Value, "$SDL"); }
  public SDLT UnPack() {
    var _o = new SDLT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(SDLT _o) {
    _o.SPI = this.SPI;
    _o.IV_LENGTH = this.IV_LENGTH;
    _o.IV = new List<byte>();
    for (var _j = 0; _j < this.IVLength; ++_j) {_o.IV.Add(this.IV(_j));}
    _o.MAC_LENGTH = this.MAC_LENGTH;
    _o.MAC = new List<byte>();
    for (var _j = 0; _j < this.MACLength; ++_j) {_o.MAC.Add(this.MAC(_j));}
    _o.PAD_LENGTH = this.PAD_LENGTH;
    _o.PAYLOAD = new List<byte>();
    for (var _j = 0; _j < this.PAYLOADLength; ++_j) {_o.PAYLOAD.Add(this.PAYLOAD(_j));}
  }
  public static Offset<SDL> Pack(FlatBufferBuilder builder, SDLT _o) {
    if (_o == null) return default(Offset<SDL>);
    var _IV = default(VectorOffset);
    if (_o.IV != null) {
      var __IV = _o.IV.ToArray();
      _IV = CreateIVVector(builder, __IV);
    }
    var _MAC = default(VectorOffset);
    if (_o.MAC != null) {
      var __MAC = _o.MAC.ToArray();
      _MAC = CreateMACVector(builder, __MAC);
    }
    var _PAYLOAD = default(VectorOffset);
    if (_o.PAYLOAD != null) {
      var __PAYLOAD = _o.PAYLOAD.ToArray();
      _PAYLOAD = CreatePAYLOADVector(builder, __PAYLOAD);
    }
    return CreateSDL(
      builder,
      _o.SPI,
      _o.IV_LENGTH,
      _IV,
      _o.MAC_LENGTH,
      _MAC,
      _o.PAD_LENGTH,
      _PAYLOAD);
  }
}

public class SDLT
{
  public ushort SPI { get; set; }
  public byte IV_LENGTH { get; set; }
  public List<byte> IV { get; set; }
  public byte MAC_LENGTH { get; set; }
  public List<byte> MAC { get; set; }
  public byte PAD_LENGTH { get; set; }
  public List<byte> PAYLOAD { get; set; }

  public SDLT() {
    this.SPI = 0;
    this.IV_LENGTH = 0;
    this.IV = null;
    this.MAC_LENGTH = 0;
    this.MAC = null;
    this.PAD_LENGTH = 0;
    this.PAYLOAD = null;
  }
  public static SDLT DeserializeFromBinary(byte[] fbBuffer) {
    return SDL.GetRootAsSDL(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    SDL.FinishSDLBuffer(fbb, SDL.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class SDLVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*SPI*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 6 /*IV_LENGTH*/, 1 /*byte*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 8 /*IV*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 10 /*MAC_LENGTH*/, 1 /*byte*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*MAC*/, 1 /*byte*/, false)
      && verifier.VerifyField(tablePos, 14 /*PAD_LENGTH*/, 1 /*byte*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 16 /*PAYLOAD*/, 1 /*byte*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
