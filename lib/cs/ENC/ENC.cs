// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Encryption Header containing all parameters needed for decryption
public struct ENC : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static ENC GetRootAsENC(ByteBuffer _bb) { return GetRootAsENC(_bb, new ENC()); }
  public static ENC GetRootAsENC(ByteBuffer _bb, ENC obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool ENCBufferHasIdentifier(ByteBuffer _bb) { return Table.__has_identifier(_bb, "$ENC"); }
  public static bool VerifyENC(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("$ENC", false, ENCVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ENC __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Schema version for forward compatibility
  public byte VERSION { get { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)1; } }
  /// Key exchange algorithm used
  public KeyExchange KEY_EXCHANGE { get { int o = __p.__offset(6); return o != 0 ? (KeyExchange)__p.bb.GetSbyte(o + __p.bb_pos) : KeyExchange.X25519; } }
  /// Symmetric encryption algorithm used
  public SymmetricAlgo SYMMETRIC { get { int o = __p.__offset(8); return o != 0 ? (SymmetricAlgo)__p.bb.GetSbyte(o + __p.bb_pos) : SymmetricAlgo.AES_256_CTR; } }
  /// Key derivation function used
  public KDF KEY_DERIVATION { get { int o = __p.__offset(10); return o != 0 ? (KDF)__p.bb.GetSbyte(o + __p.bb_pos) : KDF.HKDF_SHA256; } }
  /// Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
  public byte EPHEMERAL_PUBLIC_KEY(int j) { int o = __p.__offset(12); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int EPHEMERAL_PUBLIC_KEYLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetEPHEMERAL_PUBLIC_KEYBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetEPHEMERAL_PUBLIC_KEYArray() { return __p.__vector_as_array<byte>(12); }
  /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  public byte NONCE_START(int j) { int o = __p.__offset(14); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int NONCE_STARTLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNONCE_STARTBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetNONCE_STARTBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetNONCE_STARTArray() { return __p.__vector_as_array<byte>(14); }
  /// Optional identifier for the recipient's public key (up to 32 bytes)
  public byte RECIPIENT_KEY_ID(int j) { int o = __p.__offset(16); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int RECIPIENT_KEY_IDLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRECIPIENT_KEY_IDBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetRECIPIENT_KEY_IDBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetRECIPIENT_KEY_IDArray() { return __p.__vector_as_array<byte>(16); }
  /// Optional domain separation context string
  public string CONTEXT { get { int o = __p.__offset(18); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCONTEXTBytes() { return __p.__vector_as_span<byte>(18, 1); }
#else
  public ArraySegment<byte>? GetCONTEXTBytes() { return __p.__vector_as_arraysegment(18); }
#endif
  public byte[] GetCONTEXTArray() { return __p.__vector_as_array<byte>(18); }
  /// Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
  public byte SCHEMA_HASH(int j) { int o = __p.__offset(20); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int SCHEMA_HASHLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSCHEMA_HASHBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
  public ArraySegment<byte>? GetSCHEMA_HASHBytes() { return __p.__vector_as_arraysegment(20); }
#endif
  public byte[] GetSCHEMA_HASHArray() { return __p.__vector_as_array<byte>(20); }
  /// Optional root type name from the schema
  public string ROOT_TYPE { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetROOT_TYPEBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
  public ArraySegment<byte>? GetROOT_TYPEBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public byte[] GetROOT_TYPEArray() { return __p.__vector_as_array<byte>(22); }
  /// Optional Unix timestamp (milliseconds) when encryption was performed
  public ulong TIMESTAMP { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }

  public static Offset<ENC> CreateENC(FlatBufferBuilder builder,
      byte VERSION = 1,
      KeyExchange KEY_EXCHANGE = KeyExchange.X25519,
      SymmetricAlgo SYMMETRIC = SymmetricAlgo.AES_256_CTR,
      KDF KEY_DERIVATION = KDF.HKDF_SHA256,
      VectorOffset EPHEMERAL_PUBLIC_KEYOffset = default(VectorOffset),
      VectorOffset NONCE_STARTOffset = default(VectorOffset),
      VectorOffset RECIPIENT_KEY_IDOffset = default(VectorOffset),
      StringOffset CONTEXTOffset = default(StringOffset),
      VectorOffset SCHEMA_HASHOffset = default(VectorOffset),
      StringOffset ROOT_TYPEOffset = default(StringOffset),
      ulong TIMESTAMP = 0) {
    builder.StartTable(11);
    ENC.AddTIMESTAMP(builder, TIMESTAMP);
    ENC.AddROOT_TYPE(builder, ROOT_TYPEOffset);
    ENC.AddSCHEMA_HASH(builder, SCHEMA_HASHOffset);
    ENC.AddCONTEXT(builder, CONTEXTOffset);
    ENC.AddRECIPIENT_KEY_ID(builder, RECIPIENT_KEY_IDOffset);
    ENC.AddNONCE_START(builder, NONCE_STARTOffset);
    ENC.AddEPHEMERAL_PUBLIC_KEY(builder, EPHEMERAL_PUBLIC_KEYOffset);
    ENC.AddKEY_DERIVATION(builder, KEY_DERIVATION);
    ENC.AddSYMMETRIC(builder, SYMMETRIC);
    ENC.AddKEY_EXCHANGE(builder, KEY_EXCHANGE);
    ENC.AddVERSION(builder, VERSION);
    return ENC.EndENC(builder);
  }

  public static void StartENC(FlatBufferBuilder builder) { builder.StartTable(11); }
  public static void AddVERSION(FlatBufferBuilder builder, byte VERSION) { builder.AddByte(0, VERSION, 1); }
  public static void AddKEY_EXCHANGE(FlatBufferBuilder builder, KeyExchange KEY_EXCHANGE) { builder.AddSbyte(1, (sbyte)KEY_EXCHANGE, 0); }
  public static void AddSYMMETRIC(FlatBufferBuilder builder, SymmetricAlgo SYMMETRIC) { builder.AddSbyte(2, (sbyte)SYMMETRIC, 0); }
  public static void AddKEY_DERIVATION(FlatBufferBuilder builder, KDF KEY_DERIVATION) { builder.AddSbyte(3, (sbyte)KEY_DERIVATION, 0); }
  public static void AddEPHEMERAL_PUBLIC_KEY(FlatBufferBuilder builder, VectorOffset EPHEMERAL_PUBLIC_KEYOffset) { builder.AddOffset(4, EPHEMERAL_PUBLIC_KEYOffset.Value, 0); }
  public static VectorOffset CreateEPHEMERAL_PUBLIC_KEYVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateEPHEMERAL_PUBLIC_KEYVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEPHEMERAL_PUBLIC_KEYVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEPHEMERAL_PUBLIC_KEYVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEPHEMERAL_PUBLIC_KEYVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddNONCE_START(FlatBufferBuilder builder, VectorOffset NONCE_STARTOffset) { builder.AddOffset(5, NONCE_STARTOffset.Value, 0); }
  public static VectorOffset CreateNONCE_STARTVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNONCE_STARTVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNONCE_STARTVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddRECIPIENT_KEY_ID(FlatBufferBuilder builder, VectorOffset RECIPIENT_KEY_IDOffset) { builder.AddOffset(6, RECIPIENT_KEY_IDOffset.Value, 0); }
  public static VectorOffset CreateRECIPIENT_KEY_IDVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRECIPIENT_KEY_IDVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRECIPIENT_KEY_IDVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRECIPIENT_KEY_IDVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRECIPIENT_KEY_IDVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddCONTEXT(FlatBufferBuilder builder, StringOffset CONTEXTOffset) { builder.AddOffset(7, CONTEXTOffset.Value, 0); }
  public static void AddSCHEMA_HASH(FlatBufferBuilder builder, VectorOffset SCHEMA_HASHOffset) { builder.AddOffset(8, SCHEMA_HASHOffset.Value, 0); }
  public static VectorOffset CreateSCHEMA_HASHVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMA_HASHVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMA_HASHVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSCHEMA_HASHVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSCHEMA_HASHVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddROOT_TYPE(FlatBufferBuilder builder, StringOffset ROOT_TYPEOffset) { builder.AddOffset(9, ROOT_TYPEOffset.Value, 0); }
  public static void AddTIMESTAMP(FlatBufferBuilder builder, ulong TIMESTAMP) { builder.AddUlong(10, TIMESTAMP, 0); }
  public static Offset<ENC> EndENC(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    builder.Required(o, 12);  // EPHEMERAL_PUBLIC_KEY
    builder.Required(o, 14);  // NONCE_START
    return new Offset<ENC>(o);
  }
  public static void FinishENCBuffer(FlatBufferBuilder builder, Offset<ENC> offset) { builder.Finish(offset.Value, "$ENC"); }
  public static void FinishSizePrefixedENCBuffer(FlatBufferBuilder builder, Offset<ENC> offset) { builder.FinishSizePrefixed(offset.Value, "$ENC"); }
  public ENCT UnPack() {
    var _o = new ENCT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ENCT _o) {
    _o.VERSION = this.VERSION;
    _o.KEY_EXCHANGE = this.KEY_EXCHANGE;
    _o.SYMMETRIC = this.SYMMETRIC;
    _o.KEY_DERIVATION = this.KEY_DERIVATION;
    _o.EPHEMERAL_PUBLIC_KEY = new List<byte>();
    for (var _j = 0; _j < this.EPHEMERAL_PUBLIC_KEYLength; ++_j) {_o.EPHEMERAL_PUBLIC_KEY.Add(this.EPHEMERAL_PUBLIC_KEY(_j));}
    _o.NONCE_START = new List<byte>();
    for (var _j = 0; _j < this.NONCE_STARTLength; ++_j) {_o.NONCE_START.Add(this.NONCE_START(_j));}
    _o.RECIPIENT_KEY_ID = new List<byte>();
    for (var _j = 0; _j < this.RECIPIENT_KEY_IDLength; ++_j) {_o.RECIPIENT_KEY_ID.Add(this.RECIPIENT_KEY_ID(_j));}
    _o.CONTEXT = this.CONTEXT;
    _o.SCHEMA_HASH = new List<byte>();
    for (var _j = 0; _j < this.SCHEMA_HASHLength; ++_j) {_o.SCHEMA_HASH.Add(this.SCHEMA_HASH(_j));}
    _o.ROOT_TYPE = this.ROOT_TYPE;
    _o.TIMESTAMP = this.TIMESTAMP;
  }
  public static Offset<ENC> Pack(FlatBufferBuilder builder, ENCT _o) {
    if (_o == null) return default(Offset<ENC>);
    var _EPHEMERAL_PUBLIC_KEY = default(VectorOffset);
    if (_o.EPHEMERAL_PUBLIC_KEY != null) {
      var __EPHEMERAL_PUBLIC_KEY = _o.EPHEMERAL_PUBLIC_KEY.ToArray();
      _EPHEMERAL_PUBLIC_KEY = CreateEPHEMERAL_PUBLIC_KEYVector(builder, __EPHEMERAL_PUBLIC_KEY);
    }
    var _NONCE_START = default(VectorOffset);
    if (_o.NONCE_START != null) {
      var __NONCE_START = _o.NONCE_START.ToArray();
      _NONCE_START = CreateNONCE_STARTVector(builder, __NONCE_START);
    }
    var _RECIPIENT_KEY_ID = default(VectorOffset);
    if (_o.RECIPIENT_KEY_ID != null) {
      var __RECIPIENT_KEY_ID = _o.RECIPIENT_KEY_ID.ToArray();
      _RECIPIENT_KEY_ID = CreateRECIPIENT_KEY_IDVector(builder, __RECIPIENT_KEY_ID);
    }
    var _CONTEXT = _o.CONTEXT == null ? default(StringOffset) : builder.CreateString(_o.CONTEXT);
    var _SCHEMA_HASH = default(VectorOffset);
    if (_o.SCHEMA_HASH != null) {
      var __SCHEMA_HASH = _o.SCHEMA_HASH.ToArray();
      _SCHEMA_HASH = CreateSCHEMA_HASHVector(builder, __SCHEMA_HASH);
    }
    var _ROOT_TYPE = _o.ROOT_TYPE == null ? default(StringOffset) : builder.CreateString(_o.ROOT_TYPE);
    return CreateENC(
      builder,
      _o.VERSION,
      _o.KEY_EXCHANGE,
      _o.SYMMETRIC,
      _o.KEY_DERIVATION,
      _EPHEMERAL_PUBLIC_KEY,
      _NONCE_START,
      _RECIPIENT_KEY_ID,
      _CONTEXT,
      _SCHEMA_HASH,
      _ROOT_TYPE,
      _o.TIMESTAMP);
  }
}

public class ENCT
{
  public byte VERSION { get; set; }
  public KeyExchange KEY_EXCHANGE { get; set; }
  public SymmetricAlgo SYMMETRIC { get; set; }
  public KDF KEY_DERIVATION { get; set; }
  public List<byte> EPHEMERAL_PUBLIC_KEY { get; set; }
  public List<byte> NONCE_START { get; set; }
  public List<byte> RECIPIENT_KEY_ID { get; set; }
  public string CONTEXT { get; set; }
  public List<byte> SCHEMA_HASH { get; set; }
  public string ROOT_TYPE { get; set; }
  public ulong TIMESTAMP { get; set; }

  public ENCT() {
    this.VERSION = 1;
    this.KEY_EXCHANGE = KeyExchange.X25519;
    this.SYMMETRIC = SymmetricAlgo.AES_256_CTR;
    this.KEY_DERIVATION = KDF.HKDF_SHA256;
    this.EPHEMERAL_PUBLIC_KEY = null;
    this.NONCE_START = null;
    this.RECIPIENT_KEY_ID = null;
    this.CONTEXT = null;
    this.SCHEMA_HASH = null;
    this.ROOT_TYPE = null;
    this.TIMESTAMP = 0;
  }
  public static ENCT DeserializeFromBinary(byte[] fbBuffer) {
    return ENC.GetRootAsENC(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    ENC.FinishENCBuffer(fbb, ENC.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class ENCVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*VERSION*/, 1 /*byte*/, 1, false)
      && verifier.VerifyField(tablePos, 6 /*KEY_EXCHANGE*/, 1 /*KeyExchange*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*SYMMETRIC*/, 1 /*SymmetricAlgo*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*KEY_DERIVATION*/, 1 /*KDF*/, 1, false)
      && verifier.VerifyVectorOfData(tablePos, 12 /*EPHEMERAL_PUBLIC_KEY*/, 1 /*byte*/, true)
      && verifier.VerifyVectorOfData(tablePos, 14 /*NONCE_START*/, 1 /*byte*/, true)
      && verifier.VerifyVectorOfData(tablePos, 16 /*RECIPIENT_KEY_ID*/, 1 /*byte*/, false)
      && verifier.VerifyString(tablePos, 18 /*CONTEXT*/, false)
      && verifier.VerifyVectorOfData(tablePos, 20 /*SCHEMA_HASH*/, 1 /*byte*/, false)
      && verifier.VerifyString(tablePos, 22 /*ROOT_TYPE*/, false)
      && verifier.VerifyField(tablePos, 24 /*TIMESTAMP*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
