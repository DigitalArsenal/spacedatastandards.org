// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Represents cryptographic key information
public struct CryptoKey : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_3_3(); }
  public static CryptoKey GetRootAsCryptoKey(ByteBuffer _bb) { return GetRootAsCryptoKey(_bb, new CryptoKey()); }
  public static CryptoKey GetRootAsCryptoKey(ByteBuffer _bb, CryptoKey obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public CryptoKey __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Public part of the cryptographic key, in hexidecimal format
  public string PUBLIC_KEY { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPUBLIC_KEYBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetPUBLIC_KEYBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetPUBLIC_KEYArray() { return __p.__vector_as_array<byte>(4); }
  /// Extended public key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
  public string XPUB { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetXPUBBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetXPUBBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetXPUBArray() { return __p.__vector_as_array<byte>(6); }
  /// Private part of the cryptographic key in hexidecimal format, should be kept secret 
  public string PRIVATE_KEY { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPRIVATE_KEYBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetPRIVATE_KEYBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetPRIVATE_KEYArray() { return __p.__vector_as_array<byte>(8); }
  /// Extended private key https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
  public string XPRIV { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetXPRIVBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetXPRIVBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetXPRIVArray() { return __p.__vector_as_array<byte>(10); }
  /// Address generated from the cryptographic key
  public string KEY_ADDRESS { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetKEY_ADDRESSBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetKEY_ADDRESSBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetKEY_ADDRESSArray() { return __p.__vector_as_array<byte>(12); }
  /// Type of the address generated from the cryptographic key
  public string ADDRESS_TYPE { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetADDRESS_TYPEBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetADDRESS_TYPEBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetADDRESS_TYPEArray() { return __p.__vector_as_array<byte>(14); }
  /// Type of the cryptographic key (signing or encryption)
  public KeyType KEY_TYPE { get { int o = __p.__offset(16); return o != 0 ? (KeyType)__p.bb.GetSbyte(o + __p.bb_pos) : KeyType.Signing; } }

  public static Offset<CryptoKey> CreateCryptoKey(FlatBufferBuilder builder,
      StringOffset PUBLIC_KEYOffset = default(StringOffset),
      StringOffset XPUBOffset = default(StringOffset),
      StringOffset PRIVATE_KEYOffset = default(StringOffset),
      StringOffset XPRIVOffset = default(StringOffset),
      StringOffset KEY_ADDRESSOffset = default(StringOffset),
      StringOffset ADDRESS_TYPEOffset = default(StringOffset),
      KeyType KEY_TYPE = KeyType.Signing) {
    builder.StartTable(7);
    CryptoKey.AddADDRESS_TYPE(builder, ADDRESS_TYPEOffset);
    CryptoKey.AddKEY_ADDRESS(builder, KEY_ADDRESSOffset);
    CryptoKey.AddXPRIV(builder, XPRIVOffset);
    CryptoKey.AddPRIVATE_KEY(builder, PRIVATE_KEYOffset);
    CryptoKey.AddXPUB(builder, XPUBOffset);
    CryptoKey.AddPUBLIC_KEY(builder, PUBLIC_KEYOffset);
    CryptoKey.AddKEY_TYPE(builder, KEY_TYPE);
    return CryptoKey.EndCryptoKey(builder);
  }

  public static void StartCryptoKey(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddPUBLIC_KEY(FlatBufferBuilder builder, StringOffset PUBLIC_KEYOffset) { builder.AddOffset(0, PUBLIC_KEYOffset.Value, 0); }
  public static void AddXPUB(FlatBufferBuilder builder, StringOffset XPUBOffset) { builder.AddOffset(1, XPUBOffset.Value, 0); }
  public static void AddPRIVATE_KEY(FlatBufferBuilder builder, StringOffset PRIVATE_KEYOffset) { builder.AddOffset(2, PRIVATE_KEYOffset.Value, 0); }
  public static void AddXPRIV(FlatBufferBuilder builder, StringOffset XPRIVOffset) { builder.AddOffset(3, XPRIVOffset.Value, 0); }
  public static void AddKEY_ADDRESS(FlatBufferBuilder builder, StringOffset KEY_ADDRESSOffset) { builder.AddOffset(4, KEY_ADDRESSOffset.Value, 0); }
  public static void AddADDRESS_TYPE(FlatBufferBuilder builder, StringOffset ADDRESS_TYPEOffset) { builder.AddOffset(5, ADDRESS_TYPEOffset.Value, 0); }
  public static void AddKEY_TYPE(FlatBufferBuilder builder, KeyType KEY_TYPE) { builder.AddSbyte(6, (sbyte)KEY_TYPE, 0); }
  public static Offset<CryptoKey> EndCryptoKey(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<CryptoKey>(o);
  }
  public CryptoKeyT UnPack() {
    var _o = new CryptoKeyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(CryptoKeyT _o) {
    _o.PUBLIC_KEY = this.PUBLIC_KEY;
    _o.XPUB = this.XPUB;
    _o.PRIVATE_KEY = this.PRIVATE_KEY;
    _o.XPRIV = this.XPRIV;
    _o.KEY_ADDRESS = this.KEY_ADDRESS;
    _o.ADDRESS_TYPE = this.ADDRESS_TYPE;
    _o.KEY_TYPE = this.KEY_TYPE;
  }
  public static Offset<CryptoKey> Pack(FlatBufferBuilder builder, CryptoKeyT _o) {
    if (_o == null) return default(Offset<CryptoKey>);
    var _PUBLIC_KEY = _o.PUBLIC_KEY == null ? default(StringOffset) : builder.CreateString(_o.PUBLIC_KEY);
    var _XPUB = _o.XPUB == null ? default(StringOffset) : builder.CreateString(_o.XPUB);
    var _PRIVATE_KEY = _o.PRIVATE_KEY == null ? default(StringOffset) : builder.CreateString(_o.PRIVATE_KEY);
    var _XPRIV = _o.XPRIV == null ? default(StringOffset) : builder.CreateString(_o.XPRIV);
    var _KEY_ADDRESS = _o.KEY_ADDRESS == null ? default(StringOffset) : builder.CreateString(_o.KEY_ADDRESS);
    var _ADDRESS_TYPE = _o.ADDRESS_TYPE == null ? default(StringOffset) : builder.CreateString(_o.ADDRESS_TYPE);
    return CreateCryptoKey(
      builder,
      _PUBLIC_KEY,
      _XPUB,
      _PRIVATE_KEY,
      _XPRIV,
      _KEY_ADDRESS,
      _ADDRESS_TYPE,
      _o.KEY_TYPE);
  }
}

public class CryptoKeyT
{
  public string PUBLIC_KEY { get; set; }
  public string XPUB { get; set; }
  public string PRIVATE_KEY { get; set; }
  public string XPRIV { get; set; }
  public string KEY_ADDRESS { get; set; }
  public string ADDRESS_TYPE { get; set; }
  public KeyType KEY_TYPE { get; set; }

  public CryptoKeyT() {
    this.PUBLIC_KEY = null;
    this.XPUB = null;
    this.PRIVATE_KEY = null;
    this.XPRIV = null;
    this.KEY_ADDRESS = null;
    this.ADDRESS_TYPE = null;
    this.KEY_TYPE = KeyType.Signing;
  }
}

