// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Folder container
public struct KMLFolder : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static KMLFolder GetRootAsKMLFolder(ByteBuffer _bb) { return GetRootAsKMLFolder(_bb, new KMLFolder()); }
  public static KMLFolder GetRootAsKMLFolder(ByteBuffer _bb, KMLFolder obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public KMLFolder __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Folder name
  public string NAME { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNAMEBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNAMEBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNAMEArray() { return __p.__vector_as_array<byte>(4); }
  /// Description
  public string DESCRIPTION { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDESCRIPTIONBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetDESCRIPTIONBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetDESCRIPTIONArray() { return __p.__vector_as_array<byte>(6); }
  /// Visibility flag
  public bool VISIBILITY { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Whether folder is open in tree view
  public bool OPEN { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Placemarks in this folder
  public KMLPlacemark? PLACEMARKS(int j) { int o = __p.__offset(12); return o != 0 ? (KMLPlacemark?)(new KMLPlacemark()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PLACEMARKSLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Sub-folders
  public KMLFolder? FOLDERS(int j) { int o = __p.__offset(14); return o != 0 ? (KMLFolder?)(new KMLFolder()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int FOLDERSLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Network links
  public KMLNetworkLink? NETWORK_LINKS(int j) { int o = __p.__offset(16); return o != 0 ? (KMLNetworkLink?)(new KMLNetworkLink()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int NETWORK_LINKSLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
  /// Ground overlays
  public KMLGroundOverlay? GROUND_OVERLAYS(int j) { int o = __p.__offset(18); return o != 0 ? (KMLGroundOverlay?)(new KMLGroundOverlay()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int GROUND_OVERLAYSLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<KMLFolder> CreateKMLFolder(FlatBufferBuilder builder,
      StringOffset NAMEOffset = default(StringOffset),
      StringOffset DESCRIPTIONOffset = default(StringOffset),
      bool VISIBILITY = false,
      bool OPEN = false,
      VectorOffset PLACEMARKSOffset = default(VectorOffset),
      VectorOffset FOLDERSOffset = default(VectorOffset),
      VectorOffset NETWORK_LINKSOffset = default(VectorOffset),
      VectorOffset GROUND_OVERLAYSOffset = default(VectorOffset)) {
    builder.StartTable(8);
    KMLFolder.AddGROUND_OVERLAYS(builder, GROUND_OVERLAYSOffset);
    KMLFolder.AddNETWORK_LINKS(builder, NETWORK_LINKSOffset);
    KMLFolder.AddFOLDERS(builder, FOLDERSOffset);
    KMLFolder.AddPLACEMARKS(builder, PLACEMARKSOffset);
    KMLFolder.AddDESCRIPTION(builder, DESCRIPTIONOffset);
    KMLFolder.AddNAME(builder, NAMEOffset);
    KMLFolder.AddOPEN(builder, OPEN);
    KMLFolder.AddVISIBILITY(builder, VISIBILITY);
    return KMLFolder.EndKMLFolder(builder);
  }

  public static void StartKMLFolder(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddNAME(FlatBufferBuilder builder, StringOffset NAMEOffset) { builder.AddOffset(0, NAMEOffset.Value, 0); }
  public static void AddDESCRIPTION(FlatBufferBuilder builder, StringOffset DESCRIPTIONOffset) { builder.AddOffset(1, DESCRIPTIONOffset.Value, 0); }
  public static void AddVISIBILITY(FlatBufferBuilder builder, bool VISIBILITY) { builder.AddBool(2, VISIBILITY, false); }
  public static void AddOPEN(FlatBufferBuilder builder, bool OPEN) { builder.AddBool(3, OPEN, false); }
  public static void AddPLACEMARKS(FlatBufferBuilder builder, VectorOffset PLACEMARKSOffset) { builder.AddOffset(4, PLACEMARKSOffset.Value, 0); }
  public static VectorOffset CreatePLACEMARKSVector(FlatBufferBuilder builder, Offset<KMLPlacemark>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, Offset<KMLPlacemark>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLPlacemark>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePLACEMARKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLPlacemark>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPLACEMARKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddFOLDERS(FlatBufferBuilder builder, VectorOffset FOLDERSOffset) { builder.AddOffset(5, FOLDERSOffset.Value, 0); }
  public static VectorOffset CreateFOLDERSVector(FlatBufferBuilder builder, Offset<KMLFolder>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, Offset<KMLFolder>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLFolder>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateFOLDERSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLFolder>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartFOLDERSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddNETWORK_LINKS(FlatBufferBuilder builder, VectorOffset NETWORK_LINKSOffset) { builder.AddOffset(6, NETWORK_LINKSOffset.Value, 0); }
  public static VectorOffset CreateNETWORK_LINKSVector(FlatBufferBuilder builder, Offset<KMLNetworkLink>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, Offset<KMLNetworkLink>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLNetworkLink>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNETWORK_LINKSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLNetworkLink>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNETWORK_LINKSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGROUND_OVERLAYS(FlatBufferBuilder builder, VectorOffset GROUND_OVERLAYSOffset) { builder.AddOffset(7, GROUND_OVERLAYSOffset.Value, 0); }
  public static VectorOffset CreateGROUND_OVERLAYSVector(FlatBufferBuilder builder, Offset<KMLGroundOverlay>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, Offset<KMLGroundOverlay>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLGroundOverlay>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGROUND_OVERLAYSVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLGroundOverlay>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartGROUND_OVERLAYSVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<KMLFolder> EndKMLFolder(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<KMLFolder>(o);
  }
  public KMLFolderT UnPack() {
    var _o = new KMLFolderT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(KMLFolderT _o) {
    _o.NAME = this.NAME;
    _o.DESCRIPTION = this.DESCRIPTION;
    _o.VISIBILITY = this.VISIBILITY;
    _o.OPEN = this.OPEN;
    _o.PLACEMARKS = new List<KMLPlacemarkT>();
    for (var _j = 0; _j < this.PLACEMARKSLength; ++_j) {_o.PLACEMARKS.Add(this.PLACEMARKS(_j).HasValue ? this.PLACEMARKS(_j).Value.UnPack() : null);}
    _o.FOLDERS = new List<KMLFolderT>();
    for (var _j = 0; _j < this.FOLDERSLength; ++_j) {_o.FOLDERS.Add(this.FOLDERS(_j).HasValue ? this.FOLDERS(_j).Value.UnPack() : null);}
    _o.NETWORK_LINKS = new List<KMLNetworkLinkT>();
    for (var _j = 0; _j < this.NETWORK_LINKSLength; ++_j) {_o.NETWORK_LINKS.Add(this.NETWORK_LINKS(_j).HasValue ? this.NETWORK_LINKS(_j).Value.UnPack() : null);}
    _o.GROUND_OVERLAYS = new List<KMLGroundOverlayT>();
    for (var _j = 0; _j < this.GROUND_OVERLAYSLength; ++_j) {_o.GROUND_OVERLAYS.Add(this.GROUND_OVERLAYS(_j).HasValue ? this.GROUND_OVERLAYS(_j).Value.UnPack() : null);}
  }
  public static Offset<KMLFolder> Pack(FlatBufferBuilder builder, KMLFolderT _o) {
    if (_o == null) return default(Offset<KMLFolder>);
    var _NAME = _o.NAME == null ? default(StringOffset) : builder.CreateString(_o.NAME);
    var _DESCRIPTION = _o.DESCRIPTION == null ? default(StringOffset) : builder.CreateString(_o.DESCRIPTION);
    var _PLACEMARKS = default(VectorOffset);
    if (_o.PLACEMARKS != null) {
      var __PLACEMARKS = new Offset<KMLPlacemark>[_o.PLACEMARKS.Count];
      for (var _j = 0; _j < __PLACEMARKS.Length; ++_j) { __PLACEMARKS[_j] = KMLPlacemark.Pack(builder, _o.PLACEMARKS[_j]); }
      _PLACEMARKS = CreatePLACEMARKSVector(builder, __PLACEMARKS);
    }
    var _FOLDERS = default(VectorOffset);
    if (_o.FOLDERS != null) {
      var __FOLDERS = new Offset<KMLFolder>[_o.FOLDERS.Count];
      for (var _j = 0; _j < __FOLDERS.Length; ++_j) { __FOLDERS[_j] = KMLFolder.Pack(builder, _o.FOLDERS[_j]); }
      _FOLDERS = CreateFOLDERSVector(builder, __FOLDERS);
    }
    var _NETWORK_LINKS = default(VectorOffset);
    if (_o.NETWORK_LINKS != null) {
      var __NETWORK_LINKS = new Offset<KMLNetworkLink>[_o.NETWORK_LINKS.Count];
      for (var _j = 0; _j < __NETWORK_LINKS.Length; ++_j) { __NETWORK_LINKS[_j] = KMLNetworkLink.Pack(builder, _o.NETWORK_LINKS[_j]); }
      _NETWORK_LINKS = CreateNETWORK_LINKSVector(builder, __NETWORK_LINKS);
    }
    var _GROUND_OVERLAYS = default(VectorOffset);
    if (_o.GROUND_OVERLAYS != null) {
      var __GROUND_OVERLAYS = new Offset<KMLGroundOverlay>[_o.GROUND_OVERLAYS.Count];
      for (var _j = 0; _j < __GROUND_OVERLAYS.Length; ++_j) { __GROUND_OVERLAYS[_j] = KMLGroundOverlay.Pack(builder, _o.GROUND_OVERLAYS[_j]); }
      _GROUND_OVERLAYS = CreateGROUND_OVERLAYSVector(builder, __GROUND_OVERLAYS);
    }
    return CreateKMLFolder(
      builder,
      _NAME,
      _DESCRIPTION,
      _o.VISIBILITY,
      _o.OPEN,
      _PLACEMARKS,
      _FOLDERS,
      _NETWORK_LINKS,
      _GROUND_OVERLAYS);
  }
}

public class KMLFolderT
{
  public string NAME { get; set; }
  public string DESCRIPTION { get; set; }
  public bool VISIBILITY { get; set; }
  public bool OPEN { get; set; }
  public List<KMLPlacemarkT> PLACEMARKS { get; set; }
  public List<KMLFolderT> FOLDERS { get; set; }
  public List<KMLNetworkLinkT> NETWORK_LINKS { get; set; }
  public List<KMLGroundOverlayT> GROUND_OVERLAYS { get; set; }

  public KMLFolderT() {
    this.NAME = null;
    this.DESCRIPTION = null;
    this.VISIBILITY = false;
    this.OPEN = false;
    this.PLACEMARKS = null;
    this.FOLDERS = null;
    this.NETWORK_LINKS = null;
    this.GROUND_OVERLAYS = null;
  }
}


static public class KMLFolderVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*NAME*/, false)
      && verifier.VerifyString(tablePos, 6 /*DESCRIPTION*/, false)
      && verifier.VerifyField(tablePos, 8 /*VISIBILITY*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*OPEN*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*PLACEMARKS*/, KMLPlacemarkVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*FOLDERS*/, KMLFolderVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 16 /*NETWORK_LINKS*/, KMLNetworkLinkVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 18 /*GROUND_OVERLAYS*/, KMLGroundOverlayVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
