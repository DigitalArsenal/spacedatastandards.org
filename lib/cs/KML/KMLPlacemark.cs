// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Placemark feature
public struct KMLPlacemark : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_3_25(); }
  public static KMLPlacemark GetRootAsKMLPlacemark(ByteBuffer _bb) { return GetRootAsKMLPlacemark(_bb, new KMLPlacemark()); }
  public static KMLPlacemark GetRootAsKMLPlacemark(ByteBuffer _bb, KMLPlacemark obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public KMLPlacemark __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Placemark name
  public string NAME { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNAMEBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNAMEBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNAMEArray() { return __p.__vector_as_array<byte>(4); }
  /// Description (may contain HTML)
  public string DESCRIPTION { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDESCRIPTIONBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetDESCRIPTIONBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetDESCRIPTIONArray() { return __p.__vector_as_array<byte>(6); }
  /// Visibility flag
  public bool VISIBILITY { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  /// Style URL reference
  public string STYLE_URL { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSTYLE_URLBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetSTYLE_URLBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetSTYLE_URLArray() { return __p.__vector_as_array<byte>(10); }
  /// Inline style
  public KMLStyle? STYLE { get { int o = __p.__offset(12); return o != 0 ? (KMLStyle?)(new KMLStyle()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Snippet (short description)
  public string SNIPPET { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSNIPPETBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetSNIPPETBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetSNIPPETArray() { return __p.__vector_as_array<byte>(14); }
  /// Point geometry
  public KMLPoint? POINT { get { int o = __p.__offset(16); return o != 0 ? (KMLPoint?)(new KMLPoint()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// LineString geometry
  public KMLLineString? LINE_STRING { get { int o = __p.__offset(18); return o != 0 ? (KMLLineString?)(new KMLLineString()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Polygon geometry
  public KMLPolygon? POLYGON { get { int o = __p.__offset(20); return o != 0 ? (KMLPolygon?)(new KMLPolygon()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// MultiGeometry
  public KMLMultiGeometry? MULTI_GEOMETRY { get { int o = __p.__offset(22); return o != 0 ? (KMLMultiGeometry?)(new KMLMultiGeometry()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// LookAt viewpoint
  public KMLLookAt? LOOK_AT { get { int o = __p.__offset(24); return o != 0 ? (KMLLookAt?)(new KMLLookAt()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Camera viewpoint
  public KMLCamera? CAMERA { get { int o = __p.__offset(26); return o != 0 ? (KMLCamera?)(new KMLCamera()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// TimeSpan
  public KMLTimeSpan? TIME_SPAN { get { int o = __p.__offset(28); return o != 0 ? (KMLTimeSpan?)(new KMLTimeSpan()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// TimeStamp
  public KMLTimeStamp? TIME_STAMP { get { int o = __p.__offset(30); return o != 0 ? (KMLTimeStamp?)(new KMLTimeStamp()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Extended data
  public KMLData? EXTENDED_DATA(int j) { int o = __p.__offset(32); return o != 0 ? (KMLData?)(new KMLData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int EXTENDED_DATALength { get { int o = __p.__offset(32); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<KMLPlacemark> CreateKMLPlacemark(FlatBufferBuilder builder,
      StringOffset NAMEOffset = default(StringOffset),
      StringOffset DESCRIPTIONOffset = default(StringOffset),
      bool VISIBILITY = false,
      StringOffset STYLE_URLOffset = default(StringOffset),
      Offset<KMLStyle> STYLEOffset = default(Offset<KMLStyle>),
      StringOffset SNIPPETOffset = default(StringOffset),
      Offset<KMLPoint> POINTOffset = default(Offset<KMLPoint>),
      Offset<KMLLineString> LINE_STRINGOffset = default(Offset<KMLLineString>),
      Offset<KMLPolygon> POLYGONOffset = default(Offset<KMLPolygon>),
      Offset<KMLMultiGeometry> MULTI_GEOMETRYOffset = default(Offset<KMLMultiGeometry>),
      Offset<KMLLookAt> LOOK_ATOffset = default(Offset<KMLLookAt>),
      Offset<KMLCamera> CAMERAOffset = default(Offset<KMLCamera>),
      Offset<KMLTimeSpan> TIME_SPANOffset = default(Offset<KMLTimeSpan>),
      Offset<KMLTimeStamp> TIME_STAMPOffset = default(Offset<KMLTimeStamp>),
      VectorOffset EXTENDED_DATAOffset = default(VectorOffset)) {
    builder.StartTable(15);
    KMLPlacemark.AddEXTENDED_DATA(builder, EXTENDED_DATAOffset);
    KMLPlacemark.AddTIME_STAMP(builder, TIME_STAMPOffset);
    KMLPlacemark.AddTIME_SPAN(builder, TIME_SPANOffset);
    KMLPlacemark.AddCAMERA(builder, CAMERAOffset);
    KMLPlacemark.AddLOOK_AT(builder, LOOK_ATOffset);
    KMLPlacemark.AddMULTI_GEOMETRY(builder, MULTI_GEOMETRYOffset);
    KMLPlacemark.AddPOLYGON(builder, POLYGONOffset);
    KMLPlacemark.AddLINE_STRING(builder, LINE_STRINGOffset);
    KMLPlacemark.AddPOINT(builder, POINTOffset);
    KMLPlacemark.AddSNIPPET(builder, SNIPPETOffset);
    KMLPlacemark.AddSTYLE(builder, STYLEOffset);
    KMLPlacemark.AddSTYLE_URL(builder, STYLE_URLOffset);
    KMLPlacemark.AddDESCRIPTION(builder, DESCRIPTIONOffset);
    KMLPlacemark.AddNAME(builder, NAMEOffset);
    KMLPlacemark.AddVISIBILITY(builder, VISIBILITY);
    return KMLPlacemark.EndKMLPlacemark(builder);
  }

  public static void StartKMLPlacemark(FlatBufferBuilder builder) { builder.StartTable(15); }
  public static void AddNAME(FlatBufferBuilder builder, StringOffset NAMEOffset) { builder.AddOffset(0, NAMEOffset.Value, 0); }
  public static void AddDESCRIPTION(FlatBufferBuilder builder, StringOffset DESCRIPTIONOffset) { builder.AddOffset(1, DESCRIPTIONOffset.Value, 0); }
  public static void AddVISIBILITY(FlatBufferBuilder builder, bool VISIBILITY) { builder.AddBool(2, VISIBILITY, false); }
  public static void AddSTYLE_URL(FlatBufferBuilder builder, StringOffset STYLE_URLOffset) { builder.AddOffset(3, STYLE_URLOffset.Value, 0); }
  public static void AddSTYLE(FlatBufferBuilder builder, Offset<KMLStyle> STYLEOffset) { builder.AddOffset(4, STYLEOffset.Value, 0); }
  public static void AddSNIPPET(FlatBufferBuilder builder, StringOffset SNIPPETOffset) { builder.AddOffset(5, SNIPPETOffset.Value, 0); }
  public static void AddPOINT(FlatBufferBuilder builder, Offset<KMLPoint> POINTOffset) { builder.AddOffset(6, POINTOffset.Value, 0); }
  public static void AddLINE_STRING(FlatBufferBuilder builder, Offset<KMLLineString> LINE_STRINGOffset) { builder.AddOffset(7, LINE_STRINGOffset.Value, 0); }
  public static void AddPOLYGON(FlatBufferBuilder builder, Offset<KMLPolygon> POLYGONOffset) { builder.AddOffset(8, POLYGONOffset.Value, 0); }
  public static void AddMULTI_GEOMETRY(FlatBufferBuilder builder, Offset<KMLMultiGeometry> MULTI_GEOMETRYOffset) { builder.AddOffset(9, MULTI_GEOMETRYOffset.Value, 0); }
  public static void AddLOOK_AT(FlatBufferBuilder builder, Offset<KMLLookAt> LOOK_ATOffset) { builder.AddOffset(10, LOOK_ATOffset.Value, 0); }
  public static void AddCAMERA(FlatBufferBuilder builder, Offset<KMLCamera> CAMERAOffset) { builder.AddOffset(11, CAMERAOffset.Value, 0); }
  public static void AddTIME_SPAN(FlatBufferBuilder builder, Offset<KMLTimeSpan> TIME_SPANOffset) { builder.AddOffset(12, TIME_SPANOffset.Value, 0); }
  public static void AddTIME_STAMP(FlatBufferBuilder builder, Offset<KMLTimeStamp> TIME_STAMPOffset) { builder.AddOffset(13, TIME_STAMPOffset.Value, 0); }
  public static void AddEXTENDED_DATA(FlatBufferBuilder builder, VectorOffset EXTENDED_DATAOffset) { builder.AddOffset(14, EXTENDED_DATAOffset.Value, 0); }
  public static VectorOffset CreateEXTENDED_DATAVector(FlatBufferBuilder builder, Offset<KMLData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateEXTENDED_DATAVectorBlock(FlatBufferBuilder builder, Offset<KMLData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEXTENDED_DATAVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<KMLData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateEXTENDED_DATAVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<KMLData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartEXTENDED_DATAVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<KMLPlacemark> EndKMLPlacemark(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<KMLPlacemark>(o);
  }
  public KMLPlacemarkT UnPack() {
    var _o = new KMLPlacemarkT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(KMLPlacemarkT _o) {
    _o.NAME = this.NAME;
    _o.DESCRIPTION = this.DESCRIPTION;
    _o.VISIBILITY = this.VISIBILITY;
    _o.STYLE_URL = this.STYLE_URL;
    _o.STYLE = this.STYLE.HasValue ? this.STYLE.Value.UnPack() : null;
    _o.SNIPPET = this.SNIPPET;
    _o.POINT = this.POINT.HasValue ? this.POINT.Value.UnPack() : null;
    _o.LINE_STRING = this.LINE_STRING.HasValue ? this.LINE_STRING.Value.UnPack() : null;
    _o.POLYGON = this.POLYGON.HasValue ? this.POLYGON.Value.UnPack() : null;
    _o.MULTI_GEOMETRY = this.MULTI_GEOMETRY.HasValue ? this.MULTI_GEOMETRY.Value.UnPack() : null;
    _o.LOOK_AT = this.LOOK_AT.HasValue ? this.LOOK_AT.Value.UnPack() : null;
    _o.CAMERA = this.CAMERA.HasValue ? this.CAMERA.Value.UnPack() : null;
    _o.TIME_SPAN = this.TIME_SPAN.HasValue ? this.TIME_SPAN.Value.UnPack() : null;
    _o.TIME_STAMP = this.TIME_STAMP.HasValue ? this.TIME_STAMP.Value.UnPack() : null;
    _o.EXTENDED_DATA = new List<KMLDataT>();
    for (var _j = 0; _j < this.EXTENDED_DATALength; ++_j) {_o.EXTENDED_DATA.Add(this.EXTENDED_DATA(_j).HasValue ? this.EXTENDED_DATA(_j).Value.UnPack() : null);}
  }
  public static Offset<KMLPlacemark> Pack(FlatBufferBuilder builder, KMLPlacemarkT _o) {
    if (_o == null) return default(Offset<KMLPlacemark>);
    var _NAME = _o.NAME == null ? default(StringOffset) : builder.CreateString(_o.NAME);
    var _DESCRIPTION = _o.DESCRIPTION == null ? default(StringOffset) : builder.CreateString(_o.DESCRIPTION);
    var _STYLE_URL = _o.STYLE_URL == null ? default(StringOffset) : builder.CreateString(_o.STYLE_URL);
    var _STYLE = _o.STYLE == null ? default(Offset<KMLStyle>) : KMLStyle.Pack(builder, _o.STYLE);
    var _SNIPPET = _o.SNIPPET == null ? default(StringOffset) : builder.CreateString(_o.SNIPPET);
    var _POINT = _o.POINT == null ? default(Offset<KMLPoint>) : KMLPoint.Pack(builder, _o.POINT);
    var _LINE_STRING = _o.LINE_STRING == null ? default(Offset<KMLLineString>) : KMLLineString.Pack(builder, _o.LINE_STRING);
    var _POLYGON = _o.POLYGON == null ? default(Offset<KMLPolygon>) : KMLPolygon.Pack(builder, _o.POLYGON);
    var _MULTI_GEOMETRY = _o.MULTI_GEOMETRY == null ? default(Offset<KMLMultiGeometry>) : KMLMultiGeometry.Pack(builder, _o.MULTI_GEOMETRY);
    var _LOOK_AT = _o.LOOK_AT == null ? default(Offset<KMLLookAt>) : KMLLookAt.Pack(builder, _o.LOOK_AT);
    var _CAMERA = _o.CAMERA == null ? default(Offset<KMLCamera>) : KMLCamera.Pack(builder, _o.CAMERA);
    var _TIME_SPAN = _o.TIME_SPAN == null ? default(Offset<KMLTimeSpan>) : KMLTimeSpan.Pack(builder, _o.TIME_SPAN);
    var _TIME_STAMP = _o.TIME_STAMP == null ? default(Offset<KMLTimeStamp>) : KMLTimeStamp.Pack(builder, _o.TIME_STAMP);
    var _EXTENDED_DATA = default(VectorOffset);
    if (_o.EXTENDED_DATA != null) {
      var __EXTENDED_DATA = new Offset<KMLData>[_o.EXTENDED_DATA.Count];
      for (var _j = 0; _j < __EXTENDED_DATA.Length; ++_j) { __EXTENDED_DATA[_j] = KMLData.Pack(builder, _o.EXTENDED_DATA[_j]); }
      _EXTENDED_DATA = CreateEXTENDED_DATAVector(builder, __EXTENDED_DATA);
    }
    return CreateKMLPlacemark(
      builder,
      _NAME,
      _DESCRIPTION,
      _o.VISIBILITY,
      _STYLE_URL,
      _STYLE,
      _SNIPPET,
      _POINT,
      _LINE_STRING,
      _POLYGON,
      _MULTI_GEOMETRY,
      _LOOK_AT,
      _CAMERA,
      _TIME_SPAN,
      _TIME_STAMP,
      _EXTENDED_DATA);
  }
}

public class KMLPlacemarkT
{
  public string NAME { get; set; }
  public string DESCRIPTION { get; set; }
  public bool VISIBILITY { get; set; }
  public string STYLE_URL { get; set; }
  public KMLStyleT STYLE { get; set; }
  public string SNIPPET { get; set; }
  public KMLPointT POINT { get; set; }
  public KMLLineStringT LINE_STRING { get; set; }
  public KMLPolygonT POLYGON { get; set; }
  public KMLMultiGeometryT MULTI_GEOMETRY { get; set; }
  public KMLLookAtT LOOK_AT { get; set; }
  public KMLCameraT CAMERA { get; set; }
  public KMLTimeSpanT TIME_SPAN { get; set; }
  public KMLTimeStampT TIME_STAMP { get; set; }
  public List<KMLDataT> EXTENDED_DATA { get; set; }

  public KMLPlacemarkT() {
    this.NAME = null;
    this.DESCRIPTION = null;
    this.VISIBILITY = false;
    this.STYLE_URL = null;
    this.STYLE = null;
    this.SNIPPET = null;
    this.POINT = null;
    this.LINE_STRING = null;
    this.POLYGON = null;
    this.MULTI_GEOMETRY = null;
    this.LOOK_AT = null;
    this.CAMERA = null;
    this.TIME_SPAN = null;
    this.TIME_STAMP = null;
    this.EXTENDED_DATA = null;
  }
}


static public class KMLPlacemarkVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*NAME*/, false)
      && verifier.VerifyString(tablePos, 6 /*DESCRIPTION*/, false)
      && verifier.VerifyField(tablePos, 8 /*VISIBILITY*/, 1 /*bool*/, 1, false)
      && verifier.VerifyString(tablePos, 10 /*STYLE_URL*/, false)
      && verifier.VerifyTable(tablePos, 12 /*STYLE*/, KMLStyleVerify.Verify, false)
      && verifier.VerifyString(tablePos, 14 /*SNIPPET*/, false)
      && verifier.VerifyTable(tablePos, 16 /*POINT*/, KMLPointVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 18 /*LINE_STRING*/, KMLLineStringVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 20 /*POLYGON*/, KMLPolygonVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 22 /*MULTI_GEOMETRY*/, KMLMultiGeometryVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 24 /*LOOK_AT*/, KMLLookAtVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 26 /*CAMERA*/, KMLCameraVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 28 /*TIME_SPAN*/, KMLTimeSpanVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 30 /*TIME_STAMP*/, KMLTimeStampVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 32 /*EXTENDED_DATA*/, KMLDataVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}
