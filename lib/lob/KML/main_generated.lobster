// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum KMLAltitudeMode:
    /// Altitude relative to ground surface
    KMLAltitudeMode_CLAMP_TO_GROUND = 0
    /// Altitude relative to ground elevation
    KMLAltitudeMode_RELATIVE_TO_GROUND = 1
    /// Altitude as absolute meters above WGS84 ellipsoid
    KMLAltitudeMode_ABSOLUTE = 2
    /// Clamp to sea floor
    KMLAltitudeMode_CLAMP_TO_SEA_FLOOR = 3
    /// Relative to sea floor
    KMLAltitudeMode_RELATIVE_TO_SEA_FLOOR = 4

enum KMLColorMode:
    KMLColorMode_NORMAL = 0
    KMLColorMode_RANDOM = 1

enum KMLStyleState:
    KMLStyleState_NORMAL = 0
    KMLStyleState_HIGHLIGHT = 1

enum KMLUnits:
    KMLUnits_PIXELS = 0
    KMLUnits_FRACTION = 1
    KMLUnits_INSET_PIXELS = 2

enum KMLRefreshMode:
    KMLRefreshMode_ON_CHANGE = 0
    KMLRefreshMode_ON_INTERVAL = 1
    KMLRefreshMode_ON_EXPIRE = 2

enum KMLViewRefreshMode:
    KMLViewRefreshMode_NEVER = 0
    KMLViewRefreshMode_ON_STOP = 1
    KMLViewRefreshMode_ON_REQUEST = 2
    KMLViewRefreshMode_ON_REGION = 3

class KMLCoordinate

class KMLLookAt

class KMLCamera

class KMLIconStyle

class KMLLineStyle

class KMLPolyStyle

class KMLLabelStyle

class KMLBalloonStyle

class KMLStyle

class KMLStyleMapPair

class KMLStyleMap

class KMLPoint

class KMLLineString

class KMLLinearRing

class KMLPolygon

class KMLMultiGeometry

class KMLTimeSpan

class KMLTimeStamp

class KMLData

class KMLNetworkLink

class KMLGroundOverlay

class KMLPlacemark

class KMLFolder

class KML

/// KML coordinate (longitude, latitude, optional altitude)
class KMLCoordinate : flatbuffers.handle
    /// Longitude in decimal degrees
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Latitude in decimal degrees
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Altitude in meters
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsKMLCoordinate(buf:string): return KMLCoordinate { buf, flatbuffers.indirect(buf, 0) }

struct KMLCoordinateBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(0, LONGITUDE, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(1, LATITUDE, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(2, ALTITUDE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// LookAt viewpoint
class KMLLookAt : flatbuffers.handle
    /// Longitude of the point being looked at
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Latitude of the point being looked at
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Altitude of the point being looked at
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Heading in degrees (0=North)
    def HEADING() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Tilt in degrees from vertical (0=straight down)
    def TILT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Range in meters from the point
    def RANGE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsKMLLookAt(buf:string): return KMLLookAt { buf, flatbuffers.indirect(buf, 0) }

struct KMLLookAtBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(0, LONGITUDE, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(1, LATITUDE, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(2, ALTITUDE, 0.0)
        return this
    def add_HEADING(HEADING:float):
        b_.PrependFloat64Slot(3, HEADING, 0.0)
        return this
    def add_TILT(TILT:float):
        b_.PrependFloat64Slot(4, TILT, 0.0)
        return this
    def add_RANGE(RANGE:float):
        b_.PrependFloat64Slot(5, RANGE, 0.0)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(6, ALTITUDE_MODE, 0)
        return this
    def end():
        return b_.EndObject()

/// Camera viewpoint
class KMLCamera : flatbuffers.handle
    /// Camera longitude
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Camera latitude
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Camera altitude
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Heading in degrees (0=North)
    def HEADING() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Tilt in degrees from vertical
    def TILT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Roll in degrees
    def ROLL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsKMLCamera(buf:string): return KMLCamera { buf, flatbuffers.indirect(buf, 0) }

struct KMLCameraBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(0, LONGITUDE, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(1, LATITUDE, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(2, ALTITUDE, 0.0)
        return this
    def add_HEADING(HEADING:float):
        b_.PrependFloat64Slot(3, HEADING, 0.0)
        return this
    def add_TILT(TILT:float):
        b_.PrependFloat64Slot(4, TILT, 0.0)
        return this
    def add_ROLL(ROLL:float):
        b_.PrependFloat64Slot(5, ROLL, 0.0)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(6, ALTITUDE_MODE, 0)
        return this
    def end():
        return b_.EndObject()

/// Icon style
class KMLIconStyle : flatbuffers.handle
    /// KML color in aabbggrr hex format
    def COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Color mode
    def COLOR_MODE() -> KMLColorMode:
        return KMLColorMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Heading in degrees
    def HEADING() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Icon href (URL)
    def ICON_HREF() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Hot spot X value
    def HOTSPOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Hot spot Y value
    def HOTSPOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Hot spot X units
    def HOTSPOT_X_UNITS() -> KMLUnits:
        return KMLUnits(flatbuffers.field_int8(buf_, pos_, 18, 0))
    /// Hot spot Y units
    def HOTSPOT_Y_UNITS() -> KMLUnits:
        return KMLUnits(flatbuffers.field_int8(buf_, pos_, 20, 0))

def GetRootAsKMLIconStyle(buf:string): return KMLIconStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLIconStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COLOR)
        return this
    def add_COLOR_MODE(COLOR_MODE:KMLColorMode):
        b_.PrependInt8Slot(1, COLOR_MODE, 0)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(2, SCALE, 0.0)
        return this
    def add_HEADING(HEADING:float):
        b_.PrependFloat64Slot(3, HEADING, 0.0)
        return this
    def add_ICON_HREF(ICON_HREF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ICON_HREF)
        return this
    def add_HOTSPOT_X(HOTSPOT_X:float):
        b_.PrependFloat64Slot(5, HOTSPOT_X, 0.0)
        return this
    def add_HOTSPOT_Y(HOTSPOT_Y:float):
        b_.PrependFloat64Slot(6, HOTSPOT_Y, 0.0)
        return this
    def add_HOTSPOT_X_UNITS(HOTSPOT_X_UNITS:KMLUnits):
        b_.PrependInt8Slot(7, HOTSPOT_X_UNITS, 0)
        return this
    def add_HOTSPOT_Y_UNITS(HOTSPOT_Y_UNITS:KMLUnits):
        b_.PrependInt8Slot(8, HOTSPOT_Y_UNITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Line style
class KMLLineStyle : flatbuffers.handle
    /// KML color in aabbggrr hex format
    def COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Color mode
    def COLOR_MODE() -> KMLColorMode:
        return KMLColorMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Width in pixels
    def WIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsKMLLineStyle(buf:string): return KMLLineStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLLineStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COLOR)
        return this
    def add_COLOR_MODE(COLOR_MODE:KMLColorMode):
        b_.PrependInt8Slot(1, COLOR_MODE, 0)
        return this
    def add_WIDTH(WIDTH:float):
        b_.PrependFloat64Slot(2, WIDTH, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Polygon style
class KMLPolyStyle : flatbuffers.handle
    /// KML color in aabbggrr hex format
    def COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Color mode
    def COLOR_MODE() -> KMLColorMode:
        return KMLColorMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Whether to fill
    def FILL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Whether to outline
    def OUTLINE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))

def GetRootAsKMLPolyStyle(buf:string): return KMLPolyStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLPolyStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COLOR)
        return this
    def add_COLOR_MODE(COLOR_MODE:KMLColorMode):
        b_.PrependInt8Slot(1, COLOR_MODE, 0)
        return this
    def add_FILL(FILL:bool):
        b_.PrependBoolSlot(2, FILL, 0)
        return this
    def add_OUTLINE(OUTLINE:bool):
        b_.PrependBoolSlot(3, OUTLINE, 0)
        return this
    def end():
        return b_.EndObject()

/// Label style
class KMLLabelStyle : flatbuffers.handle
    /// KML color in aabbggrr hex format
    def COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Color mode
    def COLOR_MODE() -> KMLColorMode:
        return KMLColorMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsKMLLabelStyle(buf:string): return KMLLabelStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLLabelStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COLOR)
        return this
    def add_COLOR_MODE(COLOR_MODE:KMLColorMode):
        b_.PrependInt8Slot(1, COLOR_MODE, 0)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(2, SCALE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Balloon style
class KMLBalloonStyle : flatbuffers.handle
    /// Background color in aabbggrr hex format
    def BG_COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Text color in aabbggrr hex format
    def TEXT_COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Balloon text template (supports $[name], $[description])
    def TEXT() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsKMLBalloonStyle(buf:string): return KMLBalloonStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLBalloonStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_BG_COLOR(BG_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, BG_COLOR)
        return this
    def add_TEXT_COLOR(TEXT_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, TEXT_COLOR)
        return this
    def add_TEXT(TEXT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, TEXT)
        return this
    def end():
        return b_.EndObject()

/// Style definition
class KMLStyle : flatbuffers.handle
    /// Style identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Icon style
    def ICON_STYLE() -> KMLIconStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: KMLIconStyle { buf_, o } else: nil
    /// Label style
    def LABEL_STYLE() -> KMLLabelStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: KMLLabelStyle { buf_, o } else: nil
    /// Line style
    def LINE_STYLE() -> KMLLineStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: KMLLineStyle { buf_, o } else: nil
    /// Polygon style
    def POLY_STYLE() -> KMLPolyStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: KMLPolyStyle { buf_, o } else: nil
    /// Balloon style
    def BALLOON_STYLE() -> KMLBalloonStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: KMLBalloonStyle { buf_, o } else: nil

def GetRootAsKMLStyle(buf:string): return KMLStyle { buf, flatbuffers.indirect(buf, 0) }

struct KMLStyleBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_ICON_STYLE(ICON_STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ICON_STYLE)
        return this
    def add_LABEL_STYLE(LABEL_STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LABEL_STYLE)
        return this
    def add_LINE_STYLE(LINE_STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LINE_STYLE)
        return this
    def add_POLY_STYLE(POLY_STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, POLY_STYLE)
        return this
    def add_BALLOON_STYLE(BALLOON_STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, BALLOON_STYLE)
        return this
    def end():
        return b_.EndObject()

/// Style map pair
class KMLStyleMapPair : flatbuffers.handle
    /// State (normal or highlight)
    def STATE() -> KMLStyleState:
        return KMLStyleState(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Style URL or inline style ID
    def STYLE_URL() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsKMLStyleMapPair(buf:string): return KMLStyleMapPair { buf, flatbuffers.indirect(buf, 0) }

struct KMLStyleMapPairBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_STATE(STATE:KMLStyleState):
        b_.PrependInt8Slot(0, STATE, 0)
        return this
    def add_STYLE_URL(STYLE_URL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, STYLE_URL)
        return this
    def end():
        return b_.EndObject()

/// Style map (normal/highlight pair)
class KMLStyleMap : flatbuffers.handle
    /// Style map identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Pairs
    def PAIRS(i:int) -> KMLStyleMapPair:
        return KMLStyleMapPair { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def PAIRS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)

def GetRootAsKMLStyleMap(buf:string): return KMLStyleMap { buf, flatbuffers.indirect(buf, 0) }

struct KMLStyleMapBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_PAIRS(PAIRS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PAIRS)
        return this
    def end():
        return b_.EndObject()

def KMLStyleMapStartPAIRSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLStyleMapCreatePAIRSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Point geometry
class KMLPoint : flatbuffers.handle
    /// Coordinate
    def COORDINATES() -> KMLCoordinate?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: KMLCoordinate { buf_, o } else: nil
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Whether to extrude to ground
    def EXTRUDE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))

def GetRootAsKMLPoint(buf:string): return KMLPoint { buf, flatbuffers.indirect(buf, 0) }

struct KMLPointBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_COORDINATES(COORDINATES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COORDINATES)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(1, ALTITUDE_MODE, 0)
        return this
    def add_EXTRUDE(EXTRUDE:bool):
        b_.PrependBoolSlot(2, EXTRUDE, 0)
        return this
    def end():
        return b_.EndObject()

/// LineString geometry
class KMLLineString : flatbuffers.handle
    /// Coordinates
    def COORDINATES(i:int) -> KMLCoordinate:
        return KMLCoordinate { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def COORDINATES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Whether to extrude to ground
    def EXTRUDE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Whether to tessellate (follow terrain)
    def TESSELLATE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))

def GetRootAsKMLLineString(buf:string): return KMLLineString { buf, flatbuffers.indirect(buf, 0) }

struct KMLLineStringBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_COORDINATES(COORDINATES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COORDINATES)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(1, ALTITUDE_MODE, 0)
        return this
    def add_EXTRUDE(EXTRUDE:bool):
        b_.PrependBoolSlot(2, EXTRUDE, 0)
        return this
    def add_TESSELLATE(TESSELLATE:bool):
        b_.PrependBoolSlot(3, TESSELLATE, 0)
        return this
    def end():
        return b_.EndObject()

def KMLLineStringStartCOORDINATESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLLineStringCreateCOORDINATESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// LinearRing geometry
class KMLLinearRing : flatbuffers.handle
    /// Coordinates (first = last to close the ring)
    def COORDINATES(i:int) -> KMLCoordinate:
        return KMLCoordinate { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def COORDINATES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsKMLLinearRing(buf:string): return KMLLinearRing { buf, flatbuffers.indirect(buf, 0) }

struct KMLLinearRingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_COORDINATES(COORDINATES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COORDINATES)
        return this
    def end():
        return b_.EndObject()

def KMLLinearRingStartCOORDINATESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLLinearRingCreateCOORDINATESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Polygon geometry
class KMLPolygon : flatbuffers.handle
    /// Outer boundary
    def OUTER_BOUNDARY() -> KMLLinearRing?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: KMLLinearRing { buf_, o } else: nil
    /// Inner boundaries (holes)
    def INNER_BOUNDARIES(i:int) -> KMLLinearRing:
        return KMLLinearRing { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def INNER_BOUNDARIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Whether to extrude to ground
    def EXTRUDE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Whether to tessellate
    def TESSELLATE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))

def GetRootAsKMLPolygon(buf:string): return KMLPolygon { buf, flatbuffers.indirect(buf, 0) }

struct KMLPolygonBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_OUTER_BOUNDARY(OUTER_BOUNDARY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, OUTER_BOUNDARY)
        return this
    def add_INNER_BOUNDARIES(INNER_BOUNDARIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, INNER_BOUNDARIES)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(2, ALTITUDE_MODE, 0)
        return this
    def add_EXTRUDE(EXTRUDE:bool):
        b_.PrependBoolSlot(3, EXTRUDE, 0)
        return this
    def add_TESSELLATE(TESSELLATE:bool):
        b_.PrependBoolSlot(4, TESSELLATE, 0)
        return this
    def end():
        return b_.EndObject()

def KMLPolygonStartINNER_BOUNDARIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLPolygonCreateINNER_BOUNDARIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// MultiGeometry
class KMLMultiGeometry : flatbuffers.handle
    /// Child points
    def POINTS(i:int) -> KMLPoint:
        return KMLPoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def POINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Child line strings
    def LINE_STRINGS(i:int) -> KMLLineString:
        return KMLLineString { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def LINE_STRINGS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Child polygons
    def POLYGONS(i:int) -> KMLPolygon:
        return KMLPolygon { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def POLYGONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Nested multi-geometries
    def MULTI_GEOMETRIES(i:int) -> KMLMultiGeometry:
        return KMLMultiGeometry { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def MULTI_GEOMETRIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)

def GetRootAsKMLMultiGeometry(buf:string): return KMLMultiGeometry { buf, flatbuffers.indirect(buf, 0) }

struct KMLMultiGeometryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_POINTS(POINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, POINTS)
        return this
    def add_LINE_STRINGS(LINE_STRINGS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LINE_STRINGS)
        return this
    def add_POLYGONS(POLYGONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, POLYGONS)
        return this
    def add_MULTI_GEOMETRIES(MULTI_GEOMETRIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, MULTI_GEOMETRIES)
        return this
    def end():
        return b_.EndObject()

def KMLMultiGeometryStartPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLMultiGeometryCreatePOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLMultiGeometryStartLINE_STRINGSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLMultiGeometryCreateLINE_STRINGSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLMultiGeometryStartPOLYGONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLMultiGeometryCreatePOLYGONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLMultiGeometryStartMULTI_GEOMETRIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLMultiGeometryCreateMULTI_GEOMETRIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// TimeSpan
class KMLTimeSpan : flatbuffers.handle
    /// Begin time (ISO 8601)
    def BEGIN() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// End time (ISO 8601)
    def END() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsKMLTimeSpan(buf:string): return KMLTimeSpan { buf, flatbuffers.indirect(buf, 0) }

struct KMLTimeSpanBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_BEGIN(BEGIN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, BEGIN)
        return this
    def add_END(END:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, END)
        return this
    def end():
        return b_.EndObject()

/// TimeStamp
class KMLTimeStamp : flatbuffers.handle
    /// Time (ISO 8601)
    def WHEN() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)

def GetRootAsKMLTimeStamp(buf:string): return KMLTimeStamp { buf, flatbuffers.indirect(buf, 0) }

struct KMLTimeStampBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_WHEN(WHEN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, WHEN)
        return this
    def end():
        return b_.EndObject()

/// Extended data key-value pair
class KMLData : flatbuffers.handle
    /// Data name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Display name
    def DISPLAY_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Data value
    def VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsKMLData(buf:string): return KMLData { buf, flatbuffers.indirect(buf, 0) }

struct KMLDataBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DISPLAY_NAME(DISPLAY_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DISPLAY_NAME)
        return this
    def add_VALUE(VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, VALUE)
        return this
    def end():
        return b_.EndObject()

/// Network link
class KMLNetworkLink : flatbuffers.handle
    /// Name of the network link
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Whether the link is visible
    def VISIBILITY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Link URL
    def HREF() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Refresh mode
    def REFRESH_MODE() -> KMLRefreshMode:
        return KMLRefreshMode(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Refresh interval in seconds
    def REFRESH_INTERVAL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// View refresh mode
    def VIEW_REFRESH_MODE() -> KMLViewRefreshMode:
        return KMLViewRefreshMode(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// View refresh time in seconds
    def VIEW_REFRESH_TIME() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)

def GetRootAsKMLNetworkLink(buf:string): return KMLNetworkLink { buf, flatbuffers.indirect(buf, 0) }

struct KMLNetworkLinkBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_VISIBILITY(VISIBILITY:bool):
        b_.PrependBoolSlot(1, VISIBILITY, 0)
        return this
    def add_HREF(HREF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, HREF)
        return this
    def add_REFRESH_MODE(REFRESH_MODE:KMLRefreshMode):
        b_.PrependInt8Slot(3, REFRESH_MODE, 0)
        return this
    def add_REFRESH_INTERVAL(REFRESH_INTERVAL:float):
        b_.PrependFloat64Slot(4, REFRESH_INTERVAL, 0.0)
        return this
    def add_VIEW_REFRESH_MODE(VIEW_REFRESH_MODE:KMLViewRefreshMode):
        b_.PrependInt8Slot(5, VIEW_REFRESH_MODE, 0)
        return this
    def add_VIEW_REFRESH_TIME(VIEW_REFRESH_TIME:float):
        b_.PrependFloat64Slot(6, VIEW_REFRESH_TIME, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Ground overlay
class KMLGroundOverlay : flatbuffers.handle
    /// Name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Visibility
    def VISIBILITY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Icon/image URL
    def ICON_HREF() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Color in aabbggrr hex format
    def COLOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// North latitude of bounding box
    def NORTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// South latitude of bounding box
    def SOUTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// East longitude of bounding box
    def EAST() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// West longitude of bounding box
    def WEST() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Rotation in degrees
    def ROTATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Altitude in meters
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Altitude mode
    def ALTITUDE_MODE() -> KMLAltitudeMode:
        return KMLAltitudeMode(flatbuffers.field_int8(buf_, pos_, 26, 0))

def GetRootAsKMLGroundOverlay(buf:string): return KMLGroundOverlay { buf, flatbuffers.indirect(buf, 0) }

struct KMLGroundOverlayBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(12)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DESCRIPTION)
        return this
    def add_VISIBILITY(VISIBILITY:bool):
        b_.PrependBoolSlot(2, VISIBILITY, 0)
        return this
    def add_ICON_HREF(ICON_HREF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ICON_HREF)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COLOR)
        return this
    def add_NORTH(NORTH:float):
        b_.PrependFloat64Slot(5, NORTH, 0.0)
        return this
    def add_SOUTH(SOUTH:float):
        b_.PrependFloat64Slot(6, SOUTH, 0.0)
        return this
    def add_EAST(EAST:float):
        b_.PrependFloat64Slot(7, EAST, 0.0)
        return this
    def add_WEST(WEST:float):
        b_.PrependFloat64Slot(8, WEST, 0.0)
        return this
    def add_ROTATION(ROTATION:float):
        b_.PrependFloat64Slot(9, ROTATION, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(10, ALTITUDE, 0.0)
        return this
    def add_ALTITUDE_MODE(ALTITUDE_MODE:KMLAltitudeMode):
        b_.PrependInt8Slot(11, ALTITUDE_MODE, 0)
        return this
    def end():
        return b_.EndObject()

/// Placemark feature
class KMLPlacemark : flatbuffers.handle
    /// Placemark name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Description (may contain HTML)
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Visibility flag
    def VISIBILITY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Style URL reference
    def STYLE_URL() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Inline style
    def STYLE() -> KMLStyle?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: KMLStyle { buf_, o } else: nil
    /// Snippet (short description)
    def SNIPPET() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Point geometry
    def POINT() -> KMLPoint?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: KMLPoint { buf_, o } else: nil
    /// LineString geometry
    def LINE_STRING() -> KMLLineString?:
        let o = flatbuffers.field_table(buf_, pos_, 18)
        return if o: KMLLineString { buf_, o } else: nil
    /// Polygon geometry
    def POLYGON() -> KMLPolygon?:
        let o = flatbuffers.field_table(buf_, pos_, 20)
        return if o: KMLPolygon { buf_, o } else: nil
    /// MultiGeometry
    def MULTI_GEOMETRY() -> KMLMultiGeometry?:
        let o = flatbuffers.field_table(buf_, pos_, 22)
        return if o: KMLMultiGeometry { buf_, o } else: nil
    /// LookAt viewpoint
    def LOOK_AT() -> KMLLookAt?:
        let o = flatbuffers.field_table(buf_, pos_, 24)
        return if o: KMLLookAt { buf_, o } else: nil
    /// Camera viewpoint
    def CAMERA() -> KMLCamera?:
        let o = flatbuffers.field_table(buf_, pos_, 26)
        return if o: KMLCamera { buf_, o } else: nil
    /// TimeSpan
    def TIME_SPAN() -> KMLTimeSpan?:
        let o = flatbuffers.field_table(buf_, pos_, 28)
        return if o: KMLTimeSpan { buf_, o } else: nil
    /// TimeStamp
    def TIME_STAMP() -> KMLTimeStamp?:
        let o = flatbuffers.field_table(buf_, pos_, 30)
        return if o: KMLTimeStamp { buf_, o } else: nil
    /// Extended data
    def EXTENDED_DATA(i:int) -> KMLData:
        return KMLData { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 32) + i * 4) }
    def EXTENDED_DATA_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 32)

def GetRootAsKMLPlacemark(buf:string): return KMLPlacemark { buf, flatbuffers.indirect(buf, 0) }

struct KMLPlacemarkBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(15)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DESCRIPTION)
        return this
    def add_VISIBILITY(VISIBILITY:bool):
        b_.PrependBoolSlot(2, VISIBILITY, 0)
        return this
    def add_STYLE_URL(STYLE_URL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, STYLE_URL)
        return this
    def add_STYLE(STYLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, STYLE)
        return this
    def add_SNIPPET(SNIPPET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, SNIPPET)
        return this
    def add_POINT(POINT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, POINT)
        return this
    def add_LINE_STRING(LINE_STRING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, LINE_STRING)
        return this
    def add_POLYGON(POLYGON:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, POLYGON)
        return this
    def add_MULTI_GEOMETRY(MULTI_GEOMETRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, MULTI_GEOMETRY)
        return this
    def add_LOOK_AT(LOOK_AT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, LOOK_AT)
        return this
    def add_CAMERA(CAMERA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, CAMERA)
        return this
    def add_TIME_SPAN(TIME_SPAN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, TIME_SPAN)
        return this
    def add_TIME_STAMP(TIME_STAMP:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, TIME_STAMP)
        return this
    def add_EXTENDED_DATA(EXTENDED_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, EXTENDED_DATA)
        return this
    def end():
        return b_.EndObject()

def KMLPlacemarkStartEXTENDED_DATAVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLPlacemarkCreateEXTENDED_DATAVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Folder container
class KMLFolder : flatbuffers.handle
    /// Folder name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Visibility flag
    def VISIBILITY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Whether folder is open in tree view
    def OPEN() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Placemarks in this folder
    def PLACEMARKS(i:int) -> KMLPlacemark:
        return KMLPlacemark { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def PLACEMARKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Sub-folders
    def FOLDERS(i:int) -> KMLFolder:
        return KMLFolder { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def FOLDERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Network links
    def NETWORK_LINKS(i:int) -> KMLNetworkLink:
        return KMLNetworkLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def NETWORK_LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Ground overlays
    def GROUND_OVERLAYS(i:int) -> KMLGroundOverlay:
        return KMLGroundOverlay { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def GROUND_OVERLAYS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)

def GetRootAsKMLFolder(buf:string): return KMLFolder { buf, flatbuffers.indirect(buf, 0) }

struct KMLFolderBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DESCRIPTION)
        return this
    def add_VISIBILITY(VISIBILITY:bool):
        b_.PrependBoolSlot(2, VISIBILITY, 0)
        return this
    def add_OPEN(OPEN:bool):
        b_.PrependBoolSlot(3, OPEN, 0)
        return this
    def add_PLACEMARKS(PLACEMARKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, PLACEMARKS)
        return this
    def add_FOLDERS(FOLDERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, FOLDERS)
        return this
    def add_NETWORK_LINKS(NETWORK_LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, NETWORK_LINKS)
        return this
    def add_GROUND_OVERLAYS(GROUND_OVERLAYS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, GROUND_OVERLAYS)
        return this
    def end():
        return b_.EndObject()

def KMLFolderStartPLACEMARKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLFolderCreatePLACEMARKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLFolderStartFOLDERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLFolderCreateFOLDERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLFolderStartNETWORK_LINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLFolderCreateNETWORK_LINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLFolderStartGROUND_OVERLAYSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLFolderCreateGROUND_OVERLAYSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// KML Document
class KML : flatbuffers.handle
    /// Document name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Document description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Whether document is visible
    def VISIBILITY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Whether document is open in tree view
    def OPEN() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Shared styles
    def STYLES(i:int) -> KMLStyle:
        return KMLStyle { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def STYLES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Style maps
    def STYLE_MAPS(i:int) -> KMLStyleMap:
        return KMLStyleMap { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def STYLE_MAPS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Top-level placemarks
    def PLACEMARKS(i:int) -> KMLPlacemark:
        return KMLPlacemark { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def PLACEMARKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Top-level folders
    def FOLDERS(i:int) -> KMLFolder:
        return KMLFolder { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def FOLDERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Network links
    def NETWORK_LINKS(i:int) -> KMLNetworkLink:
        return KMLNetworkLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 20) + i * 4) }
    def NETWORK_LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// Ground overlays
    def GROUND_OVERLAYS(i:int) -> KMLGroundOverlay:
        return KMLGroundOverlay { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def GROUND_OVERLAYS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)

def GetRootAsKML(buf:string): return KML { buf, flatbuffers.indirect(buf, 0) }

struct KMLBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DESCRIPTION)
        return this
    def add_VISIBILITY(VISIBILITY:bool):
        b_.PrependBoolSlot(2, VISIBILITY, 0)
        return this
    def add_OPEN(OPEN:bool):
        b_.PrependBoolSlot(3, OPEN, 0)
        return this
    def add_STYLES(STYLES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, STYLES)
        return this
    def add_STYLE_MAPS(STYLE_MAPS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, STYLE_MAPS)
        return this
    def add_PLACEMARKS(PLACEMARKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, PLACEMARKS)
        return this
    def add_FOLDERS(FOLDERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, FOLDERS)
        return this
    def add_NETWORK_LINKS(NETWORK_LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, NETWORK_LINKS)
        return this
    def add_GROUND_OVERLAYS(GROUND_OVERLAYS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, GROUND_OVERLAYS)
        return this
    def end():
        return b_.EndObject()

def KMLStartSTYLESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreateSTYLESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLStartSTYLE_MAPSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreateSTYLE_MAPSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLStartPLACEMARKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreatePLACEMARKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLStartFOLDERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreateFOLDERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLStartNETWORK_LINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreateNETWORK_LINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def KMLStartGROUND_OVERLAYSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def KMLCreateGROUND_OVERLAYSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

