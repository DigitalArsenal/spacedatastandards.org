// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum FCSMode:
    FCSMode_OFF = 0
    FCSMode_STANDBY = 1
    FCSMode_RANGING = 2
    FCSMode_TRACKING = 3
    FCSMode_SOLUTION = 4
    FCSMode_CCIP = 5
    FCSMode_CCRP = 6
    FCSMode_MANUAL = 7

enum LeadMethod:
    LeadMethod_NONE = 0
    LeadMethod_PREDICTIVE = 1
    LeadMethod_COLLISION = 2
    LeadMethod_CONSTANT_BEARING = 3
    LeadMethod_PURSUIT = 4

enum RangefinderType:
    RangefinderType_STADIAMETRIC = 0
    RangefinderType_STEREOSCOPIC = 1
    RangefinderType_COINCIDENCE = 2
    RangefinderType_LASER = 3
    RangefinderType_RADAR = 4

class FCS

/// Fire Control Systems
class FCS : flatbuffers.handle
    def MODE() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 4, 0)
    def LEAD_METHOD() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 6, 0)
    def RANGEFINDER_TYPE() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 8, 0)
    def AMMO_SELECTED() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 10, 0)
    def TARGET() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    def SOLUTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    def LAST_RANGE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    def RANGE_RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    def ROUNDS_REMAINING() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 20, 0)
    def TEMPERATURE() -> float:
        return flatbuffers.field_float32(buf_, pos_, 22, 0.0)
    def RESERVED(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 24) + i * 1)
    def RESERVED_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)

def GetRootAsFCS(buf:string): return FCS { buf, flatbuffers.indirect(buf, 0) }

struct FCSBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_MODE(MODE:int):
        b_.PrependUint8Slot(0, MODE, 0)
        return this
    def add_LEAD_METHOD(LEAD_METHOD:int):
        b_.PrependUint8Slot(1, LEAD_METHOD, 0)
        return this
    def add_RANGEFINDER_TYPE(RANGEFINDER_TYPE:int):
        b_.PrependUint8Slot(2, RANGEFINDER_TYPE, 0)
        return this
    def add_AMMO_SELECTED(AMMO_SELECTED:int):
        b_.PrependUint8Slot(3, AMMO_SELECTED, 0)
        return this
    def add_TARGET(TARGET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, TARGET)
        return this
    def add_SOLUTION(SOLUTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, SOLUTION)
        return this
    def add_LAST_RANGE(LAST_RANGE:float):
        b_.PrependFloat64Slot(6, LAST_RANGE, 0.0)
        return this
    def add_RANGE_RATE(RANGE_RATE:float):
        b_.PrependFloat64Slot(7, RANGE_RATE, 0.0)
        return this
    def add_ROUNDS_REMAINING(ROUNDS_REMAINING:int):
        b_.PrependUint16Slot(8, ROUNDS_REMAINING, 0)
        return this
    def add_TEMPERATURE(TEMPERATURE:float):
        b_.PrependFloat32Slot(9, TEMPERATURE, 0.0)
        return this
    def add_RESERVED(RESERVED:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, RESERVED)
        return this
    def end():
        return b_.EndObject()

def FCSStartRESERVEDVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def FCSCreateRESERVEDVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

