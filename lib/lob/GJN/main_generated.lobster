// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum GJNGeometryType:
    GJNGeometryType_POINT = 0
    GJNGeometryType_MULTI_POINT = 1
    GJNGeometryType_LINE_STRING = 2
    GJNGeometryType_MULTI_LINE_STRING = 3
    GJNGeometryType_POLYGON = 4
    GJNGeometryType_MULTI_POLYGON = 5
    GJNGeometryType_GEOMETRY_COLLECTION = 6

class GJNPosition

class GJNLinearRing

class GJNPolygonRings

class GJNGeometry

class GJNProperty

class GJNFeature

class GJNBoundingBox

class GJN

/// A single position (longitude, latitude, optional altitude)
class GJNPosition : flatbuffers.handle
    /// Longitude in decimal degrees (WGS84)
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Latitude in decimal degrees (WGS84)
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Altitude in meters above WGS84 ellipsoid (optional)
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// True if altitude was explicitly provided (distinguishes 0 from absent)
    def HAS_ALTITUDE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))

def GetRootAsGJNPosition(buf:string): return GJNPosition { buf, flatbuffers.indirect(buf, 0) }

struct GJNPositionBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(0, LONGITUDE, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(1, LATITUDE, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(2, ALTITUDE, 0.0)
        return this
    def add_HAS_ALTITUDE(HAS_ALTITUDE:bool):
        b_.PrependBoolSlot(3, HAS_ALTITUDE, 0)
        return this
    def end():
        return b_.EndObject()

/// A linear ring is a closed LineString with 4+ positions (first = last)
class GJNLinearRing : flatbuffers.handle
    /// Ordered positions forming the ring
    def POSITIONS(i:int) -> GJNPosition:
        return GJNPosition { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def POSITIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsGJNLinearRing(buf:string): return GJNLinearRing { buf, flatbuffers.indirect(buf, 0) }

struct GJNLinearRingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_POSITIONS(POSITIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, POSITIONS)
        return this
    def end():
        return b_.EndObject()

def GJNLinearRingStartPOSITIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNLinearRingCreatePOSITIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// A polygon represented as an array of rings (outer boundary + holes)
class GJNPolygonRings : flatbuffers.handle
    /// Rings: first is outer boundary, rest are holes
    def RINGS(i:int) -> GJNLinearRing:
        return GJNLinearRing { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RINGS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsGJNPolygonRings(buf:string): return GJNPolygonRings { buf, flatbuffers.indirect(buf, 0) }

struct GJNPolygonRingsBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RINGS(RINGS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RINGS)
        return this
    def end():
        return b_.EndObject()

def GJNPolygonRingsStartRINGSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNPolygonRingsCreateRINGSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// GeoJSON Geometry object
class GJNGeometry : flatbuffers.handle
    /// Geometry type
    def TYPE() -> GJNGeometryType:
        return GJNGeometryType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Single position (for Point)
    def POINT() -> GJNPosition?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: GJNPosition { buf_, o } else: nil
    /// Array of positions (for MultiPoint, LineString)
    def POSITIONS(i:int) -> GJNPosition:
        return GJNPosition { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def POSITIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Array of position arrays (for MultiLineString, Polygon rings)
    def RINGS(i:int) -> GJNLinearRing:
        return GJNLinearRing { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def RINGS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Array of polygons each as array of rings (for MultiPolygon)
    def POLYGON_RINGS(i:int) -> GJNPolygonRings:
        return GJNPolygonRings { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def POLYGON_RINGS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Child geometries (for GeometryCollection)
    def GEOMETRIES(i:int) -> GJNGeometry:
        return GJNGeometry { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def GEOMETRIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Bounding box (optional, per RFC 7946 Section 5)
    def BBOX() -> GJNBoundingBox?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: GJNBoundingBox { buf_, o } else: nil

def GetRootAsGJNGeometry(buf:string): return GJNGeometry { buf, flatbuffers.indirect(buf, 0) }

struct GJNGeometryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_TYPE(TYPE:GJNGeometryType):
        b_.PrependInt8Slot(0, TYPE, 0)
        return this
    def add_POINT(POINT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, POINT)
        return this
    def add_POSITIONS(POSITIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, POSITIONS)
        return this
    def add_RINGS(RINGS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, RINGS)
        return this
    def add_POLYGON_RINGS(POLYGON_RINGS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, POLYGON_RINGS)
        return this
    def add_GEOMETRIES(GEOMETRIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, GEOMETRIES)
        return this
    def add_BBOX(BBOX:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, BBOX)
        return this
    def end():
        return b_.EndObject()

def GJNGeometryStartPOSITIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNGeometryCreatePOSITIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GJNGeometryStartRINGSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNGeometryCreateRINGSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GJNGeometryStartPOLYGON_RINGSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNGeometryCreatePOLYGON_RINGSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GJNGeometryStartGEOMETRIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNGeometryCreateGEOMETRIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// A key-value property entry for Feature properties
class GJNProperty : flatbuffers.handle
    /// Property key
    def KEY() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Property value as string
    def VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Property value as number (use if numeric)
    def NUM_VALUE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// True if NUM_VALUE should be used instead of VALUE
    def IS_NUMERIC() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// True if this property value is a boolean
    def IS_BOOL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// Boolean value (use when IS_BOOL is true)
    def BOOL_VALUE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// True if this property value is JSON null
    def IS_NULL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Raw JSON string for complex values (objects, arrays)
    def JSON_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)

def GetRootAsGJNProperty(buf:string): return GJNProperty { buf, flatbuffers.indirect(buf, 0) }

struct GJNPropertyBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_KEY(KEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, KEY)
        return this
    def add_VALUE(VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VALUE)
        return this
    def add_NUM_VALUE(NUM_VALUE:float):
        b_.PrependFloat64Slot(2, NUM_VALUE, 0.0)
        return this
    def add_IS_NUMERIC(IS_NUMERIC:bool):
        b_.PrependBoolSlot(3, IS_NUMERIC, 0)
        return this
    def add_IS_BOOL(IS_BOOL:bool):
        b_.PrependBoolSlot(4, IS_BOOL, 0)
        return this
    def add_BOOL_VALUE(BOOL_VALUE:bool):
        b_.PrependBoolSlot(5, BOOL_VALUE, 0)
        return this
    def add_IS_NULL(IS_NULL:bool):
        b_.PrependBoolSlot(6, IS_NULL, 0)
        return this
    def add_JSON_VALUE(JSON_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, JSON_VALUE)
        return this
    def end():
        return b_.EndObject()

/// GeoJSON Feature object
class GJNFeature : flatbuffers.handle
    /// Feature identifier (optional, string form)
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Geometry of the feature
    def GEOMETRY() -> GJNGeometry?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: GJNGeometry { buf_, o } else: nil
    /// Properties as key-value pairs
    def PROPERTIES(i:int) -> GJNProperty:
        return GJNProperty { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def PROPERTIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Numeric feature identifier (use when ID_IS_NUMERIC is true)
    def NUM_ID() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// True if the feature id is numeric rather than string
    def ID_IS_NUMERIC() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// True if the feature has a geometry (false means geometry was JSON null)
    def HAS_GEOMETRY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// True if properties was JSON null (vs empty object)
    def PROPERTIES_IS_NULL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Bounding box (optional, per RFC 7946 Section 5)
    def BBOX() -> GJNBoundingBox?:
        let o = flatbuffers.field_table(buf_, pos_, 18)
        return if o: GJNBoundingBox { buf_, o } else: nil

def GetRootAsGJNFeature(buf:string): return GJNFeature { buf, flatbuffers.indirect(buf, 0) }

struct GJNFeatureBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_GEOMETRY(GEOMETRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, GEOMETRY)
        return this
    def add_PROPERTIES(PROPERTIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PROPERTIES)
        return this
    def add_NUM_ID(NUM_ID:float):
        b_.PrependFloat64Slot(3, NUM_ID, 0.0)
        return this
    def add_ID_IS_NUMERIC(ID_IS_NUMERIC:bool):
        b_.PrependBoolSlot(4, ID_IS_NUMERIC, 0)
        return this
    def add_HAS_GEOMETRY(HAS_GEOMETRY:bool):
        b_.PrependBoolSlot(5, HAS_GEOMETRY, 0)
        return this
    def add_PROPERTIES_IS_NULL(PROPERTIES_IS_NULL:bool):
        b_.PrependBoolSlot(6, PROPERTIES_IS_NULL, 0)
        return this
    def add_BBOX(BBOX:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, BBOX)
        return this
    def end():
        return b_.EndObject()

def GJNFeatureStartPROPERTIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNFeatureCreatePROPERTIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// GeoJSON Bounding Box [west, south, east, north] or [west, south, min-alt, east, north, max-alt]
class GJNBoundingBox : flatbuffers.handle
    /// Western longitude
    def WEST() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Southern latitude
    def SOUTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Eastern longitude
    def EAST() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Northern latitude
    def NORTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Minimum altitude (optional)
    def MIN_ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Maximum altitude (optional)
    def MAX_ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// True if the bbox includes altitude (6 values vs 4)
    def HAS_ALTITUDE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsGJNBoundingBox(buf:string): return GJNBoundingBox { buf, flatbuffers.indirect(buf, 0) }

struct GJNBoundingBoxBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_WEST(WEST:float):
        b_.PrependFloat64Slot(0, WEST, 0.0)
        return this
    def add_SOUTH(SOUTH:float):
        b_.PrependFloat64Slot(1, SOUTH, 0.0)
        return this
    def add_EAST(EAST:float):
        b_.PrependFloat64Slot(2, EAST, 0.0)
        return this
    def add_NORTH(NORTH:float):
        b_.PrependFloat64Slot(3, NORTH, 0.0)
        return this
    def add_MIN_ALTITUDE(MIN_ALTITUDE:float):
        b_.PrependFloat64Slot(4, MIN_ALTITUDE, 0.0)
        return this
    def add_MAX_ALTITUDE(MAX_ALTITUDE:float):
        b_.PrependFloat64Slot(5, MAX_ALTITUDE, 0.0)
        return this
    def add_HAS_ALTITUDE(HAS_ALTITUDE:bool):
        b_.PrependBoolSlot(6, HAS_ALTITUDE, 0)
        return this
    def end():
        return b_.EndObject()

/// GeoJSON FeatureCollection
class GJN : flatbuffers.handle
    /// Features in the collection
    def FEATURES(i:int) -> GJNFeature:
        return GJNFeature { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def FEATURES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Bounding box (optional)
    def BBOX() -> GJNBoundingBox?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: GJNBoundingBox { buf_, o } else: nil

def GetRootAsGJN(buf:string): return GJN { buf, flatbuffers.indirect(buf, 0) }

struct GJNBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_FEATURES(FEATURES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, FEATURES)
        return this
    def add_BBOX(BBOX:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, BBOX)
        return this
    def end():
        return b_.EndObject()

def GJNStartFEATURESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GJNCreateFEATURESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

