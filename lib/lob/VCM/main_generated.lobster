// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum elementType:
    elementType_OSCULATING = 0
    elementType_MEAN = 1

enum anomalyType:
    anomalyType_TRUE_ANOMALY = 0
    anomalyType_MEAN_ANOMALY = 1

/// Enum to represent common atmospheric models
enum atmosphericModel:
    atmosphericModel_NONE = 0
    atmosphericModel_JACCHIA_70 = 1
    atmosphericModel_JB2008 = 2
    atmosphericModel_NRLMSISE_00 = 3
    atmosphericModel_DTM_2000 = 4
    atmosphericModel_HWM14 = 5
    atmosphericModel_HASDM = 6

/// Enum to represent common geopotential models
enum geopotentialModel:
    geopotentialModel_NONE = 0
    geopotentialModel_EGM96 = 1
    geopotentialModel_WGS84 = 2
    geopotentialModel_JGM2 = 3
    geopotentialModel_GEMT3 = 4
    geopotentialModel_EGM96_J5 = 5

/// Enum to represent zonal harmonics
enum zonalHarmonic:
    zonalHarmonic_NONE = 0
    zonalHarmonic_J2 = 1
    zonalHarmonic_J3 = 2
    zonalHarmonic_J4 = 3
    zonalHarmonic_J5 = 4
    zonalHarmonic_J6 = 5
    zonalHarmonic_J7 = 6
    zonalHarmonic_J8 = 7
    zonalHarmonic_J9 = 8
    zonalHarmonic_J10 = 9
    zonalHarmonic_J11 = 10
    zonalHarmonic_J12 = 11

/// Enum to represent solar radiation pressure models
enum solarRadiationPressureModel:
    solarRadiationPressureModel_NONE = 0
    solarRadiationPressureModel_SPHERICAL_MODEL = 1
    solarRadiationPressureModel_FLAT_PLATE_MODEL = 2

/// Enum to represent common lunar perturbation models
enum lunarPerturbationModel:
    lunarPerturbationModel_NONE = 0
    lunarPerturbationModel_DE430 = 1
    lunarPerturbationModel_DE431 = 2
    lunarPerturbationModel_LP150Q = 3

/// Enum to represent various solar perturbation models
enum solarPerturbationModel:
    solarPerturbationModel_NONE = 0
    solarPerturbationModel_DE430 = 1
    solarPerturbationModel_DE431 = 2

/// Enum to represent resonance models
enum resonanceModel:
    resonanceModel_NONE = 0
    resonanceModel_HIGH_ALTITUDE_RESONANCE = 1
    resonanceModel_LOW_ALTITUDE_RESONANCE = 2
    resonanceModel_LUNAR_RESONANCE = 3
    resonanceModel_SOLAR_RESONANCE = 4

/// Enum to represent the status of various perturbations (ON/OFF)
enum perturbationStatus:
    perturbationStatus_OFF = 0
    perturbationStatus_ON = 1

/// Enum to represent propagator types
enum propagatorType:
    propagatorType_NONE = 0
    propagatorType_SEMI_ANALYTICAL = 1
    propagatorType_VINTI = 2
    propagatorType_SGP4 = 3
    propagatorType_COWELL = 4
    propagatorType_RK4 = 5
    propagatorType_NYX = 6
    propagatorType_GMAT = 7
    propagatorType_SPICE = 8
    propagatorType_SGP = 9
    propagatorType_SDP4 = 10
    propagatorType_SGP8 = 11
    propagatorType_SDP8 = 12

class propagatorConfig

class VCMStateVector

class VCMCovarianceMatrixLine

class keplerianElements

class equinoctialElements

class uvwSigmas

class VCMAtmosphericModelData

class VCM

class VCM_COLLECTION

/// Propagator configuration structure to describe propagation settings
class propagatorConfig : flatbuffers.handle
    def PROPAGATOR_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def PROPAGATOR_TYPE() -> propagatorType:
        return propagatorType(flatbuffers.field_int8(buf_, pos_, 6, 0))
    def FORCE_MODELS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 4)
    def FORCE_MODELS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    def TIME_STEP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    def ZONAL_HARMONIC_TERMS(i:int) -> zonalHarmonic:
        return read_int8_le(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 1)
    def ZONAL_HARMONIC_TERMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)

def GetRootAspropagatorConfig(buf:string): return propagatorConfig { buf, flatbuffers.indirect(buf, 0) }

struct propagatorConfigBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_PROPAGATOR_NAME(PROPAGATOR_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PROPAGATOR_NAME)
        return this
    def add_PROPAGATOR_TYPE(PROPAGATOR_TYPE:propagatorType):
        b_.PrependInt8Slot(1, PROPAGATOR_TYPE, 0)
        return this
    def add_FORCE_MODELS(FORCE_MODELS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, FORCE_MODELS)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, EPOCH)
        return this
    def add_TIME_STEP(TIME_STEP:float):
        b_.PrependFloat64Slot(4, TIME_STEP, 0.0)
        return this
    def add_ZONAL_HARMONIC_TERMS(ZONAL_HARMONIC_TERMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, ZONAL_HARMONIC_TERMS)
        return this
    def end():
        return b_.EndObject()

def propagatorConfigStartFORCE_MODELSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def propagatorConfigCreateFORCE_MODELSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def propagatorConfigStartZONAL_HARMONIC_TERMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def propagatorConfigCreateZONAL_HARMONIC_TERMSVector(b_:flatbuffers.builder, v_:[zonalHarmonic]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependInt8(e_)
    return b_.EndVector(v_.length)

/// VCM State Vector (position and velocity)
class VCMStateVector : flatbuffers.handle
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    def X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    def Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    def Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)

def GetRootAsVCMStateVector(buf:string): return VCMStateVector { buf, flatbuffers.indirect(buf, 0) }

struct VCMStateVectorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_X(X:float):
        b_.PrependFloat64Slot(1, X, 0.0)
        return this
    def add_Y(Y:float):
        b_.PrependFloat64Slot(2, Y, 0.0)
        return this
    def add_Z(Z:float):
        b_.PrependFloat64Slot(3, Z, 0.0)
        return this
    def add_X_DOT(X_DOT:float):
        b_.PrependFloat64Slot(4, X_DOT, 0.0)
        return this
    def add_Y_DOT(Y_DOT:float):
        b_.PrependFloat64Slot(5, Y_DOT, 0.0)
        return this
    def add_Z_DOT(Z_DOT:float):
        b_.PrependFloat64Slot(6, Z_DOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// VCM Covariance Matrix Line
class VCMCovarianceMatrixLine : flatbuffers.handle
    def CX_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def CY_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def CZ_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def CX_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)

def GetRootAsVCMCovarianceMatrixLine(buf:string): return VCMCovarianceMatrixLine { buf, flatbuffers.indirect(buf, 0) }

struct VCMCovarianceMatrixLineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_CX_X(CX_X:float):
        b_.PrependFloat64Slot(0, CX_X, 0.0)
        return this
    def add_CY_X(CY_X:float):
        b_.PrependFloat64Slot(1, CY_X, 0.0)
        return this
    def add_CZ_X(CZ_X:float):
        b_.PrependFloat64Slot(2, CZ_X, 0.0)
        return this
    def add_CX_DOT_X(CX_DOT_X:float):
        b_.PrependFloat64Slot(3, CX_DOT_X, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Keplerian Elements
class keplerianElements : flatbuffers.handle
    def SEMI_MAJOR_AXIS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def ECCENTRICITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def INCLINATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def RA_OF_ASC_NODE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    def ARG_OF_PERICENTER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    def ANOMALY_TYPE() -> anomalyType:
        return anomalyType(flatbuffers.field_int8(buf_, pos_, 14, 0))
    def ANOMALY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)

def GetRootAskeplerianElements(buf:string): return keplerianElements { buf, flatbuffers.indirect(buf, 0) }

struct keplerianElementsBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS:float):
        b_.PrependFloat64Slot(0, SEMI_MAJOR_AXIS, 0.0)
        return this
    def add_ECCENTRICITY(ECCENTRICITY:float):
        b_.PrependFloat64Slot(1, ECCENTRICITY, 0.0)
        return this
    def add_INCLINATION(INCLINATION:float):
        b_.PrependFloat64Slot(2, INCLINATION, 0.0)
        return this
    def add_RA_OF_ASC_NODE(RA_OF_ASC_NODE:float):
        b_.PrependFloat64Slot(3, RA_OF_ASC_NODE, 0.0)
        return this
    def add_ARG_OF_PERICENTER(ARG_OF_PERICENTER:float):
        b_.PrependFloat64Slot(4, ARG_OF_PERICENTER, 0.0)
        return this
    def add_ANOMALY_TYPE(ANOMALY_TYPE:anomalyType):
        b_.PrependInt8Slot(5, ANOMALY_TYPE, 0)
        return this
    def add_ANOMALY(ANOMALY:float):
        b_.PrependFloat64Slot(6, ANOMALY, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Equinoctial Elements
class equinoctialElements : flatbuffers.handle
    def AF() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def AG() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def L() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def N() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    def CHI() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    def PSI() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)

def GetRootAsequinoctialElements(buf:string): return equinoctialElements { buf, flatbuffers.indirect(buf, 0) }

struct equinoctialElementsBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_AF(AF:float):
        b_.PrependFloat64Slot(0, AF, 0.0)
        return this
    def add_AG(AG:float):
        b_.PrependFloat64Slot(1, AG, 0.0)
        return this
    def add_L(L:float):
        b_.PrependFloat64Slot(2, L, 0.0)
        return this
    def add_N(N:float):
        b_.PrependFloat64Slot(3, N, 0.0)
        return this
    def add_CHI(CHI:float):
        b_.PrependFloat64Slot(4, CHI, 0.0)
        return this
    def add_PSI(PSI:float):
        b_.PrependFloat64Slot(5, PSI, 0.0)
        return this
    def end():
        return b_.EndObject()

/// UVW Sigmas (Covariance matrix in UVW frame)
class uvwSigmas : flatbuffers.handle
    def U_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def V_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def W_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def UD_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    def VD_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    def WD_SIGMA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)

def GetRootAsuvwSigmas(buf:string): return uvwSigmas { buf, flatbuffers.indirect(buf, 0) }

struct uvwSigmasBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_U_SIGMA(U_SIGMA:float):
        b_.PrependFloat64Slot(0, U_SIGMA, 0.0)
        return this
    def add_V_SIGMA(V_SIGMA:float):
        b_.PrependFloat64Slot(1, V_SIGMA, 0.0)
        return this
    def add_W_SIGMA(W_SIGMA:float):
        b_.PrependFloat64Slot(2, W_SIGMA, 0.0)
        return this
    def add_UD_SIGMA(UD_SIGMA:float):
        b_.PrependFloat64Slot(3, UD_SIGMA, 0.0)
        return this
    def add_VD_SIGMA(VD_SIGMA:float):
        b_.PrependFloat64Slot(4, VD_SIGMA, 0.0)
        return this
    def add_WD_SIGMA(WD_SIGMA:float):
        b_.PrependFloat64Slot(5, WD_SIGMA, 0.0)
        return this
    def end():
        return b_.EndObject()

/// VCM Atmospheric and Perturbation Model Data
class VCMAtmosphericModelData : flatbuffers.handle
    def ATMOSPHERIC_MODEL() -> atmosphericModel:
        return atmosphericModel(flatbuffers.field_int8(buf_, pos_, 4, 0))
    def GEOPOTENTIAL_MODEL() -> geopotentialModel:
        return geopotentialModel(flatbuffers.field_int8(buf_, pos_, 6, 0))
    def LUNAR_SOLAR_PERTURBATION() -> perturbationStatus:
        return perturbationStatus(flatbuffers.field_int8(buf_, pos_, 8, 0))
    def LUNAR_PERTURBATION_MODEL() -> lunarPerturbationModel:
        return lunarPerturbationModel(flatbuffers.field_int8(buf_, pos_, 10, 0))
    def SOLAR_PERTURBATION_MODEL() -> solarPerturbationModel:
        return solarPerturbationModel(flatbuffers.field_int8(buf_, pos_, 12, 0))
    def SOLAR_RADIATION_PRESSURE() -> perturbationStatus:
        return perturbationStatus(flatbuffers.field_int8(buf_, pos_, 14, 0))
    def SRP_MODEL() -> solarRadiationPressureModel:
        return solarRadiationPressureModel(flatbuffers.field_int8(buf_, pos_, 16, 0))
    def RESONANCE_MODEL() -> resonanceModel:
        return resonanceModel(flatbuffers.field_int8(buf_, pos_, 18, 0))

def GetRootAsVCMAtmosphericModelData(buf:string): return VCMAtmosphericModelData { buf, flatbuffers.indirect(buf, 0) }

struct VCMAtmosphericModelDataBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_ATMOSPHERIC_MODEL(ATMOSPHERIC_MODEL:atmosphericModel):
        b_.PrependInt8Slot(0, ATMOSPHERIC_MODEL, 0)
        return this
    def add_GEOPOTENTIAL_MODEL(GEOPOTENTIAL_MODEL:geopotentialModel):
        b_.PrependInt8Slot(1, GEOPOTENTIAL_MODEL, 0)
        return this
    def add_LUNAR_SOLAR_PERTURBATION(LUNAR_SOLAR_PERTURBATION:perturbationStatus):
        b_.PrependInt8Slot(2, LUNAR_SOLAR_PERTURBATION, 0)
        return this
    def add_LUNAR_PERTURBATION_MODEL(LUNAR_PERTURBATION_MODEL:lunarPerturbationModel):
        b_.PrependInt8Slot(3, LUNAR_PERTURBATION_MODEL, 0)
        return this
    def add_SOLAR_PERTURBATION_MODEL(SOLAR_PERTURBATION_MODEL:solarPerturbationModel):
        b_.PrependInt8Slot(4, SOLAR_PERTURBATION_MODEL, 0)
        return this
    def add_SOLAR_RADIATION_PRESSURE(SOLAR_RADIATION_PRESSURE:perturbationStatus):
        b_.PrependInt8Slot(5, SOLAR_RADIATION_PRESSURE, 0)
        return this
    def add_SRP_MODEL(SRP_MODEL:solarRadiationPressureModel):
        b_.PrependInt8Slot(6, SRP_MODEL, 0)
        return this
    def add_RESONANCE_MODEL(RESONANCE_MODEL:resonanceModel):
        b_.PrependInt8Slot(7, RESONANCE_MODEL, 0)
        return this
    def end():
        return b_.EndObject()

/// Vector Covariance Message
class VCM : flatbuffers.handle
    def CCSDS_OMM_VERS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    def OBJECT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    def OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    def CENTER_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    def REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    def TIME_SYSTEM() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    def STATE_VECTOR() -> VCMStateVector?:
        let o = flatbuffers.field_table(buf_, pos_, 20)
        return if o: VCMStateVector { buf_, o } else: nil
    def KEPLERIAN_ELEMENTS() -> keplerianElements?:
        let o = flatbuffers.field_table(buf_, pos_, 22)
        return if o: keplerianElements { buf_, o } else: nil
    def EQUINOCTIAL_ELEMENTS() -> equinoctialElements?:
        let o = flatbuffers.field_table(buf_, pos_, 24)
        return if o: equinoctialElements { buf_, o } else: nil
    def GM() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    def ATMOSPHERIC_MODEL_DATA() -> VCMAtmosphericModelData?:
        let o = flatbuffers.field_table(buf_, pos_, 28)
        return if o: VCMAtmosphericModelData { buf_, o } else: nil
    def PROPAGATOR_SETTINGS() -> propagatorConfig?:
        let o = flatbuffers.field_table(buf_, pos_, 30)
        return if o: propagatorConfig { buf_, o } else: nil
    def COVARIANCE_MATRIX(i:int) -> VCMCovarianceMatrixLine:
        return VCMCovarianceMatrixLine { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 32) + i * 4) }
    def COVARIANCE_MATRIX_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 32)
    def UVW_SIGMAS() -> uvwSigmas?:
        let o = flatbuffers.field_table(buf_, pos_, 34)
        return if o: uvwSigmas { buf_, o } else: nil
    def MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    def SOLAR_RAD_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    def SOLAR_RAD_COEFF() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    def DRAG_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    def DRAG_COEFF() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    def SRP() -> perturbationStatus:
        return perturbationStatus(flatbuffers.field_int8(buf_, pos_, 46, 0))
    def CLASSIFICATION_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 48)
    def NORAD_CAT_ID() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 50, 0)
    def ELEMENT_SET_NO() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 52, 0)
    def REV_AT_EPOCH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    def BSTAR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 56, 0.0)
    def MEAN_MOTION_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 58, 0.0)
    def MEAN_MOTION_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 60, 0.0)
    def COV_REFERENCE_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 62)
    def CX_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 64, 0.0)
    def CY_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 66, 0.0)
    def CZ_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 68, 0.0)
    def CX_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 70, 0.0)
    def USER_DEFINED_BIP_0044_TYPE() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 72, 0)
    def USER_DEFINED_OBJECT_DESIGNATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 74)
    def USER_DEFINED_EARTH_MODEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 76)
    def USER_DEFINED_EPOCH_TIMESTAMP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 78, 0.0)
    def USER_DEFINED_MICROSECONDS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 80, 0.0)

def GetRootAsVCM(buf:string): return VCM { buf, flatbuffers.indirect(buf, 0) }

struct VCMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(39)
        return this
    def add_CCSDS_OMM_VERS(CCSDS_OMM_VERS:float):
        b_.PrependFloat64Slot(0, CCSDS_OMM_VERS, 0.0)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ORIGINATOR)
        return this
    def add_OBJECT_NAME(OBJECT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OBJECT_NAME)
        return this
    def add_OBJECT_ID(OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, OBJECT_ID)
        return this
    def add_CENTER_NAME(CENTER_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, CENTER_NAME)
        return this
    def add_REF_FRAME(REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, REF_FRAME)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, TIME_SYSTEM)
        return this
    def add_STATE_VECTOR(STATE_VECTOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, STATE_VECTOR)
        return this
    def add_KEPLERIAN_ELEMENTS(KEPLERIAN_ELEMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, KEPLERIAN_ELEMENTS)
        return this
    def add_EQUINOCTIAL_ELEMENTS(EQUINOCTIAL_ELEMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, EQUINOCTIAL_ELEMENTS)
        return this
    def add_GM(GM:float):
        b_.PrependFloat64Slot(11, GM, 0.0)
        return this
    def add_ATMOSPHERIC_MODEL_DATA(ATMOSPHERIC_MODEL_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, ATMOSPHERIC_MODEL_DATA)
        return this
    def add_PROPAGATOR_SETTINGS(PROPAGATOR_SETTINGS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, PROPAGATOR_SETTINGS)
        return this
    def add_COVARIANCE_MATRIX(COVARIANCE_MATRIX:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, COVARIANCE_MATRIX)
        return this
    def add_UVW_SIGMAS(UVW_SIGMAS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, UVW_SIGMAS)
        return this
    def add_MASS(MASS:float):
        b_.PrependFloat64Slot(16, MASS, 0.0)
        return this
    def add_SOLAR_RAD_AREA(SOLAR_RAD_AREA:float):
        b_.PrependFloat64Slot(17, SOLAR_RAD_AREA, 0.0)
        return this
    def add_SOLAR_RAD_COEFF(SOLAR_RAD_COEFF:float):
        b_.PrependFloat64Slot(18, SOLAR_RAD_COEFF, 0.0)
        return this
    def add_DRAG_AREA(DRAG_AREA:float):
        b_.PrependFloat64Slot(19, DRAG_AREA, 0.0)
        return this
    def add_DRAG_COEFF(DRAG_COEFF:float):
        b_.PrependFloat64Slot(20, DRAG_COEFF, 0.0)
        return this
    def add_SRP(SRP:perturbationStatus):
        b_.PrependInt8Slot(21, SRP, 0)
        return this
    def add_CLASSIFICATION_TYPE(CLASSIFICATION_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, CLASSIFICATION_TYPE)
        return this
    def add_NORAD_CAT_ID(NORAD_CAT_ID:int):
        b_.PrependUint32Slot(23, NORAD_CAT_ID, 0)
        return this
    def add_ELEMENT_SET_NO(ELEMENT_SET_NO:int):
        b_.PrependUint32Slot(24, ELEMENT_SET_NO, 0)
        return this
    def add_REV_AT_EPOCH(REV_AT_EPOCH:float):
        b_.PrependFloat64Slot(25, REV_AT_EPOCH, 0.0)
        return this
    def add_BSTAR(BSTAR:float):
        b_.PrependFloat64Slot(26, BSTAR, 0.0)
        return this
    def add_MEAN_MOTION_DOT(MEAN_MOTION_DOT:float):
        b_.PrependFloat64Slot(27, MEAN_MOTION_DOT, 0.0)
        return this
    def add_MEAN_MOTION_DDOT(MEAN_MOTION_DDOT:float):
        b_.PrependFloat64Slot(28, MEAN_MOTION_DDOT, 0.0)
        return this
    def add_COV_REFERENCE_FRAME(COV_REFERENCE_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, COV_REFERENCE_FRAME)
        return this
    def add_CX_X(CX_X:float):
        b_.PrependFloat64Slot(30, CX_X, 0.0)
        return this
    def add_CY_X(CY_X:float):
        b_.PrependFloat64Slot(31, CY_X, 0.0)
        return this
    def add_CZ_X(CZ_X:float):
        b_.PrependFloat64Slot(32, CZ_X, 0.0)
        return this
    def add_CX_DOT_X(CX_DOT_X:float):
        b_.PrependFloat64Slot(33, CX_DOT_X, 0.0)
        return this
    def add_USER_DEFINED_BIP_0044_TYPE(USER_DEFINED_BIP_0044_TYPE:int):
        b_.PrependUint32Slot(34, USER_DEFINED_BIP_0044_TYPE, 0)
        return this
    def add_USER_DEFINED_OBJECT_DESIGNATOR(USER_DEFINED_OBJECT_DESIGNATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, USER_DEFINED_OBJECT_DESIGNATOR)
        return this
    def add_USER_DEFINED_EARTH_MODEL(USER_DEFINED_EARTH_MODEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(36, USER_DEFINED_EARTH_MODEL)
        return this
    def add_USER_DEFINED_EPOCH_TIMESTAMP(USER_DEFINED_EPOCH_TIMESTAMP:float):
        b_.PrependFloat64Slot(37, USER_DEFINED_EPOCH_TIMESTAMP, 0.0)
        return this
    def add_USER_DEFINED_MICROSECONDS(USER_DEFINED_MICROSECONDS:float):
        b_.PrependFloat64Slot(38, USER_DEFINED_MICROSECONDS, 0.0)
        return this
    def end():
        return b_.EndObject()

def VCMStartCOVARIANCE_MATRIXVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def VCMCreateCOVARIANCE_MATRIXVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of VCM records
class VCM_COLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> VCM:
        return VCM { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsVCM_COLLECTION(buf:string): return VCM_COLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct VCM_COLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def VCM_COLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def VCM_COLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

