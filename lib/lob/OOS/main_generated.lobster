// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class OOS

/// On-Orbit Solar Array
class OOS : flatbuffers.handle
    /// Unique identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Reference to parent on-orbit object
    def ID_ON_ORBIT() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Reference to solar array specification
    def ID_SOLAR_ARRAY() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Solar array name or designation
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Solar cell type (e.g., SILICON, GAAS, MULTI_JUNCTION, THIN_FILM, PEROVSKITE)
    def CELL_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Number of solar arrays of this type
    def QUANTITY() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    /// Total array area in square meters
    def AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Beginning of life power output in Watts
    def POWER_BOL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// End of life power output in Watts
    def POWER_EOL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Conversion efficiency as fraction (0.0-1.0)
    def EFFICIENCY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Degradation rate per year as fraction
    def DEGRADATION_RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Number of panels per array
    def NUM_PANELS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 26, 0)
    /// Whether the array is deployable
    def DEPLOYABLE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 28, 0))
    /// Whether the array is articulable/tracking
    def TRACKING() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 30, 0))
    /// Array mass in kg
    def MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Additional notes
    def NOTES() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)

def GetRootAsOOS(buf:string): return OOS { buf, flatbuffers.indirect(buf, 0) }

struct OOSBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(16)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_ID_ON_ORBIT(ID_ON_ORBIT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ID_ON_ORBIT)
        return this
    def add_ID_SOLAR_ARRAY(ID_SOLAR_ARRAY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ID_SOLAR_ARRAY)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, NAME)
        return this
    def add_CELL_TYPE(CELL_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, CELL_TYPE)
        return this
    def add_QUANTITY(QUANTITY:int):
        b_.PrependUint32Slot(5, QUANTITY, 0)
        return this
    def add_AREA(AREA:float):
        b_.PrependFloat64Slot(6, AREA, 0.0)
        return this
    def add_POWER_BOL(POWER_BOL:float):
        b_.PrependFloat64Slot(7, POWER_BOL, 0.0)
        return this
    def add_POWER_EOL(POWER_EOL:float):
        b_.PrependFloat64Slot(8, POWER_EOL, 0.0)
        return this
    def add_EFFICIENCY(EFFICIENCY:float):
        b_.PrependFloat64Slot(9, EFFICIENCY, 0.0)
        return this
    def add_DEGRADATION_RATE(DEGRADATION_RATE:float):
        b_.PrependFloat64Slot(10, DEGRADATION_RATE, 0.0)
        return this
    def add_NUM_PANELS(NUM_PANELS:int):
        b_.PrependUint32Slot(11, NUM_PANELS, 0)
        return this
    def add_DEPLOYABLE(DEPLOYABLE:bool):
        b_.PrependBoolSlot(12, DEPLOYABLE, 0)
        return this
    def add_TRACKING(TRACKING:bool):
        b_.PrependBoolSlot(13, TRACKING, 0)
        return this
    def add_MASS(MASS:float):
        b_.PrependFloat64Slot(14, MASS, 0.0)
        return this
    def add_NOTES(NOTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, NOTES)
        return this
    def end():
        return b_.EndObject()

