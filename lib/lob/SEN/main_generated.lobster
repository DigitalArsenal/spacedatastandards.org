// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum sensorStatus:
    sensorStatus_OPERATIONAL = 0
    sensorStatus_DEGRADED = 1
    sensorStatus_MAINTENANCE = 2
    sensorStatus_OFFLINE = 3
    sensorStatus_CALIBRATING = 4
    sensorStatus_TESTING = 5
    sensorStatus_DECOMMISSIONED = 6

enum maintenanceType:
    maintenanceType_SCHEDULED = 0
    maintenanceType_UNSCHEDULED = 1
    maintenanceType_CORRECTIVE = 2
    maintenanceType_PREVENTIVE = 3
    maintenanceType_CALIBRATION = 4
    maintenanceType_UPGRADE = 5
    maintenanceType_INSPECTION = 6

class sensorMaintenanceEvent

class sensorPlan

class sensorStats

class SEN

/// Sensor Maintenance Event
class sensorMaintenanceEvent : flatbuffers.handle
    /// Maintenance start time (ISO 8601)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Maintenance end time (ISO 8601)
    def END_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Type of maintenance
    def TYPE() -> maintenanceType:
        return maintenanceType(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Description of maintenance performed
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Components affected
    def COMPONENTS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 12) + i * 4)
    def COMPONENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAssensorMaintenanceEvent(buf:string): return sensorMaintenanceEvent { buf, flatbuffers.indirect(buf, 0) }

struct sensorMaintenanceEventBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, START_TIME)
        return this
    def add_END_TIME(END_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, END_TIME)
        return this
    def add_TYPE(TYPE:maintenanceType):
        b_.PrependInt8Slot(2, TYPE, 0)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DESCRIPTION)
        return this
    def add_COMPONENTS(COMPONENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COMPONENTS)
        return this
    def end():
        return b_.EndObject()

def sensorMaintenanceEventStartCOMPONENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def sensorMaintenanceEventCreateCOMPONENTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Sensor Tasking Plan
class sensorPlan : flatbuffers.handle
    /// Plan start time (ISO 8601)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Plan end time (ISO 8601)
    def END_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Target satellite number or designator
    def TARGET_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Priority level (1=highest)
    def PRIORITY() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 10, 0)
    /// Requested observation mode
    def MODE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Minimum elevation in degrees
    def MIN_ELEVATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Maximum range in km
    def MAX_RANGE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)

def GetRootAssensorPlan(buf:string): return sensorPlan { buf, flatbuffers.indirect(buf, 0) }

struct sensorPlanBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, START_TIME)
        return this
    def add_END_TIME(END_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, END_TIME)
        return this
    def add_TARGET_ID(TARGET_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, TARGET_ID)
        return this
    def add_PRIORITY(PRIORITY:int):
        b_.PrependUint8Slot(3, PRIORITY, 0)
        return this
    def add_MODE(MODE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, MODE)
        return this
    def add_MIN_ELEVATION(MIN_ELEVATION:float):
        b_.PrependFloat64Slot(5, MIN_ELEVATION, 0.0)
        return this
    def add_MAX_RANGE(MAX_RANGE:float):
        b_.PrependFloat64Slot(6, MAX_RANGE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Sensor Operational Statistics
class sensorStats : flatbuffers.handle
    /// Statistics period start (ISO 8601)
    def PERIOD_START() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Statistics period end (ISO 8601)
    def PERIOD_END() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Total observation attempts
    def OBS_ATTEMPTED() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    /// Successful observations
    def OBS_SUCCESSFUL() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)
    /// Failed observations
    def OBS_FAILED() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 12, 0)
    /// Uptime fraction (0.0-1.0)
    def UPTIME() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Average tracking accuracy in arcseconds
    def AVG_ACCURACY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Detected objects count
    def DETECTIONS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 18, 0)
    /// Uncorrelated tracks count
    def UCT_COUNT() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 20, 0)

def GetRootAssensorStats(buf:string): return sensorStats { buf, flatbuffers.indirect(buf, 0) }

struct sensorStatsBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_PERIOD_START(PERIOD_START:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PERIOD_START)
        return this
    def add_PERIOD_END(PERIOD_END:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PERIOD_END)
        return this
    def add_OBS_ATTEMPTED(OBS_ATTEMPTED:int):
        b_.PrependUint32Slot(2, OBS_ATTEMPTED, 0)
        return this
    def add_OBS_SUCCESSFUL(OBS_SUCCESSFUL:int):
        b_.PrependUint32Slot(3, OBS_SUCCESSFUL, 0)
        return this
    def add_OBS_FAILED(OBS_FAILED:int):
        b_.PrependUint32Slot(4, OBS_FAILED, 0)
        return this
    def add_UPTIME(UPTIME:float):
        b_.PrependFloat64Slot(5, UPTIME, 0.0)
        return this
    def add_AVG_ACCURACY(AVG_ACCURACY:float):
        b_.PrependFloat64Slot(6, AVG_ACCURACY, 0.0)
        return this
    def add_DETECTIONS(DETECTIONS:int):
        b_.PrependUint32Slot(7, DETECTIONS, 0)
        return this
    def add_UCT_COUNT(UCT_COUNT:int):
        b_.PrependUint32Slot(8, UCT_COUNT, 0)
        return this
    def end():
        return b_.EndObject()

/// Sensor Management
class SEN : flatbuffers.handle
    /// Unique sensor identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Sensor name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Sensor type
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Current operational status
    def STATUS() -> sensorStatus:
        return sensorStatus(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Site identifier
    def SITE_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Geodetic latitude in degrees
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Geodetic longitude in degrees
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Altitude in meters above WGS-84
    def ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Last status update (ISO 8601)
    def STATUS_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Maintenance history
    def MAINTENANCE(i:int) -> sensorMaintenanceEvent:
        return sensorMaintenanceEvent { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def MAINTENANCE_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    /// Observation plans/taskings
    def PLANS(i:int) -> sensorPlan:
        return sensorPlan { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 4) }
    def PLANS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Operational statistics
    def STATISTICS(i:int) -> sensorStats:
        return sensorStats { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 26) + i * 4) }
    def STATISTICS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    /// Additional notes
    def NOTES() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)

def GetRootAsSEN(buf:string): return SEN { buf, flatbuffers.indirect(buf, 0) }

struct SENBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(13)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, NAME)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, TYPE)
        return this
    def add_STATUS(STATUS:sensorStatus):
        b_.PrependInt8Slot(3, STATUS, 0)
        return this
    def add_SITE_ID(SITE_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, SITE_ID)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(5, LATITUDE, 0.0)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(6, LONGITUDE, 0.0)
        return this
    def add_ALTITUDE(ALTITUDE:float):
        b_.PrependFloat64Slot(7, ALTITUDE, 0.0)
        return this
    def add_STATUS_TIME(STATUS_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, STATUS_TIME)
        return this
    def add_MAINTENANCE(MAINTENANCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, MAINTENANCE)
        return this
    def add_PLANS(PLANS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, PLANS)
        return this
    def add_STATISTICS(STATISTICS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, STATISTICS)
        return this
    def add_NOTES(NOTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, NOTES)
        return this
    def end():
        return b_.EndObject()

def SENStartMAINTENANCEVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SENCreateMAINTENANCEVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def SENStartPLANSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SENCreatePLANSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def SENStartSTATISTICSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SENCreateSTATISTICSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

