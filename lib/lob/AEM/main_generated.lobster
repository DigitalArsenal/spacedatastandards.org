// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class AEMSegment

class AEM

class AEMSegment : flatbuffers.handle
    def OBJECT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    def REF_FRAME_A() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    def REF_FRAME_B() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    def ATTITUDE_DIR() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    def TIME_SYSTEM() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    def ATTITUDE_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    def STOP_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Time interval between attitude states in seconds (required).
    def STEP_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Number of components per attitude state.
    /// 7 = quaternion + angular rates (Q1, Q2, Q3, QC, RATE_X, RATE_Y, RATE_Z)
    /// 4 = quaternion only (Q1, Q2, Q3, QC)
    def ATTITUDE_COMPONENTS() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 24, 7)
    /// Attitude data as row-major array of doubles.
    /// Layout: [Q1_0, Q2_0, Q3_0, QC_0, RATE_X_0, RATE_Y_0, RATE_Z_0, Q1_1, ...]
    /// Time reconstruction: epoch[i] = START_TIME + (i * STEP_SIZE)
    /// Length must be divisible by ATTITUDE_COMPONENTS.
    def ATTITUDE_DATA(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 26) + i * 8)
    def ATTITUDE_DATA_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)

def GetRootAsAEMSegment(buf:string): return AEMSegment { buf, flatbuffers.indirect(buf, 0) }

struct AEMSegmentBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(12)
        return this
    def add_OBJECT_NAME(OBJECT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, OBJECT_NAME)
        return this
    def add_OBJECT_ID(OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, OBJECT_ID)
        return this
    def add_REF_FRAME_A(REF_FRAME_A:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, REF_FRAME_A)
        return this
    def add_REF_FRAME_B(REF_FRAME_B:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, REF_FRAME_B)
        return this
    def add_ATTITUDE_DIR(ATTITUDE_DIR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ATTITUDE_DIR)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, TIME_SYSTEM)
        return this
    def add_ATTITUDE_TYPE(ATTITUDE_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, ATTITUDE_TYPE)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, START_TIME)
        return this
    def add_STOP_TIME(STOP_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, STOP_TIME)
        return this
    def add_STEP_SIZE(STEP_SIZE:float):
        b_.PrependFloat64Slot(9, STEP_SIZE, 0.0)
        return this
    def add_ATTITUDE_COMPONENTS(ATTITUDE_COMPONENTS:int):
        b_.PrependUint8Slot(10, ATTITUDE_COMPONENTS, 7)
        return this
    def add_ATTITUDE_DATA(ATTITUDE_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, ATTITUDE_DATA)
        return this
    def end():
        return b_.EndObject()

def AEMSegmentStartATTITUDE_DATAVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def AEMSegmentCreateATTITUDE_DATAVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// Attitude Ephemeris Message
class AEM : flatbuffers.handle
    def CCSDS_AEM_VERS() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    def SEGMENTS(i:int) -> AEMSegment:
        return AEMSegment { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def SEGMENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)

def GetRootAsAEM(buf:string): return AEM { buf, flatbuffers.indirect(buf, 0) }

struct AEMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_CCSDS_AEM_VERS(CCSDS_AEM_VERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CCSDS_AEM_VERS)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ORIGINATOR)
        return this
    def add_SEGMENTS(SEGMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, SEGMENTS)
        return this
    def end():
        return b_.EndObject()

def AEMStartSEGMENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AEMCreateSEGMENTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

