// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum CZMHeightReference:
    CZMHeightReference_NONE = 0
    CZMHeightReference_CLAMP_TO_GROUND = 1
    CZMHeightReference_RELATIVE_TO_GROUND = 2

enum CZMClassificationType:
    CZMClassificationType_TERRAIN = 0
    CZMClassificationType_CESIUM_3D_TILE = 1
    CZMClassificationType_BOTH = 2

enum CZMLabelStyle:
    CZMLabelStyle_FILL = 0
    CZMLabelStyle_OUTLINE = 1
    CZMLabelStyle_FILL_AND_OUTLINE = 2

enum CZMHorizontalOrigin:
    CZMHorizontalOrigin_LEFT = 0
    CZMHorizontalOrigin_CENTER = 1
    CZMHorizontalOrigin_RIGHT = 2

enum CZMVerticalOrigin:
    CZMVerticalOrigin_BASELINE = 0
    CZMVerticalOrigin_BOTTOM = 1
    CZMVerticalOrigin_CENTER = 2
    CZMVerticalOrigin_TOP = 3

class CZMInterval

class CZMCartographicDegrees

class CZMCartesian

class CZMColor

class CZMNearFarScalar

class CZMBillboard

class CZMLabel

class CZMPoint

class CZMPolyline

class CZMPolygon

class CZMModel

class CZMPath

class CZMEllipse

class CZMPacket

class CZM

/// Time interval for time-dynamic properties
class CZMInterval : flatbuffers.handle
    /// ISO 8601 interval string (e.g. "2012-03-15T10:00:00Z/2012-03-16T10:00:00Z")
    def INTERVAL() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)

def GetRootAsCZMInterval(buf:string): return CZMInterval { buf, flatbuffers.indirect(buf, 0) }

struct CZMIntervalBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_INTERVAL(INTERVAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, INTERVAL)
        return this
    def end():
        return b_.EndObject()

/// Cartographic position (longitude, latitude, height in radians/meters)
class CZMCartographicDegrees : flatbuffers.handle
    /// Longitude in degrees
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Latitude in degrees
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Height in meters above WGS84 ellipsoid
    def HEIGHT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsCZMCartographicDegrees(buf:string): return CZMCartographicDegrees { buf, flatbuffers.indirect(buf, 0) }

struct CZMCartographicDegreesBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(0, LONGITUDE, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(1, LATITUDE, 0.0)
        return this
    def add_HEIGHT(HEIGHT:float):
        b_.PrependFloat64Slot(2, HEIGHT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Cartesian position (X, Y, Z in meters)
class CZMCartesian : flatbuffers.handle
    /// X component in meters (Earth-fixed)
    def X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Y component in meters (Earth-fixed)
    def Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Z component in meters (Earth-fixed)
    def Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsCZMCartesian(buf:string): return CZMCartesian { buf, flatbuffers.indirect(buf, 0) }

struct CZMCartesianBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_X(X:float):
        b_.PrependFloat64Slot(0, X, 0.0)
        return this
    def add_Y(Y:float):
        b_.PrependFloat64Slot(1, Y, 0.0)
        return this
    def add_Z(Z:float):
        b_.PrependFloat64Slot(2, Z, 0.0)
        return this
    def end():
        return b_.EndObject()

/// RGBA color
class CZMColor : flatbuffers.handle
    /// Red component (0-255)
    def RED() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 4, 0)
    /// Green component (0-255)
    def GREEN() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 6, 0)
    /// Blue component (0-255)
    def BLUE() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 8, 0)
    /// Alpha component (0-255)
    def ALPHA() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 10, 0)

def GetRootAsCZMColor(buf:string): return CZMColor { buf, flatbuffers.indirect(buf, 0) }

struct CZMColorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_RED(RED:int):
        b_.PrependUint8Slot(0, RED, 0)
        return this
    def add_GREEN(GREEN:int):
        b_.PrependUint8Slot(1, GREEN, 0)
        return this
    def add_BLUE(BLUE:int):
        b_.PrependUint8Slot(2, BLUE, 0)
        return this
    def add_ALPHA(ALPHA:int):
        b_.PrependUint8Slot(3, ALPHA, 0)
        return this
    def end():
        return b_.EndObject()

/// Near/Far scalar for distance-based display
class CZMNearFarScalar : flatbuffers.handle
    /// Near distance in meters
    def NEAR_DISTANCE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Value at near distance
    def NEAR_VALUE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Far distance in meters
    def FAR_DISTANCE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Value at far distance
    def FAR_VALUE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)

def GetRootAsCZMNearFarScalar(buf:string): return CZMNearFarScalar { buf, flatbuffers.indirect(buf, 0) }

struct CZMNearFarScalarBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_NEAR_DISTANCE(NEAR_DISTANCE:float):
        b_.PrependFloat64Slot(0, NEAR_DISTANCE, 0.0)
        return this
    def add_NEAR_VALUE(NEAR_VALUE:float):
        b_.PrependFloat64Slot(1, NEAR_VALUE, 0.0)
        return this
    def add_FAR_DISTANCE(FAR_DISTANCE:float):
        b_.PrependFloat64Slot(2, FAR_DISTANCE, 0.0)
        return this
    def add_FAR_VALUE(FAR_VALUE:float):
        b_.PrependFloat64Slot(3, FAR_VALUE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Billboard (icon) properties
class CZMBillboard : flatbuffers.handle
    /// Whether the billboard is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// URI of the billboard image
    def IMAGE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Billboard color tint
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: CZMColor { buf_, o } else: nil
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// Pixel offset X
    def PIXEL_OFFSET_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Pixel offset Y
    def PIXEL_OFFSET_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Horizontal origin
    def HORIZONTAL_ORIGIN() -> CZMHorizontalOrigin:
        return CZMHorizontalOrigin(flatbuffers.field_int8(buf_, pos_, 18, 0))
    /// Vertical origin
    def VERTICAL_ORIGIN() -> CZMVerticalOrigin:
        return CZMVerticalOrigin(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Translucency by distance
    def TRANSLUCENCY_BY_DISTANCE() -> CZMNearFarScalar?:
        let o = flatbuffers.field_table(buf_, pos_, 22)
        return if o: CZMNearFarScalar { buf_, o } else: nil

def GetRootAsCZMBillboard(buf:string): return CZMBillboard { buf, flatbuffers.indirect(buf, 0) }

struct CZMBillboardBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_IMAGE(IMAGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, IMAGE)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(2, SCALE, 0.0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, COLOR)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(4, HEIGHT_REFERENCE, 0)
        return this
    def add_PIXEL_OFFSET_X(PIXEL_OFFSET_X:float):
        b_.PrependFloat64Slot(5, PIXEL_OFFSET_X, 0.0)
        return this
    def add_PIXEL_OFFSET_Y(PIXEL_OFFSET_Y:float):
        b_.PrependFloat64Slot(6, PIXEL_OFFSET_Y, 0.0)
        return this
    def add_HORIZONTAL_ORIGIN(HORIZONTAL_ORIGIN:CZMHorizontalOrigin):
        b_.PrependInt8Slot(7, HORIZONTAL_ORIGIN, 0)
        return this
    def add_VERTICAL_ORIGIN(VERTICAL_ORIGIN:CZMVerticalOrigin):
        b_.PrependInt8Slot(8, VERTICAL_ORIGIN, 0)
        return this
    def add_TRANSLUCENCY_BY_DISTANCE(TRANSLUCENCY_BY_DISTANCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, TRANSLUCENCY_BY_DISTANCE)
        return this
    def end():
        return b_.EndObject()

/// Label properties
class CZMLabel : flatbuffers.handle
    /// Whether the label is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Label text
    def TEXT() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Font CSS string (e.g. "12pt Lucida Console")
    def FONT() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Label style
    def STYLE() -> CZMLabelStyle:
        return CZMLabelStyle(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Fill color
    def FILL_COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline color
    def OUTLINE_COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline width in pixels
    def OUTLINE_WIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Pixel offset X
    def PIXEL_OFFSET_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Pixel offset Y
    def PIXEL_OFFSET_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Horizontal origin
    def HORIZONTAL_ORIGIN() -> CZMHorizontalOrigin:
        return CZMHorizontalOrigin(flatbuffers.field_int8(buf_, pos_, 24, 0))
    /// Vertical origin
    def VERTICAL_ORIGIN() -> CZMVerticalOrigin:
        return CZMVerticalOrigin(flatbuffers.field_int8(buf_, pos_, 26, 0))
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 28, 0))

def GetRootAsCZMLabel(buf:string): return CZMLabel { buf, flatbuffers.indirect(buf, 0) }

struct CZMLabelBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(13)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_TEXT(TEXT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, TEXT)
        return this
    def add_FONT(FONT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, FONT)
        return this
    def add_STYLE(STYLE:CZMLabelStyle):
        b_.PrependInt8Slot(3, STYLE, 0)
        return this
    def add_FILL_COLOR(FILL_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, FILL_COLOR)
        return this
    def add_OUTLINE_COLOR(OUTLINE_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, OUTLINE_COLOR)
        return this
    def add_OUTLINE_WIDTH(OUTLINE_WIDTH:float):
        b_.PrependFloat64Slot(6, OUTLINE_WIDTH, 0.0)
        return this
    def add_PIXEL_OFFSET_X(PIXEL_OFFSET_X:float):
        b_.PrependFloat64Slot(7, PIXEL_OFFSET_X, 0.0)
        return this
    def add_PIXEL_OFFSET_Y(PIXEL_OFFSET_Y:float):
        b_.PrependFloat64Slot(8, PIXEL_OFFSET_Y, 0.0)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(9, SCALE, 0.0)
        return this
    def add_HORIZONTAL_ORIGIN(HORIZONTAL_ORIGIN:CZMHorizontalOrigin):
        b_.PrependInt8Slot(10, HORIZONTAL_ORIGIN, 0)
        return this
    def add_VERTICAL_ORIGIN(VERTICAL_ORIGIN:CZMVerticalOrigin):
        b_.PrependInt8Slot(11, VERTICAL_ORIGIN, 0)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(12, HEIGHT_REFERENCE, 0)
        return this
    def end():
        return b_.EndObject()

/// Point properties
class CZMPoint : flatbuffers.handle
    /// Whether the point is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Point color
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline color
    def OUTLINE_COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline width in pixels
    def OUTLINE_WIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Pixel size
    def PIXEL_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 14, 0))

def GetRootAsCZMPoint(buf:string): return CZMPoint { buf, flatbuffers.indirect(buf, 0) }

struct CZMPointBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COLOR)
        return this
    def add_OUTLINE_COLOR(OUTLINE_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, OUTLINE_COLOR)
        return this
    def add_OUTLINE_WIDTH(OUTLINE_WIDTH:float):
        b_.PrependFloat64Slot(3, OUTLINE_WIDTH, 0.0)
        return this
    def add_PIXEL_SIZE(PIXEL_SIZE:float):
        b_.PrependFloat64Slot(4, PIXEL_SIZE, 0.0)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(5, HEIGHT_REFERENCE, 0)
        return this
    def end():
        return b_.EndObject()

/// Polyline properties
class CZMPolyline : flatbuffers.handle
    /// Whether the polyline is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Positions as cartographic degrees [lon, lat, height, lon, lat, height, ...]
    def POSITIONS_CARTOGRAPHIC_DEGREES(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 6) + i * 8)
    def POSITIONS_CARTOGRAPHIC_DEGREES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Positions as Cartesian [X, Y, Z, X, Y, Z, ...]
    def POSITIONS_CARTESIAN(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 8)
    def POSITIONS_CARTESIAN_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Line width in pixels
    def WIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Line color (solid color material)
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: CZMColor { buf_, o } else: nil
    /// Whether to clamp to ground
    def CLAMP_TO_GROUND() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))

def GetRootAsCZMPolyline(buf:string): return CZMPolyline { buf, flatbuffers.indirect(buf, 0) }

struct CZMPolylineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_POSITIONS_CARTOGRAPHIC_DEGREES(POSITIONS_CARTOGRAPHIC_DEGREES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, POSITIONS_CARTOGRAPHIC_DEGREES)
        return this
    def add_POSITIONS_CARTESIAN(POSITIONS_CARTESIAN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, POSITIONS_CARTESIAN)
        return this
    def add_WIDTH(WIDTH:float):
        b_.PrependFloat64Slot(3, WIDTH, 0.0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COLOR)
        return this
    def add_CLAMP_TO_GROUND(CLAMP_TO_GROUND:bool):
        b_.PrependBoolSlot(5, CLAMP_TO_GROUND, 0)
        return this
    def end():
        return b_.EndObject()

def CZMPolylineStartPOSITIONS_CARTOGRAPHIC_DEGREESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPolylineCreatePOSITIONS_CARTOGRAPHIC_DEGREESVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def CZMPolylineStartPOSITIONS_CARTESIANVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPolylineCreatePOSITIONS_CARTESIANVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// Polygon properties
class CZMPolygon : flatbuffers.handle
    /// Whether the polygon is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Positions as cartographic degrees [lon, lat, height, ...]
    def POSITIONS_CARTOGRAPHIC_DEGREES(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 6) + i * 8)
    def POSITIONS_CARTOGRAPHIC_DEGREES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Positions as Cartesian [X, Y, Z, ...]
    def POSITIONS_CARTESIAN(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 8)
    def POSITIONS_CARTESIAN_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Fill flag
    def FILL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Fill color (solid color material)
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline flag
    def OUTLINE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// Outline color
    def OUTLINE_COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: CZMColor { buf_, o } else: nil
    /// Extruded height in meters
    def EXTRUDED_HEIGHT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Classification type
    def CLASSIFICATION_TYPE() -> CZMClassificationType:
        return CZMClassificationType(flatbuffers.field_int8(buf_, pos_, 22, 0))

def GetRootAsCZMPolygon(buf:string): return CZMPolygon { buf, flatbuffers.indirect(buf, 0) }

struct CZMPolygonBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_POSITIONS_CARTOGRAPHIC_DEGREES(POSITIONS_CARTOGRAPHIC_DEGREES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, POSITIONS_CARTOGRAPHIC_DEGREES)
        return this
    def add_POSITIONS_CARTESIAN(POSITIONS_CARTESIAN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, POSITIONS_CARTESIAN)
        return this
    def add_FILL(FILL:bool):
        b_.PrependBoolSlot(3, FILL, 0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COLOR)
        return this
    def add_OUTLINE(OUTLINE:bool):
        b_.PrependBoolSlot(5, OUTLINE, 0)
        return this
    def add_OUTLINE_COLOR(OUTLINE_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, OUTLINE_COLOR)
        return this
    def add_EXTRUDED_HEIGHT(EXTRUDED_HEIGHT:float):
        b_.PrependFloat64Slot(7, EXTRUDED_HEIGHT, 0.0)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(8, HEIGHT_REFERENCE, 0)
        return this
    def add_CLASSIFICATION_TYPE(CLASSIFICATION_TYPE:CZMClassificationType):
        b_.PrependInt8Slot(9, CLASSIFICATION_TYPE, 0)
        return this
    def end():
        return b_.EndObject()

def CZMPolygonStartPOSITIONS_CARTOGRAPHIC_DEGREESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPolygonCreatePOSITIONS_CARTOGRAPHIC_DEGREESVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def CZMPolygonStartPOSITIONS_CARTESIANVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPolygonCreatePOSITIONS_CARTESIANVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// Model properties (glTF)
class CZMModel : flatbuffers.handle
    /// Whether the model is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// URI to the glTF model
    def GLTF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Minimum pixel size
    def MINIMUM_PIXEL_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Maximum scale
    def MAXIMUM_SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// Color tint
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: CZMColor { buf_, o } else: nil

def GetRootAsCZMModel(buf:string): return CZMModel { buf, flatbuffers.indirect(buf, 0) }

struct CZMModelBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_GLTF(GLTF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, GLTF)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(2, SCALE, 0.0)
        return this
    def add_MINIMUM_PIXEL_SIZE(MINIMUM_PIXEL_SIZE:float):
        b_.PrependFloat64Slot(3, MINIMUM_PIXEL_SIZE, 0.0)
        return this
    def add_MAXIMUM_SCALE(MAXIMUM_SCALE:float):
        b_.PrependFloat64Slot(4, MAXIMUM_SCALE, 0.0)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(5, HEIGHT_REFERENCE, 0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, COLOR)
        return this
    def end():
        return b_.EndObject()

/// Path properties (orbit trail)
class CZMPath : flatbuffers.handle
    /// Whether the path is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Trail time in seconds (how far behind)
    def LEAD_TIME() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Lead time in seconds (how far ahead)
    def TRAIL_TIME() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Line width in pixels
    def WIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Path color
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: CZMColor { buf_, o } else: nil
    /// Resolution in seconds
    def RESOLUTION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)

def GetRootAsCZMPath(buf:string): return CZMPath { buf, flatbuffers.indirect(buf, 0) }

struct CZMPathBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_LEAD_TIME(LEAD_TIME:float):
        b_.PrependFloat64Slot(1, LEAD_TIME, 0.0)
        return this
    def add_TRAIL_TIME(TRAIL_TIME:float):
        b_.PrependFloat64Slot(2, TRAIL_TIME, 0.0)
        return this
    def add_WIDTH(WIDTH:float):
        b_.PrependFloat64Slot(3, WIDTH, 0.0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COLOR)
        return this
    def add_RESOLUTION(RESOLUTION:float):
        b_.PrependFloat64Slot(5, RESOLUTION, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Ellipse properties (for ground circles/ellipses)
class CZMEllipse : flatbuffers.handle
    /// Whether the ellipse is displayed
    def SHOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Semi-major axis in meters
    def SEMI_MAJOR_AXIS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Semi-minor axis in meters
    def SEMI_MINOR_AXIS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Rotation from north in radians
    def ROTATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Fill flag
    def FILL() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// Fill color
    def COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: CZMColor { buf_, o } else: nil
    /// Outline flag
    def OUTLINE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Outline color
    def OUTLINE_COLOR() -> CZMColor?:
        let o = flatbuffers.field_table(buf_, pos_, 18)
        return if o: CZMColor { buf_, o } else: nil
    /// Height in meters
    def HEIGHT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Height reference
    def HEIGHT_REFERENCE() -> CZMHeightReference:
        return CZMHeightReference(flatbuffers.field_int8(buf_, pos_, 22, 0))

def GetRootAsCZMEllipse(buf:string): return CZMEllipse { buf, flatbuffers.indirect(buf, 0) }

struct CZMEllipseBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_SHOW(SHOW:bool):
        b_.PrependBoolSlot(0, SHOW, 0)
        return this
    def add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS:float):
        b_.PrependFloat64Slot(1, SEMI_MAJOR_AXIS, 0.0)
        return this
    def add_SEMI_MINOR_AXIS(SEMI_MINOR_AXIS:float):
        b_.PrependFloat64Slot(2, SEMI_MINOR_AXIS, 0.0)
        return this
    def add_ROTATION(ROTATION:float):
        b_.PrependFloat64Slot(3, ROTATION, 0.0)
        return this
    def add_FILL(FILL:bool):
        b_.PrependBoolSlot(4, FILL, 0)
        return this
    def add_COLOR(COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, COLOR)
        return this
    def add_OUTLINE(OUTLINE:bool):
        b_.PrependBoolSlot(6, OUTLINE, 0)
        return this
    def add_OUTLINE_COLOR(OUTLINE_COLOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, OUTLINE_COLOR)
        return this
    def add_HEIGHT(HEIGHT:float):
        b_.PrependFloat64Slot(8, HEIGHT, 0.0)
        return this
    def add_HEIGHT_REFERENCE(HEIGHT_REFERENCE:CZMHeightReference):
        b_.PrependInt8Slot(9, HEIGHT_REFERENCE, 0)
        return this
    def end():
        return b_.EndObject()

/// A CZML Packet describing an entity and its properties
class CZMPacket : flatbuffers.handle
    /// Unique identifier for this object
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Human-readable name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Parent packet ID
    def PARENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Description (HTML allowed)
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Availability interval (ISO 8601 interval)
    def AVAILABILITY() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Position as cartographic degrees
    def POSITION_CARTOGRAPHIC_DEGREES() -> CZMCartographicDegrees?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: CZMCartographicDegrees { buf_, o } else: nil
    /// Position as Cartesian
    def POSITION_CARTESIAN() -> CZMCartesian?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: CZMCartesian { buf_, o } else: nil
    /// Time-tagged positions [time, lon, lat, height, time, lon, lat, height, ...]
    def POSITION_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Time-tagged cartographic degree values
    def POSITION_CARTOGRAPHIC_DEGREES_ARRAY(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 20) + i * 8)
    def POSITION_CARTOGRAPHIC_DEGREES_ARRAY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// Time-tagged Cartesian values
    def POSITION_CARTESIAN_ARRAY(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 22) + i * 8)
    def POSITION_CARTESIAN_ARRAY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    /// Billboard properties
    def BILLBOARD() -> CZMBillboard?:
        let o = flatbuffers.field_table(buf_, pos_, 24)
        return if o: CZMBillboard { buf_, o } else: nil
    /// Label properties
    def LABEL() -> CZMLabel?:
        let o = flatbuffers.field_table(buf_, pos_, 26)
        return if o: CZMLabel { buf_, o } else: nil
    /// Point properties
    def POINT() -> CZMPoint?:
        let o = flatbuffers.field_table(buf_, pos_, 28)
        return if o: CZMPoint { buf_, o } else: nil
    /// Polyline properties
    def POLYLINE() -> CZMPolyline?:
        let o = flatbuffers.field_table(buf_, pos_, 30)
        return if o: CZMPolyline { buf_, o } else: nil
    /// Polygon properties
    def POLYGON() -> CZMPolygon?:
        let o = flatbuffers.field_table(buf_, pos_, 32)
        return if o: CZMPolygon { buf_, o } else: nil
    /// Model properties
    def MODEL() -> CZMModel?:
        let o = flatbuffers.field_table(buf_, pos_, 34)
        return if o: CZMModel { buf_, o } else: nil
    /// Path properties
    def PATH() -> CZMPath?:
        let o = flatbuffers.field_table(buf_, pos_, 36)
        return if o: CZMPath { buf_, o } else: nil
    /// Ellipse properties
    def ELLIPSE() -> CZMEllipse?:
        let o = flatbuffers.field_table(buf_, pos_, 38)
        return if o: CZMEllipse { buf_, o } else: nil

def GetRootAsCZMPacket(buf:string): return CZMPacket { buf, flatbuffers.indirect(buf, 0) }

struct CZMPacketBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(18)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, NAME)
        return this
    def add_PARENT(PARENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PARENT)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DESCRIPTION)
        return this
    def add_AVAILABILITY(AVAILABILITY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, AVAILABILITY)
        return this
    def add_POSITION_CARTOGRAPHIC_DEGREES(POSITION_CARTOGRAPHIC_DEGREES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, POSITION_CARTOGRAPHIC_DEGREES)
        return this
    def add_POSITION_CARTESIAN(POSITION_CARTESIAN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, POSITION_CARTESIAN)
        return this
    def add_POSITION_EPOCH(POSITION_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, POSITION_EPOCH)
        return this
    def add_POSITION_CARTOGRAPHIC_DEGREES_ARRAY(POSITION_CARTOGRAPHIC_DEGREES_ARRAY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, POSITION_CARTOGRAPHIC_DEGREES_ARRAY)
        return this
    def add_POSITION_CARTESIAN_ARRAY(POSITION_CARTESIAN_ARRAY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, POSITION_CARTESIAN_ARRAY)
        return this
    def add_BILLBOARD(BILLBOARD:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, BILLBOARD)
        return this
    def add_LABEL(LABEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, LABEL)
        return this
    def add_POINT(POINT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, POINT)
        return this
    def add_POLYLINE(POLYLINE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, POLYLINE)
        return this
    def add_POLYGON(POLYGON:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, POLYGON)
        return this
    def add_MODEL(MODEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, MODEL)
        return this
    def add_PATH(PATH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, PATH)
        return this
    def add_ELLIPSE(ELLIPSE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, ELLIPSE)
        return this
    def end():
        return b_.EndObject()

def CZMPacketStartPOSITION_CARTOGRAPHIC_DEGREES_ARRAYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPacketCreatePOSITION_CARTOGRAPHIC_DEGREES_ARRAYVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def CZMPacketStartPOSITION_CARTESIAN_ARRAYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def CZMPacketCreatePOSITION_CARTESIAN_ARRAYVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// CZML Document
class CZM : flatbuffers.handle
    /// Document-level name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Document-level version
    def VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Clock settings - current time (ISO 8601)
    def CLOCK_CURRENT_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Clock settings - interval (ISO 8601 interval)
    def CLOCK_INTERVAL() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Clock settings - multiplier
    def CLOCK_MULTIPLIER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// All packets in the document
    def PACKETS(i:int) -> CZMPacket:
        return CZMPacket { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def PACKETS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)

def GetRootAsCZM(buf:string): return CZM { buf, flatbuffers.indirect(buf, 0) }

struct CZMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_VERSION(VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VERSION)
        return this
    def add_CLOCK_CURRENT_TIME(CLOCK_CURRENT_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CLOCK_CURRENT_TIME)
        return this
    def add_CLOCK_INTERVAL(CLOCK_INTERVAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CLOCK_INTERVAL)
        return this
    def add_CLOCK_MULTIPLIER(CLOCK_MULTIPLIER:float):
        b_.PrependFloat64Slot(4, CLOCK_MULTIPLIER, 0.0)
        return this
    def add_PACKETS(PACKETS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, PACKETS)
        return this
    def end():
        return b_.EndObject()

def CZMStartPACKETSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CZMCreatePACKETSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

