// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class ephemerisDataLine

class covarianceMatrixLine

class ephemerisDataBlock

class OEM

/// A single ephemeris data line (for non-uniform time steps only)
/// Use this format when time intervals between states are irregular.
/// For uniform time steps, use the compact EPHEMERIS_DATA array instead.
class ephemerisDataLine : flatbuffers.handle
    /// Epoch time, in ISO 8601 UTC format (required for non-uniform steps)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Position vector X-component km
    def X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Position vector Y-component km
    def Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Position vector Z-component km
    def Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Velocity vector X-component km/s
    def X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Velocity vector Y-component km/s
    def Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Velocity vector Z-component km/s
    def Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Optional: Acceleration vector X-component km/s²
    def X_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Optional: Acceleration vector Y-component km/s²
    def Y_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Optional: Acceleration vector Z-component km/s²
    def Z_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)

def GetRootAsephemerisDataLine(buf:string): return ephemerisDataLine { buf, flatbuffers.indirect(buf, 0) }

struct ephemerisDataLineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_X(X:float):
        b_.PrependFloat64Slot(1, X, 0.0)
        return this
    def add_Y(Y:float):
        b_.PrependFloat64Slot(2, Y, 0.0)
        return this
    def add_Z(Z:float):
        b_.PrependFloat64Slot(3, Z, 0.0)
        return this
    def add_X_DOT(X_DOT:float):
        b_.PrependFloat64Slot(4, X_DOT, 0.0)
        return this
    def add_Y_DOT(Y_DOT:float):
        b_.PrependFloat64Slot(5, Y_DOT, 0.0)
        return this
    def add_Z_DOT(Z_DOT:float):
        b_.PrependFloat64Slot(6, Z_DOT, 0.0)
        return this
    def add_X_DDOT(X_DDOT:float):
        b_.PrependFloat64Slot(7, X_DDOT, 0.0)
        return this
    def add_Y_DDOT(Y_DDOT:float):
        b_.PrependFloat64Slot(8, Y_DDOT, 0.0)
        return this
    def add_Z_DDOT(Z_DDOT:float):
        b_.PrependFloat64Slot(9, Z_DDOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Position/Velocity Covariance Matrix Line
class covarianceMatrixLine : flatbuffers.handle
    /// Epoch
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Covariance matrix [1,1] km**2
    def CX_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Covariance matrix [2,1] km**2
    def CY_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Covariance matrix [2,2] km**2
    def CY_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Covariance matrix [3,1] km**2
    def CZ_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Covariance matrix [3,2] km**2
    def CZ_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Covariance matrix [3,3] km**2
    def CZ_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Covariance matrix [4,1] km**2/s
    def CX_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Covariance matrix [4,2] km**2/s
    def CX_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Covariance matrix [4,3] km**2/s
    def CX_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Covariance matrix [4,4] km**2/s**2
    def CX_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Covariance matrix [5,1] km**2/s
    def CY_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Covariance matrix [5,2] km**2/s
    def CY_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Covariance matrix [5,3] km**2/s
    def CY_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Covariance matrix [5,4] km**2/s**2
    def CY_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Covariance matrix [5,5] km**2/s**2
    def CY_DOT_Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Covariance matrix [6,1] km**2/s
    def CZ_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Covariance matrix [6,2] km**2/s
    def CZ_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Covariance matrix [6,3] km**2/s
    def CZ_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Covariance matrix [6,4] km**2/s**2
    def CZ_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Covariance matrix [6,5] km**2/s**2
    def CZ_DOT_Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Covariance matrix [6,6] km**2/s**2
    def CZ_DOT_Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)

def GetRootAscovarianceMatrixLine(buf:string): return covarianceMatrixLine { buf, flatbuffers.indirect(buf, 0) }

struct covarianceMatrixLineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(22)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_CX_X(CX_X:float):
        b_.PrependFloat64Slot(1, CX_X, 0.0)
        return this
    def add_CY_X(CY_X:float):
        b_.PrependFloat64Slot(2, CY_X, 0.0)
        return this
    def add_CY_Y(CY_Y:float):
        b_.PrependFloat64Slot(3, CY_Y, 0.0)
        return this
    def add_CZ_X(CZ_X:float):
        b_.PrependFloat64Slot(4, CZ_X, 0.0)
        return this
    def add_CZ_Y(CZ_Y:float):
        b_.PrependFloat64Slot(5, CZ_Y, 0.0)
        return this
    def add_CZ_Z(CZ_Z:float):
        b_.PrependFloat64Slot(6, CZ_Z, 0.0)
        return this
    def add_CX_DOT_X(CX_DOT_X:float):
        b_.PrependFloat64Slot(7, CX_DOT_X, 0.0)
        return this
    def add_CX_DOT_Y(CX_DOT_Y:float):
        b_.PrependFloat64Slot(8, CX_DOT_Y, 0.0)
        return this
    def add_CX_DOT_Z(CX_DOT_Z:float):
        b_.PrependFloat64Slot(9, CX_DOT_Z, 0.0)
        return this
    def add_CX_DOT_X_DOT(CX_DOT_X_DOT:float):
        b_.PrependFloat64Slot(10, CX_DOT_X_DOT, 0.0)
        return this
    def add_CY_DOT_X(CY_DOT_X:float):
        b_.PrependFloat64Slot(11, CY_DOT_X, 0.0)
        return this
    def add_CY_DOT_Y(CY_DOT_Y:float):
        b_.PrependFloat64Slot(12, CY_DOT_Y, 0.0)
        return this
    def add_CY_DOT_Z(CY_DOT_Z:float):
        b_.PrependFloat64Slot(13, CY_DOT_Z, 0.0)
        return this
    def add_CY_DOT_X_DOT(CY_DOT_X_DOT:float):
        b_.PrependFloat64Slot(14, CY_DOT_X_DOT, 0.0)
        return this
    def add_CY_DOT_Y_DOT(CY_DOT_Y_DOT:float):
        b_.PrependFloat64Slot(15, CY_DOT_Y_DOT, 0.0)
        return this
    def add_CZ_DOT_X(CZ_DOT_X:float):
        b_.PrependFloat64Slot(16, CZ_DOT_X, 0.0)
        return this
    def add_CZ_DOT_Y(CZ_DOT_Y:float):
        b_.PrependFloat64Slot(17, CZ_DOT_Y, 0.0)
        return this
    def add_CZ_DOT_Z(CZ_DOT_Z:float):
        b_.PrependFloat64Slot(18, CZ_DOT_Z, 0.0)
        return this
    def add_CZ_DOT_X_DOT(CZ_DOT_X_DOT:float):
        b_.PrependFloat64Slot(19, CZ_DOT_X_DOT, 0.0)
        return this
    def add_CZ_DOT_Y_DOT(CZ_DOT_Y_DOT:float):
        b_.PrependFloat64Slot(20, CZ_DOT_Y_DOT, 0.0)
        return this
    def add_CZ_DOT_Z_DOT(CZ_DOT_Z_DOT:float):
        b_.PrependFloat64Slot(21, CZ_DOT_Z_DOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// OEM Ephemeris Data Block
class ephemerisDataBlock : flatbuffers.handle
    /// Plain-Text Comment
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Satellite name for the first object
    def OBJECT() -> CAT?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: CAT { buf_, o } else: nil
    /// Origin of reference frame (EARTH, MARS, MOON, etc.)
    def CENTER_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Name of the reference frame (TEME, EME2000, etc.)
    def REFERENCE_FRAME() -> RFM?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: RFM { buf_, o } else: nil
    /// Epoch of reference frame, if not intrinsic to the definition of the reference frame
    def REFERENCE_FRAME_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Reference frame for the covariance matrix
    def COV_REFERENCE_FRAME() -> RFM?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: RFM { buf_, o } else: nil
    /// Time system used for the orbit state and covariance matrix. (UTC)
    def TIME_SYSTEM() -> timeSystem:
        return timeSystem(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
    def USEABLE_START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
    def USEABLE_STOP_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
    def STOP_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
    def INTERPOLATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Recommended interpolation degree for ephemeris data
    def INTERPOLATION_DEGREE() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 28, 0)
    /// Time interval between ephemeris states in seconds.
    /// If > 0: Use compact EPHEMERIS_DATA array (times are implicit).
    /// If 0 or omitted: Use EPHEMERIS_DATA_LINES with explicit epochs.
    def STEP_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Number of components per state vector in EPHEMERIS_DATA array.
    /// 6 = position + velocity (X, Y, Z, X_DOT, Y_DOT, Z_DOT)
    /// 9 = position + velocity + acceleration (adds X_DDOT, Y_DDOT, Z_DDOT)
    /// Only used when STEP_SIZE > 0. Default is 6.
    def STATE_VECTOR_SIZE() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 32, 6)
    /// Compact ephemeris data as row-major array of doubles.
    /// Only used when STEP_SIZE > 0.
    /// Layout: [x0,y0,z0,xdot0,ydot0,zdot0, x1,y1,z1,xdot1,ydot1,zdot1, ...]
    /// Units: position in km, velocity in km/s, acceleration in km/s²
    /// Length must be divisible by STATE_VECTOR_SIZE.
    /// Number of states = length(EPHEMERIS_DATA) / STATE_VECTOR_SIZE
    def EPHEMERIS_DATA(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 34) + i * 8)
    def EPHEMERIS_DATA_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 34)
    /// Array of ephemeris data lines with explicit epochs.
    /// Only used when STEP_SIZE == 0 or omitted (non-uniform time steps).
    /// Each line contains its own EPOCH timestamp.
    def EPHEMERIS_DATA_LINES(i:int) -> ephemerisDataLine:
        return ephemerisDataLine { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 36) + i * 4) }
    def EPHEMERIS_DATA_LINES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 36)
    /// Array of covariance matrix lines (optional)
    def COVARIANCE_MATRIX_LINES(i:int) -> covarianceMatrixLine:
        return covarianceMatrixLine { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 38) + i * 4) }
    def COVARIANCE_MATRIX_LINES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 38)

def GetRootAsephemerisDataBlock(buf:string): return ephemerisDataBlock { buf, flatbuffers.indirect(buf, 0) }

struct ephemerisDataBlockBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(18)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COMMENT)
        return this
    def add_OBJECT(OBJECT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, OBJECT)
        return this
    def add_CENTER_NAME(CENTER_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CENTER_NAME)
        return this
    def add_REFERENCE_FRAME(REFERENCE_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, REFERENCE_FRAME)
        return this
    def add_REFERENCE_FRAME_EPOCH(REFERENCE_FRAME_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, REFERENCE_FRAME_EPOCH)
        return this
    def add_COV_REFERENCE_FRAME(COV_REFERENCE_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, COV_REFERENCE_FRAME)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:timeSystem):
        b_.PrependInt8Slot(6, TIME_SYSTEM, 0)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, START_TIME)
        return this
    def add_USEABLE_START_TIME(USEABLE_START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, USEABLE_START_TIME)
        return this
    def add_USEABLE_STOP_TIME(USEABLE_STOP_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, USEABLE_STOP_TIME)
        return this
    def add_STOP_TIME(STOP_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, STOP_TIME)
        return this
    def add_INTERPOLATION(INTERPOLATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, INTERPOLATION)
        return this
    def add_INTERPOLATION_DEGREE(INTERPOLATION_DEGREE:int):
        b_.PrependUint32Slot(12, INTERPOLATION_DEGREE, 0)
        return this
    def add_STEP_SIZE(STEP_SIZE:float):
        b_.PrependFloat64Slot(13, STEP_SIZE, 0.0)
        return this
    def add_STATE_VECTOR_SIZE(STATE_VECTOR_SIZE:int):
        b_.PrependUint8Slot(14, STATE_VECTOR_SIZE, 6)
        return this
    def add_EPHEMERIS_DATA(EPHEMERIS_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, EPHEMERIS_DATA)
        return this
    def add_EPHEMERIS_DATA_LINES(EPHEMERIS_DATA_LINES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, EPHEMERIS_DATA_LINES)
        return this
    def add_COVARIANCE_MATRIX_LINES(COVARIANCE_MATRIX_LINES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, COVARIANCE_MATRIX_LINES)
        return this
    def end():
        return b_.EndObject()

def ephemerisDataBlockStartEPHEMERIS_DATAVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def ephemerisDataBlockCreateEPHEMERIS_DATAVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

def ephemerisDataBlockStartEPHEMERIS_DATA_LINESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ephemerisDataBlockCreateEPHEMERIS_DATA_LINESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ephemerisDataBlockStartCOVARIANCE_MATRIX_LINESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ephemerisDataBlockCreateCOVARIANCE_MATRIX_LINESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Orbit Ephemeris Message
class OEM : flatbuffers.handle
    /// OEM Header
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    def CLASSIFICATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// OEM Version
    def CCSDS_OEM_VERS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Creation Date
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Originator
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Array of ephemeris data blocks
    def EPHEMERIS_DATA_BLOCK(i:int) -> ephemerisDataBlock:
        return ephemerisDataBlock { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def EPHEMERIS_DATA_BLOCK_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsOEM(buf:string): return OEM { buf, flatbuffers.indirect(buf, 0) }

struct OEMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_CLASSIFICATION(CLASSIFICATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CLASSIFICATION)
        return this
    def add_CCSDS_OEM_VERS(CCSDS_OEM_VERS:float):
        b_.PrependFloat64Slot(1, CCSDS_OEM_VERS, 0.0)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ORIGINATOR)
        return this
    def add_EPHEMERIS_DATA_BLOCK(EPHEMERIS_DATA_BLOCK:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, EPHEMERIS_DATA_BLOCK)
        return this
    def end():
        return b_.EndObject()

def OEMStartEPHEMERIS_DATA_BLOCKVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OEMCreateEPHEMERIS_DATA_BLOCKVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

