// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class ephemerisDataLine

class covarianceMatrixLine

class ephemerisDataBlock

class OEM

class OEMCOLLECTION

/// A single ephemeris data line
class ephemerisDataLine : flatbuffers.handle
    /// Epoch time, in ISO 8601 UTC format
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Position vector X-component km
    def X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Position vector Y-component km
    def Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Position vector Z-component km
    def Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Velocity vector X-component km/s
    def X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Velocity vector Y-component km/s
    def Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Velocity vector Z-component km/s
    def Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Optional: Acceleration vector X-component km/s/s
    def X_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Optional: Acceleration vector Y-component km/s/s
    def Y_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Optional: Acceleration vector Z-component km/s/s
    def Z_DDOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)

def GetRootAsephemerisDataLine(buf:string): return ephemerisDataLine { buf, flatbuffers.indirect(buf, 0) }

struct ephemerisDataLineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_X(X:float):
        b_.PrependFloat64Slot(1, X, 0.0)
        return this
    def add_Y(Y:float):
        b_.PrependFloat64Slot(2, Y, 0.0)
        return this
    def add_Z(Z:float):
        b_.PrependFloat64Slot(3, Z, 0.0)
        return this
    def add_X_DOT(X_DOT:float):
        b_.PrependFloat64Slot(4, X_DOT, 0.0)
        return this
    def add_Y_DOT(Y_DOT:float):
        b_.PrependFloat64Slot(5, Y_DOT, 0.0)
        return this
    def add_Z_DOT(Z_DOT:float):
        b_.PrependFloat64Slot(6, Z_DOT, 0.0)
        return this
    def add_X_DDOT(X_DDOT:float):
        b_.PrependFloat64Slot(7, X_DDOT, 0.0)
        return this
    def add_Y_DDOT(Y_DDOT:float):
        b_.PrependFloat64Slot(8, Y_DDOT, 0.0)
        return this
    def add_Z_DDOT(Z_DDOT:float):
        b_.PrependFloat64Slot(9, Z_DDOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Position/Velocity Covariance Matrix Line
class covarianceMatrixLine : flatbuffers.handle
    /// Epoch
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Covariance matrix [1,1] km**2
    def CX_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Covariance matrix [2,1] km**2
    def CY_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Covariance matrix [2,2] km**2
    def CY_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Covariance matrix [3,1] km**2
    def CZ_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Covariance matrix [3,2] km**2
    def CZ_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Covariance matrix [3,3] km**2
    def CZ_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Covariance matrix [4,1] km**2/s
    def CX_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Covariance matrix [4,2] km**2/s
    def CX_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Covariance matrix [4,3] km**2/s
    def CX_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Covariance matrix [4,4] km**2/s**2
    def CX_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Covariance matrix [5,1] km**2/s
    def CY_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Covariance matrix [5,2] km**2/s
    def CY_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Covariance matrix [5,3] km**2/s
    def CY_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Covariance matrix [5,4] km**2/s**2
    def CY_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Covariance matrix [5,5] km**2/s**2
    def CY_DOT_Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Covariance matrix [6,1] km**2/s
    def CZ_DOT_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Covariance matrix [6,2] km**2/s
    def CZ_DOT_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Covariance matrix [6,3] km**2/s
    def CZ_DOT_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Covariance matrix [6,4] km**2/s**2
    def CZ_DOT_X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Covariance matrix [6,5] km**2/s**2
    def CZ_DOT_Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Covariance matrix [6,6] km**2/s**2
    def CZ_DOT_Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)

def GetRootAscovarianceMatrixLine(buf:string): return covarianceMatrixLine { buf, flatbuffers.indirect(buf, 0) }

struct covarianceMatrixLineBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(22)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_CX_X(CX_X:float):
        b_.PrependFloat64Slot(1, CX_X, 0.0)
        return this
    def add_CY_X(CY_X:float):
        b_.PrependFloat64Slot(2, CY_X, 0.0)
        return this
    def add_CY_Y(CY_Y:float):
        b_.PrependFloat64Slot(3, CY_Y, 0.0)
        return this
    def add_CZ_X(CZ_X:float):
        b_.PrependFloat64Slot(4, CZ_X, 0.0)
        return this
    def add_CZ_Y(CZ_Y:float):
        b_.PrependFloat64Slot(5, CZ_Y, 0.0)
        return this
    def add_CZ_Z(CZ_Z:float):
        b_.PrependFloat64Slot(6, CZ_Z, 0.0)
        return this
    def add_CX_DOT_X(CX_DOT_X:float):
        b_.PrependFloat64Slot(7, CX_DOT_X, 0.0)
        return this
    def add_CX_DOT_Y(CX_DOT_Y:float):
        b_.PrependFloat64Slot(8, CX_DOT_Y, 0.0)
        return this
    def add_CX_DOT_Z(CX_DOT_Z:float):
        b_.PrependFloat64Slot(9, CX_DOT_Z, 0.0)
        return this
    def add_CX_DOT_X_DOT(CX_DOT_X_DOT:float):
        b_.PrependFloat64Slot(10, CX_DOT_X_DOT, 0.0)
        return this
    def add_CY_DOT_X(CY_DOT_X:float):
        b_.PrependFloat64Slot(11, CY_DOT_X, 0.0)
        return this
    def add_CY_DOT_Y(CY_DOT_Y:float):
        b_.PrependFloat64Slot(12, CY_DOT_Y, 0.0)
        return this
    def add_CY_DOT_Z(CY_DOT_Z:float):
        b_.PrependFloat64Slot(13, CY_DOT_Z, 0.0)
        return this
    def add_CY_DOT_X_DOT(CY_DOT_X_DOT:float):
        b_.PrependFloat64Slot(14, CY_DOT_X_DOT, 0.0)
        return this
    def add_CY_DOT_Y_DOT(CY_DOT_Y_DOT:float):
        b_.PrependFloat64Slot(15, CY_DOT_Y_DOT, 0.0)
        return this
    def add_CZ_DOT_X(CZ_DOT_X:float):
        b_.PrependFloat64Slot(16, CZ_DOT_X, 0.0)
        return this
    def add_CZ_DOT_Y(CZ_DOT_Y:float):
        b_.PrependFloat64Slot(17, CZ_DOT_Y, 0.0)
        return this
    def add_CZ_DOT_Z(CZ_DOT_Z:float):
        b_.PrependFloat64Slot(18, CZ_DOT_Z, 0.0)
        return this
    def add_CZ_DOT_X_DOT(CZ_DOT_X_DOT:float):
        b_.PrependFloat64Slot(19, CZ_DOT_X_DOT, 0.0)
        return this
    def add_CZ_DOT_Y_DOT(CZ_DOT_Y_DOT:float):
        b_.PrependFloat64Slot(20, CZ_DOT_Y_DOT, 0.0)
        return this
    def add_CZ_DOT_Z_DOT(CZ_DOT_Z_DOT:float):
        b_.PrependFloat64Slot(21, CZ_DOT_Z_DOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// OEM Ephemeris Data Block
class ephemerisDataBlock : flatbuffers.handle
    /// Plain-Text Comment
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Satellite name for the first object
    def OBJECT() -> CAT?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: CAT { buf_, o } else: nil
    /// Origin of reference frame (EARTH, MARS, MOON, etc.)
    def CENTER_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Name of the reference frame (TEME, EME2000, etc.)
    def REFERENCE_FRAME() -> refFrame:
        return refFrame(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Epoch of reference frame, if not intrinsic to the definition of the reference frame
    def REFERENCE_FRAME_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Reference frame for the covariance matrix
    def COV_REFERENCE_FRAME() -> refFrame:
        return refFrame(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// Time system used for the orbit state and covariance matrix. (UTC)
    def TIME_SYSTEM() -> timeSystem:
        return timeSystem(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
    def USEABLE_START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
    def USEABLE_STOP_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
    def STOP_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Step size in seconds separating the epochs of each ephemeris data row
    def STEP_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
    def INTERPOLATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Recommended interpolation degree for ephemeris data
    def INTERPOLATION_DEGREE() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 30, 0)
    /// Array of ephemeris data lines
    def EPHEMERIS_DATA_LINES(i:int) -> ephemerisDataLine:
        return ephemerisDataLine { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 32) + i * 4) }
    def EPHEMERIS_DATA_LINES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 32)
    /// Array of covariance matrix lines
    def COVARIANCE_MATRIX_LINES(i:int) -> covarianceMatrixLine:
        return covarianceMatrixLine { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 34) + i * 4) }
    def COVARIANCE_MATRIX_LINES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 34)

def GetRootAsephemerisDataBlock(buf:string): return ephemerisDataBlock { buf, flatbuffers.indirect(buf, 0) }

struct ephemerisDataBlockBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(16)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COMMENT)
        return this
    def add_OBJECT(OBJECT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, OBJECT)
        return this
    def add_CENTER_NAME(CENTER_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CENTER_NAME)
        return this
    def add_REFERENCE_FRAME(REFERENCE_FRAME:refFrame):
        b_.PrependInt8Slot(3, REFERENCE_FRAME, 0)
        return this
    def add_REFERENCE_FRAME_EPOCH(REFERENCE_FRAME_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, REFERENCE_FRAME_EPOCH)
        return this
    def add_COV_REFERENCE_FRAME(COV_REFERENCE_FRAME:refFrame):
        b_.PrependInt8Slot(5, COV_REFERENCE_FRAME, 0)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:timeSystem):
        b_.PrependInt8Slot(6, TIME_SYSTEM, 0)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, START_TIME)
        return this
    def add_USEABLE_START_TIME(USEABLE_START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, USEABLE_START_TIME)
        return this
    def add_USEABLE_STOP_TIME(USEABLE_STOP_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, USEABLE_STOP_TIME)
        return this
    def add_STOP_TIME(STOP_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, STOP_TIME)
        return this
    def add_STEP_SIZE(STEP_SIZE:float):
        b_.PrependFloat64Slot(11, STEP_SIZE, 0.0)
        return this
    def add_INTERPOLATION(INTERPOLATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, INTERPOLATION)
        return this
    def add_INTERPOLATION_DEGREE(INTERPOLATION_DEGREE:int):
        b_.PrependUint32Slot(13, INTERPOLATION_DEGREE, 0)
        return this
    def add_EPHEMERIS_DATA_LINES(EPHEMERIS_DATA_LINES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, EPHEMERIS_DATA_LINES)
        return this
    def add_COVARIANCE_MATRIX_LINES(COVARIANCE_MATRIX_LINES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, COVARIANCE_MATRIX_LINES)
        return this
    def end():
        return b_.EndObject()

def ephemerisDataBlockStartEPHEMERIS_DATA_LINESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ephemerisDataBlockCreateEPHEMERIS_DATA_LINESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ephemerisDataBlockStartCOVARIANCE_MATRIX_LINESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ephemerisDataBlockCreateCOVARIANCE_MATRIX_LINESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Orbit Ephemeris Message
class OEM : flatbuffers.handle
    /// OEM Header
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    def CLASSIFICATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// OEM Version
    def CCSDS_OEM_VERS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Creation Date
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Originator
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Array of ephemeris data blocks
    def EPHEMERIS_DATA_BLOCK(i:int) -> ephemerisDataBlock:
        return ephemerisDataBlock { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def EPHEMERIS_DATA_BLOCK_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsOEM(buf:string): return OEM { buf, flatbuffers.indirect(buf, 0) }

struct OEMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_CLASSIFICATION(CLASSIFICATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CLASSIFICATION)
        return this
    def add_CCSDS_OEM_VERS(CCSDS_OEM_VERS:float):
        b_.PrependFloat64Slot(1, CCSDS_OEM_VERS, 0.0)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ORIGINATOR)
        return this
    def add_EPHEMERIS_DATA_BLOCK(EPHEMERIS_DATA_BLOCK:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, EPHEMERIS_DATA_BLOCK)
        return this
    def end():
        return b_.EndObject()

def OEMStartEPHEMERIS_DATA_BLOCKVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OEMCreateEPHEMERIS_DATA_BLOCKVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of OEM messages
class OEMCOLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> OEM:
        return OEM { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsOEMCOLLECTION(buf:string): return OEMCOLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct OEMCOLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def OEMCOLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OEMCOLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

