// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// Access type for data listings
enum accessType:
    /// One-time purchase
    accessType_OneTime = 0
    /// Recurring subscription
    accessType_Subscription = 1
    /// Real-time streaming access
    accessType_Streaming = 2
    /// Query-based access
    accessType_Query = 3

/// Payment method accepted
enum paymentMethod:
    /// Ethereum cryptocurrency
    paymentMethod_Crypto_ETH = 0
    /// Solana cryptocurrency
    paymentMethod_Crypto_SOL = 1
    /// Bitcoin cryptocurrency
    paymentMethod_Crypto_BTC = 2
    /// Internal SDN credits system
    paymentMethod_SDN_Credits = 3
    /// Fiat payment via Stripe
    paymentMethod_Fiat_Stripe = 4
    /// Free/open data
    paymentMethod_Free = 5

class SpatialCoverage

class TemporalCoverage

class DataCoverage

class PricingTier

class STF

/// Spatial coverage definition
class SpatialCoverage : flatbuffers.handle
    /// Type of coverage: "global", "region", "object_list"
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Regions covered, e.g., ["LEO", "GEO", "MEO"]
    def REGIONS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 6) + i * 4)
    def REGIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Specific NORAD IDs or catalog numbers
    def OBJECT_IDS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 4)
    def OBJECT_IDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsSpatialCoverage(buf:string): return SpatialCoverage { buf, flatbuffers.indirect(buf, 0) }

struct SpatialCoverageBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, TYPE)
        return this
    def add_REGIONS(REGIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, REGIONS)
        return this
    def add_OBJECT_IDS(OBJECT_IDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, OBJECT_IDS)
        return this
    def end():
        return b_.EndObject()

def SpatialCoverageStartREGIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SpatialCoverageCreateREGIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def SpatialCoverageStartOBJECT_IDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SpatialCoverageCreateOBJECT_IDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Temporal coverage definition
class TemporalCoverage : flatbuffers.handle
    /// Start epoch in ISO 8601 format
    def START_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// End epoch in ISO 8601 format
    def END_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Update frequency: "realtime", "hourly", "daily"
    def UPDATE_FREQUENCY() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Days of historical data available
    def HISTORICAL_DEPTH() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)

def GetRootAsTemporalCoverage(buf:string): return TemporalCoverage { buf, flatbuffers.indirect(buf, 0) }

struct TemporalCoverageBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_START_EPOCH(START_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, START_EPOCH)
        return this
    def add_END_EPOCH(END_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, END_EPOCH)
        return this
    def add_UPDATE_FREQUENCY(UPDATE_FREQUENCY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, UPDATE_FREQUENCY)
        return this
    def add_HISTORICAL_DEPTH(HISTORICAL_DEPTH:int):
        b_.PrependUint32Slot(3, HISTORICAL_DEPTH, 0)
        return this
    def end():
        return b_.EndObject()

/// Data coverage combining spatial and temporal
class DataCoverage : flatbuffers.handle
    /// Spatial coverage definition
    def SPATIAL() -> SpatialCoverage?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: SpatialCoverage { buf_, o } else: nil
    /// Temporal coverage definition
    def TEMPORAL() -> TemporalCoverage?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: TemporalCoverage { buf_, o } else: nil

def GetRootAsDataCoverage(buf:string): return DataCoverage { buf, flatbuffers.indirect(buf, 0) }

struct DataCoverageBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_SPATIAL(SPATIAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, SPATIAL)
        return this
    def add_TEMPORAL(TEMPORAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, TEMPORAL)
        return this
    def end():
        return b_.EndObject()

/// Pricing tier for a listing
class PricingTier : flatbuffers.handle
    /// Tier name, e.g., "Basic", "Pro", "Enterprise"
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Price in smallest unit (cents, satoshis, etc.)
    def PRICE_AMOUNT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 6, 0)
    /// Currency code: "USD", "ETH", "SOL", "SDN_CREDITS"
    def PRICE_CURRENCY() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Duration in days (0 = one-time purchase)
    def DURATION_DAYS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)
    /// Rate limit in requests per hour
    def RATE_LIMIT() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 12, 0)
    /// List of features included in this tier
    def FEATURES(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 4)
    def FEATURES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)

def GetRootAsPricingTier(buf:string): return PricingTier { buf, flatbuffers.indirect(buf, 0) }

struct PricingTierBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_PRICE_AMOUNT(PRICE_AMOUNT:int):
        b_.PrependUint64Slot(1, PRICE_AMOUNT, 0)
        return this
    def add_PRICE_CURRENCY(PRICE_CURRENCY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PRICE_CURRENCY)
        return this
    def add_DURATION_DAYS(DURATION_DAYS:int):
        b_.PrependUint32Slot(3, DURATION_DAYS, 0)
        return this
    def add_RATE_LIMIT(RATE_LIMIT:int):
        b_.PrependUint32Slot(4, RATE_LIMIT, 0)
        return this
    def add_FEATURES(FEATURES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, FEATURES)
        return this
    def end():
        return b_.EndObject()

def PricingTierStartFEATURESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PricingTierCreateFEATURESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Storefront Listing - Data marketplace listing
class STF : flatbuffers.handle
    /// Unique identifier for the listing
    def LISTING_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Peer ID of the data provider
    def PROVIDER_PEER_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// IPFS CID of provider's EPM (Entity Profile Message)
    def PROVIDER_EPM_CID() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Title of the data listing
    def TITLE() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Detailed description of the data offering
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// SDS data types offered, e.g., ["OMM", "CDM", "TLE"]
    def DATA_TYPES(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 4)
    def DATA_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Coverage information (spatial and temporal)
    def COVERAGE() -> DataCoverage?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: DataCoverage { buf_, o } else: nil
    /// IPFS CID of sample data
    def SAMPLE_CID() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Type of access offered
    def ACCESS_TYPE() -> accessType:
        return accessType(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Whether encryption is required for data delivery
    def ENCRYPTION_REQUIRED() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 22, 0))
    /// Available pricing tiers
    def PRICING(i:int) -> PricingTier:
        return PricingTier { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 4) }
    def PRICING_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Payment methods accepted
    def ACCEPTED_PAYMENTS(i:int) -> paymentMethod:
        return read_int8_le(buf_, buf_.flatbuffers.field_vector(pos_, 26) + i * 1)
    def ACCEPTED_PAYMENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    /// Unix timestamp when listing was created
    def CREATED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 28, 0)
    /// Unix timestamp when listing was last updated
    def UPDATED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 30, 0)
    /// Whether the listing is currently active
    def ACTIVE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 32, 0))
    /// Ed25519 signature from provider
    def SIGNATURE(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 34) + i * 1)
    def SIGNATURE_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 34)

def GetRootAsSTF(buf:string): return STF { buf, flatbuffers.indirect(buf, 0) }

struct STFBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(16)
        return this
    def add_LISTING_ID(LISTING_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, LISTING_ID)
        return this
    def add_PROVIDER_PEER_ID(PROVIDER_PEER_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PROVIDER_PEER_ID)
        return this
    def add_PROVIDER_EPM_CID(PROVIDER_EPM_CID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PROVIDER_EPM_CID)
        return this
    def add_TITLE(TITLE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, TITLE)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DESCRIPTION)
        return this
    def add_DATA_TYPES(DATA_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, DATA_TYPES)
        return this
    def add_COVERAGE(COVERAGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, COVERAGE)
        return this
    def add_SAMPLE_CID(SAMPLE_CID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, SAMPLE_CID)
        return this
    def add_ACCESS_TYPE(ACCESS_TYPE:accessType):
        b_.PrependInt8Slot(8, ACCESS_TYPE, 0)
        return this
    def add_ENCRYPTION_REQUIRED(ENCRYPTION_REQUIRED:bool):
        b_.PrependBoolSlot(9, ENCRYPTION_REQUIRED, 0)
        return this
    def add_PRICING(PRICING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, PRICING)
        return this
    def add_ACCEPTED_PAYMENTS(ACCEPTED_PAYMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, ACCEPTED_PAYMENTS)
        return this
    def add_CREATED_AT(CREATED_AT:int):
        b_.PrependUint64Slot(12, CREATED_AT, 0)
        return this
    def add_UPDATED_AT(UPDATED_AT:int):
        b_.PrependUint64Slot(13, UPDATED_AT, 0)
        return this
    def add_ACTIVE(ACTIVE:bool):
        b_.PrependBoolSlot(14, ACTIVE, 0)
        return this
    def add_SIGNATURE(SIGNATURE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, SIGNATURE)
        return this
    def end():
        return b_.EndObject()

def STFStartDATA_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def STFCreateDATA_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def STFStartPRICINGVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def STFCreatePRICINGVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def STFStartACCEPTED_PAYMENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def STFCreateACCEPTED_PAYMENTSVector(b_:flatbuffers.builder, v_:[paymentMethod]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependInt8(e_)
    return b_.EndVector(v_.length)

def STFStartSIGNATUREVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def STFCreateSIGNATUREVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

