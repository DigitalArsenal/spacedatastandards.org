// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum IntegratorType:
    IntegratorType_RK4 = 0
    IntegratorType_RK45 = 1
    IntegratorType_RK78 = 2
    IntegratorType_DOPRI5 = 3
    IntegratorType_DOPRI853 = 4
    IntegratorType_ABM = 5
    IntegratorType_BS = 6
    IntegratorType_ANALYTICAL = 255

class PCF

/// Propagator Configuration
class PCF : flatbuffers.handle
    def STEP_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    def TOLERANCE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    def MIN_STEP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    def MAX_STEP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    def MAX_ITERATIONS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 12, 0)
    def GRAVITY_DEGREE() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 14, 0)
    def GRAVITY_ORDER() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 16, 0)
    def INTEGRATOR() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 18, 0)
    def OUTPUT_FRAME() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 20, 0)
    def FORCE_FLAGS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 22, 0)
    def DRAG_COEFFICIENT() -> float:
        return flatbuffers.field_float32(buf_, pos_, 24, 0.0)
    def SRP_COEFFICIENT() -> float:
        return flatbuffers.field_float32(buf_, pos_, 26, 0.0)
    def AREA_MASS_RATIO() -> float:
        return flatbuffers.field_float32(buf_, pos_, 28, 0.0)
    def RESERVED(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 30) + i * 1)
    def RESERVED_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 30)

def GetRootAsPCF(buf:string): return PCF { buf, flatbuffers.indirect(buf, 0) }

struct PCFBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(14)
        return this
    def add_STEP_SIZE(STEP_SIZE:float):
        b_.PrependFloat64Slot(0, STEP_SIZE, 0.0)
        return this
    def add_TOLERANCE(TOLERANCE:float):
        b_.PrependFloat64Slot(1, TOLERANCE, 0.0)
        return this
    def add_MIN_STEP(MIN_STEP:float):
        b_.PrependFloat64Slot(2, MIN_STEP, 0.0)
        return this
    def add_MAX_STEP(MAX_STEP:float):
        b_.PrependFloat64Slot(3, MAX_STEP, 0.0)
        return this
    def add_MAX_ITERATIONS(MAX_ITERATIONS:int):
        b_.PrependUint32Slot(4, MAX_ITERATIONS, 0)
        return this
    def add_GRAVITY_DEGREE(GRAVITY_DEGREE:int):
        b_.PrependUint16Slot(5, GRAVITY_DEGREE, 0)
        return this
    def add_GRAVITY_ORDER(GRAVITY_ORDER:int):
        b_.PrependUint16Slot(6, GRAVITY_ORDER, 0)
        return this
    def add_INTEGRATOR(INTEGRATOR:int):
        b_.PrependUint8Slot(7, INTEGRATOR, 0)
        return this
    def add_OUTPUT_FRAME(OUTPUT_FRAME:int):
        b_.PrependUint8Slot(8, OUTPUT_FRAME, 0)
        return this
    def add_FORCE_FLAGS(FORCE_FLAGS:int):
        b_.PrependUint16Slot(9, FORCE_FLAGS, 0)
        return this
    def add_DRAG_COEFFICIENT(DRAG_COEFFICIENT:float):
        b_.PrependFloat32Slot(10, DRAG_COEFFICIENT, 0.0)
        return this
    def add_SRP_COEFFICIENT(SRP_COEFFICIENT:float):
        b_.PrependFloat32Slot(11, SRP_COEFFICIENT, 0.0)
        return this
    def add_AREA_MASS_RATIO(AREA_MASS_RATIO:float):
        b_.PrependFloat32Slot(12, AREA_MASS_RATIO, 0.0)
        return this
    def add_RESERVED(RESERVED:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, RESERVED)
        return this
    def end():
        return b_.EndObject()

def PCFStartRESERVEDVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PCFCreateRESERVEDVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

