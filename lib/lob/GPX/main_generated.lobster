// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum GPXFixType:
    GPXFixType_NONE = 0
    /// 2D fix
    GPXFixType_FIX_2D = 1
    /// 3D fix
    GPXFixType_FIX_3D = 2
    /// Differential GPS fix
    GPXFixType_DGPS = 3
    /// PPP fix
    GPXFixType_PPS = 4

class GPXLink

class GPXWaypoint

class GPXTrackSegment

class GPXTrack

class GPXRoute

class GPX

/// GPX link to an external resource
class GPXLink : flatbuffers.handle
    /// URL
    def HREF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Link text
    def TEXT() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// MIME type
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsGPXLink(buf:string): return GPXLink { buf, flatbuffers.indirect(buf, 0) }

struct GPXLinkBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_HREF(HREF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, HREF)
        return this
    def add_TEXT(TEXT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, TEXT)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, TYPE)
        return this
    def end():
        return b_.EndObject()

/// A waypoint, point of interest, or named feature
class GPXWaypoint : flatbuffers.handle
    /// Latitude in decimal degrees (WGS84)
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Longitude in decimal degrees (WGS84)
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Elevation in meters above WGS84 ellipsoid
    def ELEVATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// UTC timestamp (ISO 8601)
    def TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Magnetic variation in degrees
    def MAGVAR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Height of geoid above WGS84 ellipsoid in meters
    def GEOID_HEIGHT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Waypoint name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Comment
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Source of data
    def SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Links to additional information
    def LINKS(i:int) -> GPXLink:
        return GPXLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 4) }
    def LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Symbol name
    def SYMBOL() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Type/category
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Type of GPS fix
    def FIX() -> GPXFixType:
        return GPXFixType(flatbuffers.field_int8(buf_, pos_, 30, 0))
    /// Number of satellites used for fix
    def SAT() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 32, 0)
    /// Horizontal dilution of precision
    def HDOP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Vertical dilution of precision
    def VDOP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Position dilution of precision
    def PDOP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Age of DGPS data in seconds
    def AGE_OF_DGPS_DATA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// DGPS station ID
    def DGPS_ID() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 42, 0)
    /// Speed in meters per second
    def SPEED() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Course/heading in degrees true
    def COURSE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)

def GetRootAsGPXWaypoint(buf:string): return GPXWaypoint { buf, flatbuffers.indirect(buf, 0) }

struct GPXWaypointBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(22)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(0, LATITUDE, 0.0)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(1, LONGITUDE, 0.0)
        return this
    def add_ELEVATION(ELEVATION:float):
        b_.PrependFloat64Slot(2, ELEVATION, 0.0)
        return this
    def add_TIME(TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, TIME)
        return this
    def add_MAGVAR(MAGVAR:float):
        b_.PrependFloat64Slot(4, MAGVAR, 0.0)
        return this
    def add_GEOID_HEIGHT(GEOID_HEIGHT:float):
        b_.PrependFloat64Slot(5, GEOID_HEIGHT, 0.0)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, NAME)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, COMMENT)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, DESCRIPTION)
        return this
    def add_SOURCE(SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, SOURCE)
        return this
    def add_LINKS(LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, LINKS)
        return this
    def add_SYMBOL(SYMBOL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, SYMBOL)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, TYPE)
        return this
    def add_FIX(FIX:GPXFixType):
        b_.PrependInt8Slot(13, FIX, 0)
        return this
    def add_SAT(SAT:int):
        b_.PrependUint16Slot(14, SAT, 0)
        return this
    def add_HDOP(HDOP:float):
        b_.PrependFloat64Slot(15, HDOP, 0.0)
        return this
    def add_VDOP(VDOP:float):
        b_.PrependFloat64Slot(16, VDOP, 0.0)
        return this
    def add_PDOP(PDOP:float):
        b_.PrependFloat64Slot(17, PDOP, 0.0)
        return this
    def add_AGE_OF_DGPS_DATA(AGE_OF_DGPS_DATA:float):
        b_.PrependFloat64Slot(18, AGE_OF_DGPS_DATA, 0.0)
        return this
    def add_DGPS_ID(DGPS_ID:int):
        b_.PrependUint16Slot(19, DGPS_ID, 0)
        return this
    def add_SPEED(SPEED:float):
        b_.PrependFloat64Slot(20, SPEED, 0.0)
        return this
    def add_COURSE(COURSE:float):
        b_.PrependFloat64Slot(21, COURSE, 0.0)
        return this
    def end():
        return b_.EndObject()

def GPXWaypointStartLINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXWaypointCreateLINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Track segment (continuous span of track points)
class GPXTrackSegment : flatbuffers.handle
    /// Ordered track points in this segment
    def POINTS(i:int) -> GPXWaypoint:
        return GPXWaypoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def POINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsGPXTrackSegment(buf:string): return GPXTrackSegment { buf, flatbuffers.indirect(buf, 0) }

struct GPXTrackSegmentBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_POINTS(POINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, POINTS)
        return this
    def end():
        return b_.EndObject()

def GPXTrackSegmentStartPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXTrackSegmentCreatePOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Track (ordered list of track segments)
class GPXTrack : flatbuffers.handle
    /// Track name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Comment
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Source of data
    def SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Links to additional information
    def LINKS(i:int) -> GPXLink:
        return GPXLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Track number
    def NUMBER() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    /// Type/category
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Track segments
    def SEGMENTS(i:int) -> GPXTrackSegment:
        return GPXTrackSegment { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def SEGMENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)

def GetRootAsGPXTrack(buf:string): return GPXTrack { buf, flatbuffers.indirect(buf, 0) }

struct GPXTrackBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COMMENT)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, DESCRIPTION)
        return this
    def add_SOURCE(SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, SOURCE)
        return this
    def add_LINKS(LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, LINKS)
        return this
    def add_NUMBER(NUMBER:int):
        b_.PrependUint32Slot(5, NUMBER, 0)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, TYPE)
        return this
    def add_SEGMENTS(SEGMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, SEGMENTS)
        return this
    def end():
        return b_.EndObject()

def GPXTrackStartLINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXTrackCreateLINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GPXTrackStartSEGMENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXTrackCreateSEGMENTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Route (ordered list of waypoints for navigation)
class GPXRoute : flatbuffers.handle
    /// Route name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Comment
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Source of data
    def SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Links to additional information
    def LINKS(i:int) -> GPXLink:
        return GPXLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Route number
    def NUMBER() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    /// Type/category
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Route points (ordered waypoints)
    def POINTS(i:int) -> GPXWaypoint:
        return GPXWaypoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def POINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)

def GetRootAsGPXRoute(buf:string): return GPXRoute { buf, flatbuffers.indirect(buf, 0) }

struct GPXRouteBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COMMENT)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, DESCRIPTION)
        return this
    def add_SOURCE(SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, SOURCE)
        return this
    def add_LINKS(LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, LINKS)
        return this
    def add_NUMBER(NUMBER:int):
        b_.PrependUint32Slot(5, NUMBER, 0)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, TYPE)
        return this
    def add_POINTS(POINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, POINTS)
        return this
    def end():
        return b_.EndObject()

def GPXRouteStartLINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXRouteCreateLINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GPXRouteStartPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXRouteCreatePOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// GPX Document
class GPX : flatbuffers.handle
    /// GPX schema version
    def VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Creator software/organization
    def CREATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// File name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// File description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Person or organization who created the file
    def AUTHOR_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Author email
    def AUTHOR_EMAIL() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Author link
    def AUTHOR_LINK() -> GPXLink?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: GPXLink { buf_, o } else: nil
    /// Copyright holder
    def COPYRIGHT_AUTHOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Copyright year
    def COPYRIGHT_YEAR() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Copyright license URL
    def COPYRIGHT_LICENSE() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Links to additional information
    def LINKS(i:int) -> GPXLink:
        return GPXLink { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 4) }
    def LINKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Creation timestamp (ISO 8601)
    def TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Keywords
    def KEYWORDS() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Minimum latitude of bounding box
    def BOUNDS_MIN_LAT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Minimum longitude of bounding box
    def BOUNDS_MIN_LON() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Maximum latitude of bounding box
    def BOUNDS_MAX_LAT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Maximum longitude of bounding box
    def BOUNDS_MAX_LON() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Waypoints
    def WAYPOINTS(i:int) -> GPXWaypoint:
        return GPXWaypoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 38) + i * 4) }
    def WAYPOINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 38)
    /// Routes
    def ROUTES(i:int) -> GPXRoute:
        return GPXRoute { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 40) + i * 4) }
    def ROUTES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 40)
    /// Tracks
    def TRACKS(i:int) -> GPXTrack:
        return GPXTrack { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 42) + i * 4) }
    def TRACKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 42)

def GetRootAsGPX(buf:string): return GPX { buf, flatbuffers.indirect(buf, 0) }

struct GPXBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(20)
        return this
    def add_VERSION(VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, VERSION)
        return this
    def add_CREATOR(CREATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CREATOR)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DESCRIPTION)
        return this
    def add_AUTHOR_NAME(AUTHOR_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, AUTHOR_NAME)
        return this
    def add_AUTHOR_EMAIL(AUTHOR_EMAIL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, AUTHOR_EMAIL)
        return this
    def add_AUTHOR_LINK(AUTHOR_LINK:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, AUTHOR_LINK)
        return this
    def add_COPYRIGHT_AUTHOR(COPYRIGHT_AUTHOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, COPYRIGHT_AUTHOR)
        return this
    def add_COPYRIGHT_YEAR(COPYRIGHT_YEAR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, COPYRIGHT_YEAR)
        return this
    def add_COPYRIGHT_LICENSE(COPYRIGHT_LICENSE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, COPYRIGHT_LICENSE)
        return this
    def add_LINKS(LINKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, LINKS)
        return this
    def add_TIME(TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, TIME)
        return this
    def add_KEYWORDS(KEYWORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, KEYWORDS)
        return this
    def add_BOUNDS_MIN_LAT(BOUNDS_MIN_LAT:float):
        b_.PrependFloat64Slot(13, BOUNDS_MIN_LAT, 0.0)
        return this
    def add_BOUNDS_MIN_LON(BOUNDS_MIN_LON:float):
        b_.PrependFloat64Slot(14, BOUNDS_MIN_LON, 0.0)
        return this
    def add_BOUNDS_MAX_LAT(BOUNDS_MAX_LAT:float):
        b_.PrependFloat64Slot(15, BOUNDS_MAX_LAT, 0.0)
        return this
    def add_BOUNDS_MAX_LON(BOUNDS_MAX_LON:float):
        b_.PrependFloat64Slot(16, BOUNDS_MAX_LON, 0.0)
        return this
    def add_WAYPOINTS(WAYPOINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, WAYPOINTS)
        return this
    def add_ROUTES(ROUTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, ROUTES)
        return this
    def add_TRACKS(TRACKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, TRACKS)
        return this
    def end():
        return b_.EndObject()

def GPXStartLINKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXCreateLINKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GPXStartWAYPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXCreateWAYPOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GPXStartROUTESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXCreateROUTESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def GPXStartTRACKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def GPXCreateTRACKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

