// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum reentryDisposition:
    reentryDisposition_CONTROLLED = 0
    reentryDisposition_UNCONTROLLED = 1
    reentryDisposition_SEMI_CONTROLLED = 2

enum reentryReason:
    reentryReason_NATURAL_DECAY = 0
    reentryReason_COMMANDED_DEORBIT = 1
    reentryReason_PROPULSION_FAILURE = 2
    reentryReason_COLLISION = 3
    reentryReason_FRAGMENTATION = 4
    reentryReason_UNKNOWN = 5

class reentryStateVector

class reentryImpact

class survivingDebris

class RDM

/// Reentry State Vector
class reentryStateVector : flatbuffers.handle
    /// Epoch (ISO 8601)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Reference frame
    def REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Position X in km
    def X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Position Y in km
    def Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Position Z in km
    def Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Velocity X in km/s
    def X_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Velocity Y in km/s
    def Y_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Velocity Z in km/s
    def Z_DOT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)

def GetRootAsreentryStateVector(buf:string): return reentryStateVector { buf, flatbuffers.indirect(buf, 0) }

struct reentryStateVectorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, EPOCH)
        return this
    def add_REF_FRAME(REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, REF_FRAME)
        return this
    def add_X(X:float):
        b_.PrependFloat64Slot(2, X, 0.0)
        return this
    def add_Y(Y:float):
        b_.PrependFloat64Slot(3, Y, 0.0)
        return this
    def add_Z(Z:float):
        b_.PrependFloat64Slot(4, Z, 0.0)
        return this
    def add_X_DOT(X_DOT:float):
        b_.PrependFloat64Slot(5, X_DOT, 0.0)
        return this
    def add_Y_DOT(Y_DOT:float):
        b_.PrependFloat64Slot(6, Y_DOT, 0.0)
        return this
    def add_Z_DOT(Z_DOT:float):
        b_.PrependFloat64Slot(7, Z_DOT, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Reentry Ground Impact Prediction
class reentryImpact : flatbuffers.handle
    /// Predicted impact epoch (ISO 8601)
    def IMPACT_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Epoch uncertainty window in seconds
    def EPOCH_UNCERTAINTY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Impact latitude in degrees
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Impact longitude in degrees
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Along-track uncertainty in km
    def ALONG_TRACK_UNC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Cross-track uncertainty in km
    def CROSS_TRACK_UNC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Impact probability (0.0-1.0)
    def IMPACT_PROBABILITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)

def GetRootAsreentryImpact(buf:string): return reentryImpact { buf, flatbuffers.indirect(buf, 0) }

struct reentryImpactBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_IMPACT_EPOCH(IMPACT_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, IMPACT_EPOCH)
        return this
    def add_EPOCH_UNCERTAINTY(EPOCH_UNCERTAINTY:float):
        b_.PrependFloat64Slot(1, EPOCH_UNCERTAINTY, 0.0)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(2, LATITUDE, 0.0)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(3, LONGITUDE, 0.0)
        return this
    def add_ALONG_TRACK_UNC(ALONG_TRACK_UNC:float):
        b_.PrependFloat64Slot(4, ALONG_TRACK_UNC, 0.0)
        return this
    def add_CROSS_TRACK_UNC(CROSS_TRACK_UNC:float):
        b_.PrependFloat64Slot(5, CROSS_TRACK_UNC, 0.0)
        return this
    def add_IMPACT_PROBABILITY(IMPACT_PROBABILITY:float):
        b_.PrependFloat64Slot(6, IMPACT_PROBABILITY, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Surviving Debris Prediction
class survivingDebris : flatbuffers.handle
    /// Fragment identifier
    def FRAGMENT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Material type
    def MATERIAL() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Fragment mass in kg
    def MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Casualty area in m^2
    def CASUALTY_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Survival probability (0.0-1.0)
    def SURVIVAL_PROBABILITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)

def GetRootAssurvivingDebris(buf:string): return survivingDebris { buf, flatbuffers.indirect(buf, 0) }

struct survivingDebrisBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_FRAGMENT_ID(FRAGMENT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, FRAGMENT_ID)
        return this
    def add_MATERIAL(MATERIAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, MATERIAL)
        return this
    def add_MASS(MASS:float):
        b_.PrependFloat64Slot(2, MASS, 0.0)
        return this
    def add_CASUALTY_AREA(CASUALTY_AREA:float):
        b_.PrependFloat64Slot(3, CASUALTY_AREA, 0.0)
        return this
    def add_SURVIVAL_PROBABILITY(SURVIVAL_PROBABILITY:float):
        b_.PrependFloat64Slot(4, SURVIVAL_PROBABILITY, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Reentry Data Message
class RDM : flatbuffers.handle
    /// CCSDS RDM version
    def CCSDS_RDM_VERS() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Message creation date (ISO 8601)
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Creating organization
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Object name
    def OBJECT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// International designator
    def OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// NORAD catalog number
    def NORAD_CAT_ID() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 0)
    /// Object type (PAYLOAD, ROCKET_BODY, DEBRIS, UNKNOWN)
    def OBJECT_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Reentry disposition
    def DISPOSITION() -> reentryDisposition:
        return reentryDisposition(flatbuffers.field_int8(buf_, pos_, 18, 0))
    /// Reentry reason
    def REASON() -> reentryReason:
        return reentryReason(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Predicted reentry epoch (ISO 8601)
    def REENTRY_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Reentry epoch uncertainty window in hours
    def REENTRY_EPOCH_UNC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Reentry latitude in degrees
    def REENTRY_LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Reentry longitude in degrees
    def REENTRY_LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Reentry altitude in km
    def REENTRY_ALTITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Time system
    def TIME_SYSTEM() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// Previous predicted reentry epoch for comparison (ISO 8601)
    def PREV_PREDICTION_EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// Ballistic coefficient in kg/m^2
    def BALLISTIC_COEFF() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Object mass in kg
    def MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Solar radiation pressure area in m^2
    def SOLAR_RAD_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Drag area in m^2
    def DRAG_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Initial state vector
    def INITIAL_STATE() -> reentryStateVector?:
        let o = flatbuffers.field_table(buf_, pos_, 44)
        return if o: reentryStateVector { buf_, o } else: nil
    /// Ground impact predictions
    def IMPACT_PREDICTIONS(i:int) -> reentryImpact:
        return reentryImpact { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 46) + i * 4) }
    def IMPACT_PREDICTIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 46)
    /// Predicted surviving debris
    def SURVIVING_DEBRIS(i:int) -> survivingDebris:
        return survivingDebris { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 48) + i * 4) }
    def SURVIVING_DEBRIS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 48)
    /// Casualty expectation
    def CASUALTY_EXPECTATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 50, 0.0)
    /// Number of breakup fragments predicted
    def NUM_FRAGMENTS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 52, 0)
    /// Total surviving mass in kg
    def SURVIVING_MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    /// Additional comments
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 56)

def GetRootAsRDM(buf:string): return RDM { buf, flatbuffers.indirect(buf, 0) }

struct RDMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(27)
        return this
    def add_CCSDS_RDM_VERS(CCSDS_RDM_VERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CCSDS_RDM_VERS)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ORIGINATOR)
        return this
    def add_OBJECT_NAME(OBJECT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OBJECT_NAME)
        return this
    def add_OBJECT_ID(OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, OBJECT_ID)
        return this
    def add_NORAD_CAT_ID(NORAD_CAT_ID:int):
        b_.PrependUint32Slot(5, NORAD_CAT_ID, 0)
        return this
    def add_OBJECT_TYPE(OBJECT_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, OBJECT_TYPE)
        return this
    def add_DISPOSITION(DISPOSITION:reentryDisposition):
        b_.PrependInt8Slot(7, DISPOSITION, 0)
        return this
    def add_REASON(REASON:reentryReason):
        b_.PrependInt8Slot(8, REASON, 0)
        return this
    def add_REENTRY_EPOCH(REENTRY_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, REENTRY_EPOCH)
        return this
    def add_REENTRY_EPOCH_UNC(REENTRY_EPOCH_UNC:float):
        b_.PrependFloat64Slot(10, REENTRY_EPOCH_UNC, 0.0)
        return this
    def add_REENTRY_LATITUDE(REENTRY_LATITUDE:float):
        b_.PrependFloat64Slot(11, REENTRY_LATITUDE, 0.0)
        return this
    def add_REENTRY_LONGITUDE(REENTRY_LONGITUDE:float):
        b_.PrependFloat64Slot(12, REENTRY_LONGITUDE, 0.0)
        return this
    def add_REENTRY_ALTITUDE(REENTRY_ALTITUDE:float):
        b_.PrependFloat64Slot(13, REENTRY_ALTITUDE, 0.0)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, TIME_SYSTEM)
        return this
    def add_PREV_PREDICTION_EPOCH(PREV_PREDICTION_EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, PREV_PREDICTION_EPOCH)
        return this
    def add_BALLISTIC_COEFF(BALLISTIC_COEFF:float):
        b_.PrependFloat64Slot(16, BALLISTIC_COEFF, 0.0)
        return this
    def add_MASS(MASS:float):
        b_.PrependFloat64Slot(17, MASS, 0.0)
        return this
    def add_SOLAR_RAD_AREA(SOLAR_RAD_AREA:float):
        b_.PrependFloat64Slot(18, SOLAR_RAD_AREA, 0.0)
        return this
    def add_DRAG_AREA(DRAG_AREA:float):
        b_.PrependFloat64Slot(19, DRAG_AREA, 0.0)
        return this
    def add_INITIAL_STATE(INITIAL_STATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, INITIAL_STATE)
        return this
    def add_IMPACT_PREDICTIONS(IMPACT_PREDICTIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, IMPACT_PREDICTIONS)
        return this
    def add_SURVIVING_DEBRIS(SURVIVING_DEBRIS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, SURVIVING_DEBRIS)
        return this
    def add_CASUALTY_EXPECTATION(CASUALTY_EXPECTATION:float):
        b_.PrependFloat64Slot(23, CASUALTY_EXPECTATION, 0.0)
        return this
    def add_NUM_FRAGMENTS(NUM_FRAGMENTS:int):
        b_.PrependUint32Slot(24, NUM_FRAGMENTS, 0)
        return this
    def add_SURVIVING_MASS(SURVIVING_MASS:float):
        b_.PrependFloat64Slot(25, SURVIVING_MASS, 0.0)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(26, COMMENT)
        return this
    def end():
        return b_.EndObject()

def RDMStartIMPACT_PREDICTIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def RDMCreateIMPACT_PREDICTIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def RDMStartSURVIVING_DEBRISVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def RDMCreateSURVIVING_DEBRISVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

