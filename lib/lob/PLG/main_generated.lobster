// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// Plugin type category
enum pluginType:
    /// Sensor simulation and analysis
    pluginType_Sensor = 0
    /// Orbital propagation algorithms
    pluginType_Propagator = 1
    /// Custom rendering/visualization
    pluginType_Renderer = 2
    /// Data analysis and processing
    pluginType_Analysis = 3
    /// External data source integration
    pluginType_DataSource = 4
    /// Electronic warfare simulation
    pluginType_EW = 5
    /// Communications modeling
    pluginType_Comms = 6
    /// Physics simulation
    pluginType_Physics = 7

class PluginCapability

class PluginDependency

class EntryFunction

class PLG

/// Plugin capability declaration
class PluginCapability : flatbuffers.handle
    /// Capability name, e.g., "gpu_compute", "wasm_simd"
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Capability version
    def VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Whether this capability is required
    def REQUIRED() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))

def GetRootAsPluginCapability(buf:string): return PluginCapability { buf, flatbuffers.indirect(buf, 0) }

struct PluginCapabilityBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_VERSION(VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VERSION)
        return this
    def add_REQUIRED(REQUIRED:bool):
        b_.PrependBoolSlot(2, REQUIRED, 0)
        return this
    def end():
        return b_.EndObject()

/// Plugin dependency on another plugin
class PluginDependency : flatbuffers.handle
    /// Plugin ID of the dependency
    def PLUGIN_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Minimum version required (semver)
    def MIN_VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Maximum version allowed (optional)
    def MAX_VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsPluginDependency(buf:string): return PluginDependency { buf, flatbuffers.indirect(buf, 0) }

struct PluginDependencyBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_PLUGIN_ID(PLUGIN_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PLUGIN_ID)
        return this
    def add_MIN_VERSION(MIN_VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, MIN_VERSION)
        return this
    def add_MAX_VERSION(MAX_VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, MAX_VERSION)
        return this
    def end():
        return b_.EndObject()

/// Plugin entry point function definition
class EntryFunction : flatbuffers.handle
    /// Function name as exported from WASM
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Human-readable description
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Input parameter types (FlatBuffer schema names)
    def INPUT_SCHEMAS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 4)
    def INPUT_SCHEMAS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Output type (FlatBuffer schema name)
    def OUTPUT_SCHEMA() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)

def GetRootAsEntryFunction(buf:string): return EntryFunction { buf, flatbuffers.indirect(buf, 0) }

struct EntryFunctionBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DESCRIPTION)
        return this
    def add_INPUT_SCHEMAS(INPUT_SCHEMAS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, INPUT_SCHEMAS)
        return this
    def add_OUTPUT_SCHEMA(OUTPUT_SCHEMA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OUTPUT_SCHEMA)
        return this
    def end():
        return b_.EndObject()

def EntryFunctionStartINPUT_SCHEMASVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def EntryFunctionCreateINPUT_SCHEMASVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Plugin Manifest - WASM plugin distribution
class PLG : flatbuffers.handle
    /// Unique identifier for the plugin
    def PLUGIN_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Human-readable plugin name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Plugin version (semver format)
    def VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Detailed description of plugin functionality
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Type/category of the plugin
    def PLUGIN_TYPE() -> pluginType:
        return pluginType(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// ABI version for compatibility checking
    def ABI_VERSION() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 14, 1)
    /// SHA256 hash of the decrypted WASM binary
    def WASM_HASH(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 16) + i * 1)
    def WASM_HASH_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Size of WASM binary in bytes
    def WASM_SIZE() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 18, 0)
    /// IPFS CID of the encrypted WASM binary
    def WASM_CID() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Entry point functions exported by the plugin
    def ENTRY_FUNCTIONS(i:int) -> EntryFunction:
        return EntryFunction { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def ENTRY_FUNCTIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    /// FlatBuffer schemas required by this plugin
    def REQUIRED_SCHEMAS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 24) + i * 4)
    def REQUIRED_SCHEMAS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Other plugins this depends on
    def DEPENDENCIES(i:int) -> PluginDependency:
        return PluginDependency { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 26) + i * 4) }
    def DEPENDENCIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    /// Capabilities provided by this plugin
    def CAPABILITIES(i:int) -> PluginCapability:
        return PluginCapability { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 28) + i * 4) }
    def CAPABILITIES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 28)
    /// Peer ID of the plugin provider
    def PROVIDER_PEER_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// IPFS CID of provider's EPM (Entity Profile Message)
    def PROVIDER_EPM_CID() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// Whether the WASM binary is encrypted
    def ENCRYPTED() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 34, 1))
    /// Minimum permissions required to run
    def MIN_PERMISSIONS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 36) + i * 4)
    def MIN_PERMISSIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 36)
    /// Unix timestamp when plugin was created
    def CREATED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 38, 0)
    /// Unix timestamp when plugin was last updated
    def UPDATED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 40, 0)
    /// URL to plugin documentation
    def DOCUMENTATION_URL() -> string:
        return flatbuffers.field_string(buf_, pos_, 42)
    /// URL to plugin icon/logo
    def ICON_URL() -> string:
        return flatbuffers.field_string(buf_, pos_, 44)
    /// License identifier (SPDX format)
    def LICENSE() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    /// Ed25519 signature from provider over manifest
    def SIGNATURE(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 48) + i * 1)
    def SIGNATURE_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 48)

def GetRootAsPLG(buf:string): return PLG { buf, flatbuffers.indirect(buf, 0) }

struct PLGBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(23)
        return this
    def add_PLUGIN_ID(PLUGIN_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PLUGIN_ID)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, NAME)
        return this
    def add_VERSION(VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, VERSION)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DESCRIPTION)
        return this
    def add_PLUGIN_TYPE(PLUGIN_TYPE:pluginType):
        b_.PrependInt8Slot(4, PLUGIN_TYPE, 0)
        return this
    def add_ABI_VERSION(ABI_VERSION:int):
        b_.PrependUint32Slot(5, ABI_VERSION, 1)
        return this
    def add_WASM_HASH(WASM_HASH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, WASM_HASH)
        return this
    def add_WASM_SIZE(WASM_SIZE:int):
        b_.PrependUint64Slot(7, WASM_SIZE, 0)
        return this
    def add_WASM_CID(WASM_CID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, WASM_CID)
        return this
    def add_ENTRY_FUNCTIONS(ENTRY_FUNCTIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, ENTRY_FUNCTIONS)
        return this
    def add_REQUIRED_SCHEMAS(REQUIRED_SCHEMAS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, REQUIRED_SCHEMAS)
        return this
    def add_DEPENDENCIES(DEPENDENCIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, DEPENDENCIES)
        return this
    def add_CAPABILITIES(CAPABILITIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, CAPABILITIES)
        return this
    def add_PROVIDER_PEER_ID(PROVIDER_PEER_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, PROVIDER_PEER_ID)
        return this
    def add_PROVIDER_EPM_CID(PROVIDER_EPM_CID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, PROVIDER_EPM_CID)
        return this
    def add_ENCRYPTED(ENCRYPTED:bool):
        b_.PrependBoolSlot(15, ENCRYPTED, 1)
        return this
    def add_MIN_PERMISSIONS(MIN_PERMISSIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, MIN_PERMISSIONS)
        return this
    def add_CREATED_AT(CREATED_AT:int):
        b_.PrependUint64Slot(17, CREATED_AT, 0)
        return this
    def add_UPDATED_AT(UPDATED_AT:int):
        b_.PrependUint64Slot(18, UPDATED_AT, 0)
        return this
    def add_DOCUMENTATION_URL(DOCUMENTATION_URL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, DOCUMENTATION_URL)
        return this
    def add_ICON_URL(ICON_URL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, ICON_URL)
        return this
    def add_LICENSE(LICENSE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, LICENSE)
        return this
    def add_SIGNATURE(SIGNATURE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, SIGNATURE)
        return this
    def end():
        return b_.EndObject()

def PLGStartWASM_HASHVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PLGCreateWASM_HASHVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def PLGStartENTRY_FUNCTIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLGCreateENTRY_FUNCTIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLGStartREQUIRED_SCHEMASVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLGCreateREQUIRED_SCHEMASVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLGStartDEPENDENCIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLGCreateDEPENDENCIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLGStartCAPABILITIESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLGCreateCAPABILITIESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLGStartMIN_PERMISSIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLGCreateMIN_PERMISSIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLGStartSIGNATUREVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PLGCreateSIGNATUREVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

