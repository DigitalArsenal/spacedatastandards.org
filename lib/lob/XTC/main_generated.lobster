// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// Comparison operators for match criteria and conditions
enum ComparisonOperator:
    /// Equal to
    ComparisonOperator_EQ = 0
    /// Not equal to
    ComparisonOperator_NE = 1
    /// Greater than
    ComparisonOperator_GT = 2
    /// Less than
    ComparisonOperator_LT = 3
    /// Greater than or equal to
    ComparisonOperator_GE = 4
    /// Less than or equal to
    ComparisonOperator_LE = 5
    /// String starts with
    ComparisonOperator_STARTS_WITH = 6
    /// String ends with
    ComparisonOperator_ENDS_WITH = 7
    /// String contains
    ComparisonOperator_CONTAINS = 8
    /// String does not start with
    ComparisonOperator_NOT_STARTS_WITH = 9
    /// String does not end with
    ComparisonOperator_NOT_ENDS_WITH = 10
    /// String does not contain
    ComparisonOperator_NOT_CONTAINS = 11

/// Data source types for telemetry parameters
enum DataSourceType:
    /// Data received from spacecraft telemetry
    DataSourceType_TELEMETERED = 0
    /// Computed from other parameters
    DataSourceType_DERIVED = 1
    /// Fixed constant value
    DataSourceType_CONSTANT = 2
    /// Local ground system value
    DataSourceType_LOCAL = 3
    /// Ground-generated data
    DataSourceType_GROUND = 4

/// Boolean operators for combining conditions
enum BooleanOperatorType:
    /// Logical AND
    BooleanOperatorType_AND = 0
    /// Logical OR
    BooleanOperatorType_OR = 1
    /// Logical XOR
    BooleanOperatorType_XOR = 2

/// Reference location for positioning within containers
enum ReferenceLocationType:
    /// Start of the container
    ReferenceLocationType_CONTAINER_START = 0
    /// End of the container
    ReferenceLocationType_CONTAINER_END = 1
    /// End of previous entry
    ReferenceLocationType_PREVIOUS_ENTRY = 2
    /// Start of next entry
    ReferenceLocationType_NEXT_ENTRY = 3

/// Rate basis for stream rate specifications
enum RateBasisType:
    /// Rate per second
    RateBasisType_PER_SECOND = 0
    /// Rate per container occurrence
    RateBasisType_PER_CONTAINER = 1

/// Byte ordering for data encoding
enum ByteOrderType:
    /// Most significant byte first
    ByteOrderType_BIG_ENDIAN = 0
    /// Least significant byte first
    ByteOrderType_LITTLE_ENDIAN = 1

/// Integer encoding types
enum IntegerEncodingType:
    /// Unsigned binary
    IntegerEncodingType_UNSIGNED = 0
    /// Two's complement signed
    IntegerEncodingType_TWOS_COMPLEMENT = 1
    /// Sign-magnitude representation
    IntegerEncodingType_SIGN_MAGNITUDE = 2
    /// Ones' complement signed
    IntegerEncodingType_ONES_COMPLEMENT = 3
    /// Binary Coded Decimal
    IntegerEncodingType_BCD = 4
    /// Packed BCD
    IntegerEncodingType_PACKED_BCD = 5

/// Float encoding formats
enum FloatEncodingType:
    /// IEEE 754-1985 single precision (32-bit)
    FloatEncodingType_IEEE754_1985 = 0
    /// MIL-STD-1750A format
    FloatEncodingType_MILSTD_1750A = 1
    /// DEC PDP format
    FloatEncodingType_DEC = 2
    /// IBM System/360 format
    FloatEncodingType_IBM = 3
    /// Texas Instruments TI format
    FloatEncodingType_TI = 4

/// String encoding character sets
enum StringEncodingType:
    /// US-ASCII (7-bit)
    StringEncodingType_US_ASCII = 0
    /// ISO 8859-1 Latin-1
    StringEncodingType_ISO_8859_1 = 1
    /// Windows-1252
    StringEncodingType_WINDOWS_1252 = 2
    /// UTF-8
    StringEncodingType_UTF_8 = 3
    /// UTF-16
    StringEncodingType_UTF_16 = 4
    /// UTF-16 Big Endian
    StringEncodingType_UTF_16BE = 5
    /// UTF-16 Little Endian
    StringEncodingType_UTF_16LE = 6

/// String size specification type
enum StringSizeType:
    /// Fixed length string
    StringSizeType_FIXED = 0
    /// Variable with leading count
    StringSizeType_LEADING_SIZE = 1
    /// Variable with termination character
    StringSizeType_TERMINATION_CHAR = 2

/// Alarm severity levels
enum AlarmSeverityType:
    /// Normal operation
    AlarmSeverityType_NORMAL = 0
    /// Watch level - early warning
    AlarmSeverityType_WATCH = 1
    /// Warning level
    AlarmSeverityType_WARNING = 2
    /// Distress level - significant issue
    AlarmSeverityType_DISTRESS = 3
    /// Critical level - immediate action required
    AlarmSeverityType_CRITICAL = 4
    /// Severe level - system failure
    AlarmSeverityType_SEVERE = 5

/// Verifier type for command verification
enum VerifierType:
    /// Execution started
    VerifierType_START = 0
    /// Progress update
    VerifierType_PROGRESS = 1
    /// Execution complete
    VerifierType_COMPLETE = 2
    /// Command failed
    VerifierType_FAILED = 3

/// Time window reference for command verification
enum TimeWindowRefType:
    /// Relative to command release time
    TimeWindowRefType_COMMAND_RELEASE = 0
    /// Relative to last verifier passed
    TimeWindowRefType_TIME_LAST_VERIFIER_PASSED = 1

/// Epoch reference for absolute time
enum EpochType:
    /// TAI epoch (1958-01-01)
    EpochType_TAI = 0
    /// J2000 epoch (2000-01-01 12:00:00 TT)
    EpochType_J2000 = 1
    /// Unix epoch (1970-01-01)
    EpochType_UNIX = 2
    /// GPS epoch (1980-01-06)
    EpochType_GPS = 3
    /// Custom epoch specified in offset
    EpochType_CUSTOM = 4

/// Error detection/correction algorithms
enum ErrorDetectionType:
    /// No error detection
    ErrorDetectionType_NONE = 0
    /// Cyclic redundancy check
    ErrorDetectionType_CRC = 1
    /// Checksum
    ErrorDetectionType_CHECKSUM = 2
    /// Parity
    ErrorDetectionType_PARITY = 3

class IntegerDataEncoding

class FloatDataEncoding

class StringDataEncoding

class BinaryDataEncoding

class PolynomialCalibrator

class SplinePoint

class SplineCalibrator

class MathOperation

class ContextCalibrator

class AlarmRange

class StaticAlarmRanges

class EnumerationAlarm

class DefaultAlarm

class ContextAlarm

class ParameterComparison

class BooleanExpression

class MatchCriteria

class Unit

class EnumerationValue

class IntegerParameterType

class FloatParameterType

class StringParameterType

class BooleanParameterType

class EnumeratedParameterType

class BinaryParameterType

class AbsoluteTimeParameterType

class RelativeTimeParameterType

class ArrayDimension

class ArrayParameterType

class AggregateMember

class AggregateParameterType

class ParameterTypeSet

class ParameterProperties

class Parameter

class ParameterSet

class LocationInContainer

class RepeatEntry

class ParameterRefEntry

class ContainerRefEntry

class FixedValueEntry

class ArrayParameterRefEntry

class ContainerEntry

class BaseContainer

class RateInStream

class ContainerBinaryEncoding

class SequenceContainer

class ContainerSet

class AlgorithmInput

class AlgorithmOutput

class AlgorithmTrigger

class CustomAlgorithm

class MathAlgorithm

class AlgorithmSet

class IntegerArgumentType

class FloatArgumentType

class StringArgumentType

class BooleanArgumentType

class EnumeratedArgumentType

class BinaryArgumentType

class AggregateArgumentType

class ArgumentTypeSet

class Argument

class ArgumentRefEntry

class CommandContainerEntry

class CommandContainer

class CommandVerifier

class CommandSignificance

class BaseMetaCommand

class ArgumentAssignment

class Interlock

class MetaCommand

class MetaCommandSet

class FixedFrameStream

class VariableFrameStream

class CustomStream

class StreamSet

class Service

class ServiceSet

class XTCHeader

class TelemetryMetaData

class CommandMetaData

class XTC

/// Integer data encoding specification
class IntegerDataEncoding : flatbuffers.handle
    /// Number of bits for this integer
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 4, 0)
    /// Byte ordering
    def BYTE_ORDER() -> ByteOrderType:
        return ByteOrderType(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Integer encoding type
    def ENCODING() -> IntegerEncodingType:
        return IntegerEncodingType(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Default calibrator reference
    def DEFAULT_CALIBRATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Context-dependent calibrators
    def CONTEXT_CALIBRATOR_LIST(i:int) -> ContextCalibrator:
        return ContextCalibrator { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def CONTEXT_CALIBRATOR_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsIntegerDataEncoding(buf:string): return IntegerDataEncoding { buf, flatbuffers.indirect(buf, 0) }

struct IntegerDataEncodingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(0, SIZE_IN_BITS, 0)
        return this
    def add_BYTE_ORDER(BYTE_ORDER:ByteOrderType):
        b_.PrependInt8Slot(1, BYTE_ORDER, 0)
        return this
    def add_ENCODING(ENCODING:IntegerEncodingType):
        b_.PrependInt8Slot(2, ENCODING, 0)
        return this
    def add_DEFAULT_CALIBRATOR(DEFAULT_CALIBRATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DEFAULT_CALIBRATOR)
        return this
    def add_CONTEXT_CALIBRATOR_LIST(CONTEXT_CALIBRATOR_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, CONTEXT_CALIBRATOR_LIST)
        return this
    def end():
        return b_.EndObject()

def IntegerDataEncodingStartCONTEXT_CALIBRATOR_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IntegerDataEncodingCreateCONTEXT_CALIBRATOR_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Float data encoding specification
class FloatDataEncoding : flatbuffers.handle
    /// Number of bits (typically 32 or 64)
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 4, 0)
    /// Byte ordering
    def BYTE_ORDER() -> ByteOrderType:
        return ByteOrderType(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Float encoding format
    def ENCODING() -> FloatEncodingType:
        return FloatEncodingType(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Default calibrator reference
    def DEFAULT_CALIBRATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Context-dependent calibrators
    def CONTEXT_CALIBRATOR_LIST(i:int) -> ContextCalibrator:
        return ContextCalibrator { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def CONTEXT_CALIBRATOR_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsFloatDataEncoding(buf:string): return FloatDataEncoding { buf, flatbuffers.indirect(buf, 0) }

struct FloatDataEncodingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(0, SIZE_IN_BITS, 0)
        return this
    def add_BYTE_ORDER(BYTE_ORDER:ByteOrderType):
        b_.PrependInt8Slot(1, BYTE_ORDER, 0)
        return this
    def add_ENCODING(ENCODING:FloatEncodingType):
        b_.PrependInt8Slot(2, ENCODING, 0)
        return this
    def add_DEFAULT_CALIBRATOR(DEFAULT_CALIBRATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DEFAULT_CALIBRATOR)
        return this
    def add_CONTEXT_CALIBRATOR_LIST(CONTEXT_CALIBRATOR_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, CONTEXT_CALIBRATOR_LIST)
        return this
    def end():
        return b_.EndObject()

def FloatDataEncodingStartCONTEXT_CALIBRATOR_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def FloatDataEncodingCreateCONTEXT_CALIBRATOR_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// String data encoding specification
class StringDataEncoding : flatbuffers.handle
    /// Character encoding
    def ENCODING() -> StringEncodingType:
        return StringEncodingType(flatbuffers.field_int8(buf_, pos_, 4, 3))
    /// Size type specification
    def SIZE_TYPE() -> StringSizeType:
        return StringSizeType(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Fixed size in bits (when SIZE_TYPE=FIXED)
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 8, 0)
    /// Termination character (when SIZE_TYPE=TERMINATION_CHAR)
    def TERMINATION_CHAR() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 10, 0)
    /// Maximum size in bits (for variable length)
    def MAX_SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 12, 0)
    /// Leading size field bits (when SIZE_TYPE=LEADING_SIZE)
    def LEADING_SIZE_BITS() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 14, 0)

def GetRootAsStringDataEncoding(buf:string): return StringDataEncoding { buf, flatbuffers.indirect(buf, 0) }

struct StringDataEncodingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_ENCODING(ENCODING:StringEncodingType):
        b_.PrependInt8Slot(0, ENCODING, 3)
        return this
    def add_SIZE_TYPE(SIZE_TYPE:StringSizeType):
        b_.PrependInt8Slot(1, SIZE_TYPE, 0)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(2, SIZE_IN_BITS, 0)
        return this
    def add_TERMINATION_CHAR(TERMINATION_CHAR:int):
        b_.PrependUint8Slot(3, TERMINATION_CHAR, 0)
        return this
    def add_MAX_SIZE_IN_BITS(MAX_SIZE_IN_BITS:int):
        b_.PrependUint16Slot(4, MAX_SIZE_IN_BITS, 0)
        return this
    def add_LEADING_SIZE_BITS(LEADING_SIZE_BITS:int):
        b_.PrependUint8Slot(5, LEADING_SIZE_BITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Binary data encoding specification
class BinaryDataEncoding : flatbuffers.handle
    /// Fixed size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 4, 0)
    /// Maximum size in bits (for variable length)
    def MAX_SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 6, 0)
    /// Leading size field bits (for variable length)
    def LEADING_SIZE_BITS() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 8, 0)

def GetRootAsBinaryDataEncoding(buf:string): return BinaryDataEncoding { buf, flatbuffers.indirect(buf, 0) }

struct BinaryDataEncodingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(0, SIZE_IN_BITS, 0)
        return this
    def add_MAX_SIZE_IN_BITS(MAX_SIZE_IN_BITS:int):
        b_.PrependUint16Slot(1, MAX_SIZE_IN_BITS, 0)
        return this
    def add_LEADING_SIZE_BITS(LEADING_SIZE_BITS:int):
        b_.PrependUint8Slot(2, LEADING_SIZE_BITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Polynomial calibrator - converts raw to engineering using polynomial
class PolynomialCalibrator : flatbuffers.handle
    /// Polynomial terms (index is power, value is coefficient)
    def COEFFICIENTS(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 4) + i * 8)
    def COEFFICIENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsPolynomialCalibrator(buf:string): return PolynomialCalibrator { buf, flatbuffers.indirect(buf, 0) }

struct PolynomialCalibratorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_COEFFICIENTS(COEFFICIENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COEFFICIENTS)
        return this
    def end():
        return b_.EndObject()

def PolynomialCalibratorStartCOEFFICIENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def PolynomialCalibratorCreateCOEFFICIENTSVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// Spline point for spline calibration
class SplinePoint : flatbuffers.handle
    /// Raw value
    def RAW() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Calibrated/engineering value
    def CALIBRATED() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)

def GetRootAsSplinePoint(buf:string): return SplinePoint { buf, flatbuffers.indirect(buf, 0) }

struct SplinePointBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_RAW(RAW:float):
        b_.PrependFloat64Slot(0, RAW, 0.0)
        return this
    def add_CALIBRATED(CALIBRATED:float):
        b_.PrependFloat64Slot(1, CALIBRATED, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Spline calibrator - piecewise linear interpolation
class SplineCalibrator : flatbuffers.handle
    /// Spline points ordered by raw value
    def POINTS(i:int) -> SplinePoint:
        return SplinePoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def POINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Extrapolate below minimum point
    def EXTRAPOLATE_LOW() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Extrapolate above maximum point
    def EXTRAPOLATE_HIGH() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 8, 0))

def GetRootAsSplineCalibrator(buf:string): return SplineCalibrator { buf, flatbuffers.indirect(buf, 0) }

struct SplineCalibratorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_POINTS(POINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, POINTS)
        return this
    def add_EXTRAPOLATE_LOW(EXTRAPOLATE_LOW:bool):
        b_.PrependBoolSlot(1, EXTRAPOLATE_LOW, 0)
        return this
    def add_EXTRAPOLATE_HIGH(EXTRAPOLATE_HIGH:bool):
        b_.PrependBoolSlot(2, EXTRAPOLATE_HIGH, 0)
        return this
    def end():
        return b_.EndObject()

def SplineCalibratorStartPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SplineCalibratorCreatePOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Mathematical operation for math operation calibrator
class MathOperation : flatbuffers.handle
    /// Operation in Reverse Polish Notation (RPN)
    def RPN_EXPRESSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)

def GetRootAsMathOperation(buf:string): return MathOperation { buf, flatbuffers.indirect(buf, 0) }

struct MathOperationBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RPN_EXPRESSION(RPN_EXPRESSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RPN_EXPRESSION)
        return this
    def end():
        return b_.EndObject()

/// Context-dependent calibrator selection
class ContextCalibrator : flatbuffers.handle
    /// Match criteria for selecting this calibrator
    def MATCH_CRITERIA() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: MatchCriteria { buf_, o } else: nil
    /// Polynomial calibrator (if used)
    def POLYNOMIAL() -> PolynomialCalibrator?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: PolynomialCalibrator { buf_, o } else: nil
    /// Spline calibrator (if used)
    def SPLINE() -> SplineCalibrator?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: SplineCalibrator { buf_, o } else: nil
    /// Math operation calibrator (if used)
    def MATH_OPERATION() -> MathOperation?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: MathOperation { buf_, o } else: nil

def GetRootAsContextCalibrator(buf:string): return ContextCalibrator { buf, flatbuffers.indirect(buf, 0) }

struct ContextCalibratorBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_MATCH_CRITERIA(MATCH_CRITERIA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, MATCH_CRITERIA)
        return this
    def add_POLYNOMIAL(POLYNOMIAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, POLYNOMIAL)
        return this
    def add_SPLINE(SPLINE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SPLINE)
        return this
    def add_MATH_OPERATION(MATH_OPERATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, MATH_OPERATION)
        return this
    def end():
        return b_.EndObject()

/// Numeric alarm range
class AlarmRange : flatbuffers.handle
    /// Minimum value (inclusive)
    def MIN_INCLUSIVE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Maximum value (inclusive)
    def MAX_INCLUSIVE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Minimum value (exclusive)
    def MIN_EXCLUSIVE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Maximum value (exclusive)
    def MAX_EXCLUSIVE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)

def GetRootAsAlarmRange(buf:string): return AlarmRange { buf, flatbuffers.indirect(buf, 0) }

struct AlarmRangeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_MIN_INCLUSIVE(MIN_INCLUSIVE:float):
        b_.PrependFloat64Slot(0, MIN_INCLUSIVE, 0.0)
        return this
    def add_MAX_INCLUSIVE(MAX_INCLUSIVE:float):
        b_.PrependFloat64Slot(1, MAX_INCLUSIVE, 0.0)
        return this
    def add_MIN_EXCLUSIVE(MIN_EXCLUSIVE:float):
        b_.PrependFloat64Slot(2, MIN_EXCLUSIVE, 0.0)
        return this
    def add_MAX_EXCLUSIVE(MAX_EXCLUSIVE:float):
        b_.PrependFloat64Slot(3, MAX_EXCLUSIVE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Static numeric alarm levels
class StaticAlarmRanges : flatbuffers.handle
    /// Watch range
    def WATCH_RANGE() -> AlarmRange?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: AlarmRange { buf_, o } else: nil
    /// Warning range
    def WARNING_RANGE() -> AlarmRange?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: AlarmRange { buf_, o } else: nil
    /// Distress range
    def DISTRESS_RANGE() -> AlarmRange?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: AlarmRange { buf_, o } else: nil
    /// Critical range
    def CRITICAL_RANGE() -> AlarmRange?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: AlarmRange { buf_, o } else: nil
    /// Severe range
    def SEVERE_RANGE() -> AlarmRange?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: AlarmRange { buf_, o } else: nil

def GetRootAsStaticAlarmRanges(buf:string): return StaticAlarmRanges { buf, flatbuffers.indirect(buf, 0) }

struct StaticAlarmRangesBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_WATCH_RANGE(WATCH_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, WATCH_RANGE)
        return this
    def add_WARNING_RANGE(WARNING_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, WARNING_RANGE)
        return this
    def add_DISTRESS_RANGE(DISTRESS_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, DISTRESS_RANGE)
        return this
    def add_CRITICAL_RANGE(CRITICAL_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CRITICAL_RANGE)
        return this
    def add_SEVERE_RANGE(SEVERE_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, SEVERE_RANGE)
        return this
    def end():
        return b_.EndObject()

/// Enumerated alarm
class EnumerationAlarm : flatbuffers.handle
    /// Enumerated value label
    def LABEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Alarm level for this value
    def ALARM_LEVEL() -> AlarmSeverityType:
        return AlarmSeverityType(flatbuffers.field_int8(buf_, pos_, 6, 0))

def GetRootAsEnumerationAlarm(buf:string): return EnumerationAlarm { buf, flatbuffers.indirect(buf, 0) }

struct EnumerationAlarmBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_LABEL(LABEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, LABEL)
        return this
    def add_ALARM_LEVEL(ALARM_LEVEL:AlarmSeverityType):
        b_.PrependInt8Slot(1, ALARM_LEVEL, 0)
        return this
    def end():
        return b_.EndObject()

/// Default alarm definition
class DefaultAlarm : flatbuffers.handle
    /// Minimum violations before alarm triggers
    def MIN_VIOLATIONS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 4, 0)
    /// Static numeric alarm ranges
    def STATIC_ALARM_RANGES() -> StaticAlarmRanges?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: StaticAlarmRanges { buf_, o } else: nil
    /// Enumeration alarms for enumerated types
    def ENUMERATION_ALARMS(i:int) -> EnumerationAlarm:
        return EnumerationAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def ENUMERATION_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsDefaultAlarm(buf:string): return DefaultAlarm { buf, flatbuffers.indirect(buf, 0) }

struct DefaultAlarmBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_MIN_VIOLATIONS(MIN_VIOLATIONS:int):
        b_.PrependUint16Slot(0, MIN_VIOLATIONS, 0)
        return this
    def add_STATIC_ALARM_RANGES(STATIC_ALARM_RANGES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, STATIC_ALARM_RANGES)
        return this
    def add_ENUMERATION_ALARMS(ENUMERATION_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ENUMERATION_ALARMS)
        return this
    def end():
        return b_.EndObject()

def DefaultAlarmStartENUMERATION_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def DefaultAlarmCreateENUMERATION_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Context-dependent alarm
class ContextAlarm : flatbuffers.handle
    /// Match criteria for this alarm context
    def MATCH_CRITERIA() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: MatchCriteria { buf_, o } else: nil
    /// Alarm definition for this context
    def ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: DefaultAlarm { buf_, o } else: nil

def GetRootAsContextAlarm(buf:string): return ContextAlarm { buf, flatbuffers.indirect(buf, 0) }

struct ContextAlarmBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_MATCH_CRITERIA(MATCH_CRITERIA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, MATCH_CRITERIA)
        return this
    def add_ALARM(ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ALARM)
        return this
    def end():
        return b_.EndObject()

/// Parameter comparison for match criteria
class ParameterComparison : flatbuffers.handle
    /// Parameter reference path
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Comparison operator
    def OPERATOR() -> ComparisonOperator:
        return ComparisonOperator(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Value to compare against
    def VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Use calibrated value (true) or raw value (false)
    def USE_CALIBRATED_VALUE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 1))

def GetRootAsParameterComparison(buf:string): return ParameterComparison { buf, flatbuffers.indirect(buf, 0) }

struct ParameterComparisonBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_OPERATOR(OPERATOR:ComparisonOperator):
        b_.PrependInt8Slot(1, OPERATOR, 0)
        return this
    def add_VALUE(VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, VALUE)
        return this
    def add_USE_CALIBRATED_VALUE(USE_CALIBRATED_VALUE:bool):
        b_.PrependBoolSlot(3, USE_CALIBRATED_VALUE, 1)
        return this
    def end():
        return b_.EndObject()

/// Boolean expression combining comparisons
class BooleanExpression : flatbuffers.handle
    /// Boolean operator
    def OPERATOR() -> BooleanOperatorType:
        return BooleanOperatorType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Comparison conditions
    def CONDITIONS(i:int) -> ParameterComparison:
        return ParameterComparison { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def CONDITIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Nested expressions
    def EXPRESSIONS(i:int) -> BooleanExpression:
        return BooleanExpression { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def EXPRESSIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsBooleanExpression(buf:string): return BooleanExpression { buf, flatbuffers.indirect(buf, 0) }

struct BooleanExpressionBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_OPERATOR(OPERATOR:BooleanOperatorType):
        b_.PrependInt8Slot(0, OPERATOR, 0)
        return this
    def add_CONDITIONS(CONDITIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CONDITIONS)
        return this
    def add_EXPRESSIONS(EXPRESSIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, EXPRESSIONS)
        return this
    def end():
        return b_.EndObject()

def BooleanExpressionStartCONDITIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def BooleanExpressionCreateCONDITIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def BooleanExpressionStartEXPRESSIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def BooleanExpressionCreateEXPRESSIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Match criteria for conditional logic
class MatchCriteria : flatbuffers.handle
    /// Single comparison
    def COMPARISON() -> ParameterComparison?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: ParameterComparison { buf_, o } else: nil
    /// List of comparisons (implicit AND)
    def COMPARISON_LIST(i:int) -> ParameterComparison:
        return ParameterComparison { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def COMPARISON_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Boolean expression
    def BOOLEAN_EXPRESSION() -> BooleanExpression?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: BooleanExpression { buf_, o } else: nil
    /// Custom algorithm reference
    def CUSTOM_ALGORITHM() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)

def GetRootAsMatchCriteria(buf:string): return MatchCriteria { buf, flatbuffers.indirect(buf, 0) }

struct MatchCriteriaBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_COMPARISON(COMPARISON:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, COMPARISON)
        return this
    def add_COMPARISON_LIST(COMPARISON_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COMPARISON_LIST)
        return this
    def add_BOOLEAN_EXPRESSION(BOOLEAN_EXPRESSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, BOOLEAN_EXPRESSION)
        return this
    def add_CUSTOM_ALGORITHM(CUSTOM_ALGORITHM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CUSTOM_ALGORITHM)
        return this
    def end():
        return b_.EndObject()

def MatchCriteriaStartCOMPARISON_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MatchCriteriaCreateCOMPARISON_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Unit specification
class Unit : flatbuffers.handle
    /// Unit description (e.g., "meters per second")
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Unit symbol (e.g., "m/s")
    def SYMBOL() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Power/exponent for this unit
    def POWER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Factor multiplier
    def FACTOR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)

def GetRootAsUnit(buf:string): return Unit { buf, flatbuffers.indirect(buf, 0) }

struct UnitBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, DESCRIPTION)
        return this
    def add_SYMBOL(SYMBOL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SYMBOL)
        return this
    def add_POWER(POWER:float):
        b_.PrependFloat64Slot(2, POWER, 0.0)
        return this
    def add_FACTOR(FACTOR:float):
        b_.PrependFloat64Slot(3, FACTOR, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Enumeration value mapping
class EnumerationValue : flatbuffers.handle
    /// Label/name for this value
    def LABEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Numeric value
    def VALUE() -> int:
        return flatbuffers.field_int64(buf_, pos_, 6, 0)
    /// Maximum value (for ranges)
    def MAX_VALUE() -> int:
        return flatbuffers.field_int64(buf_, pos_, 8, 0)
    /// Description of this enumeration value
    def DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)

def GetRootAsEnumerationValue(buf:string): return EnumerationValue { buf, flatbuffers.indirect(buf, 0) }

struct EnumerationValueBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_LABEL(LABEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, LABEL)
        return this
    def add_VALUE(VALUE:int):
        b_.PrependInt64Slot(1, VALUE, 0)
        return this
    def add_MAX_VALUE(MAX_VALUE:int):
        b_.PrependInt64Slot(2, MAX_VALUE, 0)
        return this
    def add_DESCRIPTION(DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DESCRIPTION)
        return this
    def end():
        return b_.EndObject()

/// Integer parameter type
class IntegerParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Units
    def UNITS(i:int) -> Unit:
        return Unit { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def UNITS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Minimum valid value
    def VALID_MIN() -> int:
        return flatbuffers.field_int64(buf_, pos_, 18, 0)
    /// Maximum valid value
    def VALID_MAX() -> int:
        return flatbuffers.field_int64(buf_, pos_, 20, 0)
    /// Signed integer (true) or unsigned (false)
    def SIGNED() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 22, 0))
    /// Size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 24, 0)
    /// Initial/default value
    def INITIAL_VALUE() -> int:
        return flatbuffers.field_int64(buf_, pos_, 26, 0)

def GetRootAsIntegerParameterType(buf:string): return IntegerParameterType { buf, flatbuffers.indirect(buf, 0) }

struct IntegerParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(12)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_UNITS(UNITS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UNITS)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DATA_ENCODING)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, CONTEXT_ALARMS)
        return this
    def add_VALID_MIN(VALID_MIN:int):
        b_.PrependInt64Slot(7, VALID_MIN, 0)
        return this
    def add_VALID_MAX(VALID_MAX:int):
        b_.PrependInt64Slot(8, VALID_MAX, 0)
        return this
    def add_SIGNED(SIGNED:bool):
        b_.PrependBoolSlot(9, SIGNED, 0)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(10, SIZE_IN_BITS, 0)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:int):
        b_.PrependInt64Slot(11, INITIAL_VALUE, 0)
        return this
    def end():
        return b_.EndObject()

def IntegerParameterTypeStartUNITSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IntegerParameterTypeCreateUNITSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def IntegerParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IntegerParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Float parameter type
class FloatParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Units
    def UNITS(i:int) -> Unit:
        return Unit { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def UNITS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Data encoding
    def DATA_ENCODING() -> FloatDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: FloatDataEncoding { buf_, o } else: nil
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Minimum valid value
    def VALID_MIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Maximum valid value
    def VALID_MAX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Size in bits (32 or 64)
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 22, 0)
    /// Initial/default value
    def INITIAL_VALUE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)

def GetRootAsFloatParameterType(buf:string): return FloatParameterType { buf, flatbuffers.indirect(buf, 0) }

struct FloatParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_UNITS(UNITS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UNITS)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DATA_ENCODING)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, CONTEXT_ALARMS)
        return this
    def add_VALID_MIN(VALID_MIN:float):
        b_.PrependFloat64Slot(7, VALID_MIN, 0.0)
        return this
    def add_VALID_MAX(VALID_MAX:float):
        b_.PrependFloat64Slot(8, VALID_MAX, 0.0)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(9, SIZE_IN_BITS, 0)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:float):
        b_.PrependFloat64Slot(10, INITIAL_VALUE, 0.0)
        return this
    def end():
        return b_.EndObject()

def FloatParameterTypeStartUNITSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def FloatParameterTypeCreateUNITSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def FloatParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def FloatParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// String parameter type
class StringParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> StringDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: StringDataEncoding { buf_, o } else: nil
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Initial/default value
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Restriction pattern (regex)
    def RESTRICTION_PATTERN() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)

def GetRootAsStringParameterType(buf:string): return StringParameterType { buf, flatbuffers.indirect(buf, 0) }

struct StringParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, CONTEXT_ALARMS)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, INITIAL_VALUE)
        return this
    def add_RESTRICTION_PATTERN(RESTRICTION_PATTERN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, RESTRICTION_PATTERN)
        return this
    def end():
        return b_.EndObject()

def StringParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StringParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Boolean parameter type
class BooleanParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding (typically IntegerDataEncoding with 1 bit)
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// String representation of true value
    def ONE_STRING_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// String representation of false value
    def ZERO_STRING_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Initial/default value
    def INITIAL_VALUE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsBooleanParameterType(buf:string): return BooleanParameterType { buf, flatbuffers.indirect(buf, 0) }

struct BooleanParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_ONE_STRING_VALUE(ONE_STRING_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ONE_STRING_VALUE)
        return this
    def add_ZERO_STRING_VALUE(ZERO_STRING_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, ZERO_STRING_VALUE)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:bool):
        b_.PrependBoolSlot(6, INITIAL_VALUE, 0)
        return this
    def end():
        return b_.EndObject()

/// Enumerated parameter type
class EnumeratedParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Enumeration values list
    def ENUMERATION_LIST(i:int) -> EnumerationValue:
        return EnumerationValue { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def ENUMERATION_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Initial/default value label
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)

def GetRootAsEnumeratedParameterType(buf:string): return EnumeratedParameterType { buf, flatbuffers.indirect(buf, 0) }

struct EnumeratedParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, CONTEXT_ALARMS)
        return this
    def add_ENUMERATION_LIST(ENUMERATION_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, ENUMERATION_LIST)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

def EnumeratedParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def EnumeratedParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def EnumeratedParameterTypeStartENUMERATION_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def EnumeratedParameterTypeCreateENUMERATION_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Binary parameter type
class BinaryParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> BinaryDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: BinaryDataEncoding { buf_, o } else: nil
    /// Initial/default value (hex string)
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)

def GetRootAsBinaryParameterType(buf:string): return BinaryParameterType { buf, flatbuffers.indirect(buf, 0) }

struct BinaryParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

/// Absolute time parameter type
class AbsoluteTimeParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Reference epoch
    def EPOCH() -> EpochType:
        return EpochType(flatbuffers.field_int8(buf_, pos_, 10, 2))
    /// Custom epoch date (ISO 8601) when EPOCH=CUSTOM
    def EPOCH_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Time unit scale factor
    def SCALE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Time unit offset
    def OFFSET() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 20)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)

def GetRootAsAbsoluteTimeParameterType(buf:string): return AbsoluteTimeParameterType { buf, flatbuffers.indirect(buf, 0) }

struct AbsoluteTimeParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_EPOCH(EPOCH:EpochType):
        b_.PrependInt8Slot(3, EPOCH, 2)
        return this
    def add_EPOCH_DATE(EPOCH_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, EPOCH_DATE)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, DATA_ENCODING)
        return this
    def add_SCALE(SCALE:float):
        b_.PrependFloat64Slot(6, SCALE, 0.0)
        return this
    def add_OFFSET(OFFSET:float):
        b_.PrependFloat64Slot(7, OFFSET, 0.0)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, CONTEXT_ALARMS)
        return this
    def end():
        return b_.EndObject()

def AbsoluteTimeParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AbsoluteTimeParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Relative time parameter type
class RelativeTimeParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Units
    def UNITS(i:int) -> Unit:
        return Unit { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def UNITS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Default alarm
    def DEFAULT_ALARM() -> DefaultAlarm?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: DefaultAlarm { buf_, o } else: nil
    /// Context alarms
    def CONTEXT_ALARMS(i:int) -> ContextAlarm:
        return ContextAlarm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def CONTEXT_ALARMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)

def GetRootAsRelativeTimeParameterType(buf:string): return RelativeTimeParameterType { buf, flatbuffers.indirect(buf, 0) }

struct RelativeTimeParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_UNITS(UNITS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UNITS)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DATA_ENCODING)
        return this
    def add_DEFAULT_ALARM(DEFAULT_ALARM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, DEFAULT_ALARM)
        return this
    def add_CONTEXT_ALARMS(CONTEXT_ALARMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, CONTEXT_ALARMS)
        return this
    def end():
        return b_.EndObject()

def RelativeTimeParameterTypeStartUNITSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def RelativeTimeParameterTypeCreateUNITSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def RelativeTimeParameterTypeStartCONTEXT_ALARMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def RelativeTimeParameterTypeCreateCONTEXT_ALARMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Array dimension specification
class ArrayDimension : flatbuffers.handle
    /// Fixed size of this dimension
    def SIZE() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 4, 0)
    /// Dynamic size from parameter reference
    def SIZE_PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsArrayDimension(buf:string): return ArrayDimension { buf, flatbuffers.indirect(buf, 0) }

struct ArrayDimensionBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_SIZE(SIZE:int):
        b_.PrependUint32Slot(0, SIZE, 0)
        return this
    def add_SIZE_PARAMETER_REF(SIZE_PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SIZE_PARAMETER_REF)
        return this
    def end():
        return b_.EndObject()

/// Array parameter type
class ArrayParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Reference to the array element type
    def ARRAY_TYPE_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Dimension list
    def DIMENSIONS(i:int) -> ArrayDimension:
        return ArrayDimension { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def DIMENSIONS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsArrayParameterType(buf:string): return ArrayParameterType { buf, flatbuffers.indirect(buf, 0) }

struct ArrayParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_ARRAY_TYPE_REF(ARRAY_TYPE_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ARRAY_TYPE_REF)
        return this
    def add_DIMENSIONS(DIMENSIONS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DIMENSIONS)
        return this
    def end():
        return b_.EndObject()

def ArrayParameterTypeStartDIMENSIONSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArrayParameterTypeCreateDIMENSIONSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Aggregate member definition
class AggregateMember : flatbuffers.handle
    /// Member name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Reference to parameter type
    def TYPE_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsAggregateMember(buf:string): return AggregateMember { buf, flatbuffers.indirect(buf, 0) }

struct AggregateMemberBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_TYPE_REF(TYPE_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, TYPE_REF)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SHORT_DESCRIPTION)
        return this
    def end():
        return b_.EndObject()

/// Aggregate parameter type (structure)
class AggregateParameterType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Member list
    def MEMBERS(i:int) -> AggregateMember:
        return AggregateMember { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def MEMBERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)

def GetRootAsAggregateParameterType(buf:string): return AggregateParameterType { buf, flatbuffers.indirect(buf, 0) }

struct AggregateParameterTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_MEMBERS(MEMBERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, MEMBERS)
        return this
    def end():
        return b_.EndObject()

def AggregateParameterTypeStartMEMBERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AggregateParameterTypeCreateMEMBERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of all parameter types
class ParameterTypeSet : flatbuffers.handle
    /// Integer parameter types
    def INTEGER_TYPES(i:int) -> IntegerParameterType:
        return IntegerParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def INTEGER_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Float parameter types
    def FLOAT_TYPES(i:int) -> FloatParameterType:
        return FloatParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def FLOAT_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// String parameter types
    def STRING_TYPES(i:int) -> StringParameterType:
        return StringParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def STRING_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Boolean parameter types
    def BOOLEAN_TYPES(i:int) -> BooleanParameterType:
        return BooleanParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def BOOLEAN_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Enumerated parameter types
    def ENUMERATED_TYPES(i:int) -> EnumeratedParameterType:
        return EnumeratedParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def ENUMERATED_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Binary parameter types
    def BINARY_TYPES(i:int) -> BinaryParameterType:
        return BinaryParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def BINARY_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Absolute time parameter types
    def ABSOLUTE_TIME_TYPES(i:int) -> AbsoluteTimeParameterType:
        return AbsoluteTimeParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def ABSOLUTE_TIME_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Relative time parameter types
    def RELATIVE_TIME_TYPES(i:int) -> RelativeTimeParameterType:
        return RelativeTimeParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def RELATIVE_TIME_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Array parameter types
    def ARRAY_TYPES(i:int) -> ArrayParameterType:
        return ArrayParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 20) + i * 4) }
    def ARRAY_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// Aggregate parameter types
    def AGGREGATE_TYPES(i:int) -> AggregateParameterType:
        return AggregateParameterType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def AGGREGATE_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)

def GetRootAsParameterTypeSet(buf:string): return ParameterTypeSet { buf, flatbuffers.indirect(buf, 0) }

struct ParameterTypeSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_INTEGER_TYPES(INTEGER_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, INTEGER_TYPES)
        return this
    def add_FLOAT_TYPES(FLOAT_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, FLOAT_TYPES)
        return this
    def add_STRING_TYPES(STRING_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, STRING_TYPES)
        return this
    def add_BOOLEAN_TYPES(BOOLEAN_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, BOOLEAN_TYPES)
        return this
    def add_ENUMERATED_TYPES(ENUMERATED_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ENUMERATED_TYPES)
        return this
    def add_BINARY_TYPES(BINARY_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, BINARY_TYPES)
        return this
    def add_ABSOLUTE_TIME_TYPES(ABSOLUTE_TIME_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, ABSOLUTE_TIME_TYPES)
        return this
    def add_RELATIVE_TIME_TYPES(RELATIVE_TIME_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, RELATIVE_TIME_TYPES)
        return this
    def add_ARRAY_TYPES(ARRAY_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, ARRAY_TYPES)
        return this
    def add_AGGREGATE_TYPES(AGGREGATE_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, AGGREGATE_TYPES)
        return this
    def end():
        return b_.EndObject()

def ParameterTypeSetStartINTEGER_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateINTEGER_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartFLOAT_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateFLOAT_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartSTRING_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateSTRING_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartBOOLEAN_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateBOOLEAN_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartENUMERATED_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateENUMERATED_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartBINARY_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateBINARY_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartABSOLUTE_TIME_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateABSOLUTE_TIME_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartRELATIVE_TIME_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateRELATIVE_TIME_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartARRAY_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateARRAY_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ParameterTypeSetStartAGGREGATE_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterTypeSetCreateAGGREGATE_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Parameter properties
class ParameterProperties : flatbuffers.handle
    /// Data source type
    def DATA_SOURCE() -> DataSourceType:
        return DataSourceType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Read-only parameter
    def READ_ONLY() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 6, 1))
    /// System/subsystem name
    def SYSTEM_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Validity condition
    def VALIDITY_CONDITION() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: MatchCriteria { buf_, o } else: nil

def GetRootAsParameterProperties(buf:string): return ParameterProperties { buf, flatbuffers.indirect(buf, 0) }

struct ParameterPropertiesBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_DATA_SOURCE(DATA_SOURCE:DataSourceType):
        b_.PrependInt8Slot(0, DATA_SOURCE, 0)
        return this
    def add_READ_ONLY(READ_ONLY:bool):
        b_.PrependBoolSlot(1, READ_ONLY, 1)
        return this
    def add_SYSTEM_NAME(SYSTEM_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SYSTEM_NAME)
        return this
    def add_VALIDITY_CONDITION(VALIDITY_CONDITION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, VALIDITY_CONDITION)
        return this
    def end():
        return b_.EndObject()

/// Parameter definition
class Parameter : flatbuffers.handle
    /// Parameter name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Reference to parameter type
    def PARAMETER_TYPE_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Parameter properties
    def PROPERTIES() -> ParameterProperties?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: ParameterProperties { buf_, o } else: nil
    /// Physical address mapping
    def PHYSICAL_ADDRESS() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Initial/default value
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)

def GetRootAsParameter(buf:string): return Parameter { buf, flatbuffers.indirect(buf, 0) }

struct ParameterBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_PARAMETER_TYPE_REF(PARAMETER_TYPE_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PARAMETER_TYPE_REF)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LONG_DESCRIPTION)
        return this
    def add_PROPERTIES(PROPERTIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, PROPERTIES)
        return this
    def add_PHYSICAL_ADDRESS(PHYSICAL_ADDRESS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, PHYSICAL_ADDRESS)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

/// Collection of parameters
class ParameterSet : flatbuffers.handle
    /// Parameters
    def PARAMETERS(i:int) -> Parameter:
        return Parameter { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def PARAMETERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsParameterSet(buf:string): return ParameterSet { buf, flatbuffers.indirect(buf, 0) }

struct ParameterSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_PARAMETERS(PARAMETERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETERS)
        return this
    def end():
        return b_.EndObject()

def ParameterSetStartPARAMETERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ParameterSetCreatePARAMETERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Location specification within a container
class LocationInContainer : flatbuffers.handle
    /// Reference location type
    def REFERENCE_LOCATION() -> ReferenceLocationType:
        return ReferenceLocationType(flatbuffers.field_int8(buf_, pos_, 4, 2))
    /// Offset in bits from reference location
    def OFFSET_IN_BITS() -> int:
        return flatbuffers.field_int32(buf_, pos_, 6, 0)

def GetRootAsLocationInContainer(buf:string): return LocationInContainer { buf, flatbuffers.indirect(buf, 0) }

struct LocationInContainerBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_REFERENCE_LOCATION(REFERENCE_LOCATION:ReferenceLocationType):
        b_.PrependInt8Slot(0, REFERENCE_LOCATION, 2)
        return this
    def add_OFFSET_IN_BITS(OFFSET_IN_BITS:int):
        b_.PrependInt32Slot(1, OFFSET_IN_BITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Repeat entry specification
class RepeatEntry : flatbuffers.handle
    /// Fixed repeat count
    def COUNT() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 4, 0)
    /// Dynamic count from parameter reference
    def COUNT_PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Offset in bits between repetitions
    def OFFSET_IN_BITS() -> int:
        return flatbuffers.field_int32(buf_, pos_, 8, 0)

def GetRootAsRepeatEntry(buf:string): return RepeatEntry { buf, flatbuffers.indirect(buf, 0) }

struct RepeatEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_COUNT(COUNT:int):
        b_.PrependUint32Slot(0, COUNT, 0)
        return this
    def add_COUNT_PARAMETER_REF(COUNT_PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COUNT_PARAMETER_REF)
        return this
    def add_OFFSET_IN_BITS(OFFSET_IN_BITS:int):
        b_.PrependInt32Slot(2, OFFSET_IN_BITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Parameter reference entry in container
class ParameterRefEntry : flatbuffers.handle
    /// Parameter reference path
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Location in container
    def LOCATION() -> LocationInContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: LocationInContainer { buf_, o } else: nil
    /// Repeat specification
    def REPEAT() -> RepeatEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: RepeatEntry { buf_, o } else: nil
    /// Include condition
    def INCLUDE_CONDITION() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: MatchCriteria { buf_, o } else: nil
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)

def GetRootAsParameterRefEntry(buf:string): return ParameterRefEntry { buf, flatbuffers.indirect(buf, 0) }

struct ParameterRefEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_LOCATION(LOCATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LOCATION)
        return this
    def add_REPEAT(REPEAT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, REPEAT)
        return this
    def add_INCLUDE_CONDITION(INCLUDE_CONDITION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, INCLUDE_CONDITION)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, SHORT_DESCRIPTION)
        return this
    def end():
        return b_.EndObject()

/// Container reference entry (nested container)
class ContainerRefEntry : flatbuffers.handle
    /// Container reference path
    def CONTAINER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Location in container
    def LOCATION() -> LocationInContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: LocationInContainer { buf_, o } else: nil
    /// Repeat specification
    def REPEAT() -> RepeatEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: RepeatEntry { buf_, o } else: nil
    /// Include condition
    def INCLUDE_CONDITION() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: MatchCriteria { buf_, o } else: nil

def GetRootAsContainerRefEntry(buf:string): return ContainerRefEntry { buf, flatbuffers.indirect(buf, 0) }

struct ContainerRefEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_CONTAINER_REF(CONTAINER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CONTAINER_REF)
        return this
    def add_LOCATION(LOCATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LOCATION)
        return this
    def add_REPEAT(REPEAT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, REPEAT)
        return this
    def add_INCLUDE_CONDITION(INCLUDE_CONDITION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, INCLUDE_CONDITION)
        return this
    def end():
        return b_.EndObject()

/// Fixed value entry (static padding/header)
class FixedValueEntry : flatbuffers.handle
    /// Binary value (hex string)
    def BINARY_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 6, 0)
    /// Name/description
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Location in container
    def LOCATION() -> LocationInContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: LocationInContainer { buf_, o } else: nil

def GetRootAsFixedValueEntry(buf:string): return FixedValueEntry { buf, flatbuffers.indirect(buf, 0) }

struct FixedValueEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_BINARY_VALUE(BINARY_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, BINARY_VALUE)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(1, SIZE_IN_BITS, 0)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, NAME)
        return this
    def add_LOCATION(LOCATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LOCATION)
        return this
    def end():
        return b_.EndObject()

/// Array parameter reference entry
class ArrayParameterRefEntry : flatbuffers.handle
    /// Parameter reference path
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Location in container
    def LOCATION() -> LocationInContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: LocationInContainer { buf_, o } else: nil
    /// First index to include
    def FIRST_INDEX() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    /// Last index to include
    def LAST_INDEX() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)

def GetRootAsArrayParameterRefEntry(buf:string): return ArrayParameterRefEntry { buf, flatbuffers.indirect(buf, 0) }

struct ArrayParameterRefEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_LOCATION(LOCATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LOCATION)
        return this
    def add_FIRST_INDEX(FIRST_INDEX:int):
        b_.PrependUint32Slot(2, FIRST_INDEX, 0)
        return this
    def add_LAST_INDEX(LAST_INDEX:int):
        b_.PrependUint32Slot(3, LAST_INDEX, 0)
        return this
    def end():
        return b_.EndObject()

/// Container entry list item (union of entry types)
class ContainerEntry : flatbuffers.handle
    /// Parameter reference entry
    def PARAMETER_REF_ENTRY() -> ParameterRefEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: ParameterRefEntry { buf_, o } else: nil
    /// Container reference entry
    def CONTAINER_REF_ENTRY() -> ContainerRefEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: ContainerRefEntry { buf_, o } else: nil
    /// Fixed value entry
    def FIXED_VALUE_ENTRY() -> FixedValueEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: FixedValueEntry { buf_, o } else: nil
    /// Array parameter reference entry
    def ARRAY_PARAMETER_REF_ENTRY() -> ArrayParameterRefEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: ArrayParameterRefEntry { buf_, o } else: nil

def GetRootAsContainerEntry(buf:string): return ContainerEntry { buf, flatbuffers.indirect(buf, 0) }

struct ContainerEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_PARAMETER_REF_ENTRY(PARAMETER_REF_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF_ENTRY)
        return this
    def add_CONTAINER_REF_ENTRY(CONTAINER_REF_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CONTAINER_REF_ENTRY)
        return this
    def add_FIXED_VALUE_ENTRY(FIXED_VALUE_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, FIXED_VALUE_ENTRY)
        return this
    def add_ARRAY_PARAMETER_REF_ENTRY(ARRAY_PARAMETER_REF_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ARRAY_PARAMETER_REF_ENTRY)
        return this
    def end():
        return b_.EndObject()

/// Base container reference with restriction
class BaseContainer : flatbuffers.handle
    /// Container reference path
    def CONTAINER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Restriction criteria
    def RESTRICTION_CRITERIA() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: MatchCriteria { buf_, o } else: nil

def GetRootAsBaseContainer(buf:string): return BaseContainer { buf, flatbuffers.indirect(buf, 0) }

struct BaseContainerBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_CONTAINER_REF(CONTAINER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CONTAINER_REF)
        return this
    def add_RESTRICTION_CRITERIA(RESTRICTION_CRITERIA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, RESTRICTION_CRITERIA)
        return this
    def end():
        return b_.EndObject()

/// Rate specification for container in stream
class RateInStream : flatbuffers.handle
    /// Stream reference
    def STREAM_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Rate value
    def RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Rate basis
    def BASIS() -> RateBasisType:
        return RateBasisType(flatbuffers.field_int8(buf_, pos_, 8, 0))

def GetRootAsRateInStream(buf:string): return RateInStream { buf, flatbuffers.indirect(buf, 0) }

struct RateInStreamBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_STREAM_REF(STREAM_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, STREAM_REF)
        return this
    def add_RATE(RATE:float):
        b_.PrependFloat64Slot(1, RATE, 0.0)
        return this
    def add_BASIS(BASIS:RateBasisType):
        b_.PrependInt8Slot(2, BASIS, 0)
        return this
    def end():
        return b_.EndObject()

/// Binary encoding specification for container
class ContainerBinaryEncoding : flatbuffers.handle
    /// Error detection type
    def ERROR_DETECTION() -> ErrorDetectionType:
        return ErrorDetectionType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// CRC polynomial (for CRC error detection)
    def CRC_POLYNOMIAL() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)

def GetRootAsContainerBinaryEncoding(buf:string): return ContainerBinaryEncoding { buf, flatbuffers.indirect(buf, 0) }

struct ContainerBinaryEncodingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_ERROR_DETECTION(ERROR_DETECTION:ErrorDetectionType):
        b_.PrependInt8Slot(0, ERROR_DETECTION, 0)
        return this
    def add_CRC_POLYNOMIAL(CRC_POLYNOMIAL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CRC_POLYNOMIAL)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint32Slot(2, SIZE_IN_BITS, 0)
        return this
    def end():
        return b_.EndObject()

/// Sequence container (packet definition)
class SequenceContainer : flatbuffers.handle
    /// Container name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Abstract container (used as base only)
    def ABSTRACT() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Container entry list
    def ENTRY_LIST(i:int) -> ContainerEntry:
        return ContainerEntry { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def ENTRY_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Base container (inheritance)
    def BASE_CONTAINER() -> BaseContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: BaseContainer { buf_, o } else: nil
    /// Binary encoding
    def BINARY_ENCODING() -> ContainerBinaryEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: ContainerBinaryEncoding { buf_, o } else: nil
    /// Rate in stream
    def RATE_IN_STREAM() -> RateInStream?:
        let o = flatbuffers.field_table(buf_, pos_, 18)
        return if o: RateInStream { buf_, o } else: nil
    /// Idle pattern (hex string for padding)
    def IDLE_PATTERN() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)

def GetRootAsSequenceContainer(buf:string): return SequenceContainer { buf, flatbuffers.indirect(buf, 0) }

struct SequenceContainerBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_ABSTRACT(ABSTRACT:bool):
        b_.PrependBoolSlot(3, ABSTRACT, 0)
        return this
    def add_ENTRY_LIST(ENTRY_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ENTRY_LIST)
        return this
    def add_BASE_CONTAINER(BASE_CONTAINER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, BASE_CONTAINER)
        return this
    def add_BINARY_ENCODING(BINARY_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, BINARY_ENCODING)
        return this
    def add_RATE_IN_STREAM(RATE_IN_STREAM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, RATE_IN_STREAM)
        return this
    def add_IDLE_PATTERN(IDLE_PATTERN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, IDLE_PATTERN)
        return this
    def end():
        return b_.EndObject()

def SequenceContainerStartENTRY_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SequenceContainerCreateENTRY_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of sequence containers
class ContainerSet : flatbuffers.handle
    /// Sequence containers
    def CONTAINERS(i:int) -> SequenceContainer:
        return SequenceContainer { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def CONTAINERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsContainerSet(buf:string): return ContainerSet { buf, flatbuffers.indirect(buf, 0) }

struct ContainerSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_CONTAINERS(CONTAINERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CONTAINERS)
        return this
    def end():
        return b_.EndObject()

def ContainerSetStartCONTAINERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ContainerSetCreateCONTAINERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Algorithm input binding
class AlgorithmInput : flatbuffers.handle
    /// Parameter reference
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Input name in algorithm
    def INPUT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsAlgorithmInput(buf:string): return AlgorithmInput { buf, flatbuffers.indirect(buf, 0) }

struct AlgorithmInputBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_INPUT_NAME(INPUT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, INPUT_NAME)
        return this
    def end():
        return b_.EndObject()

/// Algorithm output binding
class AlgorithmOutput : flatbuffers.handle
    /// Parameter reference
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Output name in algorithm
    def OUTPUT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsAlgorithmOutput(buf:string): return AlgorithmOutput { buf, flatbuffers.indirect(buf, 0) }

struct AlgorithmOutputBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_OUTPUT_NAME(OUTPUT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, OUTPUT_NAME)
        return this
    def end():
        return b_.EndObject()

/// Trigger condition for algorithm execution
class AlgorithmTrigger : flatbuffers.handle
    /// Trigger on parameter update
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Trigger on container reception
    def CONTAINER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Trigger rate (per second)
    def RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsAlgorithmTrigger(buf:string): return AlgorithmTrigger { buf, flatbuffers.indirect(buf, 0) }

struct AlgorithmTriggerBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_CONTAINER_REF(CONTAINER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CONTAINER_REF)
        return this
    def add_RATE(RATE:float):
        b_.PrependFloat64Slot(2, RATE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Custom algorithm definition
class CustomAlgorithm : flatbuffers.handle
    /// Algorithm name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Programming language
    def LANGUAGE() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Algorithm text/code
    def ALGORITHM_TEXT() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// External algorithm reference
    def EXTERNAL_ALGORITHM_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Input bindings
    def INPUTS(i:int) -> AlgorithmInput:
        return AlgorithmInput { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def INPUTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Output bindings
    def OUTPUTS(i:int) -> AlgorithmOutput:
        return AlgorithmOutput { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def OUTPUTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Trigger conditions
    def TRIGGERS(i:int) -> AlgorithmTrigger:
        return AlgorithmTrigger { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 20) + i * 4) }
    def TRIGGERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)

def GetRootAsCustomAlgorithm(buf:string): return CustomAlgorithm { buf, flatbuffers.indirect(buf, 0) }

struct CustomAlgorithmBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_LANGUAGE(LANGUAGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LANGUAGE)
        return this
    def add_ALGORITHM_TEXT(ALGORITHM_TEXT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ALGORITHM_TEXT)
        return this
    def add_EXTERNAL_ALGORITHM_REF(EXTERNAL_ALGORITHM_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, EXTERNAL_ALGORITHM_REF)
        return this
    def add_INPUTS(INPUTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, INPUTS)
        return this
    def add_OUTPUTS(OUTPUTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, OUTPUTS)
        return this
    def add_TRIGGERS(TRIGGERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, TRIGGERS)
        return this
    def end():
        return b_.EndObject()

def CustomAlgorithmStartINPUTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CustomAlgorithmCreateINPUTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def CustomAlgorithmStartOUTPUTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CustomAlgorithmCreateOUTPUTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def CustomAlgorithmStartTRIGGERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CustomAlgorithmCreateTRIGGERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Math algorithm (inline calculation)
class MathAlgorithm : flatbuffers.handle
    /// Algorithm name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Math operation in RPN
    def MATH_OPERATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Output parameter reference
    def OUTPUT_PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Trigger conditions
    def TRIGGERS(i:int) -> AlgorithmTrigger:
        return AlgorithmTrigger { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def TRIGGERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsMathAlgorithm(buf:string): return MathAlgorithm { buf, flatbuffers.indirect(buf, 0) }

struct MathAlgorithmBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_MATH_OPERATION(MATH_OPERATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, MATH_OPERATION)
        return this
    def add_OUTPUT_PARAMETER_REF(OUTPUT_PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OUTPUT_PARAMETER_REF)
        return this
    def add_TRIGGERS(TRIGGERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, TRIGGERS)
        return this
    def end():
        return b_.EndObject()

def MathAlgorithmStartTRIGGERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MathAlgorithmCreateTRIGGERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of algorithms
class AlgorithmSet : flatbuffers.handle
    /// Custom algorithms
    def CUSTOM_ALGORITHMS(i:int) -> CustomAlgorithm:
        return CustomAlgorithm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def CUSTOM_ALGORITHMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Math algorithms
    def MATH_ALGORITHMS(i:int) -> MathAlgorithm:
        return MathAlgorithm { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def MATH_ALGORITHMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)

def GetRootAsAlgorithmSet(buf:string): return AlgorithmSet { buf, flatbuffers.indirect(buf, 0) }

struct AlgorithmSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_CUSTOM_ALGORITHMS(CUSTOM_ALGORITHMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CUSTOM_ALGORITHMS)
        return this
    def add_MATH_ALGORITHMS(MATH_ALGORITHMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, MATH_ALGORITHMS)
        return this
    def end():
        return b_.EndObject()

def AlgorithmSetStartCUSTOM_ALGORITHMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AlgorithmSetCreateCUSTOM_ALGORITHMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AlgorithmSetStartMATH_ALGORITHMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AlgorithmSetCreateMATH_ALGORITHMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Integer argument type
class IntegerArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Units
    def UNITS(i:int) -> Unit:
        return Unit { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def UNITS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Minimum valid value
    def VALID_MIN() -> int:
        return flatbuffers.field_int64(buf_, pos_, 14, 0)
    /// Maximum valid value
    def VALID_MAX() -> int:
        return flatbuffers.field_int64(buf_, pos_, 16, 0)
    /// Signed integer (true) or unsigned (false)
    def SIGNED() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 18, 0))
    /// Size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 20, 0)
    /// Initial/default value
    def INITIAL_VALUE() -> int:
        return flatbuffers.field_int64(buf_, pos_, 22, 0)

def GetRootAsIntegerArgumentType(buf:string): return IntegerArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct IntegerArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_UNITS(UNITS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UNITS)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DATA_ENCODING)
        return this
    def add_VALID_MIN(VALID_MIN:int):
        b_.PrependInt64Slot(5, VALID_MIN, 0)
        return this
    def add_VALID_MAX(VALID_MAX:int):
        b_.PrependInt64Slot(6, VALID_MAX, 0)
        return this
    def add_SIGNED(SIGNED:bool):
        b_.PrependBoolSlot(7, SIGNED, 0)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(8, SIZE_IN_BITS, 0)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:int):
        b_.PrependInt64Slot(9, INITIAL_VALUE, 0)
        return this
    def end():
        return b_.EndObject()

def IntegerArgumentTypeStartUNITSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IntegerArgumentTypeCreateUNITSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Float argument type
class FloatArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Units
    def UNITS(i:int) -> Unit:
        return Unit { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def UNITS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Data encoding
    def DATA_ENCODING() -> FloatDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: FloatDataEncoding { buf_, o } else: nil
    /// Minimum valid value
    def VALID_MIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Maximum valid value
    def VALID_MAX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Size in bits
    def SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 18, 0)
    /// Initial/default value
    def INITIAL_VALUE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)

def GetRootAsFloatArgumentType(buf:string): return FloatArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct FloatArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_UNITS(UNITS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UNITS)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DATA_ENCODING)
        return this
    def add_VALID_MIN(VALID_MIN:float):
        b_.PrependFloat64Slot(5, VALID_MIN, 0.0)
        return this
    def add_VALID_MAX(VALID_MAX:float):
        b_.PrependFloat64Slot(6, VALID_MAX, 0.0)
        return this
    def add_SIZE_IN_BITS(SIZE_IN_BITS:int):
        b_.PrependUint16Slot(7, SIZE_IN_BITS, 0)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:float):
        b_.PrependFloat64Slot(8, INITIAL_VALUE, 0.0)
        return this
    def end():
        return b_.EndObject()

def FloatArgumentTypeStartUNITSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def FloatArgumentTypeCreateUNITSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// String argument type
class StringArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> StringDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: StringDataEncoding { buf_, o } else: nil
    /// Initial/default value
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Restriction pattern (regex)
    def RESTRICTION_PATTERN() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)

def GetRootAsStringArgumentType(buf:string): return StringArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct StringArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, INITIAL_VALUE)
        return this
    def add_RESTRICTION_PATTERN(RESTRICTION_PATTERN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, RESTRICTION_PATTERN)
        return this
    def end():
        return b_.EndObject()

/// Boolean argument type
class BooleanArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// String representation of true value
    def ONE_STRING_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// String representation of false value
    def ZERO_STRING_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Initial/default value
    def INITIAL_VALUE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsBooleanArgumentType(buf:string): return BooleanArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct BooleanArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_ONE_STRING_VALUE(ONE_STRING_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ONE_STRING_VALUE)
        return this
    def add_ZERO_STRING_VALUE(ZERO_STRING_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, ZERO_STRING_VALUE)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:bool):
        b_.PrependBoolSlot(6, INITIAL_VALUE, 0)
        return this
    def end():
        return b_.EndObject()

/// Enumerated argument type
class EnumeratedArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> IntegerDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: IntegerDataEncoding { buf_, o } else: nil
    /// Enumeration values list
    def ENUMERATION_LIST(i:int) -> EnumerationValue:
        return EnumerationValue { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def ENUMERATION_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Initial/default value label
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)

def GetRootAsEnumeratedArgumentType(buf:string): return EnumeratedArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct EnumeratedArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_ENUMERATION_LIST(ENUMERATION_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ENUMERATION_LIST)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

def EnumeratedArgumentTypeStartENUMERATION_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def EnumeratedArgumentTypeCreateENUMERATION_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Binary argument type
class BinaryArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Data encoding
    def DATA_ENCODING() -> BinaryDataEncoding?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: BinaryDataEncoding { buf_, o } else: nil
    /// Initial/default value (hex string)
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)

def GetRootAsBinaryArgumentType(buf:string): return BinaryArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct BinaryArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_DATA_ENCODING(DATA_ENCODING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, DATA_ENCODING)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

/// Aggregate argument type
class AggregateArgumentType : flatbuffers.handle
    /// Type name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Member list
    def MEMBERS(i:int) -> AggregateMember:
        return AggregateMember { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def MEMBERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)

def GetRootAsAggregateArgumentType(buf:string): return AggregateArgumentType { buf, flatbuffers.indirect(buf, 0) }

struct AggregateArgumentTypeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_MEMBERS(MEMBERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, MEMBERS)
        return this
    def end():
        return b_.EndObject()

def AggregateArgumentTypeStartMEMBERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AggregateArgumentTypeCreateMEMBERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of argument types
class ArgumentTypeSet : flatbuffers.handle
    /// Integer argument types
    def INTEGER_TYPES(i:int) -> IntegerArgumentType:
        return IntegerArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def INTEGER_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Float argument types
    def FLOAT_TYPES(i:int) -> FloatArgumentType:
        return FloatArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def FLOAT_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// String argument types
    def STRING_TYPES(i:int) -> StringArgumentType:
        return StringArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def STRING_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)
    /// Boolean argument types
    def BOOLEAN_TYPES(i:int) -> BooleanArgumentType:
        return BooleanArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 10) + i * 4) }
    def BOOLEAN_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Enumerated argument types
    def ENUMERATED_TYPES(i:int) -> EnumeratedArgumentType:
        return EnumeratedArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def ENUMERATED_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Binary argument types
    def BINARY_TYPES(i:int) -> BinaryArgumentType:
        return BinaryArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 14) + i * 4) }
    def BINARY_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Aggregate argument types
    def AGGREGATE_TYPES(i:int) -> AggregateArgumentType:
        return AggregateArgumentType { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def AGGREGATE_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)

def GetRootAsArgumentTypeSet(buf:string): return ArgumentTypeSet { buf, flatbuffers.indirect(buf, 0) }

struct ArgumentTypeSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_INTEGER_TYPES(INTEGER_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, INTEGER_TYPES)
        return this
    def add_FLOAT_TYPES(FLOAT_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, FLOAT_TYPES)
        return this
    def add_STRING_TYPES(STRING_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, STRING_TYPES)
        return this
    def add_BOOLEAN_TYPES(BOOLEAN_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, BOOLEAN_TYPES)
        return this
    def add_ENUMERATED_TYPES(ENUMERATED_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ENUMERATED_TYPES)
        return this
    def add_BINARY_TYPES(BINARY_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, BINARY_TYPES)
        return this
    def add_AGGREGATE_TYPES(AGGREGATE_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, AGGREGATE_TYPES)
        return this
    def end():
        return b_.EndObject()

def ArgumentTypeSetStartINTEGER_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateINTEGER_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartFLOAT_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateFLOAT_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartSTRING_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateSTRING_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartBOOLEAN_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateBOOLEAN_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartENUMERATED_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateENUMERATED_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartBINARY_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateBINARY_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ArgumentTypeSetStartAGGREGATE_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ArgumentTypeSetCreateAGGREGATE_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Command argument definition
class Argument : flatbuffers.handle
    /// Argument name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Reference to argument type
    def ARGUMENT_TYPE_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Initial/default value
    def INITIAL_VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)

def GetRootAsArgument(buf:string): return Argument { buf, flatbuffers.indirect(buf, 0) }

struct ArgumentBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_ARGUMENT_TYPE_REF(ARGUMENT_TYPE_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ARGUMENT_TYPE_REF)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LONG_DESCRIPTION)
        return this
    def add_INITIAL_VALUE(INITIAL_VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, INITIAL_VALUE)
        return this
    def end():
        return b_.EndObject()

/// Argument reference entry in command container
class ArgumentRefEntry : flatbuffers.handle
    /// Argument reference
    def ARGUMENT_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Location in container
    def LOCATION() -> LocationInContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: LocationInContainer { buf_, o } else: nil
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsArgumentRefEntry(buf:string): return ArgumentRefEntry { buf, flatbuffers.indirect(buf, 0) }

struct ArgumentRefEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_ARGUMENT_REF(ARGUMENT_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ARGUMENT_REF)
        return this
    def add_LOCATION(LOCATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LOCATION)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, SHORT_DESCRIPTION)
        return this
    def end():
        return b_.EndObject()

/// Command container entry
class CommandContainerEntry : flatbuffers.handle
    /// Argument reference entry
    def ARGUMENT_REF_ENTRY() -> ArgumentRefEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: ArgumentRefEntry { buf_, o } else: nil
    /// Parameter reference entry
    def PARAMETER_REF_ENTRY() -> ParameterRefEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: ParameterRefEntry { buf_, o } else: nil
    /// Fixed value entry
    def FIXED_VALUE_ENTRY() -> FixedValueEntry?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: FixedValueEntry { buf_, o } else: nil

def GetRootAsCommandContainerEntry(buf:string): return CommandContainerEntry { buf, flatbuffers.indirect(buf, 0) }

struct CommandContainerEntryBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_ARGUMENT_REF_ENTRY(ARGUMENT_REF_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ARGUMENT_REF_ENTRY)
        return this
    def add_PARAMETER_REF_ENTRY(PARAMETER_REF_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PARAMETER_REF_ENTRY)
        return this
    def add_FIXED_VALUE_ENTRY(FIXED_VALUE_ENTRY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, FIXED_VALUE_ENTRY)
        return this
    def end():
        return b_.EndObject()

/// Command container definition
class CommandContainer : flatbuffers.handle
    /// Container name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Entry list
    def ENTRY_LIST(i:int) -> CommandContainerEntry:
        return CommandContainerEntry { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def ENTRY_LIST_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Base container reference
    def BASE_CONTAINER() -> BaseContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: BaseContainer { buf_, o } else: nil

def GetRootAsCommandContainer(buf:string): return CommandContainer { buf, flatbuffers.indirect(buf, 0) }

struct CommandContainerBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_ENTRY_LIST(ENTRY_LIST:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ENTRY_LIST)
        return this
    def add_BASE_CONTAINER(BASE_CONTAINER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, BASE_CONTAINER)
        return this
    def end():
        return b_.EndObject()

def CommandContainerStartENTRY_LISTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CommandContainerCreateENTRY_LISTVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Command verifier definition
class CommandVerifier : flatbuffers.handle
    /// Verifier name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Verifier type
    def VERIFIER_TYPE() -> VerifierType:
        return VerifierType(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Verification condition
    def CONDITION() -> MatchCriteria?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: MatchCriteria { buf_, o } else: nil
    /// Container reference for verification
    def CONTAINER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Time window start (seconds)
    def TIME_WINDOW_START() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Time window stop (seconds)
    def TIME_WINDOW_STOP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Time window reference type
    def TIME_WINDOW_REF() -> TimeWindowRefType:
        return TimeWindowRefType(flatbuffers.field_int8(buf_, pos_, 16, 0))

def GetRootAsCommandVerifier(buf:string): return CommandVerifier { buf, flatbuffers.indirect(buf, 0) }

struct CommandVerifierBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_VERIFIER_TYPE(VERIFIER_TYPE:VerifierType):
        b_.PrependInt8Slot(1, VERIFIER_TYPE, 0)
        return this
    def add_CONDITION(CONDITION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CONDITION)
        return this
    def add_CONTAINER_REF(CONTAINER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CONTAINER_REF)
        return this
    def add_TIME_WINDOW_START(TIME_WINDOW_START:float):
        b_.PrependFloat64Slot(4, TIME_WINDOW_START, 0.0)
        return this
    def add_TIME_WINDOW_STOP(TIME_WINDOW_STOP:float):
        b_.PrependFloat64Slot(5, TIME_WINDOW_STOP, 0.0)
        return this
    def add_TIME_WINDOW_REF(TIME_WINDOW_REF:TimeWindowRefType):
        b_.PrependInt8Slot(6, TIME_WINDOW_REF, 0)
        return this
    def end():
        return b_.EndObject()

/// Significance of command execution
class CommandSignificance : flatbuffers.handle
    /// Consequence level (1=lowest, higher=more severe)
    def CONSEQUENCE_LEVEL() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 4, 0)
    /// Reason for significance
    def REASON_FOR_WARNING() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsCommandSignificance(buf:string): return CommandSignificance { buf, flatbuffers.indirect(buf, 0) }

struct CommandSignificanceBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_CONSEQUENCE_LEVEL(CONSEQUENCE_LEVEL:int):
        b_.PrependUint8Slot(0, CONSEQUENCE_LEVEL, 0)
        return this
    def add_REASON_FOR_WARNING(REASON_FOR_WARNING:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, REASON_FOR_WARNING)
        return this
    def end():
        return b_.EndObject()

/// Base metacommand reference
class BaseMetaCommand : flatbuffers.handle
    /// MetaCommand reference
    def META_COMMAND_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Argument assignments for inherited arguments
    def ARGUMENT_ASSIGNMENTS(i:int) -> ArgumentAssignment:
        return ArgumentAssignment { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def ARGUMENT_ASSIGNMENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)

def GetRootAsBaseMetaCommand(buf:string): return BaseMetaCommand { buf, flatbuffers.indirect(buf, 0) }

struct BaseMetaCommandBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_META_COMMAND_REF(META_COMMAND_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, META_COMMAND_REF)
        return this
    def add_ARGUMENT_ASSIGNMENTS(ARGUMENT_ASSIGNMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ARGUMENT_ASSIGNMENTS)
        return this
    def end():
        return b_.EndObject()

def BaseMetaCommandStartARGUMENT_ASSIGNMENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def BaseMetaCommandCreateARGUMENT_ASSIGNMENTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Argument assignment (value binding)
class ArgumentAssignment : flatbuffers.handle
    /// Argument name
    def ARGUMENT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Assigned value
    def VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsArgumentAssignment(buf:string): return ArgumentAssignment { buf, flatbuffers.indirect(buf, 0) }

struct ArgumentAssignmentBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_ARGUMENT_NAME(ARGUMENT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ARGUMENT_NAME)
        return this
    def add_VALUE(VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VALUE)
        return this
    def end():
        return b_.EndObject()

/// Interlock constraint
class Interlock : flatbuffers.handle
    /// Parameter reference
    def PARAMETER_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Required value
    def VALUE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Operator for comparison
    def OPERATOR() -> ComparisonOperator:
        return ComparisonOperator(flatbuffers.field_int8(buf_, pos_, 8, 0))

def GetRootAsInterlock(buf:string): return Interlock { buf, flatbuffers.indirect(buf, 0) }

struct InterlockBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_PARAMETER_REF(PARAMETER_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_REF)
        return this
    def add_VALUE(VALUE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VALUE)
        return this
    def add_OPERATOR(OPERATOR:ComparisonOperator):
        b_.PrependInt8Slot(2, OPERATOR, 0)
        return this
    def end():
        return b_.EndObject()

/// MetaCommand definition
class MetaCommand : flatbuffers.handle
    /// Command name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Abstract command (base only)
    def ABSTRACT() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Argument list
    def ARGUMENTS(i:int) -> Argument:
        return Argument { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 12) + i * 4) }
    def ARGUMENTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Command container
    def COMMAND_CONTAINER() -> CommandContainer?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: CommandContainer { buf_, o } else: nil
    /// Base metacommand (inheritance)
    def BASE_META_COMMAND() -> BaseMetaCommand?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: BaseMetaCommand { buf_, o } else: nil
    /// Command verifiers
    def VERIFIERS(i:int) -> CommandVerifier:
        return CommandVerifier { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 18) + i * 4) }
    def VERIFIERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Command significance
    def SIGNIFICANCE() -> CommandSignificance?:
        let o = flatbuffers.field_table(buf_, pos_, 20)
        return if o: CommandSignificance { buf_, o } else: nil
    /// Interlock constraints
    def INTERLOCKS(i:int) -> Interlock:
        return Interlock { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 22) + i * 4) }
    def INTERLOCKS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    /// Default significance
    def DEFAULT_SIGNIFICANCE() -> CommandSignificance?:
        let o = flatbuffers.field_table(buf_, pos_, 24)
        return if o: CommandSignificance { buf_, o } else: nil

def GetRootAsMetaCommand(buf:string): return MetaCommand { buf, flatbuffers.indirect(buf, 0) }

struct MetaCommandBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_ABSTRACT(ABSTRACT:bool):
        b_.PrependBoolSlot(3, ABSTRACT, 0)
        return this
    def add_ARGUMENTS(ARGUMENTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ARGUMENTS)
        return this
    def add_COMMAND_CONTAINER(COMMAND_CONTAINER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, COMMAND_CONTAINER)
        return this
    def add_BASE_META_COMMAND(BASE_META_COMMAND:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, BASE_META_COMMAND)
        return this
    def add_VERIFIERS(VERIFIERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, VERIFIERS)
        return this
    def add_SIGNIFICANCE(SIGNIFICANCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, SIGNIFICANCE)
        return this
    def add_INTERLOCKS(INTERLOCKS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, INTERLOCKS)
        return this
    def add_DEFAULT_SIGNIFICANCE(DEFAULT_SIGNIFICANCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, DEFAULT_SIGNIFICANCE)
        return this
    def end():
        return b_.EndObject()

def MetaCommandStartARGUMENTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MetaCommandCreateARGUMENTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MetaCommandStartVERIFIERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MetaCommandCreateVERIFIERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MetaCommandStartINTERLOCKSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MetaCommandCreateINTERLOCKSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of metacommands
class MetaCommandSet : flatbuffers.handle
    /// MetaCommands
    def META_COMMANDS(i:int) -> MetaCommand:
        return MetaCommand { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def META_COMMANDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsMetaCommandSet(buf:string): return MetaCommandSet { buf, flatbuffers.indirect(buf, 0) }

struct MetaCommandSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_META_COMMANDS(META_COMMANDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, META_COMMANDS)
        return this
    def end():
        return b_.EndObject()

def MetaCommandSetStartMETA_COMMANDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MetaCommandSetCreateMETA_COMMANDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Fixed frame stream
class FixedFrameStream : flatbuffers.handle
    /// Stream name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Frame size in bits
    def FRAME_SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    /// Sync pattern (hex string)
    def SYNC_PATTERN() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)

def GetRootAsFixedFrameStream(buf:string): return FixedFrameStream { buf, flatbuffers.indirect(buf, 0) }

struct FixedFrameStreamBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_FRAME_SIZE_IN_BITS(FRAME_SIZE_IN_BITS:int):
        b_.PrependUint32Slot(2, FRAME_SIZE_IN_BITS, 0)
        return this
    def add_SYNC_PATTERN(SYNC_PATTERN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, SYNC_PATTERN)
        return this
    def end():
        return b_.EndObject()

/// Variable frame stream
class VariableFrameStream : flatbuffers.handle
    /// Stream name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Minimum frame size in bits
    def MIN_FRAME_SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    /// Maximum frame size in bits
    def MAX_FRAME_SIZE_IN_BITS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)
    /// Size field location in bits
    def SIZE_FIELD_OFFSET() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 12, 0)
    /// Size field size in bits
    def SIZE_FIELD_SIZE() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 14, 0)

def GetRootAsVariableFrameStream(buf:string): return VariableFrameStream { buf, flatbuffers.indirect(buf, 0) }

struct VariableFrameStreamBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_MIN_FRAME_SIZE_IN_BITS(MIN_FRAME_SIZE_IN_BITS:int):
        b_.PrependUint32Slot(2, MIN_FRAME_SIZE_IN_BITS, 0)
        return this
    def add_MAX_FRAME_SIZE_IN_BITS(MAX_FRAME_SIZE_IN_BITS:int):
        b_.PrependUint32Slot(3, MAX_FRAME_SIZE_IN_BITS, 0)
        return this
    def add_SIZE_FIELD_OFFSET(SIZE_FIELD_OFFSET:int):
        b_.PrependUint32Slot(4, SIZE_FIELD_OFFSET, 0)
        return this
    def add_SIZE_FIELD_SIZE(SIZE_FIELD_SIZE:int):
        b_.PrependUint16Slot(5, SIZE_FIELD_SIZE, 0)
        return this
    def end():
        return b_.EndObject()

/// Custom stream
class CustomStream : flatbuffers.handle
    /// Stream name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Algorithm reference for parsing
    def ALGORITHM_REF() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)

def GetRootAsCustomStream(buf:string): return CustomStream { buf, flatbuffers.indirect(buf, 0) }

struct CustomStreamBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_ALGORITHM_REF(ALGORITHM_REF:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ALGORITHM_REF)
        return this
    def end():
        return b_.EndObject()

/// Collection of streams
class StreamSet : flatbuffers.handle
    /// Fixed frame streams
    def FIXED_FRAME_STREAMS(i:int) -> FixedFrameStream:
        return FixedFrameStream { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def FIXED_FRAME_STREAMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Variable frame streams
    def VARIABLE_FRAME_STREAMS(i:int) -> VariableFrameStream:
        return VariableFrameStream { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def VARIABLE_FRAME_STREAMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)
    /// Custom streams
    def CUSTOM_STREAMS(i:int) -> CustomStream:
        return CustomStream { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def CUSTOM_STREAMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsStreamSet(buf:string): return StreamSet { buf, flatbuffers.indirect(buf, 0) }

struct StreamSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_FIXED_FRAME_STREAMS(FIXED_FRAME_STREAMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, FIXED_FRAME_STREAMS)
        return this
    def add_VARIABLE_FRAME_STREAMS(VARIABLE_FRAME_STREAMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, VARIABLE_FRAME_STREAMS)
        return this
    def add_CUSTOM_STREAMS(CUSTOM_STREAMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CUSTOM_STREAMS)
        return this
    def end():
        return b_.EndObject()

def StreamSetStartFIXED_FRAME_STREAMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StreamSetCreateFIXED_FRAME_STREAMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StreamSetStartVARIABLE_FRAME_STREAMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StreamSetCreateVARIABLE_FRAME_STREAMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StreamSetStartCUSTOM_STREAMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StreamSetCreateCUSTOM_STREAMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Service definition
class Service : flatbuffers.handle
    /// Service name
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Container references provided by this service
    def CONTAINER_REFS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 4)
    def CONTAINER_REFS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Command references accepted by this service
    def COMMAND_REFS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 12) + i * 4)
    def COMMAND_REFS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsService(buf:string): return Service { buf, flatbuffers.indirect(buf, 0) }

struct ServiceBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_CONTAINER_REFS(CONTAINER_REFS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CONTAINER_REFS)
        return this
    def add_COMMAND_REFS(COMMAND_REFS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COMMAND_REFS)
        return this
    def end():
        return b_.EndObject()

def ServiceStartCONTAINER_REFSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ServiceCreateCONTAINER_REFSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ServiceStartCOMMAND_REFSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ServiceCreateCOMMAND_REFSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Collection of services
class ServiceSet : flatbuffers.handle
    /// Services
    def SERVICES(i:int) -> Service:
        return Service { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def SERVICES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsServiceSet(buf:string): return ServiceSet { buf, flatbuffers.indirect(buf, 0) }

struct ServiceSetBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_SERVICES(SERVICES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, SERVICES)
        return this
    def end():
        return b_.EndObject()

def ServiceSetStartSERVICESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ServiceSetCreateSERVICESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Document header information
class XTCHeader : flatbuffers.handle
    /// Version of this XTCE document
    def VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Date of document creation (ISO 8601)
    def DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Classification level
    def CLASSIFICATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Validation status
    def VALIDATION_STATUS() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Author information
    def AUTHOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Notes/comments
    def NOTES(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 4)
    def NOTES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)

def GetRootAsXTCHeader(buf:string): return XTCHeader { buf, flatbuffers.indirect(buf, 0) }

struct XTCHeaderBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_VERSION(VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, VERSION)
        return this
    def add_DATE(DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, DATE)
        return this
    def add_CLASSIFICATION(CLASSIFICATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CLASSIFICATION)
        return this
    def add_VALIDATION_STATUS(VALIDATION_STATUS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, VALIDATION_STATUS)
        return this
    def add_AUTHOR(AUTHOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, AUTHOR)
        return this
    def add_NOTES(NOTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, NOTES)
        return this
    def end():
        return b_.EndObject()

def XTCHeaderStartNOTESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def XTCHeaderCreateNOTESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Telemetry metadata collection
class TelemetryMetaData : flatbuffers.handle
    /// Parameter type definitions
    def PARAMETER_TYPE_SET() -> ParameterTypeSet?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: ParameterTypeSet { buf_, o } else: nil
    /// Parameter definitions
    def PARAMETER_SET() -> ParameterSet?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: ParameterSet { buf_, o } else: nil
    /// Container definitions
    def CONTAINER_SET() -> ContainerSet?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: ContainerSet { buf_, o } else: nil
    /// Algorithm definitions
    def ALGORITHM_SET() -> AlgorithmSet?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: AlgorithmSet { buf_, o } else: nil
    /// Stream definitions
    def STREAM_SET() -> StreamSet?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: StreamSet { buf_, o } else: nil

def GetRootAsTelemetryMetaData(buf:string): return TelemetryMetaData { buf, flatbuffers.indirect(buf, 0) }

struct TelemetryMetaDataBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_PARAMETER_TYPE_SET(PARAMETER_TYPE_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, PARAMETER_TYPE_SET)
        return this
    def add_PARAMETER_SET(PARAMETER_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PARAMETER_SET)
        return this
    def add_CONTAINER_SET(CONTAINER_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, CONTAINER_SET)
        return this
    def add_ALGORITHM_SET(ALGORITHM_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ALGORITHM_SET)
        return this
    def add_STREAM_SET(STREAM_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, STREAM_SET)
        return this
    def end():
        return b_.EndObject()

/// Command metadata collection
class CommandMetaData : flatbuffers.handle
    /// Argument type definitions
    def ARGUMENT_TYPE_SET() -> ArgumentTypeSet?:
        let o = flatbuffers.field_table(buf_, pos_, 4)
        return if o: ArgumentTypeSet { buf_, o } else: nil
    /// Parameter types used by commands
    def PARAMETER_TYPE_SET() -> ParameterTypeSet?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: ParameterTypeSet { buf_, o } else: nil
    /// Parameters used by commands
    def PARAMETER_SET() -> ParameterSet?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: ParameterSet { buf_, o } else: nil
    /// MetaCommand definitions
    def META_COMMAND_SET() -> MetaCommandSet?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: MetaCommandSet { buf_, o } else: nil
    /// Command container set
    def COMMAND_CONTAINER_SET() -> ContainerSet?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: ContainerSet { buf_, o } else: nil
    /// Algorithm definitions
    def ALGORITHM_SET() -> AlgorithmSet?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: AlgorithmSet { buf_, o } else: nil
    /// Stream definitions
    def STREAM_SET() -> StreamSet?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: StreamSet { buf_, o } else: nil

def GetRootAsCommandMetaData(buf:string): return CommandMetaData { buf, flatbuffers.indirect(buf, 0) }

struct CommandMetaDataBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(7)
        return this
    def add_ARGUMENT_TYPE_SET(ARGUMENT_TYPE_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ARGUMENT_TYPE_SET)
        return this
    def add_PARAMETER_TYPE_SET(PARAMETER_TYPE_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PARAMETER_TYPE_SET)
        return this
    def add_PARAMETER_SET(PARAMETER_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PARAMETER_SET)
        return this
    def add_META_COMMAND_SET(META_COMMAND_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, META_COMMAND_SET)
        return this
    def add_COMMAND_CONTAINER_SET(COMMAND_CONTAINER_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, COMMAND_CONTAINER_SET)
        return this
    def add_ALGORITHM_SET(ALGORITHM_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, ALGORITHM_SET)
        return this
    def add_STREAM_SET(STREAM_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, STREAM_SET)
        return this
    def end():
        return b_.EndObject()

/// SpaceSystem - Root element for XTCE document
/// A SpaceSystem defines the telemetry and command configuration for a space
/// vehicle or subsystem. SpaceSystems can be nested hierarchically to represent
/// the structure of a spacecraft (e.g., spacecraft -> subsystem -> payload).
class XTC : flatbuffers.handle
    /// Name of this space system
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Short description
    def SHORT_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Long description
    def LONG_DESCRIPTION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Operational status
    def OPERATIONAL_STATUS() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Document header
    def HEADER() -> XTCHeader?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: XTCHeader { buf_, o } else: nil
    /// Telemetry metadata
    def TELEMETRY_META_DATA() -> TelemetryMetaData?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: TelemetryMetaData { buf_, o } else: nil
    /// Command metadata
    def COMMAND_META_DATA() -> CommandMetaData?:
        let o = flatbuffers.field_table(buf_, pos_, 16)
        return if o: CommandMetaData { buf_, o } else: nil
    /// Service definitions
    def SERVICE_SET() -> ServiceSet?:
        let o = flatbuffers.field_table(buf_, pos_, 18)
        return if o: ServiceSet { buf_, o } else: nil
    /// Child space systems (hierarchical structure)
    def CHILD_SYSTEMS(i:int) -> XTC:
        return XTC { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 20) + i * 4) }
    def CHILD_SYSTEMS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)

def GetRootAsXTC(buf:string): return XTC { buf, flatbuffers.indirect(buf, 0) }

struct XTCBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(9)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_SHORT_DESCRIPTION(SHORT_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, SHORT_DESCRIPTION)
        return this
    def add_LONG_DESCRIPTION(LONG_DESCRIPTION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, LONG_DESCRIPTION)
        return this
    def add_OPERATIONAL_STATUS(OPERATIONAL_STATUS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OPERATIONAL_STATUS)
        return this
    def add_HEADER(HEADER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, HEADER)
        return this
    def add_TELEMETRY_META_DATA(TELEMETRY_META_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, TELEMETRY_META_DATA)
        return this
    def add_COMMAND_META_DATA(COMMAND_META_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, COMMAND_META_DATA)
        return this
    def add_SERVICE_SET(SERVICE_SET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, SERVICE_SET)
        return this
    def add_CHILD_SYSTEMS(CHILD_SYSTEMS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, CHILD_SYSTEMS)
        return this
    def end():
        return b_.EndObject()

def XTCStartCHILD_SYSTEMSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def XTCCreateCHILD_SYSTEMSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

