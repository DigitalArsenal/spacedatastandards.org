// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class MPE

/// Minimum Propagatable Element Set
class MPE : flatbuffers.handle
    /// Unique ID as a String [no units]
    def ENTITY_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Epoch of Mean Keplerian elements (UNIX timestamp) [numeric seconds since 1970-01-01T00:00:00 UTC]
    def EPOCH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Mean motion in rev/day [M if chosen to represent orbit size for SGP/SGP4 elements]
    def MEAN_MOTION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Eccentricity (unitless)
    def ECCENTRICITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Inclination in degrees
    def INCLINATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Right ascension of ascending node in degrees
    def RA_OF_ASC_NODE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Argument of pericenter in degrees
    def ARG_OF_PERICENTER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Mean anomaly in degrees
    def MEAN_ANOMALY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// SGP/SGP4 drag-like coefficient (BSTAR) in units of 1/[Earth radii]
    def BSTAR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Description of the Mean Element Theory (SGP4, DSST, USM)
    def MEAN_ELEMENT_THEORY() -> meanElementTheory:
        return meanElementTheory(flatbuffers.field_int8(buf_, pos_, 22, 0))

def GetRootAsMPE(buf:string): return MPE { buf, flatbuffers.indirect(buf, 0) }

struct MPEBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_ENTITY_ID(ENTITY_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ENTITY_ID)
        return this
    def add_EPOCH(EPOCH:float):
        b_.PrependFloat64Slot(1, EPOCH, 0.0)
        return this
    def add_MEAN_MOTION(MEAN_MOTION:float):
        b_.PrependFloat64Slot(2, MEAN_MOTION, 0.0)
        return this
    def add_ECCENTRICITY(ECCENTRICITY:float):
        b_.PrependFloat64Slot(3, ECCENTRICITY, 0.0)
        return this
    def add_INCLINATION(INCLINATION:float):
        b_.PrependFloat64Slot(4, INCLINATION, 0.0)
        return this
    def add_RA_OF_ASC_NODE(RA_OF_ASC_NODE:float):
        b_.PrependFloat64Slot(5, RA_OF_ASC_NODE, 0.0)
        return this
    def add_ARG_OF_PERICENTER(ARG_OF_PERICENTER:float):
        b_.PrependFloat64Slot(6, ARG_OF_PERICENTER, 0.0)
        return this
    def add_MEAN_ANOMALY(MEAN_ANOMALY:float):
        b_.PrependFloat64Slot(7, MEAN_ANOMALY, 0.0)
        return this
    def add_BSTAR(BSTAR:float):
        b_.PrependFloat64Slot(8, BSTAR, 0.0)
        return this
    def add_MEAN_ELEMENT_THEORY(MEAN_ELEMENT_THEORY:meanElementTheory):
        b_.PrependInt8Slot(9, MEAN_ELEMENT_THEORY, 0)
        return this
    def end():
        return b_.EndObject()

