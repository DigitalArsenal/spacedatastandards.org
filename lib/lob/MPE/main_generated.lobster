// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class MPE

class MPECOLLECTION

/// Minimum Propagatable Element Set
class MPE : flatbuffers.handle
    /// Unique ID as a String
    def ENTITY_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Epoch of Mean Keplerian elements. (UNIX TimeStamp)
    def EPOCH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Semi-major axis in km or mean motion in rev/day
    def MEAN_MOTION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Eccentricity
    def ECCENTRICITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Inclination
    def INCLINATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Right ascension of ascending node
    def RA_OF_ASC_NODE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Argument of pericenter
    def ARG_OF_PERICENTER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Mean anomaly
    def MEAN_ANOMALY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
    def BSTAR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Description of the Mean Element Theory. (SGP4,DSST,USM)
    def MEAN_ELEMENT_THEORY() -> meanElementTheory:
        return meanElementTheory(flatbuffers.field_int8(buf_, pos_, 22, 0))

def GetRootAsMPE(buf:string): return MPE { buf, flatbuffers.indirect(buf, 0) }

struct MPEBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(10)
        return this
    def add_ENTITY_ID(ENTITY_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ENTITY_ID)
        return this
    def add_EPOCH(EPOCH:float):
        b_.PrependFloat64Slot(1, EPOCH, 0.0)
        return this
    def add_MEAN_MOTION(MEAN_MOTION:float):
        b_.PrependFloat64Slot(2, MEAN_MOTION, 0.0)
        return this
    def add_ECCENTRICITY(ECCENTRICITY:float):
        b_.PrependFloat64Slot(3, ECCENTRICITY, 0.0)
        return this
    def add_INCLINATION(INCLINATION:float):
        b_.PrependFloat64Slot(4, INCLINATION, 0.0)
        return this
    def add_RA_OF_ASC_NODE(RA_OF_ASC_NODE:float):
        b_.PrependFloat64Slot(5, RA_OF_ASC_NODE, 0.0)
        return this
    def add_ARG_OF_PERICENTER(ARG_OF_PERICENTER:float):
        b_.PrependFloat64Slot(6, ARG_OF_PERICENTER, 0.0)
        return this
    def add_MEAN_ANOMALY(MEAN_ANOMALY:float):
        b_.PrependFloat64Slot(7, MEAN_ANOMALY, 0.0)
        return this
    def add_BSTAR(BSTAR:float):
        b_.PrependFloat64Slot(8, BSTAR, 0.0)
        return this
    def add_MEAN_ELEMENT_THEORY(MEAN_ELEMENT_THEORY:meanElementTheory):
        b_.PrependInt8Slot(9, MEAN_ELEMENT_THEORY, 0)
        return this
    def end():
        return b_.EndObject()

class MPECOLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> MPE:
        return MPE { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsMPECOLLECTION(buf:string): return MPECOLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct MPECOLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def MPECOLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MPECOLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

