// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum attitudeStateType:
    attitudeStateType_QUATERNION = 0
    attitudeStateType_EULER_ANGLES = 1
    attitudeStateType_SPIN = 2
    attitudeStateType_DIRECTION_COSINE = 3

enum attCovType:
    attCovType_ANGLE = 0
    attCovType_ANGLE_GYROBIAS = 1
    attCovType_ANGLE_ANGVEL = 2
    attCovType_QUATERNION_COV = 3

enum maneuverableFlag:
    maneuverableFlag_YES = 0
    maneuverableFlag_NO = 1
    maneuverableFlag_UNKNOWN = 2

class attitudeState

class attPhysicalProperties

class attCovariance

class attManeuver

class ACM

/// Attitude State Data
class attitudeState : flatbuffers.handle
    /// Attitude state type
    def ATT_TYPE() -> attitudeStateType:
        return attitudeStateType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Reference frame A
    def REF_FRAME_A() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Reference frame B
    def REF_FRAME_B() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Attitude direction (A2B or B2A)
    def ATT_DIR() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Epoch (ISO 8601)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Quaternion scalar component (q0 or qc)
    def Q1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Quaternion vector component i
    def Q2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Quaternion vector component j
    def Q3() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Quaternion vector component k
    def QC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Euler angle X in degrees
    def ANGLE_1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Euler angle Y in degrees
    def ANGLE_2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Euler angle Z in degrees
    def ANGLE_3() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Euler rotation sequence (e.g., 321, 313)
    def EULER_ROT_SEQ() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Angular velocity X in deg/s
    def ANGVEL_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Angular velocity Y in deg/s
    def ANGVEL_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Angular velocity Z in deg/s
    def ANGVEL_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Spin alpha in degrees
    def SPIN_ALPHA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Spin delta in degrees
    def SPIN_DELTA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Spin angle in degrees
    def SPIN_ANGLE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Spin angle velocity in deg/s
    def SPIN_ANGLE_VEL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Nutation angle in degrees
    def NUTATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Nutation period in seconds
    def NUTATION_PERIOD() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)
    /// Nutation phase in degrees
    def NUTATION_PHASE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)

def GetRootAsattitudeState(buf:string): return attitudeState { buf, flatbuffers.indirect(buf, 0) }

struct attitudeStateBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(23)
        return this
    def add_ATT_TYPE(ATT_TYPE:attitudeStateType):
        b_.PrependInt8Slot(0, ATT_TYPE, 0)
        return this
    def add_REF_FRAME_A(REF_FRAME_A:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, REF_FRAME_A)
        return this
    def add_REF_FRAME_B(REF_FRAME_B:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, REF_FRAME_B)
        return this
    def add_ATT_DIR(ATT_DIR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ATT_DIR)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, EPOCH)
        return this
    def add_Q1(Q1:float):
        b_.PrependFloat64Slot(5, Q1, 0.0)
        return this
    def add_Q2(Q2:float):
        b_.PrependFloat64Slot(6, Q2, 0.0)
        return this
    def add_Q3(Q3:float):
        b_.PrependFloat64Slot(7, Q3, 0.0)
        return this
    def add_QC(QC:float):
        b_.PrependFloat64Slot(8, QC, 0.0)
        return this
    def add_ANGLE_1(ANGLE_1:float):
        b_.PrependFloat64Slot(9, ANGLE_1, 0.0)
        return this
    def add_ANGLE_2(ANGLE_2:float):
        b_.PrependFloat64Slot(10, ANGLE_2, 0.0)
        return this
    def add_ANGLE_3(ANGLE_3:float):
        b_.PrependFloat64Slot(11, ANGLE_3, 0.0)
        return this
    def add_EULER_ROT_SEQ(EULER_ROT_SEQ:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, EULER_ROT_SEQ)
        return this
    def add_ANGVEL_X(ANGVEL_X:float):
        b_.PrependFloat64Slot(13, ANGVEL_X, 0.0)
        return this
    def add_ANGVEL_Y(ANGVEL_Y:float):
        b_.PrependFloat64Slot(14, ANGVEL_Y, 0.0)
        return this
    def add_ANGVEL_Z(ANGVEL_Z:float):
        b_.PrependFloat64Slot(15, ANGVEL_Z, 0.0)
        return this
    def add_SPIN_ALPHA(SPIN_ALPHA:float):
        b_.PrependFloat64Slot(16, SPIN_ALPHA, 0.0)
        return this
    def add_SPIN_DELTA(SPIN_DELTA:float):
        b_.PrependFloat64Slot(17, SPIN_DELTA, 0.0)
        return this
    def add_SPIN_ANGLE(SPIN_ANGLE:float):
        b_.PrependFloat64Slot(18, SPIN_ANGLE, 0.0)
        return this
    def add_SPIN_ANGLE_VEL(SPIN_ANGLE_VEL:float):
        b_.PrependFloat64Slot(19, SPIN_ANGLE_VEL, 0.0)
        return this
    def add_NUTATION(NUTATION:float):
        b_.PrependFloat64Slot(20, NUTATION, 0.0)
        return this
    def add_NUTATION_PERIOD(NUTATION_PERIOD:float):
        b_.PrependFloat64Slot(21, NUTATION_PERIOD, 0.0)
        return this
    def add_NUTATION_PHASE(NUTATION_PHASE:float):
        b_.PrependFloat64Slot(22, NUTATION_PHASE, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Attitude Physical Characteristics
class attPhysicalProperties : flatbuffers.handle
    /// Drag coefficient
    def DRAG_COEFF() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Wet mass in kg
    def WET_MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Dry mass in kg
    def DRY_MASS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Center of pressure reference frame
    def CP_REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Center of pressure X in m
    def CP_X() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Center of pressure Y in m
    def CP_Y() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Center of pressure Z in m
    def CP_Z() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Inertia reference frame
    def INERTIA_REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Moment of inertia about X axis in kg*m^2
    def IXX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Moment of inertia about Y axis in kg*m^2
    def IYY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Moment of inertia about Z axis in kg*m^2
    def IZZ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Product of inertia XY in kg*m^2
    def IXY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Product of inertia XZ in kg*m^2
    def IXZ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Product of inertia YZ in kg*m^2
    def IYZ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)

def GetRootAsattPhysicalProperties(buf:string): return attPhysicalProperties { buf, flatbuffers.indirect(buf, 0) }

struct attPhysicalPropertiesBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(14)
        return this
    def add_DRAG_COEFF(DRAG_COEFF:float):
        b_.PrependFloat64Slot(0, DRAG_COEFF, 0.0)
        return this
    def add_WET_MASS(WET_MASS:float):
        b_.PrependFloat64Slot(1, WET_MASS, 0.0)
        return this
    def add_DRY_MASS(DRY_MASS:float):
        b_.PrependFloat64Slot(2, DRY_MASS, 0.0)
        return this
    def add_CP_REF_FRAME(CP_REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, CP_REF_FRAME)
        return this
    def add_CP_X(CP_X:float):
        b_.PrependFloat64Slot(4, CP_X, 0.0)
        return this
    def add_CP_Y(CP_Y:float):
        b_.PrependFloat64Slot(5, CP_Y, 0.0)
        return this
    def add_CP_Z(CP_Z:float):
        b_.PrependFloat64Slot(6, CP_Z, 0.0)
        return this
    def add_INERTIA_REF_FRAME(INERTIA_REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, INERTIA_REF_FRAME)
        return this
    def add_IXX(IXX:float):
        b_.PrependFloat64Slot(8, IXX, 0.0)
        return this
    def add_IYY(IYY:float):
        b_.PrependFloat64Slot(9, IYY, 0.0)
        return this
    def add_IZZ(IZZ:float):
        b_.PrependFloat64Slot(10, IZZ, 0.0)
        return this
    def add_IXY(IXY:float):
        b_.PrependFloat64Slot(11, IXY, 0.0)
        return this
    def add_IXZ(IXZ:float):
        b_.PrependFloat64Slot(12, IXZ, 0.0)
        return this
    def add_IYZ(IYZ:float):
        b_.PrependFloat64Slot(13, IYZ, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Attitude Covariance
class attCovariance : flatbuffers.handle
    /// Covariance type
    def COV_TYPE() -> attCovType:
        return attCovType(flatbuffers.field_int8(buf_, pos_, 4, 0))
    /// Reference frame
    def COV_REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Epoch (ISO 8601)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Upper-triangular covariance matrix elements (row-major)
    def COV(i:int) -> float:
        return read_float64_le(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 8)
    def COV_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)

def GetRootAsattCovariance(buf:string): return attCovariance { buf, flatbuffers.indirect(buf, 0) }

struct attCovarianceBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_COV_TYPE(COV_TYPE:attCovType):
        b_.PrependInt8Slot(0, COV_TYPE, 0)
        return this
    def add_COV_REF_FRAME(COV_REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, COV_REF_FRAME)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, EPOCH)
        return this
    def add_COV(COV:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, COV)
        return this
    def end():
        return b_.EndObject()

def attCovarianceStartCOVVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(8, n_, 8)
def attCovarianceCreateCOVVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    return b_.EndVector(v_.length)

/// Attitude Maneuver
class attManeuver : flatbuffers.handle
    /// Maneuver epoch start (ISO 8601)
    def MAN_EPOCH_START() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Duration in seconds
    def DURATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Reference frame
    def REF_FRAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Torque about body X in N*m
    def TOR_1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Torque about body Y in N*m
    def TOR_2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Torque about body Z in N*m
    def TOR_3() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)

def GetRootAsattManeuver(buf:string): return attManeuver { buf, flatbuffers.indirect(buf, 0) }

struct attManeuverBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_MAN_EPOCH_START(MAN_EPOCH_START:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, MAN_EPOCH_START)
        return this
    def add_DURATION(DURATION:float):
        b_.PrependFloat64Slot(1, DURATION, 0.0)
        return this
    def add_REF_FRAME(REF_FRAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, REF_FRAME)
        return this
    def add_TOR_1(TOR_1:float):
        b_.PrependFloat64Slot(3, TOR_1, 0.0)
        return this
    def add_TOR_2(TOR_2:float):
        b_.PrependFloat64Slot(4, TOR_2, 0.0)
        return this
    def add_TOR_3(TOR_3:float):
        b_.PrependFloat64Slot(5, TOR_3, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Attitude Comprehensive Message
class ACM : flatbuffers.handle
    /// CCSDS ACM version
    def CCSDS_ACM_VERS() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Message creation date (ISO 8601)
    def CREATION_DATE() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Creating organization
    def ORIGINATOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Object name
    def OBJECT_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// International designator
    def OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Catalog name
    def CATALOG_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Epoch of state (ISO 8601)
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Time system
    def TIME_SYSTEM() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Attitude states
    def ATT_STATES(i:int) -> attitudeState:
        return attitudeState { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 20) + i * 4) }
    def ATT_STATES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// Physical properties
    def PHYS_PROPERTIES() -> attPhysicalProperties?:
        let o = flatbuffers.field_table(buf_, pos_, 22)
        return if o: attPhysicalProperties { buf_, o } else: nil
    /// Attitude covariance data
    def COV_DATA(i:int) -> attCovariance:
        return attCovariance { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 24) + i * 4) }
    def COV_DATA_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)
    /// Attitude maneuvers
    def MANEUVERS(i:int) -> attManeuver:
        return attManeuver { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 26) + i * 4) }
    def MANEUVERS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    /// Maneuverability status
    def MANEUVERABLE() -> maneuverableFlag:
        return maneuverableFlag(flatbuffers.field_int8(buf_, pos_, 28, 0))
    /// Additional comments
    def COMMENT() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)

def GetRootAsACM(buf:string): return ACM { buf, flatbuffers.indirect(buf, 0) }

struct ACMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(14)
        return this
    def add_CCSDS_ACM_VERS(CCSDS_ACM_VERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CCSDS_ACM_VERS)
        return this
    def add_CREATION_DATE(CREATION_DATE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CREATION_DATE)
        return this
    def add_ORIGINATOR(ORIGINATOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ORIGINATOR)
        return this
    def add_OBJECT_NAME(OBJECT_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, OBJECT_NAME)
        return this
    def add_OBJECT_ID(OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, OBJECT_ID)
        return this
    def add_CATALOG_NAME(CATALOG_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, CATALOG_NAME)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, EPOCH)
        return this
    def add_TIME_SYSTEM(TIME_SYSTEM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, TIME_SYSTEM)
        return this
    def add_ATT_STATES(ATT_STATES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, ATT_STATES)
        return this
    def add_PHYS_PROPERTIES(PHYS_PROPERTIES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, PHYS_PROPERTIES)
        return this
    def add_COV_DATA(COV_DATA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, COV_DATA)
        return this
    def add_MANEUVERS(MANEUVERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, MANEUVERS)
        return this
    def add_MANEUVERABLE(MANEUVERABLE:maneuverableFlag):
        b_.PrependInt8Slot(12, MANEUVERABLE, 0)
        return this
    def add_COMMENT(COMMENT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, COMMENT)
        return this
    def end():
        return b_.EndObject()

def ACMStartATT_STATESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ACMCreateATT_STATESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ACMStartCOV_DATAVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ACMCreateCOV_DATAVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def ACMStartMANEUVERSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def ACMCreateMANEUVERSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

