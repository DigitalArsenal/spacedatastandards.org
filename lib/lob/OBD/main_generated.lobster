// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum odMethod:
    odMethod_BATCH_LEAST_SQUARES = 0
    odMethod_SEQUENTIAL_LEAST_SQUARES = 1
    odMethod_EXTENDED_KALMAN = 2
    odMethod_UNSCENTED_KALMAN = 3
    odMethod_SPECIAL_PERTURBATIONS = 4
    odMethod_GENERAL_PERTURBATIONS = 5
    odMethod_DIFFERENTIAL_CORRECTION = 6
    odMethod_UNKNOWN = 7

class odSensorContribution

class OBD

/// Sensor contribution to an orbit determination solution
class odSensorContribution : flatbuffers.handle
    /// Sensor identifier
    def SENSOR_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Original sensor identifier
    def ORIG_SENSOR_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Number of accepted observations from this sensor
    def NUM_ACCEPTED() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 8, 0)
    /// Number of rejected observations from this sensor
    def NUM_REJECTED() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 10, 0)
    /// Weighted RMS for this sensor's observations
    def WRMS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Observation types from this sensor
    def OB_TYPES(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 4)
    def OB_TYPES_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)

def GetRootAsodSensorContribution(buf:string): return odSensorContribution { buf, flatbuffers.indirect(buf, 0) }

struct odSensorContributionBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_SENSOR_ID(SENSOR_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, SENSOR_ID)
        return this
    def add_ORIG_SENSOR_ID(ORIG_SENSOR_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, ORIG_SENSOR_ID)
        return this
    def add_NUM_ACCEPTED(NUM_ACCEPTED:int):
        b_.PrependUint32Slot(2, NUM_ACCEPTED, 0)
        return this
    def add_NUM_REJECTED(NUM_REJECTED:int):
        b_.PrependUint32Slot(3, NUM_REJECTED, 0)
        return this
    def add_WRMS(WRMS:float):
        b_.PrependFloat64Slot(4, WRMS, 0.0)
        return this
    def add_OB_TYPES(OB_TYPES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, OB_TYPES)
        return this
    def end():
        return b_.EndObject()

def odSensorContributionStartOB_TYPESVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def odSensorContributionCreateOB_TYPESVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Orbit Determination Results
class OBD : flatbuffers.handle
    /// Unique identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Satellite catalog number
    def SAT_NO() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 6, 0)
    /// International designator
    def ORIG_OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// On-orbit reference
    def ON_ORBIT() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// OD fit start time (ISO 8601)
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// OD fit end time (ISO 8601)
    def END_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// OD method used
    def METHOD() -> odMethod:
        return odMethod(flatbuffers.field_int8(buf_, pos_, 16, 0))
    /// Method source or software
    def METHOD_SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// True if this is an initial orbit determination
    def INITIAL_OD() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// A priori element set identifier
    def APRIORI_ID_ELSET() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// A priori element set data reference
    def APRIORI_ELSET() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// A priori state vector identifier
    def APRIORI_ID_STATE_VECTOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// A priori state vector data reference
    def APRIORI_STATE_VECTOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Start of last observation arc (ISO 8601)
    def LAST_OB_START() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// End of last observation arc (ISO 8601)
    def LAST_OB_END() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// Observation time span (days)
    def TIME_SPAN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Fit span in days
    def FIT_SPAN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Solution effective from (ISO 8601)
    def EFFECTIVE_FROM() -> string:
        return flatbuffers.field_string(buf_, pos_, 38)
    /// Solution effective until (ISO 8601)
    def EFFECTIVE_UNTIL() -> string:
        return flatbuffers.field_string(buf_, pos_, 40)
    /// Weighted RMS of residuals
    def WRMS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Previous solution WRMS
    def PREVIOUS_WRMS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// First pass WRMS
    def FIRST_PASS_WRMS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)
    /// Best pass WRMS
    def BEST_PASS_WRMS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)
    /// Error growth rate (km/day)
    def ERROR_GROWTH_RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 50, 0.0)
    /// Energy dissipation rate
    def EDR() -> float:
        return flatbuffers.field_float64(buf_, pos_, 52, 0.0)
    /// True if ballistic coefficient was estimated
    def BALLISTIC_COEFF_EST() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 54, 0))
    /// Ballistic coefficient model
    def BALLISTIC_COEFF_MODEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 56)
    /// True if area-to-mass ratio was estimated
    def AGOM_EST() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 58, 0))
    /// Area-to-mass ratio model
    def AGOM_MODEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 60)
    /// RMS convergence criteria
    def RMS_CONVERGENCE_CRITERIA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 62, 0.0)
    /// Number of iterations to converge
    def NUM_ITERATIONS() -> int:
        return flatbuffers.field_uint16(buf_, pos_, 64, 0)
    /// Total accepted observations
    def NUM_ACCEPTED_OBS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 66, 0)
    /// Total rejected observations
    def NUM_REJECTED_OBS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 68, 0)
    /// Sensor contributions to this solution
    def SENSORS(i:int) -> odSensorContribution:
        return odSensorContribution { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 70) + i * 4) }
    def SENSORS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 70)
    /// Accepted observation types
    def ACCEPTED_OB_TYPS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 72) + i * 4)
    def ACCEPTED_OB_TYPS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 72)
    /// Accepted observation identifiers
    def ACCEPTED_OB_IDS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 74) + i * 4)
    def ACCEPTED_OB_IDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 74)
    /// Rejected observation types
    def REJECTED_OB_TYPS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 76) + i * 4)
    def REJECTED_OB_TYPS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 76)
    /// Rejected observation identifiers
    def REJECTED_OB_IDS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 78) + i * 4)
    def REJECTED_OB_IDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 78)

def GetRootAsOBD(buf:string): return OBD { buf, flatbuffers.indirect(buf, 0) }

struct OBDBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(38)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_SAT_NO(SAT_NO:int):
        b_.PrependUint32Slot(1, SAT_NO, 0)
        return this
    def add_ORIG_OBJECT_ID(ORIG_OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ORIG_OBJECT_ID)
        return this
    def add_ON_ORBIT(ON_ORBIT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ON_ORBIT)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, START_TIME)
        return this
    def add_END_TIME(END_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, END_TIME)
        return this
    def add_METHOD(METHOD:odMethod):
        b_.PrependInt8Slot(6, METHOD, 0)
        return this
    def add_METHOD_SOURCE(METHOD_SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, METHOD_SOURCE)
        return this
    def add_INITIAL_OD(INITIAL_OD:bool):
        b_.PrependBoolSlot(8, INITIAL_OD, 0)
        return this
    def add_APRIORI_ID_ELSET(APRIORI_ID_ELSET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, APRIORI_ID_ELSET)
        return this
    def add_APRIORI_ELSET(APRIORI_ELSET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, APRIORI_ELSET)
        return this
    def add_APRIORI_ID_STATE_VECTOR(APRIORI_ID_STATE_VECTOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, APRIORI_ID_STATE_VECTOR)
        return this
    def add_APRIORI_STATE_VECTOR(APRIORI_STATE_VECTOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, APRIORI_STATE_VECTOR)
        return this
    def add_LAST_OB_START(LAST_OB_START:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, LAST_OB_START)
        return this
    def add_LAST_OB_END(LAST_OB_END:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, LAST_OB_END)
        return this
    def add_TIME_SPAN(TIME_SPAN:float):
        b_.PrependFloat64Slot(15, TIME_SPAN, 0.0)
        return this
    def add_FIT_SPAN(FIT_SPAN:float):
        b_.PrependFloat64Slot(16, FIT_SPAN, 0.0)
        return this
    def add_EFFECTIVE_FROM(EFFECTIVE_FROM:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, EFFECTIVE_FROM)
        return this
    def add_EFFECTIVE_UNTIL(EFFECTIVE_UNTIL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, EFFECTIVE_UNTIL)
        return this
    def add_WRMS(WRMS:float):
        b_.PrependFloat64Slot(19, WRMS, 0.0)
        return this
    def add_PREVIOUS_WRMS(PREVIOUS_WRMS:float):
        b_.PrependFloat64Slot(20, PREVIOUS_WRMS, 0.0)
        return this
    def add_FIRST_PASS_WRMS(FIRST_PASS_WRMS:float):
        b_.PrependFloat64Slot(21, FIRST_PASS_WRMS, 0.0)
        return this
    def add_BEST_PASS_WRMS(BEST_PASS_WRMS:float):
        b_.PrependFloat64Slot(22, BEST_PASS_WRMS, 0.0)
        return this
    def add_ERROR_GROWTH_RATE(ERROR_GROWTH_RATE:float):
        b_.PrependFloat64Slot(23, ERROR_GROWTH_RATE, 0.0)
        return this
    def add_EDR(EDR:float):
        b_.PrependFloat64Slot(24, EDR, 0.0)
        return this
    def add_BALLISTIC_COEFF_EST(BALLISTIC_COEFF_EST:bool):
        b_.PrependBoolSlot(25, BALLISTIC_COEFF_EST, 0)
        return this
    def add_BALLISTIC_COEFF_MODEL(BALLISTIC_COEFF_MODEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(26, BALLISTIC_COEFF_MODEL)
        return this
    def add_AGOM_EST(AGOM_EST:bool):
        b_.PrependBoolSlot(27, AGOM_EST, 0)
        return this
    def add_AGOM_MODEL(AGOM_MODEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(28, AGOM_MODEL)
        return this
    def add_RMS_CONVERGENCE_CRITERIA(RMS_CONVERGENCE_CRITERIA:float):
        b_.PrependFloat64Slot(29, RMS_CONVERGENCE_CRITERIA, 0.0)
        return this
    def add_NUM_ITERATIONS(NUM_ITERATIONS:int):
        b_.PrependUint16Slot(30, NUM_ITERATIONS, 0)
        return this
    def add_NUM_ACCEPTED_OBS(NUM_ACCEPTED_OBS:int):
        b_.PrependUint32Slot(31, NUM_ACCEPTED_OBS, 0)
        return this
    def add_NUM_REJECTED_OBS(NUM_REJECTED_OBS:int):
        b_.PrependUint32Slot(32, NUM_REJECTED_OBS, 0)
        return this
    def add_SENSORS(SENSORS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, SENSORS)
        return this
    def add_ACCEPTED_OB_TYPS(ACCEPTED_OB_TYPS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(34, ACCEPTED_OB_TYPS)
        return this
    def add_ACCEPTED_OB_IDS(ACCEPTED_OB_IDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, ACCEPTED_OB_IDS)
        return this
    def add_REJECTED_OB_TYPS(REJECTED_OB_TYPS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(36, REJECTED_OB_TYPS)
        return this
    def add_REJECTED_OB_IDS(REJECTED_OB_IDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(37, REJECTED_OB_IDS)
        return this
    def end():
        return b_.EndObject()

def OBDStartSENSORSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OBDCreateSENSORSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OBDStartACCEPTED_OB_TYPSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OBDCreateACCEPTED_OB_TYPSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OBDStartACCEPTED_OB_IDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OBDCreateACCEPTED_OB_IDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OBDStartREJECTED_OB_TYPSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OBDCreateREJECTED_OB_TYPSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OBDStartREJECTED_OB_IDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OBDCreateREJECTED_OB_IDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

