// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// License type for plugin access
enum licenseType:
    /// Evaluation/trial license
    licenseType_Trial = 0
    /// Standard commercial license
    licenseType_Commercial = 1
    /// Enterprise site license
    licenseType_Enterprise = 2
    /// Educational/academic license
    licenseType_Educational = 3
    /// Open source project license
    licenseType_OpenSource = 4
    /// Internal OrbPro default plugins
    licenseType_Internal = 5

class PLK

/// Plugin License Key - Issued license for plugin access
/// Uses ECIES: both parties derive symmetric key via X25519 ECDH
/// Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
class PLK : flatbuffers.handle
    /// Unique license key identifier
    def LICENSE_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Plugin ID this license is for
    def PLUGIN_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Plugin version or version range (semver)
    def PLUGIN_VERSION() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Licensee organization name
    def LICENSEE_ORG() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Licensee contact email
    def LICENSEE_EMAIL() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Licensee's SDN Peer ID
    def LICENSEE_PEER_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Licensee's X25519 public key (32 bytes)
    def LICENSEE_PUBKEY(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 16) + i * 1)
    def LICENSEE_PUBKEY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Issuer's X25519 public key (32 bytes)
    /// Used with licensee's private key to derive shared secret via ECDH
    def ISSUER_PUBKEY(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 18) + i * 1)
    def ISSUER_PUBKEY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Domain restrictions (empty = any domain allowed)
    def ALLOWED_DOMAINS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 20) + i * 4)
    def ALLOWED_DOMAINS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// TLD restrictions (e.g., ".gov", ".mil", ".edu")
    def ALLOWED_TLDS(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 22) + i * 4)
    def ALLOWED_TLDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 22)
    /// Type of license
    def LICENSE_TYPE() -> licenseType:
        return licenseType(flatbuffers.field_int8(buf_, pos_, 24, 0))
    /// Maximum concurrent activations (0 = unlimited)
    def MAX_ACTIVATIONS() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 26, 0)
    /// Unix timestamp when license was issued
    def ISSUED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 28, 0)
    /// Unix timestamp when license becomes valid
    def VALID_FROM() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 30, 0)
    /// Unix timestamp when license expires (0 = never expires)
    def EXPIRES_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 32, 0)
    /// Peer ID of the license issuer (OrbPro)
    def ISSUER_PEER_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// Ed25519 signature from issuer over all fields (except SIGNATURE)
    def SIGNATURE(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 36) + i * 1)
    def SIGNATURE_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 36)

def GetRootAsPLK(buf:string): return PLK { buf, flatbuffers.indirect(buf, 0) }

struct PLKBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(17)
        return this
    def add_LICENSE_ID(LICENSE_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, LICENSE_ID)
        return this
    def add_PLUGIN_ID(PLUGIN_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, PLUGIN_ID)
        return this
    def add_PLUGIN_VERSION(PLUGIN_VERSION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, PLUGIN_VERSION)
        return this
    def add_LICENSEE_ORG(LICENSEE_ORG:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, LICENSEE_ORG)
        return this
    def add_LICENSEE_EMAIL(LICENSEE_EMAIL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, LICENSEE_EMAIL)
        return this
    def add_LICENSEE_PEER_ID(LICENSEE_PEER_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, LICENSEE_PEER_ID)
        return this
    def add_LICENSEE_PUBKEY(LICENSEE_PUBKEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, LICENSEE_PUBKEY)
        return this
    def add_ISSUER_PUBKEY(ISSUER_PUBKEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, ISSUER_PUBKEY)
        return this
    def add_ALLOWED_DOMAINS(ALLOWED_DOMAINS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, ALLOWED_DOMAINS)
        return this
    def add_ALLOWED_TLDS(ALLOWED_TLDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, ALLOWED_TLDS)
        return this
    def add_LICENSE_TYPE(LICENSE_TYPE:licenseType):
        b_.PrependInt8Slot(10, LICENSE_TYPE, 0)
        return this
    def add_MAX_ACTIVATIONS(MAX_ACTIVATIONS:int):
        b_.PrependUint32Slot(11, MAX_ACTIVATIONS, 0)
        return this
    def add_ISSUED_AT(ISSUED_AT:int):
        b_.PrependUint64Slot(12, ISSUED_AT, 0)
        return this
    def add_VALID_FROM(VALID_FROM:int):
        b_.PrependUint64Slot(13, VALID_FROM, 0)
        return this
    def add_EXPIRES_AT(EXPIRES_AT:int):
        b_.PrependUint64Slot(14, EXPIRES_AT, 0)
        return this
    def add_ISSUER_PEER_ID(ISSUER_PEER_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, ISSUER_PEER_ID)
        return this
    def add_SIGNATURE(SIGNATURE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, SIGNATURE)
        return this
    def end():
        return b_.EndObject()

def PLKStartLICENSEE_PUBKEYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PLKCreateLICENSEE_PUBKEYVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def PLKStartISSUER_PUBKEYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PLKCreateISSUER_PUBKEYVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def PLKStartALLOWED_DOMAINSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLKCreateALLOWED_DOMAINSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLKStartALLOWED_TLDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def PLKCreateALLOWED_TLDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def PLKStartSIGNATUREVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def PLKCreateSIGNATUREVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

