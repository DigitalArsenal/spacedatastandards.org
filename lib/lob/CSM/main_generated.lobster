// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class CSM

class CSMCOLLECTION

/// Conjunction Summary Message
class CSM : flatbuffers_handle
    /// Satellite name for the first object
    def OBJECT_1() -> CAT?:
        let o = buf_.flatbuffers_field_table(pos_, 4)
        return if o: CAT { buf_, o } else: nil
    /// Days since epoch for the first object
    def DSE_1() -> float:
        return buf_.flatbuffers_field_float64(pos_, 6, 0.0)
    /// Satellite name for the second object
    def OBJECT_2() -> CAT?:
        let o = buf_.flatbuffers_field_table(pos_, 8)
        return if o: CAT { buf_, o } else: nil
    /// Days since epoch for the second object
    def DSE_2() -> float:
        return buf_.flatbuffers_field_float64(pos_, 10, 0.0)
    /// Time of closest approach as a Unix timestamp
    def TCA() -> float:
        return buf_.flatbuffers_field_float64(pos_, 12, 0.0)
    /// The distance or range between the two objects at TCA
    def TCA_RANGE() -> float:
        return buf_.flatbuffers_field_float64(pos_, 14, 0.0)
    /// The magnitude of the relative velocity at TCA
    def TCA_RELATIVE_SPEED() -> float:
        return buf_.flatbuffers_field_float64(pos_, 16, 0.0)
    /// Maximum probability
    def MAX_PROB() -> float:
        return buf_.flatbuffers_field_float64(pos_, 18, 0.0)
    /// Standard deviation that produces the maximum probability
    def DILUTION() -> float:
        return buf_.flatbuffers_field_float64(pos_, 20, 0.0)

def GetRootAsCSM(buf:string): return CSM { buf, buf.flatbuffers_indirect(0) }

struct CSMBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(9)
        return this
    def add_OBJECT_1(OBJECT_1:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, OBJECT_1)
        return this
    def add_DSE_1(DSE_1:float):
        b_.PrependFloat64Slot(1, DSE_1, 0.0)
        return this
    def add_OBJECT_2(OBJECT_2:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(2, OBJECT_2)
        return this
    def add_DSE_2(DSE_2:float):
        b_.PrependFloat64Slot(3, DSE_2, 0.0)
        return this
    def add_TCA(TCA:float):
        b_.PrependFloat64Slot(4, TCA, 0.0)
        return this
    def add_TCA_RANGE(TCA_RANGE:float):
        b_.PrependFloat64Slot(5, TCA_RANGE, 0.0)
        return this
    def add_TCA_RELATIVE_SPEED(TCA_RELATIVE_SPEED:float):
        b_.PrependFloat64Slot(6, TCA_RELATIVE_SPEED, 0.0)
        return this
    def add_MAX_PROB(MAX_PROB:float):
        b_.PrependFloat64Slot(7, MAX_PROB, 0.0)
        return this
    def add_DILUTION(DILUTION:float):
        b_.PrependFloat64Slot(8, DILUTION, 0.0)
        return this
    def end():
        return b_.EndObject()

class CSMCOLLECTION : flatbuffers_handle
    def RECORDS(i:int) -> CSM:
        return CSM { buf_, buf_.flatbuffers_indirect(buf_.flatbuffers_field_vector(pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return buf_.flatbuffers_field_vector_len(pos_, 4)

def GetRootAsCSMCOLLECTION(buf:string): return CSMCOLLECTION { buf, buf.flatbuffers_indirect(0) }

struct CSMCOLLECTIONBuilder:
    b_:flatbuffers_builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers_offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def CSMCOLLECTIONStartRECORDSVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def CSMCOLLECTIONCreateRECORDSVector(b_:flatbuffers_builder, v_:[flatbuffers_offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

