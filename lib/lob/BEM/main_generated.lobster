// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum beamType:
    beamType_SPOT = 0
    beamType_REGIONAL = 1
    beamType_GLOBAL = 2
    beamType_SHAPED = 3
    beamType_STEERABLE = 4
    beamType_HOPPING = 5

enum beamPolarization:
    beamPolarization_RHCP = 0
    beamPolarization_LHCP = 1
    beamPolarization_LINEAR_H = 2
    beamPolarization_LINEAR_V = 3
    beamPolarization_DUAL_CIRCULAR = 4
    beamPolarization_DUAL_LINEAR = 5
    beamPolarization_CROSS_POL = 6

class beamContourPoint

class beamContour

class BEM

/// Beam Contour Point (gain pattern boundary)
class beamContourPoint : flatbuffers.handle
    /// Latitude in degrees
    def LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Longitude in degrees
    def LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Gain level in dBi at this contour
    def GAIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)

def GetRootAsbeamContourPoint(buf:string): return beamContourPoint { buf, flatbuffers.indirect(buf, 0) }

struct beamContourPointBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_LATITUDE(LATITUDE:float):
        b_.PrependFloat64Slot(0, LATITUDE, 0.0)
        return this
    def add_LONGITUDE(LONGITUDE:float):
        b_.PrependFloat64Slot(1, LONGITUDE, 0.0)
        return this
    def add_GAIN(GAIN:float):
        b_.PrependFloat64Slot(2, GAIN, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Beam Contour (iso-gain boundary)
class beamContour : flatbuffers.handle
    /// Contour level identifier
    def CONTOUR_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Gain level in dBi
    def GAIN_LEVEL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Contour boundary points
    def POINTS(i:int) -> beamContourPoint:
        return beamContourPoint { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 8) + i * 4) }
    def POINTS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsbeamContour(buf:string): return beamContour { buf, flatbuffers.indirect(buf, 0) }

struct beamContourBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_CONTOUR_ID(CONTOUR_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, CONTOUR_ID)
        return this
    def add_GAIN_LEVEL(GAIN_LEVEL:float):
        b_.PrependFloat64Slot(1, GAIN_LEVEL, 0.0)
        return this
    def add_POINTS(POINTS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, POINTS)
        return this
    def end():
        return b_.EndObject()

def beamContourStartPOINTSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def beamContourCreatePOINTSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Antenna Beam
class BEM : flatbuffers.handle
    /// Unique beam identifier
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Beam name or designation
    def BEAM_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Reference to parent entity (satellite/transponder)
    def ID_ENTITY() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Reference to parent antenna
    def ID_ANTENNA() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Beam type
    def TYPE() -> beamType:
        return beamType(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// Beam polarization
    def POLARIZATION() -> beamPolarization:
        return beamPolarization(flatbuffers.field_int8(buf_, pos_, 14, 0))
    /// Peak gain in dBi
    def PEAK_GAIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Edge-of-coverage gain in dBi
    def EOC_GAIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Beam center latitude in degrees
    def CENTER_LATITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Beam center longitude in degrees
    def CENTER_LONGITUDE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Beamwidth (3dB) in degrees
    def BEAMWIDTH() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Operating frequency in MHz
    def FREQUENCY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// EIRP at beam center in dBW
    def EIRP() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// G/T at beam center in dB/K
    def G_OVER_T() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Beam footprint area in km^2
    def FOOTPRINT_AREA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Beam contour definitions
    def BEAM_CONTOURS(i:int) -> beamContour:
        return beamContour { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 34) + i * 4) }
    def BEAM_CONTOURS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 34)
    /// Additional notes
    def NOTES() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)

def GetRootAsBEM(buf:string): return BEM { buf, flatbuffers.indirect(buf, 0) }

struct BEMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(17)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_BEAM_NAME(BEAM_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, BEAM_NAME)
        return this
    def add_ID_ENTITY(ID_ENTITY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, ID_ENTITY)
        return this
    def add_ID_ANTENNA(ID_ANTENNA:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ID_ANTENNA)
        return this
    def add_TYPE(TYPE:beamType):
        b_.PrependInt8Slot(4, TYPE, 0)
        return this
    def add_POLARIZATION(POLARIZATION:beamPolarization):
        b_.PrependInt8Slot(5, POLARIZATION, 0)
        return this
    def add_PEAK_GAIN(PEAK_GAIN:float):
        b_.PrependFloat64Slot(6, PEAK_GAIN, 0.0)
        return this
    def add_EOC_GAIN(EOC_GAIN:float):
        b_.PrependFloat64Slot(7, EOC_GAIN, 0.0)
        return this
    def add_CENTER_LATITUDE(CENTER_LATITUDE:float):
        b_.PrependFloat64Slot(8, CENTER_LATITUDE, 0.0)
        return this
    def add_CENTER_LONGITUDE(CENTER_LONGITUDE:float):
        b_.PrependFloat64Slot(9, CENTER_LONGITUDE, 0.0)
        return this
    def add_BEAMWIDTH(BEAMWIDTH:float):
        b_.PrependFloat64Slot(10, BEAMWIDTH, 0.0)
        return this
    def add_FREQUENCY(FREQUENCY:float):
        b_.PrependFloat64Slot(11, FREQUENCY, 0.0)
        return this
    def add_EIRP(EIRP:float):
        b_.PrependFloat64Slot(12, EIRP, 0.0)
        return this
    def add_G_OVER_T(G_OVER_T:float):
        b_.PrependFloat64Slot(13, G_OVER_T, 0.0)
        return this
    def add_FOOTPRINT_AREA(FOOTPRINT_AREA:float):
        b_.PrependFloat64Slot(14, FOOTPRINT_AREA, 0.0)
        return this
    def add_BEAM_CONTOURS(BEAM_CONTOURS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, BEAM_CONTOURS)
        return this
    def add_NOTES(NOTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, NOTES)
        return this
    def end():
        return b_.EndObject()

def BEMStartBEAM_CONTOURSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def BEMCreateBEAM_CONTOURSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

