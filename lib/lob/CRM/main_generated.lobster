// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class CRM

class CRMCOLLECTION

/// Collection Request Message
class CRM : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    def CLASSIFICATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// The type of this collect or contact request.
    def TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Unique identifier of the parent plan or schedule associated with this request.
    def ID_PLAN() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Index number for records within a collection plan or schedule.
    def PLAN_INDEX() -> int:
        return flatbuffers.field_int32(buf_, pos_, 12, 0)
    /// Task ID associated with this request.
    def TASK_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// The dwell ID associated with this request.
    def DWELL_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Optional ID from external systems.
    def EXTERNAL_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Unique identifier of the requested/scheduled/planned sensor associated with this request.
    def ID_SENSOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
    def ORIG_SENSOR_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Optional type of observation requested.
    def OB_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// The priority of the collect request.
    def PRIORITY() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// The tasking category associated with this request.
    def TASK_CATEGORY() -> int:
        return flatbuffers.field_int32(buf_, pos_, 28, 0)
    /// The tasking suffix associated with this request.
    def SUFFIX() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// Boolean indicating that this collect request is UCT follow-up.
    def UCT_FOLLOW_UP() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 32, 0))
    /// The start time of the collect or contact request window, in ISO 8601 UTC format.
    def START_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// The end time of the collect or contact request window, in ISO 8601 UTC format.
    def END_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// Satellite/catalog number of the target on-orbit object for this request.
    def NORAD_CAT_ID() -> int:
        return flatbuffers.field_uint32(buf_, pos_, 38, 0)
    /// Optional identifier provided by the data source to indicate the target object of this request.
    def ORIG_OBJECT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 40)
    /// The tasking group to which the target object is assigned.
    def TASK_GROUP() -> string:
        return flatbuffers.field_string(buf_, pos_, 42)
    /// Inter-Range Operations Number.
    def IRON() -> int:
        return flatbuffers.field_int32(buf_, pos_, 44, 0)
    /// The orbit regime of the target.
    def ORBIT_REGIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    /// The minimum object (diameter) size, in meters, to be reported.
    def TARGET_SIZE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)
    /// The minimum Radar Cross-Section of the target, in m^2.
    def RCS_MIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 50, 0.0)
    /// The Radar Cross-Section of the target, in m^2.
    def RCS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 52, 0.0)
    /// The maximum Radar Cross-Section of the target, in m^2.
    def RCS_MAX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    /// The minimum frequency of interest, in MHz.
    def FREQ_MIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 56, 0.0)
    /// The estimated or expected emission frequency of the target, in MHz.
    def FREQ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 58, 0.0)
    /// The maximum frequency of interest, in MHz.
    def FREQ_MAX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 60, 0.0)
    /// The RF polarization.
    def POLARIZATION() -> string:
        return flatbuffers.field_string(buf_, pos_, 62)
    /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
    def VIS_MAG_MIN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 64, 0.0)
    /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
    def VIS_MAG() -> float:
        return flatbuffers.field_float64(buf_, pos_, 66, 0.0)
    /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
    def VIS_MAG_MAX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 68, 0.0)
    /// The spectral model used for the irradiance calculation.
    def SPECTRAL_MODEL() -> string:
        return flatbuffers.field_string(buf_, pos_, 70)
    /// The fraction of solar energy reflected from target.
    def REFLECTANCE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 72, 0.0)
    /// The target object irradiance value.
    def IRRADIANCE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 74, 0.0)
    /// For optical sensors, the requested number of frames to capture at each sensor step.
    def NUM_FRAMES() -> int:
        return flatbuffers.field_int32(buf_, pos_, 76, 0)
    /// For optical sensors, the frame rate of the camera, in Hz.
    def FRAME_RATE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 78, 0.0)
    /// For optical sensors, the integration time per camera frame, in milliseconds.
    def INTEGRATION_TIME() -> float:
        return flatbuffers.field_float64(buf_, pos_, 80, 0.0)
    /// The number of requested tracks on the target.
    def NUM_TRACKS() -> int:
        return flatbuffers.field_int32(buf_, pos_, 82, 0)
    /// The number of requested observations on the target.
    def NUM_OBS() -> int:
        return flatbuffers.field_int32(buf_, pos_, 84, 0)
    /// The duration of the collect request, in seconds.
    def DURATION() -> int:
        return flatbuffers.field_int32(buf_, pos_, 86, 0)
    /// The search pattern to be executed for this request.
    def SRCH_PATTERN() -> string:
        return flatbuffers.field_string(buf_, pos_, 88)
    /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
    def SCENARIO() -> string:
        return flatbuffers.field_string(buf_, pos_, 90)
    /// ID of the Elset of the object associated with this request.
    def ID_ELSET() -> string:
        return flatbuffers.field_string(buf_, pos_, 92)
    /// ID of the Manifold Elset of the object associated with this request.
    def ID_MANIFOLD() -> string:
        return flatbuffers.field_string(buf_, pos_, 94)
    /// ID of the State Vector of the object or central vector associated with this request.
    def ID_STATE_VECTOR() -> string:
        return flatbuffers.field_string(buf_, pos_, 96)
    /// ID of the Ephemeris Set of the object associated with this request.
    def ES_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 98)
    /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
    def EPOCH() -> string:
        return flatbuffers.field_string(buf_, pos_, 100)
    /// The average of the periapsis and apoapsis distances, in kilometers.
    def SEMI_MAJOR_AXIS() -> float:
        return flatbuffers.field_float64(buf_, pos_, 102, 0.0)
    /// The orbital eccentricity of an astronomical object.
    def ECCENTRICITY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 104, 0.0)
    /// The angle, in degrees, between the equator and the orbit plane.
    def INCLINATION() -> float:
        return flatbuffers.field_float64(buf_, pos_, 106, 0.0)
    /// Right ascension of the ascending node, in degrees.
    def RAAN() -> float:
        return flatbuffers.field_float64(buf_, pos_, 108, 0.0)
    /// The argument of perigee, in degrees.
    def ARG_OF_PERIGEE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 110, 0.0)
    /// The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
    def MEAN_ANOMALY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 112, 0.0)
    /// The expected or directed right ascension angle, in degrees.
    def RA() -> float:
        return flatbuffers.field_float64(buf_, pos_, 114, 0.0)
    /// The expected or directed declination angle, in degrees.
    def DEC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 116, 0.0)
    /// The expected or directed azimuth angle, in degrees.
    def AZ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 118, 0.0)
    /// The expected or directed elevation angle, in degrees.
    def EL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 120, 0.0)
    /// The expected acquisition range or defined center range, in km.
    def RANGE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 122, 0.0)
    /// The extent of the azimuth angle, in degrees, from center azimuth.
    def EXTENT_AZ() -> float:
        return flatbuffers.field_float64(buf_, pos_, 124, 0.0)
    /// The extent of the elevation angle, in degrees, from center elevation.
    def EXTENT_EL() -> float:
        return flatbuffers.field_float64(buf_, pos_, 126, 0.0)
    /// The extent of the range, in km, from center range.
    def EXTENT_RANGE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 128, 0.0)
    /// WGS-84 latitude, in degrees.
    def LAT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 130, 0.0)
    /// WGS-84 longitude, in degrees.
    def LON() -> float:
        return flatbuffers.field_float64(buf_, pos_, 132, 0.0)
    /// Height above WGS-84 ellipsoid (HAE), in kilometers.
    def ALT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 134, 0.0)
    /// The stopping WGS-84 latitude of a volume definition, in degrees.
    def STOP_LAT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 136, 0.0)
    /// The stopping WGS-84 longitude of a volume definition, in degrees.
    def STOP_LON() -> float:
        return flatbuffers.field_float64(buf_, pos_, 138, 0.0)
    /// The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
    def STOP_ALT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 140, 0.0)
    /// The maximum inclination, in degrees, to be used in search operations.
    def SRCH_INC() -> float:
        return flatbuffers.field_float64(buf_, pos_, 142, 0.0)
    /// The angular distance, in degrees, in the sensor-x direction from scan center.
    def X_ANGLE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 144, 0.0)
    /// The angular distance, in degrees, in the sensor-y direction from scan center.
    def Y_ANGLE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 146, 0.0)
    /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
    def ORIENT_ANGLE() -> float:
        return flatbuffers.field_float64(buf_, pos_, 148, 0.0)
    /// The customer for this request.
    def CUSTOMER() -> string:
        return flatbuffers.field_string(buf_, pos_, 150)
    /// Notes or comments associated with this request.
    def NOTES() -> string:
        return flatbuffers.field_string(buf_, pos_, 152)
    ///  Source of the data.
    def SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 154)
    ///  Originating system or organization which produced the data, if different from the source.
    def ORIGIN() -> string:
        return flatbuffers.field_string(buf_, pos_, 156)
    ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
    def DATA_MODE() -> string:
        return flatbuffers.field_string(buf_, pos_, 158)

def GetRootAsCRM(buf:string): return CRM { buf, flatbuffers.indirect(buf, 0) }

struct CRMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(78)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_CLASSIFICATION(CLASSIFICATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, CLASSIFICATION)
        return this
    def add_TYPE(TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, TYPE)
        return this
    def add_ID_PLAN(ID_PLAN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, ID_PLAN)
        return this
    def add_PLAN_INDEX(PLAN_INDEX:int):
        b_.PrependInt32Slot(4, PLAN_INDEX, 0)
        return this
    def add_TASK_ID(TASK_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, TASK_ID)
        return this
    def add_DWELL_ID(DWELL_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, DWELL_ID)
        return this
    def add_EXTERNAL_ID(EXTERNAL_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, EXTERNAL_ID)
        return this
    def add_ID_SENSOR(ID_SENSOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, ID_SENSOR)
        return this
    def add_ORIG_SENSOR_ID(ORIG_SENSOR_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, ORIG_SENSOR_ID)
        return this
    def add_OB_TYPE(OB_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, OB_TYPE)
        return this
    def add_PRIORITY(PRIORITY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, PRIORITY)
        return this
    def add_TASK_CATEGORY(TASK_CATEGORY:int):
        b_.PrependInt32Slot(12, TASK_CATEGORY, 0)
        return this
    def add_SUFFIX(SUFFIX:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, SUFFIX)
        return this
    def add_UCT_FOLLOW_UP(UCT_FOLLOW_UP:bool):
        b_.PrependBoolSlot(14, UCT_FOLLOW_UP, 0)
        return this
    def add_START_TIME(START_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, START_TIME)
        return this
    def add_END_TIME(END_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, END_TIME)
        return this
    def add_NORAD_CAT_ID(NORAD_CAT_ID:int):
        b_.PrependUint32Slot(17, NORAD_CAT_ID, 0)
        return this
    def add_ORIG_OBJECT_ID(ORIG_OBJECT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, ORIG_OBJECT_ID)
        return this
    def add_TASK_GROUP(TASK_GROUP:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, TASK_GROUP)
        return this
    def add_IRON(IRON:int):
        b_.PrependInt32Slot(20, IRON, 0)
        return this
    def add_ORBIT_REGIME(ORBIT_REGIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, ORBIT_REGIME)
        return this
    def add_TARGET_SIZE(TARGET_SIZE:float):
        b_.PrependFloat64Slot(22, TARGET_SIZE, 0.0)
        return this
    def add_RCS_MIN(RCS_MIN:float):
        b_.PrependFloat64Slot(23, RCS_MIN, 0.0)
        return this
    def add_RCS(RCS:float):
        b_.PrependFloat64Slot(24, RCS, 0.0)
        return this
    def add_RCS_MAX(RCS_MAX:float):
        b_.PrependFloat64Slot(25, RCS_MAX, 0.0)
        return this
    def add_FREQ_MIN(FREQ_MIN:float):
        b_.PrependFloat64Slot(26, FREQ_MIN, 0.0)
        return this
    def add_FREQ(FREQ:float):
        b_.PrependFloat64Slot(27, FREQ, 0.0)
        return this
    def add_FREQ_MAX(FREQ_MAX:float):
        b_.PrependFloat64Slot(28, FREQ_MAX, 0.0)
        return this
    def add_POLARIZATION(POLARIZATION:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, POLARIZATION)
        return this
    def add_VIS_MAG_MIN(VIS_MAG_MIN:float):
        b_.PrependFloat64Slot(30, VIS_MAG_MIN, 0.0)
        return this
    def add_VIS_MAG(VIS_MAG:float):
        b_.PrependFloat64Slot(31, VIS_MAG, 0.0)
        return this
    def add_VIS_MAG_MAX(VIS_MAG_MAX:float):
        b_.PrependFloat64Slot(32, VIS_MAG_MAX, 0.0)
        return this
    def add_SPECTRAL_MODEL(SPECTRAL_MODEL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, SPECTRAL_MODEL)
        return this
    def add_REFLECTANCE(REFLECTANCE:float):
        b_.PrependFloat64Slot(34, REFLECTANCE, 0.0)
        return this
    def add_IRRADIANCE(IRRADIANCE:float):
        b_.PrependFloat64Slot(35, IRRADIANCE, 0.0)
        return this
    def add_NUM_FRAMES(NUM_FRAMES:int):
        b_.PrependInt32Slot(36, NUM_FRAMES, 0)
        return this
    def add_FRAME_RATE(FRAME_RATE:float):
        b_.PrependFloat64Slot(37, FRAME_RATE, 0.0)
        return this
    def add_INTEGRATION_TIME(INTEGRATION_TIME:float):
        b_.PrependFloat64Slot(38, INTEGRATION_TIME, 0.0)
        return this
    def add_NUM_TRACKS(NUM_TRACKS:int):
        b_.PrependInt32Slot(39, NUM_TRACKS, 0)
        return this
    def add_NUM_OBS(NUM_OBS:int):
        b_.PrependInt32Slot(40, NUM_OBS, 0)
        return this
    def add_DURATION(DURATION:int):
        b_.PrependInt32Slot(41, DURATION, 0)
        return this
    def add_SRCH_PATTERN(SRCH_PATTERN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(42, SRCH_PATTERN)
        return this
    def add_SCENARIO(SCENARIO:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(43, SCENARIO)
        return this
    def add_ID_ELSET(ID_ELSET:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(44, ID_ELSET)
        return this
    def add_ID_MANIFOLD(ID_MANIFOLD:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(45, ID_MANIFOLD)
        return this
    def add_ID_STATE_VECTOR(ID_STATE_VECTOR:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(46, ID_STATE_VECTOR)
        return this
    def add_ES_ID(ES_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(47, ES_ID)
        return this
    def add_EPOCH(EPOCH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(48, EPOCH)
        return this
    def add_SEMI_MAJOR_AXIS(SEMI_MAJOR_AXIS:float):
        b_.PrependFloat64Slot(49, SEMI_MAJOR_AXIS, 0.0)
        return this
    def add_ECCENTRICITY(ECCENTRICITY:float):
        b_.PrependFloat64Slot(50, ECCENTRICITY, 0.0)
        return this
    def add_INCLINATION(INCLINATION:float):
        b_.PrependFloat64Slot(51, INCLINATION, 0.0)
        return this
    def add_RAAN(RAAN:float):
        b_.PrependFloat64Slot(52, RAAN, 0.0)
        return this
    def add_ARG_OF_PERIGEE(ARG_OF_PERIGEE:float):
        b_.PrependFloat64Slot(53, ARG_OF_PERIGEE, 0.0)
        return this
    def add_MEAN_ANOMALY(MEAN_ANOMALY:float):
        b_.PrependFloat64Slot(54, MEAN_ANOMALY, 0.0)
        return this
    def add_RA(RA:float):
        b_.PrependFloat64Slot(55, RA, 0.0)
        return this
    def add_DEC(DEC:float):
        b_.PrependFloat64Slot(56, DEC, 0.0)
        return this
    def add_AZ(AZ:float):
        b_.PrependFloat64Slot(57, AZ, 0.0)
        return this
    def add_EL(EL:float):
        b_.PrependFloat64Slot(58, EL, 0.0)
        return this
    def add_RANGE(RANGE:float):
        b_.PrependFloat64Slot(59, RANGE, 0.0)
        return this
    def add_EXTENT_AZ(EXTENT_AZ:float):
        b_.PrependFloat64Slot(60, EXTENT_AZ, 0.0)
        return this
    def add_EXTENT_EL(EXTENT_EL:float):
        b_.PrependFloat64Slot(61, EXTENT_EL, 0.0)
        return this
    def add_EXTENT_RANGE(EXTENT_RANGE:float):
        b_.PrependFloat64Slot(62, EXTENT_RANGE, 0.0)
        return this
    def add_LAT(LAT:float):
        b_.PrependFloat64Slot(63, LAT, 0.0)
        return this
    def add_LON(LON:float):
        b_.PrependFloat64Slot(64, LON, 0.0)
        return this
    def add_ALT(ALT:float):
        b_.PrependFloat64Slot(65, ALT, 0.0)
        return this
    def add_STOP_LAT(STOP_LAT:float):
        b_.PrependFloat64Slot(66, STOP_LAT, 0.0)
        return this
    def add_STOP_LON(STOP_LON:float):
        b_.PrependFloat64Slot(67, STOP_LON, 0.0)
        return this
    def add_STOP_ALT(STOP_ALT:float):
        b_.PrependFloat64Slot(68, STOP_ALT, 0.0)
        return this
    def add_SRCH_INC(SRCH_INC:float):
        b_.PrependFloat64Slot(69, SRCH_INC, 0.0)
        return this
    def add_X_ANGLE(X_ANGLE:float):
        b_.PrependFloat64Slot(70, X_ANGLE, 0.0)
        return this
    def add_Y_ANGLE(Y_ANGLE:float):
        b_.PrependFloat64Slot(71, Y_ANGLE, 0.0)
        return this
    def add_ORIENT_ANGLE(ORIENT_ANGLE:float):
        b_.PrependFloat64Slot(72, ORIENT_ANGLE, 0.0)
        return this
    def add_CUSTOMER(CUSTOMER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(73, CUSTOMER)
        return this
    def add_NOTES(NOTES:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(74, NOTES)
        return this
    def add_SOURCE(SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(75, SOURCE)
        return this
    def add_ORIGIN(ORIGIN:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(76, ORIGIN)
        return this
    def add_DATA_MODE(DATA_MODE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(77, DATA_MODE)
        return this
    def end():
        return b_.EndObject()

class CRMCOLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> CRM:
        return CRM { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsCRMCOLLECTION(buf:string): return CRMCOLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct CRMCOLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def CRMCOLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CRMCOLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

