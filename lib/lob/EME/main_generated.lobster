// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class EME

/// Encrypted Message Envelope
class EME : flatbuffers.handle
    /// Encrypted data blob, containing the ciphertext of the original plaintext message.
    def ENCRYPTED_BLOB(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 4) + i * 1)
    def ENCRYPTED_BLOB_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)
    /// Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
    def EPHEMERAL_PUBLIC_KEY() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Message Authentication Code to verify the integrity and authenticity of the encrypted message.
    def MAC() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
    def NONCE_START(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 1)
    def NONCE_START_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
    def TAG() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Initialization vector used to introduce randomness in the encryption process, enhancing security.
    def IV() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Cryptographic salt used in key derivation (e.g. HKDF) to ensure unique key material per session.
    def SALT() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Identifier for the public key used, aiding in recipient key management and message decryption.
    def PUBLIC_KEY_IDENTIFIER() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Specifies the set of cryptographic algorithms used in the encryption process.
    def CIPHER_SUITE() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
    def KDF_PARAMETERS() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
    def ENCRYPTION_ALGORITHM_PARAMETERS() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)

def GetRootAsEME(buf:string): return EME { buf, flatbuffers.indirect(buf, 0) }

struct EMEBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_ENCRYPTED_BLOB(ENCRYPTED_BLOB:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ENCRYPTED_BLOB)
        return this
    def add_EPHEMERAL_PUBLIC_KEY(EPHEMERAL_PUBLIC_KEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, EPHEMERAL_PUBLIC_KEY)
        return this
    def add_MAC(MAC:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, MAC)
        return this
    def add_NONCE_START(NONCE_START:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, NONCE_START)
        return this
    def add_TAG(TAG:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, TAG)
        return this
    def add_IV(IV:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, IV)
        return this
    def add_SALT(SALT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, SALT)
        return this
    def add_PUBLIC_KEY_IDENTIFIER(PUBLIC_KEY_IDENTIFIER:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, PUBLIC_KEY_IDENTIFIER)
        return this
    def add_CIPHER_SUITE(CIPHER_SUITE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, CIPHER_SUITE)
        return this
    def add_KDF_PARAMETERS(KDF_PARAMETERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, KDF_PARAMETERS)
        return this
    def add_ENCRYPTION_ALGORITHM_PARAMETERS(ENCRYPTION_ALGORITHM_PARAMETERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, ENCRYPTION_ALGORITHM_PARAMETERS)
        return this
    def end():
        return b_.EndObject()

def EMEStartENCRYPTED_BLOBVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def EMECreateENCRYPTED_BLOBVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def EMEStartNONCE_STARTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def EMECreateNONCE_STARTVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

