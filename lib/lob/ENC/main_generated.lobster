// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// Encryption Header for FlatBuffers field-level encryption
/// Key exchange algorithm used to derive the shared secret
enum KeyExchange:
    KeyExchange_X25519 = 0
    KeyExchange_Secp256k1 = 1
    KeyExchange_P256 = 2

/// Symmetric encryption algorithm
enum SymmetricAlgo:
    SymmetricAlgo_AES_256_CTR = 0

/// Key derivation function
enum KDF:
    KDF_HKDF_SHA256 = 0

class ENC

/// Encryption Header containing all parameters needed for decryption
class ENC : flatbuffers.handle
    /// Schema version for forward compatibility
    def VERSION() -> int:
        return flatbuffers.field_uint8(buf_, pos_, 4, 1)
    /// Key exchange algorithm used
    def KEY_EXCHANGE() -> KeyExchange:
        return KeyExchange(flatbuffers.field_int8(buf_, pos_, 6, 0))
    /// Symmetric encryption algorithm used
    def SYMMETRIC() -> SymmetricAlgo:
        return SymmetricAlgo(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Key derivation function used
    def KEY_DERIVATION() -> KDF:
        return KDF(flatbuffers.field_int8(buf_, pos_, 10, 0))
    /// Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
    def EPHEMERAL_PUBLIC_KEY(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 12) + i * 1)
    def EPHEMERAL_PUBLIC_KEY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)
    /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
    def NONCE_START(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 1)
    def NONCE_START_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Optional identifier for the recipient's public key (up to 32 bytes)
    def RECIPIENT_KEY_ID(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 16) + i * 1)
    def RECIPIENT_KEY_ID_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Optional domain separation context string
    def CONTEXT() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
    def SCHEMA_HASH(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 20) + i * 1)
    def SCHEMA_HASH_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 20)
    /// Optional root type name from the schema
    def ROOT_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Optional Unix timestamp (milliseconds) when encryption was performed
    def TIMESTAMP() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 24, 0)

def GetRootAsENC(buf:string): return ENC { buf, flatbuffers.indirect(buf, 0) }

struct ENCBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_VERSION(VERSION:int):
        b_.PrependUint8Slot(0, VERSION, 1)
        return this
    def add_KEY_EXCHANGE(KEY_EXCHANGE:KeyExchange):
        b_.PrependInt8Slot(1, KEY_EXCHANGE, 0)
        return this
    def add_SYMMETRIC(SYMMETRIC:SymmetricAlgo):
        b_.PrependInt8Slot(2, SYMMETRIC, 0)
        return this
    def add_KEY_DERIVATION(KEY_DERIVATION:KDF):
        b_.PrependInt8Slot(3, KEY_DERIVATION, 0)
        return this
    def add_EPHEMERAL_PUBLIC_KEY(EPHEMERAL_PUBLIC_KEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, EPHEMERAL_PUBLIC_KEY)
        return this
    def add_NONCE_START(NONCE_START:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, NONCE_START)
        return this
    def add_RECIPIENT_KEY_ID(RECIPIENT_KEY_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, RECIPIENT_KEY_ID)
        return this
    def add_CONTEXT(CONTEXT:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, CONTEXT)
        return this
    def add_SCHEMA_HASH(SCHEMA_HASH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, SCHEMA_HASH)
        return this
    def add_ROOT_TYPE(ROOT_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, ROOT_TYPE)
        return this
    def add_TIMESTAMP(TIMESTAMP:int):
        b_.PrependUint64Slot(10, TIMESTAMP, 0)
        return this
    def end():
        return b_.EndObject()

def ENCStartEPHEMERAL_PUBLIC_KEYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ENCCreateEPHEMERAL_PUBLIC_KEYVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def ENCStartNONCE_STARTVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ENCCreateNONCE_STARTVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def ENCStartRECIPIENT_KEY_IDVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ENCCreateRECIPIENT_KEY_IDVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def ENCStartSCHEMA_HASHVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ENCCreateSCHEMA_HASHVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

