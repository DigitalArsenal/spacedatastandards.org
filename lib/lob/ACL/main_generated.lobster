// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class ACL

/// Access Control Grant - Permission to access purchased data
class ACL : flatbuffers.handle
    /// Unique identifier for this grant
    def GRANT_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// ID of the listing this grant applies to
    def LISTING_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Peer ID of the buyer/grantee
    def BUYER_PEER_ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Buyer's encryption public key for encrypted delivery
    def BUYER_ENCRYPTION_PUBKEY(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 1)
    def BUYER_ENCRYPTION_PUBKEY_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Type of access granted
    def ACCESS_TYPE() -> accessType:
        return accessType(flatbuffers.field_int8(buf_, pos_, 12, 0))
    /// Name of the pricing tier purchased
    def TIER_NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Unix timestamp when access was granted
    def GRANTED_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 16, 0)
    /// Unix timestamp when access expires (0 = never expires)
    def EXPIRES_AT() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 18, 0)
    /// Transaction hash or reference proving payment
    def PAYMENT_TX_HASH() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Payment method used
    def PAYMENT_METHOD() -> paymentMethod:
        return paymentMethod(flatbuffers.field_int8(buf_, pos_, 22, 0))
    /// Ed25519 signature from provider
    def PROVIDER_SIGNATURE(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 24) + i * 1)
    def PROVIDER_SIGNATURE_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 24)

def GetRootAsACL(buf:string): return ACL { buf, flatbuffers.indirect(buf, 0) }

struct ACLBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_GRANT_ID(GRANT_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, GRANT_ID)
        return this
    def add_LISTING_ID(LISTING_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, LISTING_ID)
        return this
    def add_BUYER_PEER_ID(BUYER_PEER_ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, BUYER_PEER_ID)
        return this
    def add_BUYER_ENCRYPTION_PUBKEY(BUYER_ENCRYPTION_PUBKEY:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, BUYER_ENCRYPTION_PUBKEY)
        return this
    def add_ACCESS_TYPE(ACCESS_TYPE:accessType):
        b_.PrependInt8Slot(4, ACCESS_TYPE, 0)
        return this
    def add_TIER_NAME(TIER_NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, TIER_NAME)
        return this
    def add_GRANTED_AT(GRANTED_AT:int):
        b_.PrependUint64Slot(6, GRANTED_AT, 0)
        return this
    def add_EXPIRES_AT(EXPIRES_AT:int):
        b_.PrependUint64Slot(7, EXPIRES_AT, 0)
        return this
    def add_PAYMENT_TX_HASH(PAYMENT_TX_HASH:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, PAYMENT_TX_HASH)
        return this
    def add_PAYMENT_METHOD(PAYMENT_METHOD:paymentMethod):
        b_.PrependInt8Slot(9, PAYMENT_METHOD, 0)
        return this
    def add_PROVIDER_SIGNATURE(PROVIDER_SIGNATURE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, PROVIDER_SIGNATURE)
        return this
    def end():
        return b_.EndObject()

def ACLStartBUYER_ENCRYPTION_PUBKEYVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ACLCreateBUYER_ENCRYPTION_PUBKEYVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def ACLStartPROVIDER_SIGNATUREVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def ACLCreatePROVIDER_SIGNATUREVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

