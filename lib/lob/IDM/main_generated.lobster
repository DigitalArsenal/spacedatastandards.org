// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

/// Different types of polarization in EMT
enum PolarizationType:
    PolarizationType_linear = 0
    PolarizationType_circular = 1
    PolarizationType_elliptical = 2
    PolarizationType_unpolarized = 3

/// Simple polarization types
enum SimplePolarization:
    SimplePolarization_vertical = 0
    SimplePolarization_horizontal = 1
    SimplePolarization_leftHandCircular = 2
    SimplePolarization_rightHandCircular = 3

/// Enum for the mode of data (real, simulated, synthetic)
enum DataMode:
    /// Data collected during an exercise scenario.
    DataMode_EXERCISE = 0
    /// Data collected from real-world observations.
    DataMode_REAL = 1
    /// Data generated through simulation.
    DataMode_SIMULATED = 2
    /// Data collected for testing purposes.
    DataMode_TEST = 3

enum DeviceType:
    /// Basic or undefined sensor type
    DeviceType_UNKNOWN = 0
    /// General optical sensors
    DeviceType_OPTICAL = 1
    /// Detects infrared radiation
    DeviceType_INFRARED_SENSOR = 2
    /// Sensitive to ultraviolet light
    DeviceType_ULTRAVIOLET_SENSOR = 3
    /// For X-ray detection
    DeviceType_X_RAY_SENSOR = 4
    /// For gamma-ray detection
    DeviceType_GAMMA_RAY_SENSOR = 5
    /// Basic radar systems
    DeviceType_RADAR = 6
    /// Advanced radar with phased array technology
    DeviceType_PHASED_ARRAY_RADAR = 7
    /// For high-resolution imaging
    DeviceType_SYNTHETIC_APERTURE_RADAR = 8
    /// For astronomical observations using bistatic setup
    DeviceType_BISTATIC_RADIO_TELESCOPE = 9
    /// For radio astronomy
    DeviceType_RADIO_TELESCOPE = 10
    /// For atmospheric studies
    DeviceType_ATMOSPHERIC_SENSOR = 11
    /// For observing space weather phenomena
    DeviceType_SPACE_WEATHER_SENSOR = 12
    /// General environmental monitoring
    DeviceType_ENVIRONMENTAL_SENSOR = 13
    /// For measuring seismic activities
    DeviceType_SEISMIC_SENSOR = 14
    /// For gravity measurements
    DeviceType_GRAVIMETRIC_SENSOR = 15
    /// For magnetic field detection
    DeviceType_MAGNETIC_SENSOR = 16
    /// For electromagnetic field analysis
    DeviceType_ELECTROMAGNETIC_SENSOR = 17
    /// For temperature and heat detection
    DeviceType_THERMAL_SENSOR = 18
    /// For detecting chemicals and substances
    DeviceType_CHEMICAL_SENSOR = 19
    /// For biological research and detection
    DeviceType_BIOLOGICAL_SENSOR = 20
    /// For detecting ionizing radiation
    DeviceType_RADIATION_SENSOR = 21
    /// For detecting subatomic particles
    DeviceType_PARTICLE_DETECTOR = 22
    /// Light Detection and Ranging
    DeviceType_LIDAR = 23
    /// Sound Navigation and Ranging
    DeviceType_SONAR = 24
    /// General telescopes for astronomical observations
    DeviceType_TELESCOPE = 25
    /// For spectral analysis
    DeviceType_SPECTROSCOPIC_SENSOR = 26
    /// For measuring light intensity
    DeviceType_PHOTOMETRIC_SENSOR = 27
    /// For analyzing polarization of light
    DeviceType_POLARIMETRIC_SENSOR = 28
    /// For detailed imaging using interference
    DeviceType_INTERFEROMETRIC_SENSOR = 29
    /// Capturing image data at multiple wavelengths
    DeviceType_MULTISPECTRAL_SENSOR = 30
    /// Advanced imaging across many spectral bands
    DeviceType_HYPERSPECTRAL_SENSOR = 31
    /// For Global Positioning System reception
    DeviceType_GPS_RECEIVER = 32
    /// Standard radio communication device
    DeviceType_RADIO_COMMUNICATIONS = 33
    /// Advanced laser communication system
    DeviceType_LASER_COMMUNICATIONS = 34
    /// Satellite communication system
    DeviceType_SATELLITE_COMMUNICATIONS = 35
    /// Device for laser-based experiments and measurements
    DeviceType_LASER_INSTRUMENT = 36
    /// Radio frequency analysis and measurement device
    DeviceType_RF_ANALYZER = 37
    /// Device for ionospheric research
    DeviceType_IONOSPHERIC_SENSOR = 38
    /// Device for laser-based imaging
    DeviceType_LASER_IMAGING = 39
    /// Advanced optical telescope
    DeviceType_OPTICAL_TELESCOPE = 40
    /// Device for high-resolution optical observations
    DeviceType_HIGH_RESOLUTION_OPTICAL = 41
    DeviceType_RADIO = 42
    /// Microwave communication device
    DeviceType_MICROWAVE_TRANSMITTER = 43
    /// Device for radio frequency monitoring
    DeviceType_RF_MONITOR = 44
    /// High-frequency radio communication device
    DeviceType_HF_RADIO_COMMUNICATIONS = 45

class FrequencyRange

class StokesParameters

class Band

class IDM

class IDMCOLLECTION

/// Frequency range with lower and upper limits
class FrequencyRange : flatbuffers.handle
    /// Lower frequency in MHz
    def LOWER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Upper frequency in MHz
    def UPPER() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)

def GetRootAsFrequencyRange(buf:string): return FrequencyRange { buf, flatbuffers.indirect(buf, 0) }

struct FrequencyRangeBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_LOWER(LOWER:float):
        b_.PrependFloat64Slot(0, LOWER, 0.0)
        return this
    def add_UPPER(UPPER:float):
        b_.PrependFloat64Slot(1, UPPER, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Stokes parameters, representing different aspects of polarization
class StokesParameters : flatbuffers.handle
    /// Intensity
    def I() -> float:
        return flatbuffers.field_float64(buf_, pos_, 4, 0.0)
    /// Linear polarization
    def Q() -> float:
        return flatbuffers.field_float64(buf_, pos_, 6, 0.0)
    /// Another linear polarization, orthogonal to Q
    def U() -> float:
        return flatbuffers.field_float64(buf_, pos_, 8, 0.0)
    /// Circular polarization
    def V() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)

def GetRootAsStokesParameters(buf:string): return StokesParameters { buf, flatbuffers.indirect(buf, 0) }

struct StokesParametersBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(4)
        return this
    def add_I(I:float):
        b_.PrependFloat64Slot(0, I, 0.0)
        return this
    def add_Q(Q:float):
        b_.PrependFloat64Slot(1, Q, 0.0)
        return this
    def add_U(U:float):
        b_.PrependFloat64Slot(2, U, 0.0)
        return this
    def add_V(V:float):
        b_.PrependFloat64Slot(3, V, 0.0)
        return this
    def end():
        return b_.EndObject()

/// Table representing a frequency band with a name and frequency range
class Band : flatbuffers.handle
    /// Name of the band
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Frequency range of the band
    def FREQUENCY_RANGE() -> FrequencyRange?:
        let o = flatbuffers.field_table(buf_, pos_, 6)
        return if o: FrequencyRange { buf_, o } else: nil

def GetRootAsBand(buf:string): return Band { buf, flatbuffers.indirect(buf, 0) }

struct BandBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, NAME)
        return this
    def add_FREQUENCY_RANGE(FREQUENCY_RANGE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, FREQUENCY_RANGE)
        return this
    def end():
        return b_.EndObject()

/// Integrated Device Message
class IDM : flatbuffers.handle
    /// Unique identifier for the EMT
    def ID() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Name of the EMT
    def NAME() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Mode of the data (real, simulated, synthetic)
    def DATA_MODE() -> DataMode:
        return DataMode(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Uplink frequency range
    def UPLINK() -> FrequencyRange?:
        let o = flatbuffers.field_table(buf_, pos_, 10)
        return if o: FrequencyRange { buf_, o } else: nil
    /// Downlink frequency range
    def DOWNLINK() -> FrequencyRange?:
        let o = flatbuffers.field_table(buf_, pos_, 12)
        return if o: FrequencyRange { buf_, o } else: nil
    /// Beacon frequency range
    def BEACON() -> FrequencyRange?:
        let o = flatbuffers.field_table(buf_, pos_, 14)
        return if o: FrequencyRange { buf_, o } else: nil
    /// Bands associated with the EMT
    def BAND(i:int) -> Band:
        return Band { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 16) + i * 4) }
    def BAND_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Type of polarization used
    def POLARIZATION_TYPE() -> PolarizationType:
        return PolarizationType(flatbuffers.field_int8(buf_, pos_, 18, 0))
    /// Simple polarization configuration
    def SIMPLE_POLARIZATION() -> SimplePolarization:
        return SimplePolarization(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Stokes parameters for polarization characterization
    def STOKES_PARAMETERS() -> StokesParameters?:
        let o = flatbuffers.field_table(buf_, pos_, 22)
        return if o: StokesParameters { buf_, o } else: nil
    /// Power required in Watts
    def POWER_REQUIRED() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Type of power (eg. AC or DC)
    def POWER_TYPE() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Indicates if the EMT can transmit
    def TRANSMIT() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 28, 0))
    /// Indicates if the EMT can receive
    def RECEIVE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 30, 0))
    /// Type of the sensor
    def SENSOR_TYPE() -> DeviceType:
        return DeviceType(flatbuffers.field_int8(buf_, pos_, 32, 0))
    /// Source of the data
    def SOURCE() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// Timestamp of the last observation
    def LAST_OB_TIME() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// Lower left elevation limit
    def LOWER_LEFT_ELEVATION_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Upper left azimuth limit
    def UPPER_LEFT_AZIMUTH_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Lower right elevation limit
    def LOWER_RIGHT_ELEVATION_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Lower left azimuth limit
    def LOWER_LEFT_AZIMUTH_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Upper right elevation limit
    def UPPER_RIGHT_ELEVATION_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)
    /// Upper right azimuth limit
    def UPPER_RIGHT_AZIMUTH_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)
    /// Lower right azimuth limit
    def LOWER_RIGHT_AZIMUTH_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 50, 0.0)
    /// Upper left elevation limit
    def UPPER_LEFT_ELEVATION_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 52, 0.0)
    /// Right geostationary belt limit
    def RIGHT_GEO_BELT_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    /// Left geostationary belt limit
    def LEFT_GEO_BELT_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 56, 0.0)
    /// Magnitude limit of the sensor
    def MAGNITUDE_LIMIT() -> float:
        return flatbuffers.field_float64(buf_, pos_, 58, 0.0)
    /// Indicates if the site is taskable
    def TASKABLE() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 60, 0))

def GetRootAsIDM(buf:string): return IDM { buf, flatbuffers.indirect(buf, 0) }

struct IDMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(29)
        return this
    def add_ID(ID:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, ID)
        return this
    def add_NAME(NAME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, NAME)
        return this
    def add_DATA_MODE(DATA_MODE:DataMode):
        b_.PrependInt8Slot(2, DATA_MODE, 0)
        return this
    def add_UPLINK(UPLINK:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, UPLINK)
        return this
    def add_DOWNLINK(DOWNLINK:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, DOWNLINK)
        return this
    def add_BEACON(BEACON:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, BEACON)
        return this
    def add_BAND(BAND:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, BAND)
        return this
    def add_POLARIZATION_TYPE(POLARIZATION_TYPE:PolarizationType):
        b_.PrependInt8Slot(7, POLARIZATION_TYPE, 0)
        return this
    def add_SIMPLE_POLARIZATION(SIMPLE_POLARIZATION:SimplePolarization):
        b_.PrependInt8Slot(8, SIMPLE_POLARIZATION, 0)
        return this
    def add_STOKES_PARAMETERS(STOKES_PARAMETERS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, STOKES_PARAMETERS)
        return this
    def add_POWER_REQUIRED(POWER_REQUIRED:float):
        b_.PrependFloat64Slot(10, POWER_REQUIRED, 0.0)
        return this
    def add_POWER_TYPE(POWER_TYPE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, POWER_TYPE)
        return this
    def add_TRANSMIT(TRANSMIT:bool):
        b_.PrependBoolSlot(12, TRANSMIT, 0)
        return this
    def add_RECEIVE(RECEIVE:bool):
        b_.PrependBoolSlot(13, RECEIVE, 0)
        return this
    def add_SENSOR_TYPE(SENSOR_TYPE:DeviceType):
        b_.PrependInt8Slot(14, SENSOR_TYPE, 0)
        return this
    def add_SOURCE(SOURCE:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, SOURCE)
        return this
    def add_LAST_OB_TIME(LAST_OB_TIME:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, LAST_OB_TIME)
        return this
    def add_LOWER_LEFT_ELEVATION_LIMIT(LOWER_LEFT_ELEVATION_LIMIT:float):
        b_.PrependFloat64Slot(17, LOWER_LEFT_ELEVATION_LIMIT, 0.0)
        return this
    def add_UPPER_LEFT_AZIMUTH_LIMIT(UPPER_LEFT_AZIMUTH_LIMIT:float):
        b_.PrependFloat64Slot(18, UPPER_LEFT_AZIMUTH_LIMIT, 0.0)
        return this
    def add_LOWER_RIGHT_ELEVATION_LIMIT(LOWER_RIGHT_ELEVATION_LIMIT:float):
        b_.PrependFloat64Slot(19, LOWER_RIGHT_ELEVATION_LIMIT, 0.0)
        return this
    def add_LOWER_LEFT_AZIMUTH_LIMIT(LOWER_LEFT_AZIMUTH_LIMIT:float):
        b_.PrependFloat64Slot(20, LOWER_LEFT_AZIMUTH_LIMIT, 0.0)
        return this
    def add_UPPER_RIGHT_ELEVATION_LIMIT(UPPER_RIGHT_ELEVATION_LIMIT:float):
        b_.PrependFloat64Slot(21, UPPER_RIGHT_ELEVATION_LIMIT, 0.0)
        return this
    def add_UPPER_RIGHT_AZIMUTH_LIMIT(UPPER_RIGHT_AZIMUTH_LIMIT:float):
        b_.PrependFloat64Slot(22, UPPER_RIGHT_AZIMUTH_LIMIT, 0.0)
        return this
    def add_LOWER_RIGHT_AZIMUTH_LIMIT(LOWER_RIGHT_AZIMUTH_LIMIT:float):
        b_.PrependFloat64Slot(23, LOWER_RIGHT_AZIMUTH_LIMIT, 0.0)
        return this
    def add_UPPER_LEFT_ELEVATION_LIMIT(UPPER_LEFT_ELEVATION_LIMIT:float):
        b_.PrependFloat64Slot(24, UPPER_LEFT_ELEVATION_LIMIT, 0.0)
        return this
    def add_RIGHT_GEO_BELT_LIMIT(RIGHT_GEO_BELT_LIMIT:float):
        b_.PrependFloat64Slot(25, RIGHT_GEO_BELT_LIMIT, 0.0)
        return this
    def add_LEFT_GEO_BELT_LIMIT(LEFT_GEO_BELT_LIMIT:float):
        b_.PrependFloat64Slot(26, LEFT_GEO_BELT_LIMIT, 0.0)
        return this
    def add_MAGNITUDE_LIMIT(MAGNITUDE_LIMIT:float):
        b_.PrependFloat64Slot(27, MAGNITUDE_LIMIT, 0.0)
        return this
    def add_TASKABLE(TASKABLE:bool):
        b_.PrependBoolSlot(28, TASKABLE, 0)
        return this
    def end():
        return b_.EndObject()

def IDMStartBANDVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IDMCreateBANDVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

class IDMCOLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> IDM:
        return IDM { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsIDMCOLLECTION(buf:string): return IDMCOLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct IDMCOLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def IDMCOLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def IDMCOLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

