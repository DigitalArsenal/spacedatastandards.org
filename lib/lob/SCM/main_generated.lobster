// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class SCHEMA_STANDARD

class SCM

class SCMCOLLECTION

/// Schema Standard Definition
class SCHEMA_STANDARD : flatbuffers.handle
    /// Unique identifier for the standard
    def key() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// IDL
    def idl() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// List Of File Paths
    def files(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 8) + i * 4)
    def files_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 8)

def GetRootAsSCHEMA_STANDARD(buf:string): return SCHEMA_STANDARD { buf, flatbuffers.indirect(buf, 0) }

struct SCHEMA_STANDARDBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(3)
        return this
    def add_key(key:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, key)
        return this
    def add_idl(idl:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, idl)
        return this
    def add_files(files:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, files)
        return this
    def end():
        return b_.EndObject()

def SCHEMA_STANDARDStartFilesVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SCHEMA_STANDARDCreateFilesVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Schema Manifest
class SCM : flatbuffers.handle
    /// Version of Space Data Standards
    def version() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Standards Dictionary
    def RECORDS(i:int) -> SCHEMA_STANDARD:
        return SCHEMA_STANDARD { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 6) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 6)

def GetRootAsSCM(buf:string): return SCM { buf, flatbuffers.indirect(buf, 0) }

struct SCMBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_version(version:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, version)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, RECORDS)
        return this
    def end():
        return b_.EndObject()

def SCMStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SCMCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

/// Declaring the root type
class SCMCOLLECTION : flatbuffers.handle
    def RECORDS(i:int) -> SCM:
        return SCM { buf_, flatbuffers.indirect(buf_, flatbuffers.field_vector(buf_, pos_, 4) + i * 4) }
    def RECORDS_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 4)

def GetRootAsSCMCOLLECTION(buf:string): return SCMCOLLECTION { buf, flatbuffers.indirect(buf, 0) }

struct SCMCOLLECTIONBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(1)
        return this
    def add_RECORDS(RECORDS:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, RECORDS)
        return this
    def end():
        return b_.EndObject()

def SCMCOLLECTIONStartRECORDSVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SCMCOLLECTIONCreateRECORDSVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

