// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MSTOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Missile Track
pub struct MST<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MST<'a> {
  type Inner = MST<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MST<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_MSG_SUB_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_MSG_CREATE_DATE: flatbuffers::VOffsetT = 10;
  pub const VT_ENVIRONMENT: flatbuffers::VOffsetT = 12;
  pub const VT_OBJ_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_OBJ_TYPE_CONF: flatbuffers::VOffsetT = 16;
  pub const VT_OBJ_PLAT: flatbuffers::VOffsetT = 18;
  pub const VT_OBJ_IDENT: flatbuffers::VOffsetT = 20;
  pub const VT_SPACE_AMP: flatbuffers::VOffsetT = 22;
  pub const VT_OBJ_ACT: flatbuffers::VOffsetT = 24;
  pub const VT_SPACE_SPEC_TYPE: flatbuffers::VOffsetT = 26;
  pub const VT_ACFT_SUB_TYPE: flatbuffers::VOffsetT = 28;
  pub const VT_NAME: flatbuffers::VOffsetT = 30;
  pub const VT_CALL_SIGN: flatbuffers::VOffsetT = 32;
  pub const VT_LOST_TRK_IND: flatbuffers::VOffsetT = 34;
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 36;
  pub const VT_PARENT_TRACK_ID: flatbuffers::VOffsetT = 38;
  pub const VT_MUID_SRC_TRK: flatbuffers::VOffsetT = 40;
  pub const VT_MUID_SRC: flatbuffers::VOffsetT = 42;
  pub const VT_ALERT: flatbuffers::VOffsetT = 44;
  pub const VT_MSL_STATUS: flatbuffers::VOffsetT = 46;
  pub const VT_TS: flatbuffers::VOffsetT = 48;
  pub const VT_AOU_RPT_TYPE: flatbuffers::VOffsetT = 50;
  pub const VT_AOU_RPT_DATA: flatbuffers::VOffsetT = 52;
  pub const VT_CONTAINMENT: flatbuffers::VOffsetT = 54;
  pub const VT_TRK_CONF: flatbuffers::VOffsetT = 56;
  pub const VT_TRK_QUAL: flatbuffers::VOffsetT = 58;
  pub const VT_ANG_ELEV: flatbuffers::VOffsetT = 60;
  pub const VT_SEN_MODE: flatbuffers::VOffsetT = 62;
  pub const VT_INFO_SOURCE: flatbuffers::VOffsetT = 64;
  pub const VT_BOOSTING: flatbuffers::VOffsetT = 66;
  pub const VT_POLAR_SING_LOC_LAT: flatbuffers::VOffsetT = 68;
  pub const VT_POLAR_SING_LOC_LON: flatbuffers::VOffsetT = 70;
  pub const VT_EMG_IND: flatbuffers::VOffsetT = 72;
  pub const VT_DROP_PT_IND: flatbuffers::VOffsetT = 74;
  pub const VT_SPACE_AMP_CONF: flatbuffers::VOffsetT = 76;
  pub const VT_LAUNCH_TIME: flatbuffers::VOffsetT = 78;
  pub const VT_LAUNCH_LAT: flatbuffers::VOffsetT = 80;
  pub const VT_LAUNCH_LON: flatbuffers::VOffsetT = 82;
  pub const VT_AZ_CORR: flatbuffers::VOffsetT = 84;
  pub const VT_BURNOUT_ALT: flatbuffers::VOffsetT = 86;
  pub const VT_LAUNCH_AOU_TYPE: flatbuffers::VOffsetT = 88;
  pub const VT_LAUNCH_AOU_DATA: flatbuffers::VOffsetT = 90;
  pub const VT_IMPACT_TIME: flatbuffers::VOffsetT = 92;
  pub const VT_IMPACT_LAT: flatbuffers::VOffsetT = 94;
  pub const VT_IMPACT_LON: flatbuffers::VOffsetT = 96;
  pub const VT_IMPACT_AOU_TYPE: flatbuffers::VOffsetT = 98;
  pub const VT_IMPACT_AOU_DATA: flatbuffers::VOffsetT = 100;
  pub const VT_VECTORS: flatbuffers::VOffsetT = 102;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MST { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MSTArgs<'args>
  ) -> flatbuffers::WIPOffset<MST<'bldr>> {
    let mut builder = MSTBuilder::new(_fbb);
    builder.add_IMPACT_LON(args.IMPACT_LON);
    builder.add_IMPACT_LAT(args.IMPACT_LAT);
    builder.add_BURNOUT_ALT(args.BURNOUT_ALT);
    builder.add_AZ_CORR(args.AZ_CORR);
    builder.add_LAUNCH_LON(args.LAUNCH_LON);
    builder.add_LAUNCH_LAT(args.LAUNCH_LAT);
    builder.add_POLAR_SING_LOC_LON(args.POLAR_SING_LOC_LON);
    builder.add_POLAR_SING_LOC_LAT(args.POLAR_SING_LOC_LAT);
    builder.add_ANG_ELEV(args.ANG_ELEV);
    builder.add_TRK_CONF(args.TRK_CONF);
    builder.add_CONTAINMENT(args.CONTAINMENT);
    if let Some(x) = args.VECTORS { builder.add_VECTORS(x); }
    if let Some(x) = args.IMPACT_AOU_DATA { builder.add_IMPACT_AOU_DATA(x); }
    if let Some(x) = args.IMPACT_AOU_TYPE { builder.add_IMPACT_AOU_TYPE(x); }
    if let Some(x) = args.IMPACT_TIME { builder.add_IMPACT_TIME(x); }
    if let Some(x) = args.LAUNCH_AOU_DATA { builder.add_LAUNCH_AOU_DATA(x); }
    if let Some(x) = args.LAUNCH_AOU_TYPE { builder.add_LAUNCH_AOU_TYPE(x); }
    if let Some(x) = args.LAUNCH_TIME { builder.add_LAUNCH_TIME(x); }
    builder.add_SPACE_AMP_CONF(args.SPACE_AMP_CONF);
    if let Some(x) = args.INFO_SOURCE { builder.add_INFO_SOURCE(x); }
    if let Some(x) = args.SEN_MODE { builder.add_SEN_MODE(x); }
    builder.add_TRK_QUAL(args.TRK_QUAL);
    if let Some(x) = args.AOU_RPT_DATA { builder.add_AOU_RPT_DATA(x); }
    if let Some(x) = args.AOU_RPT_TYPE { builder.add_AOU_RPT_TYPE(x); }
    if let Some(x) = args.TS { builder.add_TS(x); }
    if let Some(x) = args.MSL_STATUS { builder.add_MSL_STATUS(x); }
    if let Some(x) = args.ALERT { builder.add_ALERT(x); }
    if let Some(x) = args.MUID_SRC { builder.add_MUID_SRC(x); }
    if let Some(x) = args.MUID_SRC_TRK { builder.add_MUID_SRC_TRK(x); }
    if let Some(x) = args.PARENT_TRACK_ID { builder.add_PARENT_TRACK_ID(x); }
    if let Some(x) = args.TRACK_ID { builder.add_TRACK_ID(x); }
    if let Some(x) = args.CALL_SIGN { builder.add_CALL_SIGN(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ACFT_SUB_TYPE { builder.add_ACFT_SUB_TYPE(x); }
    if let Some(x) = args.SPACE_SPEC_TYPE { builder.add_SPACE_SPEC_TYPE(x); }
    if let Some(x) = args.OBJ_ACT { builder.add_OBJ_ACT(x); }
    if let Some(x) = args.SPACE_AMP { builder.add_SPACE_AMP(x); }
    if let Some(x) = args.OBJ_IDENT { builder.add_OBJ_IDENT(x); }
    if let Some(x) = args.OBJ_PLAT { builder.add_OBJ_PLAT(x); }
    builder.add_OBJ_TYPE_CONF(args.OBJ_TYPE_CONF);
    if let Some(x) = args.OBJ_TYPE { builder.add_OBJ_TYPE(x); }
    if let Some(x) = args.ENVIRONMENT { builder.add_ENVIRONMENT(x); }
    if let Some(x) = args.MSG_CREATE_DATE { builder.add_MSG_CREATE_DATE(x); }
    if let Some(x) = args.MSG_SUB_TYPE { builder.add_MSG_SUB_TYPE(x); }
    if let Some(x) = args.MSG_TYPE { builder.add_MSG_TYPE(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_DROP_PT_IND(args.DROP_PT_IND);
    builder.add_EMG_IND(args.EMG_IND);
    builder.add_BOOSTING(args.BOOSTING);
    builder.add_LOST_TRK_IND(args.LOST_TRK_IND);
    builder.finish()
  }

  pub fn unpack(&self) -> MSTT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let MSG_TYPE = self.MSG_TYPE().map(|x| {
      x.to_string()
    });
    let MSG_SUB_TYPE = self.MSG_SUB_TYPE().map(|x| {
      x.to_string()
    });
    let MSG_CREATE_DATE = self.MSG_CREATE_DATE().map(|x| {
      x.to_string()
    });
    let ENVIRONMENT = self.ENVIRONMENT().map(|x| {
      x.to_string()
    });
    let OBJ_TYPE = self.OBJ_TYPE().map(|x| {
      x.to_string()
    });
    let OBJ_TYPE_CONF = self.OBJ_TYPE_CONF();
    let OBJ_PLAT = self.OBJ_PLAT().map(|x| {
      x.to_string()
    });
    let OBJ_IDENT = self.OBJ_IDENT().map(|x| {
      x.to_string()
    });
    let SPACE_AMP = self.SPACE_AMP().map(|x| {
      x.to_string()
    });
    let OBJ_ACT = self.OBJ_ACT().map(|x| {
      x.to_string()
    });
    let SPACE_SPEC_TYPE = self.SPACE_SPEC_TYPE().map(|x| {
      x.to_string()
    });
    let ACFT_SUB_TYPE = self.ACFT_SUB_TYPE().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CALL_SIGN = self.CALL_SIGN().map(|x| {
      x.to_string()
    });
    let LOST_TRK_IND = self.LOST_TRK_IND();
    let TRACK_ID = self.TRACK_ID().map(|x| {
      x.to_string()
    });
    let PARENT_TRACK_ID = self.PARENT_TRACK_ID().map(|x| {
      x.to_string()
    });
    let MUID_SRC_TRK = self.MUID_SRC_TRK().map(|x| {
      x.to_string()
    });
    let MUID_SRC = self.MUID_SRC().map(|x| {
      x.to_string()
    });
    let ALERT = self.ALERT().map(|x| {
      x.to_string()
    });
    let MSL_STATUS = self.MSL_STATUS().map(|x| {
      x.to_string()
    });
    let TS = self.TS().map(|x| {
      x.to_string()
    });
    let AOU_RPT_TYPE = self.AOU_RPT_TYPE().map(|x| {
      x.to_string()
    });
    let AOU_RPT_DATA = self.AOU_RPT_DATA().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let CONTAINMENT = self.CONTAINMENT();
    let TRK_CONF = self.TRK_CONF();
    let TRK_QUAL = self.TRK_QUAL();
    let ANG_ELEV = self.ANG_ELEV();
    let SEN_MODE = self.SEN_MODE().map(|x| {
      x.to_string()
    });
    let INFO_SOURCE = self.INFO_SOURCE().map(|x| {
      x.to_string()
    });
    let BOOSTING = self.BOOSTING();
    let POLAR_SING_LOC_LAT = self.POLAR_SING_LOC_LAT();
    let POLAR_SING_LOC_LON = self.POLAR_SING_LOC_LON();
    let EMG_IND = self.EMG_IND();
    let DROP_PT_IND = self.DROP_PT_IND();
    let SPACE_AMP_CONF = self.SPACE_AMP_CONF();
    let LAUNCH_TIME = self.LAUNCH_TIME().map(|x| {
      x.to_string()
    });
    let LAUNCH_LAT = self.LAUNCH_LAT();
    let LAUNCH_LON = self.LAUNCH_LON();
    let AZ_CORR = self.AZ_CORR();
    let BURNOUT_ALT = self.BURNOUT_ALT();
    let LAUNCH_AOU_TYPE = self.LAUNCH_AOU_TYPE().map(|x| {
      x.to_string()
    });
    let LAUNCH_AOU_DATA = self.LAUNCH_AOU_DATA().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let IMPACT_TIME = self.IMPACT_TIME().map(|x| {
      x.to_string()
    });
    let IMPACT_LAT = self.IMPACT_LAT();
    let IMPACT_LON = self.IMPACT_LON();
    let IMPACT_AOU_TYPE = self.IMPACT_AOU_TYPE().map(|x| {
      x.to_string()
    });
    let IMPACT_AOU_DATA = self.IMPACT_AOU_DATA().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let VECTORS = self.VECTORS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    MSTT {
      ID,
      MSG_TYPE,
      MSG_SUB_TYPE,
      MSG_CREATE_DATE,
      ENVIRONMENT,
      OBJ_TYPE,
      OBJ_TYPE_CONF,
      OBJ_PLAT,
      OBJ_IDENT,
      SPACE_AMP,
      OBJ_ACT,
      SPACE_SPEC_TYPE,
      ACFT_SUB_TYPE,
      NAME,
      CALL_SIGN,
      LOST_TRK_IND,
      TRACK_ID,
      PARENT_TRACK_ID,
      MUID_SRC_TRK,
      MUID_SRC,
      ALERT,
      MSL_STATUS,
      TS,
      AOU_RPT_TYPE,
      AOU_RPT_DATA,
      CONTAINMENT,
      TRK_CONF,
      TRK_QUAL,
      ANG_ELEV,
      SEN_MODE,
      INFO_SOURCE,
      BOOSTING,
      POLAR_SING_LOC_LAT,
      POLAR_SING_LOC_LON,
      EMG_IND,
      DROP_PT_IND,
      SPACE_AMP_CONF,
      LAUNCH_TIME,
      LAUNCH_LAT,
      LAUNCH_LON,
      AZ_CORR,
      BURNOUT_ALT,
      LAUNCH_AOU_TYPE,
      LAUNCH_AOU_DATA,
      IMPACT_TIME,
      IMPACT_LAT,
      IMPACT_LON,
      IMPACT_AOU_TYPE,
      IMPACT_AOU_DATA,
      VECTORS,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_ID, None)}
  }
  #[inline]
  pub fn MSG_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MSG_TYPE, None)}
  }
  #[inline]
  pub fn MSG_SUB_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MSG_SUB_TYPE, None)}
  }
  #[inline]
  pub fn MSG_CREATE_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MSG_CREATE_DATE, None)}
  }
  #[inline]
  pub fn ENVIRONMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_ENVIRONMENT, None)}
  }
  #[inline]
  pub fn OBJ_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_OBJ_TYPE, None)}
  }
  #[inline]
  pub fn OBJ_TYPE_CONF(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MST::VT_OBJ_TYPE_CONF, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OBJ_PLAT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_OBJ_PLAT, None)}
  }
  #[inline]
  pub fn OBJ_IDENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_OBJ_IDENT, None)}
  }
  #[inline]
  pub fn SPACE_AMP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_SPACE_AMP, None)}
  }
  #[inline]
  pub fn OBJ_ACT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_OBJ_ACT, None)}
  }
  #[inline]
  pub fn SPACE_SPEC_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_SPACE_SPEC_TYPE, None)}
  }
  #[inline]
  pub fn ACFT_SUB_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_ACFT_SUB_TYPE, None)}
  }
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_NAME, None)}
  }
  #[inline]
  pub fn CALL_SIGN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_CALL_SIGN, None)}
  }
  #[inline]
  pub fn LOST_TRK_IND(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MST::VT_LOST_TRK_IND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn TRACK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_TRACK_ID, None)}
  }
  #[inline]
  pub fn PARENT_TRACK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_PARENT_TRACK_ID, None)}
  }
  #[inline]
  pub fn MUID_SRC_TRK(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MUID_SRC_TRK, None)}
  }
  #[inline]
  pub fn MUID_SRC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MUID_SRC, None)}
  }
  #[inline]
  pub fn ALERT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_ALERT, None)}
  }
  #[inline]
  pub fn MSL_STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_MSL_STATUS, None)}
  }
  #[inline]
  pub fn TS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_TS, None)}
  }
  #[inline]
  pub fn AOU_RPT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_AOU_RPT_TYPE, None)}
  }
  #[inline]
  pub fn AOU_RPT_DATA(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MST::VT_AOU_RPT_DATA, None)}
  }
  #[inline]
  pub fn CONTAINMENT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_CONTAINMENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TRK_CONF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_TRK_CONF, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TRK_QUAL(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MST::VT_TRK_QUAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ANG_ELEV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_ANG_ELEV, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEN_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_SEN_MODE, None)}
  }
  #[inline]
  pub fn INFO_SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_INFO_SOURCE, None)}
  }
  #[inline]
  pub fn BOOSTING(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MST::VT_BOOSTING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn POLAR_SING_LOC_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_POLAR_SING_LOC_LAT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POLAR_SING_LOC_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_POLAR_SING_LOC_LON, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EMG_IND(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MST::VT_EMG_IND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn DROP_PT_IND(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MST::VT_DROP_PT_IND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SPACE_AMP_CONF(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MST::VT_SPACE_AMP_CONF, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_LAUNCH_TIME, None)}
  }
  #[inline]
  pub fn LAUNCH_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_LAUNCH_LAT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_LAUNCH_LON, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AZ_CORR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_AZ_CORR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BURNOUT_ALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_BURNOUT_ALT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_AOU_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_LAUNCH_AOU_TYPE, None)}
  }
  #[inline]
  pub fn LAUNCH_AOU_DATA(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MST::VT_LAUNCH_AOU_DATA, None)}
  }
  #[inline]
  pub fn IMPACT_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_IMPACT_TIME, None)}
  }
  #[inline]
  pub fn IMPACT_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_IMPACT_LAT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn IMPACT_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MST::VT_IMPACT_LON, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn IMPACT_AOU_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MST::VT_IMPACT_AOU_TYPE, None)}
  }
  #[inline]
  pub fn IMPACT_AOU_DATA(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MST::VT_IMPACT_AOU_DATA, None)}
  }
  #[inline]
  pub fn VECTORS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MST::VT_VECTORS, None)}
  }
}

impl flatbuffers::Verifiable for MST<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_TYPE", Self::VT_MSG_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_SUB_TYPE", Self::VT_MSG_SUB_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_CREATE_DATE", Self::VT_MSG_CREATE_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENVIRONMENT", Self::VT_ENVIRONMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_TYPE", Self::VT_OBJ_TYPE, false)?
     .visit_field::<i32>("OBJ_TYPE_CONF", Self::VT_OBJ_TYPE_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_PLAT", Self::VT_OBJ_PLAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_IDENT", Self::VT_OBJ_IDENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SPACE_AMP", Self::VT_SPACE_AMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_ACT", Self::VT_OBJ_ACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SPACE_SPEC_TYPE", Self::VT_SPACE_SPEC_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ACFT_SUB_TYPE", Self::VT_ACFT_SUB_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CALL_SIGN", Self::VT_CALL_SIGN, false)?
     .visit_field::<bool>("LOST_TRK_IND", Self::VT_LOST_TRK_IND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_ID", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARENT_TRACK_ID", Self::VT_PARENT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MUID_SRC_TRK", Self::VT_MUID_SRC_TRK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MUID_SRC", Self::VT_MUID_SRC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALERT", Self::VT_ALERT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSL_STATUS", Self::VT_MSL_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TS", Self::VT_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AOU_RPT_TYPE", Self::VT_AOU_RPT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("AOU_RPT_DATA", Self::VT_AOU_RPT_DATA, false)?
     .visit_field::<f64>("CONTAINMENT", Self::VT_CONTAINMENT, false)?
     .visit_field::<f64>("TRK_CONF", Self::VT_TRK_CONF, false)?
     .visit_field::<i32>("TRK_QUAL", Self::VT_TRK_QUAL, false)?
     .visit_field::<f64>("ANG_ELEV", Self::VT_ANG_ELEV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_MODE", Self::VT_SEN_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INFO_SOURCE", Self::VT_INFO_SOURCE, false)?
     .visit_field::<bool>("BOOSTING", Self::VT_BOOSTING, false)?
     .visit_field::<f64>("POLAR_SING_LOC_LAT", Self::VT_POLAR_SING_LOC_LAT, false)?
     .visit_field::<f64>("POLAR_SING_LOC_LON", Self::VT_POLAR_SING_LOC_LON, false)?
     .visit_field::<bool>("EMG_IND", Self::VT_EMG_IND, false)?
     .visit_field::<bool>("DROP_PT_IND", Self::VT_DROP_PT_IND, false)?
     .visit_field::<i32>("SPACE_AMP_CONF", Self::VT_SPACE_AMP_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_TIME", Self::VT_LAUNCH_TIME, false)?
     .visit_field::<f64>("LAUNCH_LAT", Self::VT_LAUNCH_LAT, false)?
     .visit_field::<f64>("LAUNCH_LON", Self::VT_LAUNCH_LON, false)?
     .visit_field::<f64>("AZ_CORR", Self::VT_AZ_CORR, false)?
     .visit_field::<f64>("BURNOUT_ALT", Self::VT_BURNOUT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_AOU_TYPE", Self::VT_LAUNCH_AOU_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LAUNCH_AOU_DATA", Self::VT_LAUNCH_AOU_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMPACT_TIME", Self::VT_IMPACT_TIME, false)?
     .visit_field::<f64>("IMPACT_LAT", Self::VT_IMPACT_LAT, false)?
     .visit_field::<f64>("IMPACT_LON", Self::VT_IMPACT_LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMPACT_AOU_TYPE", Self::VT_IMPACT_AOU_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("IMPACT_AOU_DATA", Self::VT_IMPACT_AOU_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("VECTORS", Self::VT_VECTORS, false)?
     .finish();
    Ok(())
  }
}
pub struct MSTArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_SUB_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_CREATE_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENVIRONMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_TYPE_CONF: i32,
    pub OBJ_PLAT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_IDENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SPACE_AMP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_ACT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SPACE_SPEC_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ACFT_SUB_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CALL_SIGN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOST_TRK_IND: bool,
    pub TRACK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARENT_TRACK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MUID_SRC_TRK: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MUID_SRC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALERT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSL_STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AOU_RPT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AOU_RPT_DATA: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub CONTAINMENT: f64,
    pub TRK_CONF: f64,
    pub TRK_QUAL: i32,
    pub ANG_ELEV: f64,
    pub SEN_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INFO_SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BOOSTING: bool,
    pub POLAR_SING_LOC_LAT: f64,
    pub POLAR_SING_LOC_LON: f64,
    pub EMG_IND: bool,
    pub DROP_PT_IND: bool,
    pub SPACE_AMP_CONF: i32,
    pub LAUNCH_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_LAT: f64,
    pub LAUNCH_LON: f64,
    pub AZ_CORR: f64,
    pub BURNOUT_ALT: f64,
    pub LAUNCH_AOU_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_AOU_DATA: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub IMPACT_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMPACT_LAT: f64,
    pub IMPACT_LON: f64,
    pub IMPACT_AOU_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMPACT_AOU_DATA: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub VECTORS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MSTArgs<'a> {
  #[inline]
  fn default() -> Self {
    MSTArgs {
      ID: None,
      MSG_TYPE: None,
      MSG_SUB_TYPE: None,
      MSG_CREATE_DATE: None,
      ENVIRONMENT: None,
      OBJ_TYPE: None,
      OBJ_TYPE_CONF: 0,
      OBJ_PLAT: None,
      OBJ_IDENT: None,
      SPACE_AMP: None,
      OBJ_ACT: None,
      SPACE_SPEC_TYPE: None,
      ACFT_SUB_TYPE: None,
      NAME: None,
      CALL_SIGN: None,
      LOST_TRK_IND: false,
      TRACK_ID: None,
      PARENT_TRACK_ID: None,
      MUID_SRC_TRK: None,
      MUID_SRC: None,
      ALERT: None,
      MSL_STATUS: None,
      TS: None,
      AOU_RPT_TYPE: None,
      AOU_RPT_DATA: None,
      CONTAINMENT: 0.0,
      TRK_CONF: 0.0,
      TRK_QUAL: 0,
      ANG_ELEV: 0.0,
      SEN_MODE: None,
      INFO_SOURCE: None,
      BOOSTING: false,
      POLAR_SING_LOC_LAT: 0.0,
      POLAR_SING_LOC_LON: 0.0,
      EMG_IND: false,
      DROP_PT_IND: false,
      SPACE_AMP_CONF: 0,
      LAUNCH_TIME: None,
      LAUNCH_LAT: 0.0,
      LAUNCH_LON: 0.0,
      AZ_CORR: 0.0,
      BURNOUT_ALT: 0.0,
      LAUNCH_AOU_TYPE: None,
      LAUNCH_AOU_DATA: None,
      IMPACT_TIME: None,
      IMPACT_LAT: 0.0,
      IMPACT_LON: 0.0,
      IMPACT_AOU_TYPE: None,
      IMPACT_AOU_DATA: None,
      VECTORS: None,
    }
  }
}

pub struct MSTBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MSTBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_ID, ID);
  }
  #[inline]
  pub fn add_MSG_TYPE(&mut self, MSG_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MSG_TYPE, MSG_TYPE);
  }
  #[inline]
  pub fn add_MSG_SUB_TYPE(&mut self, MSG_SUB_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MSG_SUB_TYPE, MSG_SUB_TYPE);
  }
  #[inline]
  pub fn add_MSG_CREATE_DATE(&mut self, MSG_CREATE_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MSG_CREATE_DATE, MSG_CREATE_DATE);
  }
  #[inline]
  pub fn add_ENVIRONMENT(&mut self, ENVIRONMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_ENVIRONMENT, ENVIRONMENT);
  }
  #[inline]
  pub fn add_OBJ_TYPE(&mut self, OBJ_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_OBJ_TYPE, OBJ_TYPE);
  }
  #[inline]
  pub fn add_OBJ_TYPE_CONF(&mut self, OBJ_TYPE_CONF: i32) {
    self.fbb_.push_slot::<i32>(MST::VT_OBJ_TYPE_CONF, OBJ_TYPE_CONF, 0);
  }
  #[inline]
  pub fn add_OBJ_PLAT(&mut self, OBJ_PLAT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_OBJ_PLAT, OBJ_PLAT);
  }
  #[inline]
  pub fn add_OBJ_IDENT(&mut self, OBJ_IDENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_OBJ_IDENT, OBJ_IDENT);
  }
  #[inline]
  pub fn add_SPACE_AMP(&mut self, SPACE_AMP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_SPACE_AMP, SPACE_AMP);
  }
  #[inline]
  pub fn add_OBJ_ACT(&mut self, OBJ_ACT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_OBJ_ACT, OBJ_ACT);
  }
  #[inline]
  pub fn add_SPACE_SPEC_TYPE(&mut self, SPACE_SPEC_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_SPACE_SPEC_TYPE, SPACE_SPEC_TYPE);
  }
  #[inline]
  pub fn add_ACFT_SUB_TYPE(&mut self, ACFT_SUB_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_ACFT_SUB_TYPE, ACFT_SUB_TYPE);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CALL_SIGN(&mut self, CALL_SIGN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_CALL_SIGN, CALL_SIGN);
  }
  #[inline]
  pub fn add_LOST_TRK_IND(&mut self, LOST_TRK_IND: bool) {
    self.fbb_.push_slot::<bool>(MST::VT_LOST_TRK_IND, LOST_TRK_IND, false);
  }
  #[inline]
  pub fn add_TRACK_ID(&mut self, TRACK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_TRACK_ID, TRACK_ID);
  }
  #[inline]
  pub fn add_PARENT_TRACK_ID(&mut self, PARENT_TRACK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_PARENT_TRACK_ID, PARENT_TRACK_ID);
  }
  #[inline]
  pub fn add_MUID_SRC_TRK(&mut self, MUID_SRC_TRK: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MUID_SRC_TRK, MUID_SRC_TRK);
  }
  #[inline]
  pub fn add_MUID_SRC(&mut self, MUID_SRC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MUID_SRC, MUID_SRC);
  }
  #[inline]
  pub fn add_ALERT(&mut self, ALERT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_ALERT, ALERT);
  }
  #[inline]
  pub fn add_MSL_STATUS(&mut self, MSL_STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_MSL_STATUS, MSL_STATUS);
  }
  #[inline]
  pub fn add_TS(&mut self, TS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_TS, TS);
  }
  #[inline]
  pub fn add_AOU_RPT_TYPE(&mut self, AOU_RPT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_AOU_RPT_TYPE, AOU_RPT_TYPE);
  }
  #[inline]
  pub fn add_AOU_RPT_DATA(&mut self, AOU_RPT_DATA: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_AOU_RPT_DATA, AOU_RPT_DATA);
  }
  #[inline]
  pub fn add_CONTAINMENT(&mut self, CONTAINMENT: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_CONTAINMENT, CONTAINMENT, 0.0);
  }
  #[inline]
  pub fn add_TRK_CONF(&mut self, TRK_CONF: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_TRK_CONF, TRK_CONF, 0.0);
  }
  #[inline]
  pub fn add_TRK_QUAL(&mut self, TRK_QUAL: i32) {
    self.fbb_.push_slot::<i32>(MST::VT_TRK_QUAL, TRK_QUAL, 0);
  }
  #[inline]
  pub fn add_ANG_ELEV(&mut self, ANG_ELEV: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_ANG_ELEV, ANG_ELEV, 0.0);
  }
  #[inline]
  pub fn add_SEN_MODE(&mut self, SEN_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_SEN_MODE, SEN_MODE);
  }
  #[inline]
  pub fn add_INFO_SOURCE(&mut self, INFO_SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_INFO_SOURCE, INFO_SOURCE);
  }
  #[inline]
  pub fn add_BOOSTING(&mut self, BOOSTING: bool) {
    self.fbb_.push_slot::<bool>(MST::VT_BOOSTING, BOOSTING, false);
  }
  #[inline]
  pub fn add_POLAR_SING_LOC_LAT(&mut self, POLAR_SING_LOC_LAT: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_POLAR_SING_LOC_LAT, POLAR_SING_LOC_LAT, 0.0);
  }
  #[inline]
  pub fn add_POLAR_SING_LOC_LON(&mut self, POLAR_SING_LOC_LON: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_POLAR_SING_LOC_LON, POLAR_SING_LOC_LON, 0.0);
  }
  #[inline]
  pub fn add_EMG_IND(&mut self, EMG_IND: bool) {
    self.fbb_.push_slot::<bool>(MST::VT_EMG_IND, EMG_IND, false);
  }
  #[inline]
  pub fn add_DROP_PT_IND(&mut self, DROP_PT_IND: bool) {
    self.fbb_.push_slot::<bool>(MST::VT_DROP_PT_IND, DROP_PT_IND, false);
  }
  #[inline]
  pub fn add_SPACE_AMP_CONF(&mut self, SPACE_AMP_CONF: i32) {
    self.fbb_.push_slot::<i32>(MST::VT_SPACE_AMP_CONF, SPACE_AMP_CONF, 0);
  }
  #[inline]
  pub fn add_LAUNCH_TIME(&mut self, LAUNCH_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_LAUNCH_TIME, LAUNCH_TIME);
  }
  #[inline]
  pub fn add_LAUNCH_LAT(&mut self, LAUNCH_LAT: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_LAUNCH_LAT, LAUNCH_LAT, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_LON(&mut self, LAUNCH_LON: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_LAUNCH_LON, LAUNCH_LON, 0.0);
  }
  #[inline]
  pub fn add_AZ_CORR(&mut self, AZ_CORR: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_AZ_CORR, AZ_CORR, 0.0);
  }
  #[inline]
  pub fn add_BURNOUT_ALT(&mut self, BURNOUT_ALT: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_BURNOUT_ALT, BURNOUT_ALT, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_AOU_TYPE(&mut self, LAUNCH_AOU_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_LAUNCH_AOU_TYPE, LAUNCH_AOU_TYPE);
  }
  #[inline]
  pub fn add_LAUNCH_AOU_DATA(&mut self, LAUNCH_AOU_DATA: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_LAUNCH_AOU_DATA, LAUNCH_AOU_DATA);
  }
  #[inline]
  pub fn add_IMPACT_TIME(&mut self, IMPACT_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_IMPACT_TIME, IMPACT_TIME);
  }
  #[inline]
  pub fn add_IMPACT_LAT(&mut self, IMPACT_LAT: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_IMPACT_LAT, IMPACT_LAT, 0.0);
  }
  #[inline]
  pub fn add_IMPACT_LON(&mut self, IMPACT_LON: f64) {
    self.fbb_.push_slot::<f64>(MST::VT_IMPACT_LON, IMPACT_LON, 0.0);
  }
  #[inline]
  pub fn add_IMPACT_AOU_TYPE(&mut self, IMPACT_AOU_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_IMPACT_AOU_TYPE, IMPACT_AOU_TYPE);
  }
  #[inline]
  pub fn add_IMPACT_AOU_DATA(&mut self, IMPACT_AOU_DATA: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_IMPACT_AOU_DATA, IMPACT_AOU_DATA);
  }
  #[inline]
  pub fn add_VECTORS(&mut self, VECTORS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MST::VT_VECTORS, VECTORS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MSTBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MSTBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MST<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MST<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MST");
      ds.field("ID", &self.ID());
      ds.field("MSG_TYPE", &self.MSG_TYPE());
      ds.field("MSG_SUB_TYPE", &self.MSG_SUB_TYPE());
      ds.field("MSG_CREATE_DATE", &self.MSG_CREATE_DATE());
      ds.field("ENVIRONMENT", &self.ENVIRONMENT());
      ds.field("OBJ_TYPE", &self.OBJ_TYPE());
      ds.field("OBJ_TYPE_CONF", &self.OBJ_TYPE_CONF());
      ds.field("OBJ_PLAT", &self.OBJ_PLAT());
      ds.field("OBJ_IDENT", &self.OBJ_IDENT());
      ds.field("SPACE_AMP", &self.SPACE_AMP());
      ds.field("OBJ_ACT", &self.OBJ_ACT());
      ds.field("SPACE_SPEC_TYPE", &self.SPACE_SPEC_TYPE());
      ds.field("ACFT_SUB_TYPE", &self.ACFT_SUB_TYPE());
      ds.field("NAME", &self.NAME());
      ds.field("CALL_SIGN", &self.CALL_SIGN());
      ds.field("LOST_TRK_IND", &self.LOST_TRK_IND());
      ds.field("TRACK_ID", &self.TRACK_ID());
      ds.field("PARENT_TRACK_ID", &self.PARENT_TRACK_ID());
      ds.field("MUID_SRC_TRK", &self.MUID_SRC_TRK());
      ds.field("MUID_SRC", &self.MUID_SRC());
      ds.field("ALERT", &self.ALERT());
      ds.field("MSL_STATUS", &self.MSL_STATUS());
      ds.field("TS", &self.TS());
      ds.field("AOU_RPT_TYPE", &self.AOU_RPT_TYPE());
      ds.field("AOU_RPT_DATA", &self.AOU_RPT_DATA());
      ds.field("CONTAINMENT", &self.CONTAINMENT());
      ds.field("TRK_CONF", &self.TRK_CONF());
      ds.field("TRK_QUAL", &self.TRK_QUAL());
      ds.field("ANG_ELEV", &self.ANG_ELEV());
      ds.field("SEN_MODE", &self.SEN_MODE());
      ds.field("INFO_SOURCE", &self.INFO_SOURCE());
      ds.field("BOOSTING", &self.BOOSTING());
      ds.field("POLAR_SING_LOC_LAT", &self.POLAR_SING_LOC_LAT());
      ds.field("POLAR_SING_LOC_LON", &self.POLAR_SING_LOC_LON());
      ds.field("EMG_IND", &self.EMG_IND());
      ds.field("DROP_PT_IND", &self.DROP_PT_IND());
      ds.field("SPACE_AMP_CONF", &self.SPACE_AMP_CONF());
      ds.field("LAUNCH_TIME", &self.LAUNCH_TIME());
      ds.field("LAUNCH_LAT", &self.LAUNCH_LAT());
      ds.field("LAUNCH_LON", &self.LAUNCH_LON());
      ds.field("AZ_CORR", &self.AZ_CORR());
      ds.field("BURNOUT_ALT", &self.BURNOUT_ALT());
      ds.field("LAUNCH_AOU_TYPE", &self.LAUNCH_AOU_TYPE());
      ds.field("LAUNCH_AOU_DATA", &self.LAUNCH_AOU_DATA());
      ds.field("IMPACT_TIME", &self.IMPACT_TIME());
      ds.field("IMPACT_LAT", &self.IMPACT_LAT());
      ds.field("IMPACT_LON", &self.IMPACT_LON());
      ds.field("IMPACT_AOU_TYPE", &self.IMPACT_AOU_TYPE());
      ds.field("IMPACT_AOU_DATA", &self.IMPACT_AOU_DATA());
      ds.field("VECTORS", &self.VECTORS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MSTT {
  pub ID: Option<String>,
  pub MSG_TYPE: Option<String>,
  pub MSG_SUB_TYPE: Option<String>,
  pub MSG_CREATE_DATE: Option<String>,
  pub ENVIRONMENT: Option<String>,
  pub OBJ_TYPE: Option<String>,
  pub OBJ_TYPE_CONF: i32,
  pub OBJ_PLAT: Option<String>,
  pub OBJ_IDENT: Option<String>,
  pub SPACE_AMP: Option<String>,
  pub OBJ_ACT: Option<String>,
  pub SPACE_SPEC_TYPE: Option<String>,
  pub ACFT_SUB_TYPE: Option<String>,
  pub NAME: Option<String>,
  pub CALL_SIGN: Option<String>,
  pub LOST_TRK_IND: bool,
  pub TRACK_ID: Option<String>,
  pub PARENT_TRACK_ID: Option<String>,
  pub MUID_SRC_TRK: Option<String>,
  pub MUID_SRC: Option<String>,
  pub ALERT: Option<String>,
  pub MSL_STATUS: Option<String>,
  pub TS: Option<String>,
  pub AOU_RPT_TYPE: Option<String>,
  pub AOU_RPT_DATA: Option<Vec<String>>,
  pub CONTAINMENT: f64,
  pub TRK_CONF: f64,
  pub TRK_QUAL: i32,
  pub ANG_ELEV: f64,
  pub SEN_MODE: Option<String>,
  pub INFO_SOURCE: Option<String>,
  pub BOOSTING: bool,
  pub POLAR_SING_LOC_LAT: f64,
  pub POLAR_SING_LOC_LON: f64,
  pub EMG_IND: bool,
  pub DROP_PT_IND: bool,
  pub SPACE_AMP_CONF: i32,
  pub LAUNCH_TIME: Option<String>,
  pub LAUNCH_LAT: f64,
  pub LAUNCH_LON: f64,
  pub AZ_CORR: f64,
  pub BURNOUT_ALT: f64,
  pub LAUNCH_AOU_TYPE: Option<String>,
  pub LAUNCH_AOU_DATA: Option<Vec<String>>,
  pub IMPACT_TIME: Option<String>,
  pub IMPACT_LAT: f64,
  pub IMPACT_LON: f64,
  pub IMPACT_AOU_TYPE: Option<String>,
  pub IMPACT_AOU_DATA: Option<Vec<String>>,
  pub VECTORS: Option<Vec<String>>,
}
impl Default for MSTT {
  fn default() -> Self {
    Self {
      ID: None,
      MSG_TYPE: None,
      MSG_SUB_TYPE: None,
      MSG_CREATE_DATE: None,
      ENVIRONMENT: None,
      OBJ_TYPE: None,
      OBJ_TYPE_CONF: 0,
      OBJ_PLAT: None,
      OBJ_IDENT: None,
      SPACE_AMP: None,
      OBJ_ACT: None,
      SPACE_SPEC_TYPE: None,
      ACFT_SUB_TYPE: None,
      NAME: None,
      CALL_SIGN: None,
      LOST_TRK_IND: false,
      TRACK_ID: None,
      PARENT_TRACK_ID: None,
      MUID_SRC_TRK: None,
      MUID_SRC: None,
      ALERT: None,
      MSL_STATUS: None,
      TS: None,
      AOU_RPT_TYPE: None,
      AOU_RPT_DATA: None,
      CONTAINMENT: 0.0,
      TRK_CONF: 0.0,
      TRK_QUAL: 0,
      ANG_ELEV: 0.0,
      SEN_MODE: None,
      INFO_SOURCE: None,
      BOOSTING: false,
      POLAR_SING_LOC_LAT: 0.0,
      POLAR_SING_LOC_LON: 0.0,
      EMG_IND: false,
      DROP_PT_IND: false,
      SPACE_AMP_CONF: 0,
      LAUNCH_TIME: None,
      LAUNCH_LAT: 0.0,
      LAUNCH_LON: 0.0,
      AZ_CORR: 0.0,
      BURNOUT_ALT: 0.0,
      LAUNCH_AOU_TYPE: None,
      LAUNCH_AOU_DATA: None,
      IMPACT_TIME: None,
      IMPACT_LAT: 0.0,
      IMPACT_LON: 0.0,
      IMPACT_AOU_TYPE: None,
      IMPACT_AOU_DATA: None,
      VECTORS: None,
    }
  }
}
impl MSTT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MST<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_TYPE = self.MSG_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_SUB_TYPE = self.MSG_SUB_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_CREATE_DATE = self.MSG_CREATE_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENVIRONMENT = self.ENVIRONMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_TYPE = self.OBJ_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_TYPE_CONF = self.OBJ_TYPE_CONF;
    let OBJ_PLAT = self.OBJ_PLAT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_IDENT = self.OBJ_IDENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SPACE_AMP = self.SPACE_AMP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_ACT = self.OBJ_ACT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SPACE_SPEC_TYPE = self.SPACE_SPEC_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ACFT_SUB_TYPE = self.ACFT_SUB_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CALL_SIGN = self.CALL_SIGN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOST_TRK_IND = self.LOST_TRK_IND;
    let TRACK_ID = self.TRACK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARENT_TRACK_ID = self.PARENT_TRACK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MUID_SRC_TRK = self.MUID_SRC_TRK.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MUID_SRC = self.MUID_SRC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALERT = self.ALERT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSL_STATUS = self.MSL_STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TS = self.TS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AOU_RPT_TYPE = self.AOU_RPT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AOU_RPT_DATA = self.AOU_RPT_DATA.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let CONTAINMENT = self.CONTAINMENT;
    let TRK_CONF = self.TRK_CONF;
    let TRK_QUAL = self.TRK_QUAL;
    let ANG_ELEV = self.ANG_ELEV;
    let SEN_MODE = self.SEN_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INFO_SOURCE = self.INFO_SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BOOSTING = self.BOOSTING;
    let POLAR_SING_LOC_LAT = self.POLAR_SING_LOC_LAT;
    let POLAR_SING_LOC_LON = self.POLAR_SING_LOC_LON;
    let EMG_IND = self.EMG_IND;
    let DROP_PT_IND = self.DROP_PT_IND;
    let SPACE_AMP_CONF = self.SPACE_AMP_CONF;
    let LAUNCH_TIME = self.LAUNCH_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_LAT = self.LAUNCH_LAT;
    let LAUNCH_LON = self.LAUNCH_LON;
    let AZ_CORR = self.AZ_CORR;
    let BURNOUT_ALT = self.BURNOUT_ALT;
    let LAUNCH_AOU_TYPE = self.LAUNCH_AOU_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_AOU_DATA = self.LAUNCH_AOU_DATA.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let IMPACT_TIME = self.IMPACT_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMPACT_LAT = self.IMPACT_LAT;
    let IMPACT_LON = self.IMPACT_LON;
    let IMPACT_AOU_TYPE = self.IMPACT_AOU_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMPACT_AOU_DATA = self.IMPACT_AOU_DATA.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let VECTORS = self.VECTORS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MST::create(_fbb, &MSTArgs{
      ID,
      MSG_TYPE,
      MSG_SUB_TYPE,
      MSG_CREATE_DATE,
      ENVIRONMENT,
      OBJ_TYPE,
      OBJ_TYPE_CONF,
      OBJ_PLAT,
      OBJ_IDENT,
      SPACE_AMP,
      OBJ_ACT,
      SPACE_SPEC_TYPE,
      ACFT_SUB_TYPE,
      NAME,
      CALL_SIGN,
      LOST_TRK_IND,
      TRACK_ID,
      PARENT_TRACK_ID,
      MUID_SRC_TRK,
      MUID_SRC,
      ALERT,
      MSL_STATUS,
      TS,
      AOU_RPT_TYPE,
      AOU_RPT_DATA,
      CONTAINMENT,
      TRK_CONF,
      TRK_QUAL,
      ANG_ELEV,
      SEN_MODE,
      INFO_SOURCE,
      BOOSTING,
      POLAR_SING_LOC_LAT,
      POLAR_SING_LOC_LON,
      EMG_IND,
      DROP_PT_IND,
      SPACE_AMP_CONF,
      LAUNCH_TIME,
      LAUNCH_LAT,
      LAUNCH_LON,
      AZ_CORR,
      BURNOUT_ALT,
      LAUNCH_AOU_TYPE,
      LAUNCH_AOU_DATA,
      IMPACT_TIME,
      IMPACT_LAT,
      IMPACT_LON,
      IMPACT_AOU_TYPE,
      IMPACT_AOU_DATA,
      VECTORS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MST`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MST_unchecked`.
pub fn root_as_MST(buf: &[u8]) -> Result<MST, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MST>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MST` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_MST_unchecked`.
pub fn size_prefixed_root_as_MST(buf: &[u8]) -> Result<MST, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MST>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MST` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MST_unchecked`.
pub fn root_as_MST_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MST<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MST<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MST` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MST_unchecked`.
pub fn size_prefixed_root_as_MST_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MST<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MST<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MST and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MST`.
pub unsafe fn root_as_MST_unchecked(buf: &[u8]) -> MST {
  flatbuffers::root_unchecked::<MST>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MST and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MST`.
pub unsafe fn size_prefixed_root_as_MST_unchecked(buf: &[u8]) -> MST {
  flatbuffers::size_prefixed_root_unchecked::<MST>(buf)
}
pub const MST_IDENTIFIER: &str = "$MST";

#[inline]
pub fn MST_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MST_IDENTIFIER, false)
}

#[inline]
pub fn MST_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MST_IDENTIFIER, true)
}

#[inline]
pub fn finish_MST_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MST<'a>>) {
  fbb.finish(root, Some(MST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_MST_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MST<'a>>) {
  fbb.finish_size_prefixed(root, Some(MST_IDENTIFIER));
}
