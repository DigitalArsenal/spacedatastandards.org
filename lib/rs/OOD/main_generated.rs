// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OODOffset {}
#[derive(Copy, Clone, PartialEq)]

/// On-Orbit Object Details
pub struct OOD<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OOD<'a> {
  type Inner = OOD<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OOD<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LAST_OB_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_VISMAG: flatbuffers::VOffsetT = 8;
  pub const VT_VISMAG_MIN: flatbuffers::VOffsetT = 10;
  pub const VT_VISMAG_MAX: flatbuffers::VOffsetT = 12;
  pub const VT_VISMAG_MEAN: flatbuffers::VOffsetT = 14;
  pub const VT_RCS: flatbuffers::VOffsetT = 16;
  pub const VT_RCS_MIN: flatbuffers::VOffsetT = 18;
  pub const VT_RCS_MAX: flatbuffers::VOffsetT = 20;
  pub const VT_RCS_MEAN: flatbuffers::VOffsetT = 22;
  pub const VT_BOL_DELTA_V: flatbuffers::VOffsetT = 24;
  pub const VT_MAX_DELTA_V: flatbuffers::VOffsetT = 26;
  pub const VT_DELTA_VUNC: flatbuffers::VOffsetT = 28;
  pub const VT_EST_DELTA_VDURATION: flatbuffers::VOffsetT = 30;
  pub const VT_NUM_MISSION: flatbuffers::VOffsetT = 32;
  pub const VT_MISSION_TYPES: flatbuffers::VOffsetT = 34;
  pub const VT_BUS_TYPE: flatbuffers::VOffsetT = 36;
  pub const VT_GEO_SLOT: flatbuffers::VOffsetT = 38;
  pub const VT_DRIFT_RATE: flatbuffers::VOffsetT = 40;
  pub const VT_DRY_MASS: flatbuffers::VOffsetT = 42;
  pub const VT_ADDITIONAL_MASS: flatbuffers::VOffsetT = 44;
  pub const VT_LAUNCH_MASS_MIN: flatbuffers::VOffsetT = 46;
  pub const VT_LAUNCH_MASS: flatbuffers::VOffsetT = 48;
  pub const VT_LAUNCH_MASS_MAX: flatbuffers::VOffsetT = 50;
  pub const VT_BOL_FUEL_MASS: flatbuffers::VOffsetT = 52;
  pub const VT_CURRENT_MASS: flatbuffers::VOffsetT = 54;
  pub const VT_TOTAL_MASS_UNC: flatbuffers::VOffsetT = 56;
  pub const VT_SOLAR_ARRAY_AREA: flatbuffers::VOffsetT = 58;
  pub const VT_MANEUVERABLE: flatbuffers::VOffsetT = 60;
  pub const VT_FUEL_REMAINING: flatbuffers::VOffsetT = 62;
  pub const VT_CROSS_SECTION: flatbuffers::VOffsetT = 64;
  pub const VT_BUS_CROSS_SECTION: flatbuffers::VOffsetT = 66;
  pub const VT_MAX_RADIUS: flatbuffers::VOffsetT = 68;
  pub const VT_COLA_RADIUS: flatbuffers::VOffsetT = 70;
  pub const VT_ADEPT_RADIUS: flatbuffers::VOffsetT = 72;
  pub const VT_NUM_DEPLOYABLE: flatbuffers::VOffsetT = 74;
  pub const VT_DEP_NAMES: flatbuffers::VOffsetT = 76;
  pub const VT_DEP_EST_MASSES: flatbuffers::VOffsetT = 78;
  pub const VT_DEP_MASS_UNCS: flatbuffers::VOffsetT = 80;
  pub const VT_LAST_OB_SOURCE: flatbuffers::VOffsetT = 82;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OOD { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OODArgs<'args>
  ) -> flatbuffers::WIPOffset<OOD<'bldr>> {
    let mut builder = OODBuilder::new(_fbb);
    builder.add_ADEPT_RADIUS(args.ADEPT_RADIUS);
    builder.add_COLA_RADIUS(args.COLA_RADIUS);
    builder.add_MAX_RADIUS(args.MAX_RADIUS);
    builder.add_BUS_CROSS_SECTION(args.BUS_CROSS_SECTION);
    builder.add_CROSS_SECTION(args.CROSS_SECTION);
    builder.add_FUEL_REMAINING(args.FUEL_REMAINING);
    builder.add_SOLAR_ARRAY_AREA(args.SOLAR_ARRAY_AREA);
    builder.add_TOTAL_MASS_UNC(args.TOTAL_MASS_UNC);
    builder.add_CURRENT_MASS(args.CURRENT_MASS);
    builder.add_BOL_FUEL_MASS(args.BOL_FUEL_MASS);
    builder.add_LAUNCH_MASS_MAX(args.LAUNCH_MASS_MAX);
    builder.add_LAUNCH_MASS(args.LAUNCH_MASS);
    builder.add_LAUNCH_MASS_MIN(args.LAUNCH_MASS_MIN);
    builder.add_ADDITIONAL_MASS(args.ADDITIONAL_MASS);
    builder.add_DRY_MASS(args.DRY_MASS);
    builder.add_DRIFT_RATE(args.DRIFT_RATE);
    builder.add_GEO_SLOT(args.GEO_SLOT);
    builder.add_EST_DELTA_VDURATION(args.EST_DELTA_VDURATION);
    builder.add_DELTA_VUNC(args.DELTA_VUNC);
    builder.add_MAX_DELTA_V(args.MAX_DELTA_V);
    builder.add_BOL_DELTA_V(args.BOL_DELTA_V);
    builder.add_RCS_MEAN(args.RCS_MEAN);
    builder.add_RCS_MAX(args.RCS_MAX);
    builder.add_RCS_MIN(args.RCS_MIN);
    builder.add_RCS(args.RCS);
    builder.add_VISMAG_MEAN(args.VISMAG_MEAN);
    builder.add_VISMAG_MAX(args.VISMAG_MAX);
    builder.add_VISMAG_MIN(args.VISMAG_MIN);
    builder.add_VISMAG(args.VISMAG);
    if let Some(x) = args.LAST_OB_SOURCE { builder.add_LAST_OB_SOURCE(x); }
    if let Some(x) = args.DEP_MASS_UNCS { builder.add_DEP_MASS_UNCS(x); }
    if let Some(x) = args.DEP_EST_MASSES { builder.add_DEP_EST_MASSES(x); }
    if let Some(x) = args.DEP_NAMES { builder.add_DEP_NAMES(x); }
    builder.add_NUM_DEPLOYABLE(args.NUM_DEPLOYABLE);
    if let Some(x) = args.BUS_TYPE { builder.add_BUS_TYPE(x); }
    if let Some(x) = args.MISSION_TYPES { builder.add_MISSION_TYPES(x); }
    builder.add_NUM_MISSION(args.NUM_MISSION);
    if let Some(x) = args.LAST_OB_TIME { builder.add_LAST_OB_TIME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_MANEUVERABLE(args.MANEUVERABLE);
    builder.finish()
  }

  pub fn unpack(&self) -> OODT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let LAST_OB_TIME = self.LAST_OB_TIME().map(|x| {
      x.to_string()
    });
    let VISMAG = self.VISMAG();
    let VISMAG_MIN = self.VISMAG_MIN();
    let VISMAG_MAX = self.VISMAG_MAX();
    let VISMAG_MEAN = self.VISMAG_MEAN();
    let RCS = self.RCS();
    let RCS_MIN = self.RCS_MIN();
    let RCS_MAX = self.RCS_MAX();
    let RCS_MEAN = self.RCS_MEAN();
    let BOL_DELTA_V = self.BOL_DELTA_V();
    let MAX_DELTA_V = self.MAX_DELTA_V();
    let DELTA_VUNC = self.DELTA_VUNC();
    let EST_DELTA_VDURATION = self.EST_DELTA_VDURATION();
    let NUM_MISSION = self.NUM_MISSION();
    let MISSION_TYPES = self.MISSION_TYPES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let BUS_TYPE = self.BUS_TYPE().map(|x| {
      x.to_string()
    });
    let GEO_SLOT = self.GEO_SLOT();
    let DRIFT_RATE = self.DRIFT_RATE();
    let DRY_MASS = self.DRY_MASS();
    let ADDITIONAL_MASS = self.ADDITIONAL_MASS();
    let LAUNCH_MASS_MIN = self.LAUNCH_MASS_MIN();
    let LAUNCH_MASS = self.LAUNCH_MASS();
    let LAUNCH_MASS_MAX = self.LAUNCH_MASS_MAX();
    let BOL_FUEL_MASS = self.BOL_FUEL_MASS();
    let CURRENT_MASS = self.CURRENT_MASS();
    let TOTAL_MASS_UNC = self.TOTAL_MASS_UNC();
    let SOLAR_ARRAY_AREA = self.SOLAR_ARRAY_AREA();
    let MANEUVERABLE = self.MANEUVERABLE();
    let FUEL_REMAINING = self.FUEL_REMAINING();
    let CROSS_SECTION = self.CROSS_SECTION();
    let BUS_CROSS_SECTION = self.BUS_CROSS_SECTION();
    let MAX_RADIUS = self.MAX_RADIUS();
    let COLA_RADIUS = self.COLA_RADIUS();
    let ADEPT_RADIUS = self.ADEPT_RADIUS();
    let NUM_DEPLOYABLE = self.NUM_DEPLOYABLE();
    let DEP_NAMES = self.DEP_NAMES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DEP_EST_MASSES = self.DEP_EST_MASSES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DEP_MASS_UNCS = self.DEP_MASS_UNCS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let LAST_OB_SOURCE = self.LAST_OB_SOURCE().map(|x| {
      x.to_string()
    });
    OODT {
      ID,
      LAST_OB_TIME,
      VISMAG,
      VISMAG_MIN,
      VISMAG_MAX,
      VISMAG_MEAN,
      RCS,
      RCS_MIN,
      RCS_MAX,
      RCS_MEAN,
      BOL_DELTA_V,
      MAX_DELTA_V,
      DELTA_VUNC,
      EST_DELTA_VDURATION,
      NUM_MISSION,
      MISSION_TYPES,
      BUS_TYPE,
      GEO_SLOT,
      DRIFT_RATE,
      DRY_MASS,
      ADDITIONAL_MASS,
      LAUNCH_MASS_MIN,
      LAUNCH_MASS,
      LAUNCH_MASS_MAX,
      BOL_FUEL_MASS,
      CURRENT_MASS,
      TOTAL_MASS_UNC,
      SOLAR_ARRAY_AREA,
      MANEUVERABLE,
      FUEL_REMAINING,
      CROSS_SECTION,
      BUS_CROSS_SECTION,
      MAX_RADIUS,
      COLA_RADIUS,
      ADEPT_RADIUS,
      NUM_DEPLOYABLE,
      DEP_NAMES,
      DEP_EST_MASSES,
      DEP_MASS_UNCS,
      LAST_OB_SOURCE,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOD::VT_ID, None)}
  }
  #[inline]
  pub fn LAST_OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOD::VT_LAST_OB_TIME, None)}
  }
  #[inline]
  pub fn VISMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_VISMAG, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VISMAG_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_VISMAG_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VISMAG_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_VISMAG_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VISMAG_MEAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_VISMAG_MEAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_RCS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_RCS_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_RCS_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS_MEAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_RCS_MEAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BOL_DELTA_V(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_BOL_DELTA_V, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAX_DELTA_V(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_MAX_DELTA_V, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DELTA_VUNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_DELTA_VUNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EST_DELTA_VDURATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_EST_DELTA_VDURATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NUM_MISSION(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OOD::VT_NUM_MISSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MISSION_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOD::VT_MISSION_TYPES, None)}
  }
  #[inline]
  pub fn BUS_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOD::VT_BUS_TYPE, None)}
  }
  #[inline]
  pub fn GEO_SLOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_GEO_SLOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRIFT_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_DRIFT_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRY_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_DRY_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ADDITIONAL_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_ADDITIONAL_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_MASS_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_LAUNCH_MASS_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_LAUNCH_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_MASS_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_LAUNCH_MASS_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BOL_FUEL_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_BOL_FUEL_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CURRENT_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_CURRENT_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TOTAL_MASS_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_TOTAL_MASS_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_ARRAY_AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_SOLAR_ARRAY_AREA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MANEUVERABLE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OOD::VT_MANEUVERABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn FUEL_REMAINING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_FUEL_REMAINING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CROSS_SECTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_CROSS_SECTION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BUS_CROSS_SECTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_BUS_CROSS_SECTION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAX_RADIUS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_MAX_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn COLA_RADIUS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_COLA_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ADEPT_RADIUS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOD::VT_ADEPT_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NUM_DEPLOYABLE(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OOD::VT_NUM_DEPLOYABLE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DEP_NAMES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOD::VT_DEP_NAMES, None)}
  }
  #[inline]
  pub fn DEP_EST_MASSES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOD::VT_DEP_EST_MASSES, None)}
  }
  #[inline]
  pub fn DEP_MASS_UNCS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOD::VT_DEP_MASS_UNCS, None)}
  }
  #[inline]
  pub fn LAST_OB_SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOD::VT_LAST_OB_SOURCE, None)}
  }
}

impl flatbuffers::Verifiable for OOD<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAST_OB_TIME", Self::VT_LAST_OB_TIME, false)?
     .visit_field::<f64>("VISMAG", Self::VT_VISMAG, false)?
     .visit_field::<f64>("VISMAG_MIN", Self::VT_VISMAG_MIN, false)?
     .visit_field::<f64>("VISMAG_MAX", Self::VT_VISMAG_MAX, false)?
     .visit_field::<f64>("VISMAG_MEAN", Self::VT_VISMAG_MEAN, false)?
     .visit_field::<f64>("RCS", Self::VT_RCS, false)?
     .visit_field::<f64>("RCS_MIN", Self::VT_RCS_MIN, false)?
     .visit_field::<f64>("RCS_MAX", Self::VT_RCS_MAX, false)?
     .visit_field::<f64>("RCS_MEAN", Self::VT_RCS_MEAN, false)?
     .visit_field::<f64>("BOL_DELTA_V", Self::VT_BOL_DELTA_V, false)?
     .visit_field::<f64>("MAX_DELTA_V", Self::VT_MAX_DELTA_V, false)?
     .visit_field::<f64>("DELTA_VUNC", Self::VT_DELTA_VUNC, false)?
     .visit_field::<f64>("EST_DELTA_VDURATION", Self::VT_EST_DELTA_VDURATION, false)?
     .visit_field::<i32>("NUM_MISSION", Self::VT_NUM_MISSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MISSION_TYPES", Self::VT_MISSION_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BUS_TYPE", Self::VT_BUS_TYPE, false)?
     .visit_field::<f64>("GEO_SLOT", Self::VT_GEO_SLOT, false)?
     .visit_field::<f64>("DRIFT_RATE", Self::VT_DRIFT_RATE, false)?
     .visit_field::<f64>("DRY_MASS", Self::VT_DRY_MASS, false)?
     .visit_field::<f64>("ADDITIONAL_MASS", Self::VT_ADDITIONAL_MASS, false)?
     .visit_field::<f64>("LAUNCH_MASS_MIN", Self::VT_LAUNCH_MASS_MIN, false)?
     .visit_field::<f64>("LAUNCH_MASS", Self::VT_LAUNCH_MASS, false)?
     .visit_field::<f64>("LAUNCH_MASS_MAX", Self::VT_LAUNCH_MASS_MAX, false)?
     .visit_field::<f64>("BOL_FUEL_MASS", Self::VT_BOL_FUEL_MASS, false)?
     .visit_field::<f64>("CURRENT_MASS", Self::VT_CURRENT_MASS, false)?
     .visit_field::<f64>("TOTAL_MASS_UNC", Self::VT_TOTAL_MASS_UNC, false)?
     .visit_field::<f64>("SOLAR_ARRAY_AREA", Self::VT_SOLAR_ARRAY_AREA, false)?
     .visit_field::<bool>("MANEUVERABLE", Self::VT_MANEUVERABLE, false)?
     .visit_field::<f64>("FUEL_REMAINING", Self::VT_FUEL_REMAINING, false)?
     .visit_field::<f64>("CROSS_SECTION", Self::VT_CROSS_SECTION, false)?
     .visit_field::<f64>("BUS_CROSS_SECTION", Self::VT_BUS_CROSS_SECTION, false)?
     .visit_field::<f64>("MAX_RADIUS", Self::VT_MAX_RADIUS, false)?
     .visit_field::<f64>("COLA_RADIUS", Self::VT_COLA_RADIUS, false)?
     .visit_field::<f64>("ADEPT_RADIUS", Self::VT_ADEPT_RADIUS, false)?
     .visit_field::<i32>("NUM_DEPLOYABLE", Self::VT_NUM_DEPLOYABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DEP_NAMES", Self::VT_DEP_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DEP_EST_MASSES", Self::VT_DEP_EST_MASSES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DEP_MASS_UNCS", Self::VT_DEP_MASS_UNCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAST_OB_SOURCE", Self::VT_LAST_OB_SOURCE, false)?
     .finish();
    Ok(())
  }
}
pub struct OODArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAST_OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISMAG: f64,
    pub VISMAG_MIN: f64,
    pub VISMAG_MAX: f64,
    pub VISMAG_MEAN: f64,
    pub RCS: f64,
    pub RCS_MIN: f64,
    pub RCS_MAX: f64,
    pub RCS_MEAN: f64,
    pub BOL_DELTA_V: f64,
    pub MAX_DELTA_V: f64,
    pub DELTA_VUNC: f64,
    pub EST_DELTA_VDURATION: f64,
    pub NUM_MISSION: i32,
    pub MISSION_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub BUS_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GEO_SLOT: f64,
    pub DRIFT_RATE: f64,
    pub DRY_MASS: f64,
    pub ADDITIONAL_MASS: f64,
    pub LAUNCH_MASS_MIN: f64,
    pub LAUNCH_MASS: f64,
    pub LAUNCH_MASS_MAX: f64,
    pub BOL_FUEL_MASS: f64,
    pub CURRENT_MASS: f64,
    pub TOTAL_MASS_UNC: f64,
    pub SOLAR_ARRAY_AREA: f64,
    pub MANEUVERABLE: bool,
    pub FUEL_REMAINING: f64,
    pub CROSS_SECTION: f64,
    pub BUS_CROSS_SECTION: f64,
    pub MAX_RADIUS: f64,
    pub COLA_RADIUS: f64,
    pub ADEPT_RADIUS: f64,
    pub NUM_DEPLOYABLE: i32,
    pub DEP_NAMES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DEP_EST_MASSES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DEP_MASS_UNCS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub LAST_OB_SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OODArgs<'a> {
  #[inline]
  fn default() -> Self {
    OODArgs {
      ID: None,
      LAST_OB_TIME: None,
      VISMAG: 0.0,
      VISMAG_MIN: 0.0,
      VISMAG_MAX: 0.0,
      VISMAG_MEAN: 0.0,
      RCS: 0.0,
      RCS_MIN: 0.0,
      RCS_MAX: 0.0,
      RCS_MEAN: 0.0,
      BOL_DELTA_V: 0.0,
      MAX_DELTA_V: 0.0,
      DELTA_VUNC: 0.0,
      EST_DELTA_VDURATION: 0.0,
      NUM_MISSION: 0,
      MISSION_TYPES: None,
      BUS_TYPE: None,
      GEO_SLOT: 0.0,
      DRIFT_RATE: 0.0,
      DRY_MASS: 0.0,
      ADDITIONAL_MASS: 0.0,
      LAUNCH_MASS_MIN: 0.0,
      LAUNCH_MASS: 0.0,
      LAUNCH_MASS_MAX: 0.0,
      BOL_FUEL_MASS: 0.0,
      CURRENT_MASS: 0.0,
      TOTAL_MASS_UNC: 0.0,
      SOLAR_ARRAY_AREA: 0.0,
      MANEUVERABLE: false,
      FUEL_REMAINING: 0.0,
      CROSS_SECTION: 0.0,
      BUS_CROSS_SECTION: 0.0,
      MAX_RADIUS: 0.0,
      COLA_RADIUS: 0.0,
      ADEPT_RADIUS: 0.0,
      NUM_DEPLOYABLE: 0,
      DEP_NAMES: None,
      DEP_EST_MASSES: None,
      DEP_MASS_UNCS: None,
      LAST_OB_SOURCE: None,
    }
  }
}

pub struct OODBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OODBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_ID, ID);
  }
  #[inline]
  pub fn add_LAST_OB_TIME(&mut self, LAST_OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_LAST_OB_TIME, LAST_OB_TIME);
  }
  #[inline]
  pub fn add_VISMAG(&mut self, VISMAG: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_VISMAG, VISMAG, 0.0);
  }
  #[inline]
  pub fn add_VISMAG_MIN(&mut self, VISMAG_MIN: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_VISMAG_MIN, VISMAG_MIN, 0.0);
  }
  #[inline]
  pub fn add_VISMAG_MAX(&mut self, VISMAG_MAX: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_VISMAG_MAX, VISMAG_MAX, 0.0);
  }
  #[inline]
  pub fn add_VISMAG_MEAN(&mut self, VISMAG_MEAN: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_VISMAG_MEAN, VISMAG_MEAN, 0.0);
  }
  #[inline]
  pub fn add_RCS(&mut self, RCS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_RCS, RCS, 0.0);
  }
  #[inline]
  pub fn add_RCS_MIN(&mut self, RCS_MIN: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_RCS_MIN, RCS_MIN, 0.0);
  }
  #[inline]
  pub fn add_RCS_MAX(&mut self, RCS_MAX: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_RCS_MAX, RCS_MAX, 0.0);
  }
  #[inline]
  pub fn add_RCS_MEAN(&mut self, RCS_MEAN: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_RCS_MEAN, RCS_MEAN, 0.0);
  }
  #[inline]
  pub fn add_BOL_DELTA_V(&mut self, BOL_DELTA_V: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_BOL_DELTA_V, BOL_DELTA_V, 0.0);
  }
  #[inline]
  pub fn add_MAX_DELTA_V(&mut self, MAX_DELTA_V: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_MAX_DELTA_V, MAX_DELTA_V, 0.0);
  }
  #[inline]
  pub fn add_DELTA_VUNC(&mut self, DELTA_VUNC: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_DELTA_VUNC, DELTA_VUNC, 0.0);
  }
  #[inline]
  pub fn add_EST_DELTA_VDURATION(&mut self, EST_DELTA_VDURATION: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_EST_DELTA_VDURATION, EST_DELTA_VDURATION, 0.0);
  }
  #[inline]
  pub fn add_NUM_MISSION(&mut self, NUM_MISSION: i32) {
    self.fbb_.push_slot::<i32>(OOD::VT_NUM_MISSION, NUM_MISSION, 0);
  }
  #[inline]
  pub fn add_MISSION_TYPES(&mut self, MISSION_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_MISSION_TYPES, MISSION_TYPES);
  }
  #[inline]
  pub fn add_BUS_TYPE(&mut self, BUS_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_BUS_TYPE, BUS_TYPE);
  }
  #[inline]
  pub fn add_GEO_SLOT(&mut self, GEO_SLOT: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_GEO_SLOT, GEO_SLOT, 0.0);
  }
  #[inline]
  pub fn add_DRIFT_RATE(&mut self, DRIFT_RATE: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_DRIFT_RATE, DRIFT_RATE, 0.0);
  }
  #[inline]
  pub fn add_DRY_MASS(&mut self, DRY_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_DRY_MASS, DRY_MASS, 0.0);
  }
  #[inline]
  pub fn add_ADDITIONAL_MASS(&mut self, ADDITIONAL_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_ADDITIONAL_MASS, ADDITIONAL_MASS, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_MASS_MIN(&mut self, LAUNCH_MASS_MIN: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_LAUNCH_MASS_MIN, LAUNCH_MASS_MIN, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_MASS(&mut self, LAUNCH_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_LAUNCH_MASS, LAUNCH_MASS, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_MASS_MAX(&mut self, LAUNCH_MASS_MAX: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_LAUNCH_MASS_MAX, LAUNCH_MASS_MAX, 0.0);
  }
  #[inline]
  pub fn add_BOL_FUEL_MASS(&mut self, BOL_FUEL_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_BOL_FUEL_MASS, BOL_FUEL_MASS, 0.0);
  }
  #[inline]
  pub fn add_CURRENT_MASS(&mut self, CURRENT_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_CURRENT_MASS, CURRENT_MASS, 0.0);
  }
  #[inline]
  pub fn add_TOTAL_MASS_UNC(&mut self, TOTAL_MASS_UNC: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_TOTAL_MASS_UNC, TOTAL_MASS_UNC, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_ARRAY_AREA(&mut self, SOLAR_ARRAY_AREA: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_SOLAR_ARRAY_AREA, SOLAR_ARRAY_AREA, 0.0);
  }
  #[inline]
  pub fn add_MANEUVERABLE(&mut self, MANEUVERABLE: bool) {
    self.fbb_.push_slot::<bool>(OOD::VT_MANEUVERABLE, MANEUVERABLE, false);
  }
  #[inline]
  pub fn add_FUEL_REMAINING(&mut self, FUEL_REMAINING: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_FUEL_REMAINING, FUEL_REMAINING, 0.0);
  }
  #[inline]
  pub fn add_CROSS_SECTION(&mut self, CROSS_SECTION: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_CROSS_SECTION, CROSS_SECTION, 0.0);
  }
  #[inline]
  pub fn add_BUS_CROSS_SECTION(&mut self, BUS_CROSS_SECTION: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_BUS_CROSS_SECTION, BUS_CROSS_SECTION, 0.0);
  }
  #[inline]
  pub fn add_MAX_RADIUS(&mut self, MAX_RADIUS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_MAX_RADIUS, MAX_RADIUS, 0.0);
  }
  #[inline]
  pub fn add_COLA_RADIUS(&mut self, COLA_RADIUS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_COLA_RADIUS, COLA_RADIUS, 0.0);
  }
  #[inline]
  pub fn add_ADEPT_RADIUS(&mut self, ADEPT_RADIUS: f64) {
    self.fbb_.push_slot::<f64>(OOD::VT_ADEPT_RADIUS, ADEPT_RADIUS, 0.0);
  }
  #[inline]
  pub fn add_NUM_DEPLOYABLE(&mut self, NUM_DEPLOYABLE: i32) {
    self.fbb_.push_slot::<i32>(OOD::VT_NUM_DEPLOYABLE, NUM_DEPLOYABLE, 0);
  }
  #[inline]
  pub fn add_DEP_NAMES(&mut self, DEP_NAMES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_DEP_NAMES, DEP_NAMES);
  }
  #[inline]
  pub fn add_DEP_EST_MASSES(&mut self, DEP_EST_MASSES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_DEP_EST_MASSES, DEP_EST_MASSES);
  }
  #[inline]
  pub fn add_DEP_MASS_UNCS(&mut self, DEP_MASS_UNCS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_DEP_MASS_UNCS, DEP_MASS_UNCS);
  }
  #[inline]
  pub fn add_LAST_OB_SOURCE(&mut self, LAST_OB_SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOD::VT_LAST_OB_SOURCE, LAST_OB_SOURCE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OODBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OODBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OOD<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OOD<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OOD");
      ds.field("ID", &self.ID());
      ds.field("LAST_OB_TIME", &self.LAST_OB_TIME());
      ds.field("VISMAG", &self.VISMAG());
      ds.field("VISMAG_MIN", &self.VISMAG_MIN());
      ds.field("VISMAG_MAX", &self.VISMAG_MAX());
      ds.field("VISMAG_MEAN", &self.VISMAG_MEAN());
      ds.field("RCS", &self.RCS());
      ds.field("RCS_MIN", &self.RCS_MIN());
      ds.field("RCS_MAX", &self.RCS_MAX());
      ds.field("RCS_MEAN", &self.RCS_MEAN());
      ds.field("BOL_DELTA_V", &self.BOL_DELTA_V());
      ds.field("MAX_DELTA_V", &self.MAX_DELTA_V());
      ds.field("DELTA_VUNC", &self.DELTA_VUNC());
      ds.field("EST_DELTA_VDURATION", &self.EST_DELTA_VDURATION());
      ds.field("NUM_MISSION", &self.NUM_MISSION());
      ds.field("MISSION_TYPES", &self.MISSION_TYPES());
      ds.field("BUS_TYPE", &self.BUS_TYPE());
      ds.field("GEO_SLOT", &self.GEO_SLOT());
      ds.field("DRIFT_RATE", &self.DRIFT_RATE());
      ds.field("DRY_MASS", &self.DRY_MASS());
      ds.field("ADDITIONAL_MASS", &self.ADDITIONAL_MASS());
      ds.field("LAUNCH_MASS_MIN", &self.LAUNCH_MASS_MIN());
      ds.field("LAUNCH_MASS", &self.LAUNCH_MASS());
      ds.field("LAUNCH_MASS_MAX", &self.LAUNCH_MASS_MAX());
      ds.field("BOL_FUEL_MASS", &self.BOL_FUEL_MASS());
      ds.field("CURRENT_MASS", &self.CURRENT_MASS());
      ds.field("TOTAL_MASS_UNC", &self.TOTAL_MASS_UNC());
      ds.field("SOLAR_ARRAY_AREA", &self.SOLAR_ARRAY_AREA());
      ds.field("MANEUVERABLE", &self.MANEUVERABLE());
      ds.field("FUEL_REMAINING", &self.FUEL_REMAINING());
      ds.field("CROSS_SECTION", &self.CROSS_SECTION());
      ds.field("BUS_CROSS_SECTION", &self.BUS_CROSS_SECTION());
      ds.field("MAX_RADIUS", &self.MAX_RADIUS());
      ds.field("COLA_RADIUS", &self.COLA_RADIUS());
      ds.field("ADEPT_RADIUS", &self.ADEPT_RADIUS());
      ds.field("NUM_DEPLOYABLE", &self.NUM_DEPLOYABLE());
      ds.field("DEP_NAMES", &self.DEP_NAMES());
      ds.field("DEP_EST_MASSES", &self.DEP_EST_MASSES());
      ds.field("DEP_MASS_UNCS", &self.DEP_MASS_UNCS());
      ds.field("LAST_OB_SOURCE", &self.LAST_OB_SOURCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OODT {
  pub ID: Option<String>,
  pub LAST_OB_TIME: Option<String>,
  pub VISMAG: f64,
  pub VISMAG_MIN: f64,
  pub VISMAG_MAX: f64,
  pub VISMAG_MEAN: f64,
  pub RCS: f64,
  pub RCS_MIN: f64,
  pub RCS_MAX: f64,
  pub RCS_MEAN: f64,
  pub BOL_DELTA_V: f64,
  pub MAX_DELTA_V: f64,
  pub DELTA_VUNC: f64,
  pub EST_DELTA_VDURATION: f64,
  pub NUM_MISSION: i32,
  pub MISSION_TYPES: Option<Vec<String>>,
  pub BUS_TYPE: Option<String>,
  pub GEO_SLOT: f64,
  pub DRIFT_RATE: f64,
  pub DRY_MASS: f64,
  pub ADDITIONAL_MASS: f64,
  pub LAUNCH_MASS_MIN: f64,
  pub LAUNCH_MASS: f64,
  pub LAUNCH_MASS_MAX: f64,
  pub BOL_FUEL_MASS: f64,
  pub CURRENT_MASS: f64,
  pub TOTAL_MASS_UNC: f64,
  pub SOLAR_ARRAY_AREA: f64,
  pub MANEUVERABLE: bool,
  pub FUEL_REMAINING: f64,
  pub CROSS_SECTION: f64,
  pub BUS_CROSS_SECTION: f64,
  pub MAX_RADIUS: f64,
  pub COLA_RADIUS: f64,
  pub ADEPT_RADIUS: f64,
  pub NUM_DEPLOYABLE: i32,
  pub DEP_NAMES: Option<Vec<String>>,
  pub DEP_EST_MASSES: Option<Vec<String>>,
  pub DEP_MASS_UNCS: Option<Vec<String>>,
  pub LAST_OB_SOURCE: Option<String>,
}
impl Default for OODT {
  fn default() -> Self {
    Self {
      ID: None,
      LAST_OB_TIME: None,
      VISMAG: 0.0,
      VISMAG_MIN: 0.0,
      VISMAG_MAX: 0.0,
      VISMAG_MEAN: 0.0,
      RCS: 0.0,
      RCS_MIN: 0.0,
      RCS_MAX: 0.0,
      RCS_MEAN: 0.0,
      BOL_DELTA_V: 0.0,
      MAX_DELTA_V: 0.0,
      DELTA_VUNC: 0.0,
      EST_DELTA_VDURATION: 0.0,
      NUM_MISSION: 0,
      MISSION_TYPES: None,
      BUS_TYPE: None,
      GEO_SLOT: 0.0,
      DRIFT_RATE: 0.0,
      DRY_MASS: 0.0,
      ADDITIONAL_MASS: 0.0,
      LAUNCH_MASS_MIN: 0.0,
      LAUNCH_MASS: 0.0,
      LAUNCH_MASS_MAX: 0.0,
      BOL_FUEL_MASS: 0.0,
      CURRENT_MASS: 0.0,
      TOTAL_MASS_UNC: 0.0,
      SOLAR_ARRAY_AREA: 0.0,
      MANEUVERABLE: false,
      FUEL_REMAINING: 0.0,
      CROSS_SECTION: 0.0,
      BUS_CROSS_SECTION: 0.0,
      MAX_RADIUS: 0.0,
      COLA_RADIUS: 0.0,
      ADEPT_RADIUS: 0.0,
      NUM_DEPLOYABLE: 0,
      DEP_NAMES: None,
      DEP_EST_MASSES: None,
      DEP_MASS_UNCS: None,
      LAST_OB_SOURCE: None,
    }
  }
}
impl OODT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OOD<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAST_OB_TIME = self.LAST_OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISMAG = self.VISMAG;
    let VISMAG_MIN = self.VISMAG_MIN;
    let VISMAG_MAX = self.VISMAG_MAX;
    let VISMAG_MEAN = self.VISMAG_MEAN;
    let RCS = self.RCS;
    let RCS_MIN = self.RCS_MIN;
    let RCS_MAX = self.RCS_MAX;
    let RCS_MEAN = self.RCS_MEAN;
    let BOL_DELTA_V = self.BOL_DELTA_V;
    let MAX_DELTA_V = self.MAX_DELTA_V;
    let DELTA_VUNC = self.DELTA_VUNC;
    let EST_DELTA_VDURATION = self.EST_DELTA_VDURATION;
    let NUM_MISSION = self.NUM_MISSION;
    let MISSION_TYPES = self.MISSION_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let BUS_TYPE = self.BUS_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GEO_SLOT = self.GEO_SLOT;
    let DRIFT_RATE = self.DRIFT_RATE;
    let DRY_MASS = self.DRY_MASS;
    let ADDITIONAL_MASS = self.ADDITIONAL_MASS;
    let LAUNCH_MASS_MIN = self.LAUNCH_MASS_MIN;
    let LAUNCH_MASS = self.LAUNCH_MASS;
    let LAUNCH_MASS_MAX = self.LAUNCH_MASS_MAX;
    let BOL_FUEL_MASS = self.BOL_FUEL_MASS;
    let CURRENT_MASS = self.CURRENT_MASS;
    let TOTAL_MASS_UNC = self.TOTAL_MASS_UNC;
    let SOLAR_ARRAY_AREA = self.SOLAR_ARRAY_AREA;
    let MANEUVERABLE = self.MANEUVERABLE;
    let FUEL_REMAINING = self.FUEL_REMAINING;
    let CROSS_SECTION = self.CROSS_SECTION;
    let BUS_CROSS_SECTION = self.BUS_CROSS_SECTION;
    let MAX_RADIUS = self.MAX_RADIUS;
    let COLA_RADIUS = self.COLA_RADIUS;
    let ADEPT_RADIUS = self.ADEPT_RADIUS;
    let NUM_DEPLOYABLE = self.NUM_DEPLOYABLE;
    let DEP_NAMES = self.DEP_NAMES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DEP_EST_MASSES = self.DEP_EST_MASSES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DEP_MASS_UNCS = self.DEP_MASS_UNCS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let LAST_OB_SOURCE = self.LAST_OB_SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OOD::create(_fbb, &OODArgs{
      ID,
      LAST_OB_TIME,
      VISMAG,
      VISMAG_MIN,
      VISMAG_MAX,
      VISMAG_MEAN,
      RCS,
      RCS_MIN,
      RCS_MAX,
      RCS_MEAN,
      BOL_DELTA_V,
      MAX_DELTA_V,
      DELTA_VUNC,
      EST_DELTA_VDURATION,
      NUM_MISSION,
      MISSION_TYPES,
      BUS_TYPE,
      GEO_SLOT,
      DRIFT_RATE,
      DRY_MASS,
      ADDITIONAL_MASS,
      LAUNCH_MASS_MIN,
      LAUNCH_MASS,
      LAUNCH_MASS_MAX,
      BOL_FUEL_MASS,
      CURRENT_MASS,
      TOTAL_MASS_UNC,
      SOLAR_ARRAY_AREA,
      MANEUVERABLE,
      FUEL_REMAINING,
      CROSS_SECTION,
      BUS_CROSS_SECTION,
      MAX_RADIUS,
      COLA_RADIUS,
      ADEPT_RADIUS,
      NUM_DEPLOYABLE,
      DEP_NAMES,
      DEP_EST_MASSES,
      DEP_MASS_UNCS,
      LAST_OB_SOURCE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OOD`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOD_unchecked`.
pub fn root_as_OOD(buf: &[u8]) -> Result<OOD, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OOD>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OOD` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OOD_unchecked`.
pub fn size_prefixed_root_as_OOD(buf: &[u8]) -> Result<OOD, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OOD>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OOD` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOD_unchecked`.
pub fn root_as_OOD_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOD<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OOD<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OOD` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOD_unchecked`.
pub fn size_prefixed_root_as_OOD_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOD<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OOD<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OOD and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OOD`.
pub unsafe fn root_as_OOD_unchecked(buf: &[u8]) -> OOD {
  flatbuffers::root_unchecked::<OOD>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OOD and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OOD`.
pub unsafe fn size_prefixed_root_as_OOD_unchecked(buf: &[u8]) -> OOD {
  flatbuffers::size_prefixed_root_unchecked::<OOD>(buf)
}
pub const OOD_IDENTIFIER: &str = "$OOD";

#[inline]
pub fn OOD_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOD_IDENTIFIER, false)
}

#[inline]
pub fn OOD_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOD_IDENTIFIER, true)
}

#[inline]
pub fn finish_OOD_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OOD<'a>>) {
  fbb.finish(root, Some(OOD_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OOD_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OOD<'a>>) {
  fbb.finish_size_prefixed(root, Some(OOD_IDENTIFIER));
}
