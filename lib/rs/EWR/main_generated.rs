// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_JAMMING_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_JAMMING_TYPE: i8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_JAMMING_TYPE: [JammingType; 14] = [
  JammingType::NOISE_BARRAGE,
  JammingType::NOISE_SPOT,
  JammingType::NOISE_SWEPT,
  JammingType::DECEPTION_RANGE_GATE,
  JammingType::DECEPTION_VELOCITY_GATE,
  JammingType::DECEPTION_ANGLE,
  JammingType::DECEPTION_FALSE_TARGET,
  JammingType::DRFM,
  JammingType::REPEATER,
  JammingType::CROSS_EYE,
  JammingType::CROSS_POLARIZATION,
  JammingType::CHAFF,
  JammingType::FLARE,
  JammingType::TOWED_DECOY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct JammingType(pub i8);
#[allow(non_upper_case_globals)]
impl JammingType {
  pub const NOISE_BARRAGE: Self = Self(0);
  pub const NOISE_SPOT: Self = Self(1);
  pub const NOISE_SWEPT: Self = Self(2);
  pub const DECEPTION_RANGE_GATE: Self = Self(3);
  pub const DECEPTION_VELOCITY_GATE: Self = Self(4);
  pub const DECEPTION_ANGLE: Self = Self(5);
  pub const DECEPTION_FALSE_TARGET: Self = Self(6);
  pub const DRFM: Self = Self(7);
  pub const REPEATER: Self = Self(8);
  pub const CROSS_EYE: Self = Self(9);
  pub const CROSS_POLARIZATION: Self = Self(10);
  pub const CHAFF: Self = Self(11);
  pub const FLARE: Self = Self(12);
  pub const TOWED_DECOY: Self = Self(13);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOISE_BARRAGE,
    Self::NOISE_SPOT,
    Self::NOISE_SWEPT,
    Self::DECEPTION_RANGE_GATE,
    Self::DECEPTION_VELOCITY_GATE,
    Self::DECEPTION_ANGLE,
    Self::DECEPTION_FALSE_TARGET,
    Self::DRFM,
    Self::REPEATER,
    Self::CROSS_EYE,
    Self::CROSS_POLARIZATION,
    Self::CHAFF,
    Self::FLARE,
    Self::TOWED_DECOY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NOISE_BARRAGE => Some("NOISE_BARRAGE"),
      Self::NOISE_SPOT => Some("NOISE_SPOT"),
      Self::NOISE_SWEPT => Some("NOISE_SWEPT"),
      Self::DECEPTION_RANGE_GATE => Some("DECEPTION_RANGE_GATE"),
      Self::DECEPTION_VELOCITY_GATE => Some("DECEPTION_VELOCITY_GATE"),
      Self::DECEPTION_ANGLE => Some("DECEPTION_ANGLE"),
      Self::DECEPTION_FALSE_TARGET => Some("DECEPTION_FALSE_TARGET"),
      Self::DRFM => Some("DRFM"),
      Self::REPEATER => Some("REPEATER"),
      Self::CROSS_EYE => Some("CROSS_EYE"),
      Self::CROSS_POLARIZATION => Some("CROSS_POLARIZATION"),
      Self::CHAFF => Some("CHAFF"),
      Self::FLARE => Some("FLARE"),
      Self::TOWED_DECOY => Some("TOWED_DECOY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for JammingType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for JammingType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for JammingType {
    type Output = JammingType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for JammingType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for JammingType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for JammingType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_THREAT_CATEGORY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_THREAT_CATEGORY: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_THREAT_CATEGORY: [ThreatCategory; 15] = [
  ThreatCategory::UNKNOWN,
  ThreatCategory::EARLY_WARNING,
  ThreatCategory::ACQUISITION,
  ThreatCategory::TRACKING,
  ThreatCategory::GUIDANCE,
  ThreatCategory::HEIGHT_FINDER,
  ThreatCategory::GCI,
  ThreatCategory::AIRBORNE_INTERCEPT,
  ThreatCategory::SURFACE_SEARCH,
  ThreatCategory::AIR_SEARCH,
  ThreatCategory::NAVIGATION,
  ThreatCategory::WEATHER,
  ThreatCategory::CIVIL,
  ThreatCategory::FRIENDLY,
  ThreatCategory::IFF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ThreatCategory(pub i8);
#[allow(non_upper_case_globals)]
impl ThreatCategory {
  pub const UNKNOWN: Self = Self(0);
  pub const EARLY_WARNING: Self = Self(1);
  pub const ACQUISITION: Self = Self(2);
  pub const TRACKING: Self = Self(3);
  pub const GUIDANCE: Self = Self(4);
  pub const HEIGHT_FINDER: Self = Self(5);
  pub const GCI: Self = Self(6);
  pub const AIRBORNE_INTERCEPT: Self = Self(7);
  pub const SURFACE_SEARCH: Self = Self(8);
  pub const AIR_SEARCH: Self = Self(9);
  pub const NAVIGATION: Self = Self(10);
  pub const WEATHER: Self = Self(11);
  pub const CIVIL: Self = Self(12);
  pub const FRIENDLY: Self = Self(13);
  pub const IFF: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::EARLY_WARNING,
    Self::ACQUISITION,
    Self::TRACKING,
    Self::GUIDANCE,
    Self::HEIGHT_FINDER,
    Self::GCI,
    Self::AIRBORNE_INTERCEPT,
    Self::SURFACE_SEARCH,
    Self::AIR_SEARCH,
    Self::NAVIGATION,
    Self::WEATHER,
    Self::CIVIL,
    Self::FRIENDLY,
    Self::IFF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::EARLY_WARNING => Some("EARLY_WARNING"),
      Self::ACQUISITION => Some("ACQUISITION"),
      Self::TRACKING => Some("TRACKING"),
      Self::GUIDANCE => Some("GUIDANCE"),
      Self::HEIGHT_FINDER => Some("HEIGHT_FINDER"),
      Self::GCI => Some("GCI"),
      Self::AIRBORNE_INTERCEPT => Some("AIRBORNE_INTERCEPT"),
      Self::SURFACE_SEARCH => Some("SURFACE_SEARCH"),
      Self::AIR_SEARCH => Some("AIR_SEARCH"),
      Self::NAVIGATION => Some("NAVIGATION"),
      Self::WEATHER => Some("WEATHER"),
      Self::CIVIL => Some("CIVIL"),
      Self::FRIENDLY => Some("FRIENDLY"),
      Self::IFF => Some("IFF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ThreatCategory {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ThreatCategory {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ThreatCategory {
    type Output = ThreatCategory;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ThreatCategory {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ThreatCategory {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ThreatCategory {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ESMFUNCTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ESMFUNCTION: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ESMFUNCTION: [ESMFunction; 7] = [
  ESMFunction::SEARCH,
  ESMFunction::CLASSIFICATION,
  ESMFunction::IDENTIFICATION,
  ESMFunction::DIRECTION_FINDING,
  ESMFunction::LOCATION,
  ESMFunction::RECORDING,
  ESMFunction::SITUATIONAL_AWARENESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ESMFunction(pub i8);
#[allow(non_upper_case_globals)]
impl ESMFunction {
  pub const SEARCH: Self = Self(0);
  pub const CLASSIFICATION: Self = Self(1);
  pub const IDENTIFICATION: Self = Self(2);
  pub const DIRECTION_FINDING: Self = Self(3);
  pub const LOCATION: Self = Self(4);
  pub const RECORDING: Self = Self(5);
  pub const SITUATIONAL_AWARENESS: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SEARCH,
    Self::CLASSIFICATION,
    Self::IDENTIFICATION,
    Self::DIRECTION_FINDING,
    Self::LOCATION,
    Self::RECORDING,
    Self::SITUATIONAL_AWARENESS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SEARCH => Some("SEARCH"),
      Self::CLASSIFICATION => Some("CLASSIFICATION"),
      Self::IDENTIFICATION => Some("IDENTIFICATION"),
      Self::DIRECTION_FINDING => Some("DIRECTION_FINDING"),
      Self::LOCATION => Some("LOCATION"),
      Self::RECORDING => Some("RECORDING"),
      Self::SITUATIONAL_AWARENESS => Some("SITUATIONAL_AWARENESS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ESMFunction {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ESMFunction {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ESMFunction {
    type Output = ESMFunction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ESMFunction {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ESMFunction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ESMFunction {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COUNTERMEASURE_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COUNTERMEASURE_STATUS: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COUNTERMEASURE_STATUS: [CountermeasureStatus; 6] = [
  CountermeasureStatus::READY,
  CountermeasureStatus::DEPLOYING,
  CountermeasureStatus::ACTIVE,
  CountermeasureStatus::EXPENDED,
  CountermeasureStatus::RELOADING,
  CountermeasureStatus::FAILED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CountermeasureStatus(pub i8);
#[allow(non_upper_case_globals)]
impl CountermeasureStatus {
  pub const READY: Self = Self(0);
  pub const DEPLOYING: Self = Self(1);
  pub const ACTIVE: Self = Self(2);
  pub const EXPENDED: Self = Self(3);
  pub const RELOADING: Self = Self(4);
  pub const FAILED: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::READY,
    Self::DEPLOYING,
    Self::ACTIVE,
    Self::EXPENDED,
    Self::RELOADING,
    Self::FAILED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::READY => Some("READY"),
      Self::DEPLOYING => Some("DEPLOYING"),
      Self::ACTIVE => Some("ACTIVE"),
      Self::EXPENDED => Some("EXPENDED"),
      Self::RELOADING => Some("RELOADING"),
      Self::FAILED => Some("FAILED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CountermeasureStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CountermeasureStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CountermeasureStatus {
    type Output = CountermeasureStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CountermeasureStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CountermeasureStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CountermeasureStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WAVEFORM_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WAVEFORM_TYPE: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WAVEFORM_TYPE: [WaveformType; 10] = [
  WaveformType::CW,
  WaveformType::PULSED,
  WaveformType::PULSE_DOPPLER,
  WaveformType::FM_CW,
  WaveformType::CHIRP,
  WaveformType::PHASE_CODED,
  WaveformType::FREQUENCY_AGILE,
  WaveformType::PRI_AGILE,
  WaveformType::COMPLEX,
  WaveformType::LPI,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WaveformType(pub i8);
#[allow(non_upper_case_globals)]
impl WaveformType {
  pub const CW: Self = Self(0);
  pub const PULSED: Self = Self(1);
  pub const PULSE_DOPPLER: Self = Self(2);
  pub const FM_CW: Self = Self(3);
  pub const CHIRP: Self = Self(4);
  pub const PHASE_CODED: Self = Self(5);
  pub const FREQUENCY_AGILE: Self = Self(6);
  pub const PRI_AGILE: Self = Self(7);
  pub const COMPLEX: Self = Self(8);
  pub const LPI: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CW,
    Self::PULSED,
    Self::PULSE_DOPPLER,
    Self::FM_CW,
    Self::CHIRP,
    Self::PHASE_CODED,
    Self::FREQUENCY_AGILE,
    Self::PRI_AGILE,
    Self::COMPLEX,
    Self::LPI,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CW => Some("CW"),
      Self::PULSED => Some("PULSED"),
      Self::PULSE_DOPPLER => Some("PULSE_DOPPLER"),
      Self::FM_CW => Some("FM_CW"),
      Self::CHIRP => Some("CHIRP"),
      Self::PHASE_CODED => Some("PHASE_CODED"),
      Self::FREQUENCY_AGILE => Some("FREQUENCY_AGILE"),
      Self::PRI_AGILE => Some("PRI_AGILE"),
      Self::COMPLEX => Some("COMPLEX"),
      Self::LPI => Some("LPI"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for WaveformType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WaveformType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for WaveformType {
    type Output = WaveformType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WaveformType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WaveformType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WaveformType {}
pub enum EWROffset {}
#[derive(Copy, Clone, PartialEq)]

/// Electronic Warfare
pub struct EWR<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EWR<'a> {
  type Inner = EWR<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EWR<'a> {
  pub const VT_SYSTEM_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY_ID: flatbuffers::VOffsetT = 6;
  pub const VT_ESM_ACTIVE: flatbuffers::VOffsetT = 8;
  pub const VT_ECM_ACTIVE: flatbuffers::VOffsetT = 10;
  pub const VT_RWR_ACTIVE: flatbuffers::VOffsetT = 12;
  pub const VT_ESM_CONTACTS: flatbuffers::VOffsetT = 14;
  pub const VT_ACTIVE_JAMMING: flatbuffers::VOffsetT = 16;
  pub const VT_COUNTERMEASURES: flatbuffers::VOffsetT = 18;
  pub const VT_THREAT_WARNINGS: flatbuffers::VOffsetT = 20;
  pub const VT_EMCON_LEVEL: flatbuffers::VOffsetT = 22;
  pub const VT_LAST_UPDATE_MS: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EWR { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EWRArgs<'args>
  ) -> flatbuffers::WIPOffset<EWR<'bldr>> {
    let mut builder = EWRBuilder::new(_fbb);
    builder.add_LAST_UPDATE_MS(args.LAST_UPDATE_MS);
    if let Some(x) = args.THREAT_WARNINGS { builder.add_THREAT_WARNINGS(x); }
    if let Some(x) = args.COUNTERMEASURES { builder.add_COUNTERMEASURES(x); }
    if let Some(x) = args.ACTIVE_JAMMING { builder.add_ACTIVE_JAMMING(x); }
    if let Some(x) = args.ESM_CONTACTS { builder.add_ESM_CONTACTS(x); }
    builder.add_ENTITY_ID(args.ENTITY_ID);
    builder.add_SYSTEM_ID(args.SYSTEM_ID);
    builder.add_EMCON_LEVEL(args.EMCON_LEVEL);
    builder.add_RWR_ACTIVE(args.RWR_ACTIVE);
    builder.add_ECM_ACTIVE(args.ECM_ACTIVE);
    builder.add_ESM_ACTIVE(args.ESM_ACTIVE);
    builder.finish()
  }

  pub fn unpack(&self) -> EWRT {
    let SYSTEM_ID = self.SYSTEM_ID();
    let ENTITY_ID = self.ENTITY_ID();
    let ESM_ACTIVE = self.ESM_ACTIVE();
    let ECM_ACTIVE = self.ECM_ACTIVE();
    let RWR_ACTIVE = self.RWR_ACTIVE();
    let ESM_CONTACTS = self.ESM_CONTACTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ACTIVE_JAMMING = self.ACTIVE_JAMMING().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let COUNTERMEASURES = self.COUNTERMEASURES().map(|x| {
      x.to_string()
    });
    let THREAT_WARNINGS = self.THREAT_WARNINGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let EMCON_LEVEL = self.EMCON_LEVEL();
    let LAST_UPDATE_MS = self.LAST_UPDATE_MS();
    EWRT {
      SYSTEM_ID,
      ENTITY_ID,
      ESM_ACTIVE,
      ECM_ACTIVE,
      RWR_ACTIVE,
      ESM_CONTACTS,
      ACTIVE_JAMMING,
      COUNTERMEASURES,
      THREAT_WARNINGS,
      EMCON_LEVEL,
      LAST_UPDATE_MS,
    }
  }

  #[inline]
  pub fn SYSTEM_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EWR::VT_SYSTEM_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ENTITY_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(EWR::VT_ENTITY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ESM_ACTIVE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EWR::VT_ESM_ACTIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ECM_ACTIVE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EWR::VT_ECM_ACTIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn RWR_ACTIVE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EWR::VT_RWR_ACTIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn ESM_CONTACTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EWR::VT_ESM_CONTACTS, None)}
  }
  #[inline]
  pub fn ACTIVE_JAMMING(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EWR::VT_ACTIVE_JAMMING, None)}
  }
  #[inline]
  pub fn COUNTERMEASURES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EWR::VT_COUNTERMEASURES, None)}
  }
  #[inline]
  pub fn THREAT_WARNINGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EWR::VT_THREAT_WARNINGS, None)}
  }
  #[inline]
  pub fn EMCON_LEVEL(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(EWR::VT_EMCON_LEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LAST_UPDATE_MS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EWR::VT_LAST_UPDATE_MS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EWR<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("SYSTEM_ID", Self::VT_SYSTEM_ID, false)?
     .visit_field::<u32>("ENTITY_ID", Self::VT_ENTITY_ID, false)?
     .visit_field::<bool>("ESM_ACTIVE", Self::VT_ESM_ACTIVE, false)?
     .visit_field::<bool>("ECM_ACTIVE", Self::VT_ECM_ACTIVE, false)?
     .visit_field::<bool>("RWR_ACTIVE", Self::VT_RWR_ACTIVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ESM_CONTACTS", Self::VT_ESM_CONTACTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ACTIVE_JAMMING", Self::VT_ACTIVE_JAMMING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COUNTERMEASURES", Self::VT_COUNTERMEASURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("THREAT_WARNINGS", Self::VT_THREAT_WARNINGS, false)?
     .visit_field::<u8>("EMCON_LEVEL", Self::VT_EMCON_LEVEL, false)?
     .visit_field::<i64>("LAST_UPDATE_MS", Self::VT_LAST_UPDATE_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct EWRArgs<'a> {
    pub SYSTEM_ID: u32,
    pub ENTITY_ID: u32,
    pub ESM_ACTIVE: bool,
    pub ECM_ACTIVE: bool,
    pub RWR_ACTIVE: bool,
    pub ESM_CONTACTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ACTIVE_JAMMING: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub COUNTERMEASURES: Option<flatbuffers::WIPOffset<&'a str>>,
    pub THREAT_WARNINGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EMCON_LEVEL: u8,
    pub LAST_UPDATE_MS: i64,
}
impl<'a> Default for EWRArgs<'a> {
  #[inline]
  fn default() -> Self {
    EWRArgs {
      SYSTEM_ID: 0,
      ENTITY_ID: 0,
      ESM_ACTIVE: false,
      ECM_ACTIVE: false,
      RWR_ACTIVE: false,
      ESM_CONTACTS: None,
      ACTIVE_JAMMING: None,
      COUNTERMEASURES: None,
      THREAT_WARNINGS: None,
      EMCON_LEVEL: 0,
      LAST_UPDATE_MS: 0,
    }
  }
}

pub struct EWRBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EWRBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SYSTEM_ID(&mut self, SYSTEM_ID: u32) {
    self.fbb_.push_slot::<u32>(EWR::VT_SYSTEM_ID, SYSTEM_ID, 0);
  }
  #[inline]
  pub fn add_ENTITY_ID(&mut self, ENTITY_ID: u32) {
    self.fbb_.push_slot::<u32>(EWR::VT_ENTITY_ID, ENTITY_ID, 0);
  }
  #[inline]
  pub fn add_ESM_ACTIVE(&mut self, ESM_ACTIVE: bool) {
    self.fbb_.push_slot::<bool>(EWR::VT_ESM_ACTIVE, ESM_ACTIVE, false);
  }
  #[inline]
  pub fn add_ECM_ACTIVE(&mut self, ECM_ACTIVE: bool) {
    self.fbb_.push_slot::<bool>(EWR::VT_ECM_ACTIVE, ECM_ACTIVE, false);
  }
  #[inline]
  pub fn add_RWR_ACTIVE(&mut self, RWR_ACTIVE: bool) {
    self.fbb_.push_slot::<bool>(EWR::VT_RWR_ACTIVE, RWR_ACTIVE, false);
  }
  #[inline]
  pub fn add_ESM_CONTACTS(&mut self, ESM_CONTACTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EWR::VT_ESM_CONTACTS, ESM_CONTACTS);
  }
  #[inline]
  pub fn add_ACTIVE_JAMMING(&mut self, ACTIVE_JAMMING: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EWR::VT_ACTIVE_JAMMING, ACTIVE_JAMMING);
  }
  #[inline]
  pub fn add_COUNTERMEASURES(&mut self, COUNTERMEASURES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EWR::VT_COUNTERMEASURES, COUNTERMEASURES);
  }
  #[inline]
  pub fn add_THREAT_WARNINGS(&mut self, THREAT_WARNINGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EWR::VT_THREAT_WARNINGS, THREAT_WARNINGS);
  }
  #[inline]
  pub fn add_EMCON_LEVEL(&mut self, EMCON_LEVEL: u8) {
    self.fbb_.push_slot::<u8>(EWR::VT_EMCON_LEVEL, EMCON_LEVEL, 0);
  }
  #[inline]
  pub fn add_LAST_UPDATE_MS(&mut self, LAST_UPDATE_MS: i64) {
    self.fbb_.push_slot::<i64>(EWR::VT_LAST_UPDATE_MS, LAST_UPDATE_MS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EWRBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EWRBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EWR<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EWR<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EWR");
      ds.field("SYSTEM_ID", &self.SYSTEM_ID());
      ds.field("ENTITY_ID", &self.ENTITY_ID());
      ds.field("ESM_ACTIVE", &self.ESM_ACTIVE());
      ds.field("ECM_ACTIVE", &self.ECM_ACTIVE());
      ds.field("RWR_ACTIVE", &self.RWR_ACTIVE());
      ds.field("ESM_CONTACTS", &self.ESM_CONTACTS());
      ds.field("ACTIVE_JAMMING", &self.ACTIVE_JAMMING());
      ds.field("COUNTERMEASURES", &self.COUNTERMEASURES());
      ds.field("THREAT_WARNINGS", &self.THREAT_WARNINGS());
      ds.field("EMCON_LEVEL", &self.EMCON_LEVEL());
      ds.field("LAST_UPDATE_MS", &self.LAST_UPDATE_MS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EWRT {
  pub SYSTEM_ID: u32,
  pub ENTITY_ID: u32,
  pub ESM_ACTIVE: bool,
  pub ECM_ACTIVE: bool,
  pub RWR_ACTIVE: bool,
  pub ESM_CONTACTS: Option<Vec<String>>,
  pub ACTIVE_JAMMING: Option<Vec<String>>,
  pub COUNTERMEASURES: Option<String>,
  pub THREAT_WARNINGS: Option<Vec<String>>,
  pub EMCON_LEVEL: u8,
  pub LAST_UPDATE_MS: i64,
}
impl Default for EWRT {
  fn default() -> Self {
    Self {
      SYSTEM_ID: 0,
      ENTITY_ID: 0,
      ESM_ACTIVE: false,
      ECM_ACTIVE: false,
      RWR_ACTIVE: false,
      ESM_CONTACTS: None,
      ACTIVE_JAMMING: None,
      COUNTERMEASURES: None,
      THREAT_WARNINGS: None,
      EMCON_LEVEL: 0,
      LAST_UPDATE_MS: 0,
    }
  }
}
impl EWRT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EWR<'b>> {
    let SYSTEM_ID = self.SYSTEM_ID;
    let ENTITY_ID = self.ENTITY_ID;
    let ESM_ACTIVE = self.ESM_ACTIVE;
    let ECM_ACTIVE = self.ECM_ACTIVE;
    let RWR_ACTIVE = self.RWR_ACTIVE;
    let ESM_CONTACTS = self.ESM_CONTACTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ACTIVE_JAMMING = self.ACTIVE_JAMMING.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let COUNTERMEASURES = self.COUNTERMEASURES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let THREAT_WARNINGS = self.THREAT_WARNINGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EMCON_LEVEL = self.EMCON_LEVEL;
    let LAST_UPDATE_MS = self.LAST_UPDATE_MS;
    EWR::create(_fbb, &EWRArgs{
      SYSTEM_ID,
      ENTITY_ID,
      ESM_ACTIVE,
      ECM_ACTIVE,
      RWR_ACTIVE,
      ESM_CONTACTS,
      ACTIVE_JAMMING,
      COUNTERMEASURES,
      THREAT_WARNINGS,
      EMCON_LEVEL,
      LAST_UPDATE_MS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EWR`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EWR_unchecked`.
pub fn root_as_EWR(buf: &[u8]) -> Result<EWR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EWR>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EWR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EWR_unchecked`.
pub fn size_prefixed_root_as_EWR(buf: &[u8]) -> Result<EWR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EWR>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EWR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EWR_unchecked`.
pub fn root_as_EWR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EWR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EWR<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EWR` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EWR_unchecked`.
pub fn size_prefixed_root_as_EWR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EWR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EWR<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EWR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EWR`.
pub unsafe fn root_as_EWR_unchecked(buf: &[u8]) -> EWR {
  flatbuffers::root_unchecked::<EWR>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EWR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EWR`.
pub unsafe fn size_prefixed_root_as_EWR_unchecked(buf: &[u8]) -> EWR {
  flatbuffers::size_prefixed_root_unchecked::<EWR>(buf)
}
pub const EWR_IDENTIFIER: &str = "$EWR";

#[inline]
pub fn EWR_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EWR_IDENTIFIER, false)
}

#[inline]
pub fn EWR_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EWR_IDENTIFIER, true)
}

#[inline]
pub fn finish_EWR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EWR<'a>>) {
  fbb.finish(root, Some(EWR_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EWR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EWR<'a>>) {
  fbb.finish_size_prefixed(root, Some(EWR_IDENTIFIER));
}
