// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OBSERVERLOCATION_REFERENCE_FRAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OBSERVERLOCATION_REFERENCE_FRAME: i8 = 19;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OBSERVERLOCATION_REFERENCE_FRAME: [OBSERVERLocationReferenceFrame; 20] = [
  OBSERVERLocationReferenceFrame::EME2000,
  OBSERVERLocationReferenceFrame::GCRF,
  OBSERVERLocationReferenceFrame::GRC,
  OBSERVERLocationReferenceFrame::ICRF,
  OBSERVERLocationReferenceFrame::ITRF2000,
  OBSERVERLocationReferenceFrame::ITRF93,
  OBSERVERLocationReferenceFrame::ITRF97,
  OBSERVERLocationReferenceFrame::MCI,
  OBSERVERLocationReferenceFrame::TDR,
  OBSERVERLocationReferenceFrame::TEME,
  OBSERVERLocationReferenceFrame::TOD,
  OBSERVERLocationReferenceFrame::VVLH,
  OBSERVERLocationReferenceFrame::RIC,
  OBSERVERLocationReferenceFrame::VLVH,
  OBSERVERLocationReferenceFrame::ENU,
  OBSERVERLocationReferenceFrame::NED,
  OBSERVERLocationReferenceFrame::LTP,
  OBSERVERLocationReferenceFrame::LVLH,
  OBSERVERLocationReferenceFrame::PNE,
  OBSERVERLocationReferenceFrame::BRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OBSERVERLocationReferenceFrame(pub i8);
#[allow(non_upper_case_globals)]
impl OBSERVERLocationReferenceFrame {
  /// Earth Mean Equator and Equinox of J2000
  pub const EME2000: Self = Self(0);
  ///  Geocentric Celestial Reference Frame
  pub const GCRF: Self = Self(1);
  /// Greenwich Rotating Coordinates
  pub const GRC: Self = Self(2);
  /// International Celestial Reference Frame
  pub const ICRF: Self = Self(3);
  /// International Terrestrial Reference Frame 2000
  pub const ITRF2000: Self = Self(4);
  /// International Terrestrial Reference Frame 1993
  pub const ITRF93: Self = Self(5);
  /// International Terrestrial Reference Frame 1997
  pub const ITRF97: Self = Self(6);
  /// Mars Centered Inertial
  pub const MCI: Self = Self(7);
  /// True of Date, Rotating
  pub const TDR: Self = Self(8);
  /// True Equator Mean Equinox
  pub const TEME: Self = Self(9);
  /// True of Date
  pub const TOD: Self = Self(10);
  /// Vehicle-Body-Local-Horizontal (VVLH): An orbit reference frame with X-axis pointing from the center of the central body to the vehicle, Z-axis oppoOBSERVER to the orbital angular momentum vector, and Y-axis completing the right-handed system.
  pub const VVLH: Self = Self(11);
  /// Radial-Intrack-Crosstrack (RIC): A local orbital reference frame with the radial axis pointing away from the central body, the intrack axis in the direction of motion, and the crosstrack axis completing the right-handed system.
  pub const RIC: Self = Self(12);
  /// Vehicle-Local-Vertical-Local-Horizontal (VLVH): An orbit reference frame similar to VVLH, often used in close proximity operations or surface-oriented missions.
  pub const VLVH: Self = Self(13);
  /// East-North-Up (ENU): A terrestrial reference frame where the X-axis points East, the Y-axis points North, and the Z-axis points Up (away from the center of the Earth).
  pub const ENU: Self = Self(14);
  /// North-East-Down (NED): Similar to ENU, but with axes oriented Northward, Eastward, and Downward towards the Earth's center.
  pub const NED: Self = Self(15);
  /// Local Tangent Plane (LTP): A local, surface-fixed reference frame often used for terrestrial applications, aligned with the local horizon.
  pub const LTP: Self = Self(16);
  /// Local Vertical-Local Horizontal (LVLH): An orbit reference frame with the Z-axis pointing towards the center of the central body (oppoOBSERVER to local vertical), the X-axis in the velocity direction (local horizontal), and the Y-axis completing the right-hand system.
  pub const LVLH: Self = Self(17);
  /// Polar-North-East (PNE): A variation of local coordinate systems typically used in polar regions, with axes aligned toward the geographic North Pole, Eastward, and perpendicular to the Earth's surface.
  pub const PNE: Self = Self(18);
  /// Body-Fixed Reference Frame (BRF): A reference frame fixed to the body of a spacecraft or celestial object, oriented according to the body's principal axes.
  pub const BRF: Self = Self(19);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 19;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EME2000,
    Self::GCRF,
    Self::GRC,
    Self::ICRF,
    Self::ITRF2000,
    Self::ITRF93,
    Self::ITRF97,
    Self::MCI,
    Self::TDR,
    Self::TEME,
    Self::TOD,
    Self::VVLH,
    Self::RIC,
    Self::VLVH,
    Self::ENU,
    Self::NED,
    Self::LTP,
    Self::LVLH,
    Self::PNE,
    Self::BRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EME2000 => Some("EME2000"),
      Self::GCRF => Some("GCRF"),
      Self::GRC => Some("GRC"),
      Self::ICRF => Some("ICRF"),
      Self::ITRF2000 => Some("ITRF2000"),
      Self::ITRF93 => Some("ITRF93"),
      Self::ITRF97 => Some("ITRF97"),
      Self::MCI => Some("MCI"),
      Self::TDR => Some("TDR"),
      Self::TEME => Some("TEME"),
      Self::TOD => Some("TOD"),
      Self::VVLH => Some("VVLH"),
      Self::RIC => Some("RIC"),
      Self::VLVH => Some("VLVH"),
      Self::ENU => Some("ENU"),
      Self::NED => Some("NED"),
      Self::LTP => Some("LTP"),
      Self::LVLH => Some("LVLH"),
      Self::PNE => Some("PNE"),
      Self::BRF => Some("BRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OBSERVERLocationReferenceFrame {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OBSERVERLocationReferenceFrame {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OBSERVERLocationReferenceFrame {
    type Output = OBSERVERLocationReferenceFrame;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OBSERVERLocationReferenceFrame {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OBSERVERLocationReferenceFrame {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OBSERVERLocationReferenceFrame {}
pub enum TDMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Tracking Data Message
pub struct TDM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TDM<'a> {
  type Inner = TDM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TDM<'a> {
  pub const VT_OBSERVER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OBSERVER_X: flatbuffers::VOffsetT = 6;
  pub const VT_OBSERVER_Y: flatbuffers::VOffsetT = 8;
  pub const VT_OBSERVER_Z: flatbuffers::VOffsetT = 10;
  pub const VT_OBSERVER_VX: flatbuffers::VOffsetT = 12;
  pub const VT_OBSERVER_VY: flatbuffers::VOffsetT = 14;
  pub const VT_OBSERVER_VZ: flatbuffers::VOffsetT = 16;
  pub const VT_OBSERVER_POSITION_REFERENCE_FRAME: flatbuffers::VOffsetT = 18;
  pub const VT_OBS_REFERENCE_FRAME: flatbuffers::VOffsetT = 20;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 22;
  pub const VT_CCSDS_TDM_VERS: flatbuffers::VOffsetT = 24;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 26;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 28;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 30;
  pub const VT_META_START: flatbuffers::VOffsetT = 32;
  pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 34;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 36;
  pub const VT_STOP_TIME: flatbuffers::VOffsetT = 38;
  pub const VT_PARTICIPANT_1: flatbuffers::VOffsetT = 40;
  pub const VT_PARTICIPANT_2: flatbuffers::VOffsetT = 42;
  pub const VT_PARTICIPANT_3: flatbuffers::VOffsetT = 44;
  pub const VT_MODE: flatbuffers::VOffsetT = 46;
  pub const VT_PATH_1: flatbuffers::VOffsetT = 48;
  pub const VT_PATH_2: flatbuffers::VOffsetT = 50;
  pub const VT_TRANSMIT_BAND: flatbuffers::VOffsetT = 52;
  pub const VT_RECEIVE_BAND: flatbuffers::VOffsetT = 54;
  pub const VT_INTEGRATION_INTERVAL: flatbuffers::VOffsetT = 56;
  pub const VT_INTEGRATION_REF: flatbuffers::VOffsetT = 58;
  pub const VT_RECEIVE_DELAY_2: flatbuffers::VOffsetT = 60;
  pub const VT_RECEIVE_DELAY_3: flatbuffers::VOffsetT = 62;
  pub const VT_DATA_QUALITY: flatbuffers::VOffsetT = 64;
  pub const VT_META_STOP: flatbuffers::VOffsetT = 66;
  pub const VT_DATA_START: flatbuffers::VOffsetT = 68;
  pub const VT_TRANSMIT_FREQ_1: flatbuffers::VOffsetT = 70;
  pub const VT_RECEIVE_FREQ: flatbuffers::VOffsetT = 72;
  pub const VT_DATA_STOP: flatbuffers::VOffsetT = 74;
  pub const VT_TIMETAG_REF: flatbuffers::VOffsetT = 76;
  pub const VT_ANGLE_TYPE: flatbuffers::VOffsetT = 78;
  pub const VT_ANGLE_1: flatbuffers::VOffsetT = 80;
  pub const VT_ANGLE_2: flatbuffers::VOffsetT = 82;
  pub const VT_ANGLE_UNCERTAINTY_1: flatbuffers::VOffsetT = 84;
  pub const VT_ANGLE_UNCERTAINTY_2: flatbuffers::VOffsetT = 86;
  pub const VT_RANGE_RATE: flatbuffers::VOffsetT = 88;
  pub const VT_RANGE_UNCERTAINTY: flatbuffers::VOffsetT = 90;
  pub const VT_RANGE_MODE: flatbuffers::VOffsetT = 92;
  pub const VT_RANGE_MODULUS: flatbuffers::VOffsetT = 94;
  pub const VT_CORRECTION_ANGLE_1: flatbuffers::VOffsetT = 96;
  pub const VT_CORRECTION_ANGLE_2: flatbuffers::VOffsetT = 98;
  pub const VT_CORRECTIONS_APPLIED: flatbuffers::VOffsetT = 100;
  pub const VT_TROPO_DRY: flatbuffers::VOffsetT = 102;
  pub const VT_TROPO_WET: flatbuffers::VOffsetT = 104;
  pub const VT_STEC: flatbuffers::VOffsetT = 106;
  pub const VT_PRESSURE: flatbuffers::VOffsetT = 108;
  pub const VT_RHUMIDITY: flatbuffers::VOffsetT = 110;
  pub const VT_TEMPERATURE: flatbuffers::VOffsetT = 112;
  pub const VT_CLOCK_BIAS: flatbuffers::VOffsetT = 114;
  pub const VT_CLOCK_DRIFT: flatbuffers::VOffsetT = 116;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TDM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TDMArgs<'args>
  ) -> flatbuffers::WIPOffset<TDM<'bldr>> {
    let mut builder = TDMBuilder::new(_fbb);
    builder.add_RANGE_MODULUS(args.RANGE_MODULUS);
    builder.add_RANGE_UNCERTAINTY(args.RANGE_UNCERTAINTY);
    builder.add_RANGE_RATE(args.RANGE_RATE);
    builder.add_TRANSMIT_FREQ_1(args.TRANSMIT_FREQ_1);
    builder.add_RECEIVE_DELAY_3(args.RECEIVE_DELAY_3);
    builder.add_RECEIVE_DELAY_2(args.RECEIVE_DELAY_2);
    builder.add_OBSERVER_VZ(args.OBSERVER_VZ);
    builder.add_OBSERVER_VY(args.OBSERVER_VY);
    builder.add_OBSERVER_VX(args.OBSERVER_VX);
    builder.add_OBSERVER_Z(args.OBSERVER_Z);
    builder.add_OBSERVER_Y(args.OBSERVER_Y);
    builder.add_OBSERVER_X(args.OBSERVER_X);
    if let Some(x) = args.CLOCK_DRIFT { builder.add_CLOCK_DRIFT(x); }
    if let Some(x) = args.CLOCK_BIAS { builder.add_CLOCK_BIAS(x); }
    if let Some(x) = args.TEMPERATURE { builder.add_TEMPERATURE(x); }
    if let Some(x) = args.RHUMIDITY { builder.add_RHUMIDITY(x); }
    if let Some(x) = args.PRESSURE { builder.add_PRESSURE(x); }
    if let Some(x) = args.STEC { builder.add_STEC(x); }
    if let Some(x) = args.TROPO_WET { builder.add_TROPO_WET(x); }
    if let Some(x) = args.TROPO_DRY { builder.add_TROPO_DRY(x); }
    if let Some(x) = args.CORRECTIONS_APPLIED { builder.add_CORRECTIONS_APPLIED(x); }
    builder.add_CORRECTION_ANGLE_2(args.CORRECTION_ANGLE_2);
    builder.add_CORRECTION_ANGLE_1(args.CORRECTION_ANGLE_1);
    if let Some(x) = args.RANGE_MODE { builder.add_RANGE_MODE(x); }
    builder.add_ANGLE_UNCERTAINTY_2(args.ANGLE_UNCERTAINTY_2);
    builder.add_ANGLE_UNCERTAINTY_1(args.ANGLE_UNCERTAINTY_1);
    if let Some(x) = args.ANGLE_2 { builder.add_ANGLE_2(x); }
    if let Some(x) = args.ANGLE_1 { builder.add_ANGLE_1(x); }
    if let Some(x) = args.ANGLE_TYPE { builder.add_ANGLE_TYPE(x); }
    if let Some(x) = args.TIMETAG_REF { builder.add_TIMETAG_REF(x); }
    if let Some(x) = args.DATA_STOP { builder.add_DATA_STOP(x); }
    if let Some(x) = args.RECEIVE_FREQ { builder.add_RECEIVE_FREQ(x); }
    if let Some(x) = args.DATA_START { builder.add_DATA_START(x); }
    if let Some(x) = args.META_STOP { builder.add_META_STOP(x); }
    if let Some(x) = args.DATA_QUALITY { builder.add_DATA_QUALITY(x); }
    if let Some(x) = args.INTEGRATION_REF { builder.add_INTEGRATION_REF(x); }
    builder.add_INTEGRATION_INTERVAL(args.INTEGRATION_INTERVAL);
    if let Some(x) = args.RECEIVE_BAND { builder.add_RECEIVE_BAND(x); }
    if let Some(x) = args.TRANSMIT_BAND { builder.add_TRANSMIT_BAND(x); }
    if let Some(x) = args.MODE { builder.add_MODE(x); }
    if let Some(x) = args.PARTICIPANT_3 { builder.add_PARTICIPANT_3(x); }
    if let Some(x) = args.PARTICIPANT_2 { builder.add_PARTICIPANT_2(x); }
    if let Some(x) = args.PARTICIPANT_1 { builder.add_PARTICIPANT_1(x); }
    if let Some(x) = args.STOP_TIME { builder.add_STOP_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.TIME_SYSTEM { builder.add_TIME_SYSTEM(x); }
    if let Some(x) = args.META_START { builder.add_META_START(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    if let Some(x) = args.CCSDS_TDM_VERS { builder.add_CCSDS_TDM_VERS(x); }
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    if let Some(x) = args.OBSERVER_ID { builder.add_OBSERVER_ID(x); }
    builder.add_PATH_2(args.PATH_2);
    builder.add_PATH_1(args.PATH_1);
    builder.add_OBS_REFERENCE_FRAME(args.OBS_REFERENCE_FRAME);
    builder.add_OBSERVER_POSITION_REFERENCE_FRAME(args.OBSERVER_POSITION_REFERENCE_FRAME);
    builder.finish()
  }

  pub fn unpack(&self) -> TDMT {
    let OBSERVER_ID = self.OBSERVER_ID().map(|x| {
      x.to_string()
    });
    let OBSERVER_X = self.OBSERVER_X();
    let OBSERVER_Y = self.OBSERVER_Y();
    let OBSERVER_Z = self.OBSERVER_Z();
    let OBSERVER_VX = self.OBSERVER_VX();
    let OBSERVER_VY = self.OBSERVER_VY();
    let OBSERVER_VZ = self.OBSERVER_VZ();
    let OBSERVER_POSITION_REFERENCE_FRAME = self.OBSERVER_POSITION_REFERENCE_FRAME();
    let OBS_REFERENCE_FRAME = self.OBS_REFERENCE_FRAME();
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let CCSDS_TDM_VERS = self.CCSDS_TDM_VERS().map(|x| {
      x.to_string()
    });
    let COMMENT = self.COMMENT().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let META_START = self.META_START().map(|x| {
      x.to_string()
    });
    let TIME_SYSTEM = self.TIME_SYSTEM().map(|x| {
      x.to_string()
    });
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let STOP_TIME = self.STOP_TIME().map(|x| {
      x.to_string()
    });
    let PARTICIPANT_1 = self.PARTICIPANT_1().map(|x| {
      x.to_string()
    });
    let PARTICIPANT_2 = self.PARTICIPANT_2().map(|x| {
      x.to_string()
    });
    let PARTICIPANT_3 = self.PARTICIPANT_3().map(|x| {
      x.to_string()
    });
    let MODE = self.MODE().map(|x| {
      x.to_string()
    });
    let PATH_1 = self.PATH_1();
    let PATH_2 = self.PATH_2();
    let TRANSMIT_BAND = self.TRANSMIT_BAND().map(|x| {
      x.to_string()
    });
    let RECEIVE_BAND = self.RECEIVE_BAND().map(|x| {
      x.to_string()
    });
    let INTEGRATION_INTERVAL = self.INTEGRATION_INTERVAL();
    let INTEGRATION_REF = self.INTEGRATION_REF().map(|x| {
      x.to_string()
    });
    let RECEIVE_DELAY_2 = self.RECEIVE_DELAY_2();
    let RECEIVE_DELAY_3 = self.RECEIVE_DELAY_3();
    let DATA_QUALITY = self.DATA_QUALITY().map(|x| {
      x.to_string()
    });
    let META_STOP = self.META_STOP().map(|x| {
      x.to_string()
    });
    let DATA_START = self.DATA_START().map(|x| {
      x.to_string()
    });
    let TRANSMIT_FREQ_1 = self.TRANSMIT_FREQ_1();
    let RECEIVE_FREQ = self.RECEIVE_FREQ().map(|x| {
      x.into_iter().collect()
    });
    let DATA_STOP = self.DATA_STOP().map(|x| {
      x.to_string()
    });
    let TIMETAG_REF = self.TIMETAG_REF().map(|x| {
      x.to_string()
    });
    let ANGLE_TYPE = self.ANGLE_TYPE().map(|x| {
      x.to_string()
    });
    let ANGLE_1 = self.ANGLE_1().map(|x| {
      x.into_iter().collect()
    });
    let ANGLE_2 = self.ANGLE_2().map(|x| {
      x.into_iter().collect()
    });
    let ANGLE_UNCERTAINTY_1 = self.ANGLE_UNCERTAINTY_1();
    let ANGLE_UNCERTAINTY_2 = self.ANGLE_UNCERTAINTY_2();
    let RANGE_RATE = self.RANGE_RATE();
    let RANGE_UNCERTAINTY = self.RANGE_UNCERTAINTY();
    let RANGE_MODE = self.RANGE_MODE().map(|x| {
      x.to_string()
    });
    let RANGE_MODULUS = self.RANGE_MODULUS();
    let CORRECTION_ANGLE_1 = self.CORRECTION_ANGLE_1();
    let CORRECTION_ANGLE_2 = self.CORRECTION_ANGLE_2();
    let CORRECTIONS_APPLIED = self.CORRECTIONS_APPLIED().map(|x| {
      x.to_string()
    });
    let TROPO_DRY = self.TROPO_DRY().map(|x| {
      x.into_iter().collect()
    });
    let TROPO_WET = self.TROPO_WET().map(|x| {
      x.into_iter().collect()
    });
    let STEC = self.STEC().map(|x| {
      x.into_iter().collect()
    });
    let PRESSURE = self.PRESSURE().map(|x| {
      x.into_iter().collect()
    });
    let RHUMIDITY = self.RHUMIDITY().map(|x| {
      x.into_iter().collect()
    });
    let TEMPERATURE = self.TEMPERATURE().map(|x| {
      x.into_iter().collect()
    });
    let CLOCK_BIAS = self.CLOCK_BIAS().map(|x| {
      x.into_iter().collect()
    });
    let CLOCK_DRIFT = self.CLOCK_DRIFT().map(|x| {
      x.into_iter().collect()
    });
    TDMT {
      OBSERVER_ID,
      OBSERVER_X,
      OBSERVER_Y,
      OBSERVER_Z,
      OBSERVER_VX,
      OBSERVER_VY,
      OBSERVER_VZ,
      OBSERVER_POSITION_REFERENCE_FRAME,
      OBS_REFERENCE_FRAME,
      EPOCH,
      CCSDS_TDM_VERS,
      COMMENT,
      CREATION_DATE,
      ORIGINATOR,
      META_START,
      TIME_SYSTEM,
      START_TIME,
      STOP_TIME,
      PARTICIPANT_1,
      PARTICIPANT_2,
      PARTICIPANT_3,
      MODE,
      PATH_1,
      PATH_2,
      TRANSMIT_BAND,
      RECEIVE_BAND,
      INTEGRATION_INTERVAL,
      INTEGRATION_REF,
      RECEIVE_DELAY_2,
      RECEIVE_DELAY_3,
      DATA_QUALITY,
      META_STOP,
      DATA_START,
      TRANSMIT_FREQ_1,
      RECEIVE_FREQ,
      DATA_STOP,
      TIMETAG_REF,
      ANGLE_TYPE,
      ANGLE_1,
      ANGLE_2,
      ANGLE_UNCERTAINTY_1,
      ANGLE_UNCERTAINTY_2,
      RANGE_RATE,
      RANGE_UNCERTAINTY,
      RANGE_MODE,
      RANGE_MODULUS,
      CORRECTION_ANGLE_1,
      CORRECTION_ANGLE_2,
      CORRECTIONS_APPLIED,
      TROPO_DRY,
      TROPO_WET,
      STEC,
      PRESSURE,
      RHUMIDITY,
      TEMPERATURE,
      CLOCK_BIAS,
      CLOCK_DRIFT,
    }
  }

  /// Unique identifier for the observation OBSERVER -  [Specific CCSDS Document]
  #[inline]
  pub fn OBSERVER_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_OBSERVER_ID, None)}
  }
  /// Cartesian X coordinate of the OBSERVER location in chosen reference frame
  #[inline]
  pub fn OBSERVER_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_X, Some(0.0)).unwrap()}
  }
  /// Cartesian Y coordinate of the OBSERVER location in chosen reference frame 
  #[inline]
  pub fn OBSERVER_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_Y, Some(0.0)).unwrap()}
  }
  /// Cartesian Z coordinate of the OBSERVER location in chosen reference frame 
  #[inline]
  pub fn OBSERVER_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_Z, Some(0.0)).unwrap()}
  }
  /// Cartesian X coordinate of the OBSERVER velocity in chosen reference frame
  #[inline]
  pub fn OBSERVER_VX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_VX, Some(0.0)).unwrap()}
  }
  /// Cartesian Y coordinate of the OBSERVER velocity in chosen reference frame 
  #[inline]
  pub fn OBSERVER_VY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_VY, Some(0.0)).unwrap()}
  }
  /// Cartesian Z coordinate of the OBSERVER velocity in chosen reference frame 
  #[inline]
  pub fn OBSERVER_VZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_OBSERVER_VZ, Some(0.0)).unwrap()}
  }
  /// Reference frame used for OBSERVER location Cartesian coordinates (e.g., ECEF, ECI)
  #[inline]
  pub fn OBSERVER_POSITION_REFERENCE_FRAME(&self) -> OBSERVERLocationReferenceFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OBSERVERLocationReferenceFrame>(TDM::VT_OBSERVER_POSITION_REFERENCE_FRAME, Some(OBSERVERLocationReferenceFrame::EME2000)).unwrap()}
  }
  /// Reference frame used for obs location Cartesian coordinates (e.g., ECEF, ECI)
  #[inline]
  pub fn OBS_REFERENCE_FRAME(&self) -> OBSERVERLocationReferenceFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OBSERVERLocationReferenceFrame>(TDM::VT_OBS_REFERENCE_FRAME, Some(OBSERVERLocationReferenceFrame::EME2000)).unwrap()}
  }
  /// Epoch or observation time -  CCSDS 503.0-B-1
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_EPOCH, None)}
  }
  /// TDM version number -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn CCSDS_TDM_VERS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_CCSDS_TDM_VERS, None)}
  }
  /// Comments regarding TDM -  various sections, e.g., Page D-9
  #[inline]
  pub fn COMMENT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TDM::VT_COMMENT, None)}
  }
  /// Date of TDM creation -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_CREATION_DATE, None)}
  }
  /// Originator of the TDM -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_ORIGINATOR, None)}
  }
  /// Start of metadata section -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn META_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_META_START, None)}
  }
  /// Time system used -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn TIME_SYSTEM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_TIME_SYSTEM, None)}
  }
  /// Start time of the data -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_START_TIME, None)}
  }
  /// Stop time of the data -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_STOP_TIME, None)}
  }
  /// First participant in the TDM -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn PARTICIPANT_1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_PARTICIPANT_1, None)}
  }
  /// Second participant in the TDM -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn PARTICIPANT_2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_PARTICIPANT_2, None)}
  }
  /// Third participant in the TDM (if applicable) -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn PARTICIPANT_3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_PARTICIPANT_3, None)}
  }
  /// Mode of TDM -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_MODE, None)}
  }
  /// First path in TDM -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn PATH_1(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TDM::VT_PATH_1, Some(0)).unwrap()}
  }
  /// Second path in TDM (if applicable) -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn PATH_2(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TDM::VT_PATH_2, Some(0)).unwrap()}
  }
  /// Transmit band -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn TRANSMIT_BAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_TRANSMIT_BAND, None)}
  }
  /// Receive band -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn RECEIVE_BAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_RECEIVE_BAND, None)}
  }
  /// Integration interval -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn INTEGRATION_INTERVAL(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TDM::VT_INTEGRATION_INTERVAL, Some(0.0)).unwrap()}
  }
  /// Integration reference -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn INTEGRATION_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_INTEGRATION_REF, None)}
  }
  /// Receive delay for second participant -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn RECEIVE_DELAY_2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_RECEIVE_DELAY_2, Some(0.0)).unwrap()}
  }
  /// Receive delay for third participant -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn RECEIVE_DELAY_3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_RECEIVE_DELAY_3, Some(0.0)).unwrap()}
  }
  /// Data quality -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn DATA_QUALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_DATA_QUALITY, None)}
  }
  /// End of metadata section -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn META_STOP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_META_STOP, None)}
  }
  /// Start of data section -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn DATA_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_DATA_START, None)}
  }
  /// Transmit frequency for first participant -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn TRANSMIT_FREQ_1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_TRANSMIT_FREQ_1, Some(0.0)).unwrap()}
  }
  /// Receive frequency -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn RECEIVE_FREQ(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_RECEIVE_FREQ, None)}
  }
  /// End of data section -  CCSDS 503.0-B-1, Page D-9
  #[inline]
  pub fn DATA_STOP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_DATA_STOP, None)}
  }
  /// Additional properties as required by the specific application of the TDM...
  /// Reference for time tagging -  CCSDS 503.0-B-1, Page D-10
  #[inline]
  pub fn TIMETAG_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_TIMETAG_REF, None)}
  }
  /// Type of angle data -  CCSDS 503.0-B-1, Page D-12
  /// Can be AZEL, RADEC, XEYN, XSYE, or another value with provided ICD
  #[inline]
  pub fn ANGLE_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_ANGLE_TYPE, None)}
  }
  /// First angle value -  CCSDS 503.0-B-1, Page D-12
  #[inline]
  pub fn ANGLE_1(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TDM::VT_ANGLE_1, None)}
  }
  /// Second angle value -  CCSDS 503.0-B-1, Page D-12
  #[inline]
  pub fn ANGLE_2(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(TDM::VT_ANGLE_2, None)}
  }
  /// Uncertainty of first angle -  CCSDS 503.0-B-1
  #[inline]
  pub fn ANGLE_UNCERTAINTY_1(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TDM::VT_ANGLE_UNCERTAINTY_1, Some(0.0)).unwrap()}
  }
  /// Uncertainty of second angle -  CCSDS 503.0-B-1
  #[inline]
  pub fn ANGLE_UNCERTAINTY_2(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TDM::VT_ANGLE_UNCERTAINTY_2, Some(0.0)).unwrap()}
  }
  /// Rate of change of range -  CCSDS 503.0-B-1
  #[inline]
  pub fn RANGE_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_RANGE_RATE, Some(0.0)).unwrap()}
  }
  /// Uncertainty in range -  CCSDS 503.0-B-1
  #[inline]
  pub fn RANGE_UNCERTAINTY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_RANGE_UNCERTAINTY, Some(0.0)).unwrap()}
  }
  /// Mode of range data -  CCSDS 503.0-B-1, Page D-10
  #[inline]
  pub fn RANGE_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_RANGE_MODE, None)}
  }
  /// Modulus value for range data -  CCSDS 503.0-B-1, Page D-10
  #[inline]
  pub fn RANGE_MODULUS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TDM::VT_RANGE_MODULUS, Some(0.0)).unwrap()}
  }
  /// First correction angle -  CCSDS 503.0-B-1, Page D-12
  #[inline]
  pub fn CORRECTION_ANGLE_1(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TDM::VT_CORRECTION_ANGLE_1, Some(0.0)).unwrap()}
  }
  /// Second correction angle -  CCSDS 503.0-B-1, Page D-12
  #[inline]
  pub fn CORRECTION_ANGLE_2(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TDM::VT_CORRECTION_ANGLE_2, Some(0.0)).unwrap()}
  }
  /// Indicator of corrections applied -  CCSDS 503.0-B-1, Page D-12
  #[inline]
  pub fn CORRECTIONS_APPLIED(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TDM::VT_CORRECTIONS_APPLIED, None)}
  }
  /// Dry component of tropospheric delay -  CCSDS 503.0-B-1, Page D-14
  #[inline]
  pub fn TROPO_DRY(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_TROPO_DRY, None)}
  }
  /// Wet component of tropospheric delay -  CCSDS 503.0-B-1, Page D-14
  #[inline]
  pub fn TROPO_WET(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_TROPO_WET, None)}
  }
  /// Slant total electron content -  CCSDS 503.0-B-1, Page D-13
  #[inline]
  pub fn STEC(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_STEC, None)}
  }
  /// Atmospheric pressure -  CCSDS 503.0-B-1, Page D-14
  #[inline]
  pub fn PRESSURE(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_PRESSURE, None)}
  }
  /// Relative humidity -  CCSDS 503.0-B-1, Page D-14
  #[inline]
  pub fn RHUMIDITY(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_RHUMIDITY, None)}
  }
  /// Ambient temperature -  CCSDS 503.0-B-1, Page D-14
  #[inline]
  pub fn TEMPERATURE(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_TEMPERATURE, None)}
  }
  /// Clock bias values -  CCSDS 503.0-B-1, Page D-15
  #[inline]
  pub fn CLOCK_BIAS(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_CLOCK_BIAS, None)}
  }
  /// Clock drift values -  CCSDS 503.0-B-1, Page D-15
  #[inline]
  pub fn CLOCK_DRIFT(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TDM::VT_CLOCK_DRIFT, None)}
  }
}

impl flatbuffers::Verifiable for TDM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVER_ID", Self::VT_OBSERVER_ID, false)?
     .visit_field::<f64>("OBSERVER_X", Self::VT_OBSERVER_X, false)?
     .visit_field::<f64>("OBSERVER_Y", Self::VT_OBSERVER_Y, false)?
     .visit_field::<f64>("OBSERVER_Z", Self::VT_OBSERVER_Z, false)?
     .visit_field::<f64>("OBSERVER_VX", Self::VT_OBSERVER_VX, false)?
     .visit_field::<f64>("OBSERVER_VY", Self::VT_OBSERVER_VY, false)?
     .visit_field::<f64>("OBSERVER_VZ", Self::VT_OBSERVER_VZ, false)?
     .visit_field::<OBSERVERLocationReferenceFrame>("OBSERVER_POSITION_REFERENCE_FRAME", Self::VT_OBSERVER_POSITION_REFERENCE_FRAME, false)?
     .visit_field::<OBSERVERLocationReferenceFrame>("OBS_REFERENCE_FRAME", Self::VT_OBS_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CCSDS_TDM_VERS", Self::VT_CCSDS_TDM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("META_START", Self::VT_META_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME_SYSTEM", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STOP_TIME", Self::VT_STOP_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARTICIPANT_1", Self::VT_PARTICIPANT_1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARTICIPANT_2", Self::VT_PARTICIPANT_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARTICIPANT_3", Self::VT_PARTICIPANT_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MODE", Self::VT_MODE, false)?
     .visit_field::<u16>("PATH_1", Self::VT_PATH_1, false)?
     .visit_field::<u16>("PATH_2", Self::VT_PATH_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSMIT_BAND", Self::VT_TRANSMIT_BAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RECEIVE_BAND", Self::VT_RECEIVE_BAND, false)?
     .visit_field::<f32>("INTEGRATION_INTERVAL", Self::VT_INTEGRATION_INTERVAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INTEGRATION_REF", Self::VT_INTEGRATION_REF, false)?
     .visit_field::<f64>("RECEIVE_DELAY_2", Self::VT_RECEIVE_DELAY_2, false)?
     .visit_field::<f64>("RECEIVE_DELAY_3", Self::VT_RECEIVE_DELAY_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_QUALITY", Self::VT_DATA_QUALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("META_STOP", Self::VT_META_STOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_START", Self::VT_DATA_START, false)?
     .visit_field::<f64>("TRANSMIT_FREQ_1", Self::VT_TRANSMIT_FREQ_1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("RECEIVE_FREQ", Self::VT_RECEIVE_FREQ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_STOP", Self::VT_DATA_STOP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIMETAG_REF", Self::VT_TIMETAG_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ANGLE_TYPE", Self::VT_ANGLE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("ANGLE_1", Self::VT_ANGLE_1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("ANGLE_2", Self::VT_ANGLE_2, false)?
     .visit_field::<f32>("ANGLE_UNCERTAINTY_1", Self::VT_ANGLE_UNCERTAINTY_1, false)?
     .visit_field::<f32>("ANGLE_UNCERTAINTY_2", Self::VT_ANGLE_UNCERTAINTY_2, false)?
     .visit_field::<f64>("RANGE_RATE", Self::VT_RANGE_RATE, false)?
     .visit_field::<f64>("RANGE_UNCERTAINTY", Self::VT_RANGE_UNCERTAINTY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RANGE_MODE", Self::VT_RANGE_MODE, false)?
     .visit_field::<f64>("RANGE_MODULUS", Self::VT_RANGE_MODULUS, false)?
     .visit_field::<f32>("CORRECTION_ANGLE_1", Self::VT_CORRECTION_ANGLE_1, false)?
     .visit_field::<f32>("CORRECTION_ANGLE_2", Self::VT_CORRECTION_ANGLE_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CORRECTIONS_APPLIED", Self::VT_CORRECTIONS_APPLIED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("TROPO_DRY", Self::VT_TROPO_DRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("TROPO_WET", Self::VT_TROPO_WET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("STEC", Self::VT_STEC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("PRESSURE", Self::VT_PRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("RHUMIDITY", Self::VT_RHUMIDITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("TEMPERATURE", Self::VT_TEMPERATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("CLOCK_BIAS", Self::VT_CLOCK_BIAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("CLOCK_DRIFT", Self::VT_CLOCK_DRIFT, false)?
     .finish();
    Ok(())
  }
}
pub struct TDMArgs<'a> {
    pub OBSERVER_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVER_X: f64,
    pub OBSERVER_Y: f64,
    pub OBSERVER_Z: f64,
    pub OBSERVER_VX: f64,
    pub OBSERVER_VY: f64,
    pub OBSERVER_VZ: f64,
    pub OBSERVER_POSITION_REFERENCE_FRAME: OBSERVERLocationReferenceFrame,
    pub OBS_REFERENCE_FRAME: OBSERVERLocationReferenceFrame,
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CCSDS_TDM_VERS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COMMENT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub META_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_SYSTEM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARTICIPANT_1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARTICIPANT_2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARTICIPANT_3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PATH_1: u16,
    pub PATH_2: u16,
    pub TRANSMIT_BAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RECEIVE_BAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTEGRATION_INTERVAL: f32,
    pub INTEGRATION_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RECEIVE_DELAY_2: f64,
    pub RECEIVE_DELAY_3: f64,
    pub DATA_QUALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub META_STOP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSMIT_FREQ_1: f64,
    pub RECEIVE_FREQ: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub DATA_STOP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIMETAG_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ANGLE_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ANGLE_1: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub ANGLE_2: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub ANGLE_UNCERTAINTY_1: f32,
    pub ANGLE_UNCERTAINTY_2: f32,
    pub RANGE_RATE: f64,
    pub RANGE_UNCERTAINTY: f64,
    pub RANGE_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RANGE_MODULUS: f64,
    pub CORRECTION_ANGLE_1: f32,
    pub CORRECTION_ANGLE_2: f32,
    pub CORRECTIONS_APPLIED: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TROPO_DRY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub TROPO_WET: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub STEC: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub PRESSURE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub RHUMIDITY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub TEMPERATURE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub CLOCK_BIAS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub CLOCK_DRIFT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for TDMArgs<'a> {
  #[inline]
  fn default() -> Self {
    TDMArgs {
      OBSERVER_ID: None,
      OBSERVER_X: 0.0,
      OBSERVER_Y: 0.0,
      OBSERVER_Z: 0.0,
      OBSERVER_VX: 0.0,
      OBSERVER_VY: 0.0,
      OBSERVER_VZ: 0.0,
      OBSERVER_POSITION_REFERENCE_FRAME: OBSERVERLocationReferenceFrame::EME2000,
      OBS_REFERENCE_FRAME: OBSERVERLocationReferenceFrame::EME2000,
      EPOCH: None,
      CCSDS_TDM_VERS: None,
      COMMENT: None,
      CREATION_DATE: None,
      ORIGINATOR: None,
      META_START: None,
      TIME_SYSTEM: None,
      START_TIME: None,
      STOP_TIME: None,
      PARTICIPANT_1: None,
      PARTICIPANT_2: None,
      PARTICIPANT_3: None,
      MODE: None,
      PATH_1: 0,
      PATH_2: 0,
      TRANSMIT_BAND: None,
      RECEIVE_BAND: None,
      INTEGRATION_INTERVAL: 0.0,
      INTEGRATION_REF: None,
      RECEIVE_DELAY_2: 0.0,
      RECEIVE_DELAY_3: 0.0,
      DATA_QUALITY: None,
      META_STOP: None,
      DATA_START: None,
      TRANSMIT_FREQ_1: 0.0,
      RECEIVE_FREQ: None,
      DATA_STOP: None,
      TIMETAG_REF: None,
      ANGLE_TYPE: None,
      ANGLE_1: None,
      ANGLE_2: None,
      ANGLE_UNCERTAINTY_1: 0.0,
      ANGLE_UNCERTAINTY_2: 0.0,
      RANGE_RATE: 0.0,
      RANGE_UNCERTAINTY: 0.0,
      RANGE_MODE: None,
      RANGE_MODULUS: 0.0,
      CORRECTION_ANGLE_1: 0.0,
      CORRECTION_ANGLE_2: 0.0,
      CORRECTIONS_APPLIED: None,
      TROPO_DRY: None,
      TROPO_WET: None,
      STEC: None,
      PRESSURE: None,
      RHUMIDITY: None,
      TEMPERATURE: None,
      CLOCK_BIAS: None,
      CLOCK_DRIFT: None,
    }
  }
}

pub struct TDMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TDMBuilder<'a, 'b> {
  #[inline]
  pub fn add_OBSERVER_ID(&mut self, OBSERVER_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_OBSERVER_ID, OBSERVER_ID);
  }
  #[inline]
  pub fn add_OBSERVER_X(&mut self, OBSERVER_X: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_X, OBSERVER_X, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_Y(&mut self, OBSERVER_Y: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_Y, OBSERVER_Y, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_Z(&mut self, OBSERVER_Z: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_Z, OBSERVER_Z, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_VX(&mut self, OBSERVER_VX: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_VX, OBSERVER_VX, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_VY(&mut self, OBSERVER_VY: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_VY, OBSERVER_VY, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_VZ(&mut self, OBSERVER_VZ: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_OBSERVER_VZ, OBSERVER_VZ, 0.0);
  }
  #[inline]
  pub fn add_OBSERVER_POSITION_REFERENCE_FRAME(&mut self, OBSERVER_POSITION_REFERENCE_FRAME: OBSERVERLocationReferenceFrame) {
    self.fbb_.push_slot::<OBSERVERLocationReferenceFrame>(TDM::VT_OBSERVER_POSITION_REFERENCE_FRAME, OBSERVER_POSITION_REFERENCE_FRAME, OBSERVERLocationReferenceFrame::EME2000);
  }
  #[inline]
  pub fn add_OBS_REFERENCE_FRAME(&mut self, OBS_REFERENCE_FRAME: OBSERVERLocationReferenceFrame) {
    self.fbb_.push_slot::<OBSERVERLocationReferenceFrame>(TDM::VT_OBS_REFERENCE_FRAME, OBS_REFERENCE_FRAME, OBSERVERLocationReferenceFrame::EME2000);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_CCSDS_TDM_VERS(&mut self, CCSDS_TDM_VERS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_CCSDS_TDM_VERS, CCSDS_TDM_VERS);
  }
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_META_START(&mut self, META_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_META_START, META_START);
  }
  #[inline]
  pub fn add_TIME_SYSTEM(&mut self, TIME_SYSTEM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_STOP_TIME(&mut self, STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_STOP_TIME, STOP_TIME);
  }
  #[inline]
  pub fn add_PARTICIPANT_1(&mut self, PARTICIPANT_1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_PARTICIPANT_1, PARTICIPANT_1);
  }
  #[inline]
  pub fn add_PARTICIPANT_2(&mut self, PARTICIPANT_2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_PARTICIPANT_2, PARTICIPANT_2);
  }
  #[inline]
  pub fn add_PARTICIPANT_3(&mut self, PARTICIPANT_3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_PARTICIPANT_3, PARTICIPANT_3);
  }
  #[inline]
  pub fn add_MODE(&mut self, MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_MODE, MODE);
  }
  #[inline]
  pub fn add_PATH_1(&mut self, PATH_1: u16) {
    self.fbb_.push_slot::<u16>(TDM::VT_PATH_1, PATH_1, 0);
  }
  #[inline]
  pub fn add_PATH_2(&mut self, PATH_2: u16) {
    self.fbb_.push_slot::<u16>(TDM::VT_PATH_2, PATH_2, 0);
  }
  #[inline]
  pub fn add_TRANSMIT_BAND(&mut self, TRANSMIT_BAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TRANSMIT_BAND, TRANSMIT_BAND);
  }
  #[inline]
  pub fn add_RECEIVE_BAND(&mut self, RECEIVE_BAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_RECEIVE_BAND, RECEIVE_BAND);
  }
  #[inline]
  pub fn add_INTEGRATION_INTERVAL(&mut self, INTEGRATION_INTERVAL: f32) {
    self.fbb_.push_slot::<f32>(TDM::VT_INTEGRATION_INTERVAL, INTEGRATION_INTERVAL, 0.0);
  }
  #[inline]
  pub fn add_INTEGRATION_REF(&mut self, INTEGRATION_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_INTEGRATION_REF, INTEGRATION_REF);
  }
  #[inline]
  pub fn add_RECEIVE_DELAY_2(&mut self, RECEIVE_DELAY_2: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_RECEIVE_DELAY_2, RECEIVE_DELAY_2, 0.0);
  }
  #[inline]
  pub fn add_RECEIVE_DELAY_3(&mut self, RECEIVE_DELAY_3: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_RECEIVE_DELAY_3, RECEIVE_DELAY_3, 0.0);
  }
  #[inline]
  pub fn add_DATA_QUALITY(&mut self, DATA_QUALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_DATA_QUALITY, DATA_QUALITY);
  }
  #[inline]
  pub fn add_META_STOP(&mut self, META_STOP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_META_STOP, META_STOP);
  }
  #[inline]
  pub fn add_DATA_START(&mut self, DATA_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_DATA_START, DATA_START);
  }
  #[inline]
  pub fn add_TRANSMIT_FREQ_1(&mut self, TRANSMIT_FREQ_1: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_TRANSMIT_FREQ_1, TRANSMIT_FREQ_1, 0.0);
  }
  #[inline]
  pub fn add_RECEIVE_FREQ(&mut self, RECEIVE_FREQ: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_RECEIVE_FREQ, RECEIVE_FREQ);
  }
  #[inline]
  pub fn add_DATA_STOP(&mut self, DATA_STOP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_DATA_STOP, DATA_STOP);
  }
  #[inline]
  pub fn add_TIMETAG_REF(&mut self, TIMETAG_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TIMETAG_REF, TIMETAG_REF);
  }
  #[inline]
  pub fn add_ANGLE_TYPE(&mut self, ANGLE_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_ANGLE_TYPE, ANGLE_TYPE);
  }
  #[inline]
  pub fn add_ANGLE_1(&mut self, ANGLE_1: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_ANGLE_1, ANGLE_1);
  }
  #[inline]
  pub fn add_ANGLE_2(&mut self, ANGLE_2: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_ANGLE_2, ANGLE_2);
  }
  #[inline]
  pub fn add_ANGLE_UNCERTAINTY_1(&mut self, ANGLE_UNCERTAINTY_1: f32) {
    self.fbb_.push_slot::<f32>(TDM::VT_ANGLE_UNCERTAINTY_1, ANGLE_UNCERTAINTY_1, 0.0);
  }
  #[inline]
  pub fn add_ANGLE_UNCERTAINTY_2(&mut self, ANGLE_UNCERTAINTY_2: f32) {
    self.fbb_.push_slot::<f32>(TDM::VT_ANGLE_UNCERTAINTY_2, ANGLE_UNCERTAINTY_2, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE(&mut self, RANGE_RATE: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_RANGE_RATE, RANGE_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_UNCERTAINTY(&mut self, RANGE_UNCERTAINTY: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_RANGE_UNCERTAINTY, RANGE_UNCERTAINTY, 0.0);
  }
  #[inline]
  pub fn add_RANGE_MODE(&mut self, RANGE_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_RANGE_MODE, RANGE_MODE);
  }
  #[inline]
  pub fn add_RANGE_MODULUS(&mut self, RANGE_MODULUS: f64) {
    self.fbb_.push_slot::<f64>(TDM::VT_RANGE_MODULUS, RANGE_MODULUS, 0.0);
  }
  #[inline]
  pub fn add_CORRECTION_ANGLE_1(&mut self, CORRECTION_ANGLE_1: f32) {
    self.fbb_.push_slot::<f32>(TDM::VT_CORRECTION_ANGLE_1, CORRECTION_ANGLE_1, 0.0);
  }
  #[inline]
  pub fn add_CORRECTION_ANGLE_2(&mut self, CORRECTION_ANGLE_2: f32) {
    self.fbb_.push_slot::<f32>(TDM::VT_CORRECTION_ANGLE_2, CORRECTION_ANGLE_2, 0.0);
  }
  #[inline]
  pub fn add_CORRECTIONS_APPLIED(&mut self, CORRECTIONS_APPLIED: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_CORRECTIONS_APPLIED, CORRECTIONS_APPLIED);
  }
  #[inline]
  pub fn add_TROPO_DRY(&mut self, TROPO_DRY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TROPO_DRY, TROPO_DRY);
  }
  #[inline]
  pub fn add_TROPO_WET(&mut self, TROPO_WET: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TROPO_WET, TROPO_WET);
  }
  #[inline]
  pub fn add_STEC(&mut self, STEC: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_STEC, STEC);
  }
  #[inline]
  pub fn add_PRESSURE(&mut self, PRESSURE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_PRESSURE, PRESSURE);
  }
  #[inline]
  pub fn add_RHUMIDITY(&mut self, RHUMIDITY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_RHUMIDITY, RHUMIDITY);
  }
  #[inline]
  pub fn add_TEMPERATURE(&mut self, TEMPERATURE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_TEMPERATURE, TEMPERATURE);
  }
  #[inline]
  pub fn add_CLOCK_BIAS(&mut self, CLOCK_BIAS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_CLOCK_BIAS, CLOCK_BIAS);
  }
  #[inline]
  pub fn add_CLOCK_DRIFT(&mut self, CLOCK_DRIFT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDM::VT_CLOCK_DRIFT, CLOCK_DRIFT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TDMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TDMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TDM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TDM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TDM");
      ds.field("OBSERVER_ID", &self.OBSERVER_ID());
      ds.field("OBSERVER_X", &self.OBSERVER_X());
      ds.field("OBSERVER_Y", &self.OBSERVER_Y());
      ds.field("OBSERVER_Z", &self.OBSERVER_Z());
      ds.field("OBSERVER_VX", &self.OBSERVER_VX());
      ds.field("OBSERVER_VY", &self.OBSERVER_VY());
      ds.field("OBSERVER_VZ", &self.OBSERVER_VZ());
      ds.field("OBSERVER_POSITION_REFERENCE_FRAME", &self.OBSERVER_POSITION_REFERENCE_FRAME());
      ds.field("OBS_REFERENCE_FRAME", &self.OBS_REFERENCE_FRAME());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("CCSDS_TDM_VERS", &self.CCSDS_TDM_VERS());
      ds.field("COMMENT", &self.COMMENT());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("META_START", &self.META_START());
      ds.field("TIME_SYSTEM", &self.TIME_SYSTEM());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("STOP_TIME", &self.STOP_TIME());
      ds.field("PARTICIPANT_1", &self.PARTICIPANT_1());
      ds.field("PARTICIPANT_2", &self.PARTICIPANT_2());
      ds.field("PARTICIPANT_3", &self.PARTICIPANT_3());
      ds.field("MODE", &self.MODE());
      ds.field("PATH_1", &self.PATH_1());
      ds.field("PATH_2", &self.PATH_2());
      ds.field("TRANSMIT_BAND", &self.TRANSMIT_BAND());
      ds.field("RECEIVE_BAND", &self.RECEIVE_BAND());
      ds.field("INTEGRATION_INTERVAL", &self.INTEGRATION_INTERVAL());
      ds.field("INTEGRATION_REF", &self.INTEGRATION_REF());
      ds.field("RECEIVE_DELAY_2", &self.RECEIVE_DELAY_2());
      ds.field("RECEIVE_DELAY_3", &self.RECEIVE_DELAY_3());
      ds.field("DATA_QUALITY", &self.DATA_QUALITY());
      ds.field("META_STOP", &self.META_STOP());
      ds.field("DATA_START", &self.DATA_START());
      ds.field("TRANSMIT_FREQ_1", &self.TRANSMIT_FREQ_1());
      ds.field("RECEIVE_FREQ", &self.RECEIVE_FREQ());
      ds.field("DATA_STOP", &self.DATA_STOP());
      ds.field("TIMETAG_REF", &self.TIMETAG_REF());
      ds.field("ANGLE_TYPE", &self.ANGLE_TYPE());
      ds.field("ANGLE_1", &self.ANGLE_1());
      ds.field("ANGLE_2", &self.ANGLE_2());
      ds.field("ANGLE_UNCERTAINTY_1", &self.ANGLE_UNCERTAINTY_1());
      ds.field("ANGLE_UNCERTAINTY_2", &self.ANGLE_UNCERTAINTY_2());
      ds.field("RANGE_RATE", &self.RANGE_RATE());
      ds.field("RANGE_UNCERTAINTY", &self.RANGE_UNCERTAINTY());
      ds.field("RANGE_MODE", &self.RANGE_MODE());
      ds.field("RANGE_MODULUS", &self.RANGE_MODULUS());
      ds.field("CORRECTION_ANGLE_1", &self.CORRECTION_ANGLE_1());
      ds.field("CORRECTION_ANGLE_2", &self.CORRECTION_ANGLE_2());
      ds.field("CORRECTIONS_APPLIED", &self.CORRECTIONS_APPLIED());
      ds.field("TROPO_DRY", &self.TROPO_DRY());
      ds.field("TROPO_WET", &self.TROPO_WET());
      ds.field("STEC", &self.STEC());
      ds.field("PRESSURE", &self.PRESSURE());
      ds.field("RHUMIDITY", &self.RHUMIDITY());
      ds.field("TEMPERATURE", &self.TEMPERATURE());
      ds.field("CLOCK_BIAS", &self.CLOCK_BIAS());
      ds.field("CLOCK_DRIFT", &self.CLOCK_DRIFT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TDMT {
  pub OBSERVER_ID: Option<String>,
  pub OBSERVER_X: f64,
  pub OBSERVER_Y: f64,
  pub OBSERVER_Z: f64,
  pub OBSERVER_VX: f64,
  pub OBSERVER_VY: f64,
  pub OBSERVER_VZ: f64,
  pub OBSERVER_POSITION_REFERENCE_FRAME: OBSERVERLocationReferenceFrame,
  pub OBS_REFERENCE_FRAME: OBSERVERLocationReferenceFrame,
  pub EPOCH: Option<String>,
  pub CCSDS_TDM_VERS: Option<String>,
  pub COMMENT: Option<Vec<String>>,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub META_START: Option<String>,
  pub TIME_SYSTEM: Option<String>,
  pub START_TIME: Option<String>,
  pub STOP_TIME: Option<String>,
  pub PARTICIPANT_1: Option<String>,
  pub PARTICIPANT_2: Option<String>,
  pub PARTICIPANT_3: Option<String>,
  pub MODE: Option<String>,
  pub PATH_1: u16,
  pub PATH_2: u16,
  pub TRANSMIT_BAND: Option<String>,
  pub RECEIVE_BAND: Option<String>,
  pub INTEGRATION_INTERVAL: f32,
  pub INTEGRATION_REF: Option<String>,
  pub RECEIVE_DELAY_2: f64,
  pub RECEIVE_DELAY_3: f64,
  pub DATA_QUALITY: Option<String>,
  pub META_STOP: Option<String>,
  pub DATA_START: Option<String>,
  pub TRANSMIT_FREQ_1: f64,
  pub RECEIVE_FREQ: Option<Vec<f64>>,
  pub DATA_STOP: Option<String>,
  pub TIMETAG_REF: Option<String>,
  pub ANGLE_TYPE: Option<String>,
  pub ANGLE_1: Option<Vec<f32>>,
  pub ANGLE_2: Option<Vec<f32>>,
  pub ANGLE_UNCERTAINTY_1: f32,
  pub ANGLE_UNCERTAINTY_2: f32,
  pub RANGE_RATE: f64,
  pub RANGE_UNCERTAINTY: f64,
  pub RANGE_MODE: Option<String>,
  pub RANGE_MODULUS: f64,
  pub CORRECTION_ANGLE_1: f32,
  pub CORRECTION_ANGLE_2: f32,
  pub CORRECTIONS_APPLIED: Option<String>,
  pub TROPO_DRY: Option<Vec<f64>>,
  pub TROPO_WET: Option<Vec<f64>>,
  pub STEC: Option<Vec<f64>>,
  pub PRESSURE: Option<Vec<f64>>,
  pub RHUMIDITY: Option<Vec<f64>>,
  pub TEMPERATURE: Option<Vec<f64>>,
  pub CLOCK_BIAS: Option<Vec<f64>>,
  pub CLOCK_DRIFT: Option<Vec<f64>>,
}
impl Default for TDMT {
  fn default() -> Self {
    Self {
      OBSERVER_ID: None,
      OBSERVER_X: 0.0,
      OBSERVER_Y: 0.0,
      OBSERVER_Z: 0.0,
      OBSERVER_VX: 0.0,
      OBSERVER_VY: 0.0,
      OBSERVER_VZ: 0.0,
      OBSERVER_POSITION_REFERENCE_FRAME: OBSERVERLocationReferenceFrame::EME2000,
      OBS_REFERENCE_FRAME: OBSERVERLocationReferenceFrame::EME2000,
      EPOCH: None,
      CCSDS_TDM_VERS: None,
      COMMENT: None,
      CREATION_DATE: None,
      ORIGINATOR: None,
      META_START: None,
      TIME_SYSTEM: None,
      START_TIME: None,
      STOP_TIME: None,
      PARTICIPANT_1: None,
      PARTICIPANT_2: None,
      PARTICIPANT_3: None,
      MODE: None,
      PATH_1: 0,
      PATH_2: 0,
      TRANSMIT_BAND: None,
      RECEIVE_BAND: None,
      INTEGRATION_INTERVAL: 0.0,
      INTEGRATION_REF: None,
      RECEIVE_DELAY_2: 0.0,
      RECEIVE_DELAY_3: 0.0,
      DATA_QUALITY: None,
      META_STOP: None,
      DATA_START: None,
      TRANSMIT_FREQ_1: 0.0,
      RECEIVE_FREQ: None,
      DATA_STOP: None,
      TIMETAG_REF: None,
      ANGLE_TYPE: None,
      ANGLE_1: None,
      ANGLE_2: None,
      ANGLE_UNCERTAINTY_1: 0.0,
      ANGLE_UNCERTAINTY_2: 0.0,
      RANGE_RATE: 0.0,
      RANGE_UNCERTAINTY: 0.0,
      RANGE_MODE: None,
      RANGE_MODULUS: 0.0,
      CORRECTION_ANGLE_1: 0.0,
      CORRECTION_ANGLE_2: 0.0,
      CORRECTIONS_APPLIED: None,
      TROPO_DRY: None,
      TROPO_WET: None,
      STEC: None,
      PRESSURE: None,
      RHUMIDITY: None,
      TEMPERATURE: None,
      CLOCK_BIAS: None,
      CLOCK_DRIFT: None,
    }
  }
}
impl TDMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TDM<'b>> {
    let OBSERVER_ID = self.OBSERVER_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVER_X = self.OBSERVER_X;
    let OBSERVER_Y = self.OBSERVER_Y;
    let OBSERVER_Z = self.OBSERVER_Z;
    let OBSERVER_VX = self.OBSERVER_VX;
    let OBSERVER_VY = self.OBSERVER_VY;
    let OBSERVER_VZ = self.OBSERVER_VZ;
    let OBSERVER_POSITION_REFERENCE_FRAME = self.OBSERVER_POSITION_REFERENCE_FRAME;
    let OBS_REFERENCE_FRAME = self.OBS_REFERENCE_FRAME;
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CCSDS_TDM_VERS = self.CCSDS_TDM_VERS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let META_START = self.META_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_SYSTEM = self.TIME_SYSTEM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STOP_TIME = self.STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARTICIPANT_1 = self.PARTICIPANT_1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARTICIPANT_2 = self.PARTICIPANT_2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARTICIPANT_3 = self.PARTICIPANT_3.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MODE = self.MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PATH_1 = self.PATH_1;
    let PATH_2 = self.PATH_2;
    let TRANSMIT_BAND = self.TRANSMIT_BAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RECEIVE_BAND = self.RECEIVE_BAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTEGRATION_INTERVAL = self.INTEGRATION_INTERVAL;
    let INTEGRATION_REF = self.INTEGRATION_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RECEIVE_DELAY_2 = self.RECEIVE_DELAY_2;
    let RECEIVE_DELAY_3 = self.RECEIVE_DELAY_3;
    let DATA_QUALITY = self.DATA_QUALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let META_STOP = self.META_STOP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_START = self.DATA_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSMIT_FREQ_1 = self.TRANSMIT_FREQ_1;
    let RECEIVE_FREQ = self.RECEIVE_FREQ.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let DATA_STOP = self.DATA_STOP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIMETAG_REF = self.TIMETAG_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ANGLE_TYPE = self.ANGLE_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ANGLE_1 = self.ANGLE_1.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ANGLE_2 = self.ANGLE_2.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ANGLE_UNCERTAINTY_1 = self.ANGLE_UNCERTAINTY_1;
    let ANGLE_UNCERTAINTY_2 = self.ANGLE_UNCERTAINTY_2;
    let RANGE_RATE = self.RANGE_RATE;
    let RANGE_UNCERTAINTY = self.RANGE_UNCERTAINTY;
    let RANGE_MODE = self.RANGE_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RANGE_MODULUS = self.RANGE_MODULUS;
    let CORRECTION_ANGLE_1 = self.CORRECTION_ANGLE_1;
    let CORRECTION_ANGLE_2 = self.CORRECTION_ANGLE_2;
    let CORRECTIONS_APPLIED = self.CORRECTIONS_APPLIED.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TROPO_DRY = self.TROPO_DRY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let TROPO_WET = self.TROPO_WET.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let STEC = self.STEC.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let PRESSURE = self.PRESSURE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let RHUMIDITY = self.RHUMIDITY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let TEMPERATURE = self.TEMPERATURE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CLOCK_BIAS = self.CLOCK_BIAS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CLOCK_DRIFT = self.CLOCK_DRIFT.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    TDM::create(_fbb, &TDMArgs{
      OBSERVER_ID,
      OBSERVER_X,
      OBSERVER_Y,
      OBSERVER_Z,
      OBSERVER_VX,
      OBSERVER_VY,
      OBSERVER_VZ,
      OBSERVER_POSITION_REFERENCE_FRAME,
      OBS_REFERENCE_FRAME,
      EPOCH,
      CCSDS_TDM_VERS,
      COMMENT,
      CREATION_DATE,
      ORIGINATOR,
      META_START,
      TIME_SYSTEM,
      START_TIME,
      STOP_TIME,
      PARTICIPANT_1,
      PARTICIPANT_2,
      PARTICIPANT_3,
      MODE,
      PATH_1,
      PATH_2,
      TRANSMIT_BAND,
      RECEIVE_BAND,
      INTEGRATION_INTERVAL,
      INTEGRATION_REF,
      RECEIVE_DELAY_2,
      RECEIVE_DELAY_3,
      DATA_QUALITY,
      META_STOP,
      DATA_START,
      TRANSMIT_FREQ_1,
      RECEIVE_FREQ,
      DATA_STOP,
      TIMETAG_REF,
      ANGLE_TYPE,
      ANGLE_1,
      ANGLE_2,
      ANGLE_UNCERTAINTY_1,
      ANGLE_UNCERTAINTY_2,
      RANGE_RATE,
      RANGE_UNCERTAINTY,
      RANGE_MODE,
      RANGE_MODULUS,
      CORRECTION_ANGLE_1,
      CORRECTION_ANGLE_2,
      CORRECTIONS_APPLIED,
      TROPO_DRY,
      TROPO_WET,
      STEC,
      PRESSURE,
      RHUMIDITY,
      TEMPERATURE,
      CLOCK_BIAS,
      CLOCK_DRIFT,
    })
  }
}
pub enum TDMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of TDM records
pub struct TDMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TDMCOLLECTION<'a> {
  type Inner = TDMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TDMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TDMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TDMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<TDMCOLLECTION<'bldr>> {
    let mut builder = TDMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TDMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    TDMCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TDM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TDM>>>>(TDMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for TDMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TDM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct TDMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TDM<'a>>>>>,
}
impl<'a> Default for TDMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    TDMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct TDMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TDMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TDM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TDMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TDMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TDMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TDMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TDMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TDMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TDMCOLLECTIONT {
  pub RECORDS: Option<Vec<TDMT>>,
}
impl Default for TDMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl TDMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TDMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    TDMCOLLECTION::create(_fbb, &TDMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TDMCOLLECTION`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TDMCOLLECTION_unchecked`.
pub fn root_as_TDMCOLLECTION(buf: &[u8]) -> Result<TDMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TDMCOLLECTION>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TDMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_TDMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_TDMCOLLECTION(buf: &[u8]) -> Result<TDMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TDMCOLLECTION>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TDMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TDMCOLLECTION_unchecked`.
pub fn root_as_TDMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TDMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TDMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TDMCOLLECTION` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TDMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_TDMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TDMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TDMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TDMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TDMCOLLECTION`.
pub unsafe fn root_as_TDMCOLLECTION_unchecked(buf: &[u8]) -> TDMCOLLECTION {
  flatbuffers::root_unchecked::<TDMCOLLECTION>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TDMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TDMCOLLECTION`.
pub unsafe fn size_prefixed_root_as_TDMCOLLECTION_unchecked(buf: &[u8]) -> TDMCOLLECTION {
  flatbuffers::size_prefixed_root_unchecked::<TDMCOLLECTION>(buf)
}
pub const TDMCOLLECTION_IDENTIFIER: &str = "$TDM";

#[inline]
pub fn TDMCOLLECTION_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TDMCOLLECTION_IDENTIFIER, false)
}

#[inline]
pub fn TDMCOLLECTION_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TDMCOLLECTION_IDENTIFIER, true)
}

#[inline]
pub fn finish_TDMCOLLECTION_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<TDMCOLLECTION<'a>>) {
  fbb.finish(root, Some(TDMCOLLECTION_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_TDMCOLLECTION_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<TDMCOLLECTION<'a>>) {
  fbb.finish_size_prefixed(root, Some(TDMCOLLECTION_IDENTIFIER));
}
