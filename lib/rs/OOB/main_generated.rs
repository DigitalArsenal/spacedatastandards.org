// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OOBOffset {}
#[derive(Copy, Clone, PartialEq)]

/// On-Orbit Battery
pub struct OOB<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OOB<'a> {
  type Inner = OOB<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OOB<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ID_ON_ORBIT: flatbuffers::VOffsetT = 6;
  pub const VT_ID_BATTERY: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_CHEMISTRY: flatbuffers::VOffsetT = 12;
  pub const VT_QUANTITY: flatbuffers::VOffsetT = 14;
  pub const VT_VOLTAGE: flatbuffers::VOffsetT = 16;
  pub const VT_CAPACITY_AH: flatbuffers::VOffsetT = 18;
  pub const VT_ENERGY_WH: flatbuffers::VOffsetT = 20;
  pub const VT_MAX_DOD: flatbuffers::VOffsetT = 22;
  pub const VT_CYCLE_LIFE: flatbuffers::VOffsetT = 24;
  pub const VT_MASS: flatbuffers::VOffsetT = 26;
  pub const VT_STATE_OF_HEALTH: flatbuffers::VOffsetT = 28;
  pub const VT_NOTES: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OOB { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OOBArgs<'args>
  ) -> flatbuffers::WIPOffset<OOB<'bldr>> {
    let mut builder = OOBBuilder::new(_fbb);
    builder.add_STATE_OF_HEALTH(args.STATE_OF_HEALTH);
    builder.add_MASS(args.MASS);
    builder.add_MAX_DOD(args.MAX_DOD);
    builder.add_ENERGY_WH(args.ENERGY_WH);
    builder.add_CAPACITY_AH(args.CAPACITY_AH);
    builder.add_VOLTAGE(args.VOLTAGE);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    builder.add_CYCLE_LIFE(args.CYCLE_LIFE);
    builder.add_QUANTITY(args.QUANTITY);
    if let Some(x) = args.CHEMISTRY { builder.add_CHEMISTRY(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID_BATTERY { builder.add_ID_BATTERY(x); }
    if let Some(x) = args.ID_ON_ORBIT { builder.add_ID_ON_ORBIT(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OOBT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT().map(|x| {
      x.to_string()
    });
    let ID_BATTERY = self.ID_BATTERY().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CHEMISTRY = self.CHEMISTRY().map(|x| {
      x.to_string()
    });
    let QUANTITY = self.QUANTITY();
    let VOLTAGE = self.VOLTAGE();
    let CAPACITY_AH = self.CAPACITY_AH();
    let ENERGY_WH = self.ENERGY_WH();
    let MAX_DOD = self.MAX_DOD();
    let CYCLE_LIFE = self.CYCLE_LIFE();
    let MASS = self.MASS();
    let STATE_OF_HEALTH = self.STATE_OF_HEALTH();
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    OOBT {
      ID,
      ID_ON_ORBIT,
      ID_BATTERY,
      NAME,
      CHEMISTRY,
      QUANTITY,
      VOLTAGE,
      CAPACITY_AH,
      ENERGY_WH,
      MAX_DOD,
      CYCLE_LIFE,
      MASS,
      STATE_OF_HEALTH,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_ID, None)}
  }
  /// Reference to parent on-orbit object
  #[inline]
  pub fn ID_ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_ID_ON_ORBIT, None)}
  }
  /// Reference to battery specification
  #[inline]
  pub fn ID_BATTERY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_ID_BATTERY, None)}
  }
  /// Battery name or designation
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_NAME, None)}
  }
  /// Battery chemistry (e.g., LI_ION, NICD, NIMH, LIPO, SILVER_ZINC)
  #[inline]
  pub fn CHEMISTRY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_CHEMISTRY, None)}
  }
  /// Number of batteries of this type
  #[inline]
  pub fn QUANTITY(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OOB::VT_QUANTITY, Some(0)).unwrap()}
  }
  /// Nominal voltage in Volts
  #[inline]
  pub fn VOLTAGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_VOLTAGE, Some(0.0)).unwrap()}
  }
  /// Capacity in Amp-hours
  #[inline]
  pub fn CAPACITY_AH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_CAPACITY_AH, Some(0.0)).unwrap()}
  }
  /// Energy capacity in Watt-hours
  #[inline]
  pub fn ENERGY_WH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_ENERGY_WH, Some(0.0)).unwrap()}
  }
  /// Maximum depth of discharge as fraction (0.0-1.0)
  #[inline]
  pub fn MAX_DOD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_MAX_DOD, Some(0.0)).unwrap()}
  }
  /// Number of charge/discharge cycles rated
  #[inline]
  pub fn CYCLE_LIFE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OOB::VT_CYCLE_LIFE, Some(0)).unwrap()}
  }
  /// Battery mass in kg
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_MASS, Some(0.0)).unwrap()}
  }
  /// Current state of health as fraction (0.0-1.0)
  #[inline]
  pub fn STATE_OF_HEALTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOB::VT_STATE_OF_HEALTH, Some(0.0)).unwrap()}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOB::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for OOB<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_ON_ORBIT", Self::VT_ID_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_BATTERY", Self::VT_ID_BATTERY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CHEMISTRY", Self::VT_CHEMISTRY, false)?
     .visit_field::<u32>("QUANTITY", Self::VT_QUANTITY, false)?
     .visit_field::<f64>("VOLTAGE", Self::VT_VOLTAGE, false)?
     .visit_field::<f64>("CAPACITY_AH", Self::VT_CAPACITY_AH, false)?
     .visit_field::<f64>("ENERGY_WH", Self::VT_ENERGY_WH, false)?
     .visit_field::<f64>("MAX_DOD", Self::VT_MAX_DOD, false)?
     .visit_field::<u32>("CYCLE_LIFE", Self::VT_CYCLE_LIFE, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<f64>("STATE_OF_HEALTH", Self::VT_STATE_OF_HEALTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct OOBArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_BATTERY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CHEMISTRY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub QUANTITY: u32,
    pub VOLTAGE: f64,
    pub CAPACITY_AH: f64,
    pub ENERGY_WH: f64,
    pub MAX_DOD: f64,
    pub CYCLE_LIFE: u32,
    pub MASS: f64,
    pub STATE_OF_HEALTH: f64,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OOBArgs<'a> {
  #[inline]
  fn default() -> Self {
    OOBArgs {
      ID: None,
      ID_ON_ORBIT: None,
      ID_BATTERY: None,
      NAME: None,
      CHEMISTRY: None,
      QUANTITY: 0,
      VOLTAGE: 0.0,
      CAPACITY_AH: 0.0,
      ENERGY_WH: 0.0,
      MAX_DOD: 0.0,
      CYCLE_LIFE: 0,
      MASS: 0.0,
      STATE_OF_HEALTH: 0.0,
      NOTES: None,
    }
  }
}

pub struct OOBBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OOBBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_ID, ID);
  }
  #[inline]
  pub fn add_ID_ON_ORBIT(&mut self, ID_ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  #[inline]
  pub fn add_ID_BATTERY(&mut self, ID_BATTERY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_ID_BATTERY, ID_BATTERY);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CHEMISTRY(&mut self, CHEMISTRY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_CHEMISTRY, CHEMISTRY);
  }
  #[inline]
  pub fn add_QUANTITY(&mut self, QUANTITY: u32) {
    self.fbb_.push_slot::<u32>(OOB::VT_QUANTITY, QUANTITY, 0);
  }
  #[inline]
  pub fn add_VOLTAGE(&mut self, VOLTAGE: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_VOLTAGE, VOLTAGE, 0.0);
  }
  #[inline]
  pub fn add_CAPACITY_AH(&mut self, CAPACITY_AH: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_CAPACITY_AH, CAPACITY_AH, 0.0);
  }
  #[inline]
  pub fn add_ENERGY_WH(&mut self, ENERGY_WH: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_ENERGY_WH, ENERGY_WH, 0.0);
  }
  #[inline]
  pub fn add_MAX_DOD(&mut self, MAX_DOD: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_MAX_DOD, MAX_DOD, 0.0);
  }
  #[inline]
  pub fn add_CYCLE_LIFE(&mut self, CYCLE_LIFE: u32) {
    self.fbb_.push_slot::<u32>(OOB::VT_CYCLE_LIFE, CYCLE_LIFE, 0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_STATE_OF_HEALTH(&mut self, STATE_OF_HEALTH: f64) {
    self.fbb_.push_slot::<f64>(OOB::VT_STATE_OF_HEALTH, STATE_OF_HEALTH, 0.0);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOB::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OOBBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OOBBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OOB<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OOB<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OOB");
      ds.field("ID", &self.ID());
      ds.field("ID_ON_ORBIT", &self.ID_ON_ORBIT());
      ds.field("ID_BATTERY", &self.ID_BATTERY());
      ds.field("NAME", &self.NAME());
      ds.field("CHEMISTRY", &self.CHEMISTRY());
      ds.field("QUANTITY", &self.QUANTITY());
      ds.field("VOLTAGE", &self.VOLTAGE());
      ds.field("CAPACITY_AH", &self.CAPACITY_AH());
      ds.field("ENERGY_WH", &self.ENERGY_WH());
      ds.field("MAX_DOD", &self.MAX_DOD());
      ds.field("CYCLE_LIFE", &self.CYCLE_LIFE());
      ds.field("MASS", &self.MASS());
      ds.field("STATE_OF_HEALTH", &self.STATE_OF_HEALTH());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OOBT {
  pub ID: Option<String>,
  pub ID_ON_ORBIT: Option<String>,
  pub ID_BATTERY: Option<String>,
  pub NAME: Option<String>,
  pub CHEMISTRY: Option<String>,
  pub QUANTITY: u32,
  pub VOLTAGE: f64,
  pub CAPACITY_AH: f64,
  pub ENERGY_WH: f64,
  pub MAX_DOD: f64,
  pub CYCLE_LIFE: u32,
  pub MASS: f64,
  pub STATE_OF_HEALTH: f64,
  pub NOTES: Option<String>,
}
impl Default for OOBT {
  fn default() -> Self {
    Self {
      ID: None,
      ID_ON_ORBIT: None,
      ID_BATTERY: None,
      NAME: None,
      CHEMISTRY: None,
      QUANTITY: 0,
      VOLTAGE: 0.0,
      CAPACITY_AH: 0.0,
      ENERGY_WH: 0.0,
      MAX_DOD: 0.0,
      CYCLE_LIFE: 0,
      MASS: 0.0,
      STATE_OF_HEALTH: 0.0,
      NOTES: None,
    }
  }
}
impl OOBT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OOB<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_BATTERY = self.ID_BATTERY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CHEMISTRY = self.CHEMISTRY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let QUANTITY = self.QUANTITY;
    let VOLTAGE = self.VOLTAGE;
    let CAPACITY_AH = self.CAPACITY_AH;
    let ENERGY_WH = self.ENERGY_WH;
    let MAX_DOD = self.MAX_DOD;
    let CYCLE_LIFE = self.CYCLE_LIFE;
    let MASS = self.MASS;
    let STATE_OF_HEALTH = self.STATE_OF_HEALTH;
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OOB::create(_fbb, &OOBArgs{
      ID,
      ID_ON_ORBIT,
      ID_BATTERY,
      NAME,
      CHEMISTRY,
      QUANTITY,
      VOLTAGE,
      CAPACITY_AH,
      ENERGY_WH,
      MAX_DOD,
      CYCLE_LIFE,
      MASS,
      STATE_OF_HEALTH,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OOB`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOB_unchecked`.
pub fn root_as_OOB(buf: &[u8]) -> Result<OOB, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OOB>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OOB` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OOB_unchecked`.
pub fn size_prefixed_root_as_OOB(buf: &[u8]) -> Result<OOB, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OOB>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OOB` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOB_unchecked`.
pub fn root_as_OOB_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOB<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OOB<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OOB` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOB_unchecked`.
pub fn size_prefixed_root_as_OOB_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOB<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OOB<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OOB and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OOB`.
pub unsafe fn root_as_OOB_unchecked(buf: &[u8]) -> OOB {
  flatbuffers::root_unchecked::<OOB>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OOB and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OOB`.
pub unsafe fn size_prefixed_root_as_OOB_unchecked(buf: &[u8]) -> OOB {
  flatbuffers::size_prefixed_root_unchecked::<OOB>(buf)
}
pub const OOB_IDENTIFIER: &str = "$OOB";

#[inline]
pub fn OOB_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOB_IDENTIFIER, false)
}

#[inline]
pub fn OOB_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOB_IDENTIFIER, true)
}

#[inline]
pub fn finish_OOB_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OOB<'a>>) {
  fbb.finish(root, Some(OOB_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OOB_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OOB<'a>>) {
  fbb.finish_size_prefixed(root, Some(OOB_IDENTIFIER));
}
