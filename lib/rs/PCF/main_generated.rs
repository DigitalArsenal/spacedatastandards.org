// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTEGRATOR_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTEGRATOR_TYPE: u8 = 255;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTEGRATOR_TYPE: [IntegratorType; 8] = [
  IntegratorType::RK4,
  IntegratorType::RK45,
  IntegratorType::RK78,
  IntegratorType::DOPRI5,
  IntegratorType::DOPRI853,
  IntegratorType::ABM,
  IntegratorType::BS,
  IntegratorType::ANALYTICAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IntegratorType(pub u8);
#[allow(non_upper_case_globals)]
impl IntegratorType {
  pub const RK4: Self = Self(0);
  pub const RK45: Self = Self(1);
  pub const RK78: Self = Self(2);
  pub const DOPRI5: Self = Self(3);
  pub const DOPRI853: Self = Self(4);
  pub const ABM: Self = Self(5);
  pub const BS: Self = Self(6);
  pub const ANALYTICAL: Self = Self(255);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 255;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RK4,
    Self::RK45,
    Self::RK78,
    Self::DOPRI5,
    Self::DOPRI853,
    Self::ABM,
    Self::BS,
    Self::ANALYTICAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RK4 => Some("RK4"),
      Self::RK45 => Some("RK45"),
      Self::RK78 => Some("RK78"),
      Self::DOPRI5 => Some("DOPRI5"),
      Self::DOPRI853 => Some("DOPRI853"),
      Self::ABM => Some("ABM"),
      Self::BS => Some("BS"),
      Self::ANALYTICAL => Some("ANALYTICAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IntegratorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IntegratorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IntegratorType {
    type Output = IntegratorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IntegratorType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IntegratorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IntegratorType {}
pub enum PCFOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Propagator Configuration
pub struct PCF<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PCF<'a> {
  type Inner = PCF<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PCF<'a> {
  pub const VT_STEP_SIZE: flatbuffers::VOffsetT = 4;
  pub const VT_TOLERANCE: flatbuffers::VOffsetT = 6;
  pub const VT_MIN_STEP: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_STEP: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_ITERATIONS: flatbuffers::VOffsetT = 12;
  pub const VT_GRAVITY_DEGREE: flatbuffers::VOffsetT = 14;
  pub const VT_GRAVITY_ORDER: flatbuffers::VOffsetT = 16;
  pub const VT_INTEGRATOR: flatbuffers::VOffsetT = 18;
  pub const VT_OUTPUT_FRAME: flatbuffers::VOffsetT = 20;
  pub const VT_FORCE_FLAGS: flatbuffers::VOffsetT = 22;
  pub const VT_DRAG_COEFFICIENT: flatbuffers::VOffsetT = 24;
  pub const VT_SRP_COEFFICIENT: flatbuffers::VOffsetT = 26;
  pub const VT_AREA_MASS_RATIO: flatbuffers::VOffsetT = 28;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PCF { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PCFArgs<'args>
  ) -> flatbuffers::WIPOffset<PCF<'bldr>> {
    let mut builder = PCFBuilder::new(_fbb);
    builder.add_MAX_STEP(args.MAX_STEP);
    builder.add_MIN_STEP(args.MIN_STEP);
    builder.add_TOLERANCE(args.TOLERANCE);
    builder.add_STEP_SIZE(args.STEP_SIZE);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_AREA_MASS_RATIO(args.AREA_MASS_RATIO);
    builder.add_SRP_COEFFICIENT(args.SRP_COEFFICIENT);
    builder.add_DRAG_COEFFICIENT(args.DRAG_COEFFICIENT);
    builder.add_MAX_ITERATIONS(args.MAX_ITERATIONS);
    builder.add_FORCE_FLAGS(args.FORCE_FLAGS);
    builder.add_GRAVITY_ORDER(args.GRAVITY_ORDER);
    builder.add_GRAVITY_DEGREE(args.GRAVITY_DEGREE);
    builder.add_OUTPUT_FRAME(args.OUTPUT_FRAME);
    builder.add_INTEGRATOR(args.INTEGRATOR);
    builder.finish()
  }

  pub fn unpack(&self) -> PCFT {
    let STEP_SIZE = self.STEP_SIZE();
    let TOLERANCE = self.TOLERANCE();
    let MIN_STEP = self.MIN_STEP();
    let MAX_STEP = self.MAX_STEP();
    let MAX_ITERATIONS = self.MAX_ITERATIONS();
    let GRAVITY_DEGREE = self.GRAVITY_DEGREE();
    let GRAVITY_ORDER = self.GRAVITY_ORDER();
    let INTEGRATOR = self.INTEGRATOR();
    let OUTPUT_FRAME = self.OUTPUT_FRAME();
    let FORCE_FLAGS = self.FORCE_FLAGS();
    let DRAG_COEFFICIENT = self.DRAG_COEFFICIENT();
    let SRP_COEFFICIENT = self.SRP_COEFFICIENT();
    let AREA_MASS_RATIO = self.AREA_MASS_RATIO();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    PCFT {
      STEP_SIZE,
      TOLERANCE,
      MIN_STEP,
      MAX_STEP,
      MAX_ITERATIONS,
      GRAVITY_DEGREE,
      GRAVITY_ORDER,
      INTEGRATOR,
      OUTPUT_FRAME,
      FORCE_FLAGS,
      DRAG_COEFFICIENT,
      SRP_COEFFICIENT,
      AREA_MASS_RATIO,
      RESERVED,
    }
  }

  #[inline]
  pub fn STEP_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PCF::VT_STEP_SIZE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TOLERANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PCF::VT_TOLERANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MIN_STEP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PCF::VT_MIN_STEP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAX_STEP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PCF::VT_MAX_STEP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAX_ITERATIONS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PCF::VT_MAX_ITERATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GRAVITY_DEGREE(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PCF::VT_GRAVITY_DEGREE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GRAVITY_ORDER(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PCF::VT_GRAVITY_ORDER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn INTEGRATOR(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PCF::VT_INTEGRATOR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn OUTPUT_FRAME(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PCF::VT_OUTPUT_FRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FORCE_FLAGS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PCF::VT_FORCE_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DRAG_COEFFICIENT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PCF::VT_DRAG_COEFFICIENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SRP_COEFFICIENT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PCF::VT_SRP_COEFFICIENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AREA_MASS_RATIO(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PCF::VT_AREA_MASS_RATIO, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PCF::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for PCF<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("STEP_SIZE", Self::VT_STEP_SIZE, false)?
     .visit_field::<f64>("TOLERANCE", Self::VT_TOLERANCE, false)?
     .visit_field::<f64>("MIN_STEP", Self::VT_MIN_STEP, false)?
     .visit_field::<f64>("MAX_STEP", Self::VT_MAX_STEP, false)?
     .visit_field::<u32>("MAX_ITERATIONS", Self::VT_MAX_ITERATIONS, false)?
     .visit_field::<u16>("GRAVITY_DEGREE", Self::VT_GRAVITY_DEGREE, false)?
     .visit_field::<u16>("GRAVITY_ORDER", Self::VT_GRAVITY_ORDER, false)?
     .visit_field::<u8>("INTEGRATOR", Self::VT_INTEGRATOR, false)?
     .visit_field::<u8>("OUTPUT_FRAME", Self::VT_OUTPUT_FRAME, false)?
     .visit_field::<u16>("FORCE_FLAGS", Self::VT_FORCE_FLAGS, false)?
     .visit_field::<f32>("DRAG_COEFFICIENT", Self::VT_DRAG_COEFFICIENT, false)?
     .visit_field::<f32>("SRP_COEFFICIENT", Self::VT_SRP_COEFFICIENT, false)?
     .visit_field::<f32>("AREA_MASS_RATIO", Self::VT_AREA_MASS_RATIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct PCFArgs<'a> {
    pub STEP_SIZE: f64,
    pub TOLERANCE: f64,
    pub MIN_STEP: f64,
    pub MAX_STEP: f64,
    pub MAX_ITERATIONS: u32,
    pub GRAVITY_DEGREE: u16,
    pub GRAVITY_ORDER: u16,
    pub INTEGRATOR: u8,
    pub OUTPUT_FRAME: u8,
    pub FORCE_FLAGS: u16,
    pub DRAG_COEFFICIENT: f32,
    pub SRP_COEFFICIENT: f32,
    pub AREA_MASS_RATIO: f32,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for PCFArgs<'a> {
  #[inline]
  fn default() -> Self {
    PCFArgs {
      STEP_SIZE: 0.0,
      TOLERANCE: 0.0,
      MIN_STEP: 0.0,
      MAX_STEP: 0.0,
      MAX_ITERATIONS: 0,
      GRAVITY_DEGREE: 0,
      GRAVITY_ORDER: 0,
      INTEGRATOR: 0,
      OUTPUT_FRAME: 0,
      FORCE_FLAGS: 0,
      DRAG_COEFFICIENT: 0.0,
      SRP_COEFFICIENT: 0.0,
      AREA_MASS_RATIO: 0.0,
      RESERVED: None,
    }
  }
}

pub struct PCFBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PCFBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_STEP_SIZE(&mut self, STEP_SIZE: f64) {
    self.fbb_.push_slot::<f64>(PCF::VT_STEP_SIZE, STEP_SIZE, 0.0);
  }
  #[inline]
  pub fn add_TOLERANCE(&mut self, TOLERANCE: f64) {
    self.fbb_.push_slot::<f64>(PCF::VT_TOLERANCE, TOLERANCE, 0.0);
  }
  #[inline]
  pub fn add_MIN_STEP(&mut self, MIN_STEP: f64) {
    self.fbb_.push_slot::<f64>(PCF::VT_MIN_STEP, MIN_STEP, 0.0);
  }
  #[inline]
  pub fn add_MAX_STEP(&mut self, MAX_STEP: f64) {
    self.fbb_.push_slot::<f64>(PCF::VT_MAX_STEP, MAX_STEP, 0.0);
  }
  #[inline]
  pub fn add_MAX_ITERATIONS(&mut self, MAX_ITERATIONS: u32) {
    self.fbb_.push_slot::<u32>(PCF::VT_MAX_ITERATIONS, MAX_ITERATIONS, 0);
  }
  #[inline]
  pub fn add_GRAVITY_DEGREE(&mut self, GRAVITY_DEGREE: u16) {
    self.fbb_.push_slot::<u16>(PCF::VT_GRAVITY_DEGREE, GRAVITY_DEGREE, 0);
  }
  #[inline]
  pub fn add_GRAVITY_ORDER(&mut self, GRAVITY_ORDER: u16) {
    self.fbb_.push_slot::<u16>(PCF::VT_GRAVITY_ORDER, GRAVITY_ORDER, 0);
  }
  #[inline]
  pub fn add_INTEGRATOR(&mut self, INTEGRATOR: u8) {
    self.fbb_.push_slot::<u8>(PCF::VT_INTEGRATOR, INTEGRATOR, 0);
  }
  #[inline]
  pub fn add_OUTPUT_FRAME(&mut self, OUTPUT_FRAME: u8) {
    self.fbb_.push_slot::<u8>(PCF::VT_OUTPUT_FRAME, OUTPUT_FRAME, 0);
  }
  #[inline]
  pub fn add_FORCE_FLAGS(&mut self, FORCE_FLAGS: u16) {
    self.fbb_.push_slot::<u16>(PCF::VT_FORCE_FLAGS, FORCE_FLAGS, 0);
  }
  #[inline]
  pub fn add_DRAG_COEFFICIENT(&mut self, DRAG_COEFFICIENT: f32) {
    self.fbb_.push_slot::<f32>(PCF::VT_DRAG_COEFFICIENT, DRAG_COEFFICIENT, 0.0);
  }
  #[inline]
  pub fn add_SRP_COEFFICIENT(&mut self, SRP_COEFFICIENT: f32) {
    self.fbb_.push_slot::<f32>(PCF::VT_SRP_COEFFICIENT, SRP_COEFFICIENT, 0.0);
  }
  #[inline]
  pub fn add_AREA_MASS_RATIO(&mut self, AREA_MASS_RATIO: f32) {
    self.fbb_.push_slot::<f32>(PCF::VT_AREA_MASS_RATIO, AREA_MASS_RATIO, 0.0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PCF::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PCFBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PCFBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PCF<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PCF<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PCF");
      ds.field("STEP_SIZE", &self.STEP_SIZE());
      ds.field("TOLERANCE", &self.TOLERANCE());
      ds.field("MIN_STEP", &self.MIN_STEP());
      ds.field("MAX_STEP", &self.MAX_STEP());
      ds.field("MAX_ITERATIONS", &self.MAX_ITERATIONS());
      ds.field("GRAVITY_DEGREE", &self.GRAVITY_DEGREE());
      ds.field("GRAVITY_ORDER", &self.GRAVITY_ORDER());
      ds.field("INTEGRATOR", &self.INTEGRATOR());
      ds.field("OUTPUT_FRAME", &self.OUTPUT_FRAME());
      ds.field("FORCE_FLAGS", &self.FORCE_FLAGS());
      ds.field("DRAG_COEFFICIENT", &self.DRAG_COEFFICIENT());
      ds.field("SRP_COEFFICIENT", &self.SRP_COEFFICIENT());
      ds.field("AREA_MASS_RATIO", &self.AREA_MASS_RATIO());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PCFT {
  pub STEP_SIZE: f64,
  pub TOLERANCE: f64,
  pub MIN_STEP: f64,
  pub MAX_STEP: f64,
  pub MAX_ITERATIONS: u32,
  pub GRAVITY_DEGREE: u16,
  pub GRAVITY_ORDER: u16,
  pub INTEGRATOR: u8,
  pub OUTPUT_FRAME: u8,
  pub FORCE_FLAGS: u16,
  pub DRAG_COEFFICIENT: f32,
  pub SRP_COEFFICIENT: f32,
  pub AREA_MASS_RATIO: f32,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for PCFT {
  fn default() -> Self {
    Self {
      STEP_SIZE: 0.0,
      TOLERANCE: 0.0,
      MIN_STEP: 0.0,
      MAX_STEP: 0.0,
      MAX_ITERATIONS: 0,
      GRAVITY_DEGREE: 0,
      GRAVITY_ORDER: 0,
      INTEGRATOR: 0,
      OUTPUT_FRAME: 0,
      FORCE_FLAGS: 0,
      DRAG_COEFFICIENT: 0.0,
      SRP_COEFFICIENT: 0.0,
      AREA_MASS_RATIO: 0.0,
      RESERVED: None,
    }
  }
}
impl PCFT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PCF<'b>> {
    let STEP_SIZE = self.STEP_SIZE;
    let TOLERANCE = self.TOLERANCE;
    let MIN_STEP = self.MIN_STEP;
    let MAX_STEP = self.MAX_STEP;
    let MAX_ITERATIONS = self.MAX_ITERATIONS;
    let GRAVITY_DEGREE = self.GRAVITY_DEGREE;
    let GRAVITY_ORDER = self.GRAVITY_ORDER;
    let INTEGRATOR = self.INTEGRATOR;
    let OUTPUT_FRAME = self.OUTPUT_FRAME;
    let FORCE_FLAGS = self.FORCE_FLAGS;
    let DRAG_COEFFICIENT = self.DRAG_COEFFICIENT;
    let SRP_COEFFICIENT = self.SRP_COEFFICIENT;
    let AREA_MASS_RATIO = self.AREA_MASS_RATIO;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    PCF::create(_fbb, &PCFArgs{
      STEP_SIZE,
      TOLERANCE,
      MIN_STEP,
      MAX_STEP,
      MAX_ITERATIONS,
      GRAVITY_DEGREE,
      GRAVITY_ORDER,
      INTEGRATOR,
      OUTPUT_FRAME,
      FORCE_FLAGS,
      DRAG_COEFFICIENT,
      SRP_COEFFICIENT,
      AREA_MASS_RATIO,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PCF`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PCF_unchecked`.
pub fn root_as_PCF(buf: &[u8]) -> Result<PCF, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PCF>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PCF` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_PCF_unchecked`.
pub fn size_prefixed_root_as_PCF(buf: &[u8]) -> Result<PCF, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PCF>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PCF` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PCF_unchecked`.
pub fn root_as_PCF_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PCF<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PCF<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PCF` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PCF_unchecked`.
pub fn size_prefixed_root_as_PCF_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PCF<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PCF<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PCF and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PCF`.
pub unsafe fn root_as_PCF_unchecked(buf: &[u8]) -> PCF {
  flatbuffers::root_unchecked::<PCF>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PCF and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PCF`.
pub unsafe fn size_prefixed_root_as_PCF_unchecked(buf: &[u8]) -> PCF {
  flatbuffers::size_prefixed_root_unchecked::<PCF>(buf)
}
pub const PCF_IDENTIFIER: &str = "$PCF";

#[inline]
pub fn PCF_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PCF_IDENTIFIER, false)
}

#[inline]
pub fn PCF_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PCF_IDENTIFIER, true)
}

#[inline]
pub fn finish_PCF_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PCF<'a>>) {
  fbb.finish(root, Some(PCF_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_PCF_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<PCF<'a>>) {
  fbb.finish_size_prefixed(root, Some(PCF_IDENTIFIER));
}
