// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum EOOOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Electro-Optical Observation
pub struct EOO<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EOO<'a> {
  type Inner = EOO<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EOO<'a> {
  pub const VT_EOBSERVATION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATION: flatbuffers::VOffsetT = 6;
  pub const VT_OB_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_CORR_QUALITY: flatbuffers::VOffsetT = 10;
  pub const VT_ID_ON_ORBIT: flatbuffers::VOffsetT = 12;
  pub const VT_SENSOR_ID: flatbuffers::VOffsetT = 14;
  pub const VT_COLLECT_METHOD: flatbuffers::VOffsetT = 16;
  pub const VT_NORAD_CAT_ID: flatbuffers::VOffsetT = 18;
  pub const VT_TASK_ID: flatbuffers::VOffsetT = 20;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 22;
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 24;
  pub const VT_OB_POSITION: flatbuffers::VOffsetT = 26;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 28;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 30;
  pub const VT_UCT: flatbuffers::VOffsetT = 32;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 34;
  pub const VT_AZIMUTH_UNC: flatbuffers::VOffsetT = 36;
  pub const VT_AZIMUTH_BIAS: flatbuffers::VOffsetT = 38;
  pub const VT_AZIMUTH_RATE: flatbuffers::VOffsetT = 40;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 42;
  pub const VT_ELEVATION_UNC: flatbuffers::VOffsetT = 44;
  pub const VT_ELEVATION_BIAS: flatbuffers::VOffsetT = 46;
  pub const VT_ELEVATION_RATE: flatbuffers::VOffsetT = 48;
  pub const VT_RANGE: flatbuffers::VOffsetT = 50;
  pub const VT_RANGE_UNC: flatbuffers::VOffsetT = 52;
  pub const VT_RANGE_BIAS: flatbuffers::VOffsetT = 54;
  pub const VT_RANGE_RATE: flatbuffers::VOffsetT = 56;
  pub const VT_RANGE_RATE_UNC: flatbuffers::VOffsetT = 58;
  pub const VT_RA: flatbuffers::VOffsetT = 60;
  pub const VT_RA_RATE: flatbuffers::VOffsetT = 62;
  pub const VT_RA_UNC: flatbuffers::VOffsetT = 64;
  pub const VT_RA_BIAS: flatbuffers::VOffsetT = 66;
  pub const VT_DECLINATION: flatbuffers::VOffsetT = 68;
  pub const VT_DECLINATION_RATE: flatbuffers::VOffsetT = 70;
  pub const VT_DECLINATION_UNC: flatbuffers::VOffsetT = 72;
  pub const VT_DECLINATION_BIAS: flatbuffers::VOffsetT = 74;
  pub const VT_LOSX: flatbuffers::VOffsetT = 76;
  pub const VT_LOSY: flatbuffers::VOffsetT = 78;
  pub const VT_LOSZ: flatbuffers::VOffsetT = 80;
  pub const VT_LOS_UNC: flatbuffers::VOffsetT = 82;
  pub const VT_LOSXVEL: flatbuffers::VOffsetT = 84;
  pub const VT_LOSYVEL: flatbuffers::VOffsetT = 86;
  pub const VT_LOSZVEL: flatbuffers::VOffsetT = 88;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 90;
  pub const VT_SENLON: flatbuffers::VOffsetT = 92;
  pub const VT_SENALT: flatbuffers::VOffsetT = 94;
  pub const VT_SENX: flatbuffers::VOffsetT = 96;
  pub const VT_SENY: flatbuffers::VOffsetT = 98;
  pub const VT_SENZ: flatbuffers::VOffsetT = 100;
  pub const VT_FOV_COUNT: flatbuffers::VOffsetT = 102;
  pub const VT_EXP_DURATION: flatbuffers::VOffsetT = 104;
  pub const VT_ZEROPTD: flatbuffers::VOffsetT = 106;
  pub const VT_NET_OBJ_SIG: flatbuffers::VOffsetT = 108;
  pub const VT_NET_OBJ_SIG_UNC: flatbuffers::VOffsetT = 110;
  pub const VT_MAG: flatbuffers::VOffsetT = 112;
  pub const VT_MAG_UNC: flatbuffers::VOffsetT = 114;
  pub const VT_MAG_NORM_RANGE: flatbuffers::VOffsetT = 116;
  pub const VT_GEOLAT: flatbuffers::VOffsetT = 118;
  pub const VT_GEOLON: flatbuffers::VOffsetT = 120;
  pub const VT_GEOALT: flatbuffers::VOffsetT = 122;
  pub const VT_GEORANGE: flatbuffers::VOffsetT = 124;
  pub const VT_SKY_BKGRND: flatbuffers::VOffsetT = 126;
  pub const VT_PRIMARY_EXTINCTION: flatbuffers::VOffsetT = 128;
  pub const VT_PRIMARY_EXTINCTION_UNC: flatbuffers::VOffsetT = 130;
  pub const VT_SOLAR_PHASE_ANGLE: flatbuffers::VOffsetT = 132;
  pub const VT_SOLAR_EQ_PHASE_ANGLE: flatbuffers::VOffsetT = 134;
  pub const VT_SOLAR_DEC_ANGLE: flatbuffers::VOffsetT = 136;
  pub const VT_SHUTTER_DELAY: flatbuffers::VOffsetT = 138;
  pub const VT_TIMING_BIAS: flatbuffers::VOffsetT = 140;
  pub const VT_RAW_FILE_URI: flatbuffers::VOffsetT = 142;
  pub const VT_INTENSITY: flatbuffers::VOffsetT = 144;
  pub const VT_BG_INTENSITY: flatbuffers::VOffsetT = 146;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 148;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 150;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 152;
  pub const VT_DATA_MODE: flatbuffers::VOffsetT = 154;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 156;
  pub const VT_CREATED_BY: flatbuffers::VOffsetT = 158;
  pub const VT_REFERENCE_FRAME: flatbuffers::VOffsetT = 160;
  pub const VT_SEN_REFERENCE_FRAME: flatbuffers::VOffsetT = 162;
  pub const VT_UMBRA: flatbuffers::VOffsetT = 164;
  pub const VT_PENUMBRA: flatbuffers::VOffsetT = 166;
  pub const VT_ORIG_NETWORK: flatbuffers::VOffsetT = 168;
  pub const VT_SOURCE_DL: flatbuffers::VOffsetT = 170;
  pub const VT_TYPE: flatbuffers::VOffsetT = 172;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EOO { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EOOArgs<'args>
  ) -> flatbuffers::WIPOffset<EOO<'bldr>> {
    let mut builder = EOOBuilder::new(_fbb);
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.SOURCE_DL { builder.add_SOURCE_DL(x); }
    if let Some(x) = args.ORIG_NETWORK { builder.add_ORIG_NETWORK(x); }
    if let Some(x) = args.SEN_REFERENCE_FRAME { builder.add_SEN_REFERENCE_FRAME(x); }
    if let Some(x) = args.CREATED_BY { builder.add_CREATED_BY(x); }
    if let Some(x) = args.CREATED_AT { builder.add_CREATED_AT(x); }
    if let Some(x) = args.DATA_MODE { builder.add_DATA_MODE(x); }
    if let Some(x) = args.ORIGIN { builder.add_ORIGIN(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    builder.add_BG_INTENSITY(args.BG_INTENSITY);
    builder.add_INTENSITY(args.INTENSITY);
    if let Some(x) = args.RAW_FILE_URI { builder.add_RAW_FILE_URI(x); }
    builder.add_TIMING_BIAS(args.TIMING_BIAS);
    builder.add_SHUTTER_DELAY(args.SHUTTER_DELAY);
    builder.add_SOLAR_DEC_ANGLE(args.SOLAR_DEC_ANGLE);
    builder.add_SOLAR_EQ_PHASE_ANGLE(args.SOLAR_EQ_PHASE_ANGLE);
    builder.add_SOLAR_PHASE_ANGLE(args.SOLAR_PHASE_ANGLE);
    builder.add_PRIMARY_EXTINCTION_UNC(args.PRIMARY_EXTINCTION_UNC);
    builder.add_PRIMARY_EXTINCTION(args.PRIMARY_EXTINCTION);
    builder.add_SKY_BKGRND(args.SKY_BKGRND);
    builder.add_GEORANGE(args.GEORANGE);
    builder.add_GEOALT(args.GEOALT);
    builder.add_GEOLON(args.GEOLON);
    builder.add_GEOLAT(args.GEOLAT);
    builder.add_MAG_NORM_RANGE(args.MAG_NORM_RANGE);
    builder.add_MAG_UNC(args.MAG_UNC);
    builder.add_MAG(args.MAG);
    builder.add_NET_OBJ_SIG_UNC(args.NET_OBJ_SIG_UNC);
    builder.add_NET_OBJ_SIG(args.NET_OBJ_SIG);
    builder.add_ZEROPTD(args.ZEROPTD);
    builder.add_EXP_DURATION(args.EXP_DURATION);
    builder.add_FOV_COUNT(args.FOV_COUNT);
    builder.add_SENZ(args.SENZ);
    builder.add_SENY(args.SENY);
    builder.add_SENX(args.SENX);
    builder.add_SENALT(args.SENALT);
    builder.add_SENLON(args.SENLON);
    builder.add_SENLAT(args.SENLAT);
    builder.add_LOSZVEL(args.LOSZVEL);
    builder.add_LOSYVEL(args.LOSYVEL);
    builder.add_LOSXVEL(args.LOSXVEL);
    builder.add_LOS_UNC(args.LOS_UNC);
    builder.add_LOSZ(args.LOSZ);
    builder.add_LOSY(args.LOSY);
    builder.add_LOSX(args.LOSX);
    builder.add_DECLINATION_BIAS(args.DECLINATION_BIAS);
    builder.add_DECLINATION_UNC(args.DECLINATION_UNC);
    builder.add_DECLINATION_RATE(args.DECLINATION_RATE);
    builder.add_DECLINATION(args.DECLINATION);
    builder.add_RA_BIAS(args.RA_BIAS);
    builder.add_RA_UNC(args.RA_UNC);
    builder.add_RA_RATE(args.RA_RATE);
    builder.add_RA(args.RA);
    builder.add_RANGE_RATE_UNC(args.RANGE_RATE_UNC);
    builder.add_RANGE_RATE(args.RANGE_RATE);
    builder.add_RANGE_BIAS(args.RANGE_BIAS);
    builder.add_RANGE_UNC(args.RANGE_UNC);
    builder.add_RANGE(args.RANGE);
    builder.add_ELEVATION_RATE(args.ELEVATION_RATE);
    builder.add_ELEVATION_BIAS(args.ELEVATION_BIAS);
    builder.add_ELEVATION_UNC(args.ELEVATION_UNC);
    builder.add_ELEVATION(args.ELEVATION);
    builder.add_AZIMUTH_RATE(args.AZIMUTH_RATE);
    builder.add_AZIMUTH_BIAS(args.AZIMUTH_BIAS);
    builder.add_AZIMUTH_UNC(args.AZIMUTH_UNC);
    builder.add_AZIMUTH(args.AZIMUTH);
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    if let Some(x) = args.OB_POSITION { builder.add_OB_POSITION(x); }
    if let Some(x) = args.TRACK_ID { builder.add_TRACK_ID(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.TASK_ID { builder.add_TASK_ID(x); }
    builder.add_NORAD_CAT_ID(args.NORAD_CAT_ID);
    if let Some(x) = args.COLLECT_METHOD { builder.add_COLLECT_METHOD(x); }
    if let Some(x) = args.SENSOR_ID { builder.add_SENSOR_ID(x); }
    if let Some(x) = args.ID_ON_ORBIT { builder.add_ID_ON_ORBIT(x); }
    builder.add_CORR_QUALITY(args.CORR_QUALITY);
    if let Some(x) = args.OB_TIME { builder.add_OB_TIME(x); }
    if let Some(x) = args.CLASSIFICATION { builder.add_CLASSIFICATION(x); }
    if let Some(x) = args.EOBSERVATION_ID { builder.add_EOBSERVATION_ID(x); }
    builder.add_PENUMBRA(args.PENUMBRA);
    builder.add_UMBRA(args.UMBRA);
    builder.add_REFERENCE_FRAME(args.REFERENCE_FRAME);
    builder.add_UCT(args.UCT);
    builder.finish()
  }

  pub fn unpack(&self) -> EOOT {
    let EOBSERVATION_ID = self.EOBSERVATION_ID().map(|x| {
      x.to_string()
    });
    let CLASSIFICATION = self.CLASSIFICATION().map(|x| {
      x.to_string()
    });
    let OB_TIME = self.OB_TIME().map(|x| {
      x.to_string()
    });
    let CORR_QUALITY = self.CORR_QUALITY();
    let ID_ON_ORBIT = self.ID_ON_ORBIT().map(|x| {
      x.to_string()
    });
    let SENSOR_ID = self.SENSOR_ID().map(|x| {
      x.to_string()
    });
    let COLLECT_METHOD = self.COLLECT_METHOD().map(|x| {
      x.to_string()
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID();
    let TASK_ID = self.TASK_ID().map(|x| {
      x.to_string()
    });
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let TRACK_ID = self.TRACK_ID().map(|x| {
      x.to_string()
    });
    let OB_POSITION = self.OB_POSITION().map(|x| {
      x.to_string()
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let UCT = self.UCT();
    let AZIMUTH = self.AZIMUTH();
    let AZIMUTH_UNC = self.AZIMUTH_UNC();
    let AZIMUTH_BIAS = self.AZIMUTH_BIAS();
    let AZIMUTH_RATE = self.AZIMUTH_RATE();
    let ELEVATION = self.ELEVATION();
    let ELEVATION_UNC = self.ELEVATION_UNC();
    let ELEVATION_BIAS = self.ELEVATION_BIAS();
    let ELEVATION_RATE = self.ELEVATION_RATE();
    let RANGE = self.RANGE();
    let RANGE_UNC = self.RANGE_UNC();
    let RANGE_BIAS = self.RANGE_BIAS();
    let RANGE_RATE = self.RANGE_RATE();
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC();
    let RA = self.RA();
    let RA_RATE = self.RA_RATE();
    let RA_UNC = self.RA_UNC();
    let RA_BIAS = self.RA_BIAS();
    let DECLINATION = self.DECLINATION();
    let DECLINATION_RATE = self.DECLINATION_RATE();
    let DECLINATION_UNC = self.DECLINATION_UNC();
    let DECLINATION_BIAS = self.DECLINATION_BIAS();
    let LOSX = self.LOSX();
    let LOSY = self.LOSY();
    let LOSZ = self.LOSZ();
    let LOS_UNC = self.LOS_UNC();
    let LOSXVEL = self.LOSXVEL();
    let LOSYVEL = self.LOSYVEL();
    let LOSZVEL = self.LOSZVEL();
    let SENLAT = self.SENLAT();
    let SENLON = self.SENLON();
    let SENALT = self.SENALT();
    let SENX = self.SENX();
    let SENY = self.SENY();
    let SENZ = self.SENZ();
    let FOV_COUNT = self.FOV_COUNT();
    let EXP_DURATION = self.EXP_DURATION();
    let ZEROPTD = self.ZEROPTD();
    let NET_OBJ_SIG = self.NET_OBJ_SIG();
    let NET_OBJ_SIG_UNC = self.NET_OBJ_SIG_UNC();
    let MAG = self.MAG();
    let MAG_UNC = self.MAG_UNC();
    let MAG_NORM_RANGE = self.MAG_NORM_RANGE();
    let GEOLAT = self.GEOLAT();
    let GEOLON = self.GEOLON();
    let GEOALT = self.GEOALT();
    let GEORANGE = self.GEORANGE();
    let SKY_BKGRND = self.SKY_BKGRND();
    let PRIMARY_EXTINCTION = self.PRIMARY_EXTINCTION();
    let PRIMARY_EXTINCTION_UNC = self.PRIMARY_EXTINCTION_UNC();
    let SOLAR_PHASE_ANGLE = self.SOLAR_PHASE_ANGLE();
    let SOLAR_EQ_PHASE_ANGLE = self.SOLAR_EQ_PHASE_ANGLE();
    let SOLAR_DEC_ANGLE = self.SOLAR_DEC_ANGLE();
    let SHUTTER_DELAY = self.SHUTTER_DELAY();
    let TIMING_BIAS = self.TIMING_BIAS();
    let RAW_FILE_URI = self.RAW_FILE_URI().map(|x| {
      x.to_string()
    });
    let INTENSITY = self.INTENSITY();
    let BG_INTENSITY = self.BG_INTENSITY();
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let ORIGIN = self.ORIGIN().map(|x| {
      x.to_string()
    });
    let DATA_MODE = self.DATA_MODE().map(|x| {
      x.to_string()
    });
    let CREATED_AT = self.CREATED_AT().map(|x| {
      x.to_string()
    });
    let CREATED_BY = self.CREATED_BY().map(|x| {
      x.to_string()
    });
    let REFERENCE_FRAME = self.REFERENCE_FRAME();
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let UMBRA = self.UMBRA();
    let PENUMBRA = self.PENUMBRA();
    let ORIG_NETWORK = self.ORIG_NETWORK().map(|x| {
      x.to_string()
    });
    let SOURCE_DL = self.SOURCE_DL().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    EOOT {
      EOBSERVATION_ID,
      CLASSIFICATION,
      OB_TIME,
      CORR_QUALITY,
      ID_ON_ORBIT,
      SENSOR_ID,
      COLLECT_METHOD,
      NORAD_CAT_ID,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      OB_POSITION,
      ORIG_OBJECT_ID,
      ORIG_SENSOR_ID,
      UCT,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_BIAS,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_BIAS,
      ELEVATION_RATE,
      RANGE,
      RANGE_UNC,
      RANGE_BIAS,
      RANGE_RATE,
      RANGE_RATE_UNC,
      RA,
      RA_RATE,
      RA_UNC,
      RA_BIAS,
      DECLINATION,
      DECLINATION_RATE,
      DECLINATION_UNC,
      DECLINATION_BIAS,
      LOSX,
      LOSY,
      LOSZ,
      LOS_UNC,
      LOSXVEL,
      LOSYVEL,
      LOSZVEL,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      FOV_COUNT,
      EXP_DURATION,
      ZEROPTD,
      NET_OBJ_SIG,
      NET_OBJ_SIG_UNC,
      MAG,
      MAG_UNC,
      MAG_NORM_RANGE,
      GEOLAT,
      GEOLON,
      GEOALT,
      GEORANGE,
      SKY_BKGRND,
      PRIMARY_EXTINCTION,
      PRIMARY_EXTINCTION_UNC,
      SOLAR_PHASE_ANGLE,
      SOLAR_EQ_PHASE_ANGLE,
      SOLAR_DEC_ANGLE,
      SHUTTER_DELAY,
      TIMING_BIAS,
      RAW_FILE_URI,
      INTENSITY,
      BG_INTENSITY,
      DESCRIPTOR,
      SOURCE,
      ORIGIN,
      DATA_MODE,
      CREATED_AT,
      CREATED_BY,
      REFERENCE_FRAME,
      SEN_REFERENCE_FRAME,
      UMBRA,
      PENUMBRA,
      ORIG_NETWORK,
      SOURCE_DL,
      TYPE,
    }
  }

  /// Unique identifier for Earth Observation Observation
  #[inline]
  pub fn EOBSERVATION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_EOBSERVATION_ID, None)}
  }
  /// Classification marking of the data
  #[inline]
  pub fn CLASSIFICATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_CLASSIFICATION, None)}
  }
  /// Observation time in UTC
  #[inline]
  pub fn OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_OB_TIME, None)}
  }
  /// Quality of the correlation
  #[inline]
  pub fn CORR_QUALITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_CORR_QUALITY, Some(0.0)).unwrap()}
  }
  /// Identifier for the satellite on orbit
  #[inline]
  pub fn ID_ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_ID_ON_ORBIT, None)}
  }
  /// Identifier for the sensor
  #[inline]
  pub fn SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_SENSOR_ID, None)}
  }
  /// Method of data collection
  #[inline]
  pub fn COLLECT_METHOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_COLLECT_METHOD, None)}
  }
  /// NORAD catalog identifier for the satellite
  #[inline]
  pub fn NORAD_CAT_ID(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOO::VT_NORAD_CAT_ID, Some(0)).unwrap()}
  }
  /// Identifier for the task
  #[inline]
  pub fn TASK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_TASK_ID, None)}
  }
  /// Identifier for the transaction
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_TRANSACTION_ID, None)}
  }
  /// Identifier for the track
  #[inline]
  pub fn TRACK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_TRACK_ID, None)}
  }
  /// Position of the observation
  #[inline]
  pub fn OB_POSITION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_OB_POSITION, None)}
  }
  /// Original object identifier
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_ORIG_OBJECT_ID, None)}
  }
  /// Original sensor identifier
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_ORIG_SENSOR_ID, None)}
  }
  /// Universal Coordinated Time flag
  #[inline]
  pub fn UCT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EOO::VT_UCT, Some(false)).unwrap()}
  }
  /// Azimuth angle
  #[inline]
  pub fn AZIMUTH(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// Uncertainty in azimuth angle
  #[inline]
  pub fn AZIMUTH_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_AZIMUTH_UNC, Some(0.0)).unwrap()}
  }
  /// Bias in azimuth angle
  #[inline]
  pub fn AZIMUTH_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_AZIMUTH_BIAS, Some(0.0)).unwrap()}
  }
  /// Rate of change in azimuth
  #[inline]
  pub fn AZIMUTH_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_AZIMUTH_RATE, Some(0.0)).unwrap()}
  }
  /// Elevation angle
  #[inline]
  pub fn ELEVATION(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  /// Uncertainty in elevation angle
  #[inline]
  pub fn ELEVATION_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_ELEVATION_UNC, Some(0.0)).unwrap()}
  }
  /// Bias in elevation angle
  #[inline]
  pub fn ELEVATION_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_ELEVATION_BIAS, Some(0.0)).unwrap()}
  }
  /// Rate of change in elevation
  #[inline]
  pub fn ELEVATION_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_ELEVATION_RATE, Some(0.0)).unwrap()}
  }
  /// Range to the target
  #[inline]
  pub fn RANGE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// Uncertainty in range
  #[inline]
  pub fn RANGE_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RANGE_UNC, Some(0.0)).unwrap()}
  }
  /// Bias in range measurement
  #[inline]
  pub fn RANGE_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RANGE_BIAS, Some(0.0)).unwrap()}
  }
  /// Rate of change in range
  #[inline]
  pub fn RANGE_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RANGE_RATE, Some(0.0)).unwrap()}
  }
  /// Uncertainty in range rate
  #[inline]
  pub fn RANGE_RATE_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RANGE_RATE_UNC, Some(0.0)).unwrap()}
  }
  /// Right ascension
  #[inline]
  pub fn RA(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RA, Some(0.0)).unwrap()}
  }
  /// Rate of change in right ascension
  #[inline]
  pub fn RA_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RA_RATE, Some(0.0)).unwrap()}
  }
  /// Uncertainty in right ascension
  #[inline]
  pub fn RA_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RA_UNC, Some(0.0)).unwrap()}
  }
  /// Bias in right ascension
  #[inline]
  pub fn RA_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_RA_BIAS, Some(0.0)).unwrap()}
  }
  /// Declination angle
  #[inline]
  pub fn DECLINATION(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_DECLINATION, Some(0.0)).unwrap()}
  }
  /// Rate of change in declination
  #[inline]
  pub fn DECLINATION_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_DECLINATION_RATE, Some(0.0)).unwrap()}
  }
  /// Uncertainty in declination
  #[inline]
  pub fn DECLINATION_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_DECLINATION_UNC, Some(0.0)).unwrap()}
  }
  /// Bias in declination
  #[inline]
  pub fn DECLINATION_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_DECLINATION_BIAS, Some(0.0)).unwrap()}
  }
  /// X-component of line-of-sight vector
  #[inline]
  pub fn LOSX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSX, Some(0.0)).unwrap()}
  }
  /// Y-component of line-of-sight vector
  #[inline]
  pub fn LOSY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSY, Some(0.0)).unwrap()}
  }
  /// Z-component of line-of-sight vector
  #[inline]
  pub fn LOSZ(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSZ, Some(0.0)).unwrap()}
  }
  /// Uncertainty in line-of-sight vector
  #[inline]
  pub fn LOS_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOS_UNC, Some(0.0)).unwrap()}
  }
  /// X-component of line-of-sight velocity
  #[inline]
  pub fn LOSXVEL(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSXVEL, Some(0.0)).unwrap()}
  }
  /// Y-component of line-of-sight velocity
  #[inline]
  pub fn LOSYVEL(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSYVEL, Some(0.0)).unwrap()}
  }
  /// Z-component of line-of-sight velocity
  #[inline]
  pub fn LOSZVEL(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_LOSZVEL, Some(0.0)).unwrap()}
  }
  /// Latitude of sensor
  #[inline]
  pub fn SENLAT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Longitude of sensor
  #[inline]
  pub fn SENLON(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Altitude of sensor
  #[inline]
  pub fn SENALT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// X-coordinate of sensor position
  #[inline]
  pub fn SENX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENX, Some(0.0)).unwrap()}
  }
  /// Y-coordinate of sensor position
  #[inline]
  pub fn SENY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENY, Some(0.0)).unwrap()}
  }
  /// Z-coordinate of sensor position
  #[inline]
  pub fn SENZ(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SENZ, Some(0.0)).unwrap()}
  }
  /// Number of fields of view
  #[inline]
  pub fn FOV_COUNT(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(EOO::VT_FOV_COUNT, Some(0)).unwrap()}
  }
  /// Duration of the exposure
  #[inline]
  pub fn EXP_DURATION(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_EXP_DURATION, Some(0.0)).unwrap()}
  }
  /// Zero-point displacement
  #[inline]
  pub fn ZEROPTD(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_ZEROPTD, Some(0.0)).unwrap()}
  }
  /// Net object signal
  #[inline]
  pub fn NET_OBJ_SIG(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_NET_OBJ_SIG, Some(0.0)).unwrap()}
  }
  /// Uncertainty in net object signal
  #[inline]
  pub fn NET_OBJ_SIG_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_NET_OBJ_SIG_UNC, Some(0.0)).unwrap()}
  }
  /// Magnitude of the observation
  #[inline]
  pub fn MAG(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_MAG, Some(0.0)).unwrap()}
  }
  /// Uncertainty in magnitude
  #[inline]
  pub fn MAG_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_MAG_UNC, Some(0.0)).unwrap()}
  }
  /// Normalized range for magnitude
  #[inline]
  pub fn MAG_NORM_RANGE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_MAG_NORM_RANGE, Some(0.0)).unwrap()}
  }
  /// Geocentric latitude
  #[inline]
  pub fn GEOLAT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_GEOLAT, Some(0.0)).unwrap()}
  }
  /// Geocentric longitude
  #[inline]
  pub fn GEOLON(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_GEOLON, Some(0.0)).unwrap()}
  }
  /// Geocentric altitude
  #[inline]
  pub fn GEOALT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_GEOALT, Some(0.0)).unwrap()}
  }
  /// Geocentric range
  #[inline]
  pub fn GEORANGE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_GEORANGE, Some(0.0)).unwrap()}
  }
  /// Sky background level
  #[inline]
  pub fn SKY_BKGRND(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SKY_BKGRND, Some(0.0)).unwrap()}
  }
  /// Primary extinction
  #[inline]
  pub fn PRIMARY_EXTINCTION(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_PRIMARY_EXTINCTION, Some(0.0)).unwrap()}
  }
  /// Uncertainty in primary extinction
  #[inline]
  pub fn PRIMARY_EXTINCTION_UNC(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_PRIMARY_EXTINCTION_UNC, Some(0.0)).unwrap()}
  }
  /// Solar phase angle
  #[inline]
  pub fn SOLAR_PHASE_ANGLE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SOLAR_PHASE_ANGLE, Some(0.0)).unwrap()}
  }
  /// Solar equatorial phase angle
  #[inline]
  pub fn SOLAR_EQ_PHASE_ANGLE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SOLAR_EQ_PHASE_ANGLE, Some(0.0)).unwrap()}
  }
  /// Solar declination angle
  #[inline]
  pub fn SOLAR_DEC_ANGLE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SOLAR_DEC_ANGLE, Some(0.0)).unwrap()}
  }
  /// Shutter delay
  #[inline]
  pub fn SHUTTER_DELAY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_SHUTTER_DELAY, Some(0.0)).unwrap()}
  }
  /// Timing bias
  #[inline]
  pub fn TIMING_BIAS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_TIMING_BIAS, Some(0.0)).unwrap()}
  }
  /// URI of the raw data file
  #[inline]
  pub fn RAW_FILE_URI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_RAW_FILE_URI, None)}
  }
  /// Intensity of the observation
  #[inline]
  pub fn INTENSITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_INTENSITY, Some(0.0)).unwrap()}
  }
  /// Background intensity
  #[inline]
  pub fn BG_INTENSITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(EOO::VT_BG_INTENSITY, Some(0.0)).unwrap()}
  }
  /// Descriptor of the provided data
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_DESCRIPTOR, None)}
  }
  /// Source of the data
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_SOURCE, None)}
  }
  /// Origin of the data
  #[inline]
  pub fn ORIGIN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_ORIGIN, None)}
  }
  /// Mode of the data
  #[inline]
  pub fn DATA_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_DATA_MODE, None)}
  }
  /// Creation time of the record
  #[inline]
  pub fn CREATED_AT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_CREATED_AT, None)}
  }
  /// User who created the record
  #[inline]
  pub fn CREATED_BY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_CREATED_BY, None)}
  }
  /// Reference frame of the observation
  #[inline]
  pub fn REFERENCE_FRAME(&self) -> refFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<refFrame>(EOO::VT_REFERENCE_FRAME, Some(refFrame::ECEF)).unwrap()}
  }
  /// Reference frame of the sensor
  #[inline]
  pub fn SEN_REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_SEN_REFERENCE_FRAME, None)}
  }
  /// Flag for umbra (total eclipse)
  #[inline]
  pub fn UMBRA(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EOO::VT_UMBRA, Some(false)).unwrap()}
  }
  /// Flag for penumbra (partial eclipse)
  #[inline]
  pub fn PENUMBRA(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(EOO::VT_PENUMBRA, Some(false)).unwrap()}
  }
  /// Original network identifier
  #[inline]
  pub fn ORIG_NETWORK(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_ORIG_NETWORK, None)}
  }
  /// Data link source
  #[inline]
  pub fn SOURCE_DL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_SOURCE_DL, None)}
  }
  /// Type of the observation
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EOO::VT_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for EOO<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EOBSERVATION_ID", Self::VT_EOBSERVATION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION", Self::VT_CLASSIFICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_TIME", Self::VT_OB_TIME, false)?
     .visit_field::<f32>("CORR_QUALITY", Self::VT_CORR_QUALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_ON_ORBIT", Self::VT_ID_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SENSOR_ID", Self::VT_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECT_METHOD", Self::VT_COLLECT_METHOD, false)?
     .visit_field::<i32>("NORAD_CAT_ID", Self::VT_NORAD_CAT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TASK_ID", Self::VT_TASK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_ID", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_POSITION", Self::VT_OB_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<bool>("UCT", Self::VT_UCT, false)?
     .visit_field::<f32>("AZIMUTH", Self::VT_AZIMUTH, false)?
     .visit_field::<f32>("AZIMUTH_UNC", Self::VT_AZIMUTH_UNC, false)?
     .visit_field::<f32>("AZIMUTH_BIAS", Self::VT_AZIMUTH_BIAS, false)?
     .visit_field::<f32>("AZIMUTH_RATE", Self::VT_AZIMUTH_RATE, false)?
     .visit_field::<f32>("ELEVATION", Self::VT_ELEVATION, false)?
     .visit_field::<f32>("ELEVATION_UNC", Self::VT_ELEVATION_UNC, false)?
     .visit_field::<f32>("ELEVATION_BIAS", Self::VT_ELEVATION_BIAS, false)?
     .visit_field::<f32>("ELEVATION_RATE", Self::VT_ELEVATION_RATE, false)?
     .visit_field::<f32>("RANGE", Self::VT_RANGE, false)?
     .visit_field::<f32>("RANGE_UNC", Self::VT_RANGE_UNC, false)?
     .visit_field::<f32>("RANGE_BIAS", Self::VT_RANGE_BIAS, false)?
     .visit_field::<f32>("RANGE_RATE", Self::VT_RANGE_RATE, false)?
     .visit_field::<f32>("RANGE_RATE_UNC", Self::VT_RANGE_RATE_UNC, false)?
     .visit_field::<f32>("RA", Self::VT_RA, false)?
     .visit_field::<f32>("RA_RATE", Self::VT_RA_RATE, false)?
     .visit_field::<f32>("RA_UNC", Self::VT_RA_UNC, false)?
     .visit_field::<f32>("RA_BIAS", Self::VT_RA_BIAS, false)?
     .visit_field::<f32>("DECLINATION", Self::VT_DECLINATION, false)?
     .visit_field::<f32>("DECLINATION_RATE", Self::VT_DECLINATION_RATE, false)?
     .visit_field::<f32>("DECLINATION_UNC", Self::VT_DECLINATION_UNC, false)?
     .visit_field::<f32>("DECLINATION_BIAS", Self::VT_DECLINATION_BIAS, false)?
     .visit_field::<f32>("LOSX", Self::VT_LOSX, false)?
     .visit_field::<f32>("LOSY", Self::VT_LOSY, false)?
     .visit_field::<f32>("LOSZ", Self::VT_LOSZ, false)?
     .visit_field::<f32>("LOS_UNC", Self::VT_LOS_UNC, false)?
     .visit_field::<f32>("LOSXVEL", Self::VT_LOSXVEL, false)?
     .visit_field::<f32>("LOSYVEL", Self::VT_LOSYVEL, false)?
     .visit_field::<f32>("LOSZVEL", Self::VT_LOSZVEL, false)?
     .visit_field::<f32>("SENLAT", Self::VT_SENLAT, false)?
     .visit_field::<f32>("SENLON", Self::VT_SENLON, false)?
     .visit_field::<f32>("SENALT", Self::VT_SENALT, false)?
     .visit_field::<f32>("SENX", Self::VT_SENX, false)?
     .visit_field::<f32>("SENY", Self::VT_SENY, false)?
     .visit_field::<f32>("SENZ", Self::VT_SENZ, false)?
     .visit_field::<i32>("FOV_COUNT", Self::VT_FOV_COUNT, false)?
     .visit_field::<f32>("EXP_DURATION", Self::VT_EXP_DURATION, false)?
     .visit_field::<f32>("ZEROPTD", Self::VT_ZEROPTD, false)?
     .visit_field::<f32>("NET_OBJ_SIG", Self::VT_NET_OBJ_SIG, false)?
     .visit_field::<f32>("NET_OBJ_SIG_UNC", Self::VT_NET_OBJ_SIG_UNC, false)?
     .visit_field::<f32>("MAG", Self::VT_MAG, false)?
     .visit_field::<f32>("MAG_UNC", Self::VT_MAG_UNC, false)?
     .visit_field::<f32>("MAG_NORM_RANGE", Self::VT_MAG_NORM_RANGE, false)?
     .visit_field::<f32>("GEOLAT", Self::VT_GEOLAT, false)?
     .visit_field::<f32>("GEOLON", Self::VT_GEOLON, false)?
     .visit_field::<f32>("GEOALT", Self::VT_GEOALT, false)?
     .visit_field::<f32>("GEORANGE", Self::VT_GEORANGE, false)?
     .visit_field::<f32>("SKY_BKGRND", Self::VT_SKY_BKGRND, false)?
     .visit_field::<f32>("PRIMARY_EXTINCTION", Self::VT_PRIMARY_EXTINCTION, false)?
     .visit_field::<f32>("PRIMARY_EXTINCTION_UNC", Self::VT_PRIMARY_EXTINCTION_UNC, false)?
     .visit_field::<f32>("SOLAR_PHASE_ANGLE", Self::VT_SOLAR_PHASE_ANGLE, false)?
     .visit_field::<f32>("SOLAR_EQ_PHASE_ANGLE", Self::VT_SOLAR_EQ_PHASE_ANGLE, false)?
     .visit_field::<f32>("SOLAR_DEC_ANGLE", Self::VT_SOLAR_DEC_ANGLE, false)?
     .visit_field::<f32>("SHUTTER_DELAY", Self::VT_SHUTTER_DELAY, false)?
     .visit_field::<f32>("TIMING_BIAS", Self::VT_TIMING_BIAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RAW_FILE_URI", Self::VT_RAW_FILE_URI, false)?
     .visit_field::<f32>("INTENSITY", Self::VT_INTENSITY, false)?
     .visit_field::<f32>("BG_INTENSITY", Self::VT_BG_INTENSITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGIN", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_MODE", Self::VT_DATA_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATED_AT", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATED_BY", Self::VT_CREATED_BY, false)?
     .visit_field::<refFrame>("REFERENCE_FRAME", Self::VT_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_REFERENCE_FRAME", Self::VT_SEN_REFERENCE_FRAME, false)?
     .visit_field::<bool>("UMBRA", Self::VT_UMBRA, false)?
     .visit_field::<bool>("PENUMBRA", Self::VT_PENUMBRA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_NETWORK", Self::VT_ORIG_NETWORK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE_DL", Self::VT_SOURCE_DL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct EOOArgs<'a> {
    pub EOBSERVATION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLASSIFICATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CORR_QUALITY: f32,
    pub ID_ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECT_METHOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NORAD_CAT_ID: i32,
    pub TASK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_POSITION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UCT: bool,
    pub AZIMUTH: f32,
    pub AZIMUTH_UNC: f32,
    pub AZIMUTH_BIAS: f32,
    pub AZIMUTH_RATE: f32,
    pub ELEVATION: f32,
    pub ELEVATION_UNC: f32,
    pub ELEVATION_BIAS: f32,
    pub ELEVATION_RATE: f32,
    pub RANGE: f32,
    pub RANGE_UNC: f32,
    pub RANGE_BIAS: f32,
    pub RANGE_RATE: f32,
    pub RANGE_RATE_UNC: f32,
    pub RA: f32,
    pub RA_RATE: f32,
    pub RA_UNC: f32,
    pub RA_BIAS: f32,
    pub DECLINATION: f32,
    pub DECLINATION_RATE: f32,
    pub DECLINATION_UNC: f32,
    pub DECLINATION_BIAS: f32,
    pub LOSX: f32,
    pub LOSY: f32,
    pub LOSZ: f32,
    pub LOS_UNC: f32,
    pub LOSXVEL: f32,
    pub LOSYVEL: f32,
    pub LOSZVEL: f32,
    pub SENLAT: f32,
    pub SENLON: f32,
    pub SENALT: f32,
    pub SENX: f32,
    pub SENY: f32,
    pub SENZ: f32,
    pub FOV_COUNT: i32,
    pub EXP_DURATION: f32,
    pub ZEROPTD: f32,
    pub NET_OBJ_SIG: f32,
    pub NET_OBJ_SIG_UNC: f32,
    pub MAG: f32,
    pub MAG_UNC: f32,
    pub MAG_NORM_RANGE: f32,
    pub GEOLAT: f32,
    pub GEOLON: f32,
    pub GEOALT: f32,
    pub GEORANGE: f32,
    pub SKY_BKGRND: f32,
    pub PRIMARY_EXTINCTION: f32,
    pub PRIMARY_EXTINCTION_UNC: f32,
    pub SOLAR_PHASE_ANGLE: f32,
    pub SOLAR_EQ_PHASE_ANGLE: f32,
    pub SOLAR_DEC_ANGLE: f32,
    pub SHUTTER_DELAY: f32,
    pub TIMING_BIAS: f32,
    pub RAW_FILE_URI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTENSITY: f32,
    pub BG_INTENSITY: f32,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGIN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CREATED_AT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CREATED_BY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REFERENCE_FRAME: refFrame,
    pub SEN_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UMBRA: bool,
    pub PENUMBRA: bool,
    pub ORIG_NETWORK: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE_DL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EOOArgs<'a> {
  #[inline]
  fn default() -> Self {
    EOOArgs {
      EOBSERVATION_ID: None,
      CLASSIFICATION: None,
      OB_TIME: None,
      CORR_QUALITY: 0.0,
      ID_ON_ORBIT: None,
      SENSOR_ID: None,
      COLLECT_METHOD: None,
      NORAD_CAT_ID: 0,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      OB_POSITION: None,
      ORIG_OBJECT_ID: None,
      ORIG_SENSOR_ID: None,
      UCT: false,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_BIAS: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_BIAS: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_UNC: 0.0,
      RANGE_BIAS: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      RA: 0.0,
      RA_RATE: 0.0,
      RA_UNC: 0.0,
      RA_BIAS: 0.0,
      DECLINATION: 0.0,
      DECLINATION_RATE: 0.0,
      DECLINATION_UNC: 0.0,
      DECLINATION_BIAS: 0.0,
      LOSX: 0.0,
      LOSY: 0.0,
      LOSZ: 0.0,
      LOS_UNC: 0.0,
      LOSXVEL: 0.0,
      LOSYVEL: 0.0,
      LOSZVEL: 0.0,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      FOV_COUNT: 0,
      EXP_DURATION: 0.0,
      ZEROPTD: 0.0,
      NET_OBJ_SIG: 0.0,
      NET_OBJ_SIG_UNC: 0.0,
      MAG: 0.0,
      MAG_UNC: 0.0,
      MAG_NORM_RANGE: 0.0,
      GEOLAT: 0.0,
      GEOLON: 0.0,
      GEOALT: 0.0,
      GEORANGE: 0.0,
      SKY_BKGRND: 0.0,
      PRIMARY_EXTINCTION: 0.0,
      PRIMARY_EXTINCTION_UNC: 0.0,
      SOLAR_PHASE_ANGLE: 0.0,
      SOLAR_EQ_PHASE_ANGLE: 0.0,
      SOLAR_DEC_ANGLE: 0.0,
      SHUTTER_DELAY: 0.0,
      TIMING_BIAS: 0.0,
      RAW_FILE_URI: None,
      INTENSITY: 0.0,
      BG_INTENSITY: 0.0,
      DESCRIPTOR: None,
      SOURCE: None,
      ORIGIN: None,
      DATA_MODE: None,
      CREATED_AT: None,
      CREATED_BY: None,
      REFERENCE_FRAME: refFrame::ECEF,
      SEN_REFERENCE_FRAME: None,
      UMBRA: false,
      PENUMBRA: false,
      ORIG_NETWORK: None,
      SOURCE_DL: None,
      TYPE: None,
    }
  }
}

pub struct EOOBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EOOBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EOBSERVATION_ID(&mut self, EOBSERVATION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_EOBSERVATION_ID, EOBSERVATION_ID);
  }
  #[inline]
  pub fn add_CLASSIFICATION(&mut self, CLASSIFICATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_CLASSIFICATION, CLASSIFICATION);
  }
  #[inline]
  pub fn add_OB_TIME(&mut self, OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_OB_TIME, OB_TIME);
  }
  #[inline]
  pub fn add_CORR_QUALITY(&mut self, CORR_QUALITY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_CORR_QUALITY, CORR_QUALITY, 0.0);
  }
  #[inline]
  pub fn add_ID_ON_ORBIT(&mut self, ID_ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  #[inline]
  pub fn add_SENSOR_ID(&mut self, SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_SENSOR_ID, SENSOR_ID);
  }
  #[inline]
  pub fn add_COLLECT_METHOD(&mut self, COLLECT_METHOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_COLLECT_METHOD, COLLECT_METHOD);
  }
  #[inline]
  pub fn add_NORAD_CAT_ID(&mut self, NORAD_CAT_ID: i32) {
    self.fbb_.push_slot::<i32>(EOO::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  #[inline]
  pub fn add_TASK_ID(&mut self, TASK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_TASK_ID, TASK_ID);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_TRACK_ID(&mut self, TRACK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_TRACK_ID, TRACK_ID);
  }
  #[inline]
  pub fn add_OB_POSITION(&mut self, OB_POSITION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_OB_POSITION, OB_POSITION);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_UCT(&mut self, UCT: bool) {
    self.fbb_.push_slot::<bool>(EOO::VT_UCT, UCT, false);
  }
  #[inline]
  pub fn add_AZIMUTH(&mut self, AZIMUTH: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_AZIMUTH, AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_UNC(&mut self, AZIMUTH_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_AZIMUTH_UNC, AZIMUTH_UNC, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_BIAS(&mut self, AZIMUTH_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_AZIMUTH_BIAS, AZIMUTH_BIAS, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_RATE(&mut self, AZIMUTH_RATE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_AZIMUTH_RATE, AZIMUTH_RATE, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION(&mut self, ELEVATION: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_ELEVATION, ELEVATION, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_UNC(&mut self, ELEVATION_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_ELEVATION_UNC, ELEVATION_UNC, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_BIAS(&mut self, ELEVATION_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_ELEVATION_BIAS, ELEVATION_BIAS, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_RATE(&mut self, ELEVATION_RATE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_ELEVATION_RATE, ELEVATION_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE(&mut self, RANGE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RANGE, RANGE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_UNC(&mut self, RANGE_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RANGE_UNC, RANGE_UNC, 0.0);
  }
  #[inline]
  pub fn add_RANGE_BIAS(&mut self, RANGE_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RANGE_BIAS, RANGE_BIAS, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE(&mut self, RANGE_RATE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RANGE_RATE, RANGE_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE_UNC(&mut self, RANGE_RATE_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RANGE_RATE_UNC, RANGE_RATE_UNC, 0.0);
  }
  #[inline]
  pub fn add_RA(&mut self, RA: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RA, RA, 0.0);
  }
  #[inline]
  pub fn add_RA_RATE(&mut self, RA_RATE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RA_RATE, RA_RATE, 0.0);
  }
  #[inline]
  pub fn add_RA_UNC(&mut self, RA_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RA_UNC, RA_UNC, 0.0);
  }
  #[inline]
  pub fn add_RA_BIAS(&mut self, RA_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_RA_BIAS, RA_BIAS, 0.0);
  }
  #[inline]
  pub fn add_DECLINATION(&mut self, DECLINATION: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_DECLINATION, DECLINATION, 0.0);
  }
  #[inline]
  pub fn add_DECLINATION_RATE(&mut self, DECLINATION_RATE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_DECLINATION_RATE, DECLINATION_RATE, 0.0);
  }
  #[inline]
  pub fn add_DECLINATION_UNC(&mut self, DECLINATION_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_DECLINATION_UNC, DECLINATION_UNC, 0.0);
  }
  #[inline]
  pub fn add_DECLINATION_BIAS(&mut self, DECLINATION_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_DECLINATION_BIAS, DECLINATION_BIAS, 0.0);
  }
  #[inline]
  pub fn add_LOSX(&mut self, LOSX: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSX, LOSX, 0.0);
  }
  #[inline]
  pub fn add_LOSY(&mut self, LOSY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSY, LOSY, 0.0);
  }
  #[inline]
  pub fn add_LOSZ(&mut self, LOSZ: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSZ, LOSZ, 0.0);
  }
  #[inline]
  pub fn add_LOS_UNC(&mut self, LOS_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOS_UNC, LOS_UNC, 0.0);
  }
  #[inline]
  pub fn add_LOSXVEL(&mut self, LOSXVEL: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSXVEL, LOSXVEL, 0.0);
  }
  #[inline]
  pub fn add_LOSYVEL(&mut self, LOSYVEL: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSYVEL, LOSYVEL, 0.0);
  }
  #[inline]
  pub fn add_LOSZVEL(&mut self, LOSZVEL: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_LOSZVEL, LOSZVEL, 0.0);
  }
  #[inline]
  pub fn add_SENLAT(&mut self, SENLAT: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENLAT, SENLAT, 0.0);
  }
  #[inline]
  pub fn add_SENLON(&mut self, SENLON: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENLON, SENLON, 0.0);
  }
  #[inline]
  pub fn add_SENALT(&mut self, SENALT: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENALT, SENALT, 0.0);
  }
  #[inline]
  pub fn add_SENX(&mut self, SENX: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENX, SENX, 0.0);
  }
  #[inline]
  pub fn add_SENY(&mut self, SENY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENY, SENY, 0.0);
  }
  #[inline]
  pub fn add_SENZ(&mut self, SENZ: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SENZ, SENZ, 0.0);
  }
  #[inline]
  pub fn add_FOV_COUNT(&mut self, FOV_COUNT: i32) {
    self.fbb_.push_slot::<i32>(EOO::VT_FOV_COUNT, FOV_COUNT, 0);
  }
  #[inline]
  pub fn add_EXP_DURATION(&mut self, EXP_DURATION: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_EXP_DURATION, EXP_DURATION, 0.0);
  }
  #[inline]
  pub fn add_ZEROPTD(&mut self, ZEROPTD: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_ZEROPTD, ZEROPTD, 0.0);
  }
  #[inline]
  pub fn add_NET_OBJ_SIG(&mut self, NET_OBJ_SIG: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_NET_OBJ_SIG, NET_OBJ_SIG, 0.0);
  }
  #[inline]
  pub fn add_NET_OBJ_SIG_UNC(&mut self, NET_OBJ_SIG_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_NET_OBJ_SIG_UNC, NET_OBJ_SIG_UNC, 0.0);
  }
  #[inline]
  pub fn add_MAG(&mut self, MAG: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_MAG, MAG, 0.0);
  }
  #[inline]
  pub fn add_MAG_UNC(&mut self, MAG_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_MAG_UNC, MAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_MAG_NORM_RANGE(&mut self, MAG_NORM_RANGE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_MAG_NORM_RANGE, MAG_NORM_RANGE, 0.0);
  }
  #[inline]
  pub fn add_GEOLAT(&mut self, GEOLAT: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_GEOLAT, GEOLAT, 0.0);
  }
  #[inline]
  pub fn add_GEOLON(&mut self, GEOLON: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_GEOLON, GEOLON, 0.0);
  }
  #[inline]
  pub fn add_GEOALT(&mut self, GEOALT: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_GEOALT, GEOALT, 0.0);
  }
  #[inline]
  pub fn add_GEORANGE(&mut self, GEORANGE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_GEORANGE, GEORANGE, 0.0);
  }
  #[inline]
  pub fn add_SKY_BKGRND(&mut self, SKY_BKGRND: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SKY_BKGRND, SKY_BKGRND, 0.0);
  }
  #[inline]
  pub fn add_PRIMARY_EXTINCTION(&mut self, PRIMARY_EXTINCTION: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_PRIMARY_EXTINCTION, PRIMARY_EXTINCTION, 0.0);
  }
  #[inline]
  pub fn add_PRIMARY_EXTINCTION_UNC(&mut self, PRIMARY_EXTINCTION_UNC: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_PRIMARY_EXTINCTION_UNC, PRIMARY_EXTINCTION_UNC, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_PHASE_ANGLE(&mut self, SOLAR_PHASE_ANGLE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SOLAR_PHASE_ANGLE, SOLAR_PHASE_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_EQ_PHASE_ANGLE(&mut self, SOLAR_EQ_PHASE_ANGLE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SOLAR_EQ_PHASE_ANGLE, SOLAR_EQ_PHASE_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_DEC_ANGLE(&mut self, SOLAR_DEC_ANGLE: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SOLAR_DEC_ANGLE, SOLAR_DEC_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_SHUTTER_DELAY(&mut self, SHUTTER_DELAY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_SHUTTER_DELAY, SHUTTER_DELAY, 0.0);
  }
  #[inline]
  pub fn add_TIMING_BIAS(&mut self, TIMING_BIAS: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_TIMING_BIAS, TIMING_BIAS, 0.0);
  }
  #[inline]
  pub fn add_RAW_FILE_URI(&mut self, RAW_FILE_URI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_RAW_FILE_URI, RAW_FILE_URI);
  }
  #[inline]
  pub fn add_INTENSITY(&mut self, INTENSITY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_INTENSITY, INTENSITY, 0.0);
  }
  #[inline]
  pub fn add_BG_INTENSITY(&mut self, BG_INTENSITY: f32) {
    self.fbb_.push_slot::<f32>(EOO::VT_BG_INTENSITY, BG_INTENSITY, 0.0);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_ORIGIN(&mut self, ORIGIN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_ORIGIN, ORIGIN);
  }
  #[inline]
  pub fn add_DATA_MODE(&mut self, DATA_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_DATA_MODE, DATA_MODE);
  }
  #[inline]
  pub fn add_CREATED_AT(&mut self, CREATED_AT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_CREATED_AT, CREATED_AT);
  }
  #[inline]
  pub fn add_CREATED_BY(&mut self, CREATED_BY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_CREATED_BY, CREATED_BY);
  }
  #[inline]
  pub fn add_REFERENCE_FRAME(&mut self, REFERENCE_FRAME: refFrame) {
    self.fbb_.push_slot::<refFrame>(EOO::VT_REFERENCE_FRAME, REFERENCE_FRAME, refFrame::ECEF);
  }
  #[inline]
  pub fn add_SEN_REFERENCE_FRAME(&mut self, SEN_REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_SEN_REFERENCE_FRAME, SEN_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_UMBRA(&mut self, UMBRA: bool) {
    self.fbb_.push_slot::<bool>(EOO::VT_UMBRA, UMBRA, false);
  }
  #[inline]
  pub fn add_PENUMBRA(&mut self, PENUMBRA: bool) {
    self.fbb_.push_slot::<bool>(EOO::VT_PENUMBRA, PENUMBRA, false);
  }
  #[inline]
  pub fn add_ORIG_NETWORK(&mut self, ORIG_NETWORK: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_ORIG_NETWORK, ORIG_NETWORK);
  }
  #[inline]
  pub fn add_SOURCE_DL(&mut self, SOURCE_DL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_SOURCE_DL, SOURCE_DL);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOO::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EOOBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EOOBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EOO<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EOO<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EOO");
      ds.field("EOBSERVATION_ID", &self.EOBSERVATION_ID());
      ds.field("CLASSIFICATION", &self.CLASSIFICATION());
      ds.field("OB_TIME", &self.OB_TIME());
      ds.field("CORR_QUALITY", &self.CORR_QUALITY());
      ds.field("ID_ON_ORBIT", &self.ID_ON_ORBIT());
      ds.field("SENSOR_ID", &self.SENSOR_ID());
      ds.field("COLLECT_METHOD", &self.COLLECT_METHOD());
      ds.field("NORAD_CAT_ID", &self.NORAD_CAT_ID());
      ds.field("TASK_ID", &self.TASK_ID());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("TRACK_ID", &self.TRACK_ID());
      ds.field("OB_POSITION", &self.OB_POSITION());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("UCT", &self.UCT());
      ds.field("AZIMUTH", &self.AZIMUTH());
      ds.field("AZIMUTH_UNC", &self.AZIMUTH_UNC());
      ds.field("AZIMUTH_BIAS", &self.AZIMUTH_BIAS());
      ds.field("AZIMUTH_RATE", &self.AZIMUTH_RATE());
      ds.field("ELEVATION", &self.ELEVATION());
      ds.field("ELEVATION_UNC", &self.ELEVATION_UNC());
      ds.field("ELEVATION_BIAS", &self.ELEVATION_BIAS());
      ds.field("ELEVATION_RATE", &self.ELEVATION_RATE());
      ds.field("RANGE", &self.RANGE());
      ds.field("RANGE_UNC", &self.RANGE_UNC());
      ds.field("RANGE_BIAS", &self.RANGE_BIAS());
      ds.field("RANGE_RATE", &self.RANGE_RATE());
      ds.field("RANGE_RATE_UNC", &self.RANGE_RATE_UNC());
      ds.field("RA", &self.RA());
      ds.field("RA_RATE", &self.RA_RATE());
      ds.field("RA_UNC", &self.RA_UNC());
      ds.field("RA_BIAS", &self.RA_BIAS());
      ds.field("DECLINATION", &self.DECLINATION());
      ds.field("DECLINATION_RATE", &self.DECLINATION_RATE());
      ds.field("DECLINATION_UNC", &self.DECLINATION_UNC());
      ds.field("DECLINATION_BIAS", &self.DECLINATION_BIAS());
      ds.field("LOSX", &self.LOSX());
      ds.field("LOSY", &self.LOSY());
      ds.field("LOSZ", &self.LOSZ());
      ds.field("LOS_UNC", &self.LOS_UNC());
      ds.field("LOSXVEL", &self.LOSXVEL());
      ds.field("LOSYVEL", &self.LOSYVEL());
      ds.field("LOSZVEL", &self.LOSZVEL());
      ds.field("SENLAT", &self.SENLAT());
      ds.field("SENLON", &self.SENLON());
      ds.field("SENALT", &self.SENALT());
      ds.field("SENX", &self.SENX());
      ds.field("SENY", &self.SENY());
      ds.field("SENZ", &self.SENZ());
      ds.field("FOV_COUNT", &self.FOV_COUNT());
      ds.field("EXP_DURATION", &self.EXP_DURATION());
      ds.field("ZEROPTD", &self.ZEROPTD());
      ds.field("NET_OBJ_SIG", &self.NET_OBJ_SIG());
      ds.field("NET_OBJ_SIG_UNC", &self.NET_OBJ_SIG_UNC());
      ds.field("MAG", &self.MAG());
      ds.field("MAG_UNC", &self.MAG_UNC());
      ds.field("MAG_NORM_RANGE", &self.MAG_NORM_RANGE());
      ds.field("GEOLAT", &self.GEOLAT());
      ds.field("GEOLON", &self.GEOLON());
      ds.field("GEOALT", &self.GEOALT());
      ds.field("GEORANGE", &self.GEORANGE());
      ds.field("SKY_BKGRND", &self.SKY_BKGRND());
      ds.field("PRIMARY_EXTINCTION", &self.PRIMARY_EXTINCTION());
      ds.field("PRIMARY_EXTINCTION_UNC", &self.PRIMARY_EXTINCTION_UNC());
      ds.field("SOLAR_PHASE_ANGLE", &self.SOLAR_PHASE_ANGLE());
      ds.field("SOLAR_EQ_PHASE_ANGLE", &self.SOLAR_EQ_PHASE_ANGLE());
      ds.field("SOLAR_DEC_ANGLE", &self.SOLAR_DEC_ANGLE());
      ds.field("SHUTTER_DELAY", &self.SHUTTER_DELAY());
      ds.field("TIMING_BIAS", &self.TIMING_BIAS());
      ds.field("RAW_FILE_URI", &self.RAW_FILE_URI());
      ds.field("INTENSITY", &self.INTENSITY());
      ds.field("BG_INTENSITY", &self.BG_INTENSITY());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("ORIGIN", &self.ORIGIN());
      ds.field("DATA_MODE", &self.DATA_MODE());
      ds.field("CREATED_AT", &self.CREATED_AT());
      ds.field("CREATED_BY", &self.CREATED_BY());
      ds.field("REFERENCE_FRAME", &self.REFERENCE_FRAME());
      ds.field("SEN_REFERENCE_FRAME", &self.SEN_REFERENCE_FRAME());
      ds.field("UMBRA", &self.UMBRA());
      ds.field("PENUMBRA", &self.PENUMBRA());
      ds.field("ORIG_NETWORK", &self.ORIG_NETWORK());
      ds.field("SOURCE_DL", &self.SOURCE_DL());
      ds.field("TYPE", &self.TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EOOT {
  pub EOBSERVATION_ID: Option<String>,
  pub CLASSIFICATION: Option<String>,
  pub OB_TIME: Option<String>,
  pub CORR_QUALITY: f32,
  pub ID_ON_ORBIT: Option<String>,
  pub SENSOR_ID: Option<String>,
  pub COLLECT_METHOD: Option<String>,
  pub NORAD_CAT_ID: i32,
  pub TASK_ID: Option<String>,
  pub TRANSACTION_ID: Option<String>,
  pub TRACK_ID: Option<String>,
  pub OB_POSITION: Option<String>,
  pub ORIG_OBJECT_ID: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub UCT: bool,
  pub AZIMUTH: f32,
  pub AZIMUTH_UNC: f32,
  pub AZIMUTH_BIAS: f32,
  pub AZIMUTH_RATE: f32,
  pub ELEVATION: f32,
  pub ELEVATION_UNC: f32,
  pub ELEVATION_BIAS: f32,
  pub ELEVATION_RATE: f32,
  pub RANGE: f32,
  pub RANGE_UNC: f32,
  pub RANGE_BIAS: f32,
  pub RANGE_RATE: f32,
  pub RANGE_RATE_UNC: f32,
  pub RA: f32,
  pub RA_RATE: f32,
  pub RA_UNC: f32,
  pub RA_BIAS: f32,
  pub DECLINATION: f32,
  pub DECLINATION_RATE: f32,
  pub DECLINATION_UNC: f32,
  pub DECLINATION_BIAS: f32,
  pub LOSX: f32,
  pub LOSY: f32,
  pub LOSZ: f32,
  pub LOS_UNC: f32,
  pub LOSXVEL: f32,
  pub LOSYVEL: f32,
  pub LOSZVEL: f32,
  pub SENLAT: f32,
  pub SENLON: f32,
  pub SENALT: f32,
  pub SENX: f32,
  pub SENY: f32,
  pub SENZ: f32,
  pub FOV_COUNT: i32,
  pub EXP_DURATION: f32,
  pub ZEROPTD: f32,
  pub NET_OBJ_SIG: f32,
  pub NET_OBJ_SIG_UNC: f32,
  pub MAG: f32,
  pub MAG_UNC: f32,
  pub MAG_NORM_RANGE: f32,
  pub GEOLAT: f32,
  pub GEOLON: f32,
  pub GEOALT: f32,
  pub GEORANGE: f32,
  pub SKY_BKGRND: f32,
  pub PRIMARY_EXTINCTION: f32,
  pub PRIMARY_EXTINCTION_UNC: f32,
  pub SOLAR_PHASE_ANGLE: f32,
  pub SOLAR_EQ_PHASE_ANGLE: f32,
  pub SOLAR_DEC_ANGLE: f32,
  pub SHUTTER_DELAY: f32,
  pub TIMING_BIAS: f32,
  pub RAW_FILE_URI: Option<String>,
  pub INTENSITY: f32,
  pub BG_INTENSITY: f32,
  pub DESCRIPTOR: Option<String>,
  pub SOURCE: Option<String>,
  pub ORIGIN: Option<String>,
  pub DATA_MODE: Option<String>,
  pub CREATED_AT: Option<String>,
  pub CREATED_BY: Option<String>,
  pub REFERENCE_FRAME: refFrame,
  pub SEN_REFERENCE_FRAME: Option<String>,
  pub UMBRA: bool,
  pub PENUMBRA: bool,
  pub ORIG_NETWORK: Option<String>,
  pub SOURCE_DL: Option<String>,
  pub TYPE: Option<String>,
}
impl Default for EOOT {
  fn default() -> Self {
    Self {
      EOBSERVATION_ID: None,
      CLASSIFICATION: None,
      OB_TIME: None,
      CORR_QUALITY: 0.0,
      ID_ON_ORBIT: None,
      SENSOR_ID: None,
      COLLECT_METHOD: None,
      NORAD_CAT_ID: 0,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      OB_POSITION: None,
      ORIG_OBJECT_ID: None,
      ORIG_SENSOR_ID: None,
      UCT: false,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_BIAS: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_BIAS: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_UNC: 0.0,
      RANGE_BIAS: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      RA: 0.0,
      RA_RATE: 0.0,
      RA_UNC: 0.0,
      RA_BIAS: 0.0,
      DECLINATION: 0.0,
      DECLINATION_RATE: 0.0,
      DECLINATION_UNC: 0.0,
      DECLINATION_BIAS: 0.0,
      LOSX: 0.0,
      LOSY: 0.0,
      LOSZ: 0.0,
      LOS_UNC: 0.0,
      LOSXVEL: 0.0,
      LOSYVEL: 0.0,
      LOSZVEL: 0.0,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      FOV_COUNT: 0,
      EXP_DURATION: 0.0,
      ZEROPTD: 0.0,
      NET_OBJ_SIG: 0.0,
      NET_OBJ_SIG_UNC: 0.0,
      MAG: 0.0,
      MAG_UNC: 0.0,
      MAG_NORM_RANGE: 0.0,
      GEOLAT: 0.0,
      GEOLON: 0.0,
      GEOALT: 0.0,
      GEORANGE: 0.0,
      SKY_BKGRND: 0.0,
      PRIMARY_EXTINCTION: 0.0,
      PRIMARY_EXTINCTION_UNC: 0.0,
      SOLAR_PHASE_ANGLE: 0.0,
      SOLAR_EQ_PHASE_ANGLE: 0.0,
      SOLAR_DEC_ANGLE: 0.0,
      SHUTTER_DELAY: 0.0,
      TIMING_BIAS: 0.0,
      RAW_FILE_URI: None,
      INTENSITY: 0.0,
      BG_INTENSITY: 0.0,
      DESCRIPTOR: None,
      SOURCE: None,
      ORIGIN: None,
      DATA_MODE: None,
      CREATED_AT: None,
      CREATED_BY: None,
      REFERENCE_FRAME: refFrame::ECEF,
      SEN_REFERENCE_FRAME: None,
      UMBRA: false,
      PENUMBRA: false,
      ORIG_NETWORK: None,
      SOURCE_DL: None,
      TYPE: None,
    }
  }
}
impl EOOT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EOO<'b>> {
    let EOBSERVATION_ID = self.EOBSERVATION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLASSIFICATION = self.CLASSIFICATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_TIME = self.OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CORR_QUALITY = self.CORR_QUALITY;
    let ID_ON_ORBIT = self.ID_ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENSOR_ID = self.SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECT_METHOD = self.COLLECT_METHOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID;
    let TASK_ID = self.TASK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACK_ID = self.TRACK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_POSITION = self.OB_POSITION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UCT = self.UCT;
    let AZIMUTH = self.AZIMUTH;
    let AZIMUTH_UNC = self.AZIMUTH_UNC;
    let AZIMUTH_BIAS = self.AZIMUTH_BIAS;
    let AZIMUTH_RATE = self.AZIMUTH_RATE;
    let ELEVATION = self.ELEVATION;
    let ELEVATION_UNC = self.ELEVATION_UNC;
    let ELEVATION_BIAS = self.ELEVATION_BIAS;
    let ELEVATION_RATE = self.ELEVATION_RATE;
    let RANGE = self.RANGE;
    let RANGE_UNC = self.RANGE_UNC;
    let RANGE_BIAS = self.RANGE_BIAS;
    let RANGE_RATE = self.RANGE_RATE;
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC;
    let RA = self.RA;
    let RA_RATE = self.RA_RATE;
    let RA_UNC = self.RA_UNC;
    let RA_BIAS = self.RA_BIAS;
    let DECLINATION = self.DECLINATION;
    let DECLINATION_RATE = self.DECLINATION_RATE;
    let DECLINATION_UNC = self.DECLINATION_UNC;
    let DECLINATION_BIAS = self.DECLINATION_BIAS;
    let LOSX = self.LOSX;
    let LOSY = self.LOSY;
    let LOSZ = self.LOSZ;
    let LOS_UNC = self.LOS_UNC;
    let LOSXVEL = self.LOSXVEL;
    let LOSYVEL = self.LOSYVEL;
    let LOSZVEL = self.LOSZVEL;
    let SENLAT = self.SENLAT;
    let SENLON = self.SENLON;
    let SENALT = self.SENALT;
    let SENX = self.SENX;
    let SENY = self.SENY;
    let SENZ = self.SENZ;
    let FOV_COUNT = self.FOV_COUNT;
    let EXP_DURATION = self.EXP_DURATION;
    let ZEROPTD = self.ZEROPTD;
    let NET_OBJ_SIG = self.NET_OBJ_SIG;
    let NET_OBJ_SIG_UNC = self.NET_OBJ_SIG_UNC;
    let MAG = self.MAG;
    let MAG_UNC = self.MAG_UNC;
    let MAG_NORM_RANGE = self.MAG_NORM_RANGE;
    let GEOLAT = self.GEOLAT;
    let GEOLON = self.GEOLON;
    let GEOALT = self.GEOALT;
    let GEORANGE = self.GEORANGE;
    let SKY_BKGRND = self.SKY_BKGRND;
    let PRIMARY_EXTINCTION = self.PRIMARY_EXTINCTION;
    let PRIMARY_EXTINCTION_UNC = self.PRIMARY_EXTINCTION_UNC;
    let SOLAR_PHASE_ANGLE = self.SOLAR_PHASE_ANGLE;
    let SOLAR_EQ_PHASE_ANGLE = self.SOLAR_EQ_PHASE_ANGLE;
    let SOLAR_DEC_ANGLE = self.SOLAR_DEC_ANGLE;
    let SHUTTER_DELAY = self.SHUTTER_DELAY;
    let TIMING_BIAS = self.TIMING_BIAS;
    let RAW_FILE_URI = self.RAW_FILE_URI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTENSITY = self.INTENSITY;
    let BG_INTENSITY = self.BG_INTENSITY;
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGIN = self.ORIGIN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_MODE = self.DATA_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CREATED_AT = self.CREATED_AT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CREATED_BY = self.CREATED_BY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REFERENCE_FRAME = self.REFERENCE_FRAME;
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UMBRA = self.UMBRA;
    let PENUMBRA = self.PENUMBRA;
    let ORIG_NETWORK = self.ORIG_NETWORK.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE_DL = self.SOURCE_DL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EOO::create(_fbb, &EOOArgs{
      EOBSERVATION_ID,
      CLASSIFICATION,
      OB_TIME,
      CORR_QUALITY,
      ID_ON_ORBIT,
      SENSOR_ID,
      COLLECT_METHOD,
      NORAD_CAT_ID,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      OB_POSITION,
      ORIG_OBJECT_ID,
      ORIG_SENSOR_ID,
      UCT,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_BIAS,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_BIAS,
      ELEVATION_RATE,
      RANGE,
      RANGE_UNC,
      RANGE_BIAS,
      RANGE_RATE,
      RANGE_RATE_UNC,
      RA,
      RA_RATE,
      RA_UNC,
      RA_BIAS,
      DECLINATION,
      DECLINATION_RATE,
      DECLINATION_UNC,
      DECLINATION_BIAS,
      LOSX,
      LOSY,
      LOSZ,
      LOS_UNC,
      LOSXVEL,
      LOSYVEL,
      LOSZVEL,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      FOV_COUNT,
      EXP_DURATION,
      ZEROPTD,
      NET_OBJ_SIG,
      NET_OBJ_SIG_UNC,
      MAG,
      MAG_UNC,
      MAG_NORM_RANGE,
      GEOLAT,
      GEOLON,
      GEOALT,
      GEORANGE,
      SKY_BKGRND,
      PRIMARY_EXTINCTION,
      PRIMARY_EXTINCTION_UNC,
      SOLAR_PHASE_ANGLE,
      SOLAR_EQ_PHASE_ANGLE,
      SOLAR_DEC_ANGLE,
      SHUTTER_DELAY,
      TIMING_BIAS,
      RAW_FILE_URI,
      INTENSITY,
      BG_INTENSITY,
      DESCRIPTOR,
      SOURCE,
      ORIGIN,
      DATA_MODE,
      CREATED_AT,
      CREATED_BY,
      REFERENCE_FRAME,
      SEN_REFERENCE_FRAME,
      UMBRA,
      PENUMBRA,
      ORIG_NETWORK,
      SOURCE_DL,
      TYPE,
    })
  }
}
pub enum EOOCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EOOCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EOOCOLLECTION<'a> {
  type Inner = EOOCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EOOCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EOOCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EOOCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<EOOCOLLECTION<'bldr>> {
    let mut builder = EOOCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EOOCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    EOOCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EOO<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EOO>>>>(EOOCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for EOOCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EOO>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct EOOCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EOO<'a>>>>>,
}
impl<'a> Default for EOOCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    EOOCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct EOOCOLLECTIONBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EOOCOLLECTIONBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EOO<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EOOCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EOOCOLLECTIONBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EOOCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EOOCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EOOCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EOOCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EOOCOLLECTIONT {
  pub RECORDS: Option<Vec<EOOT>>,
}
impl Default for EOOCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl EOOCOLLECTIONT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EOOCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    EOOCOLLECTION::create(_fbb, &EOOCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EOO`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EOO_unchecked`.
pub fn root_as_EOO(buf: &[u8]) -> Result<EOO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EOO>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EOO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EOO_unchecked`.
pub fn size_prefixed_root_as_EOO(buf: &[u8]) -> Result<EOO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EOO>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EOO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EOO_unchecked`.
pub fn root_as_EOO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EOO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EOO<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EOO` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EOO_unchecked`.
pub fn size_prefixed_root_as_EOO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EOO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EOO<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EOO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EOO`.
pub unsafe fn root_as_EOO_unchecked(buf: &[u8]) -> EOO {
  flatbuffers::root_unchecked::<EOO>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EOO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EOO`.
pub unsafe fn size_prefixed_root_as_EOO_unchecked(buf: &[u8]) -> EOO {
  flatbuffers::size_prefixed_root_unchecked::<EOO>(buf)
}
pub const EOO_IDENTIFIER: &str = "$EOO";

#[inline]
pub fn EOO_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EOO_IDENTIFIER, false)
}

#[inline]
pub fn EOO_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EOO_IDENTIFIER, true)
}

#[inline]
pub fn finish_EOO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<EOO<'a>>) {
  fbb.finish(root, Some(EOO_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EOO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<EOO<'a>>) {
  fbb.finish_size_prefixed(root, Some(EOO_IDENTIFIER));
}
