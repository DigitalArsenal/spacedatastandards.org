// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUS_SIZE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUS_SIZE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUS_SIZE: [busSize; 9] = [
  busSize::FEMTO,
  busSize::PICO,
  busSize::NANO,
  busSize::MICRO,
  busSize::MINI,
  busSize::SMALL,
  busSize::MEDIUM,
  busSize::LARGE,
  busSize::HEAVY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct busSize(pub i8);
#[allow(non_upper_case_globals)]
impl busSize {
  pub const FEMTO: Self = Self(0);
  pub const PICO: Self = Self(1);
  pub const NANO: Self = Self(2);
  pub const MICRO: Self = Self(3);
  pub const MINI: Self = Self(4);
  pub const SMALL: Self = Self(5);
  pub const MEDIUM: Self = Self(6);
  pub const LARGE: Self = Self(7);
  pub const HEAVY: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FEMTO,
    Self::PICO,
    Self::NANO,
    Self::MICRO,
    Self::MINI,
    Self::SMALL,
    Self::MEDIUM,
    Self::LARGE,
    Self::HEAVY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FEMTO => Some("FEMTO"),
      Self::PICO => Some("PICO"),
      Self::NANO => Some("NANO"),
      Self::MICRO => Some("MICRO"),
      Self::MINI => Some("MINI"),
      Self::SMALL => Some("SMALL"),
      Self::MEDIUM => Some("MEDIUM"),
      Self::LARGE => Some("LARGE"),
      Self::HEAVY => Some("HEAVY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for busSize {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for busSize {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for busSize {
    type Output = busSize;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for busSize {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for busSize {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for busSize {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUS_STABILIZATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUS_STABILIZATION_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUS_STABILIZATION_TYPE: [BusStabilizationType; 6] = [
  BusStabilizationType::THREE_AXIS,
  BusStabilizationType::SPIN,
  BusStabilizationType::GRAVITY_GRADIENT,
  BusStabilizationType::MAGNETIC,
  BusStabilizationType::DUAL_SPIN,
  BusStabilizationType::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BusStabilizationType(pub i8);
#[allow(non_upper_case_globals)]
impl BusStabilizationType {
  pub const THREE_AXIS: Self = Self(0);
  pub const SPIN: Self = Self(1);
  pub const GRAVITY_GRADIENT: Self = Self(2);
  pub const MAGNETIC: Self = Self(3);
  pub const DUAL_SPIN: Self = Self(4);
  pub const NONE: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::THREE_AXIS,
    Self::SPIN,
    Self::GRAVITY_GRADIENT,
    Self::MAGNETIC,
    Self::DUAL_SPIN,
    Self::NONE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::THREE_AXIS => Some("THREE_AXIS"),
      Self::SPIN => Some("SPIN"),
      Self::GRAVITY_GRADIENT => Some("GRAVITY_GRADIENT"),
      Self::MAGNETIC => Some("MAGNETIC"),
      Self::DUAL_SPIN => Some("DUAL_SPIN"),
      Self::NONE => Some("NONE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BusStabilizationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BusStabilizationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BusStabilizationType {
    type Output = BusStabilizationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BusStabilizationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BusStabilizationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BusStabilizationType {}
pub enum BUSOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Satellite Bus Specification
pub struct BUS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BUS<'a> {
  type Inner = BUS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BUS<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_MANUFACTURER: flatbuffers::VOffsetT = 8;
  pub const VT_SIZE: flatbuffers::VOffsetT = 10;
  pub const VT_DRY_MASS: flatbuffers::VOffsetT = 12;
  pub const VT_WET_MASS: flatbuffers::VOffsetT = 14;
  pub const VT_PAYLOAD_MASS: flatbuffers::VOffsetT = 16;
  pub const VT_DIM_X: flatbuffers::VOffsetT = 18;
  pub const VT_DIM_Y: flatbuffers::VOffsetT = 20;
  pub const VT_DIM_Z: flatbuffers::VOffsetT = 22;
  pub const VT_STOWED_X: flatbuffers::VOffsetT = 24;
  pub const VT_STOWED_Y: flatbuffers::VOffsetT = 26;
  pub const VT_STOWED_Z: flatbuffers::VOffsetT = 28;
  pub const VT_POWER_GENERATION: flatbuffers::VOffsetT = 30;
  pub const VT_PAYLOAD_POWER: flatbuffers::VOffsetT = 32;
  pub const VT_BATTERY_CAPACITY: flatbuffers::VOffsetT = 34;
  pub const VT_STABILIZATION: flatbuffers::VOffsetT = 36;
  pub const VT_POINTING_ACCURACY: flatbuffers::VOffsetT = 38;
  pub const VT_POINTING_KNOWLEDGE: flatbuffers::VOffsetT = 40;
  pub const VT_DESIGN_LIFE: flatbuffers::VOffsetT = 42;
  pub const VT_DATA_STORAGE: flatbuffers::VOffsetT = 44;
  pub const VT_DOWNLINK_RATE: flatbuffers::VOffsetT = 46;
  pub const VT_PAYLOAD_SLOTS: flatbuffers::VOffsetT = 48;
  pub const VT_HERITAGE_COUNT: flatbuffers::VOffsetT = 50;
  pub const VT_NOTES: flatbuffers::VOffsetT = 52;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BUS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BUSArgs<'args>
  ) -> flatbuffers::WIPOffset<BUS<'bldr>> {
    let mut builder = BUSBuilder::new(_fbb);
    builder.add_DOWNLINK_RATE(args.DOWNLINK_RATE);
    builder.add_DATA_STORAGE(args.DATA_STORAGE);
    builder.add_DESIGN_LIFE(args.DESIGN_LIFE);
    builder.add_POINTING_KNOWLEDGE(args.POINTING_KNOWLEDGE);
    builder.add_POINTING_ACCURACY(args.POINTING_ACCURACY);
    builder.add_BATTERY_CAPACITY(args.BATTERY_CAPACITY);
    builder.add_PAYLOAD_POWER(args.PAYLOAD_POWER);
    builder.add_POWER_GENERATION(args.POWER_GENERATION);
    builder.add_STOWED_Z(args.STOWED_Z);
    builder.add_STOWED_Y(args.STOWED_Y);
    builder.add_STOWED_X(args.STOWED_X);
    builder.add_DIM_Z(args.DIM_Z);
    builder.add_DIM_Y(args.DIM_Y);
    builder.add_DIM_X(args.DIM_X);
    builder.add_PAYLOAD_MASS(args.PAYLOAD_MASS);
    builder.add_WET_MASS(args.WET_MASS);
    builder.add_DRY_MASS(args.DRY_MASS);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    builder.add_HERITAGE_COUNT(args.HERITAGE_COUNT);
    builder.add_PAYLOAD_SLOTS(args.PAYLOAD_SLOTS);
    if let Some(x) = args.MANUFACTURER { builder.add_MANUFACTURER(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_STABILIZATION(args.STABILIZATION);
    builder.add_SIZE(args.SIZE);
    builder.finish()
  }

  pub fn unpack(&self) -> BUST {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let MANUFACTURER = self.MANUFACTURER().map(|x| {
      x.to_string()
    });
    let SIZE = self.SIZE();
    let DRY_MASS = self.DRY_MASS();
    let WET_MASS = self.WET_MASS();
    let PAYLOAD_MASS = self.PAYLOAD_MASS();
    let DIM_X = self.DIM_X();
    let DIM_Y = self.DIM_Y();
    let DIM_Z = self.DIM_Z();
    let STOWED_X = self.STOWED_X();
    let STOWED_Y = self.STOWED_Y();
    let STOWED_Z = self.STOWED_Z();
    let POWER_GENERATION = self.POWER_GENERATION();
    let PAYLOAD_POWER = self.PAYLOAD_POWER();
    let BATTERY_CAPACITY = self.BATTERY_CAPACITY();
    let STABILIZATION = self.STABILIZATION();
    let POINTING_ACCURACY = self.POINTING_ACCURACY();
    let POINTING_KNOWLEDGE = self.POINTING_KNOWLEDGE();
    let DESIGN_LIFE = self.DESIGN_LIFE();
    let DATA_STORAGE = self.DATA_STORAGE();
    let DOWNLINK_RATE = self.DOWNLINK_RATE();
    let PAYLOAD_SLOTS = self.PAYLOAD_SLOTS();
    let HERITAGE_COUNT = self.HERITAGE_COUNT();
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    BUST {
      ID,
      NAME,
      MANUFACTURER,
      SIZE,
      DRY_MASS,
      WET_MASS,
      PAYLOAD_MASS,
      DIM_X,
      DIM_Y,
      DIM_Z,
      STOWED_X,
      STOWED_Y,
      STOWED_Z,
      POWER_GENERATION,
      PAYLOAD_POWER,
      BATTERY_CAPACITY,
      STABILIZATION,
      POINTING_ACCURACY,
      POINTING_KNOWLEDGE,
      DESIGN_LIFE,
      DATA_STORAGE,
      DOWNLINK_RATE,
      PAYLOAD_SLOTS,
      HERITAGE_COUNT,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BUS::VT_ID, None)}
  }
  /// Bus name or model
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BUS::VT_NAME, None)}
  }
  /// Manufacturer
  #[inline]
  pub fn MANUFACTURER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BUS::VT_MANUFACTURER, None)}
  }
  /// Bus size category
  #[inline]
  pub fn SIZE(&self) -> busSize {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<busSize>(BUS::VT_SIZE, Some(busSize::FEMTO)).unwrap()}
  }
  /// Dry mass in kg
  #[inline]
  pub fn DRY_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DRY_MASS, Some(0.0)).unwrap()}
  }
  /// Maximum wet mass (with propellant) in kg
  #[inline]
  pub fn WET_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_WET_MASS, Some(0.0)).unwrap()}
  }
  /// Maximum payload mass in kg
  #[inline]
  pub fn PAYLOAD_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_PAYLOAD_MASS, Some(0.0)).unwrap()}
  }
  /// Bus dimensions X in meters
  #[inline]
  pub fn DIM_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DIM_X, Some(0.0)).unwrap()}
  }
  /// Bus dimensions Y in meters
  #[inline]
  pub fn DIM_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DIM_Y, Some(0.0)).unwrap()}
  }
  /// Bus dimensions Z in meters
  #[inline]
  pub fn DIM_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DIM_Z, Some(0.0)).unwrap()}
  }
  /// Stowed dimensions X in meters
  #[inline]
  pub fn STOWED_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_STOWED_X, Some(0.0)).unwrap()}
  }
  /// Stowed dimensions Y in meters
  #[inline]
  pub fn STOWED_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_STOWED_Y, Some(0.0)).unwrap()}
  }
  /// Stowed dimensions Z in meters
  #[inline]
  pub fn STOWED_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_STOWED_Z, Some(0.0)).unwrap()}
  }
  /// Total power generation in Watts
  #[inline]
  pub fn POWER_GENERATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_POWER_GENERATION, Some(0.0)).unwrap()}
  }
  /// Available payload power in Watts
  #[inline]
  pub fn PAYLOAD_POWER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_PAYLOAD_POWER, Some(0.0)).unwrap()}
  }
  /// Battery capacity in Watt-hours
  #[inline]
  pub fn BATTERY_CAPACITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_BATTERY_CAPACITY, Some(0.0)).unwrap()}
  }
  /// Stabilization method
  #[inline]
  pub fn STABILIZATION(&self) -> BusStabilizationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BusStabilizationType>(BUS::VT_STABILIZATION, Some(BusStabilizationType::THREE_AXIS)).unwrap()}
  }
  /// Pointing accuracy in degrees
  #[inline]
  pub fn POINTING_ACCURACY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_POINTING_ACCURACY, Some(0.0)).unwrap()}
  }
  /// Pointing knowledge in degrees
  #[inline]
  pub fn POINTING_KNOWLEDGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_POINTING_KNOWLEDGE, Some(0.0)).unwrap()}
  }
  /// Design life in years
  #[inline]
  pub fn DESIGN_LIFE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DESIGN_LIFE, Some(0.0)).unwrap()}
  }
  /// Data storage capacity in Gbits
  #[inline]
  pub fn DATA_STORAGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DATA_STORAGE, Some(0.0)).unwrap()}
  }
  /// Downlink data rate in Mbps
  #[inline]
  pub fn DOWNLINK_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BUS::VT_DOWNLINK_RATE, Some(0.0)).unwrap()}
  }
  /// Number of payload slots/interfaces
  #[inline]
  pub fn PAYLOAD_SLOTS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BUS::VT_PAYLOAD_SLOTS, Some(0)).unwrap()}
  }
  /// Heritage missions count
  #[inline]
  pub fn HERITAGE_COUNT(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(BUS::VT_HERITAGE_COUNT, Some(0)).unwrap()}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BUS::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for BUS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MANUFACTURER", Self::VT_MANUFACTURER, false)?
     .visit_field::<busSize>("SIZE", Self::VT_SIZE, false)?
     .visit_field::<f64>("DRY_MASS", Self::VT_DRY_MASS, false)?
     .visit_field::<f64>("WET_MASS", Self::VT_WET_MASS, false)?
     .visit_field::<f64>("PAYLOAD_MASS", Self::VT_PAYLOAD_MASS, false)?
     .visit_field::<f64>("DIM_X", Self::VT_DIM_X, false)?
     .visit_field::<f64>("DIM_Y", Self::VT_DIM_Y, false)?
     .visit_field::<f64>("DIM_Z", Self::VT_DIM_Z, false)?
     .visit_field::<f64>("STOWED_X", Self::VT_STOWED_X, false)?
     .visit_field::<f64>("STOWED_Y", Self::VT_STOWED_Y, false)?
     .visit_field::<f64>("STOWED_Z", Self::VT_STOWED_Z, false)?
     .visit_field::<f64>("POWER_GENERATION", Self::VT_POWER_GENERATION, false)?
     .visit_field::<f64>("PAYLOAD_POWER", Self::VT_PAYLOAD_POWER, false)?
     .visit_field::<f64>("BATTERY_CAPACITY", Self::VT_BATTERY_CAPACITY, false)?
     .visit_field::<BusStabilizationType>("STABILIZATION", Self::VT_STABILIZATION, false)?
     .visit_field::<f64>("POINTING_ACCURACY", Self::VT_POINTING_ACCURACY, false)?
     .visit_field::<f64>("POINTING_KNOWLEDGE", Self::VT_POINTING_KNOWLEDGE, false)?
     .visit_field::<f64>("DESIGN_LIFE", Self::VT_DESIGN_LIFE, false)?
     .visit_field::<f64>("DATA_STORAGE", Self::VT_DATA_STORAGE, false)?
     .visit_field::<f64>("DOWNLINK_RATE", Self::VT_DOWNLINK_RATE, false)?
     .visit_field::<u32>("PAYLOAD_SLOTS", Self::VT_PAYLOAD_SLOTS, false)?
     .visit_field::<u32>("HERITAGE_COUNT", Self::VT_HERITAGE_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct BUSArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MANUFACTURER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIZE: busSize,
    pub DRY_MASS: f64,
    pub WET_MASS: f64,
    pub PAYLOAD_MASS: f64,
    pub DIM_X: f64,
    pub DIM_Y: f64,
    pub DIM_Z: f64,
    pub STOWED_X: f64,
    pub STOWED_Y: f64,
    pub STOWED_Z: f64,
    pub POWER_GENERATION: f64,
    pub PAYLOAD_POWER: f64,
    pub BATTERY_CAPACITY: f64,
    pub STABILIZATION: BusStabilizationType,
    pub POINTING_ACCURACY: f64,
    pub POINTING_KNOWLEDGE: f64,
    pub DESIGN_LIFE: f64,
    pub DATA_STORAGE: f64,
    pub DOWNLINK_RATE: f64,
    pub PAYLOAD_SLOTS: u32,
    pub HERITAGE_COUNT: u32,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BUSArgs<'a> {
  #[inline]
  fn default() -> Self {
    BUSArgs {
      ID: None,
      NAME: None,
      MANUFACTURER: None,
      SIZE: busSize::FEMTO,
      DRY_MASS: 0.0,
      WET_MASS: 0.0,
      PAYLOAD_MASS: 0.0,
      DIM_X: 0.0,
      DIM_Y: 0.0,
      DIM_Z: 0.0,
      STOWED_X: 0.0,
      STOWED_Y: 0.0,
      STOWED_Z: 0.0,
      POWER_GENERATION: 0.0,
      PAYLOAD_POWER: 0.0,
      BATTERY_CAPACITY: 0.0,
      STABILIZATION: BusStabilizationType::THREE_AXIS,
      POINTING_ACCURACY: 0.0,
      POINTING_KNOWLEDGE: 0.0,
      DESIGN_LIFE: 0.0,
      DATA_STORAGE: 0.0,
      DOWNLINK_RATE: 0.0,
      PAYLOAD_SLOTS: 0,
      HERITAGE_COUNT: 0,
      NOTES: None,
    }
  }
}

pub struct BUSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BUSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BUS::VT_ID, ID);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BUS::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_MANUFACTURER(&mut self, MANUFACTURER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BUS::VT_MANUFACTURER, MANUFACTURER);
  }
  #[inline]
  pub fn add_SIZE(&mut self, SIZE: busSize) {
    self.fbb_.push_slot::<busSize>(BUS::VT_SIZE, SIZE, busSize::FEMTO);
  }
  #[inline]
  pub fn add_DRY_MASS(&mut self, DRY_MASS: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DRY_MASS, DRY_MASS, 0.0);
  }
  #[inline]
  pub fn add_WET_MASS(&mut self, WET_MASS: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_WET_MASS, WET_MASS, 0.0);
  }
  #[inline]
  pub fn add_PAYLOAD_MASS(&mut self, PAYLOAD_MASS: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_PAYLOAD_MASS, PAYLOAD_MASS, 0.0);
  }
  #[inline]
  pub fn add_DIM_X(&mut self, DIM_X: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DIM_X, DIM_X, 0.0);
  }
  #[inline]
  pub fn add_DIM_Y(&mut self, DIM_Y: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DIM_Y, DIM_Y, 0.0);
  }
  #[inline]
  pub fn add_DIM_Z(&mut self, DIM_Z: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DIM_Z, DIM_Z, 0.0);
  }
  #[inline]
  pub fn add_STOWED_X(&mut self, STOWED_X: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_STOWED_X, STOWED_X, 0.0);
  }
  #[inline]
  pub fn add_STOWED_Y(&mut self, STOWED_Y: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_STOWED_Y, STOWED_Y, 0.0);
  }
  #[inline]
  pub fn add_STOWED_Z(&mut self, STOWED_Z: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_STOWED_Z, STOWED_Z, 0.0);
  }
  #[inline]
  pub fn add_POWER_GENERATION(&mut self, POWER_GENERATION: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_POWER_GENERATION, POWER_GENERATION, 0.0);
  }
  #[inline]
  pub fn add_PAYLOAD_POWER(&mut self, PAYLOAD_POWER: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_PAYLOAD_POWER, PAYLOAD_POWER, 0.0);
  }
  #[inline]
  pub fn add_BATTERY_CAPACITY(&mut self, BATTERY_CAPACITY: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_BATTERY_CAPACITY, BATTERY_CAPACITY, 0.0);
  }
  #[inline]
  pub fn add_STABILIZATION(&mut self, STABILIZATION: BusStabilizationType) {
    self.fbb_.push_slot::<BusStabilizationType>(BUS::VT_STABILIZATION, STABILIZATION, BusStabilizationType::THREE_AXIS);
  }
  #[inline]
  pub fn add_POINTING_ACCURACY(&mut self, POINTING_ACCURACY: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_POINTING_ACCURACY, POINTING_ACCURACY, 0.0);
  }
  #[inline]
  pub fn add_POINTING_KNOWLEDGE(&mut self, POINTING_KNOWLEDGE: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_POINTING_KNOWLEDGE, POINTING_KNOWLEDGE, 0.0);
  }
  #[inline]
  pub fn add_DESIGN_LIFE(&mut self, DESIGN_LIFE: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DESIGN_LIFE, DESIGN_LIFE, 0.0);
  }
  #[inline]
  pub fn add_DATA_STORAGE(&mut self, DATA_STORAGE: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DATA_STORAGE, DATA_STORAGE, 0.0);
  }
  #[inline]
  pub fn add_DOWNLINK_RATE(&mut self, DOWNLINK_RATE: f64) {
    self.fbb_.push_slot::<f64>(BUS::VT_DOWNLINK_RATE, DOWNLINK_RATE, 0.0);
  }
  #[inline]
  pub fn add_PAYLOAD_SLOTS(&mut self, PAYLOAD_SLOTS: u32) {
    self.fbb_.push_slot::<u32>(BUS::VT_PAYLOAD_SLOTS, PAYLOAD_SLOTS, 0);
  }
  #[inline]
  pub fn add_HERITAGE_COUNT(&mut self, HERITAGE_COUNT: u32) {
    self.fbb_.push_slot::<u32>(BUS::VT_HERITAGE_COUNT, HERITAGE_COUNT, 0);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BUS::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BUSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BUSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BUS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BUS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BUS");
      ds.field("ID", &self.ID());
      ds.field("NAME", &self.NAME());
      ds.field("MANUFACTURER", &self.MANUFACTURER());
      ds.field("SIZE", &self.SIZE());
      ds.field("DRY_MASS", &self.DRY_MASS());
      ds.field("WET_MASS", &self.WET_MASS());
      ds.field("PAYLOAD_MASS", &self.PAYLOAD_MASS());
      ds.field("DIM_X", &self.DIM_X());
      ds.field("DIM_Y", &self.DIM_Y());
      ds.field("DIM_Z", &self.DIM_Z());
      ds.field("STOWED_X", &self.STOWED_X());
      ds.field("STOWED_Y", &self.STOWED_Y());
      ds.field("STOWED_Z", &self.STOWED_Z());
      ds.field("POWER_GENERATION", &self.POWER_GENERATION());
      ds.field("PAYLOAD_POWER", &self.PAYLOAD_POWER());
      ds.field("BATTERY_CAPACITY", &self.BATTERY_CAPACITY());
      ds.field("STABILIZATION", &self.STABILIZATION());
      ds.field("POINTING_ACCURACY", &self.POINTING_ACCURACY());
      ds.field("POINTING_KNOWLEDGE", &self.POINTING_KNOWLEDGE());
      ds.field("DESIGN_LIFE", &self.DESIGN_LIFE());
      ds.field("DATA_STORAGE", &self.DATA_STORAGE());
      ds.field("DOWNLINK_RATE", &self.DOWNLINK_RATE());
      ds.field("PAYLOAD_SLOTS", &self.PAYLOAD_SLOTS());
      ds.field("HERITAGE_COUNT", &self.HERITAGE_COUNT());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BUST {
  pub ID: Option<String>,
  pub NAME: Option<String>,
  pub MANUFACTURER: Option<String>,
  pub SIZE: busSize,
  pub DRY_MASS: f64,
  pub WET_MASS: f64,
  pub PAYLOAD_MASS: f64,
  pub DIM_X: f64,
  pub DIM_Y: f64,
  pub DIM_Z: f64,
  pub STOWED_X: f64,
  pub STOWED_Y: f64,
  pub STOWED_Z: f64,
  pub POWER_GENERATION: f64,
  pub PAYLOAD_POWER: f64,
  pub BATTERY_CAPACITY: f64,
  pub STABILIZATION: BusStabilizationType,
  pub POINTING_ACCURACY: f64,
  pub POINTING_KNOWLEDGE: f64,
  pub DESIGN_LIFE: f64,
  pub DATA_STORAGE: f64,
  pub DOWNLINK_RATE: f64,
  pub PAYLOAD_SLOTS: u32,
  pub HERITAGE_COUNT: u32,
  pub NOTES: Option<String>,
}
impl Default for BUST {
  fn default() -> Self {
    Self {
      ID: None,
      NAME: None,
      MANUFACTURER: None,
      SIZE: busSize::FEMTO,
      DRY_MASS: 0.0,
      WET_MASS: 0.0,
      PAYLOAD_MASS: 0.0,
      DIM_X: 0.0,
      DIM_Y: 0.0,
      DIM_Z: 0.0,
      STOWED_X: 0.0,
      STOWED_Y: 0.0,
      STOWED_Z: 0.0,
      POWER_GENERATION: 0.0,
      PAYLOAD_POWER: 0.0,
      BATTERY_CAPACITY: 0.0,
      STABILIZATION: BusStabilizationType::THREE_AXIS,
      POINTING_ACCURACY: 0.0,
      POINTING_KNOWLEDGE: 0.0,
      DESIGN_LIFE: 0.0,
      DATA_STORAGE: 0.0,
      DOWNLINK_RATE: 0.0,
      PAYLOAD_SLOTS: 0,
      HERITAGE_COUNT: 0,
      NOTES: None,
    }
  }
}
impl BUST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BUS<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MANUFACTURER = self.MANUFACTURER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIZE = self.SIZE;
    let DRY_MASS = self.DRY_MASS;
    let WET_MASS = self.WET_MASS;
    let PAYLOAD_MASS = self.PAYLOAD_MASS;
    let DIM_X = self.DIM_X;
    let DIM_Y = self.DIM_Y;
    let DIM_Z = self.DIM_Z;
    let STOWED_X = self.STOWED_X;
    let STOWED_Y = self.STOWED_Y;
    let STOWED_Z = self.STOWED_Z;
    let POWER_GENERATION = self.POWER_GENERATION;
    let PAYLOAD_POWER = self.PAYLOAD_POWER;
    let BATTERY_CAPACITY = self.BATTERY_CAPACITY;
    let STABILIZATION = self.STABILIZATION;
    let POINTING_ACCURACY = self.POINTING_ACCURACY;
    let POINTING_KNOWLEDGE = self.POINTING_KNOWLEDGE;
    let DESIGN_LIFE = self.DESIGN_LIFE;
    let DATA_STORAGE = self.DATA_STORAGE;
    let DOWNLINK_RATE = self.DOWNLINK_RATE;
    let PAYLOAD_SLOTS = self.PAYLOAD_SLOTS;
    let HERITAGE_COUNT = self.HERITAGE_COUNT;
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    BUS::create(_fbb, &BUSArgs{
      ID,
      NAME,
      MANUFACTURER,
      SIZE,
      DRY_MASS,
      WET_MASS,
      PAYLOAD_MASS,
      DIM_X,
      DIM_Y,
      DIM_Z,
      STOWED_X,
      STOWED_Y,
      STOWED_Z,
      POWER_GENERATION,
      PAYLOAD_POWER,
      BATTERY_CAPACITY,
      STABILIZATION,
      POINTING_ACCURACY,
      POINTING_KNOWLEDGE,
      DESIGN_LIFE,
      DATA_STORAGE,
      DOWNLINK_RATE,
      PAYLOAD_SLOTS,
      HERITAGE_COUNT,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `BUS`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BUS_unchecked`.
pub fn root_as_BUS(buf: &[u8]) -> Result<BUS, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<BUS>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `BUS` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_BUS_unchecked`.
pub fn size_prefixed_root_as_BUS(buf: &[u8]) -> Result<BUS, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<BUS>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `BUS` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BUS_unchecked`.
pub fn root_as_BUS_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BUS<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<BUS<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `BUS` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BUS_unchecked`.
pub fn size_prefixed_root_as_BUS_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BUS<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<BUS<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a BUS and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `BUS`.
pub unsafe fn root_as_BUS_unchecked(buf: &[u8]) -> BUS {
  flatbuffers::root_unchecked::<BUS>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed BUS and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `BUS`.
pub unsafe fn size_prefixed_root_as_BUS_unchecked(buf: &[u8]) -> BUS {
  flatbuffers::size_prefixed_root_unchecked::<BUS>(buf)
}
pub const BUS_IDENTIFIER: &str = "$BUS";

#[inline]
pub fn BUS_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BUS_IDENTIFIER, false)
}

#[inline]
pub fn BUS_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BUS_IDENTIFIER, true)
}

#[inline]
pub fn finish_BUS_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<BUS<'a>>) {
  fbb.finish(root, Some(BUS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_BUS_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<BUS<'a>>) {
  fbb.finish_size_prefixed(root, Some(BUS_IDENTIFIER));
}
