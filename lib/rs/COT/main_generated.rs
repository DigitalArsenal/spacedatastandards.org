// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COTHOW_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COTHOW_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COTHOW_TYPE: [COTHowType; 7] = [
  COTHowType::HE,
  COTHowType::H_E,
  COTHowType::M_G,
  COTHowType::M_S,
  COTHowType::M_F,
  COTHowType::M_I,
  COTHowType::M_C,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct COTHowType(pub i8);
#[allow(non_upper_case_globals)]
impl COTHowType {
  /// Human entered or generated
  pub const HE: Self = Self(0);
  /// Human estimated
  pub const H_E: Self = Self(1);
  /// Machine generated via GPS
  pub const M_G: Self = Self(2);
  /// Machine generated via sensor
  pub const M_S: Self = Self(3);
  /// Machine fused
  pub const M_F: Self = Self(4);
  /// Machine inferred
  pub const M_I: Self = Self(5);
  /// Configured
  pub const M_C: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HE,
    Self::H_E,
    Self::M_G,
    Self::M_S,
    Self::M_F,
    Self::M_I,
    Self::M_C,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HE => Some("HE"),
      Self::H_E => Some("H_E"),
      Self::M_G => Some("M_G"),
      Self::M_S => Some("M_S"),
      Self::M_F => Some("M_F"),
      Self::M_I => Some("M_I"),
      Self::M_C => Some("M_C"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for COTHowType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for COTHowType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for COTHowType {
    type Output = COTHowType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for COTHowType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for COTHowType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for COTHowType {}
pub enum COTPointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// CoT Point - geographical point with error estimates
pub struct COTPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for COTPoint<'a> {
  type Inner = COTPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> COTPoint<'a> {
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_HAE: flatbuffers::VOffsetT = 8;
  pub const VT_CE: flatbuffers::VOffsetT = 10;
  pub const VT_LE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    COTPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args COTPointArgs
  ) -> flatbuffers::WIPOffset<COTPoint<'bldr>> {
    let mut builder = COTPointBuilder::new(_fbb);
    builder.add_LE(args.LE);
    builder.add_CE(args.CE);
    builder.add_HAE(args.HAE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    builder.finish()
  }

  pub fn unpack(&self) -> COTPointT {
    let LATITUDE = self.LATITUDE();
    let LONGITUDE = self.LONGITUDE();
    let HAE = self.HAE();
    let CE = self.CE();
    let LE = self.LE();
    COTPointT {
      LATITUDE,
      LONGITUDE,
      HAE,
      CE,
      LE,
    }
  }

  /// Latitude in decimal degrees (WGS84)
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTPoint::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Longitude in decimal degrees (WGS84)
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTPoint::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Height above WGS84 ellipsoid in meters
  #[inline]
  pub fn HAE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTPoint::VT_HAE, Some(0.0)).unwrap()}
  }
  /// Circular error in meters (95% confidence)
  #[inline]
  pub fn CE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTPoint::VT_CE, Some(0.0)).unwrap()}
  }
  /// Linear error (vertical) in meters (95% confidence)
  #[inline]
  pub fn LE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTPoint::VT_LE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for COTPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("HAE", Self::VT_HAE, false)?
     .visit_field::<f64>("CE", Self::VT_CE, false)?
     .visit_field::<f64>("LE", Self::VT_LE, false)?
     .finish();
    Ok(())
  }
}
pub struct COTPointArgs {
    pub LATITUDE: f64,
    pub LONGITUDE: f64,
    pub HAE: f64,
    pub CE: f64,
    pub LE: f64,
}
impl<'a> Default for COTPointArgs {
  #[inline]
  fn default() -> Self {
    COTPointArgs {
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      HAE: 0.0,
      CE: 0.0,
      LE: 0.0,
    }
  }
}

pub struct COTPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> COTPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(COTPoint::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(COTPoint::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_HAE(&mut self, HAE: f64) {
    self.fbb_.push_slot::<f64>(COTPoint::VT_HAE, HAE, 0.0);
  }
  #[inline]
  pub fn add_CE(&mut self, CE: f64) {
    self.fbb_.push_slot::<f64>(COTPoint::VT_CE, CE, 0.0);
  }
  #[inline]
  pub fn add_LE(&mut self, LE: f64) {
    self.fbb_.push_slot::<f64>(COTPoint::VT_LE, LE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> COTPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    COTPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<COTPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for COTPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("COTPoint");
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("HAE", &self.HAE());
      ds.field("CE", &self.CE());
      ds.field("LE", &self.LE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct COTPointT {
  pub LATITUDE: f64,
  pub LONGITUDE: f64,
  pub HAE: f64,
  pub CE: f64,
  pub LE: f64,
}
impl Default for COTPointT {
  fn default() -> Self {
    Self {
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      HAE: 0.0,
      CE: 0.0,
      LE: 0.0,
    }
  }
}
impl COTPointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<COTPoint<'b>> {
    let LATITUDE = self.LATITUDE;
    let LONGITUDE = self.LONGITUDE;
    let HAE = self.HAE;
    let CE = self.CE;
    let LE = self.LE;
    COTPoint::create(_fbb, &COTPointArgs{
      LATITUDE,
      LONGITUDE,
      HAE,
      CE,
      LE,
    })
  }
}
pub enum COTDetailOffset {}
#[derive(Copy, Clone, PartialEq)]

/// CoT Detail - extensible detail element
pub struct COTDetail<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for COTDetail<'a> {
  type Inner = COTDetail<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> COTDetail<'a> {
  pub const VT_CALLSIGN: flatbuffers::VOffsetT = 4;
  pub const VT_ENDPOINT: flatbuffers::VOffsetT = 6;
  pub const VT_PHONE: flatbuffers::VOffsetT = 8;
  pub const VT_COURSE: flatbuffers::VOffsetT = 10;
  pub const VT_SPEED: flatbuffers::VOffsetT = 12;
  pub const VT_GROUP_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_GROUP_ROLE: flatbuffers::VOffsetT = 16;
  pub const VT_STATUS_BATTERY: flatbuffers::VOffsetT = 18;
  pub const VT_STATUS_READINESS: flatbuffers::VOffsetT = 20;
  pub const VT_PREC_LOCATION_SOURCE: flatbuffers::VOffsetT = 22;
  pub const VT_PREC_ALTSRC: flatbuffers::VOffsetT = 24;
  pub const VT_UID_DROID: flatbuffers::VOffsetT = 26;
  pub const VT_REMARKS: flatbuffers::VOffsetT = 28;
  pub const VT_REMARKS_SOURCE: flatbuffers::VOffsetT = 30;
  pub const VT_REMARKS_TIME: flatbuffers::VOffsetT = 32;
  pub const VT_LINK_UID: flatbuffers::VOffsetT = 34;
  pub const VT_LINK_TYPE: flatbuffers::VOffsetT = 36;
  pub const VT_LINK_RELATION: flatbuffers::VOffsetT = 38;
  pub const VT_COLOR: flatbuffers::VOffsetT = 40;
  pub const VT_STROKE_WEIGHT: flatbuffers::VOffsetT = 42;
  pub const VT_FILL_COLOR: flatbuffers::VOffsetT = 44;
  pub const VT_LABELLED: flatbuffers::VOffsetT = 46;
  pub const VT_ARCHIVE: flatbuffers::VOffsetT = 48;
  pub const VT_RAW_XML: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    COTDetail { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args COTDetailArgs<'args>
  ) -> flatbuffers::WIPOffset<COTDetail<'bldr>> {
    let mut builder = COTDetailBuilder::new(_fbb);
    builder.add_STROKE_WEIGHT(args.STROKE_WEIGHT);
    builder.add_STATUS_BATTERY(args.STATUS_BATTERY);
    builder.add_SPEED(args.SPEED);
    builder.add_COURSE(args.COURSE);
    if let Some(x) = args.RAW_XML { builder.add_RAW_XML(x); }
    builder.add_FILL_COLOR(args.FILL_COLOR);
    builder.add_COLOR(args.COLOR);
    if let Some(x) = args.LINK_RELATION { builder.add_LINK_RELATION(x); }
    if let Some(x) = args.LINK_TYPE { builder.add_LINK_TYPE(x); }
    if let Some(x) = args.LINK_UID { builder.add_LINK_UID(x); }
    if let Some(x) = args.REMARKS_TIME { builder.add_REMARKS_TIME(x); }
    if let Some(x) = args.REMARKS_SOURCE { builder.add_REMARKS_SOURCE(x); }
    if let Some(x) = args.REMARKS { builder.add_REMARKS(x); }
    if let Some(x) = args.UID_DROID { builder.add_UID_DROID(x); }
    if let Some(x) = args.PREC_ALTSRC { builder.add_PREC_ALTSRC(x); }
    if let Some(x) = args.PREC_LOCATION_SOURCE { builder.add_PREC_LOCATION_SOURCE(x); }
    if let Some(x) = args.GROUP_ROLE { builder.add_GROUP_ROLE(x); }
    if let Some(x) = args.GROUP_NAME { builder.add_GROUP_NAME(x); }
    if let Some(x) = args.PHONE { builder.add_PHONE(x); }
    if let Some(x) = args.ENDPOINT { builder.add_ENDPOINT(x); }
    if let Some(x) = args.CALLSIGN { builder.add_CALLSIGN(x); }
    builder.add_ARCHIVE(args.ARCHIVE);
    builder.add_LABELLED(args.LABELLED);
    builder.add_STATUS_READINESS(args.STATUS_READINESS);
    builder.finish()
  }

  pub fn unpack(&self) -> COTDetailT {
    let CALLSIGN = self.CALLSIGN().map(|x| {
      x.to_string()
    });
    let ENDPOINT = self.ENDPOINT().map(|x| {
      x.to_string()
    });
    let PHONE = self.PHONE().map(|x| {
      x.to_string()
    });
    let COURSE = self.COURSE();
    let SPEED = self.SPEED();
    let GROUP_NAME = self.GROUP_NAME().map(|x| {
      x.to_string()
    });
    let GROUP_ROLE = self.GROUP_ROLE().map(|x| {
      x.to_string()
    });
    let STATUS_BATTERY = self.STATUS_BATTERY();
    let STATUS_READINESS = self.STATUS_READINESS();
    let PREC_LOCATION_SOURCE = self.PREC_LOCATION_SOURCE().map(|x| {
      x.to_string()
    });
    let PREC_ALTSRC = self.PREC_ALTSRC().map(|x| {
      x.to_string()
    });
    let UID_DROID = self.UID_DROID().map(|x| {
      x.to_string()
    });
    let REMARKS = self.REMARKS().map(|x| {
      x.to_string()
    });
    let REMARKS_SOURCE = self.REMARKS_SOURCE().map(|x| {
      x.to_string()
    });
    let REMARKS_TIME = self.REMARKS_TIME().map(|x| {
      x.to_string()
    });
    let LINK_UID = self.LINK_UID().map(|x| {
      x.to_string()
    });
    let LINK_TYPE = self.LINK_TYPE().map(|x| {
      x.to_string()
    });
    let LINK_RELATION = self.LINK_RELATION().map(|x| {
      x.to_string()
    });
    let COLOR = self.COLOR();
    let STROKE_WEIGHT = self.STROKE_WEIGHT();
    let FILL_COLOR = self.FILL_COLOR();
    let LABELLED = self.LABELLED();
    let ARCHIVE = self.ARCHIVE();
    let RAW_XML = self.RAW_XML().map(|x| {
      x.to_string()
    });
    COTDetailT {
      CALLSIGN,
      ENDPOINT,
      PHONE,
      COURSE,
      SPEED,
      GROUP_NAME,
      GROUP_ROLE,
      STATUS_BATTERY,
      STATUS_READINESS,
      PREC_LOCATION_SOURCE,
      PREC_ALTSRC,
      UID_DROID,
      REMARKS,
      REMARKS_SOURCE,
      REMARKS_TIME,
      LINK_UID,
      LINK_TYPE,
      LINK_RELATION,
      COLOR,
      STROKE_WEIGHT,
      FILL_COLOR,
      LABELLED,
      ARCHIVE,
      RAW_XML,
    }
  }

  /// Contact callsign
  #[inline]
  pub fn CALLSIGN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_CALLSIGN, None)}
  }
  /// Contact endpoint (e.g. IP:port)
  #[inline]
  pub fn ENDPOINT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_ENDPOINT, None)}
  }
  /// Contact phone number
  #[inline]
  pub fn PHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_PHONE, None)}
  }
  /// Track course in degrees true
  #[inline]
  pub fn COURSE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTDetail::VT_COURSE, Some(0.0)).unwrap()}
  }
  /// Track speed in m/s
  #[inline]
  pub fn SPEED(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTDetail::VT_SPEED, Some(0.0)).unwrap()}
  }
  /// Group name/team
  #[inline]
  pub fn GROUP_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_GROUP_NAME, None)}
  }
  /// Group role
  #[inline]
  pub fn GROUP_ROLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_GROUP_ROLE, None)}
  }
  /// Status (battery percentage, etc.)
  #[inline]
  pub fn STATUS_BATTERY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTDetail::VT_STATUS_BATTERY, Some(0.0)).unwrap()}
  }
  /// Status readiness
  #[inline]
  pub fn STATUS_READINESS(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(COTDetail::VT_STATUS_READINESS, Some(false)).unwrap()}
  }
  /// Precision location source
  #[inline]
  pub fn PREC_LOCATION_SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_PREC_LOCATION_SOURCE, None)}
  }
  /// Precision location altitude source
  #[inline]
  pub fn PREC_ALTSRC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_PREC_ALTSRC, None)}
  }
  /// UID of the device
  #[inline]
  pub fn UID_DROID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_UID_DROID, None)}
  }
  /// Remarks text
  #[inline]
  pub fn REMARKS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_REMARKS, None)}
  }
  /// Remarks source
  #[inline]
  pub fn REMARKS_SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_REMARKS_SOURCE, None)}
  }
  /// Remarks timestamp (ISO 8601)
  #[inline]
  pub fn REMARKS_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_REMARKS_TIME, None)}
  }
  /// Link UID (for related events)
  #[inline]
  pub fn LINK_UID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_LINK_UID, None)}
  }
  /// Link type
  #[inline]
  pub fn LINK_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_LINK_TYPE, None)}
  }
  /// Link relation
  #[inline]
  pub fn LINK_RELATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_LINK_RELATION, None)}
  }
  /// Color in ARGB integer format
  #[inline]
  pub fn COLOR(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(COTDetail::VT_COLOR, Some(0)).unwrap()}
  }
  /// Stroke weight for drawing
  #[inline]
  pub fn STROKE_WEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COTDetail::VT_STROKE_WEIGHT, Some(0.0)).unwrap()}
  }
  /// Fill color in ARGB integer format
  #[inline]
  pub fn FILL_COLOR(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(COTDetail::VT_FILL_COLOR, Some(0)).unwrap()}
  }
  /// Labeled flag
  #[inline]
  pub fn LABELLED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(COTDetail::VT_LABELLED, Some(false)).unwrap()}
  }
  /// Archive flag
  #[inline]
  pub fn ARCHIVE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(COTDetail::VT_ARCHIVE, Some(false)).unwrap()}
  }
  /// Raw XML detail content (for extensions not covered above)
  #[inline]
  pub fn RAW_XML(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COTDetail::VT_RAW_XML, None)}
  }
}

impl flatbuffers::Verifiable for COTDetail<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CALLSIGN", Self::VT_CALLSIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENDPOINT", Self::VT_ENDPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PHONE", Self::VT_PHONE, false)?
     .visit_field::<f64>("COURSE", Self::VT_COURSE, false)?
     .visit_field::<f64>("SPEED", Self::VT_SPEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GROUP_NAME", Self::VT_GROUP_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GROUP_ROLE", Self::VT_GROUP_ROLE, false)?
     .visit_field::<f64>("STATUS_BATTERY", Self::VT_STATUS_BATTERY, false)?
     .visit_field::<bool>("STATUS_READINESS", Self::VT_STATUS_READINESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PREC_LOCATION_SOURCE", Self::VT_PREC_LOCATION_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PREC_ALTSRC", Self::VT_PREC_ALTSRC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("UID_DROID", Self::VT_UID_DROID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REMARKS", Self::VT_REMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REMARKS_SOURCE", Self::VT_REMARKS_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REMARKS_TIME", Self::VT_REMARKS_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LINK_UID", Self::VT_LINK_UID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LINK_TYPE", Self::VT_LINK_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LINK_RELATION", Self::VT_LINK_RELATION, false)?
     .visit_field::<i32>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<f64>("STROKE_WEIGHT", Self::VT_STROKE_WEIGHT, false)?
     .visit_field::<i32>("FILL_COLOR", Self::VT_FILL_COLOR, false)?
     .visit_field::<bool>("LABELLED", Self::VT_LABELLED, false)?
     .visit_field::<bool>("ARCHIVE", Self::VT_ARCHIVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RAW_XML", Self::VT_RAW_XML, false)?
     .finish();
    Ok(())
  }
}
pub struct COTDetailArgs<'a> {
    pub CALLSIGN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENDPOINT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COURSE: f64,
    pub SPEED: f64,
    pub GROUP_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GROUP_ROLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STATUS_BATTERY: f64,
    pub STATUS_READINESS: bool,
    pub PREC_LOCATION_SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PREC_ALTSRC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UID_DROID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REMARKS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REMARKS_SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REMARKS_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINK_UID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINK_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINK_RELATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR: i32,
    pub STROKE_WEIGHT: f64,
    pub FILL_COLOR: i32,
    pub LABELLED: bool,
    pub ARCHIVE: bool,
    pub RAW_XML: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for COTDetailArgs<'a> {
  #[inline]
  fn default() -> Self {
    COTDetailArgs {
      CALLSIGN: None,
      ENDPOINT: None,
      PHONE: None,
      COURSE: 0.0,
      SPEED: 0.0,
      GROUP_NAME: None,
      GROUP_ROLE: None,
      STATUS_BATTERY: 0.0,
      STATUS_READINESS: false,
      PREC_LOCATION_SOURCE: None,
      PREC_ALTSRC: None,
      UID_DROID: None,
      REMARKS: None,
      REMARKS_SOURCE: None,
      REMARKS_TIME: None,
      LINK_UID: None,
      LINK_TYPE: None,
      LINK_RELATION: None,
      COLOR: 0,
      STROKE_WEIGHT: 0.0,
      FILL_COLOR: 0,
      LABELLED: false,
      ARCHIVE: false,
      RAW_XML: None,
    }
  }
}

pub struct COTDetailBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> COTDetailBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CALLSIGN(&mut self, CALLSIGN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_CALLSIGN, CALLSIGN);
  }
  #[inline]
  pub fn add_ENDPOINT(&mut self, ENDPOINT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_ENDPOINT, ENDPOINT);
  }
  #[inline]
  pub fn add_PHONE(&mut self, PHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_PHONE, PHONE);
  }
  #[inline]
  pub fn add_COURSE(&mut self, COURSE: f64) {
    self.fbb_.push_slot::<f64>(COTDetail::VT_COURSE, COURSE, 0.0);
  }
  #[inline]
  pub fn add_SPEED(&mut self, SPEED: f64) {
    self.fbb_.push_slot::<f64>(COTDetail::VT_SPEED, SPEED, 0.0);
  }
  #[inline]
  pub fn add_GROUP_NAME(&mut self, GROUP_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_GROUP_NAME, GROUP_NAME);
  }
  #[inline]
  pub fn add_GROUP_ROLE(&mut self, GROUP_ROLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_GROUP_ROLE, GROUP_ROLE);
  }
  #[inline]
  pub fn add_STATUS_BATTERY(&mut self, STATUS_BATTERY: f64) {
    self.fbb_.push_slot::<f64>(COTDetail::VT_STATUS_BATTERY, STATUS_BATTERY, 0.0);
  }
  #[inline]
  pub fn add_STATUS_READINESS(&mut self, STATUS_READINESS: bool) {
    self.fbb_.push_slot::<bool>(COTDetail::VT_STATUS_READINESS, STATUS_READINESS, false);
  }
  #[inline]
  pub fn add_PREC_LOCATION_SOURCE(&mut self, PREC_LOCATION_SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_PREC_LOCATION_SOURCE, PREC_LOCATION_SOURCE);
  }
  #[inline]
  pub fn add_PREC_ALTSRC(&mut self, PREC_ALTSRC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_PREC_ALTSRC, PREC_ALTSRC);
  }
  #[inline]
  pub fn add_UID_DROID(&mut self, UID_DROID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_UID_DROID, UID_DROID);
  }
  #[inline]
  pub fn add_REMARKS(&mut self, REMARKS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_REMARKS, REMARKS);
  }
  #[inline]
  pub fn add_REMARKS_SOURCE(&mut self, REMARKS_SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_REMARKS_SOURCE, REMARKS_SOURCE);
  }
  #[inline]
  pub fn add_REMARKS_TIME(&mut self, REMARKS_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_REMARKS_TIME, REMARKS_TIME);
  }
  #[inline]
  pub fn add_LINK_UID(&mut self, LINK_UID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_LINK_UID, LINK_UID);
  }
  #[inline]
  pub fn add_LINK_TYPE(&mut self, LINK_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_LINK_TYPE, LINK_TYPE);
  }
  #[inline]
  pub fn add_LINK_RELATION(&mut self, LINK_RELATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_LINK_RELATION, LINK_RELATION);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: i32) {
    self.fbb_.push_slot::<i32>(COTDetail::VT_COLOR, COLOR, 0);
  }
  #[inline]
  pub fn add_STROKE_WEIGHT(&mut self, STROKE_WEIGHT: f64) {
    self.fbb_.push_slot::<f64>(COTDetail::VT_STROKE_WEIGHT, STROKE_WEIGHT, 0.0);
  }
  #[inline]
  pub fn add_FILL_COLOR(&mut self, FILL_COLOR: i32) {
    self.fbb_.push_slot::<i32>(COTDetail::VT_FILL_COLOR, FILL_COLOR, 0);
  }
  #[inline]
  pub fn add_LABELLED(&mut self, LABELLED: bool) {
    self.fbb_.push_slot::<bool>(COTDetail::VT_LABELLED, LABELLED, false);
  }
  #[inline]
  pub fn add_ARCHIVE(&mut self, ARCHIVE: bool) {
    self.fbb_.push_slot::<bool>(COTDetail::VT_ARCHIVE, ARCHIVE, false);
  }
  #[inline]
  pub fn add_RAW_XML(&mut self, RAW_XML: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COTDetail::VT_RAW_XML, RAW_XML);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> COTDetailBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    COTDetailBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<COTDetail<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for COTDetail<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("COTDetail");
      ds.field("CALLSIGN", &self.CALLSIGN());
      ds.field("ENDPOINT", &self.ENDPOINT());
      ds.field("PHONE", &self.PHONE());
      ds.field("COURSE", &self.COURSE());
      ds.field("SPEED", &self.SPEED());
      ds.field("GROUP_NAME", &self.GROUP_NAME());
      ds.field("GROUP_ROLE", &self.GROUP_ROLE());
      ds.field("STATUS_BATTERY", &self.STATUS_BATTERY());
      ds.field("STATUS_READINESS", &self.STATUS_READINESS());
      ds.field("PREC_LOCATION_SOURCE", &self.PREC_LOCATION_SOURCE());
      ds.field("PREC_ALTSRC", &self.PREC_ALTSRC());
      ds.field("UID_DROID", &self.UID_DROID());
      ds.field("REMARKS", &self.REMARKS());
      ds.field("REMARKS_SOURCE", &self.REMARKS_SOURCE());
      ds.field("REMARKS_TIME", &self.REMARKS_TIME());
      ds.field("LINK_UID", &self.LINK_UID());
      ds.field("LINK_TYPE", &self.LINK_TYPE());
      ds.field("LINK_RELATION", &self.LINK_RELATION());
      ds.field("COLOR", &self.COLOR());
      ds.field("STROKE_WEIGHT", &self.STROKE_WEIGHT());
      ds.field("FILL_COLOR", &self.FILL_COLOR());
      ds.field("LABELLED", &self.LABELLED());
      ds.field("ARCHIVE", &self.ARCHIVE());
      ds.field("RAW_XML", &self.RAW_XML());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct COTDetailT {
  pub CALLSIGN: Option<String>,
  pub ENDPOINT: Option<String>,
  pub PHONE: Option<String>,
  pub COURSE: f64,
  pub SPEED: f64,
  pub GROUP_NAME: Option<String>,
  pub GROUP_ROLE: Option<String>,
  pub STATUS_BATTERY: f64,
  pub STATUS_READINESS: bool,
  pub PREC_LOCATION_SOURCE: Option<String>,
  pub PREC_ALTSRC: Option<String>,
  pub UID_DROID: Option<String>,
  pub REMARKS: Option<String>,
  pub REMARKS_SOURCE: Option<String>,
  pub REMARKS_TIME: Option<String>,
  pub LINK_UID: Option<String>,
  pub LINK_TYPE: Option<String>,
  pub LINK_RELATION: Option<String>,
  pub COLOR: i32,
  pub STROKE_WEIGHT: f64,
  pub FILL_COLOR: i32,
  pub LABELLED: bool,
  pub ARCHIVE: bool,
  pub RAW_XML: Option<String>,
}
impl Default for COTDetailT {
  fn default() -> Self {
    Self {
      CALLSIGN: None,
      ENDPOINT: None,
      PHONE: None,
      COURSE: 0.0,
      SPEED: 0.0,
      GROUP_NAME: None,
      GROUP_ROLE: None,
      STATUS_BATTERY: 0.0,
      STATUS_READINESS: false,
      PREC_LOCATION_SOURCE: None,
      PREC_ALTSRC: None,
      UID_DROID: None,
      REMARKS: None,
      REMARKS_SOURCE: None,
      REMARKS_TIME: None,
      LINK_UID: None,
      LINK_TYPE: None,
      LINK_RELATION: None,
      COLOR: 0,
      STROKE_WEIGHT: 0.0,
      FILL_COLOR: 0,
      LABELLED: false,
      ARCHIVE: false,
      RAW_XML: None,
    }
  }
}
impl COTDetailT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<COTDetail<'b>> {
    let CALLSIGN = self.CALLSIGN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENDPOINT = self.ENDPOINT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PHONE = self.PHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COURSE = self.COURSE;
    let SPEED = self.SPEED;
    let GROUP_NAME = self.GROUP_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GROUP_ROLE = self.GROUP_ROLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STATUS_BATTERY = self.STATUS_BATTERY;
    let STATUS_READINESS = self.STATUS_READINESS;
    let PREC_LOCATION_SOURCE = self.PREC_LOCATION_SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PREC_ALTSRC = self.PREC_ALTSRC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UID_DROID = self.UID_DROID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REMARKS = self.REMARKS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REMARKS_SOURCE = self.REMARKS_SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REMARKS_TIME = self.REMARKS_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINK_UID = self.LINK_UID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINK_TYPE = self.LINK_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINK_RELATION = self.LINK_RELATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR = self.COLOR;
    let STROKE_WEIGHT = self.STROKE_WEIGHT;
    let FILL_COLOR = self.FILL_COLOR;
    let LABELLED = self.LABELLED;
    let ARCHIVE = self.ARCHIVE;
    let RAW_XML = self.RAW_XML.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    COTDetail::create(_fbb, &COTDetailArgs{
      CALLSIGN,
      ENDPOINT,
      PHONE,
      COURSE,
      SPEED,
      GROUP_NAME,
      GROUP_ROLE,
      STATUS_BATTERY,
      STATUS_READINESS,
      PREC_LOCATION_SOURCE,
      PREC_ALTSRC,
      UID_DROID,
      REMARKS,
      REMARKS_SOURCE,
      REMARKS_TIME,
      LINK_UID,
      LINK_TYPE,
      LINK_RELATION,
      COLOR,
      STROKE_WEIGHT,
      FILL_COLOR,
      LABELLED,
      ARCHIVE,
      RAW_XML,
    })
  }
}
pub enum COTOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Cursor on Target Event
pub struct COT<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for COT<'a> {
  type Inner = COT<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> COT<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_UID: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_HOW: flatbuffers::VOffsetT = 10;
  pub const VT_TIME: flatbuffers::VOffsetT = 12;
  pub const VT_START: flatbuffers::VOffsetT = 14;
  pub const VT_STALE: flatbuffers::VOffsetT = 16;
  pub const VT_ACCESS: flatbuffers::VOffsetT = 18;
  pub const VT_QOS: flatbuffers::VOffsetT = 20;
  pub const VT_OPEX: flatbuffers::VOffsetT = 22;
  pub const VT_POINT: flatbuffers::VOffsetT = 24;
  pub const VT_DETAIL: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    COT { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args COTArgs<'args>
  ) -> flatbuffers::WIPOffset<COT<'bldr>> {
    let mut builder = COTBuilder::new(_fbb);
    if let Some(x) = args.DETAIL { builder.add_DETAIL(x); }
    if let Some(x) = args.POINT { builder.add_POINT(x); }
    if let Some(x) = args.OPEX { builder.add_OPEX(x); }
    if let Some(x) = args.QOS { builder.add_QOS(x); }
    if let Some(x) = args.ACCESS { builder.add_ACCESS(x); }
    if let Some(x) = args.STALE { builder.add_STALE(x); }
    if let Some(x) = args.START { builder.add_START(x); }
    if let Some(x) = args.TIME { builder.add_TIME(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.UID { builder.add_UID(x); }
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    builder.add_HOW(args.HOW);
    builder.finish()
  }

  pub fn unpack(&self) -> COTT {
    let VERSION = self.VERSION().map(|x| {
      x.to_string()
    });
    let UID = self.UID().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let HOW = self.HOW();
    let TIME = self.TIME().map(|x| {
      x.to_string()
    });
    let START = self.START().map(|x| {
      x.to_string()
    });
    let STALE = self.STALE().map(|x| {
      x.to_string()
    });
    let ACCESS = self.ACCESS().map(|x| {
      x.to_string()
    });
    let QOS = self.QOS().map(|x| {
      x.to_string()
    });
    let OPEX = self.OPEX().map(|x| {
      x.to_string()
    });
    let POINT = self.POINT().map(|x| {
      Box::new(x.unpack())
    });
    let DETAIL = self.DETAIL().map(|x| {
      Box::new(x.unpack())
    });
    COTT {
      VERSION,
      UID,
      TYPE,
      HOW,
      TIME,
      START,
      STALE,
      ACCESS,
      QOS,
      OPEX,
      POINT,
      DETAIL,
    }
  }

  /// Schema version
  #[inline]
  pub fn VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_VERSION, None)}
  }
  /// Globally unique event identifier
  #[inline]
  pub fn UID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_UID, None)}
  }
  /// CoT event type (dot-delimited MIL-STD-2525/APP-6 hierarchy)
  /// e.g. "a-f-G-U-C" = atom, friend, Ground, Unit, Combat
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_TYPE, None)}
  }
  /// How the event was generated (e.g. "m-g" = machine GPS)
  #[inline]
  pub fn HOW(&self) -> COTHowType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<COTHowType>(COT::VT_HOW, Some(COTHowType::HE)).unwrap()}
  }
  /// Time the event was generated (ISO 8601)
  #[inline]
  pub fn TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_TIME, None)}
  }
  /// Time the event information was valid (ISO 8601)
  #[inline]
  pub fn START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_START, None)}
  }
  /// Time the event information is no longer valid (ISO 8601)
  #[inline]
  pub fn STALE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_STALE, None)}
  }
  /// Access control marking
  #[inline]
  pub fn ACCESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_ACCESS, None)}
  }
  /// Quality of service
  #[inline]
  pub fn QOS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_QOS, None)}
  }
  /// Operational status
  #[inline]
  pub fn OPEX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(COT::VT_OPEX, None)}
  }
  /// Point location
  #[inline]
  pub fn POINT(&self) -> Option<COTPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<COTPoint>>(COT::VT_POINT, None)}
  }
  /// Detailed event information
  #[inline]
  pub fn DETAIL(&self) -> Option<COTDetail<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<COTDetail>>(COT::VT_DETAIL, None)}
  }
}

impl flatbuffers::Verifiable for COT<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("UID", Self::VT_UID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<COTHowType>("HOW", Self::VT_HOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STALE", Self::VT_STALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ACCESS", Self::VT_ACCESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("QOS", Self::VT_QOS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPEX", Self::VT_OPEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<COTPoint>>("POINT", Self::VT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<COTDetail>>("DETAIL", Self::VT_DETAIL, false)?
     .finish();
    Ok(())
  }
}
pub struct COTArgs<'a> {
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HOW: COTHowType,
    pub TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STALE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ACCESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub QOS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPEX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POINT: Option<flatbuffers::WIPOffset<COTPoint<'a>>>,
    pub DETAIL: Option<flatbuffers::WIPOffset<COTDetail<'a>>>,
}
impl<'a> Default for COTArgs<'a> {
  #[inline]
  fn default() -> Self {
    COTArgs {
      VERSION: None,
      UID: None,
      TYPE: None,
      HOW: COTHowType::HE,
      TIME: None,
      START: None,
      STALE: None,
      ACCESS: None,
      QOS: None,
      OPEX: None,
      POINT: None,
      DETAIL: None,
    }
  }
}

pub struct COTBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> COTBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_UID(&mut self, UID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_UID, UID);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_HOW(&mut self, HOW: COTHowType) {
    self.fbb_.push_slot::<COTHowType>(COT::VT_HOW, HOW, COTHowType::HE);
  }
  #[inline]
  pub fn add_TIME(&mut self, TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_TIME, TIME);
  }
  #[inline]
  pub fn add_START(&mut self, START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_START, START);
  }
  #[inline]
  pub fn add_STALE(&mut self, STALE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_STALE, STALE);
  }
  #[inline]
  pub fn add_ACCESS(&mut self, ACCESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_ACCESS, ACCESS);
  }
  #[inline]
  pub fn add_QOS(&mut self, QOS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_QOS, QOS);
  }
  #[inline]
  pub fn add_OPEX(&mut self, OPEX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COT::VT_OPEX, OPEX);
  }
  #[inline]
  pub fn add_POINT(&mut self, POINT: flatbuffers::WIPOffset<COTPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<COTPoint>>(COT::VT_POINT, POINT);
  }
  #[inline]
  pub fn add_DETAIL(&mut self, DETAIL: flatbuffers::WIPOffset<COTDetail<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<COTDetail>>(COT::VT_DETAIL, DETAIL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> COTBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    COTBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<COT<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for COT<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("COT");
      ds.field("VERSION", &self.VERSION());
      ds.field("UID", &self.UID());
      ds.field("TYPE", &self.TYPE());
      ds.field("HOW", &self.HOW());
      ds.field("TIME", &self.TIME());
      ds.field("START", &self.START());
      ds.field("STALE", &self.STALE());
      ds.field("ACCESS", &self.ACCESS());
      ds.field("QOS", &self.QOS());
      ds.field("OPEX", &self.OPEX());
      ds.field("POINT", &self.POINT());
      ds.field("DETAIL", &self.DETAIL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct COTT {
  pub VERSION: Option<String>,
  pub UID: Option<String>,
  pub TYPE: Option<String>,
  pub HOW: COTHowType,
  pub TIME: Option<String>,
  pub START: Option<String>,
  pub STALE: Option<String>,
  pub ACCESS: Option<String>,
  pub QOS: Option<String>,
  pub OPEX: Option<String>,
  pub POINT: Option<Box<COTPointT>>,
  pub DETAIL: Option<Box<COTDetailT>>,
}
impl Default for COTT {
  fn default() -> Self {
    Self {
      VERSION: None,
      UID: None,
      TYPE: None,
      HOW: COTHowType::HE,
      TIME: None,
      START: None,
      STALE: None,
      ACCESS: None,
      QOS: None,
      OPEX: None,
      POINT: None,
      DETAIL: None,
    }
  }
}
impl COTT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<COT<'b>> {
    let VERSION = self.VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UID = self.UID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HOW = self.HOW;
    let TIME = self.TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let START = self.START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STALE = self.STALE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ACCESS = self.ACCESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let QOS = self.QOS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPEX = self.OPEX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POINT = self.POINT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DETAIL = self.DETAIL.as_ref().map(|x|{
      x.pack(_fbb)
    });
    COT::create(_fbb, &COTArgs{
      VERSION,
      UID,
      TYPE,
      HOW,
      TIME,
      START,
      STALE,
      ACCESS,
      QOS,
      OPEX,
      POINT,
      DETAIL,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `COT`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COT_unchecked`.
pub fn root_as_COT(buf: &[u8]) -> Result<COT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<COT>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `COT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_COT_unchecked`.
pub fn size_prefixed_root_as_COT(buf: &[u8]) -> Result<COT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<COT>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `COT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COT_unchecked`.
pub fn root_as_COT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<COT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<COT<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `COT` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COT_unchecked`.
pub fn size_prefixed_root_as_COT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<COT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<COT<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a COT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `COT`.
pub unsafe fn root_as_COT_unchecked(buf: &[u8]) -> COT {
  flatbuffers::root_unchecked::<COT>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed COT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `COT`.
pub unsafe fn size_prefixed_root_as_COT_unchecked(buf: &[u8]) -> COT {
  flatbuffers::size_prefixed_root_unchecked::<COT>(buf)
}
pub const COT_IDENTIFIER: &str = "$COT";

#[inline]
pub fn COT_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COT_IDENTIFIER, false)
}

#[inline]
pub fn COT_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COT_IDENTIFIER, true)
}

#[inline]
pub fn finish_COT_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<COT<'a>>) {
  fbb.finish(root, Some(COT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_COT_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<COT<'a>>) {
  fbb.finish_size_prefixed(root, Some(COT_IDENTIFIER));
}
