// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REFERENCE_FRAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REFERENCE_FRAME: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REFERENCE_FRAME: [referenceFrame; 11] = [
  referenceFrame::EME2000,
  referenceFrame::GCRF,
  referenceFrame::GRC,
  referenceFrame::ICRF,
  referenceFrame::ITRF2000,
  referenceFrame::ITRF93,
  referenceFrame::ITRF97,
  referenceFrame::MCI,
  referenceFrame::TDR,
  referenceFrame::TEME,
  referenceFrame::TOD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct referenceFrame(pub i8);
#[allow(non_upper_case_globals)]
impl referenceFrame {
  /// Earth Mean Equator and Equinox of J2000
  pub const EME2000: Self = Self(0);
  /// Geocentric Celestial Reference Frame
  pub const GCRF: Self = Self(1);
  /// Greenwich Rotating Coordinates
  pub const GRC: Self = Self(2);
  /// International Celestial Reference Frame
  pub const ICRF: Self = Self(3);
  /// International Terrestrial Reference Frame 2000
  pub const ITRF2000: Self = Self(4);
  /// International Terrestrial Reference Frame 1993
  pub const ITRF93: Self = Self(5);
  /// International Terrestrial Reference Frame 1997
  pub const ITRF97: Self = Self(6);
  /// Mars Centered Inertial
  pub const MCI: Self = Self(7);
  /// True of Date, Rotating
  pub const TDR: Self = Self(8);
  /// True Equator Mean Equinox
  pub const TEME: Self = Self(9);
  /// True of Date
  pub const TOD: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EME2000,
    Self::GCRF,
    Self::GRC,
    Self::ICRF,
    Self::ITRF2000,
    Self::ITRF93,
    Self::ITRF97,
    Self::MCI,
    Self::TDR,
    Self::TEME,
    Self::TOD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EME2000 => Some("EME2000"),
      Self::GCRF => Some("GCRF"),
      Self::GRC => Some("GRC"),
      Self::ICRF => Some("ICRF"),
      Self::ITRF2000 => Some("ITRF2000"),
      Self::ITRF93 => Some("ITRF93"),
      Self::ITRF97 => Some("ITRF97"),
      Self::MCI => Some("MCI"),
      Self::TDR => Some("TDR"),
      Self::TEME => Some("TEME"),
      Self::TOD => Some("TOD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for referenceFrame {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for referenceFrame {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for referenceFrame {
    type Output = referenceFrame;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for referenceFrame {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for referenceFrame {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for referenceFrame {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TIME_SYSTEM: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TIME_SYSTEM: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TIME_SYSTEM: [timeSystem; 12] = [
  timeSystem::GMST,
  timeSystem::GPS,
  timeSystem::MET,
  timeSystem::MRT,
  timeSystem::SCLK,
  timeSystem::TAI,
  timeSystem::TCB,
  timeSystem::TDB,
  timeSystem::TCG,
  timeSystem::TT,
  timeSystem::UT1,
  timeSystem::UTC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct timeSystem(pub i8);
#[allow(non_upper_case_globals)]
impl timeSystem {
  /// Greenwich Mean Sidereal Time
  pub const GMST: Self = Self(0);
  /// Global Positioning System
  pub const GPS: Self = Self(1);
  /// Mission Elapsed Time
  pub const MET: Self = Self(2);
  /// Mission Relative Time
  pub const MRT: Self = Self(3);
  /// Spacecraft Clock (receiver) (requires rules for interpretation in ICD)
  pub const SCLK: Self = Self(4);
  /// International Atomic Time
  pub const TAI: Self = Self(5);
  /// Barycentric Coordinate Time
  pub const TCB: Self = Self(6);
  /// Barycentric Dynamical Time
  pub const TDB: Self = Self(7);
  /// Geocentric Coordinate Time
  pub const TCG: Self = Self(8);
  /// Terrestrial Time
  pub const TT: Self = Self(9);
  /// Universal Time
  pub const UT1: Self = Self(10);
  /// Coordinated Universal Time
  pub const UTC: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GMST,
    Self::GPS,
    Self::MET,
    Self::MRT,
    Self::SCLK,
    Self::TAI,
    Self::TCB,
    Self::TDB,
    Self::TCG,
    Self::TT,
    Self::UT1,
    Self::UTC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GMST => Some("GMST"),
      Self::GPS => Some("GPS"),
      Self::MET => Some("MET"),
      Self::MRT => Some("MRT"),
      Self::SCLK => Some("SCLK"),
      Self::TAI => Some("TAI"),
      Self::TCB => Some("TCB"),
      Self::TDB => Some("TDB"),
      Self::TCG => Some("TCG"),
      Self::TT => Some("TT"),
      Self::UT1 => Some("UT1"),
      Self::UTC => Some("UTC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for timeSystem {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for timeSystem {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for timeSystem {
    type Output = timeSystem;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for timeSystem {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for timeSystem {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for timeSystem {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MAN_COV_REF_FRAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MAN_COV_REF_FRAME: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MAN_COV_REF_FRAME: [manCovRefFrame; 3] = [
  manCovRefFrame::RSW,
  manCovRefFrame::RTN,
  manCovRefFrame::TNW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct manCovRefFrame(pub i8);
#[allow(non_upper_case_globals)]
impl manCovRefFrame {
  /// Another name for 'Radial, Transverse, Normal'
  pub const RSW: Self = Self(0);
  /// Radial, Transverse, Normal
  pub const RTN: Self = Self(1);
  /// A local orbital coordinate frame
  pub const TNW: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RSW,
    Self::RTN,
    Self::TNW,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RSW => Some("RSW"),
      Self::RTN => Some("RTN"),
      Self::TNW => Some("TNW"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for manCovRefFrame {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for manCovRefFrame {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for manCovRefFrame {
    type Output = manCovRefFrame;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for manCovRefFrame {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for manCovRefFrame {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for manCovRefFrame {}
pub enum ephemerisDataLineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single ephemeris data line
pub struct ephemerisDataLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ephemerisDataLine<'a> {
  type Inner = ephemerisDataLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ephemerisDataLine<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_X: flatbuffers::VOffsetT = 6;
  pub const VT_Y: flatbuffers::VOffsetT = 8;
  pub const VT_Z: flatbuffers::VOffsetT = 10;
  pub const VT_X_DOT: flatbuffers::VOffsetT = 12;
  pub const VT_Y_DOT: flatbuffers::VOffsetT = 14;
  pub const VT_Z_DOT: flatbuffers::VOffsetT = 16;
  pub const VT_X_DDOT: flatbuffers::VOffsetT = 18;
  pub const VT_Y_DDOT: flatbuffers::VOffsetT = 20;
  pub const VT_Z_DDOT: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ephemerisDataLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ephemerisDataLineArgs<'args>
  ) -> flatbuffers::WIPOffset<ephemerisDataLine<'bldr>> {
    let mut builder = ephemerisDataLineBuilder::new(_fbb);
    builder.add_Z_DDOT(args.Z_DDOT);
    builder.add_Y_DDOT(args.Y_DDOT);
    builder.add_X_DDOT(args.X_DDOT);
    builder.add_Z_DOT(args.Z_DOT);
    builder.add_Y_DOT(args.Y_DOT);
    builder.add_X_DOT(args.X_DOT);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ephemerisDataLineT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let X_DOT = self.X_DOT();
    let Y_DOT = self.Y_DOT();
    let Z_DOT = self.Z_DOT();
    let X_DDOT = self.X_DDOT();
    let Y_DDOT = self.Y_DDOT();
    let Z_DDOT = self.Z_DDOT();
    ephemerisDataLineT {
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT,
    }
  }

  /// Epoch of state vector (ISO 8601)
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataLine::VT_EPOCH, None)}
  }
  /// Position vector X-component km
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X, Some(0.0)).unwrap()}
  }
  /// Position vector Y-component km
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y, Some(0.0)).unwrap()}
  }
  /// Position vector Z-component km
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z, Some(0.0)).unwrap()}
  }
  /// Velocity vector X-component km/s
  #[inline]
  pub fn X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Velocity vector Y-component km/s
  #[inline]
  pub fn Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Velocity vector Z-component km/s
  #[inline]
  pub fn Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z_DOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector X-component km/s/s
  #[inline]
  pub fn X_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X_DDOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector Y-component km/s/s
  #[inline]
  pub fn Y_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y_DDOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector Z-component km/s/s
  #[inline]
  pub fn Z_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z_DDOT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ephemerisDataLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("X_DOT", Self::VT_X_DOT, false)?
     .visit_field::<f64>("Y_DOT", Self::VT_Y_DOT, false)?
     .visit_field::<f64>("Z_DOT", Self::VT_Z_DOT, false)?
     .visit_field::<f64>("X_DDOT", Self::VT_X_DDOT, false)?
     .visit_field::<f64>("Y_DDOT", Self::VT_Y_DDOT, false)?
     .visit_field::<f64>("Z_DDOT", Self::VT_Z_DDOT, false)?
     .finish();
    Ok(())
  }
}
pub struct ephemerisDataLineArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub X_DOT: f64,
    pub Y_DOT: f64,
    pub Z_DOT: f64,
    pub X_DDOT: f64,
    pub Y_DDOT: f64,
    pub Z_DDOT: f64,
}
impl<'a> Default for ephemerisDataLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    ephemerisDataLineArgs {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      X_DDOT: 0.0,
      Y_DDOT: 0.0,
      Z_DDOT: 0.0,
    }
  }
}

pub struct ephemerisDataLineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ephemerisDataLineBuilder<'a, 'b> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataLine::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_X_DOT(&mut self, X_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X_DOT, X_DOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DOT(&mut self, Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y_DOT, Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DOT(&mut self, Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z_DOT, Z_DOT, 0.0);
  }
  #[inline]
  pub fn add_X_DDOT(&mut self, X_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X_DDOT, X_DDOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DDOT(&mut self, Y_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y_DDOT, Y_DDOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DDOT(&mut self, Z_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z_DDOT, Z_DDOT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ephemerisDataLineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ephemerisDataLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ephemerisDataLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ephemerisDataLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ephemerisDataLine");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("X_DOT", &self.X_DOT());
      ds.field("Y_DOT", &self.Y_DOT());
      ds.field("Z_DOT", &self.Z_DOT());
      ds.field("X_DDOT", &self.X_DDOT());
      ds.field("Y_DDOT", &self.Y_DDOT());
      ds.field("Z_DDOT", &self.Z_DDOT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ephemerisDataLineT {
  pub EPOCH: Option<String>,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub X_DOT: f64,
  pub Y_DOT: f64,
  pub Z_DOT: f64,
  pub X_DDOT: f64,
  pub Y_DDOT: f64,
  pub Z_DDOT: f64,
}
impl Default for ephemerisDataLineT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      X_DDOT: 0.0,
      Y_DDOT: 0.0,
      Z_DDOT: 0.0,
    }
  }
}
impl ephemerisDataLineT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ephemerisDataLine<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let X_DOT = self.X_DOT;
    let Y_DOT = self.Y_DOT;
    let Z_DOT = self.Z_DOT;
    let X_DDOT = self.X_DDOT;
    let Y_DDOT = self.Y_DDOT;
    let Z_DDOT = self.Z_DDOT;
    ephemerisDataLine::create(_fbb, &ephemerisDataLineArgs{
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT,
    })
  }
}
pub enum covarianceMatrixLineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Position/Velocity Covariance Matrix Line
pub struct covarianceMatrixLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for covarianceMatrixLine<'a> {
  type Inner = covarianceMatrixLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> covarianceMatrixLine<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_COV_REF_FRAME: flatbuffers::VOffsetT = 6;
  pub const VT_CX_X: flatbuffers::VOffsetT = 8;
  pub const VT_CY_X: flatbuffers::VOffsetT = 10;
  pub const VT_CY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_CZ_X: flatbuffers::VOffsetT = 14;
  pub const VT_CZ_Y: flatbuffers::VOffsetT = 16;
  pub const VT_CZ_Z: flatbuffers::VOffsetT = 18;
  pub const VT_CX_DOT_X: flatbuffers::VOffsetT = 20;
  pub const VT_CX_DOT_Y: flatbuffers::VOffsetT = 22;
  pub const VT_CX_DOT_Z: flatbuffers::VOffsetT = 24;
  pub const VT_CX_DOT_X_DOT: flatbuffers::VOffsetT = 26;
  pub const VT_CY_DOT_X: flatbuffers::VOffsetT = 28;
  pub const VT_CY_DOT_Y: flatbuffers::VOffsetT = 30;
  pub const VT_CY_DOT_Z: flatbuffers::VOffsetT = 32;
  pub const VT_CY_DOT_X_DOT: flatbuffers::VOffsetT = 34;
  pub const VT_CY_DOT_Y_DOT: flatbuffers::VOffsetT = 36;
  pub const VT_CZ_DOT_X: flatbuffers::VOffsetT = 38;
  pub const VT_CZ_DOT_Y: flatbuffers::VOffsetT = 40;
  pub const VT_CZ_DOT_Z: flatbuffers::VOffsetT = 42;
  pub const VT_CZ_DOT_X_DOT: flatbuffers::VOffsetT = 44;
  pub const VT_CZ_DOT_Y_DOT: flatbuffers::VOffsetT = 46;
  pub const VT_CZ_DOT_Z_DOT: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    covarianceMatrixLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args covarianceMatrixLineArgs<'args>
  ) -> flatbuffers::WIPOffset<covarianceMatrixLine<'bldr>> {
    let mut builder = covarianceMatrixLineBuilder::new(_fbb);
    builder.add_CZ_DOT_Z_DOT(args.CZ_DOT_Z_DOT);
    builder.add_CZ_DOT_Y_DOT(args.CZ_DOT_Y_DOT);
    builder.add_CZ_DOT_X_DOT(args.CZ_DOT_X_DOT);
    builder.add_CZ_DOT_Z(args.CZ_DOT_Z);
    builder.add_CZ_DOT_Y(args.CZ_DOT_Y);
    builder.add_CZ_DOT_X(args.CZ_DOT_X);
    builder.add_CY_DOT_Y_DOT(args.CY_DOT_Y_DOT);
    builder.add_CY_DOT_X_DOT(args.CY_DOT_X_DOT);
    builder.add_CY_DOT_Z(args.CY_DOT_Z);
    builder.add_CY_DOT_Y(args.CY_DOT_Y);
    builder.add_CY_DOT_X(args.CY_DOT_X);
    builder.add_CX_DOT_X_DOT(args.CX_DOT_X_DOT);
    builder.add_CX_DOT_Z(args.CX_DOT_Z);
    builder.add_CX_DOT_Y(args.CX_DOT_Y);
    builder.add_CX_DOT_X(args.CX_DOT_X);
    builder.add_CZ_Z(args.CZ_Z);
    builder.add_CZ_Y(args.CZ_Y);
    builder.add_CZ_X(args.CZ_X);
    builder.add_CY_Y(args.CY_Y);
    builder.add_CY_X(args.CY_X);
    builder.add_CX_X(args.CX_X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.add_COV_REF_FRAME(args.COV_REF_FRAME);
    builder.finish()
  }

  pub fn unpack(&self) -> covarianceMatrixLineT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let COV_REF_FRAME = self.COV_REF_FRAME();
    let CX_X = self.CX_X();
    let CY_X = self.CY_X();
    let CY_Y = self.CY_Y();
    let CZ_X = self.CZ_X();
    let CZ_Y = self.CZ_Y();
    let CZ_Z = self.CZ_Z();
    let CX_DOT_X = self.CX_DOT_X();
    let CX_DOT_Y = self.CX_DOT_Y();
    let CX_DOT_Z = self.CX_DOT_Z();
    let CX_DOT_X_DOT = self.CX_DOT_X_DOT();
    let CY_DOT_X = self.CY_DOT_X();
    let CY_DOT_Y = self.CY_DOT_Y();
    let CY_DOT_Z = self.CY_DOT_Z();
    let CY_DOT_X_DOT = self.CY_DOT_X_DOT();
    let CY_DOT_Y_DOT = self.CY_DOT_Y_DOT();
    let CZ_DOT_X = self.CZ_DOT_X();
    let CZ_DOT_Y = self.CZ_DOT_Y();
    let CZ_DOT_Z = self.CZ_DOT_Z();
    let CZ_DOT_X_DOT = self.CZ_DOT_X_DOT();
    let CZ_DOT_Y_DOT = self.CZ_DOT_Y_DOT();
    let CZ_DOT_Z_DOT = self.CZ_DOT_Z_DOT();
    covarianceMatrixLineT {
      EPOCH,
      COV_REF_FRAME,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT,
    }
  }

  /// Epoch
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(covarianceMatrixLine::VT_EPOCH, None)}
  }
  /// Reference frame for the covariance matrix
  #[inline]
  pub fn COV_REF_FRAME(&self) -> manCovRefFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<manCovRefFrame>(covarianceMatrixLine::VT_COV_REF_FRAME, Some(manCovRefFrame::RSW)).unwrap()}
  }
  /// Covariance matrix [1,1] km**2
  #[inline]
  pub fn CX_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [2,1] km**2
  #[inline]
  pub fn CY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [2,2] km**2
  #[inline]
  pub fn CY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,1] km**2
  #[inline]
  pub fn CZ_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,2] km**2
  #[inline]
  pub fn CZ_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,3] km**2
  #[inline]
  pub fn CZ_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,1] km**2/s
  #[inline]
  pub fn CX_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,2] km**2/s
  #[inline]
  pub fn CX_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,3] km**2/s
  #[inline]
  pub fn CX_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,4] km**2/s**2
  #[inline]
  pub fn CX_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,1] km**2/s
  #[inline]
  pub fn CY_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,2] km**2/s
  #[inline]
  pub fn CY_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,3] km**2/s
  #[inline]
  pub fn CY_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,4] km**2/s**2
  #[inline]
  pub fn CY_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,5] km**2/s**2
  #[inline]
  pub fn CY_DOT_Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,1] km**2/s
  #[inline]
  pub fn CZ_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,2] km**2/s
  #[inline]
  pub fn CZ_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,3] km**2/s
  #[inline]
  pub fn CZ_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,4] km**2/s**2
  #[inline]
  pub fn CZ_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,5] km**2/s**2
  #[inline]
  pub fn CZ_DOT_Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,6] km**2/s**2
  #[inline]
  pub fn CZ_DOT_Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z_DOT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for covarianceMatrixLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<manCovRefFrame>("COV_REF_FRAME", Self::VT_COV_REF_FRAME, false)?
     .visit_field::<f64>("CX_X", Self::VT_CX_X, false)?
     .visit_field::<f64>("CY_X", Self::VT_CY_X, false)?
     .visit_field::<f64>("CY_Y", Self::VT_CY_Y, false)?
     .visit_field::<f64>("CZ_X", Self::VT_CZ_X, false)?
     .visit_field::<f64>("CZ_Y", Self::VT_CZ_Y, false)?
     .visit_field::<f64>("CZ_Z", Self::VT_CZ_Z, false)?
     .visit_field::<f64>("CX_DOT_X", Self::VT_CX_DOT_X, false)?
     .visit_field::<f64>("CX_DOT_Y", Self::VT_CX_DOT_Y, false)?
     .visit_field::<f64>("CX_DOT_Z", Self::VT_CX_DOT_Z, false)?
     .visit_field::<f64>("CX_DOT_X_DOT", Self::VT_CX_DOT_X_DOT, false)?
     .visit_field::<f64>("CY_DOT_X", Self::VT_CY_DOT_X, false)?
     .visit_field::<f64>("CY_DOT_Y", Self::VT_CY_DOT_Y, false)?
     .visit_field::<f64>("CY_DOT_Z", Self::VT_CY_DOT_Z, false)?
     .visit_field::<f64>("CY_DOT_X_DOT", Self::VT_CY_DOT_X_DOT, false)?
     .visit_field::<f64>("CY_DOT_Y_DOT", Self::VT_CY_DOT_Y_DOT, false)?
     .visit_field::<f64>("CZ_DOT_X", Self::VT_CZ_DOT_X, false)?
     .visit_field::<f64>("CZ_DOT_Y", Self::VT_CZ_DOT_Y, false)?
     .visit_field::<f64>("CZ_DOT_Z", Self::VT_CZ_DOT_Z, false)?
     .visit_field::<f64>("CZ_DOT_X_DOT", Self::VT_CZ_DOT_X_DOT, false)?
     .visit_field::<f64>("CZ_DOT_Y_DOT", Self::VT_CZ_DOT_Y_DOT, false)?
     .visit_field::<f64>("CZ_DOT_Z_DOT", Self::VT_CZ_DOT_Z_DOT, false)?
     .finish();
    Ok(())
  }
}
pub struct covarianceMatrixLineArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COV_REF_FRAME: manCovRefFrame,
    pub CX_X: f64,
    pub CY_X: f64,
    pub CY_Y: f64,
    pub CZ_X: f64,
    pub CZ_Y: f64,
    pub CZ_Z: f64,
    pub CX_DOT_X: f64,
    pub CX_DOT_Y: f64,
    pub CX_DOT_Z: f64,
    pub CX_DOT_X_DOT: f64,
    pub CY_DOT_X: f64,
    pub CY_DOT_Y: f64,
    pub CY_DOT_Z: f64,
    pub CY_DOT_X_DOT: f64,
    pub CY_DOT_Y_DOT: f64,
    pub CZ_DOT_X: f64,
    pub CZ_DOT_Y: f64,
    pub CZ_DOT_Z: f64,
    pub CZ_DOT_X_DOT: f64,
    pub CZ_DOT_Y_DOT: f64,
    pub CZ_DOT_Z_DOT: f64,
}
impl<'a> Default for covarianceMatrixLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    covarianceMatrixLineArgs {
      EPOCH: None,
      COV_REF_FRAME: manCovRefFrame::RSW,
      CX_X: 0.0,
      CY_X: 0.0,
      CY_Y: 0.0,
      CZ_X: 0.0,
      CZ_Y: 0.0,
      CZ_Z: 0.0,
      CX_DOT_X: 0.0,
      CX_DOT_Y: 0.0,
      CX_DOT_Z: 0.0,
      CX_DOT_X_DOT: 0.0,
      CY_DOT_X: 0.0,
      CY_DOT_Y: 0.0,
      CY_DOT_Z: 0.0,
      CY_DOT_X_DOT: 0.0,
      CY_DOT_Y_DOT: 0.0,
      CZ_DOT_X: 0.0,
      CZ_DOT_Y: 0.0,
      CZ_DOT_Z: 0.0,
      CZ_DOT_X_DOT: 0.0,
      CZ_DOT_Y_DOT: 0.0,
      CZ_DOT_Z_DOT: 0.0,
    }
  }
}

pub struct covarianceMatrixLineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> covarianceMatrixLineBuilder<'a, 'b> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(covarianceMatrixLine::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_COV_REF_FRAME(&mut self, COV_REF_FRAME: manCovRefFrame) {
    self.fbb_.push_slot::<manCovRefFrame>(covarianceMatrixLine::VT_COV_REF_FRAME, COV_REF_FRAME, manCovRefFrame::RSW);
  }
  #[inline]
  pub fn add_CX_X(&mut self, CX_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_X, CX_X, 0.0);
  }
  #[inline]
  pub fn add_CY_X(&mut self, CY_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_X, CY_X, 0.0);
  }
  #[inline]
  pub fn add_CY_Y(&mut self, CY_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_Y, CY_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_X(&mut self, CZ_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_X, CZ_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_Y(&mut self, CZ_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_Y, CZ_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_Z(&mut self, CZ_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_Z, CZ_Z, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X(&mut self, CX_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_Y(&mut self, CX_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_Y, CX_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_Z(&mut self, CX_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_Z, CX_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X_DOT(&mut self, CX_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_X_DOT, CX_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_X(&mut self, CY_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_X, CY_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Y(&mut self, CY_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Y, CY_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Z(&mut self, CY_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Z, CY_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_X_DOT(&mut self, CY_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_X_DOT, CY_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Y_DOT(&mut self, CY_DOT_Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Y_DOT, CY_DOT_Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_X(&mut self, CZ_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_X, CZ_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Y(&mut self, CZ_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y, CZ_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Z(&mut self, CZ_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z, CZ_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_X_DOT(&mut self, CZ_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_X_DOT, CZ_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Y_DOT(&mut self, CZ_DOT_Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y_DOT, CZ_DOT_Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Z_DOT(&mut self, CZ_DOT_Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z_DOT, CZ_DOT_Z_DOT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> covarianceMatrixLineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    covarianceMatrixLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<covarianceMatrixLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for covarianceMatrixLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("covarianceMatrixLine");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("COV_REF_FRAME", &self.COV_REF_FRAME());
      ds.field("CX_X", &self.CX_X());
      ds.field("CY_X", &self.CY_X());
      ds.field("CY_Y", &self.CY_Y());
      ds.field("CZ_X", &self.CZ_X());
      ds.field("CZ_Y", &self.CZ_Y());
      ds.field("CZ_Z", &self.CZ_Z());
      ds.field("CX_DOT_X", &self.CX_DOT_X());
      ds.field("CX_DOT_Y", &self.CX_DOT_Y());
      ds.field("CX_DOT_Z", &self.CX_DOT_Z());
      ds.field("CX_DOT_X_DOT", &self.CX_DOT_X_DOT());
      ds.field("CY_DOT_X", &self.CY_DOT_X());
      ds.field("CY_DOT_Y", &self.CY_DOT_Y());
      ds.field("CY_DOT_Z", &self.CY_DOT_Z());
      ds.field("CY_DOT_X_DOT", &self.CY_DOT_X_DOT());
      ds.field("CY_DOT_Y_DOT", &self.CY_DOT_Y_DOT());
      ds.field("CZ_DOT_X", &self.CZ_DOT_X());
      ds.field("CZ_DOT_Y", &self.CZ_DOT_Y());
      ds.field("CZ_DOT_Z", &self.CZ_DOT_Z());
      ds.field("CZ_DOT_X_DOT", &self.CZ_DOT_X_DOT());
      ds.field("CZ_DOT_Y_DOT", &self.CZ_DOT_Y_DOT());
      ds.field("CZ_DOT_Z_DOT", &self.CZ_DOT_Z_DOT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct covarianceMatrixLineT {
  pub EPOCH: Option<String>,
  pub COV_REF_FRAME: manCovRefFrame,
  pub CX_X: f64,
  pub CY_X: f64,
  pub CY_Y: f64,
  pub CZ_X: f64,
  pub CZ_Y: f64,
  pub CZ_Z: f64,
  pub CX_DOT_X: f64,
  pub CX_DOT_Y: f64,
  pub CX_DOT_Z: f64,
  pub CX_DOT_X_DOT: f64,
  pub CY_DOT_X: f64,
  pub CY_DOT_Y: f64,
  pub CY_DOT_Z: f64,
  pub CY_DOT_X_DOT: f64,
  pub CY_DOT_Y_DOT: f64,
  pub CZ_DOT_X: f64,
  pub CZ_DOT_Y: f64,
  pub CZ_DOT_Z: f64,
  pub CZ_DOT_X_DOT: f64,
  pub CZ_DOT_Y_DOT: f64,
  pub CZ_DOT_Z_DOT: f64,
}
impl Default for covarianceMatrixLineT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      COV_REF_FRAME: manCovRefFrame::RSW,
      CX_X: 0.0,
      CY_X: 0.0,
      CY_Y: 0.0,
      CZ_X: 0.0,
      CZ_Y: 0.0,
      CZ_Z: 0.0,
      CX_DOT_X: 0.0,
      CX_DOT_Y: 0.0,
      CX_DOT_Z: 0.0,
      CX_DOT_X_DOT: 0.0,
      CY_DOT_X: 0.0,
      CY_DOT_Y: 0.0,
      CY_DOT_Z: 0.0,
      CY_DOT_X_DOT: 0.0,
      CY_DOT_Y_DOT: 0.0,
      CZ_DOT_X: 0.0,
      CZ_DOT_Y: 0.0,
      CZ_DOT_Z: 0.0,
      CZ_DOT_X_DOT: 0.0,
      CZ_DOT_Y_DOT: 0.0,
      CZ_DOT_Z_DOT: 0.0,
    }
  }
}
impl covarianceMatrixLineT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<covarianceMatrixLine<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COV_REF_FRAME = self.COV_REF_FRAME;
    let CX_X = self.CX_X;
    let CY_X = self.CY_X;
    let CY_Y = self.CY_Y;
    let CZ_X = self.CZ_X;
    let CZ_Y = self.CZ_Y;
    let CZ_Z = self.CZ_Z;
    let CX_DOT_X = self.CX_DOT_X;
    let CX_DOT_Y = self.CX_DOT_Y;
    let CX_DOT_Z = self.CX_DOT_Z;
    let CX_DOT_X_DOT = self.CX_DOT_X_DOT;
    let CY_DOT_X = self.CY_DOT_X;
    let CY_DOT_Y = self.CY_DOT_Y;
    let CY_DOT_Z = self.CY_DOT_Z;
    let CY_DOT_X_DOT = self.CY_DOT_X_DOT;
    let CY_DOT_Y_DOT = self.CY_DOT_Y_DOT;
    let CZ_DOT_X = self.CZ_DOT_X;
    let CZ_DOT_Y = self.CZ_DOT_Y;
    let CZ_DOT_Z = self.CZ_DOT_Z;
    let CZ_DOT_X_DOT = self.CZ_DOT_X_DOT;
    let CZ_DOT_Y_DOT = self.CZ_DOT_Y_DOT;
    let CZ_DOT_Z_DOT = self.CZ_DOT_Z_DOT;
    covarianceMatrixLine::create(_fbb, &covarianceMatrixLineArgs{
      EPOCH,
      COV_REF_FRAME,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT,
    })
  }
}
pub enum ephemerisDataBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

/// OEM Ephemeris Data Block
pub struct ephemerisDataBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ephemerisDataBlock<'a> {
  type Inner = ephemerisDataBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ephemerisDataBlock<'a> {
  pub const VT_COMMENT: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CENTER_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_REF_FRAME: flatbuffers::VOffsetT = 12;
  pub const VT_REF_FRAME_EPOCH: flatbuffers::VOffsetT = 14;
  pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 16;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 18;
  pub const VT_USEABLE_START_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_USEABLE_STOP_TIME: flatbuffers::VOffsetT = 22;
  pub const VT_STOP_TIME: flatbuffers::VOffsetT = 24;
  pub const VT_INTERPOLATION: flatbuffers::VOffsetT = 26;
  pub const VT_INTERPOLATION_DEGREE: flatbuffers::VOffsetT = 28;
  pub const VT_EPHEMERIS_DATA_LINES: flatbuffers::VOffsetT = 30;
  pub const VT_COVARIANCE_MATRIX_LINES: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ephemerisDataBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ephemerisDataBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<ephemerisDataBlock<'bldr>> {
    let mut builder = ephemerisDataBlockBuilder::new(_fbb);
    if let Some(x) = args.COVARIANCE_MATRIX_LINES { builder.add_COVARIANCE_MATRIX_LINES(x); }
    if let Some(x) = args.EPHEMERIS_DATA_LINES { builder.add_EPHEMERIS_DATA_LINES(x); }
    builder.add_INTERPOLATION_DEGREE(args.INTERPOLATION_DEGREE);
    if let Some(x) = args.INTERPOLATION { builder.add_INTERPOLATION(x); }
    if let Some(x) = args.STOP_TIME { builder.add_STOP_TIME(x); }
    if let Some(x) = args.USEABLE_STOP_TIME { builder.add_USEABLE_STOP_TIME(x); }
    if let Some(x) = args.USEABLE_START_TIME { builder.add_USEABLE_START_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.REF_FRAME_EPOCH { builder.add_REF_FRAME_EPOCH(x); }
    if let Some(x) = args.CENTER_NAME { builder.add_CENTER_NAME(x); }
    if let Some(x) = args.OBJECT_ID { builder.add_OBJECT_ID(x); }
    if let Some(x) = args.OBJECT_NAME { builder.add_OBJECT_NAME(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    builder.add_TIME_SYSTEM(args.TIME_SYSTEM);
    builder.add_REF_FRAME(args.REF_FRAME);
    builder.finish()
  }

  pub fn unpack(&self) -> ephemerisDataBlockT {
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let OBJECT_NAME = self.OBJECT_NAME().map(|x| {
      x.to_string()
    });
    let OBJECT_ID = self.OBJECT_ID().map(|x| {
      x.to_string()
    });
    let CENTER_NAME = self.CENTER_NAME().map(|x| {
      x.to_string()
    });
    let REF_FRAME = self.REF_FRAME();
    let REF_FRAME_EPOCH = self.REF_FRAME_EPOCH().map(|x| {
      x.to_string()
    });
    let TIME_SYSTEM = self.TIME_SYSTEM();
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let USEABLE_START_TIME = self.USEABLE_START_TIME().map(|x| {
      x.to_string()
    });
    let USEABLE_STOP_TIME = self.USEABLE_STOP_TIME().map(|x| {
      x.to_string()
    });
    let STOP_TIME = self.STOP_TIME().map(|x| {
      x.to_string()
    });
    let INTERPOLATION = self.INTERPOLATION().map(|x| {
      x.to_string()
    });
    let INTERPOLATION_DEGREE = self.INTERPOLATION_DEGREE();
    let EPHEMERIS_DATA_LINES = self.EPHEMERIS_DATA_LINES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let COVARIANCE_MATRIX_LINES = self.COVARIANCE_MATRIX_LINES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ephemerisDataBlockT {
      COMMENT,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      REF_FRAME_EPOCH,
      TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      INTERPOLATION,
      INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES,
    }
  }

  /// Plain-Text Comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_COMMENT, None)}
  }
  /// Satellite Name(s)
  #[inline]
  pub fn OBJECT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_OBJECT_NAME, None)}
  }
  /// International Designator (YYYY-NNNAAA)
  #[inline]
  pub fn OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_OBJECT_ID, None)}
  }
  /// Origin of reference frame (EARTH, MARS, MOON, etc.)
  #[inline]
  pub fn CENTER_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_CENTER_NAME, None)}
  }
  /// Name of the reference frame (TEME, EME2000, etc.)
  #[inline]
  pub fn REF_FRAME(&self) -> referenceFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<referenceFrame>(ephemerisDataBlock::VT_REF_FRAME, Some(referenceFrame::EME2000)).unwrap()}
  }
  /// Epoch of reference frame, if not intrinsic to the definition of the reference frame
  #[inline]
  pub fn REF_FRAME_EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_REF_FRAME_EPOCH, None)}
  }
  /// Time system used for the orbit state and covariance matrix. (UTC)
  #[inline]
  pub fn TIME_SYSTEM(&self) -> timeSystem {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<timeSystem>(ephemerisDataBlock::VT_TIME_SYSTEM, Some(timeSystem::GMST)).unwrap()}
  }
  /// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_START_TIME, None)}
  }
  /// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
  #[inline]
  pub fn USEABLE_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_USEABLE_START_TIME, None)}
  }
  /// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
  #[inline]
  pub fn USEABLE_STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_USEABLE_STOP_TIME, None)}
  }
  /// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  #[inline]
  pub fn STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_STOP_TIME, None)}
  }
  /// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
  #[inline]
  pub fn INTERPOLATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_INTERPOLATION, None)}
  }
  /// Recommended interpolation degree for ephemeris data
  #[inline]
  pub fn INTERPOLATION_DEGREE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ephemerisDataBlock::VT_INTERPOLATION_DEGREE, Some(0)).unwrap()}
  }
  /// Array of ephemeris data lines
  #[inline]
  pub fn EPHEMERIS_DATA_LINES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine>>>>(ephemerisDataBlock::VT_EPHEMERIS_DATA_LINES, None)}
  }
  /// Array of covariance matrix lines
  #[inline]
  pub fn COVARIANCE_MATRIX_LINES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine>>>>(ephemerisDataBlock::VT_COVARIANCE_MATRIX_LINES, None)}
  }
}

impl flatbuffers::Verifiable for ephemerisDataBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_NAME", Self::VT_OBJECT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_ID", Self::VT_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CENTER_NAME", Self::VT_CENTER_NAME, false)?
     .visit_field::<referenceFrame>("REF_FRAME", Self::VT_REF_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REF_FRAME_EPOCH", Self::VT_REF_FRAME_EPOCH, false)?
     .visit_field::<timeSystem>("TIME_SYSTEM", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USEABLE_START_TIME", Self::VT_USEABLE_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USEABLE_STOP_TIME", Self::VT_USEABLE_STOP_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STOP_TIME", Self::VT_STOP_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INTERPOLATION", Self::VT_INTERPOLATION, false)?
     .visit_field::<u32>("INTERPOLATION_DEGREE", Self::VT_INTERPOLATION_DEGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemerisDataLine>>>>("EPHEMERIS_DATA_LINES", Self::VT_EPHEMERIS_DATA_LINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<covarianceMatrixLine>>>>("COVARIANCE_MATRIX_LINES", Self::VT_COVARIANCE_MATRIX_LINES, false)?
     .finish();
    Ok(())
  }
}
pub struct ephemerisDataBlockArgs<'a> {
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CENTER_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REF_FRAME: referenceFrame,
    pub REF_FRAME_EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_SYSTEM: timeSystem,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USEABLE_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USEABLE_STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTERPOLATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTERPOLATION_DEGREE: u32,
    pub EPHEMERIS_DATA_LINES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine<'a>>>>>,
    pub COVARIANCE_MATRIX_LINES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine<'a>>>>>,
}
impl<'a> Default for ephemerisDataBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    ephemerisDataBlockArgs {
      COMMENT: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: referenceFrame::EME2000,
      REF_FRAME_EPOCH: None,
      TIME_SYSTEM: timeSystem::GMST,
      START_TIME: None,
      USEABLE_START_TIME: None,
      USEABLE_STOP_TIME: None,
      STOP_TIME: None,
      INTERPOLATION: None,
      INTERPOLATION_DEGREE: 0,
      EPHEMERIS_DATA_LINES: None,
      COVARIANCE_MATRIX_LINES: None,
    }
  }
}

pub struct ephemerisDataBlockBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ephemerisDataBlockBuilder<'a, 'b> {
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_OBJECT_NAME(&mut self, OBJECT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_OBJECT_NAME, OBJECT_NAME);
  }
  #[inline]
  pub fn add_OBJECT_ID(&mut self, OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_OBJECT_ID, OBJECT_ID);
  }
  #[inline]
  pub fn add_CENTER_NAME(&mut self, CENTER_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_CENTER_NAME, CENTER_NAME);
  }
  #[inline]
  pub fn add_REF_FRAME(&mut self, REF_FRAME: referenceFrame) {
    self.fbb_.push_slot::<referenceFrame>(ephemerisDataBlock::VT_REF_FRAME, REF_FRAME, referenceFrame::EME2000);
  }
  #[inline]
  pub fn add_REF_FRAME_EPOCH(&mut self, REF_FRAME_EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_REF_FRAME_EPOCH, REF_FRAME_EPOCH);
  }
  #[inline]
  pub fn add_TIME_SYSTEM(&mut self, TIME_SYSTEM: timeSystem) {
    self.fbb_.push_slot::<timeSystem>(ephemerisDataBlock::VT_TIME_SYSTEM, TIME_SYSTEM, timeSystem::GMST);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_USEABLE_START_TIME(&mut self, USEABLE_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_USEABLE_START_TIME, USEABLE_START_TIME);
  }
  #[inline]
  pub fn add_USEABLE_STOP_TIME(&mut self, USEABLE_STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_USEABLE_STOP_TIME, USEABLE_STOP_TIME);
  }
  #[inline]
  pub fn add_STOP_TIME(&mut self, STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_STOP_TIME, STOP_TIME);
  }
  #[inline]
  pub fn add_INTERPOLATION(&mut self, INTERPOLATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_INTERPOLATION, INTERPOLATION);
  }
  #[inline]
  pub fn add_INTERPOLATION_DEGREE(&mut self, INTERPOLATION_DEGREE: u32) {
    self.fbb_.push_slot::<u32>(ephemerisDataBlock::VT_INTERPOLATION_DEGREE, INTERPOLATION_DEGREE, 0);
  }
  #[inline]
  pub fn add_EPHEMERIS_DATA_LINES(&mut self, EPHEMERIS_DATA_LINES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemerisDataLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_EPHEMERIS_DATA_LINES, EPHEMERIS_DATA_LINES);
  }
  #[inline]
  pub fn add_COVARIANCE_MATRIX_LINES(&mut self, COVARIANCE_MATRIX_LINES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<covarianceMatrixLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_COVARIANCE_MATRIX_LINES, COVARIANCE_MATRIX_LINES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ephemerisDataBlockBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ephemerisDataBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ephemerisDataBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ephemerisDataBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ephemerisDataBlock");
      ds.field("COMMENT", &self.COMMENT());
      ds.field("OBJECT_NAME", &self.OBJECT_NAME());
      ds.field("OBJECT_ID", &self.OBJECT_ID());
      ds.field("CENTER_NAME", &self.CENTER_NAME());
      ds.field("REF_FRAME", &self.REF_FRAME());
      ds.field("REF_FRAME_EPOCH", &self.REF_FRAME_EPOCH());
      ds.field("TIME_SYSTEM", &self.TIME_SYSTEM());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("USEABLE_START_TIME", &self.USEABLE_START_TIME());
      ds.field("USEABLE_STOP_TIME", &self.USEABLE_STOP_TIME());
      ds.field("STOP_TIME", &self.STOP_TIME());
      ds.field("INTERPOLATION", &self.INTERPOLATION());
      ds.field("INTERPOLATION_DEGREE", &self.INTERPOLATION_DEGREE());
      ds.field("EPHEMERIS_DATA_LINES", &self.EPHEMERIS_DATA_LINES());
      ds.field("COVARIANCE_MATRIX_LINES", &self.COVARIANCE_MATRIX_LINES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ephemerisDataBlockT {
  pub COMMENT: Option<String>,
  pub OBJECT_NAME: Option<String>,
  pub OBJECT_ID: Option<String>,
  pub CENTER_NAME: Option<String>,
  pub REF_FRAME: referenceFrame,
  pub REF_FRAME_EPOCH: Option<String>,
  pub TIME_SYSTEM: timeSystem,
  pub START_TIME: Option<String>,
  pub USEABLE_START_TIME: Option<String>,
  pub USEABLE_STOP_TIME: Option<String>,
  pub STOP_TIME: Option<String>,
  pub INTERPOLATION: Option<String>,
  pub INTERPOLATION_DEGREE: u32,
  pub EPHEMERIS_DATA_LINES: Option<Vec<ephemerisDataLineT>>,
  pub COVARIANCE_MATRIX_LINES: Option<Vec<covarianceMatrixLineT>>,
}
impl Default for ephemerisDataBlockT {
  fn default() -> Self {
    Self {
      COMMENT: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: referenceFrame::EME2000,
      REF_FRAME_EPOCH: None,
      TIME_SYSTEM: timeSystem::GMST,
      START_TIME: None,
      USEABLE_START_TIME: None,
      USEABLE_STOP_TIME: None,
      STOP_TIME: None,
      INTERPOLATION: None,
      INTERPOLATION_DEGREE: 0,
      EPHEMERIS_DATA_LINES: None,
      COVARIANCE_MATRIX_LINES: None,
    }
  }
}
impl ephemerisDataBlockT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ephemerisDataBlock<'b>> {
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_NAME = self.OBJECT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_ID = self.OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CENTER_NAME = self.CENTER_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REF_FRAME = self.REF_FRAME;
    let REF_FRAME_EPOCH = self.REF_FRAME_EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_SYSTEM = self.TIME_SYSTEM;
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USEABLE_START_TIME = self.USEABLE_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USEABLE_STOP_TIME = self.USEABLE_STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STOP_TIME = self.STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTERPOLATION = self.INTERPOLATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTERPOLATION_DEGREE = self.INTERPOLATION_DEGREE;
    let EPHEMERIS_DATA_LINES = self.EPHEMERIS_DATA_LINES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let COVARIANCE_MATRIX_LINES = self.COVARIANCE_MATRIX_LINES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ephemerisDataBlock::create(_fbb, &ephemerisDataBlockArgs{
      COMMENT,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      REF_FRAME_EPOCH,
      TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      INTERPOLATION,
      INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES,
    })
  }
}
pub enum OEMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Orbit Ephemeris Message
pub struct OEM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OEM<'a> {
  type Inner = OEM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OEM<'a> {
  pub const VT_CCSDS_OEM_VERS: flatbuffers::VOffsetT = 4;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 8;
  pub const VT_EPHEMERIS_DATA_BLOCK: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OEM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OEMArgs<'args>
  ) -> flatbuffers::WIPOffset<OEM<'bldr>> {
    let mut builder = OEMBuilder::new(_fbb);
    builder.add_CCSDS_OEM_VERS(args.CCSDS_OEM_VERS);
    if let Some(x) = args.EPHEMERIS_DATA_BLOCK { builder.add_EPHEMERIS_DATA_BLOCK(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OEMT {
    let CCSDS_OEM_VERS = self.CCSDS_OEM_VERS();
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let EPHEMERIS_DATA_BLOCK = self.EPHEMERIS_DATA_BLOCK().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    OEMT {
      CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK,
    }
  }

  /// OEM Header
  /// OEM Version
  #[inline]
  pub fn CCSDS_OEM_VERS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OEM::VT_CCSDS_OEM_VERS, Some(0.0)).unwrap()}
  }
  /// Creation Date
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OEM::VT_CREATION_DATE, None)}
  }
  /// Originator
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OEM::VT_ORIGINATOR, None)}
  }
  /// Array of ephemeris data blocks
  #[inline]
  pub fn EPHEMERIS_DATA_BLOCK(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock>>>>(OEM::VT_EPHEMERIS_DATA_BLOCK, None)}
  }
}

impl flatbuffers::Verifiable for OEM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("CCSDS_OEM_VERS", Self::VT_CCSDS_OEM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemerisDataBlock>>>>("EPHEMERIS_DATA_BLOCK", Self::VT_EPHEMERIS_DATA_BLOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct OEMArgs<'a> {
    pub CCSDS_OEM_VERS: f64,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPHEMERIS_DATA_BLOCK: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock<'a>>>>>,
}
impl<'a> Default for OEMArgs<'a> {
  #[inline]
  fn default() -> Self {
    OEMArgs {
      CCSDS_OEM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      EPHEMERIS_DATA_BLOCK: None,
    }
  }
}

pub struct OEMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OEMBuilder<'a, 'b> {
  #[inline]
  pub fn add_CCSDS_OEM_VERS(&mut self, CCSDS_OEM_VERS: f64) {
    self.fbb_.push_slot::<f64>(OEM::VT_CCSDS_OEM_VERS, CCSDS_OEM_VERS, 0.0);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_EPHEMERIS_DATA_BLOCK(&mut self, EPHEMERIS_DATA_BLOCK: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemerisDataBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_EPHEMERIS_DATA_BLOCK, EPHEMERIS_DATA_BLOCK);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OEMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OEMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OEM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OEM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OEM");
      ds.field("CCSDS_OEM_VERS", &self.CCSDS_OEM_VERS());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("EPHEMERIS_DATA_BLOCK", &self.EPHEMERIS_DATA_BLOCK());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OEMT {
  pub CCSDS_OEM_VERS: f64,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub EPHEMERIS_DATA_BLOCK: Option<Vec<ephemerisDataBlockT>>,
}
impl Default for OEMT {
  fn default() -> Self {
    Self {
      CCSDS_OEM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      EPHEMERIS_DATA_BLOCK: None,
    }
  }
}
impl OEMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<OEM<'b>> {
    let CCSDS_OEM_VERS = self.CCSDS_OEM_VERS;
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPHEMERIS_DATA_BLOCK = self.EPHEMERIS_DATA_BLOCK.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    OEM::create(_fbb, &OEMArgs{
      CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OEM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn root_as_OEM(buf: &[u8]) -> Result<OEM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OEM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OEM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OEM_unchecked`.
pub fn size_prefixed_root_as_OEM(buf: &[u8]) -> Result<OEM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OEM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OEM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn root_as_OEM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OEM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OEM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OEM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn size_prefixed_root_as_OEM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OEM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OEM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OEM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OEM`.
pub unsafe fn root_as_OEM_unchecked(buf: &[u8]) -> OEM {
  flatbuffers::root_unchecked::<OEM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OEM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OEM`.
pub unsafe fn size_prefixed_root_as_OEM_unchecked(buf: &[u8]) -> OEM {
  flatbuffers::size_prefixed_root_unchecked::<OEM>(buf)
}
pub const OEM_IDENTIFIER: &str = "$OEM";

#[inline]
pub fn OEM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OEM_IDENTIFIER, false)
}

#[inline]
pub fn OEM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OEM_IDENTIFIER, true)
}

#[inline]
pub fn finish_OEM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<OEM<'a>>) {
  fbb.finish(root, Some(OEM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OEM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<OEM<'a>>) {
  fbb.finish_size_prefixed(root, Some(OEM_IDENTIFIER));
}
