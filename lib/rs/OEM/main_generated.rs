// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum ephemerisDataLineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single ephemeris data line
pub struct ephemerisDataLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ephemerisDataLine<'a> {
  type Inner = ephemerisDataLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ephemerisDataLine<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_X: flatbuffers::VOffsetT = 6;
  pub const VT_Y: flatbuffers::VOffsetT = 8;
  pub const VT_Z: flatbuffers::VOffsetT = 10;
  pub const VT_X_DOT: flatbuffers::VOffsetT = 12;
  pub const VT_Y_DOT: flatbuffers::VOffsetT = 14;
  pub const VT_Z_DOT: flatbuffers::VOffsetT = 16;
  pub const VT_X_DDOT: flatbuffers::VOffsetT = 18;
  pub const VT_Y_DDOT: flatbuffers::VOffsetT = 20;
  pub const VT_Z_DDOT: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ephemerisDataLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ephemerisDataLineArgs<'args>
  ) -> flatbuffers::WIPOffset<ephemerisDataLine<'bldr>> {
    let mut builder = ephemerisDataLineBuilder::new(_fbb);
    builder.add_Z_DDOT(args.Z_DDOT);
    builder.add_Y_DDOT(args.Y_DDOT);
    builder.add_X_DDOT(args.X_DDOT);
    builder.add_Z_DOT(args.Z_DOT);
    builder.add_Y_DOT(args.Y_DOT);
    builder.add_X_DOT(args.X_DOT);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ephemerisDataLineT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let X_DOT = self.X_DOT();
    let Y_DOT = self.Y_DOT();
    let Z_DOT = self.Z_DOT();
    let X_DDOT = self.X_DDOT();
    let Y_DDOT = self.Y_DDOT();
    let Z_DDOT = self.Z_DDOT();
    ephemerisDataLineT {
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT,
    }
  }

  /// Epoch time, in ISO 8601 UTC format
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataLine::VT_EPOCH, None)}
  }
  /// Position vector X-component km
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X, Some(0.0)).unwrap()}
  }
  /// Position vector Y-component km
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y, Some(0.0)).unwrap()}
  }
  /// Position vector Z-component km
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z, Some(0.0)).unwrap()}
  }
  /// Velocity vector X-component km/s
  #[inline]
  pub fn X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Velocity vector Y-component km/s
  #[inline]
  pub fn Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Velocity vector Z-component km/s
  #[inline]
  pub fn Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z_DOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector X-component km/s/s
  #[inline]
  pub fn X_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_X_DDOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector Y-component km/s/s
  #[inline]
  pub fn Y_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Y_DDOT, Some(0.0)).unwrap()}
  }
  /// Optional: Acceleration vector Z-component km/s/s
  #[inline]
  pub fn Z_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataLine::VT_Z_DDOT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ephemerisDataLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("X_DOT", Self::VT_X_DOT, false)?
     .visit_field::<f64>("Y_DOT", Self::VT_Y_DOT, false)?
     .visit_field::<f64>("Z_DOT", Self::VT_Z_DOT, false)?
     .visit_field::<f64>("X_DDOT", Self::VT_X_DDOT, false)?
     .visit_field::<f64>("Y_DDOT", Self::VT_Y_DDOT, false)?
     .visit_field::<f64>("Z_DDOT", Self::VT_Z_DDOT, false)?
     .finish();
    Ok(())
  }
}
pub struct ephemerisDataLineArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub X_DOT: f64,
    pub Y_DOT: f64,
    pub Z_DOT: f64,
    pub X_DDOT: f64,
    pub Y_DDOT: f64,
    pub Z_DDOT: f64,
}
impl<'a> Default for ephemerisDataLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    ephemerisDataLineArgs {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      X_DDOT: 0.0,
      Y_DDOT: 0.0,
      Z_DDOT: 0.0,
    }
  }
}

pub struct ephemerisDataLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ephemerisDataLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataLine::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_X_DOT(&mut self, X_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X_DOT, X_DOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DOT(&mut self, Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y_DOT, Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DOT(&mut self, Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z_DOT, Z_DOT, 0.0);
  }
  #[inline]
  pub fn add_X_DDOT(&mut self, X_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_X_DDOT, X_DDOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DDOT(&mut self, Y_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Y_DDOT, Y_DDOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DDOT(&mut self, Z_DDOT: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataLine::VT_Z_DDOT, Z_DDOT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ephemerisDataLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ephemerisDataLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ephemerisDataLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ephemerisDataLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ephemerisDataLine");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("X_DOT", &self.X_DOT());
      ds.field("Y_DOT", &self.Y_DOT());
      ds.field("Z_DOT", &self.Z_DOT());
      ds.field("X_DDOT", &self.X_DDOT());
      ds.field("Y_DDOT", &self.Y_DDOT());
      ds.field("Z_DDOT", &self.Z_DDOT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ephemerisDataLineT {
  pub EPOCH: Option<String>,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub X_DOT: f64,
  pub Y_DOT: f64,
  pub Z_DOT: f64,
  pub X_DDOT: f64,
  pub Y_DDOT: f64,
  pub Z_DDOT: f64,
}
impl Default for ephemerisDataLineT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      X_DDOT: 0.0,
      Y_DDOT: 0.0,
      Z_DDOT: 0.0,
    }
  }
}
impl ephemerisDataLineT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ephemerisDataLine<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let X_DOT = self.X_DOT;
    let Y_DOT = self.Y_DOT;
    let Z_DOT = self.Z_DOT;
    let X_DDOT = self.X_DDOT;
    let Y_DDOT = self.Y_DDOT;
    let Z_DDOT = self.Z_DDOT;
    ephemerisDataLine::create(_fbb, &ephemerisDataLineArgs{
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      X_DDOT,
      Y_DDOT,
      Z_DDOT,
    })
  }
}
pub enum covarianceMatrixLineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Position/Velocity Covariance Matrix Line
pub struct covarianceMatrixLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for covarianceMatrixLine<'a> {
  type Inner = covarianceMatrixLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> covarianceMatrixLine<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_CX_X: flatbuffers::VOffsetT = 6;
  pub const VT_CY_X: flatbuffers::VOffsetT = 8;
  pub const VT_CY_Y: flatbuffers::VOffsetT = 10;
  pub const VT_CZ_X: flatbuffers::VOffsetT = 12;
  pub const VT_CZ_Y: flatbuffers::VOffsetT = 14;
  pub const VT_CZ_Z: flatbuffers::VOffsetT = 16;
  pub const VT_CX_DOT_X: flatbuffers::VOffsetT = 18;
  pub const VT_CX_DOT_Y: flatbuffers::VOffsetT = 20;
  pub const VT_CX_DOT_Z: flatbuffers::VOffsetT = 22;
  pub const VT_CX_DOT_X_DOT: flatbuffers::VOffsetT = 24;
  pub const VT_CY_DOT_X: flatbuffers::VOffsetT = 26;
  pub const VT_CY_DOT_Y: flatbuffers::VOffsetT = 28;
  pub const VT_CY_DOT_Z: flatbuffers::VOffsetT = 30;
  pub const VT_CY_DOT_X_DOT: flatbuffers::VOffsetT = 32;
  pub const VT_CY_DOT_Y_DOT: flatbuffers::VOffsetT = 34;
  pub const VT_CZ_DOT_X: flatbuffers::VOffsetT = 36;
  pub const VT_CZ_DOT_Y: flatbuffers::VOffsetT = 38;
  pub const VT_CZ_DOT_Z: flatbuffers::VOffsetT = 40;
  pub const VT_CZ_DOT_X_DOT: flatbuffers::VOffsetT = 42;
  pub const VT_CZ_DOT_Y_DOT: flatbuffers::VOffsetT = 44;
  pub const VT_CZ_DOT_Z_DOT: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    covarianceMatrixLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args covarianceMatrixLineArgs<'args>
  ) -> flatbuffers::WIPOffset<covarianceMatrixLine<'bldr>> {
    let mut builder = covarianceMatrixLineBuilder::new(_fbb);
    builder.add_CZ_DOT_Z_DOT(args.CZ_DOT_Z_DOT);
    builder.add_CZ_DOT_Y_DOT(args.CZ_DOT_Y_DOT);
    builder.add_CZ_DOT_X_DOT(args.CZ_DOT_X_DOT);
    builder.add_CZ_DOT_Z(args.CZ_DOT_Z);
    builder.add_CZ_DOT_Y(args.CZ_DOT_Y);
    builder.add_CZ_DOT_X(args.CZ_DOT_X);
    builder.add_CY_DOT_Y_DOT(args.CY_DOT_Y_DOT);
    builder.add_CY_DOT_X_DOT(args.CY_DOT_X_DOT);
    builder.add_CY_DOT_Z(args.CY_DOT_Z);
    builder.add_CY_DOT_Y(args.CY_DOT_Y);
    builder.add_CY_DOT_X(args.CY_DOT_X);
    builder.add_CX_DOT_X_DOT(args.CX_DOT_X_DOT);
    builder.add_CX_DOT_Z(args.CX_DOT_Z);
    builder.add_CX_DOT_Y(args.CX_DOT_Y);
    builder.add_CX_DOT_X(args.CX_DOT_X);
    builder.add_CZ_Z(args.CZ_Z);
    builder.add_CZ_Y(args.CZ_Y);
    builder.add_CZ_X(args.CZ_X);
    builder.add_CY_Y(args.CY_Y);
    builder.add_CY_X(args.CY_X);
    builder.add_CX_X(args.CX_X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> covarianceMatrixLineT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let CX_X = self.CX_X();
    let CY_X = self.CY_X();
    let CY_Y = self.CY_Y();
    let CZ_X = self.CZ_X();
    let CZ_Y = self.CZ_Y();
    let CZ_Z = self.CZ_Z();
    let CX_DOT_X = self.CX_DOT_X();
    let CX_DOT_Y = self.CX_DOT_Y();
    let CX_DOT_Z = self.CX_DOT_Z();
    let CX_DOT_X_DOT = self.CX_DOT_X_DOT();
    let CY_DOT_X = self.CY_DOT_X();
    let CY_DOT_Y = self.CY_DOT_Y();
    let CY_DOT_Z = self.CY_DOT_Z();
    let CY_DOT_X_DOT = self.CY_DOT_X_DOT();
    let CY_DOT_Y_DOT = self.CY_DOT_Y_DOT();
    let CZ_DOT_X = self.CZ_DOT_X();
    let CZ_DOT_Y = self.CZ_DOT_Y();
    let CZ_DOT_Z = self.CZ_DOT_Z();
    let CZ_DOT_X_DOT = self.CZ_DOT_X_DOT();
    let CZ_DOT_Y_DOT = self.CZ_DOT_Y_DOT();
    let CZ_DOT_Z_DOT = self.CZ_DOT_Z_DOT();
    covarianceMatrixLineT {
      EPOCH,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT,
    }
  }

  /// Epoch
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(covarianceMatrixLine::VT_EPOCH, None)}
  }
  /// Covariance matrix [1,1] km**2
  #[inline]
  pub fn CX_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [2,1] km**2
  #[inline]
  pub fn CY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [2,2] km**2
  #[inline]
  pub fn CY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,1] km**2
  #[inline]
  pub fn CZ_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,2] km**2
  #[inline]
  pub fn CZ_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [3,3] km**2
  #[inline]
  pub fn CZ_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,1] km**2/s
  #[inline]
  pub fn CX_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,2] km**2/s
  #[inline]
  pub fn CX_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,3] km**2/s
  #[inline]
  pub fn CX_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [4,4] km**2/s**2
  #[inline]
  pub fn CX_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CX_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,1] km**2/s
  #[inline]
  pub fn CY_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,2] km**2/s
  #[inline]
  pub fn CY_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,3] km**2/s
  #[inline]
  pub fn CY_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,4] km**2/s**2
  #[inline]
  pub fn CY_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [5,5] km**2/s**2
  #[inline]
  pub fn CY_DOT_Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CY_DOT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,1] km**2/s
  #[inline]
  pub fn CZ_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_X, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,2] km**2/s
  #[inline]
  pub fn CZ_DOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,3] km**2/s
  #[inline]
  pub fn CZ_DOT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,4] km**2/s**2
  #[inline]
  pub fn CZ_DOT_X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,5] km**2/s**2
  #[inline]
  pub fn CZ_DOT_Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix [6,6] km**2/s**2
  #[inline]
  pub fn CZ_DOT_Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z_DOT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for covarianceMatrixLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("CX_X", Self::VT_CX_X, false)?
     .visit_field::<f64>("CY_X", Self::VT_CY_X, false)?
     .visit_field::<f64>("CY_Y", Self::VT_CY_Y, false)?
     .visit_field::<f64>("CZ_X", Self::VT_CZ_X, false)?
     .visit_field::<f64>("CZ_Y", Self::VT_CZ_Y, false)?
     .visit_field::<f64>("CZ_Z", Self::VT_CZ_Z, false)?
     .visit_field::<f64>("CX_DOT_X", Self::VT_CX_DOT_X, false)?
     .visit_field::<f64>("CX_DOT_Y", Self::VT_CX_DOT_Y, false)?
     .visit_field::<f64>("CX_DOT_Z", Self::VT_CX_DOT_Z, false)?
     .visit_field::<f64>("CX_DOT_X_DOT", Self::VT_CX_DOT_X_DOT, false)?
     .visit_field::<f64>("CY_DOT_X", Self::VT_CY_DOT_X, false)?
     .visit_field::<f64>("CY_DOT_Y", Self::VT_CY_DOT_Y, false)?
     .visit_field::<f64>("CY_DOT_Z", Self::VT_CY_DOT_Z, false)?
     .visit_field::<f64>("CY_DOT_X_DOT", Self::VT_CY_DOT_X_DOT, false)?
     .visit_field::<f64>("CY_DOT_Y_DOT", Self::VT_CY_DOT_Y_DOT, false)?
     .visit_field::<f64>("CZ_DOT_X", Self::VT_CZ_DOT_X, false)?
     .visit_field::<f64>("CZ_DOT_Y", Self::VT_CZ_DOT_Y, false)?
     .visit_field::<f64>("CZ_DOT_Z", Self::VT_CZ_DOT_Z, false)?
     .visit_field::<f64>("CZ_DOT_X_DOT", Self::VT_CZ_DOT_X_DOT, false)?
     .visit_field::<f64>("CZ_DOT_Y_DOT", Self::VT_CZ_DOT_Y_DOT, false)?
     .visit_field::<f64>("CZ_DOT_Z_DOT", Self::VT_CZ_DOT_Z_DOT, false)?
     .finish();
    Ok(())
  }
}
pub struct covarianceMatrixLineArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CX_X: f64,
    pub CY_X: f64,
    pub CY_Y: f64,
    pub CZ_X: f64,
    pub CZ_Y: f64,
    pub CZ_Z: f64,
    pub CX_DOT_X: f64,
    pub CX_DOT_Y: f64,
    pub CX_DOT_Z: f64,
    pub CX_DOT_X_DOT: f64,
    pub CY_DOT_X: f64,
    pub CY_DOT_Y: f64,
    pub CY_DOT_Z: f64,
    pub CY_DOT_X_DOT: f64,
    pub CY_DOT_Y_DOT: f64,
    pub CZ_DOT_X: f64,
    pub CZ_DOT_Y: f64,
    pub CZ_DOT_Z: f64,
    pub CZ_DOT_X_DOT: f64,
    pub CZ_DOT_Y_DOT: f64,
    pub CZ_DOT_Z_DOT: f64,
}
impl<'a> Default for covarianceMatrixLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    covarianceMatrixLineArgs {
      EPOCH: None,
      CX_X: 0.0,
      CY_X: 0.0,
      CY_Y: 0.0,
      CZ_X: 0.0,
      CZ_Y: 0.0,
      CZ_Z: 0.0,
      CX_DOT_X: 0.0,
      CX_DOT_Y: 0.0,
      CX_DOT_Z: 0.0,
      CX_DOT_X_DOT: 0.0,
      CY_DOT_X: 0.0,
      CY_DOT_Y: 0.0,
      CY_DOT_Z: 0.0,
      CY_DOT_X_DOT: 0.0,
      CY_DOT_Y_DOT: 0.0,
      CZ_DOT_X: 0.0,
      CZ_DOT_Y: 0.0,
      CZ_DOT_Z: 0.0,
      CZ_DOT_X_DOT: 0.0,
      CZ_DOT_Y_DOT: 0.0,
      CZ_DOT_Z_DOT: 0.0,
    }
  }
}

pub struct covarianceMatrixLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> covarianceMatrixLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(covarianceMatrixLine::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_CX_X(&mut self, CX_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_X, CX_X, 0.0);
  }
  #[inline]
  pub fn add_CY_X(&mut self, CY_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_X, CY_X, 0.0);
  }
  #[inline]
  pub fn add_CY_Y(&mut self, CY_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_Y, CY_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_X(&mut self, CZ_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_X, CZ_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_Y(&mut self, CZ_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_Y, CZ_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_Z(&mut self, CZ_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_Z, CZ_Z, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X(&mut self, CX_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_Y(&mut self, CX_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_Y, CX_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_Z(&mut self, CX_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_Z, CX_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X_DOT(&mut self, CX_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CX_DOT_X_DOT, CX_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_X(&mut self, CY_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_X, CY_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Y(&mut self, CY_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Y, CY_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Z(&mut self, CY_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Z, CY_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_X_DOT(&mut self, CY_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_X_DOT, CY_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CY_DOT_Y_DOT(&mut self, CY_DOT_Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CY_DOT_Y_DOT, CY_DOT_Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_X(&mut self, CZ_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_X, CZ_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Y(&mut self, CZ_DOT_Y: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y, CZ_DOT_Y, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Z(&mut self, CZ_DOT_Z: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z, CZ_DOT_Z, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_X_DOT(&mut self, CZ_DOT_X_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_X_DOT, CZ_DOT_X_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Y_DOT(&mut self, CZ_DOT_Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Y_DOT, CZ_DOT_Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_CZ_DOT_Z_DOT(&mut self, CZ_DOT_Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(covarianceMatrixLine::VT_CZ_DOT_Z_DOT, CZ_DOT_Z_DOT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> covarianceMatrixLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    covarianceMatrixLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<covarianceMatrixLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for covarianceMatrixLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("covarianceMatrixLine");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("CX_X", &self.CX_X());
      ds.field("CY_X", &self.CY_X());
      ds.field("CY_Y", &self.CY_Y());
      ds.field("CZ_X", &self.CZ_X());
      ds.field("CZ_Y", &self.CZ_Y());
      ds.field("CZ_Z", &self.CZ_Z());
      ds.field("CX_DOT_X", &self.CX_DOT_X());
      ds.field("CX_DOT_Y", &self.CX_DOT_Y());
      ds.field("CX_DOT_Z", &self.CX_DOT_Z());
      ds.field("CX_DOT_X_DOT", &self.CX_DOT_X_DOT());
      ds.field("CY_DOT_X", &self.CY_DOT_X());
      ds.field("CY_DOT_Y", &self.CY_DOT_Y());
      ds.field("CY_DOT_Z", &self.CY_DOT_Z());
      ds.field("CY_DOT_X_DOT", &self.CY_DOT_X_DOT());
      ds.field("CY_DOT_Y_DOT", &self.CY_DOT_Y_DOT());
      ds.field("CZ_DOT_X", &self.CZ_DOT_X());
      ds.field("CZ_DOT_Y", &self.CZ_DOT_Y());
      ds.field("CZ_DOT_Z", &self.CZ_DOT_Z());
      ds.field("CZ_DOT_X_DOT", &self.CZ_DOT_X_DOT());
      ds.field("CZ_DOT_Y_DOT", &self.CZ_DOT_Y_DOT());
      ds.field("CZ_DOT_Z_DOT", &self.CZ_DOT_Z_DOT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct covarianceMatrixLineT {
  pub EPOCH: Option<String>,
  pub CX_X: f64,
  pub CY_X: f64,
  pub CY_Y: f64,
  pub CZ_X: f64,
  pub CZ_Y: f64,
  pub CZ_Z: f64,
  pub CX_DOT_X: f64,
  pub CX_DOT_Y: f64,
  pub CX_DOT_Z: f64,
  pub CX_DOT_X_DOT: f64,
  pub CY_DOT_X: f64,
  pub CY_DOT_Y: f64,
  pub CY_DOT_Z: f64,
  pub CY_DOT_X_DOT: f64,
  pub CY_DOT_Y_DOT: f64,
  pub CZ_DOT_X: f64,
  pub CZ_DOT_Y: f64,
  pub CZ_DOT_Z: f64,
  pub CZ_DOT_X_DOT: f64,
  pub CZ_DOT_Y_DOT: f64,
  pub CZ_DOT_Z_DOT: f64,
}
impl Default for covarianceMatrixLineT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      CX_X: 0.0,
      CY_X: 0.0,
      CY_Y: 0.0,
      CZ_X: 0.0,
      CZ_Y: 0.0,
      CZ_Z: 0.0,
      CX_DOT_X: 0.0,
      CX_DOT_Y: 0.0,
      CX_DOT_Z: 0.0,
      CX_DOT_X_DOT: 0.0,
      CY_DOT_X: 0.0,
      CY_DOT_Y: 0.0,
      CY_DOT_Z: 0.0,
      CY_DOT_X_DOT: 0.0,
      CY_DOT_Y_DOT: 0.0,
      CZ_DOT_X: 0.0,
      CZ_DOT_Y: 0.0,
      CZ_DOT_Z: 0.0,
      CZ_DOT_X_DOT: 0.0,
      CZ_DOT_Y_DOT: 0.0,
      CZ_DOT_Z_DOT: 0.0,
    }
  }
}
impl covarianceMatrixLineT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<covarianceMatrixLine<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CX_X = self.CX_X;
    let CY_X = self.CY_X;
    let CY_Y = self.CY_Y;
    let CZ_X = self.CZ_X;
    let CZ_Y = self.CZ_Y;
    let CZ_Z = self.CZ_Z;
    let CX_DOT_X = self.CX_DOT_X;
    let CX_DOT_Y = self.CX_DOT_Y;
    let CX_DOT_Z = self.CX_DOT_Z;
    let CX_DOT_X_DOT = self.CX_DOT_X_DOT;
    let CY_DOT_X = self.CY_DOT_X;
    let CY_DOT_Y = self.CY_DOT_Y;
    let CY_DOT_Z = self.CY_DOT_Z;
    let CY_DOT_X_DOT = self.CY_DOT_X_DOT;
    let CY_DOT_Y_DOT = self.CY_DOT_Y_DOT;
    let CZ_DOT_X = self.CZ_DOT_X;
    let CZ_DOT_Y = self.CZ_DOT_Y;
    let CZ_DOT_Z = self.CZ_DOT_Z;
    let CZ_DOT_X_DOT = self.CZ_DOT_X_DOT;
    let CZ_DOT_Y_DOT = self.CZ_DOT_Y_DOT;
    let CZ_DOT_Z_DOT = self.CZ_DOT_Z_DOT;
    covarianceMatrixLine::create(_fbb, &covarianceMatrixLineArgs{
      EPOCH,
      CX_X,
      CY_X,
      CY_Y,
      CZ_X,
      CZ_Y,
      CZ_Z,
      CX_DOT_X,
      CX_DOT_Y,
      CX_DOT_Z,
      CX_DOT_X_DOT,
      CY_DOT_X,
      CY_DOT_Y,
      CY_DOT_Z,
      CY_DOT_X_DOT,
      CY_DOT_Y_DOT,
      CZ_DOT_X,
      CZ_DOT_Y,
      CZ_DOT_Z,
      CZ_DOT_X_DOT,
      CZ_DOT_Y_DOT,
      CZ_DOT_Z_DOT,
    })
  }
}
pub enum ephemerisDataBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

/// OEM Ephemeris Data Block
pub struct ephemerisDataBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ephemerisDataBlock<'a> {
  type Inner = ephemerisDataBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ephemerisDataBlock<'a> {
  pub const VT_COMMENT: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECT: flatbuffers::VOffsetT = 6;
  pub const VT_CENTER_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_REFERENCE_FRAME: flatbuffers::VOffsetT = 10;
  pub const VT_REFERENCE_FRAME_EPOCH: flatbuffers::VOffsetT = 12;
  pub const VT_COV_REFERENCE_FRAME: flatbuffers::VOffsetT = 14;
  pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 16;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 18;
  pub const VT_USEABLE_START_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_USEABLE_STOP_TIME: flatbuffers::VOffsetT = 22;
  pub const VT_STOP_TIME: flatbuffers::VOffsetT = 24;
  pub const VT_STEP_SIZE: flatbuffers::VOffsetT = 26;
  pub const VT_INTERPOLATION: flatbuffers::VOffsetT = 28;
  pub const VT_INTERPOLATION_DEGREE: flatbuffers::VOffsetT = 30;
  pub const VT_EPHEMERIS_DATA_LINES: flatbuffers::VOffsetT = 32;
  pub const VT_COVARIANCE_MATRIX_LINES: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ephemerisDataBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ephemerisDataBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<ephemerisDataBlock<'bldr>> {
    let mut builder = ephemerisDataBlockBuilder::new(_fbb);
    builder.add_STEP_SIZE(args.STEP_SIZE);
    if let Some(x) = args.COVARIANCE_MATRIX_LINES { builder.add_COVARIANCE_MATRIX_LINES(x); }
    if let Some(x) = args.EPHEMERIS_DATA_LINES { builder.add_EPHEMERIS_DATA_LINES(x); }
    builder.add_INTERPOLATION_DEGREE(args.INTERPOLATION_DEGREE);
    if let Some(x) = args.INTERPOLATION { builder.add_INTERPOLATION(x); }
    if let Some(x) = args.STOP_TIME { builder.add_STOP_TIME(x); }
    if let Some(x) = args.USEABLE_STOP_TIME { builder.add_USEABLE_STOP_TIME(x); }
    if let Some(x) = args.USEABLE_START_TIME { builder.add_USEABLE_START_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.COV_REFERENCE_FRAME { builder.add_COV_REFERENCE_FRAME(x); }
    if let Some(x) = args.REFERENCE_FRAME_EPOCH { builder.add_REFERENCE_FRAME_EPOCH(x); }
    if let Some(x) = args.REFERENCE_FRAME { builder.add_REFERENCE_FRAME(x); }
    if let Some(x) = args.CENTER_NAME { builder.add_CENTER_NAME(x); }
    if let Some(x) = args.OBJECT { builder.add_OBJECT(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    builder.add_TIME_SYSTEM(args.TIME_SYSTEM);
    builder.finish()
  }

  pub fn unpack(&self) -> ephemerisDataBlockT {
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let OBJECT = self.OBJECT().map(|x| {
      Box::new(x.unpack())
    });
    let CENTER_NAME = self.CENTER_NAME().map(|x| {
      x.to_string()
    });
    let REFERENCE_FRAME = self.REFERENCE_FRAME().map(|x| {
      Box::new(x.unpack())
    });
    let REFERENCE_FRAME_EPOCH = self.REFERENCE_FRAME_EPOCH().map(|x| {
      x.to_string()
    });
    let COV_REFERENCE_FRAME = self.COV_REFERENCE_FRAME().map(|x| {
      Box::new(x.unpack())
    });
    let TIME_SYSTEM = self.TIME_SYSTEM();
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let USEABLE_START_TIME = self.USEABLE_START_TIME().map(|x| {
      x.to_string()
    });
    let USEABLE_STOP_TIME = self.USEABLE_STOP_TIME().map(|x| {
      x.to_string()
    });
    let STOP_TIME = self.STOP_TIME().map(|x| {
      x.to_string()
    });
    let STEP_SIZE = self.STEP_SIZE();
    let INTERPOLATION = self.INTERPOLATION().map(|x| {
      x.to_string()
    });
    let INTERPOLATION_DEGREE = self.INTERPOLATION_DEGREE();
    let EPHEMERIS_DATA_LINES = self.EPHEMERIS_DATA_LINES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let COVARIANCE_MATRIX_LINES = self.COVARIANCE_MATRIX_LINES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ephemerisDataBlockT {
      COMMENT,
      OBJECT,
      CENTER_NAME,
      REFERENCE_FRAME,
      REFERENCE_FRAME_EPOCH,
      COV_REFERENCE_FRAME,
      TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      STEP_SIZE,
      INTERPOLATION,
      INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES,
    }
  }

  /// Plain-Text Comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_COMMENT, None)}
  }
  /// Satellite name for the first object
  #[inline]
  pub fn OBJECT(&self) -> Option<CAT<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CAT>>(ephemerisDataBlock::VT_OBJECT, None)}
  }
  /// Origin of reference frame (EARTH, MARS, MOON, etc.)
  #[inline]
  pub fn CENTER_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_CENTER_NAME, None)}
  }
  /// Name of the reference frame (TEME, EME2000, etc.)
  #[inline]
  pub fn REFERENCE_FRAME(&self) -> Option<RFM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RFM>>(ephemerisDataBlock::VT_REFERENCE_FRAME, None)}
  }
  /// Epoch of reference frame, if not intrinsic to the definition of the reference frame
  #[inline]
  pub fn REFERENCE_FRAME_EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_REFERENCE_FRAME_EPOCH, None)}
  }
  /// Reference frame for the covariance matrix
  #[inline]
  pub fn COV_REFERENCE_FRAME(&self) -> Option<RFM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RFM>>(ephemerisDataBlock::VT_COV_REFERENCE_FRAME, None)}
  }
  /// Time system used for the orbit state and covariance matrix. (UTC)
  #[inline]
  pub fn TIME_SYSTEM(&self) -> timeSystem {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<timeSystem>(ephemerisDataBlock::VT_TIME_SYSTEM, Some(timeSystem::GMST)).unwrap()}
  }
  /// Start of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_START_TIME, None)}
  }
  /// Optional start USEABLE time span covered by ephemeris data (ISO 8601)
  #[inline]
  pub fn USEABLE_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_USEABLE_START_TIME, None)}
  }
  /// Optional end of USEABLE time span covered by ephemeris data (ISO 8601)
  #[inline]
  pub fn USEABLE_STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_USEABLE_STOP_TIME, None)}
  }
  /// End of TOTAL time span covered by ephemeris data and covariance data (ISO 8601)
  #[inline]
  pub fn STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_STOP_TIME, None)}
  }
  /// Step size in seconds separating the epochs of each ephemeris data row
  #[inline]
  pub fn STEP_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ephemerisDataBlock::VT_STEP_SIZE, Some(0.0)).unwrap()}
  }
  /// Recommended interpolation method for ephemeris data (Hermite, Linear, Lagrange, etc.)
  #[inline]
  pub fn INTERPOLATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ephemerisDataBlock::VT_INTERPOLATION, None)}
  }
  /// Recommended interpolation degree for ephemeris data
  #[inline]
  pub fn INTERPOLATION_DEGREE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ephemerisDataBlock::VT_INTERPOLATION_DEGREE, Some(0)).unwrap()}
  }
  /// Array of ephemeris data lines
  #[inline]
  pub fn EPHEMERIS_DATA_LINES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine>>>>(ephemerisDataBlock::VT_EPHEMERIS_DATA_LINES, None)}
  }
  /// Array of covariance matrix lines
  #[inline]
  pub fn COVARIANCE_MATRIX_LINES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine>>>>(ephemerisDataBlock::VT_COVARIANCE_MATRIX_LINES, None)}
  }
}

impl flatbuffers::Verifiable for ephemerisDataBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CAT>>("OBJECT", Self::VT_OBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CENTER_NAME", Self::VT_CENTER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RFM>>("REFERENCE_FRAME", Self::VT_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REFERENCE_FRAME_EPOCH", Self::VT_REFERENCE_FRAME_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RFM>>("COV_REFERENCE_FRAME", Self::VT_COV_REFERENCE_FRAME, false)?
     .visit_field::<timeSystem>("TIME_SYSTEM", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USEABLE_START_TIME", Self::VT_USEABLE_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USEABLE_STOP_TIME", Self::VT_USEABLE_STOP_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STOP_TIME", Self::VT_STOP_TIME, false)?
     .visit_field::<f64>("STEP_SIZE", Self::VT_STEP_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INTERPOLATION", Self::VT_INTERPOLATION, false)?
     .visit_field::<u32>("INTERPOLATION_DEGREE", Self::VT_INTERPOLATION_DEGREE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemerisDataLine>>>>("EPHEMERIS_DATA_LINES", Self::VT_EPHEMERIS_DATA_LINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<covarianceMatrixLine>>>>("COVARIANCE_MATRIX_LINES", Self::VT_COVARIANCE_MATRIX_LINES, false)?
     .finish();
    Ok(())
  }
}
pub struct ephemerisDataBlockArgs<'a> {
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT: Option<flatbuffers::WIPOffset<CAT<'a>>>,
    pub CENTER_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REFERENCE_FRAME: Option<flatbuffers::WIPOffset<RFM<'a>>>,
    pub REFERENCE_FRAME_EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COV_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<RFM<'a>>>,
    pub TIME_SYSTEM: timeSystem,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USEABLE_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USEABLE_STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STEP_SIZE: f64,
    pub INTERPOLATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTERPOLATION_DEGREE: u32,
    pub EPHEMERIS_DATA_LINES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataLine<'a>>>>>,
    pub COVARIANCE_MATRIX_LINES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<covarianceMatrixLine<'a>>>>>,
}
impl<'a> Default for ephemerisDataBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    ephemerisDataBlockArgs {
      COMMENT: None,
      OBJECT: None,
      CENTER_NAME: None,
      REFERENCE_FRAME: None,
      REFERENCE_FRAME_EPOCH: None,
      COV_REFERENCE_FRAME: None,
      TIME_SYSTEM: timeSystem::GMST,
      START_TIME: None,
      USEABLE_START_TIME: None,
      USEABLE_STOP_TIME: None,
      STOP_TIME: None,
      STEP_SIZE: 0.0,
      INTERPOLATION: None,
      INTERPOLATION_DEGREE: 0,
      EPHEMERIS_DATA_LINES: None,
      COVARIANCE_MATRIX_LINES: None,
    }
  }
}

pub struct ephemerisDataBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ephemerisDataBlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_OBJECT(&mut self, OBJECT: flatbuffers::WIPOffset<CAT<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CAT>>(ephemerisDataBlock::VT_OBJECT, OBJECT);
  }
  #[inline]
  pub fn add_CENTER_NAME(&mut self, CENTER_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_CENTER_NAME, CENTER_NAME);
  }
  #[inline]
  pub fn add_REFERENCE_FRAME(&mut self, REFERENCE_FRAME: flatbuffers::WIPOffset<RFM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RFM>>(ephemerisDataBlock::VT_REFERENCE_FRAME, REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_REFERENCE_FRAME_EPOCH(&mut self, REFERENCE_FRAME_EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_REFERENCE_FRAME_EPOCH, REFERENCE_FRAME_EPOCH);
  }
  #[inline]
  pub fn add_COV_REFERENCE_FRAME(&mut self, COV_REFERENCE_FRAME: flatbuffers::WIPOffset<RFM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RFM>>(ephemerisDataBlock::VT_COV_REFERENCE_FRAME, COV_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_TIME_SYSTEM(&mut self, TIME_SYSTEM: timeSystem) {
    self.fbb_.push_slot::<timeSystem>(ephemerisDataBlock::VT_TIME_SYSTEM, TIME_SYSTEM, timeSystem::GMST);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_USEABLE_START_TIME(&mut self, USEABLE_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_USEABLE_START_TIME, USEABLE_START_TIME);
  }
  #[inline]
  pub fn add_USEABLE_STOP_TIME(&mut self, USEABLE_STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_USEABLE_STOP_TIME, USEABLE_STOP_TIME);
  }
  #[inline]
  pub fn add_STOP_TIME(&mut self, STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_STOP_TIME, STOP_TIME);
  }
  #[inline]
  pub fn add_STEP_SIZE(&mut self, STEP_SIZE: f64) {
    self.fbb_.push_slot::<f64>(ephemerisDataBlock::VT_STEP_SIZE, STEP_SIZE, 0.0);
  }
  #[inline]
  pub fn add_INTERPOLATION(&mut self, INTERPOLATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_INTERPOLATION, INTERPOLATION);
  }
  #[inline]
  pub fn add_INTERPOLATION_DEGREE(&mut self, INTERPOLATION_DEGREE: u32) {
    self.fbb_.push_slot::<u32>(ephemerisDataBlock::VT_INTERPOLATION_DEGREE, INTERPOLATION_DEGREE, 0);
  }
  #[inline]
  pub fn add_EPHEMERIS_DATA_LINES(&mut self, EPHEMERIS_DATA_LINES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemerisDataLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_EPHEMERIS_DATA_LINES, EPHEMERIS_DATA_LINES);
  }
  #[inline]
  pub fn add_COVARIANCE_MATRIX_LINES(&mut self, COVARIANCE_MATRIX_LINES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<covarianceMatrixLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ephemerisDataBlock::VT_COVARIANCE_MATRIX_LINES, COVARIANCE_MATRIX_LINES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ephemerisDataBlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ephemerisDataBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ephemerisDataBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ephemerisDataBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ephemerisDataBlock");
      ds.field("COMMENT", &self.COMMENT());
      ds.field("OBJECT", &self.OBJECT());
      ds.field("CENTER_NAME", &self.CENTER_NAME());
      ds.field("REFERENCE_FRAME", &self.REFERENCE_FRAME());
      ds.field("REFERENCE_FRAME_EPOCH", &self.REFERENCE_FRAME_EPOCH());
      ds.field("COV_REFERENCE_FRAME", &self.COV_REFERENCE_FRAME());
      ds.field("TIME_SYSTEM", &self.TIME_SYSTEM());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("USEABLE_START_TIME", &self.USEABLE_START_TIME());
      ds.field("USEABLE_STOP_TIME", &self.USEABLE_STOP_TIME());
      ds.field("STOP_TIME", &self.STOP_TIME());
      ds.field("STEP_SIZE", &self.STEP_SIZE());
      ds.field("INTERPOLATION", &self.INTERPOLATION());
      ds.field("INTERPOLATION_DEGREE", &self.INTERPOLATION_DEGREE());
      ds.field("EPHEMERIS_DATA_LINES", &self.EPHEMERIS_DATA_LINES());
      ds.field("COVARIANCE_MATRIX_LINES", &self.COVARIANCE_MATRIX_LINES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ephemerisDataBlockT {
  pub COMMENT: Option<String>,
  pub OBJECT: Option<Box<CATT>>,
  pub CENTER_NAME: Option<String>,
  pub REFERENCE_FRAME: Option<Box<RFMT>>,
  pub REFERENCE_FRAME_EPOCH: Option<String>,
  pub COV_REFERENCE_FRAME: Option<Box<RFMT>>,
  pub TIME_SYSTEM: timeSystem,
  pub START_TIME: Option<String>,
  pub USEABLE_START_TIME: Option<String>,
  pub USEABLE_STOP_TIME: Option<String>,
  pub STOP_TIME: Option<String>,
  pub STEP_SIZE: f64,
  pub INTERPOLATION: Option<String>,
  pub INTERPOLATION_DEGREE: u32,
  pub EPHEMERIS_DATA_LINES: Option<Vec<ephemerisDataLineT>>,
  pub COVARIANCE_MATRIX_LINES: Option<Vec<covarianceMatrixLineT>>,
}
impl Default for ephemerisDataBlockT {
  fn default() -> Self {
    Self {
      COMMENT: None,
      OBJECT: None,
      CENTER_NAME: None,
      REFERENCE_FRAME: None,
      REFERENCE_FRAME_EPOCH: None,
      COV_REFERENCE_FRAME: None,
      TIME_SYSTEM: timeSystem::GMST,
      START_TIME: None,
      USEABLE_START_TIME: None,
      USEABLE_STOP_TIME: None,
      STOP_TIME: None,
      STEP_SIZE: 0.0,
      INTERPOLATION: None,
      INTERPOLATION_DEGREE: 0,
      EPHEMERIS_DATA_LINES: None,
      COVARIANCE_MATRIX_LINES: None,
    }
  }
}
impl ephemerisDataBlockT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ephemerisDataBlock<'b>> {
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT = self.OBJECT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CENTER_NAME = self.CENTER_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REFERENCE_FRAME = self.REFERENCE_FRAME.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let REFERENCE_FRAME_EPOCH = self.REFERENCE_FRAME_EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COV_REFERENCE_FRAME = self.COV_REFERENCE_FRAME.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let TIME_SYSTEM = self.TIME_SYSTEM;
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USEABLE_START_TIME = self.USEABLE_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USEABLE_STOP_TIME = self.USEABLE_STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STOP_TIME = self.STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STEP_SIZE = self.STEP_SIZE;
    let INTERPOLATION = self.INTERPOLATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTERPOLATION_DEGREE = self.INTERPOLATION_DEGREE;
    let EPHEMERIS_DATA_LINES = self.EPHEMERIS_DATA_LINES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let COVARIANCE_MATRIX_LINES = self.COVARIANCE_MATRIX_LINES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ephemerisDataBlock::create(_fbb, &ephemerisDataBlockArgs{
      COMMENT,
      OBJECT,
      CENTER_NAME,
      REFERENCE_FRAME,
      REFERENCE_FRAME_EPOCH,
      COV_REFERENCE_FRAME,
      TIME_SYSTEM,
      START_TIME,
      USEABLE_START_TIME,
      USEABLE_STOP_TIME,
      STOP_TIME,
      STEP_SIZE,
      INTERPOLATION,
      INTERPOLATION_DEGREE,
      EPHEMERIS_DATA_LINES,
      COVARIANCE_MATRIX_LINES,
    })
  }
}
pub enum OEMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Orbit Ephemeris Message
pub struct OEM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OEM<'a> {
  type Inner = OEM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OEM<'a> {
  pub const VT_CLASSIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_CCSDS_OEM_VERS: flatbuffers::VOffsetT = 6;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 10;
  pub const VT_EPHEMERIS_DATA_BLOCK: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OEM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OEMArgs<'args>
  ) -> flatbuffers::WIPOffset<OEM<'bldr>> {
    let mut builder = OEMBuilder::new(_fbb);
    builder.add_CCSDS_OEM_VERS(args.CCSDS_OEM_VERS);
    if let Some(x) = args.EPHEMERIS_DATA_BLOCK { builder.add_EPHEMERIS_DATA_BLOCK(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    if let Some(x) = args.CLASSIFICATION { builder.add_CLASSIFICATION(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OEMT {
    let CLASSIFICATION = self.CLASSIFICATION().map(|x| {
      x.to_string()
    });
    let CCSDS_OEM_VERS = self.CCSDS_OEM_VERS();
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let EPHEMERIS_DATA_BLOCK = self.EPHEMERIS_DATA_BLOCK().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    OEMT {
      CLASSIFICATION,
      CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK,
    }
  }

  /// OEM Header
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  #[inline]
  pub fn CLASSIFICATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OEM::VT_CLASSIFICATION, None)}
  }
  /// OEM Version
  #[inline]
  pub fn CCSDS_OEM_VERS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OEM::VT_CCSDS_OEM_VERS, Some(0.0)).unwrap()}
  }
  /// Creation Date
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OEM::VT_CREATION_DATE, None)}
  }
  /// Originator
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OEM::VT_ORIGINATOR, None)}
  }
  /// Array of ephemeris data blocks
  #[inline]
  pub fn EPHEMERIS_DATA_BLOCK(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock>>>>(OEM::VT_EPHEMERIS_DATA_BLOCK, None)}
  }
}

impl flatbuffers::Verifiable for OEM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION", Self::VT_CLASSIFICATION, false)?
     .visit_field::<f64>("CCSDS_OEM_VERS", Self::VT_CCSDS_OEM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ephemerisDataBlock>>>>("EPHEMERIS_DATA_BLOCK", Self::VT_EPHEMERIS_DATA_BLOCK, false)?
     .finish();
    Ok(())
  }
}
pub struct OEMArgs<'a> {
    pub CLASSIFICATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CCSDS_OEM_VERS: f64,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPHEMERIS_DATA_BLOCK: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ephemerisDataBlock<'a>>>>>,
}
impl<'a> Default for OEMArgs<'a> {
  #[inline]
  fn default() -> Self {
    OEMArgs {
      CLASSIFICATION: None,
      CCSDS_OEM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      EPHEMERIS_DATA_BLOCK: None,
    }
  }
}

pub struct OEMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OEMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CLASSIFICATION(&mut self, CLASSIFICATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_CLASSIFICATION, CLASSIFICATION);
  }
  #[inline]
  pub fn add_CCSDS_OEM_VERS(&mut self, CCSDS_OEM_VERS: f64) {
    self.fbb_.push_slot::<f64>(OEM::VT_CCSDS_OEM_VERS, CCSDS_OEM_VERS, 0.0);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_EPHEMERIS_DATA_BLOCK(&mut self, EPHEMERIS_DATA_BLOCK: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ephemerisDataBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OEM::VT_EPHEMERIS_DATA_BLOCK, EPHEMERIS_DATA_BLOCK);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OEMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OEMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OEM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OEM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OEM");
      ds.field("CLASSIFICATION", &self.CLASSIFICATION());
      ds.field("CCSDS_OEM_VERS", &self.CCSDS_OEM_VERS());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("EPHEMERIS_DATA_BLOCK", &self.EPHEMERIS_DATA_BLOCK());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OEMT {
  pub CLASSIFICATION: Option<String>,
  pub CCSDS_OEM_VERS: f64,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub EPHEMERIS_DATA_BLOCK: Option<Vec<ephemerisDataBlockT>>,
}
impl Default for OEMT {
  fn default() -> Self {
    Self {
      CLASSIFICATION: None,
      CCSDS_OEM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      EPHEMERIS_DATA_BLOCK: None,
    }
  }
}
impl OEMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OEM<'b>> {
    let CLASSIFICATION = self.CLASSIFICATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CCSDS_OEM_VERS = self.CCSDS_OEM_VERS;
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPHEMERIS_DATA_BLOCK = self.EPHEMERIS_DATA_BLOCK.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    OEM::create(_fbb, &OEMArgs{
      CLASSIFICATION,
      CCSDS_OEM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      EPHEMERIS_DATA_BLOCK,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OEM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn root_as_OEM(buf: &[u8]) -> Result<OEM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OEM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OEM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OEM_unchecked`.
pub fn size_prefixed_root_as_OEM(buf: &[u8]) -> Result<OEM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OEM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OEM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn root_as_OEM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OEM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OEM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OEM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OEM_unchecked`.
pub fn size_prefixed_root_as_OEM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OEM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OEM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OEM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OEM`.
pub unsafe fn root_as_OEM_unchecked(buf: &[u8]) -> OEM {
  flatbuffers::root_unchecked::<OEM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OEM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OEM`.
pub unsafe fn size_prefixed_root_as_OEM_unchecked(buf: &[u8]) -> OEM {
  flatbuffers::size_prefixed_root_unchecked::<OEM>(buf)
}
pub const OEM_IDENTIFIER: &str = "$OEM";

#[inline]
pub fn OEM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OEM_IDENTIFIER, false)
}

#[inline]
pub fn OEM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OEM_IDENTIFIER, true)
}

#[inline]
pub fn finish_OEM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OEM<'a>>) {
  fbb.finish(root, Some(OEM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OEM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OEM<'a>>) {
  fbb.finish_size_prefixed(root, Some(OEM_IDENTIFIER));
}
