// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GPXFIX_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GPXFIX_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GPXFIX_TYPE: [GPXFixType; 5] = [
  GPXFixType::NONE,
  GPXFixType::FIX_2D,
  GPXFixType::FIX_3D,
  GPXFixType::DGPS,
  GPXFixType::PPS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GPXFixType(pub i8);
#[allow(non_upper_case_globals)]
impl GPXFixType {
  pub const NONE: Self = Self(0);
  /// 2D fix
  pub const FIX_2D: Self = Self(1);
  /// 3D fix
  pub const FIX_3D: Self = Self(2);
  /// Differential GPS fix
  pub const DGPS: Self = Self(3);
  /// PPP fix
  pub const PPS: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::FIX_2D,
    Self::FIX_3D,
    Self::DGPS,
    Self::PPS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::FIX_2D => Some("FIX_2D"),
      Self::FIX_3D => Some("FIX_3D"),
      Self::DGPS => Some("DGPS"),
      Self::PPS => Some("PPS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GPXFixType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GPXFixType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GPXFixType {
    type Output = GPXFixType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GPXFixType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GPXFixType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GPXFixType {}
pub enum GPXLinkOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GPX link to an external resource
pub struct GPXLink<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPXLink<'a> {
  type Inner = GPXLink<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPXLink<'a> {
  pub const VT_HREF: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPXLink { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXLinkArgs<'args>
  ) -> flatbuffers::WIPOffset<GPXLink<'bldr>> {
    let mut builder = GPXLinkBuilder::new(_fbb);
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.TEXT { builder.add_TEXT(x); }
    if let Some(x) = args.HREF { builder.add_HREF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GPXLinkT {
    let HREF = self.HREF().map(|x| {
      x.to_string()
    });
    let TEXT = self.TEXT().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    GPXLinkT {
      HREF,
      TEXT,
      TYPE,
    }
  }

  /// URL
  #[inline]
  pub fn HREF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXLink::VT_HREF, None)}
  }
  /// Link text
  #[inline]
  pub fn TEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXLink::VT_TEXT, None)}
  }
  /// MIME type
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXLink::VT_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for GPXLink<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HREF", Self::VT_HREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TEXT", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXLinkArgs<'a> {
    pub HREF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TEXT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GPXLinkArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXLinkArgs {
      HREF: None,
      TEXT: None,
      TYPE: None,
    }
  }
}

pub struct GPXLinkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXLinkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_HREF(&mut self, HREF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXLink::VT_HREF, HREF);
  }
  #[inline]
  pub fn add_TEXT(&mut self, TEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXLink::VT_TEXT, TEXT);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXLink::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXLinkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXLinkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPXLink<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPXLink<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPXLink");
      ds.field("HREF", &self.HREF());
      ds.field("TEXT", &self.TEXT());
      ds.field("TYPE", &self.TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXLinkT {
  pub HREF: Option<String>,
  pub TEXT: Option<String>,
  pub TYPE: Option<String>,
}
impl Default for GPXLinkT {
  fn default() -> Self {
    Self {
      HREF: None,
      TEXT: None,
      TYPE: None,
    }
  }
}
impl GPXLinkT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPXLink<'b>> {
    let HREF = self.HREF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TEXT = self.TEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    GPXLink::create(_fbb, &GPXLinkArgs{
      HREF,
      TEXT,
      TYPE,
    })
  }
}
pub enum GPXWaypointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A waypoint, point of interest, or named feature
pub struct GPXWaypoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPXWaypoint<'a> {
  type Inner = GPXWaypoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPXWaypoint<'a> {
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 8;
  pub const VT_TIME: flatbuffers::VOffsetT = 10;
  pub const VT_MAGVAR: flatbuffers::VOffsetT = 12;
  pub const VT_GEOID_HEIGHT: flatbuffers::VOffsetT = 14;
  pub const VT_NAME: flatbuffers::VOffsetT = 16;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 18;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 20;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 22;
  pub const VT_LINKS: flatbuffers::VOffsetT = 24;
  pub const VT_SYMBOL: flatbuffers::VOffsetT = 26;
  pub const VT_TYPE: flatbuffers::VOffsetT = 28;
  pub const VT_FIX: flatbuffers::VOffsetT = 30;
  pub const VT_SAT: flatbuffers::VOffsetT = 32;
  pub const VT_HDOP: flatbuffers::VOffsetT = 34;
  pub const VT_VDOP: flatbuffers::VOffsetT = 36;
  pub const VT_PDOP: flatbuffers::VOffsetT = 38;
  pub const VT_AGE_OF_DGPS_DATA: flatbuffers::VOffsetT = 40;
  pub const VT_DGPS_ID: flatbuffers::VOffsetT = 42;
  pub const VT_SPEED: flatbuffers::VOffsetT = 44;
  pub const VT_COURSE: flatbuffers::VOffsetT = 46;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPXWaypoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXWaypointArgs<'args>
  ) -> flatbuffers::WIPOffset<GPXWaypoint<'bldr>> {
    let mut builder = GPXWaypointBuilder::new(_fbb);
    builder.add_COURSE(args.COURSE);
    builder.add_SPEED(args.SPEED);
    builder.add_AGE_OF_DGPS_DATA(args.AGE_OF_DGPS_DATA);
    builder.add_PDOP(args.PDOP);
    builder.add_VDOP(args.VDOP);
    builder.add_HDOP(args.HDOP);
    builder.add_GEOID_HEIGHT(args.GEOID_HEIGHT);
    builder.add_MAGVAR(args.MAGVAR);
    builder.add_ELEVATION(args.ELEVATION);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.SYMBOL { builder.add_SYMBOL(x); }
    if let Some(x) = args.LINKS { builder.add_LINKS(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.TIME { builder.add_TIME(x); }
    builder.add_DGPS_ID(args.DGPS_ID);
    builder.add_SAT(args.SAT);
    builder.add_FIX(args.FIX);
    builder.finish()
  }

  pub fn unpack(&self) -> GPXWaypointT {
    let LATITUDE = self.LATITUDE();
    let LONGITUDE = self.LONGITUDE();
    let ELEVATION = self.ELEVATION();
    let TIME = self.TIME().map(|x| {
      x.to_string()
    });
    let MAGVAR = self.MAGVAR();
    let GEOID_HEIGHT = self.GEOID_HEIGHT();
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let LINKS = self.LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let SYMBOL = self.SYMBOL().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let FIX = self.FIX();
    let SAT = self.SAT();
    let HDOP = self.HDOP();
    let VDOP = self.VDOP();
    let PDOP = self.PDOP();
    let AGE_OF_DGPS_DATA = self.AGE_OF_DGPS_DATA();
    let DGPS_ID = self.DGPS_ID();
    let SPEED = self.SPEED();
    let COURSE = self.COURSE();
    GPXWaypointT {
      LATITUDE,
      LONGITUDE,
      ELEVATION,
      TIME,
      MAGVAR,
      GEOID_HEIGHT,
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      SYMBOL,
      TYPE,
      FIX,
      SAT,
      HDOP,
      VDOP,
      PDOP,
      AGE_OF_DGPS_DATA,
      DGPS_ID,
      SPEED,
      COURSE,
    }
  }

  /// Latitude in decimal degrees (WGS84)
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Longitude in decimal degrees (WGS84)
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Elevation in meters above WGS84 ellipsoid
  #[inline]
  pub fn ELEVATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  /// UTC timestamp (ISO 8601)
  #[inline]
  pub fn TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_TIME, None)}
  }
  /// Magnetic variation in degrees
  #[inline]
  pub fn MAGVAR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_MAGVAR, Some(0.0)).unwrap()}
  }
  /// Height of geoid above WGS84 ellipsoid in meters
  #[inline]
  pub fn GEOID_HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_GEOID_HEIGHT, Some(0.0)).unwrap()}
  }
  /// Waypoint name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_NAME, None)}
  }
  /// Comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_COMMENT, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_DESCRIPTION, None)}
  }
  /// Source of data
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_SOURCE, None)}
  }
  /// Links to additional information
  #[inline]
  pub fn LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink>>>>(GPXWaypoint::VT_LINKS, None)}
  }
  /// Symbol name
  #[inline]
  pub fn SYMBOL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_SYMBOL, None)}
  }
  /// Type/category
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXWaypoint::VT_TYPE, None)}
  }
  /// Type of GPS fix
  #[inline]
  pub fn FIX(&self) -> GPXFixType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GPXFixType>(GPXWaypoint::VT_FIX, Some(GPXFixType::NONE)).unwrap()}
  }
  /// Number of satellites used for fix
  #[inline]
  pub fn SAT(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GPXWaypoint::VT_SAT, Some(0)).unwrap()}
  }
  /// Horizontal dilution of precision
  #[inline]
  pub fn HDOP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_HDOP, Some(0.0)).unwrap()}
  }
  /// Vertical dilution of precision
  #[inline]
  pub fn VDOP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_VDOP, Some(0.0)).unwrap()}
  }
  /// Position dilution of precision
  #[inline]
  pub fn PDOP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_PDOP, Some(0.0)).unwrap()}
  }
  /// Age of DGPS data in seconds
  #[inline]
  pub fn AGE_OF_DGPS_DATA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_AGE_OF_DGPS_DATA, Some(0.0)).unwrap()}
  }
  /// DGPS station ID
  #[inline]
  pub fn DGPS_ID(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GPXWaypoint::VT_DGPS_ID, Some(0)).unwrap()}
  }
  /// Speed in meters per second
  #[inline]
  pub fn SPEED(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_SPEED, Some(0.0)).unwrap()}
  }
  /// Course/heading in degrees true
  #[inline]
  pub fn COURSE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPXWaypoint::VT_COURSE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GPXWaypoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("ELEVATION", Self::VT_ELEVATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME", Self::VT_TIME, false)?
     .visit_field::<f64>("MAGVAR", Self::VT_MAGVAR, false)?
     .visit_field::<f64>("GEOID_HEIGHT", Self::VT_GEOID_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXLink>>>>("LINKS", Self::VT_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SYMBOL", Self::VT_SYMBOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<GPXFixType>("FIX", Self::VT_FIX, false)?
     .visit_field::<u16>("SAT", Self::VT_SAT, false)?
     .visit_field::<f64>("HDOP", Self::VT_HDOP, false)?
     .visit_field::<f64>("VDOP", Self::VT_VDOP, false)?
     .visit_field::<f64>("PDOP", Self::VT_PDOP, false)?
     .visit_field::<f64>("AGE_OF_DGPS_DATA", Self::VT_AGE_OF_DGPS_DATA, false)?
     .visit_field::<u16>("DGPS_ID", Self::VT_DGPS_ID, false)?
     .visit_field::<f64>("SPEED", Self::VT_SPEED, false)?
     .visit_field::<f64>("COURSE", Self::VT_COURSE, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXWaypointArgs<'a> {
    pub LATITUDE: f64,
    pub LONGITUDE: f64,
    pub ELEVATION: f64,
    pub TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MAGVAR: f64,
    pub GEOID_HEIGHT: f64,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>>>,
    pub SYMBOL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FIX: GPXFixType,
    pub SAT: u16,
    pub HDOP: f64,
    pub VDOP: f64,
    pub PDOP: f64,
    pub AGE_OF_DGPS_DATA: f64,
    pub DGPS_ID: u16,
    pub SPEED: f64,
    pub COURSE: f64,
}
impl<'a> Default for GPXWaypointArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXWaypointArgs {
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ELEVATION: 0.0,
      TIME: None,
      MAGVAR: 0.0,
      GEOID_HEIGHT: 0.0,
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      SYMBOL: None,
      TYPE: None,
      FIX: GPXFixType::NONE,
      SAT: 0,
      HDOP: 0.0,
      VDOP: 0.0,
      PDOP: 0.0,
      AGE_OF_DGPS_DATA: 0.0,
      DGPS_ID: 0,
      SPEED: 0.0,
      COURSE: 0.0,
    }
  }
}

pub struct GPXWaypointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXWaypointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION(&mut self, ELEVATION: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_ELEVATION, ELEVATION, 0.0);
  }
  #[inline]
  pub fn add_TIME(&mut self, TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_TIME, TIME);
  }
  #[inline]
  pub fn add_MAGVAR(&mut self, MAGVAR: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_MAGVAR, MAGVAR, 0.0);
  }
  #[inline]
  pub fn add_GEOID_HEIGHT(&mut self, GEOID_HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_GEOID_HEIGHT, GEOID_HEIGHT, 0.0);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_LINKS(&mut self, LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_LINKS, LINKS);
  }
  #[inline]
  pub fn add_SYMBOL(&mut self, SYMBOL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_SYMBOL, SYMBOL);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXWaypoint::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_FIX(&mut self, FIX: GPXFixType) {
    self.fbb_.push_slot::<GPXFixType>(GPXWaypoint::VT_FIX, FIX, GPXFixType::NONE);
  }
  #[inline]
  pub fn add_SAT(&mut self, SAT: u16) {
    self.fbb_.push_slot::<u16>(GPXWaypoint::VT_SAT, SAT, 0);
  }
  #[inline]
  pub fn add_HDOP(&mut self, HDOP: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_HDOP, HDOP, 0.0);
  }
  #[inline]
  pub fn add_VDOP(&mut self, VDOP: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_VDOP, VDOP, 0.0);
  }
  #[inline]
  pub fn add_PDOP(&mut self, PDOP: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_PDOP, PDOP, 0.0);
  }
  #[inline]
  pub fn add_AGE_OF_DGPS_DATA(&mut self, AGE_OF_DGPS_DATA: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_AGE_OF_DGPS_DATA, AGE_OF_DGPS_DATA, 0.0);
  }
  #[inline]
  pub fn add_DGPS_ID(&mut self, DGPS_ID: u16) {
    self.fbb_.push_slot::<u16>(GPXWaypoint::VT_DGPS_ID, DGPS_ID, 0);
  }
  #[inline]
  pub fn add_SPEED(&mut self, SPEED: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_SPEED, SPEED, 0.0);
  }
  #[inline]
  pub fn add_COURSE(&mut self, COURSE: f64) {
    self.fbb_.push_slot::<f64>(GPXWaypoint::VT_COURSE, COURSE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXWaypointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXWaypointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPXWaypoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPXWaypoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPXWaypoint");
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("ELEVATION", &self.ELEVATION());
      ds.field("TIME", &self.TIME());
      ds.field("MAGVAR", &self.MAGVAR());
      ds.field("GEOID_HEIGHT", &self.GEOID_HEIGHT());
      ds.field("NAME", &self.NAME());
      ds.field("COMMENT", &self.COMMENT());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("LINKS", &self.LINKS());
      ds.field("SYMBOL", &self.SYMBOL());
      ds.field("TYPE", &self.TYPE());
      ds.field("FIX", &self.FIX());
      ds.field("SAT", &self.SAT());
      ds.field("HDOP", &self.HDOP());
      ds.field("VDOP", &self.VDOP());
      ds.field("PDOP", &self.PDOP());
      ds.field("AGE_OF_DGPS_DATA", &self.AGE_OF_DGPS_DATA());
      ds.field("DGPS_ID", &self.DGPS_ID());
      ds.field("SPEED", &self.SPEED());
      ds.field("COURSE", &self.COURSE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXWaypointT {
  pub LATITUDE: f64,
  pub LONGITUDE: f64,
  pub ELEVATION: f64,
  pub TIME: Option<String>,
  pub MAGVAR: f64,
  pub GEOID_HEIGHT: f64,
  pub NAME: Option<String>,
  pub COMMENT: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub SOURCE: Option<String>,
  pub LINKS: Option<Vec<GPXLinkT>>,
  pub SYMBOL: Option<String>,
  pub TYPE: Option<String>,
  pub FIX: GPXFixType,
  pub SAT: u16,
  pub HDOP: f64,
  pub VDOP: f64,
  pub PDOP: f64,
  pub AGE_OF_DGPS_DATA: f64,
  pub DGPS_ID: u16,
  pub SPEED: f64,
  pub COURSE: f64,
}
impl Default for GPXWaypointT {
  fn default() -> Self {
    Self {
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ELEVATION: 0.0,
      TIME: None,
      MAGVAR: 0.0,
      GEOID_HEIGHT: 0.0,
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      SYMBOL: None,
      TYPE: None,
      FIX: GPXFixType::NONE,
      SAT: 0,
      HDOP: 0.0,
      VDOP: 0.0,
      PDOP: 0.0,
      AGE_OF_DGPS_DATA: 0.0,
      DGPS_ID: 0,
      SPEED: 0.0,
      COURSE: 0.0,
    }
  }
}
impl GPXWaypointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPXWaypoint<'b>> {
    let LATITUDE = self.LATITUDE;
    let LONGITUDE = self.LONGITUDE;
    let ELEVATION = self.ELEVATION;
    let TIME = self.TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MAGVAR = self.MAGVAR;
    let GEOID_HEIGHT = self.GEOID_HEIGHT;
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINKS = self.LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let SYMBOL = self.SYMBOL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FIX = self.FIX;
    let SAT = self.SAT;
    let HDOP = self.HDOP;
    let VDOP = self.VDOP;
    let PDOP = self.PDOP;
    let AGE_OF_DGPS_DATA = self.AGE_OF_DGPS_DATA;
    let DGPS_ID = self.DGPS_ID;
    let SPEED = self.SPEED;
    let COURSE = self.COURSE;
    GPXWaypoint::create(_fbb, &GPXWaypointArgs{
      LATITUDE,
      LONGITUDE,
      ELEVATION,
      TIME,
      MAGVAR,
      GEOID_HEIGHT,
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      SYMBOL,
      TYPE,
      FIX,
      SAT,
      HDOP,
      VDOP,
      PDOP,
      AGE_OF_DGPS_DATA,
      DGPS_ID,
      SPEED,
      COURSE,
    })
  }
}
pub enum GPXTrackSegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Track segment (continuous span of track points)
pub struct GPXTrackSegment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPXTrackSegment<'a> {
  type Inner = GPXTrackSegment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPXTrackSegment<'a> {
  pub const VT_POINTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPXTrackSegment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXTrackSegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<GPXTrackSegment<'bldr>> {
    let mut builder = GPXTrackSegmentBuilder::new(_fbb);
    if let Some(x) = args.POINTS { builder.add_POINTS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GPXTrackSegmentT {
    let POINTS = self.POINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GPXTrackSegmentT {
      POINTS,
    }
  }

  /// Ordered track points in this segment
  #[inline]
  pub fn POINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>(GPXTrackSegment::VT_POINTS, None)}
  }
}

impl flatbuffers::Verifiable for GPXTrackSegment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>("POINTS", Self::VT_POINTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXTrackSegmentArgs<'a> {
    pub POINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>>>,
}
impl<'a> Default for GPXTrackSegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXTrackSegmentArgs {
      POINTS: None,
    }
  }
}

pub struct GPXTrackSegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXTrackSegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POINTS(&mut self, POINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXWaypoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrackSegment::VT_POINTS, POINTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXTrackSegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXTrackSegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPXTrackSegment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPXTrackSegment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPXTrackSegment");
      ds.field("POINTS", &self.POINTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXTrackSegmentT {
  pub POINTS: Option<Vec<GPXWaypointT>>,
}
impl Default for GPXTrackSegmentT {
  fn default() -> Self {
    Self {
      POINTS: None,
    }
  }
}
impl GPXTrackSegmentT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPXTrackSegment<'b>> {
    let POINTS = self.POINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GPXTrackSegment::create(_fbb, &GPXTrackSegmentArgs{
      POINTS,
    })
  }
}
pub enum GPXTrackOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Track (ordered list of track segments)
pub struct GPXTrack<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPXTrack<'a> {
  type Inner = GPXTrack<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPXTrack<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 10;
  pub const VT_LINKS: flatbuffers::VOffsetT = 12;
  pub const VT_NUMBER: flatbuffers::VOffsetT = 14;
  pub const VT_TYPE: flatbuffers::VOffsetT = 16;
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPXTrack { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXTrackArgs<'args>
  ) -> flatbuffers::WIPOffset<GPXTrack<'bldr>> {
    let mut builder = GPXTrackBuilder::new(_fbb);
    if let Some(x) = args.SEGMENTS { builder.add_SEGMENTS(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    builder.add_NUMBER(args.NUMBER);
    if let Some(x) = args.LINKS { builder.add_LINKS(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GPXTrackT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let LINKS = self.LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NUMBER = self.NUMBER();
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let SEGMENTS = self.SEGMENTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GPXTrackT {
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      NUMBER,
      TYPE,
      SEGMENTS,
    }
  }

  /// Track name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXTrack::VT_NAME, None)}
  }
  /// Comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXTrack::VT_COMMENT, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXTrack::VT_DESCRIPTION, None)}
  }
  /// Source of data
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXTrack::VT_SOURCE, None)}
  }
  /// Links to additional information
  #[inline]
  pub fn LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink>>>>(GPXTrack::VT_LINKS, None)}
  }
  /// Track number
  #[inline]
  pub fn NUMBER(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GPXTrack::VT_NUMBER, Some(0)).unwrap()}
  }
  /// Type/category
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXTrack::VT_TYPE, None)}
  }
  /// Track segments
  #[inline]
  pub fn SEGMENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrackSegment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrackSegment>>>>(GPXTrack::VT_SEGMENTS, None)}
  }
}

impl flatbuffers::Verifiable for GPXTrack<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXLink>>>>("LINKS", Self::VT_LINKS, false)?
     .visit_field::<u32>("NUMBER", Self::VT_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXTrackSegment>>>>("SEGMENTS", Self::VT_SEGMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXTrackArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>>>,
    pub NUMBER: u32,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEGMENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrackSegment<'a>>>>>,
}
impl<'a> Default for GPXTrackArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXTrackArgs {
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      NUMBER: 0,
      TYPE: None,
      SEGMENTS: None,
    }
  }
}

pub struct GPXTrackBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXTrackBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_LINKS(&mut self, LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_LINKS, LINKS);
  }
  #[inline]
  pub fn add_NUMBER(&mut self, NUMBER: u32) {
    self.fbb_.push_slot::<u32>(GPXTrack::VT_NUMBER, NUMBER, 0);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_SEGMENTS(&mut self, SEGMENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXTrackSegment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXTrack::VT_SEGMENTS, SEGMENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXTrackBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXTrackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPXTrack<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPXTrack<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPXTrack");
      ds.field("NAME", &self.NAME());
      ds.field("COMMENT", &self.COMMENT());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("LINKS", &self.LINKS());
      ds.field("NUMBER", &self.NUMBER());
      ds.field("TYPE", &self.TYPE());
      ds.field("SEGMENTS", &self.SEGMENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXTrackT {
  pub NAME: Option<String>,
  pub COMMENT: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub SOURCE: Option<String>,
  pub LINKS: Option<Vec<GPXLinkT>>,
  pub NUMBER: u32,
  pub TYPE: Option<String>,
  pub SEGMENTS: Option<Vec<GPXTrackSegmentT>>,
}
impl Default for GPXTrackT {
  fn default() -> Self {
    Self {
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      NUMBER: 0,
      TYPE: None,
      SEGMENTS: None,
    }
  }
}
impl GPXTrackT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPXTrack<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINKS = self.LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NUMBER = self.NUMBER;
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEGMENTS = self.SEGMENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GPXTrack::create(_fbb, &GPXTrackArgs{
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      NUMBER,
      TYPE,
      SEGMENTS,
    })
  }
}
pub enum GPXRouteOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Route (ordered list of waypoints for navigation)
pub struct GPXRoute<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPXRoute<'a> {
  type Inner = GPXRoute<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPXRoute<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_COMMENT: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 10;
  pub const VT_LINKS: flatbuffers::VOffsetT = 12;
  pub const VT_NUMBER: flatbuffers::VOffsetT = 14;
  pub const VT_TYPE: flatbuffers::VOffsetT = 16;
  pub const VT_POINTS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPXRoute { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXRouteArgs<'args>
  ) -> flatbuffers::WIPOffset<GPXRoute<'bldr>> {
    let mut builder = GPXRouteBuilder::new(_fbb);
    if let Some(x) = args.POINTS { builder.add_POINTS(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    builder.add_NUMBER(args.NUMBER);
    if let Some(x) = args.LINKS { builder.add_LINKS(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GPXRouteT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let LINKS = self.LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NUMBER = self.NUMBER();
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let POINTS = self.POINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GPXRouteT {
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      NUMBER,
      TYPE,
      POINTS,
    }
  }

  /// Route name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXRoute::VT_NAME, None)}
  }
  /// Comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXRoute::VT_COMMENT, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXRoute::VT_DESCRIPTION, None)}
  }
  /// Source of data
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXRoute::VT_SOURCE, None)}
  }
  /// Links to additional information
  #[inline]
  pub fn LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink>>>>(GPXRoute::VT_LINKS, None)}
  }
  /// Route number
  #[inline]
  pub fn NUMBER(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(GPXRoute::VT_NUMBER, Some(0)).unwrap()}
  }
  /// Type/category
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPXRoute::VT_TYPE, None)}
  }
  /// Route points (ordered waypoints)
  #[inline]
  pub fn POINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>(GPXRoute::VT_POINTS, None)}
  }
}

impl flatbuffers::Verifiable for GPXRoute<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXLink>>>>("LINKS", Self::VT_LINKS, false)?
     .visit_field::<u32>("NUMBER", Self::VT_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>("POINTS", Self::VT_POINTS, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXRouteArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>>>,
    pub NUMBER: u32,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>>>,
}
impl<'a> Default for GPXRouteArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXRouteArgs {
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      NUMBER: 0,
      TYPE: None,
      POINTS: None,
    }
  }
}

pub struct GPXRouteBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXRouteBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_LINKS(&mut self, LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_LINKS, LINKS);
  }
  #[inline]
  pub fn add_NUMBER(&mut self, NUMBER: u32) {
    self.fbb_.push_slot::<u32>(GPXRoute::VT_NUMBER, NUMBER, 0);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_POINTS(&mut self, POINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXWaypoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPXRoute::VT_POINTS, POINTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXRouteBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXRouteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPXRoute<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPXRoute<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPXRoute");
      ds.field("NAME", &self.NAME());
      ds.field("COMMENT", &self.COMMENT());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("LINKS", &self.LINKS());
      ds.field("NUMBER", &self.NUMBER());
      ds.field("TYPE", &self.TYPE());
      ds.field("POINTS", &self.POINTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXRouteT {
  pub NAME: Option<String>,
  pub COMMENT: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub SOURCE: Option<String>,
  pub LINKS: Option<Vec<GPXLinkT>>,
  pub NUMBER: u32,
  pub TYPE: Option<String>,
  pub POINTS: Option<Vec<GPXWaypointT>>,
}
impl Default for GPXRouteT {
  fn default() -> Self {
    Self {
      NAME: None,
      COMMENT: None,
      DESCRIPTION: None,
      SOURCE: None,
      LINKS: None,
      NUMBER: 0,
      TYPE: None,
      POINTS: None,
    }
  }
}
impl GPXRouteT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPXRoute<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINKS = self.LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NUMBER = self.NUMBER;
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POINTS = self.POINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GPXRoute::create(_fbb, &GPXRouteArgs{
      NAME,
      COMMENT,
      DESCRIPTION,
      SOURCE,
      LINKS,
      NUMBER,
      TYPE,
      POINTS,
    })
  }
}
pub enum GPXOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GPX Document
pub struct GPX<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GPX<'a> {
  type Inner = GPX<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GPX<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_CREATOR: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_AUTHOR_NAME: flatbuffers::VOffsetT = 12;
  pub const VT_AUTHOR_EMAIL: flatbuffers::VOffsetT = 14;
  pub const VT_AUTHOR_LINK: flatbuffers::VOffsetT = 16;
  pub const VT_COPYRIGHT_AUTHOR: flatbuffers::VOffsetT = 18;
  pub const VT_COPYRIGHT_YEAR: flatbuffers::VOffsetT = 20;
  pub const VT_COPYRIGHT_LICENSE: flatbuffers::VOffsetT = 22;
  pub const VT_LINKS: flatbuffers::VOffsetT = 24;
  pub const VT_TIME: flatbuffers::VOffsetT = 26;
  pub const VT_KEYWORDS: flatbuffers::VOffsetT = 28;
  pub const VT_BOUNDS_MIN_LAT: flatbuffers::VOffsetT = 30;
  pub const VT_BOUNDS_MIN_LON: flatbuffers::VOffsetT = 32;
  pub const VT_BOUNDS_MAX_LAT: flatbuffers::VOffsetT = 34;
  pub const VT_BOUNDS_MAX_LON: flatbuffers::VOffsetT = 36;
  pub const VT_WAYPOINTS: flatbuffers::VOffsetT = 38;
  pub const VT_ROUTES: flatbuffers::VOffsetT = 40;
  pub const VT_TRACKS: flatbuffers::VOffsetT = 42;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GPX { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GPXArgs<'args>
  ) -> flatbuffers::WIPOffset<GPX<'bldr>> {
    let mut builder = GPXBuilder::new(_fbb);
    builder.add_BOUNDS_MAX_LON(args.BOUNDS_MAX_LON);
    builder.add_BOUNDS_MAX_LAT(args.BOUNDS_MAX_LAT);
    builder.add_BOUNDS_MIN_LON(args.BOUNDS_MIN_LON);
    builder.add_BOUNDS_MIN_LAT(args.BOUNDS_MIN_LAT);
    if let Some(x) = args.TRACKS { builder.add_TRACKS(x); }
    if let Some(x) = args.ROUTES { builder.add_ROUTES(x); }
    if let Some(x) = args.WAYPOINTS { builder.add_WAYPOINTS(x); }
    if let Some(x) = args.KEYWORDS { builder.add_KEYWORDS(x); }
    if let Some(x) = args.TIME { builder.add_TIME(x); }
    if let Some(x) = args.LINKS { builder.add_LINKS(x); }
    if let Some(x) = args.COPYRIGHT_LICENSE { builder.add_COPYRIGHT_LICENSE(x); }
    if let Some(x) = args.COPYRIGHT_YEAR { builder.add_COPYRIGHT_YEAR(x); }
    if let Some(x) = args.COPYRIGHT_AUTHOR { builder.add_COPYRIGHT_AUTHOR(x); }
    if let Some(x) = args.AUTHOR_LINK { builder.add_AUTHOR_LINK(x); }
    if let Some(x) = args.AUTHOR_EMAIL { builder.add_AUTHOR_EMAIL(x); }
    if let Some(x) = args.AUTHOR_NAME { builder.add_AUTHOR_NAME(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.CREATOR { builder.add_CREATOR(x); }
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GPXT {
    let VERSION = self.VERSION().map(|x| {
      x.to_string()
    });
    let CREATOR = self.CREATOR().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let AUTHOR_NAME = self.AUTHOR_NAME().map(|x| {
      x.to_string()
    });
    let AUTHOR_EMAIL = self.AUTHOR_EMAIL().map(|x| {
      x.to_string()
    });
    let AUTHOR_LINK = self.AUTHOR_LINK().map(|x| {
      Box::new(x.unpack())
    });
    let COPYRIGHT_AUTHOR = self.COPYRIGHT_AUTHOR().map(|x| {
      x.to_string()
    });
    let COPYRIGHT_YEAR = self.COPYRIGHT_YEAR().map(|x| {
      x.to_string()
    });
    let COPYRIGHT_LICENSE = self.COPYRIGHT_LICENSE().map(|x| {
      x.to_string()
    });
    let LINKS = self.LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let TIME = self.TIME().map(|x| {
      x.to_string()
    });
    let KEYWORDS = self.KEYWORDS().map(|x| {
      x.to_string()
    });
    let BOUNDS_MIN_LAT = self.BOUNDS_MIN_LAT();
    let BOUNDS_MIN_LON = self.BOUNDS_MIN_LON();
    let BOUNDS_MAX_LAT = self.BOUNDS_MAX_LAT();
    let BOUNDS_MAX_LON = self.BOUNDS_MAX_LON();
    let WAYPOINTS = self.WAYPOINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ROUTES = self.ROUTES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let TRACKS = self.TRACKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GPXT {
      VERSION,
      CREATOR,
      NAME,
      DESCRIPTION,
      AUTHOR_NAME,
      AUTHOR_EMAIL,
      AUTHOR_LINK,
      COPYRIGHT_AUTHOR,
      COPYRIGHT_YEAR,
      COPYRIGHT_LICENSE,
      LINKS,
      TIME,
      KEYWORDS,
      BOUNDS_MIN_LAT,
      BOUNDS_MIN_LON,
      BOUNDS_MAX_LAT,
      BOUNDS_MAX_LON,
      WAYPOINTS,
      ROUTES,
      TRACKS,
    }
  }

  /// GPX schema version
  #[inline]
  pub fn VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_VERSION, None)}
  }
  /// Creator software/organization
  #[inline]
  pub fn CREATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_CREATOR, None)}
  }
  /// File name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_NAME, None)}
  }
  /// File description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_DESCRIPTION, None)}
  }
  /// Person or organization who created the file
  #[inline]
  pub fn AUTHOR_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_AUTHOR_NAME, None)}
  }
  /// Author email
  #[inline]
  pub fn AUTHOR_EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_AUTHOR_EMAIL, None)}
  }
  /// Author link
  #[inline]
  pub fn AUTHOR_LINK(&self) -> Option<GPXLink<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GPXLink>>(GPX::VT_AUTHOR_LINK, None)}
  }
  /// Copyright holder
  #[inline]
  pub fn COPYRIGHT_AUTHOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_COPYRIGHT_AUTHOR, None)}
  }
  /// Copyright year
  #[inline]
  pub fn COPYRIGHT_YEAR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_COPYRIGHT_YEAR, None)}
  }
  /// Copyright license URL
  #[inline]
  pub fn COPYRIGHT_LICENSE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_COPYRIGHT_LICENSE, None)}
  }
  /// Links to additional information
  #[inline]
  pub fn LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink>>>>(GPX::VT_LINKS, None)}
  }
  /// Creation timestamp (ISO 8601)
  #[inline]
  pub fn TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_TIME, None)}
  }
  /// Keywords
  #[inline]
  pub fn KEYWORDS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GPX::VT_KEYWORDS, None)}
  }
  /// Minimum latitude of bounding box
  #[inline]
  pub fn BOUNDS_MIN_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPX::VT_BOUNDS_MIN_LAT, Some(0.0)).unwrap()}
  }
  /// Minimum longitude of bounding box
  #[inline]
  pub fn BOUNDS_MIN_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPX::VT_BOUNDS_MIN_LON, Some(0.0)).unwrap()}
  }
  /// Maximum latitude of bounding box
  #[inline]
  pub fn BOUNDS_MAX_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPX::VT_BOUNDS_MAX_LAT, Some(0.0)).unwrap()}
  }
  /// Maximum longitude of bounding box
  #[inline]
  pub fn BOUNDS_MAX_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GPX::VT_BOUNDS_MAX_LON, Some(0.0)).unwrap()}
  }
  /// Waypoints
  #[inline]
  pub fn WAYPOINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>(GPX::VT_WAYPOINTS, None)}
  }
  /// Routes
  #[inline]
  pub fn ROUTES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXRoute<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXRoute>>>>(GPX::VT_ROUTES, None)}
  }
  /// Tracks
  #[inline]
  pub fn TRACKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrack<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrack>>>>(GPX::VT_TRACKS, None)}
  }
}

impl flatbuffers::Verifiable for GPX<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATOR", Self::VT_CREATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AUTHOR_NAME", Self::VT_AUTHOR_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AUTHOR_EMAIL", Self::VT_AUTHOR_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GPXLink>>("AUTHOR_LINK", Self::VT_AUTHOR_LINK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COPYRIGHT_AUTHOR", Self::VT_COPYRIGHT_AUTHOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COPYRIGHT_YEAR", Self::VT_COPYRIGHT_YEAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COPYRIGHT_LICENSE", Self::VT_COPYRIGHT_LICENSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXLink>>>>("LINKS", Self::VT_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME", Self::VT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEYWORDS", Self::VT_KEYWORDS, false)?
     .visit_field::<f64>("BOUNDS_MIN_LAT", Self::VT_BOUNDS_MIN_LAT, false)?
     .visit_field::<f64>("BOUNDS_MIN_LON", Self::VT_BOUNDS_MIN_LON, false)?
     .visit_field::<f64>("BOUNDS_MAX_LAT", Self::VT_BOUNDS_MAX_LAT, false)?
     .visit_field::<f64>("BOUNDS_MAX_LON", Self::VT_BOUNDS_MAX_LON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXWaypoint>>>>("WAYPOINTS", Self::VT_WAYPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXRoute>>>>("ROUTES", Self::VT_ROUTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GPXTrack>>>>("TRACKS", Self::VT_TRACKS, false)?
     .finish();
    Ok(())
  }
}
pub struct GPXArgs<'a> {
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CREATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AUTHOR_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AUTHOR_EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AUTHOR_LINK: Option<flatbuffers::WIPOffset<GPXLink<'a>>>,
    pub COPYRIGHT_AUTHOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COPYRIGHT_YEAR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COPYRIGHT_LICENSE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXLink<'a>>>>>,
    pub TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEYWORDS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub BOUNDS_MIN_LAT: f64,
    pub BOUNDS_MIN_LON: f64,
    pub BOUNDS_MAX_LAT: f64,
    pub BOUNDS_MAX_LON: f64,
    pub WAYPOINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXWaypoint<'a>>>>>,
    pub ROUTES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXRoute<'a>>>>>,
    pub TRACKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GPXTrack<'a>>>>>,
}
impl<'a> Default for GPXArgs<'a> {
  #[inline]
  fn default() -> Self {
    GPXArgs {
      VERSION: None,
      CREATOR: None,
      NAME: None,
      DESCRIPTION: None,
      AUTHOR_NAME: None,
      AUTHOR_EMAIL: None,
      AUTHOR_LINK: None,
      COPYRIGHT_AUTHOR: None,
      COPYRIGHT_YEAR: None,
      COPYRIGHT_LICENSE: None,
      LINKS: None,
      TIME: None,
      KEYWORDS: None,
      BOUNDS_MIN_LAT: 0.0,
      BOUNDS_MIN_LON: 0.0,
      BOUNDS_MAX_LAT: 0.0,
      BOUNDS_MAX_LON: 0.0,
      WAYPOINTS: None,
      ROUTES: None,
      TRACKS: None,
    }
  }
}

pub struct GPXBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GPXBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_CREATOR(&mut self, CREATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_CREATOR, CREATOR);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_AUTHOR_NAME(&mut self, AUTHOR_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_AUTHOR_NAME, AUTHOR_NAME);
  }
  #[inline]
  pub fn add_AUTHOR_EMAIL(&mut self, AUTHOR_EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_AUTHOR_EMAIL, AUTHOR_EMAIL);
  }
  #[inline]
  pub fn add_AUTHOR_LINK(&mut self, AUTHOR_LINK: flatbuffers::WIPOffset<GPXLink<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GPXLink>>(GPX::VT_AUTHOR_LINK, AUTHOR_LINK);
  }
  #[inline]
  pub fn add_COPYRIGHT_AUTHOR(&mut self, COPYRIGHT_AUTHOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_COPYRIGHT_AUTHOR, COPYRIGHT_AUTHOR);
  }
  #[inline]
  pub fn add_COPYRIGHT_YEAR(&mut self, COPYRIGHT_YEAR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_COPYRIGHT_YEAR, COPYRIGHT_YEAR);
  }
  #[inline]
  pub fn add_COPYRIGHT_LICENSE(&mut self, COPYRIGHT_LICENSE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_COPYRIGHT_LICENSE, COPYRIGHT_LICENSE);
  }
  #[inline]
  pub fn add_LINKS(&mut self, LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_LINKS, LINKS);
  }
  #[inline]
  pub fn add_TIME(&mut self, TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_TIME, TIME);
  }
  #[inline]
  pub fn add_KEYWORDS(&mut self, KEYWORDS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_KEYWORDS, KEYWORDS);
  }
  #[inline]
  pub fn add_BOUNDS_MIN_LAT(&mut self, BOUNDS_MIN_LAT: f64) {
    self.fbb_.push_slot::<f64>(GPX::VT_BOUNDS_MIN_LAT, BOUNDS_MIN_LAT, 0.0);
  }
  #[inline]
  pub fn add_BOUNDS_MIN_LON(&mut self, BOUNDS_MIN_LON: f64) {
    self.fbb_.push_slot::<f64>(GPX::VT_BOUNDS_MIN_LON, BOUNDS_MIN_LON, 0.0);
  }
  #[inline]
  pub fn add_BOUNDS_MAX_LAT(&mut self, BOUNDS_MAX_LAT: f64) {
    self.fbb_.push_slot::<f64>(GPX::VT_BOUNDS_MAX_LAT, BOUNDS_MAX_LAT, 0.0);
  }
  #[inline]
  pub fn add_BOUNDS_MAX_LON(&mut self, BOUNDS_MAX_LON: f64) {
    self.fbb_.push_slot::<f64>(GPX::VT_BOUNDS_MAX_LON, BOUNDS_MAX_LON, 0.0);
  }
  #[inline]
  pub fn add_WAYPOINTS(&mut self, WAYPOINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXWaypoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_WAYPOINTS, WAYPOINTS);
  }
  #[inline]
  pub fn add_ROUTES(&mut self, ROUTES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXRoute<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_ROUTES, ROUTES);
  }
  #[inline]
  pub fn add_TRACKS(&mut self, TRACKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GPXTrack<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GPX::VT_TRACKS, TRACKS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GPXBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GPXBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GPX<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GPX<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GPX");
      ds.field("VERSION", &self.VERSION());
      ds.field("CREATOR", &self.CREATOR());
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("AUTHOR_NAME", &self.AUTHOR_NAME());
      ds.field("AUTHOR_EMAIL", &self.AUTHOR_EMAIL());
      ds.field("AUTHOR_LINK", &self.AUTHOR_LINK());
      ds.field("COPYRIGHT_AUTHOR", &self.COPYRIGHT_AUTHOR());
      ds.field("COPYRIGHT_YEAR", &self.COPYRIGHT_YEAR());
      ds.field("COPYRIGHT_LICENSE", &self.COPYRIGHT_LICENSE());
      ds.field("LINKS", &self.LINKS());
      ds.field("TIME", &self.TIME());
      ds.field("KEYWORDS", &self.KEYWORDS());
      ds.field("BOUNDS_MIN_LAT", &self.BOUNDS_MIN_LAT());
      ds.field("BOUNDS_MIN_LON", &self.BOUNDS_MIN_LON());
      ds.field("BOUNDS_MAX_LAT", &self.BOUNDS_MAX_LAT());
      ds.field("BOUNDS_MAX_LON", &self.BOUNDS_MAX_LON());
      ds.field("WAYPOINTS", &self.WAYPOINTS());
      ds.field("ROUTES", &self.ROUTES());
      ds.field("TRACKS", &self.TRACKS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GPXT {
  pub VERSION: Option<String>,
  pub CREATOR: Option<String>,
  pub NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub AUTHOR_NAME: Option<String>,
  pub AUTHOR_EMAIL: Option<String>,
  pub AUTHOR_LINK: Option<Box<GPXLinkT>>,
  pub COPYRIGHT_AUTHOR: Option<String>,
  pub COPYRIGHT_YEAR: Option<String>,
  pub COPYRIGHT_LICENSE: Option<String>,
  pub LINKS: Option<Vec<GPXLinkT>>,
  pub TIME: Option<String>,
  pub KEYWORDS: Option<String>,
  pub BOUNDS_MIN_LAT: f64,
  pub BOUNDS_MIN_LON: f64,
  pub BOUNDS_MAX_LAT: f64,
  pub BOUNDS_MAX_LON: f64,
  pub WAYPOINTS: Option<Vec<GPXWaypointT>>,
  pub ROUTES: Option<Vec<GPXRouteT>>,
  pub TRACKS: Option<Vec<GPXTrackT>>,
}
impl Default for GPXT {
  fn default() -> Self {
    Self {
      VERSION: None,
      CREATOR: None,
      NAME: None,
      DESCRIPTION: None,
      AUTHOR_NAME: None,
      AUTHOR_EMAIL: None,
      AUTHOR_LINK: None,
      COPYRIGHT_AUTHOR: None,
      COPYRIGHT_YEAR: None,
      COPYRIGHT_LICENSE: None,
      LINKS: None,
      TIME: None,
      KEYWORDS: None,
      BOUNDS_MIN_LAT: 0.0,
      BOUNDS_MIN_LON: 0.0,
      BOUNDS_MAX_LAT: 0.0,
      BOUNDS_MAX_LON: 0.0,
      WAYPOINTS: None,
      ROUTES: None,
      TRACKS: None,
    }
  }
}
impl GPXT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GPX<'b>> {
    let VERSION = self.VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CREATOR = self.CREATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AUTHOR_NAME = self.AUTHOR_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AUTHOR_EMAIL = self.AUTHOR_EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AUTHOR_LINK = self.AUTHOR_LINK.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let COPYRIGHT_AUTHOR = self.COPYRIGHT_AUTHOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COPYRIGHT_YEAR = self.COPYRIGHT_YEAR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COPYRIGHT_LICENSE = self.COPYRIGHT_LICENSE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINKS = self.LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let TIME = self.TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEYWORDS = self.KEYWORDS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let BOUNDS_MIN_LAT = self.BOUNDS_MIN_LAT;
    let BOUNDS_MIN_LON = self.BOUNDS_MIN_LON;
    let BOUNDS_MAX_LAT = self.BOUNDS_MAX_LAT;
    let BOUNDS_MAX_LON = self.BOUNDS_MAX_LON;
    let WAYPOINTS = self.WAYPOINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ROUTES = self.ROUTES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let TRACKS = self.TRACKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GPX::create(_fbb, &GPXArgs{
      VERSION,
      CREATOR,
      NAME,
      DESCRIPTION,
      AUTHOR_NAME,
      AUTHOR_EMAIL,
      AUTHOR_LINK,
      COPYRIGHT_AUTHOR,
      COPYRIGHT_YEAR,
      COPYRIGHT_LICENSE,
      LINKS,
      TIME,
      KEYWORDS,
      BOUNDS_MIN_LAT,
      BOUNDS_MIN_LON,
      BOUNDS_MAX_LAT,
      BOUNDS_MAX_LON,
      WAYPOINTS,
      ROUTES,
      TRACKS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GPX`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GPX_unchecked`.
pub fn root_as_GPX(buf: &[u8]) -> Result<GPX, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GPX>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GPX` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_GPX_unchecked`.
pub fn size_prefixed_root_as_GPX(buf: &[u8]) -> Result<GPX, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GPX>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GPX` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GPX_unchecked`.
pub fn root_as_GPX_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GPX<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GPX<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GPX` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GPX_unchecked`.
pub fn size_prefixed_root_as_GPX_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GPX<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GPX<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GPX and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GPX`.
pub unsafe fn root_as_GPX_unchecked(buf: &[u8]) -> GPX {
  flatbuffers::root_unchecked::<GPX>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GPX and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GPX`.
pub unsafe fn size_prefixed_root_as_GPX_unchecked(buf: &[u8]) -> GPX {
  flatbuffers::size_prefixed_root_unchecked::<GPX>(buf)
}
pub const GPX_IDENTIFIER: &str = "$GPX";

#[inline]
pub fn GPX_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GPX_IDENTIFIER, false)
}

#[inline]
pub fn GPX_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GPX_IDENTIFIER, true)
}

#[inline]
pub fn finish_GPX_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GPX<'a>>) {
  fbb.finish(root, Some(GPX_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_GPX_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GPX<'a>>) {
  fbb.finish_size_prefixed(root, Some(GPX_IDENTIFIER));
}
