// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRK_TRACK_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRK_TRACK_STATUS: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRK_TRACK_STATUS: [TrkTrackStatus; 6] = [
  TrkTrackStatus::ACTIVE,
  TrkTrackStatus::DROPPED,
  TrkTrackStatus::TENTATIVE,
  TrkTrackStatus::CONFIRMED,
  TrkTrackStatus::COASTED,
  TrkTrackStatus::DEAD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrkTrackStatus(pub i8);
#[allow(non_upper_case_globals)]
impl TrkTrackStatus {
  pub const ACTIVE: Self = Self(0);
  pub const DROPPED: Self = Self(1);
  pub const TENTATIVE: Self = Self(2);
  pub const CONFIRMED: Self = Self(3);
  pub const COASTED: Self = Self(4);
  pub const DEAD: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ACTIVE,
    Self::DROPPED,
    Self::TENTATIVE,
    Self::CONFIRMED,
    Self::COASTED,
    Self::DEAD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ACTIVE => Some("ACTIVE"),
      Self::DROPPED => Some("DROPPED"),
      Self::TENTATIVE => Some("TENTATIVE"),
      Self::CONFIRMED => Some("CONFIRMED"),
      Self::COASTED => Some("COASTED"),
      Self::DEAD => Some("DEAD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrkTrackStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrkTrackStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrkTrackStatus {
    type Output = TrkTrackStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrkTrackStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrkTrackStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrkTrackStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_ENVIRONMENT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_ENVIRONMENT: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_ENVIRONMENT: [trackEnvironment; 6] = [
  trackEnvironment::SPACE,
  trackEnvironment::AIR,
  trackEnvironment::SURFACE,
  trackEnvironment::SUBSURFACE,
  trackEnvironment::LAND,
  trackEnvironment::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct trackEnvironment(pub i8);
#[allow(non_upper_case_globals)]
impl trackEnvironment {
  pub const SPACE: Self = Self(0);
  pub const AIR: Self = Self(1);
  pub const SURFACE: Self = Self(2);
  pub const SUBSURFACE: Self = Self(3);
  pub const LAND: Self = Self(4);
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPACE,
    Self::AIR,
    Self::SURFACE,
    Self::SUBSURFACE,
    Self::LAND,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPACE => Some("SPACE"),
      Self::AIR => Some("AIR"),
      Self::SURFACE => Some("SURFACE"),
      Self::SUBSURFACE => Some("SUBSURFACE"),
      Self::LAND => Some("LAND"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for trackEnvironment {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for trackEnvironment {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for trackEnvironment {
    type Output = trackEnvironment;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for trackEnvironment {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for trackEnvironment {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for trackEnvironment {}
pub enum TRKOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Track
pub struct TRK<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TRK<'a> {
  type Inner = TRK<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TRK<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CNTCT: flatbuffers::VOffsetT = 6;
  pub const VT_MSG_TS: flatbuffers::VOffsetT = 8;
  pub const VT_MSN_ID: flatbuffers::VOffsetT = 10;
  pub const VT_ASSET_NAT: flatbuffers::VOffsetT = 12;
  pub const VT_ASSET: flatbuffers::VOffsetT = 14;
  pub const VT_SENSOR_ID: flatbuffers::VOffsetT = 16;
  pub const VT_SEN_QUAL: flatbuffers::VOffsetT = 18;
  pub const VT_TRK_ID: flatbuffers::VOffsetT = 20;
  pub const VT_TRK_NUM: flatbuffers::VOffsetT = 22;
  pub const VT_TRK_STAT: flatbuffers::VOffsetT = 24;
  pub const VT_OBJ_NAT: flatbuffers::VOffsetT = 26;
  pub const VT_OBJ_ID: flatbuffers::VOffsetT = 28;
  pub const VT_OBJ_TYPE: flatbuffers::VOffsetT = 30;
  pub const VT_OBJ_SPEC: flatbuffers::VOffsetT = 32;
  pub const VT_OBJ_PLAT: flatbuffers::VOffsetT = 34;
  pub const VT_OBJ_ACT: flatbuffers::VOffsetT = 36;
  pub const VT_MOD_TYPE: flatbuffers::VOffsetT = 38;
  pub const VT_TRK_ITM_ID: flatbuffers::VOffsetT = 40;
  pub const VT_TS: flatbuffers::VOffsetT = 42;
  pub const VT_TRK_QUAL: flatbuffers::VOffsetT = 44;
  pub const VT_TRK_PT_TYPE: flatbuffers::VOffsetT = 46;
  pub const VT_OBJ_IDENT: flatbuffers::VOffsetT = 48;
  pub const VT_IDENT_CRED: flatbuffers::VOffsetT = 50;
  pub const VT_IDENT_REL: flatbuffers::VOffsetT = 52;
  pub const VT_IDENT_AMP: flatbuffers::VOffsetT = 54;
  pub const VT_ENVIRONMENT: flatbuffers::VOffsetT = 56;
  pub const VT_ENVIRONMENT_CONF: flatbuffers::VOffsetT = 58;
  pub const VT_TRK_CONF: flatbuffers::VOffsetT = 60;
  pub const VT_LAT: flatbuffers::VOffsetT = 62;
  pub const VT_LON: flatbuffers::VOffsetT = 64;
  pub const VT_ALT: flatbuffers::VOffsetT = 66;
  pub const VT_SPD: flatbuffers::VOffsetT = 68;
  pub const VT_HDNG: flatbuffers::VOffsetT = 70;
  pub const VT_COURSE: flatbuffers::VOffsetT = 72;
  pub const VT_SRC_TYPS: flatbuffers::VOffsetT = 74;
  pub const VT_SRC_IDS: flatbuffers::VOffsetT = 76;
  pub const VT_CALL_SIGN: flatbuffers::VOffsetT = 78;
  pub const VT_MULTI_SOURCE: flatbuffers::VOffsetT = 80;
  pub const VT_J_SERIES: flatbuffers::VOffsetT = 82;
  pub const VT_STRENGTH: flatbuffers::VOffsetT = 84;
  pub const VT_M1: flatbuffers::VOffsetT = 86;
  pub const VT_M1V: flatbuffers::VOffsetT = 88;
  pub const VT_M2: flatbuffers::VOffsetT = 90;
  pub const VT_M2V: flatbuffers::VOffsetT = 92;
  pub const VT_M3A: flatbuffers::VOffsetT = 94;
  pub const VT_M3AV: flatbuffers::VOffsetT = 96;
  pub const VT_TAGS: flatbuffers::VOffsetT = 98;
  pub const VT_TRACK_START_TIME: flatbuffers::VOffsetT = 100;
  pub const VT_TRACK_STEP_SIZE: flatbuffers::VOffsetT = 102;
  pub const VT_TRACK_COMPONENTS: flatbuffers::VOffsetT = 104;
  pub const VT_ECEF_POS: flatbuffers::VOffsetT = 106;
  pub const VT_ECEF_VEL: flatbuffers::VOffsetT = 108;
  pub const VT_ECEF_ACC: flatbuffers::VOffsetT = 110;
  pub const VT_LC_POS: flatbuffers::VOffsetT = 112;
  pub const VT_LC_VEL: flatbuffers::VOffsetT = 114;
  pub const VT_LC_ACC: flatbuffers::VOffsetT = 116;
  pub const VT_COV: flatbuffers::VOffsetT = 118;
  pub const VT_ERR_ELLP: flatbuffers::VOffsetT = 120;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TRK { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TRKArgs<'args>
  ) -> flatbuffers::WIPOffset<TRK<'bldr>> {
    let mut builder = TRKBuilder::new(_fbb);
    builder.add_TRACK_STEP_SIZE(args.TRACK_STEP_SIZE);
    builder.add_COURSE(args.COURSE);
    builder.add_HDNG(args.HDNG);
    builder.add_SPD(args.SPD);
    builder.add_ALT(args.ALT);
    builder.add_LON(args.LON);
    builder.add_LAT(args.LAT);
    builder.add_TRK_CONF(args.TRK_CONF);
    builder.add_ENVIRONMENT_CONF(args.ENVIRONMENT_CONF);
    if let Some(x) = args.ERR_ELLP { builder.add_ERR_ELLP(x); }
    if let Some(x) = args.COV { builder.add_COV(x); }
    if let Some(x) = args.LC_ACC { builder.add_LC_ACC(x); }
    if let Some(x) = args.LC_VEL { builder.add_LC_VEL(x); }
    if let Some(x) = args.LC_POS { builder.add_LC_POS(x); }
    if let Some(x) = args.ECEF_ACC { builder.add_ECEF_ACC(x); }
    if let Some(x) = args.ECEF_VEL { builder.add_ECEF_VEL(x); }
    if let Some(x) = args.ECEF_POS { builder.add_ECEF_POS(x); }
    if let Some(x) = args.TRACK_START_TIME { builder.add_TRACK_START_TIME(x); }
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.J_SERIES { builder.add_J_SERIES(x); }
    if let Some(x) = args.CALL_SIGN { builder.add_CALL_SIGN(x); }
    if let Some(x) = args.SRC_IDS { builder.add_SRC_IDS(x); }
    if let Some(x) = args.SRC_TYPS { builder.add_SRC_TYPS(x); }
    if let Some(x) = args.IDENT_AMP { builder.add_IDENT_AMP(x); }
    if let Some(x) = args.OBJ_IDENT { builder.add_OBJ_IDENT(x); }
    if let Some(x) = args.TRK_PT_TYPE { builder.add_TRK_PT_TYPE(x); }
    if let Some(x) = args.TS { builder.add_TS(x); }
    if let Some(x) = args.TRK_ITM_ID { builder.add_TRK_ITM_ID(x); }
    if let Some(x) = args.MOD_TYPE { builder.add_MOD_TYPE(x); }
    if let Some(x) = args.OBJ_ACT { builder.add_OBJ_ACT(x); }
    if let Some(x) = args.OBJ_PLAT { builder.add_OBJ_PLAT(x); }
    if let Some(x) = args.OBJ_SPEC { builder.add_OBJ_SPEC(x); }
    if let Some(x) = args.OBJ_TYPE { builder.add_OBJ_TYPE(x); }
    if let Some(x) = args.OBJ_ID { builder.add_OBJ_ID(x); }
    if let Some(x) = args.OBJ_NAT { builder.add_OBJ_NAT(x); }
    if let Some(x) = args.TRK_NUM { builder.add_TRK_NUM(x); }
    if let Some(x) = args.TRK_ID { builder.add_TRK_ID(x); }
    if let Some(x) = args.SEN_QUAL { builder.add_SEN_QUAL(x); }
    if let Some(x) = args.SENSOR_ID { builder.add_SENSOR_ID(x); }
    if let Some(x) = args.ASSET { builder.add_ASSET(x); }
    if let Some(x) = args.ASSET_NAT { builder.add_ASSET_NAT(x); }
    if let Some(x) = args.MSN_ID { builder.add_MSN_ID(x); }
    if let Some(x) = args.MSG_TS { builder.add_MSG_TS(x); }
    if let Some(x) = args.CNTCT { builder.add_CNTCT(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_M3A(args.M3A);
    builder.add_M2(args.M2);
    builder.add_M1(args.M1);
    builder.add_STRENGTH(args.STRENGTH);
    builder.add_TRACK_COMPONENTS(args.TRACK_COMPONENTS);
    builder.add_M3AV(args.M3AV);
    builder.add_M2V(args.M2V);
    builder.add_M1V(args.M1V);
    builder.add_MULTI_SOURCE(args.MULTI_SOURCE);
    builder.add_ENVIRONMENT(args.ENVIRONMENT);
    builder.add_IDENT_REL(args.IDENT_REL);
    builder.add_IDENT_CRED(args.IDENT_CRED);
    builder.add_TRK_QUAL(args.TRK_QUAL);
    builder.add_TRK_STAT(args.TRK_STAT);
    builder.finish()
  }

  pub fn unpack(&self) -> TRKT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let CNTCT = self.CNTCT().map(|x| {
      x.to_string()
    });
    let MSG_TS = self.MSG_TS().map(|x| {
      x.to_string()
    });
    let MSN_ID = self.MSN_ID().map(|x| {
      x.to_string()
    });
    let ASSET_NAT = self.ASSET_NAT().map(|x| {
      x.to_string()
    });
    let ASSET = self.ASSET().map(|x| {
      x.to_string()
    });
    let SENSOR_ID = self.SENSOR_ID().map(|x| {
      x.to_string()
    });
    let SEN_QUAL = self.SEN_QUAL().map(|x| {
      x.to_string()
    });
    let TRK_ID = self.TRK_ID().map(|x| {
      x.to_string()
    });
    let TRK_NUM = self.TRK_NUM().map(|x| {
      x.to_string()
    });
    let TRK_STAT = self.TRK_STAT();
    let OBJ_NAT = self.OBJ_NAT().map(|x| {
      x.to_string()
    });
    let OBJ_ID = self.OBJ_ID().map(|x| {
      x.to_string()
    });
    let OBJ_TYPE = self.OBJ_TYPE().map(|x| {
      x.to_string()
    });
    let OBJ_SPEC = self.OBJ_SPEC().map(|x| {
      x.to_string()
    });
    let OBJ_PLAT = self.OBJ_PLAT().map(|x| {
      x.to_string()
    });
    let OBJ_ACT = self.OBJ_ACT().map(|x| {
      x.to_string()
    });
    let MOD_TYPE = self.MOD_TYPE().map(|x| {
      x.to_string()
    });
    let TRK_ITM_ID = self.TRK_ITM_ID().map(|x| {
      x.to_string()
    });
    let TS = self.TS().map(|x| {
      x.to_string()
    });
    let TRK_QUAL = self.TRK_QUAL();
    let TRK_PT_TYPE = self.TRK_PT_TYPE().map(|x| {
      x.to_string()
    });
    let OBJ_IDENT = self.OBJ_IDENT().map(|x| {
      x.to_string()
    });
    let IDENT_CRED = self.IDENT_CRED();
    let IDENT_REL = self.IDENT_REL();
    let IDENT_AMP = self.IDENT_AMP().map(|x| {
      x.to_string()
    });
    let ENVIRONMENT = self.ENVIRONMENT();
    let ENVIRONMENT_CONF = self.ENVIRONMENT_CONF();
    let TRK_CONF = self.TRK_CONF();
    let LAT = self.LAT();
    let LON = self.LON();
    let ALT = self.ALT();
    let SPD = self.SPD();
    let HDNG = self.HDNG();
    let COURSE = self.COURSE();
    let SRC_TYPS = self.SRC_TYPS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SRC_IDS = self.SRC_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let CALL_SIGN = self.CALL_SIGN().map(|x| {
      x.to_string()
    });
    let MULTI_SOURCE = self.MULTI_SOURCE();
    let J_SERIES = self.J_SERIES().map(|x| {
      x.to_string()
    });
    let STRENGTH = self.STRENGTH();
    let M1 = self.M1();
    let M1V = self.M1V();
    let M2 = self.M2();
    let M2V = self.M2V();
    let M3A = self.M3A();
    let M3AV = self.M3AV();
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let TRACK_START_TIME = self.TRACK_START_TIME().map(|x| {
      x.to_string()
    });
    let TRACK_STEP_SIZE = self.TRACK_STEP_SIZE();
    let TRACK_COMPONENTS = self.TRACK_COMPONENTS();
    let ECEF_POS = self.ECEF_POS().map(|x| {
      x.into_iter().collect()
    });
    let ECEF_VEL = self.ECEF_VEL().map(|x| {
      x.into_iter().collect()
    });
    let ECEF_ACC = self.ECEF_ACC().map(|x| {
      x.into_iter().collect()
    });
    let LC_POS = self.LC_POS().map(|x| {
      x.into_iter().collect()
    });
    let LC_VEL = self.LC_VEL().map(|x| {
      x.into_iter().collect()
    });
    let LC_ACC = self.LC_ACC().map(|x| {
      x.into_iter().collect()
    });
    let COV = self.COV().map(|x| {
      x.into_iter().collect()
    });
    let ERR_ELLP = self.ERR_ELLP().map(|x| {
      x.into_iter().collect()
    });
    TRKT {
      ID,
      CNTCT,
      MSG_TS,
      MSN_ID,
      ASSET_NAT,
      ASSET,
      SENSOR_ID,
      SEN_QUAL,
      TRK_ID,
      TRK_NUM,
      TRK_STAT,
      OBJ_NAT,
      OBJ_ID,
      OBJ_TYPE,
      OBJ_SPEC,
      OBJ_PLAT,
      OBJ_ACT,
      MOD_TYPE,
      TRK_ITM_ID,
      TS,
      TRK_QUAL,
      TRK_PT_TYPE,
      OBJ_IDENT,
      IDENT_CRED,
      IDENT_REL,
      IDENT_AMP,
      ENVIRONMENT,
      ENVIRONMENT_CONF,
      TRK_CONF,
      LAT,
      LON,
      ALT,
      SPD,
      HDNG,
      COURSE,
      SRC_TYPS,
      SRC_IDS,
      CALL_SIGN,
      MULTI_SOURCE,
      J_SERIES,
      STRENGTH,
      M1,
      M1V,
      M2,
      M2V,
      M3A,
      M3AV,
      TAGS,
      TRACK_START_TIME,
      TRACK_STEP_SIZE,
      TRACK_COMPONENTS,
      ECEF_POS,
      ECEF_VEL,
      ECEF_ACC,
      LC_POS,
      LC_VEL,
      LC_ACC,
      COV,
      ERR_ELLP,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_ID, None)}
  }
  /// Contact reference
  #[inline]
  pub fn CNTCT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_CNTCT, None)}
  }
  /// Message timestamp (ISO 8601)
  #[inline]
  pub fn MSG_TS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_MSG_TS, None)}
  }
  /// Mission identifier
  #[inline]
  pub fn MSN_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_MSN_ID, None)}
  }
  /// Asset nationality
  #[inline]
  pub fn ASSET_NAT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_ASSET_NAT, None)}
  }
  /// Asset identifier
  #[inline]
  pub fn ASSET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_ASSET, None)}
  }
  /// Sensor identifier
  #[inline]
  pub fn SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_SENSOR_ID, None)}
  }
  /// Sensor quality assessment
  #[inline]
  pub fn SEN_QUAL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_SEN_QUAL, None)}
  }
  /// Track identifier
  #[inline]
  pub fn TRK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TRK_ID, None)}
  }
  /// Track number
  #[inline]
  pub fn TRK_NUM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TRK_NUM, None)}
  }
  /// Track status
  #[inline]
  pub fn TRK_STAT(&self) -> TrkTrackStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TrkTrackStatus>(TRK::VT_TRK_STAT, Some(TrkTrackStatus::ACTIVE)).unwrap()}
  }
  /// Object nationality
  #[inline]
  pub fn OBJ_NAT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_NAT, None)}
  }
  /// Object identifier
  #[inline]
  pub fn OBJ_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_ID, None)}
  }
  /// Object type classification
  #[inline]
  pub fn OBJ_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_TYPE, None)}
  }
  /// Object specific type
  #[inline]
  pub fn OBJ_SPEC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_SPEC, None)}
  }
  /// Object platform type
  #[inline]
  pub fn OBJ_PLAT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_PLAT, None)}
  }
  /// Object activity
  #[inline]
  pub fn OBJ_ACT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_ACT, None)}
  }
  /// Mode type
  #[inline]
  pub fn MOD_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_MOD_TYPE, None)}
  }
  /// Track item identifier
  #[inline]
  pub fn TRK_ITM_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TRK_ITM_ID, None)}
  }
  /// Track point timestamp (ISO 8601)
  #[inline]
  pub fn TS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TS, None)}
  }
  /// Track quality (0-15)
  #[inline]
  pub fn TRK_QUAL(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_TRK_QUAL, Some(0)).unwrap()}
  }
  /// Track point type
  #[inline]
  pub fn TRK_PT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TRK_PT_TYPE, None)}
  }
  /// Object identity assessment
  #[inline]
  pub fn OBJ_IDENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_OBJ_IDENT, None)}
  }
  /// Identity credibility (1-6)
  #[inline]
  pub fn IDENT_CRED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_IDENT_CRED, Some(0)).unwrap()}
  }
  /// Identity reliability (A-F)
  #[inline]
  pub fn IDENT_REL(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_IDENT_REL, Some(0)).unwrap()}
  }
  /// Identity amplification
  #[inline]
  pub fn IDENT_AMP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_IDENT_AMP, None)}
  }
  /// Track environment
  #[inline]
  pub fn ENVIRONMENT(&self) -> trackEnvironment {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<trackEnvironment>(TRK::VT_ENVIRONMENT, Some(trackEnvironment::SPACE)).unwrap()}
  }
  /// Environment confidence (0-1)
  #[inline]
  pub fn ENVIRONMENT_CONF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_ENVIRONMENT_CONF, Some(0.0)).unwrap()}
  }
  /// Track confidence (0-1)
  #[inline]
  pub fn TRK_CONF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_TRK_CONF, Some(0.0)).unwrap()}
  }
  /// Latitude (degrees)
  #[inline]
  pub fn LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_LAT, Some(0.0)).unwrap()}
  }
  /// Longitude (degrees)
  #[inline]
  pub fn LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_LON, Some(0.0)).unwrap()}
  }
  /// Altitude (km)
  #[inline]
  pub fn ALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_ALT, Some(0.0)).unwrap()}
  }
  /// Speed (km/s)
  #[inline]
  pub fn SPD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_SPD, Some(0.0)).unwrap()}
  }
  /// Heading (degrees from north)
  #[inline]
  pub fn HDNG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_HDNG, Some(0.0)).unwrap()}
  }
  /// Course (degrees from north)
  #[inline]
  pub fn COURSE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_COURSE, Some(0.0)).unwrap()}
  }
  /// Source types
  #[inline]
  pub fn SRC_TYPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TRK::VT_SRC_TYPS, None)}
  }
  /// Source identifiers
  #[inline]
  pub fn SRC_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TRK::VT_SRC_IDS, None)}
  }
  /// Call sign
  #[inline]
  pub fn CALL_SIGN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_CALL_SIGN, None)}
  }
  /// True if fused from multiple sources
  #[inline]
  pub fn MULTI_SOURCE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TRK::VT_MULTI_SOURCE, Some(false)).unwrap()}
  }
  /// J-series message type
  #[inline]
  pub fn J_SERIES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_J_SERIES, None)}
  }
  /// Force strength indicator
  #[inline]
  pub fn STRENGTH(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TRK::VT_STRENGTH, Some(0)).unwrap()}
  }
  /// Mode 1 code
  #[inline]
  pub fn M1(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TRK::VT_M1, Some(0)).unwrap()}
  }
  /// Mode 1 validity
  #[inline]
  pub fn M1V(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_M1V, Some(0)).unwrap()}
  }
  /// Mode 2 code
  #[inline]
  pub fn M2(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TRK::VT_M2, Some(0)).unwrap()}
  }
  /// Mode 2 validity
  #[inline]
  pub fn M2V(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_M2V, Some(0)).unwrap()}
  }
  /// Mode 3A code
  #[inline]
  pub fn M3A(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(TRK::VT_M3A, Some(0)).unwrap()}
  }
  /// Mode 3A validity
  #[inline]
  pub fn M3AV(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_M3AV, Some(0)).unwrap()}
  }
  /// Associated tags
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TRK::VT_TAGS, None)}
  }
  /// Start time for track data (ISO 8601)
  #[inline]
  pub fn TRACK_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TRK::VT_TRACK_START_TIME, None)}
  }
  /// Time interval between track points (seconds)
  #[inline]
  pub fn TRACK_STEP_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TRK::VT_TRACK_STEP_SIZE, Some(0.0)).unwrap()}
  }
  /// Number of components per point (default 3 for X, Y, Z)
  #[inline]
  pub fn TRACK_COMPONENTS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TRK::VT_TRACK_COMPONENTS, Some(3)).unwrap()}
  }
  /// ECEF position as flat array [X0, Y0, Z0, X1, Y1, Z1, ...]
  #[inline]
  pub fn ECEF_POS(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_ECEF_POS, None)}
  }
  /// ECEF velocity as flat array [VX0, VY0, VZ0, VX1, VY1, VZ1, ...]
  #[inline]
  pub fn ECEF_VEL(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_ECEF_VEL, None)}
  }
  /// ECEF acceleration as flat array [AX0, AY0, AZ0, AX1, AY1, AZ1, ...]
  #[inline]
  pub fn ECEF_ACC(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_ECEF_ACC, None)}
  }
  /// Local coordinate position as flat array
  #[inline]
  pub fn LC_POS(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_LC_POS, None)}
  }
  /// Local coordinate velocity as flat array
  #[inline]
  pub fn LC_VEL(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_LC_VEL, None)}
  }
  /// Local coordinate acceleration as flat array
  #[inline]
  pub fn LC_ACC(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_LC_ACC, None)}
  }
  /// Covariance data (21 elements per point for 6x6 lower triangular)
  #[inline]
  pub fn COV(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_COV, None)}
  }
  /// Error ellipse data (6 elements per point)
  #[inline]
  pub fn ERR_ELLP(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TRK::VT_ERR_ELLP, None)}
  }
}

impl flatbuffers::Verifiable for TRK<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CNTCT", Self::VT_CNTCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_TS", Self::VT_MSG_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSN_ID", Self::VT_MSN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ASSET_NAT", Self::VT_ASSET_NAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ASSET", Self::VT_ASSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SENSOR_ID", Self::VT_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_QUAL", Self::VT_SEN_QUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRK_ID", Self::VT_TRK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRK_NUM", Self::VT_TRK_NUM, false)?
     .visit_field::<TrkTrackStatus>("TRK_STAT", Self::VT_TRK_STAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_NAT", Self::VT_OBJ_NAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_ID", Self::VT_OBJ_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_TYPE", Self::VT_OBJ_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_SPEC", Self::VT_OBJ_SPEC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_PLAT", Self::VT_OBJ_PLAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_ACT", Self::VT_OBJ_ACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MOD_TYPE", Self::VT_MOD_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRK_ITM_ID", Self::VT_TRK_ITM_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TS", Self::VT_TS, false)?
     .visit_field::<u8>("TRK_QUAL", Self::VT_TRK_QUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRK_PT_TYPE", Self::VT_TRK_PT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJ_IDENT", Self::VT_OBJ_IDENT, false)?
     .visit_field::<u8>("IDENT_CRED", Self::VT_IDENT_CRED, false)?
     .visit_field::<u8>("IDENT_REL", Self::VT_IDENT_REL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IDENT_AMP", Self::VT_IDENT_AMP, false)?
     .visit_field::<trackEnvironment>("ENVIRONMENT", Self::VT_ENVIRONMENT, false)?
     .visit_field::<f64>("ENVIRONMENT_CONF", Self::VT_ENVIRONMENT_CONF, false)?
     .visit_field::<f64>("TRK_CONF", Self::VT_TRK_CONF, false)?
     .visit_field::<f64>("LAT", Self::VT_LAT, false)?
     .visit_field::<f64>("LON", Self::VT_LON, false)?
     .visit_field::<f64>("ALT", Self::VT_ALT, false)?
     .visit_field::<f64>("SPD", Self::VT_SPD, false)?
     .visit_field::<f64>("HDNG", Self::VT_HDNG, false)?
     .visit_field::<f64>("COURSE", Self::VT_COURSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_TYPS", Self::VT_SRC_TYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_IDS", Self::VT_SRC_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CALL_SIGN", Self::VT_CALL_SIGN, false)?
     .visit_field::<bool>("MULTI_SOURCE", Self::VT_MULTI_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("J_SERIES", Self::VT_J_SERIES, false)?
     .visit_field::<u16>("STRENGTH", Self::VT_STRENGTH, false)?
     .visit_field::<u16>("M1", Self::VT_M1, false)?
     .visit_field::<u8>("M1V", Self::VT_M1V, false)?
     .visit_field::<u16>("M2", Self::VT_M2, false)?
     .visit_field::<u8>("M2V", Self::VT_M2V, false)?
     .visit_field::<u16>("M3A", Self::VT_M3A, false)?
     .visit_field::<u8>("M3AV", Self::VT_M3AV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_START_TIME", Self::VT_TRACK_START_TIME, false)?
     .visit_field::<f64>("TRACK_STEP_SIZE", Self::VT_TRACK_STEP_SIZE, false)?
     .visit_field::<u8>("TRACK_COMPONENTS", Self::VT_TRACK_COMPONENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("ECEF_POS", Self::VT_ECEF_POS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("ECEF_VEL", Self::VT_ECEF_VEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("ECEF_ACC", Self::VT_ECEF_ACC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("LC_POS", Self::VT_LC_POS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("LC_VEL", Self::VT_LC_VEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("LC_ACC", Self::VT_LC_ACC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("COV", Self::VT_COV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("ERR_ELLP", Self::VT_ERR_ELLP, false)?
     .finish();
    Ok(())
  }
}
pub struct TRKArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CNTCT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_TS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSN_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ASSET_NAT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ASSET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEN_QUAL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRK_NUM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRK_STAT: TrkTrackStatus,
    pub OBJ_NAT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_SPEC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_PLAT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_ACT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MOD_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRK_ITM_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRK_QUAL: u8,
    pub TRK_PT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJ_IDENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IDENT_CRED: u8,
    pub IDENT_REL: u8,
    pub IDENT_AMP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENVIRONMENT: trackEnvironment,
    pub ENVIRONMENT_CONF: f64,
    pub TRK_CONF: f64,
    pub LAT: f64,
    pub LON: f64,
    pub ALT: f64,
    pub SPD: f64,
    pub HDNG: f64,
    pub COURSE: f64,
    pub SRC_TYPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SRC_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub CALL_SIGN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MULTI_SOURCE: bool,
    pub J_SERIES: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STRENGTH: u16,
    pub M1: u16,
    pub M1V: u8,
    pub M2: u16,
    pub M2V: u8,
    pub M3A: u16,
    pub M3AV: u8,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub TRACK_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACK_STEP_SIZE: f64,
    pub TRACK_COMPONENTS: u8,
    pub ECEF_POS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub ECEF_VEL: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub ECEF_ACC: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub LC_POS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub LC_VEL: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub LC_ACC: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub COV: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub ERR_ELLP: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for TRKArgs<'a> {
  #[inline]
  fn default() -> Self {
    TRKArgs {
      ID: None,
      CNTCT: None,
      MSG_TS: None,
      MSN_ID: None,
      ASSET_NAT: None,
      ASSET: None,
      SENSOR_ID: None,
      SEN_QUAL: None,
      TRK_ID: None,
      TRK_NUM: None,
      TRK_STAT: TrkTrackStatus::ACTIVE,
      OBJ_NAT: None,
      OBJ_ID: None,
      OBJ_TYPE: None,
      OBJ_SPEC: None,
      OBJ_PLAT: None,
      OBJ_ACT: None,
      MOD_TYPE: None,
      TRK_ITM_ID: None,
      TS: None,
      TRK_QUAL: 0,
      TRK_PT_TYPE: None,
      OBJ_IDENT: None,
      IDENT_CRED: 0,
      IDENT_REL: 0,
      IDENT_AMP: None,
      ENVIRONMENT: trackEnvironment::SPACE,
      ENVIRONMENT_CONF: 0.0,
      TRK_CONF: 0.0,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      SPD: 0.0,
      HDNG: 0.0,
      COURSE: 0.0,
      SRC_TYPS: None,
      SRC_IDS: None,
      CALL_SIGN: None,
      MULTI_SOURCE: false,
      J_SERIES: None,
      STRENGTH: 0,
      M1: 0,
      M1V: 0,
      M2: 0,
      M2V: 0,
      M3A: 0,
      M3AV: 0,
      TAGS: None,
      TRACK_START_TIME: None,
      TRACK_STEP_SIZE: 0.0,
      TRACK_COMPONENTS: 3,
      ECEF_POS: None,
      ECEF_VEL: None,
      ECEF_ACC: None,
      LC_POS: None,
      LC_VEL: None,
      LC_ACC: None,
      COV: None,
      ERR_ELLP: None,
    }
  }
}

pub struct TRKBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TRKBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ID, ID);
  }
  #[inline]
  pub fn add_CNTCT(&mut self, CNTCT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_CNTCT, CNTCT);
  }
  #[inline]
  pub fn add_MSG_TS(&mut self, MSG_TS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_MSG_TS, MSG_TS);
  }
  #[inline]
  pub fn add_MSN_ID(&mut self, MSN_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_MSN_ID, MSN_ID);
  }
  #[inline]
  pub fn add_ASSET_NAT(&mut self, ASSET_NAT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ASSET_NAT, ASSET_NAT);
  }
  #[inline]
  pub fn add_ASSET(&mut self, ASSET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ASSET, ASSET);
  }
  #[inline]
  pub fn add_SENSOR_ID(&mut self, SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_SENSOR_ID, SENSOR_ID);
  }
  #[inline]
  pub fn add_SEN_QUAL(&mut self, SEN_QUAL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_SEN_QUAL, SEN_QUAL);
  }
  #[inline]
  pub fn add_TRK_ID(&mut self, TRK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TRK_ID, TRK_ID);
  }
  #[inline]
  pub fn add_TRK_NUM(&mut self, TRK_NUM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TRK_NUM, TRK_NUM);
  }
  #[inline]
  pub fn add_TRK_STAT(&mut self, TRK_STAT: TrkTrackStatus) {
    self.fbb_.push_slot::<TrkTrackStatus>(TRK::VT_TRK_STAT, TRK_STAT, TrkTrackStatus::ACTIVE);
  }
  #[inline]
  pub fn add_OBJ_NAT(&mut self, OBJ_NAT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_NAT, OBJ_NAT);
  }
  #[inline]
  pub fn add_OBJ_ID(&mut self, OBJ_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_ID, OBJ_ID);
  }
  #[inline]
  pub fn add_OBJ_TYPE(&mut self, OBJ_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_TYPE, OBJ_TYPE);
  }
  #[inline]
  pub fn add_OBJ_SPEC(&mut self, OBJ_SPEC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_SPEC, OBJ_SPEC);
  }
  #[inline]
  pub fn add_OBJ_PLAT(&mut self, OBJ_PLAT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_PLAT, OBJ_PLAT);
  }
  #[inline]
  pub fn add_OBJ_ACT(&mut self, OBJ_ACT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_ACT, OBJ_ACT);
  }
  #[inline]
  pub fn add_MOD_TYPE(&mut self, MOD_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_MOD_TYPE, MOD_TYPE);
  }
  #[inline]
  pub fn add_TRK_ITM_ID(&mut self, TRK_ITM_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TRK_ITM_ID, TRK_ITM_ID);
  }
  #[inline]
  pub fn add_TS(&mut self, TS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TS, TS);
  }
  #[inline]
  pub fn add_TRK_QUAL(&mut self, TRK_QUAL: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_TRK_QUAL, TRK_QUAL, 0);
  }
  #[inline]
  pub fn add_TRK_PT_TYPE(&mut self, TRK_PT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TRK_PT_TYPE, TRK_PT_TYPE);
  }
  #[inline]
  pub fn add_OBJ_IDENT(&mut self, OBJ_IDENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_OBJ_IDENT, OBJ_IDENT);
  }
  #[inline]
  pub fn add_IDENT_CRED(&mut self, IDENT_CRED: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_IDENT_CRED, IDENT_CRED, 0);
  }
  #[inline]
  pub fn add_IDENT_REL(&mut self, IDENT_REL: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_IDENT_REL, IDENT_REL, 0);
  }
  #[inline]
  pub fn add_IDENT_AMP(&mut self, IDENT_AMP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_IDENT_AMP, IDENT_AMP);
  }
  #[inline]
  pub fn add_ENVIRONMENT(&mut self, ENVIRONMENT: trackEnvironment) {
    self.fbb_.push_slot::<trackEnvironment>(TRK::VT_ENVIRONMENT, ENVIRONMENT, trackEnvironment::SPACE);
  }
  #[inline]
  pub fn add_ENVIRONMENT_CONF(&mut self, ENVIRONMENT_CONF: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_ENVIRONMENT_CONF, ENVIRONMENT_CONF, 0.0);
  }
  #[inline]
  pub fn add_TRK_CONF(&mut self, TRK_CONF: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_TRK_CONF, TRK_CONF, 0.0);
  }
  #[inline]
  pub fn add_LAT(&mut self, LAT: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_LAT, LAT, 0.0);
  }
  #[inline]
  pub fn add_LON(&mut self, LON: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_LON, LON, 0.0);
  }
  #[inline]
  pub fn add_ALT(&mut self, ALT: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_ALT, ALT, 0.0);
  }
  #[inline]
  pub fn add_SPD(&mut self, SPD: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_SPD, SPD, 0.0);
  }
  #[inline]
  pub fn add_HDNG(&mut self, HDNG: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_HDNG, HDNG, 0.0);
  }
  #[inline]
  pub fn add_COURSE(&mut self, COURSE: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_COURSE, COURSE, 0.0);
  }
  #[inline]
  pub fn add_SRC_TYPS(&mut self, SRC_TYPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_SRC_TYPS, SRC_TYPS);
  }
  #[inline]
  pub fn add_SRC_IDS(&mut self, SRC_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_SRC_IDS, SRC_IDS);
  }
  #[inline]
  pub fn add_CALL_SIGN(&mut self, CALL_SIGN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_CALL_SIGN, CALL_SIGN);
  }
  #[inline]
  pub fn add_MULTI_SOURCE(&mut self, MULTI_SOURCE: bool) {
    self.fbb_.push_slot::<bool>(TRK::VT_MULTI_SOURCE, MULTI_SOURCE, false);
  }
  #[inline]
  pub fn add_J_SERIES(&mut self, J_SERIES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_J_SERIES, J_SERIES);
  }
  #[inline]
  pub fn add_STRENGTH(&mut self, STRENGTH: u16) {
    self.fbb_.push_slot::<u16>(TRK::VT_STRENGTH, STRENGTH, 0);
  }
  #[inline]
  pub fn add_M1(&mut self, M1: u16) {
    self.fbb_.push_slot::<u16>(TRK::VT_M1, M1, 0);
  }
  #[inline]
  pub fn add_M1V(&mut self, M1V: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_M1V, M1V, 0);
  }
  #[inline]
  pub fn add_M2(&mut self, M2: u16) {
    self.fbb_.push_slot::<u16>(TRK::VT_M2, M2, 0);
  }
  #[inline]
  pub fn add_M2V(&mut self, M2V: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_M2V, M2V, 0);
  }
  #[inline]
  pub fn add_M3A(&mut self, M3A: u16) {
    self.fbb_.push_slot::<u16>(TRK::VT_M3A, M3A, 0);
  }
  #[inline]
  pub fn add_M3AV(&mut self, M3AV: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_M3AV, M3AV, 0);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn add_TRACK_START_TIME(&mut self, TRACK_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_TRACK_START_TIME, TRACK_START_TIME);
  }
  #[inline]
  pub fn add_TRACK_STEP_SIZE(&mut self, TRACK_STEP_SIZE: f64) {
    self.fbb_.push_slot::<f64>(TRK::VT_TRACK_STEP_SIZE, TRACK_STEP_SIZE, 0.0);
  }
  #[inline]
  pub fn add_TRACK_COMPONENTS(&mut self, TRACK_COMPONENTS: u8) {
    self.fbb_.push_slot::<u8>(TRK::VT_TRACK_COMPONENTS, TRACK_COMPONENTS, 3);
  }
  #[inline]
  pub fn add_ECEF_POS(&mut self, ECEF_POS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ECEF_POS, ECEF_POS);
  }
  #[inline]
  pub fn add_ECEF_VEL(&mut self, ECEF_VEL: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ECEF_VEL, ECEF_VEL);
  }
  #[inline]
  pub fn add_ECEF_ACC(&mut self, ECEF_ACC: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ECEF_ACC, ECEF_ACC);
  }
  #[inline]
  pub fn add_LC_POS(&mut self, LC_POS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_LC_POS, LC_POS);
  }
  #[inline]
  pub fn add_LC_VEL(&mut self, LC_VEL: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_LC_VEL, LC_VEL);
  }
  #[inline]
  pub fn add_LC_ACC(&mut self, LC_ACC: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_LC_ACC, LC_ACC);
  }
  #[inline]
  pub fn add_COV(&mut self, COV: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_COV, COV);
  }
  #[inline]
  pub fn add_ERR_ELLP(&mut self, ERR_ELLP: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TRK::VT_ERR_ELLP, ERR_ELLP);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TRKBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TRKBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TRK<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TRK<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TRK");
      ds.field("ID", &self.ID());
      ds.field("CNTCT", &self.CNTCT());
      ds.field("MSG_TS", &self.MSG_TS());
      ds.field("MSN_ID", &self.MSN_ID());
      ds.field("ASSET_NAT", &self.ASSET_NAT());
      ds.field("ASSET", &self.ASSET());
      ds.field("SENSOR_ID", &self.SENSOR_ID());
      ds.field("SEN_QUAL", &self.SEN_QUAL());
      ds.field("TRK_ID", &self.TRK_ID());
      ds.field("TRK_NUM", &self.TRK_NUM());
      ds.field("TRK_STAT", &self.TRK_STAT());
      ds.field("OBJ_NAT", &self.OBJ_NAT());
      ds.field("OBJ_ID", &self.OBJ_ID());
      ds.field("OBJ_TYPE", &self.OBJ_TYPE());
      ds.field("OBJ_SPEC", &self.OBJ_SPEC());
      ds.field("OBJ_PLAT", &self.OBJ_PLAT());
      ds.field("OBJ_ACT", &self.OBJ_ACT());
      ds.field("MOD_TYPE", &self.MOD_TYPE());
      ds.field("TRK_ITM_ID", &self.TRK_ITM_ID());
      ds.field("TS", &self.TS());
      ds.field("TRK_QUAL", &self.TRK_QUAL());
      ds.field("TRK_PT_TYPE", &self.TRK_PT_TYPE());
      ds.field("OBJ_IDENT", &self.OBJ_IDENT());
      ds.field("IDENT_CRED", &self.IDENT_CRED());
      ds.field("IDENT_REL", &self.IDENT_REL());
      ds.field("IDENT_AMP", &self.IDENT_AMP());
      ds.field("ENVIRONMENT", &self.ENVIRONMENT());
      ds.field("ENVIRONMENT_CONF", &self.ENVIRONMENT_CONF());
      ds.field("TRK_CONF", &self.TRK_CONF());
      ds.field("LAT", &self.LAT());
      ds.field("LON", &self.LON());
      ds.field("ALT", &self.ALT());
      ds.field("SPD", &self.SPD());
      ds.field("HDNG", &self.HDNG());
      ds.field("COURSE", &self.COURSE());
      ds.field("SRC_TYPS", &self.SRC_TYPS());
      ds.field("SRC_IDS", &self.SRC_IDS());
      ds.field("CALL_SIGN", &self.CALL_SIGN());
      ds.field("MULTI_SOURCE", &self.MULTI_SOURCE());
      ds.field("J_SERIES", &self.J_SERIES());
      ds.field("STRENGTH", &self.STRENGTH());
      ds.field("M1", &self.M1());
      ds.field("M1V", &self.M1V());
      ds.field("M2", &self.M2());
      ds.field("M2V", &self.M2V());
      ds.field("M3A", &self.M3A());
      ds.field("M3AV", &self.M3AV());
      ds.field("TAGS", &self.TAGS());
      ds.field("TRACK_START_TIME", &self.TRACK_START_TIME());
      ds.field("TRACK_STEP_SIZE", &self.TRACK_STEP_SIZE());
      ds.field("TRACK_COMPONENTS", &self.TRACK_COMPONENTS());
      ds.field("ECEF_POS", &self.ECEF_POS());
      ds.field("ECEF_VEL", &self.ECEF_VEL());
      ds.field("ECEF_ACC", &self.ECEF_ACC());
      ds.field("LC_POS", &self.LC_POS());
      ds.field("LC_VEL", &self.LC_VEL());
      ds.field("LC_ACC", &self.LC_ACC());
      ds.field("COV", &self.COV());
      ds.field("ERR_ELLP", &self.ERR_ELLP());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TRKT {
  pub ID: Option<String>,
  pub CNTCT: Option<String>,
  pub MSG_TS: Option<String>,
  pub MSN_ID: Option<String>,
  pub ASSET_NAT: Option<String>,
  pub ASSET: Option<String>,
  pub SENSOR_ID: Option<String>,
  pub SEN_QUAL: Option<String>,
  pub TRK_ID: Option<String>,
  pub TRK_NUM: Option<String>,
  pub TRK_STAT: TrkTrackStatus,
  pub OBJ_NAT: Option<String>,
  pub OBJ_ID: Option<String>,
  pub OBJ_TYPE: Option<String>,
  pub OBJ_SPEC: Option<String>,
  pub OBJ_PLAT: Option<String>,
  pub OBJ_ACT: Option<String>,
  pub MOD_TYPE: Option<String>,
  pub TRK_ITM_ID: Option<String>,
  pub TS: Option<String>,
  pub TRK_QUAL: u8,
  pub TRK_PT_TYPE: Option<String>,
  pub OBJ_IDENT: Option<String>,
  pub IDENT_CRED: u8,
  pub IDENT_REL: u8,
  pub IDENT_AMP: Option<String>,
  pub ENVIRONMENT: trackEnvironment,
  pub ENVIRONMENT_CONF: f64,
  pub TRK_CONF: f64,
  pub LAT: f64,
  pub LON: f64,
  pub ALT: f64,
  pub SPD: f64,
  pub HDNG: f64,
  pub COURSE: f64,
  pub SRC_TYPS: Option<Vec<String>>,
  pub SRC_IDS: Option<Vec<String>>,
  pub CALL_SIGN: Option<String>,
  pub MULTI_SOURCE: bool,
  pub J_SERIES: Option<String>,
  pub STRENGTH: u16,
  pub M1: u16,
  pub M1V: u8,
  pub M2: u16,
  pub M2V: u8,
  pub M3A: u16,
  pub M3AV: u8,
  pub TAGS: Option<Vec<String>>,
  pub TRACK_START_TIME: Option<String>,
  pub TRACK_STEP_SIZE: f64,
  pub TRACK_COMPONENTS: u8,
  pub ECEF_POS: Option<Vec<f64>>,
  pub ECEF_VEL: Option<Vec<f64>>,
  pub ECEF_ACC: Option<Vec<f64>>,
  pub LC_POS: Option<Vec<f64>>,
  pub LC_VEL: Option<Vec<f64>>,
  pub LC_ACC: Option<Vec<f64>>,
  pub COV: Option<Vec<f64>>,
  pub ERR_ELLP: Option<Vec<f64>>,
}
impl Default for TRKT {
  fn default() -> Self {
    Self {
      ID: None,
      CNTCT: None,
      MSG_TS: None,
      MSN_ID: None,
      ASSET_NAT: None,
      ASSET: None,
      SENSOR_ID: None,
      SEN_QUAL: None,
      TRK_ID: None,
      TRK_NUM: None,
      TRK_STAT: TrkTrackStatus::ACTIVE,
      OBJ_NAT: None,
      OBJ_ID: None,
      OBJ_TYPE: None,
      OBJ_SPEC: None,
      OBJ_PLAT: None,
      OBJ_ACT: None,
      MOD_TYPE: None,
      TRK_ITM_ID: None,
      TS: None,
      TRK_QUAL: 0,
      TRK_PT_TYPE: None,
      OBJ_IDENT: None,
      IDENT_CRED: 0,
      IDENT_REL: 0,
      IDENT_AMP: None,
      ENVIRONMENT: trackEnvironment::SPACE,
      ENVIRONMENT_CONF: 0.0,
      TRK_CONF: 0.0,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      SPD: 0.0,
      HDNG: 0.0,
      COURSE: 0.0,
      SRC_TYPS: None,
      SRC_IDS: None,
      CALL_SIGN: None,
      MULTI_SOURCE: false,
      J_SERIES: None,
      STRENGTH: 0,
      M1: 0,
      M1V: 0,
      M2: 0,
      M2V: 0,
      M3A: 0,
      M3AV: 0,
      TAGS: None,
      TRACK_START_TIME: None,
      TRACK_STEP_SIZE: 0.0,
      TRACK_COMPONENTS: 3,
      ECEF_POS: None,
      ECEF_VEL: None,
      ECEF_ACC: None,
      LC_POS: None,
      LC_VEL: None,
      LC_ACC: None,
      COV: None,
      ERR_ELLP: None,
    }
  }
}
impl TRKT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TRK<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CNTCT = self.CNTCT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_TS = self.MSG_TS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSN_ID = self.MSN_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ASSET_NAT = self.ASSET_NAT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ASSET = self.ASSET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENSOR_ID = self.SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEN_QUAL = self.SEN_QUAL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRK_ID = self.TRK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRK_NUM = self.TRK_NUM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRK_STAT = self.TRK_STAT;
    let OBJ_NAT = self.OBJ_NAT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_ID = self.OBJ_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_TYPE = self.OBJ_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_SPEC = self.OBJ_SPEC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_PLAT = self.OBJ_PLAT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_ACT = self.OBJ_ACT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MOD_TYPE = self.MOD_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRK_ITM_ID = self.TRK_ITM_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TS = self.TS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRK_QUAL = self.TRK_QUAL;
    let TRK_PT_TYPE = self.TRK_PT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJ_IDENT = self.OBJ_IDENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IDENT_CRED = self.IDENT_CRED;
    let IDENT_REL = self.IDENT_REL;
    let IDENT_AMP = self.IDENT_AMP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENVIRONMENT = self.ENVIRONMENT;
    let ENVIRONMENT_CONF = self.ENVIRONMENT_CONF;
    let TRK_CONF = self.TRK_CONF;
    let LAT = self.LAT;
    let LON = self.LON;
    let ALT = self.ALT;
    let SPD = self.SPD;
    let HDNG = self.HDNG;
    let COURSE = self.COURSE;
    let SRC_TYPS = self.SRC_TYPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SRC_IDS = self.SRC_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let CALL_SIGN = self.CALL_SIGN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MULTI_SOURCE = self.MULTI_SOURCE;
    let J_SERIES = self.J_SERIES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STRENGTH = self.STRENGTH;
    let M1 = self.M1;
    let M1V = self.M1V;
    let M2 = self.M2;
    let M2V = self.M2V;
    let M3A = self.M3A;
    let M3AV = self.M3AV;
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let TRACK_START_TIME = self.TRACK_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACK_STEP_SIZE = self.TRACK_STEP_SIZE;
    let TRACK_COMPONENTS = self.TRACK_COMPONENTS;
    let ECEF_POS = self.ECEF_POS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ECEF_VEL = self.ECEF_VEL.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ECEF_ACC = self.ECEF_ACC.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let LC_POS = self.LC_POS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let LC_VEL = self.LC_VEL.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let LC_ACC = self.LC_ACC.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let COV = self.COV.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ERR_ELLP = self.ERR_ELLP.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    TRK::create(_fbb, &TRKArgs{
      ID,
      CNTCT,
      MSG_TS,
      MSN_ID,
      ASSET_NAT,
      ASSET,
      SENSOR_ID,
      SEN_QUAL,
      TRK_ID,
      TRK_NUM,
      TRK_STAT,
      OBJ_NAT,
      OBJ_ID,
      OBJ_TYPE,
      OBJ_SPEC,
      OBJ_PLAT,
      OBJ_ACT,
      MOD_TYPE,
      TRK_ITM_ID,
      TS,
      TRK_QUAL,
      TRK_PT_TYPE,
      OBJ_IDENT,
      IDENT_CRED,
      IDENT_REL,
      IDENT_AMP,
      ENVIRONMENT,
      ENVIRONMENT_CONF,
      TRK_CONF,
      LAT,
      LON,
      ALT,
      SPD,
      HDNG,
      COURSE,
      SRC_TYPS,
      SRC_IDS,
      CALL_SIGN,
      MULTI_SOURCE,
      J_SERIES,
      STRENGTH,
      M1,
      M1V,
      M2,
      M2V,
      M3A,
      M3AV,
      TAGS,
      TRACK_START_TIME,
      TRACK_STEP_SIZE,
      TRACK_COMPONENTS,
      ECEF_POS,
      ECEF_VEL,
      ECEF_ACC,
      LC_POS,
      LC_VEL,
      LC_ACC,
      COV,
      ERR_ELLP,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TRK`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TRK_unchecked`.
pub fn root_as_TRK(buf: &[u8]) -> Result<TRK, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TRK>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TRK` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_TRK_unchecked`.
pub fn size_prefixed_root_as_TRK(buf: &[u8]) -> Result<TRK, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TRK>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TRK` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TRK_unchecked`.
pub fn root_as_TRK_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRK<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TRK<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TRK` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TRK_unchecked`.
pub fn size_prefixed_root_as_TRK_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TRK<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TRK<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TRK and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TRK`.
pub unsafe fn root_as_TRK_unchecked(buf: &[u8]) -> TRK {
  flatbuffers::root_unchecked::<TRK>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TRK and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TRK`.
pub unsafe fn size_prefixed_root_as_TRK_unchecked(buf: &[u8]) -> TRK {
  flatbuffers::size_prefixed_root_unchecked::<TRK>(buf)
}
pub const TRK_IDENTIFIER: &str = "$TRK";

#[inline]
pub fn TRK_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRK_IDENTIFIER, false)
}

#[inline]
pub fn TRK_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TRK_IDENTIFIER, true)
}

#[inline]
pub fn finish_TRK_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TRK<'a>>) {
  fbb.finish(root, Some(TRK_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_TRK_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TRK<'a>>) {
  fbb.finish_size_prefixed(root, Some(TRK_IDENTIFIER));
}
