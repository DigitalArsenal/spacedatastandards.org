// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OBJECT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OBJECT_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OBJECT_TYPE: [objectType; 4] = [
  objectType::PAYLOAD,
  objectType::ROCKET_BODY,
  objectType::DEBRIS,
  objectType::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct objectType(pub i8);
#[allow(non_upper_case_globals)]
impl objectType {
  ///0
  pub const PAYLOAD: Self = Self(0);
  ///1
  pub const ROCKET_BODY: Self = Self(1);
  ///2
  pub const DEBRIS: Self = Self(2);
  ///3
  pub const UNKNOWN: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PAYLOAD,
    Self::ROCKET_BODY,
    Self::DEBRIS,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PAYLOAD => Some("PAYLOAD"),
      Self::ROCKET_BODY => Some("ROCKET_BODY"),
      Self::DEBRIS => Some("DEBRIS"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for objectType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for objectType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for objectType {
    type Output = objectType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for objectType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for objectType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for objectType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OPS_STATUS_CODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OPS_STATUS_CODE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OPS_STATUS_CODE: [opsStatusCode; 8] = [
  opsStatusCode::OPERATIONAL,
  opsStatusCode::NONOPERATIONAL,
  opsStatusCode::PARTIALLY_OPERATIONAL,
  opsStatusCode::BACKUP_STANDBY,
  opsStatusCode::SPARE,
  opsStatusCode::EXTENDED_MISSION,
  opsStatusCode::DECAYED,
  opsStatusCode::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct opsStatusCode(pub i8);
#[allow(non_upper_case_globals)]
impl opsStatusCode {
  ///+
  pub const OPERATIONAL: Self = Self(0);
  ///-
  pub const NONOPERATIONAL: Self = Self(1);
  ///P
  pub const PARTIALLY_OPERATIONAL: Self = Self(2);
  ///B
  pub const BACKUP_STANDBY: Self = Self(3);
  ///S
  pub const SPARE: Self = Self(4);
  ///X
  pub const EXTENDED_MISSION: Self = Self(5);
  ///D
  pub const DECAYED: Self = Self(6);
  ///?
  pub const UNKNOWN: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPERATIONAL,
    Self::NONOPERATIONAL,
    Self::PARTIALLY_OPERATIONAL,
    Self::BACKUP_STANDBY,
    Self::SPARE,
    Self::EXTENDED_MISSION,
    Self::DECAYED,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPERATIONAL => Some("OPERATIONAL"),
      Self::NONOPERATIONAL => Some("NONOPERATIONAL"),
      Self::PARTIALLY_OPERATIONAL => Some("PARTIALLY_OPERATIONAL"),
      Self::BACKUP_STANDBY => Some("BACKUP_STANDBY"),
      Self::SPARE => Some("SPARE"),
      Self::EXTENDED_MISSION => Some("EXTENDED_MISSION"),
      Self::DECAYED => Some("DECAYED"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for opsStatusCode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for opsStatusCode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for opsStatusCode {
    type Output = opsStatusCode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for opsStatusCode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for opsStatusCode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for opsStatusCode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_STATUS_CODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_STATUS_CODE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_STATUS_CODE: [dataStatusCode; 4] = [
  dataStatusCode::NO_CURRENT_ELEMENTS,
  dataStatusCode::NO_INITIAL_ELEMENTS,
  dataStatusCode::NO_ELEMENTS_AVAILABLE,
  dataStatusCode::OK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct dataStatusCode(pub i8);
#[allow(non_upper_case_globals)]
impl dataStatusCode {
  ///NCE
  pub const NO_CURRENT_ELEMENTS: Self = Self(0);
  ///NIE
  pub const NO_INITIAL_ELEMENTS: Self = Self(1);
  ///NEA
  pub const NO_ELEMENTS_AVAILABLE: Self = Self(2);
  ///OK
  pub const OK: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NO_CURRENT_ELEMENTS,
    Self::NO_INITIAL_ELEMENTS,
    Self::NO_ELEMENTS_AVAILABLE,
    Self::OK,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NO_CURRENT_ELEMENTS => Some("NO_CURRENT_ELEMENTS"),
      Self::NO_INITIAL_ELEMENTS => Some("NO_INITIAL_ELEMENTS"),
      Self::NO_ELEMENTS_AVAILABLE => Some("NO_ELEMENTS_AVAILABLE"),
      Self::OK => Some("OK"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for dataStatusCode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for dataStatusCode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for dataStatusCode {
    type Output = dataStatusCode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for dataStatusCode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for dataStatusCode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for dataStatusCode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ORBIT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ORBIT_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ORBIT_TYPE: [orbitType; 5] = [
  orbitType::ORBIT,
  orbitType::LANDING,
  orbitType::IMPACT,
  orbitType::DOCKED,
  orbitType::ROUNDTRIP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct orbitType(pub i8);
#[allow(non_upper_case_globals)]
impl orbitType {
  ///0
  pub const ORBIT: Self = Self(0);
  ///1
  pub const LANDING: Self = Self(1);
  ///2
  pub const IMPACT: Self = Self(2);
  ///3
  pub const DOCKED: Self = Self(3);
  ///4
  pub const ROUNDTRIP: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ORBIT,
    Self::LANDING,
    Self::IMPACT,
    Self::DOCKED,
    Self::ROUNDTRIP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ORBIT => Some("ORBIT"),
      Self::LANDING => Some("LANDING"),
      Self::IMPACT => Some("IMPACT"),
      Self::DOCKED => Some("DOCKED"),
      Self::ROUNDTRIP => Some("ROUNDTRIP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for orbitType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for orbitType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for orbitType {
    type Output = orbitType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for orbitType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for orbitType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for orbitType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MASS_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MASS_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MASS_TYPE: [massType; 2] = [
  massType::DRY,
  massType::WET,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct massType(pub i8);
#[allow(non_upper_case_globals)]
impl massType {
  pub const DRY: Self = Self(0);
  pub const WET: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DRY,
    Self::WET,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DRY => Some("DRY"),
      Self::WET => Some("WET"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for massType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for massType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for massType {
    type Output = massType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for massType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for massType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for massType {}
pub enum CATOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Catalog Entity Message
pub struct CAT<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CAT<'a> {
  type Inner = CAT<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CAT<'a> {
  pub const VT_OBJECT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_NORAD_CAT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_OBJECT_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_OPS_STATUS_CODE: flatbuffers::VOffsetT = 12;
  pub const VT_OWNER: flatbuffers::VOffsetT = 14;
  pub const VT_LAUNCH_DATE: flatbuffers::VOffsetT = 16;
  pub const VT_LAUNCH_SITE: flatbuffers::VOffsetT = 18;
  pub const VT_DECAY_DATE: flatbuffers::VOffsetT = 20;
  pub const VT_PERIOD: flatbuffers::VOffsetT = 22;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 24;
  pub const VT_APOGEE: flatbuffers::VOffsetT = 26;
  pub const VT_PERIGEE: flatbuffers::VOffsetT = 28;
  pub const VT_RCS: flatbuffers::VOffsetT = 30;
  pub const VT_DATA_STATUS_CODE: flatbuffers::VOffsetT = 32;
  pub const VT_ORBIT_CENTER: flatbuffers::VOffsetT = 34;
  pub const VT_ORBIT_TYPE: flatbuffers::VOffsetT = 36;
  pub const VT_DEPLOYMENT_DATE: flatbuffers::VOffsetT = 38;
  pub const VT_MANEUVERABLE: flatbuffers::VOffsetT = 40;
  pub const VT_SIZE: flatbuffers::VOffsetT = 42;
  pub const VT_MASS: flatbuffers::VOffsetT = 44;
  pub const VT_MASS_TYPE: flatbuffers::VOffsetT = 46;
  pub const VT_PAYLOADS: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CAT { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CATArgs<'args>
  ) -> flatbuffers::WIPOffset<CAT<'bldr>> {
    let mut builder = CATBuilder::new(_fbb);
    builder.add_MASS(args.MASS);
    builder.add_SIZE(args.SIZE);
    builder.add_RCS(args.RCS);
    builder.add_PERIGEE(args.PERIGEE);
    builder.add_APOGEE(args.APOGEE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_PERIOD(args.PERIOD);
    if let Some(x) = args.PAYLOADS { builder.add_PAYLOADS(x); }
    if let Some(x) = args.DEPLOYMENT_DATE { builder.add_DEPLOYMENT_DATE(x); }
    if let Some(x) = args.ORBIT_CENTER { builder.add_ORBIT_CENTER(x); }
    if let Some(x) = args.DECAY_DATE { builder.add_DECAY_DATE(x); }
    if let Some(x) = args.LAUNCH_SITE { builder.add_LAUNCH_SITE(x); }
    if let Some(x) = args.LAUNCH_DATE { builder.add_LAUNCH_DATE(x); }
    if let Some(x) = args.OWNER { builder.add_OWNER(x); }
    builder.add_NORAD_CAT_ID(args.NORAD_CAT_ID);
    if let Some(x) = args.OBJECT_ID { builder.add_OBJECT_ID(x); }
    if let Some(x) = args.OBJECT_NAME { builder.add_OBJECT_NAME(x); }
    builder.add_MASS_TYPE(args.MASS_TYPE);
    builder.add_MANEUVERABLE(args.MANEUVERABLE);
    builder.add_ORBIT_TYPE(args.ORBIT_TYPE);
    builder.add_DATA_STATUS_CODE(args.DATA_STATUS_CODE);
    builder.add_OPS_STATUS_CODE(args.OPS_STATUS_CODE);
    builder.add_OBJECT_TYPE(args.OBJECT_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> CATT {
    let OBJECT_NAME = self.OBJECT_NAME().map(|x| {
      x.to_string()
    });
    let OBJECT_ID = self.OBJECT_ID().map(|x| {
      x.to_string()
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID();
    let OBJECT_TYPE = self.OBJECT_TYPE();
    let OPS_STATUS_CODE = self.OPS_STATUS_CODE();
    let OWNER = self.OWNER().map(|x| {
      x.to_string()
    });
    let LAUNCH_DATE = self.LAUNCH_DATE().map(|x| {
      x.to_string()
    });
    let LAUNCH_SITE = self.LAUNCH_SITE().map(|x| {
      x.to_string()
    });
    let DECAY_DATE = self.DECAY_DATE().map(|x| {
      x.to_string()
    });
    let PERIOD = self.PERIOD();
    let INCLINATION = self.INCLINATION();
    let APOGEE = self.APOGEE();
    let PERIGEE = self.PERIGEE();
    let RCS = self.RCS();
    let DATA_STATUS_CODE = self.DATA_STATUS_CODE();
    let ORBIT_CENTER = self.ORBIT_CENTER().map(|x| {
      x.to_string()
    });
    let ORBIT_TYPE = self.ORBIT_TYPE();
    let DEPLOYMENT_DATE = self.DEPLOYMENT_DATE().map(|x| {
      x.to_string()
    });
    let MANEUVERABLE = self.MANEUVERABLE();
    let SIZE = self.SIZE();
    let MASS = self.MASS();
    let MASS_TYPE = self.MASS_TYPE();
    let PAYLOADS = self.PAYLOADS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    CATT {
      OBJECT_NAME,
      OBJECT_ID,
      NORAD_CAT_ID,
      OBJECT_TYPE,
      OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      PERIOD,
      INCLINATION,
      APOGEE,
      PERIGEE,
      RCS,
      DATA_STATUS_CODE,
      ORBIT_CENTER,
      ORBIT_TYPE,
      DEPLOYMENT_DATE,
      MANEUVERABLE,
      SIZE,
      MASS,
      MASS_TYPE,
      PAYLOADS,
    }
  }

  /// Satellite Name(s)
  #[inline]
  pub fn OBJECT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_OBJECT_NAME, None)}
  }
  /// International Designator (YYYY-NNNAAA)
  #[inline]
  pub fn OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_OBJECT_ID, None)}
  }
  /// NORAD Catalog Number
  #[inline]
  pub fn NORAD_CAT_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CAT::VT_NORAD_CAT_ID, Some(0)).unwrap()}
  }
  /// Object type (Payload, Rocket body, Debris, Unknown)
  #[inline]
  pub fn OBJECT_TYPE(&self) -> objectType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<objectType>(CAT::VT_OBJECT_TYPE, Some(objectType::UNKNOWN)).unwrap()}
  }
  /// Operational Status Code
  #[inline]
  pub fn OPS_STATUS_CODE(&self) -> opsStatusCode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<opsStatusCode>(CAT::VT_OPS_STATUS_CODE, Some(opsStatusCode::UNKNOWN)).unwrap()}
  }
  /// Ownership, typically country or company
  #[inline]
  pub fn OWNER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_OWNER, None)}
  }
  /// Launch Date [year-month-day] (ISO 8601)
  #[inline]
  pub fn LAUNCH_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_LAUNCH_DATE, None)}
  }
  /// Launch Site
  #[inline]
  pub fn LAUNCH_SITE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_LAUNCH_SITE, None)}
  }
  /// Decay Date, if applicable [year-month-day] (ISO 8601)
  #[inline]
  pub fn DECAY_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_DECAY_DATE, None)}
  }
  /// Orbital period [minutes]
  #[inline]
  pub fn PERIOD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_PERIOD, Some(0.0)).unwrap()}
  }
  /// Inclination [degrees]
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  /// Apogee Altitude [kilometers]
  #[inline]
  pub fn APOGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_APOGEE, Some(0.0)).unwrap()}
  }
  /// Perigee Altitude [kilometers]
  #[inline]
  pub fn PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_PERIGEE, Some(0.0)).unwrap()}
  }
  /// Radar Cross Section [meters2]; blank if no data available
  #[inline]
  pub fn RCS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_RCS, Some(0.0)).unwrap()}
  }
  /// Data status code; blank otherwise
  #[inline]
  pub fn DATA_STATUS_CODE(&self) -> dataStatusCode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<dataStatusCode>(CAT::VT_DATA_STATUS_CODE, Some(dataStatusCode::NO_CURRENT_ELEMENTS)).unwrap()}
  }
  /// Orbit center
  #[inline]
  pub fn ORBIT_CENTER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_ORBIT_CENTER, None)}
  }
  /// Orbit type (Orbit, Landing, Impact, Docked to RSO, roundtrip)
  #[inline]
  pub fn ORBIT_TYPE(&self) -> orbitType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<orbitType>(CAT::VT_ORBIT_TYPE, Some(orbitType::ORBIT)).unwrap()}
  }
  /// Deployment Date [year-month-day] (ISO 8601)
  #[inline]
  pub fn DEPLOYMENT_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CAT::VT_DEPLOYMENT_DATE, None)}
  }
  /// Indicates if the object is maneuverable
  #[inline]
  pub fn MANEUVERABLE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CAT::VT_MANEUVERABLE, Some(false)).unwrap()}
  }
  /// Size [meters]; blank if no data available
  #[inline]
  pub fn SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_SIZE, Some(0.0)).unwrap()}
  }
  /// Mass [kilograms]; blank if no data available
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CAT::VT_MASS, Some(0.0)).unwrap()}
  }
  /// Mass type (Dry, Wet)
  #[inline]
  pub fn MASS_TYPE(&self) -> massType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<massType>(CAT::VT_MASS_TYPE, Some(massType::DRY)).unwrap()}
  }
  /// Vector of PAYLOADS
  #[inline]
  pub fn PAYLOADS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PLD<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PLD>>>>(CAT::VT_PAYLOADS, None)}
  }
}

impl flatbuffers::Verifiable for CAT<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_NAME", Self::VT_OBJECT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_ID", Self::VT_OBJECT_ID, false)?
     .visit_field::<u32>("NORAD_CAT_ID", Self::VT_NORAD_CAT_ID, false)?
     .visit_field::<objectType>("OBJECT_TYPE", Self::VT_OBJECT_TYPE, false)?
     .visit_field::<opsStatusCode>("OPS_STATUS_CODE", Self::VT_OPS_STATUS_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OWNER", Self::VT_OWNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_DATE", Self::VT_LAUNCH_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_SITE", Self::VT_LAUNCH_SITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DECAY_DATE", Self::VT_DECAY_DATE, false)?
     .visit_field::<f64>("PERIOD", Self::VT_PERIOD, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("APOGEE", Self::VT_APOGEE, false)?
     .visit_field::<f64>("PERIGEE", Self::VT_PERIGEE, false)?
     .visit_field::<f64>("RCS", Self::VT_RCS, false)?
     .visit_field::<dataStatusCode>("DATA_STATUS_CODE", Self::VT_DATA_STATUS_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORBIT_CENTER", Self::VT_ORBIT_CENTER, false)?
     .visit_field::<orbitType>("ORBIT_TYPE", Self::VT_ORBIT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DEPLOYMENT_DATE", Self::VT_DEPLOYMENT_DATE, false)?
     .visit_field::<bool>("MANEUVERABLE", Self::VT_MANEUVERABLE, false)?
     .visit_field::<f64>("SIZE", Self::VT_SIZE, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<massType>("MASS_TYPE", Self::VT_MASS_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PLD>>>>("PAYLOADS", Self::VT_PAYLOADS, false)?
     .finish();
    Ok(())
  }
}
pub struct CATArgs<'a> {
    pub OBJECT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NORAD_CAT_ID: u32,
    pub OBJECT_TYPE: objectType,
    pub OPS_STATUS_CODE: opsStatusCode,
    pub OWNER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_SITE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DECAY_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PERIOD: f64,
    pub INCLINATION: f64,
    pub APOGEE: f64,
    pub PERIGEE: f64,
    pub RCS: f64,
    pub DATA_STATUS_CODE: dataStatusCode,
    pub ORBIT_CENTER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORBIT_TYPE: orbitType,
    pub DEPLOYMENT_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MANEUVERABLE: bool,
    pub SIZE: f64,
    pub MASS: f64,
    pub MASS_TYPE: massType,
    pub PAYLOADS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PLD<'a>>>>>,
}
impl<'a> Default for CATArgs<'a> {
  #[inline]
  fn default() -> Self {
    CATArgs {
      OBJECT_NAME: None,
      OBJECT_ID: None,
      NORAD_CAT_ID: 0,
      OBJECT_TYPE: objectType::UNKNOWN,
      OPS_STATUS_CODE: opsStatusCode::UNKNOWN,
      OWNER: None,
      LAUNCH_DATE: None,
      LAUNCH_SITE: None,
      DECAY_DATE: None,
      PERIOD: 0.0,
      INCLINATION: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      RCS: 0.0,
      DATA_STATUS_CODE: dataStatusCode::NO_CURRENT_ELEMENTS,
      ORBIT_CENTER: None,
      ORBIT_TYPE: orbitType::ORBIT,
      DEPLOYMENT_DATE: None,
      MANEUVERABLE: false,
      SIZE: 0.0,
      MASS: 0.0,
      MASS_TYPE: massType::DRY,
      PAYLOADS: None,
    }
  }
}

pub struct CATBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CATBuilder<'a, 'b> {
  #[inline]
  pub fn add_OBJECT_NAME(&mut self, OBJECT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_OBJECT_NAME, OBJECT_NAME);
  }
  #[inline]
  pub fn add_OBJECT_ID(&mut self, OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_OBJECT_ID, OBJECT_ID);
  }
  #[inline]
  pub fn add_NORAD_CAT_ID(&mut self, NORAD_CAT_ID: u32) {
    self.fbb_.push_slot::<u32>(CAT::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  #[inline]
  pub fn add_OBJECT_TYPE(&mut self, OBJECT_TYPE: objectType) {
    self.fbb_.push_slot::<objectType>(CAT::VT_OBJECT_TYPE, OBJECT_TYPE, objectType::UNKNOWN);
  }
  #[inline]
  pub fn add_OPS_STATUS_CODE(&mut self, OPS_STATUS_CODE: opsStatusCode) {
    self.fbb_.push_slot::<opsStatusCode>(CAT::VT_OPS_STATUS_CODE, OPS_STATUS_CODE, opsStatusCode::UNKNOWN);
  }
  #[inline]
  pub fn add_OWNER(&mut self, OWNER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_OWNER, OWNER);
  }
  #[inline]
  pub fn add_LAUNCH_DATE(&mut self, LAUNCH_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_LAUNCH_DATE, LAUNCH_DATE);
  }
  #[inline]
  pub fn add_LAUNCH_SITE(&mut self, LAUNCH_SITE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_LAUNCH_SITE, LAUNCH_SITE);
  }
  #[inline]
  pub fn add_DECAY_DATE(&mut self, DECAY_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_DECAY_DATE, DECAY_DATE);
  }
  #[inline]
  pub fn add_PERIOD(&mut self, PERIOD: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_PERIOD, PERIOD, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_APOGEE(&mut self, APOGEE: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_APOGEE, APOGEE, 0.0);
  }
  #[inline]
  pub fn add_PERIGEE(&mut self, PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_PERIGEE, PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_RCS(&mut self, RCS: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_RCS, RCS, 0.0);
  }
  #[inline]
  pub fn add_DATA_STATUS_CODE(&mut self, DATA_STATUS_CODE: dataStatusCode) {
    self.fbb_.push_slot::<dataStatusCode>(CAT::VT_DATA_STATUS_CODE, DATA_STATUS_CODE, dataStatusCode::NO_CURRENT_ELEMENTS);
  }
  #[inline]
  pub fn add_ORBIT_CENTER(&mut self, ORBIT_CENTER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_ORBIT_CENTER, ORBIT_CENTER);
  }
  #[inline]
  pub fn add_ORBIT_TYPE(&mut self, ORBIT_TYPE: orbitType) {
    self.fbb_.push_slot::<orbitType>(CAT::VT_ORBIT_TYPE, ORBIT_TYPE, orbitType::ORBIT);
  }
  #[inline]
  pub fn add_DEPLOYMENT_DATE(&mut self, DEPLOYMENT_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_DEPLOYMENT_DATE, DEPLOYMENT_DATE);
  }
  #[inline]
  pub fn add_MANEUVERABLE(&mut self, MANEUVERABLE: bool) {
    self.fbb_.push_slot::<bool>(CAT::VT_MANEUVERABLE, MANEUVERABLE, false);
  }
  #[inline]
  pub fn add_SIZE(&mut self, SIZE: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_SIZE, SIZE, 0.0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(CAT::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_MASS_TYPE(&mut self, MASS_TYPE: massType) {
    self.fbb_.push_slot::<massType>(CAT::VT_MASS_TYPE, MASS_TYPE, massType::DRY);
  }
  #[inline]
  pub fn add_PAYLOADS(&mut self, PAYLOADS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PLD<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CAT::VT_PAYLOADS, PAYLOADS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CATBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CATBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CAT<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CAT<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CAT");
      ds.field("OBJECT_NAME", &self.OBJECT_NAME());
      ds.field("OBJECT_ID", &self.OBJECT_ID());
      ds.field("NORAD_CAT_ID", &self.NORAD_CAT_ID());
      ds.field("OBJECT_TYPE", &self.OBJECT_TYPE());
      ds.field("OPS_STATUS_CODE", &self.OPS_STATUS_CODE());
      ds.field("OWNER", &self.OWNER());
      ds.field("LAUNCH_DATE", &self.LAUNCH_DATE());
      ds.field("LAUNCH_SITE", &self.LAUNCH_SITE());
      ds.field("DECAY_DATE", &self.DECAY_DATE());
      ds.field("PERIOD", &self.PERIOD());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("APOGEE", &self.APOGEE());
      ds.field("PERIGEE", &self.PERIGEE());
      ds.field("RCS", &self.RCS());
      ds.field("DATA_STATUS_CODE", &self.DATA_STATUS_CODE());
      ds.field("ORBIT_CENTER", &self.ORBIT_CENTER());
      ds.field("ORBIT_TYPE", &self.ORBIT_TYPE());
      ds.field("DEPLOYMENT_DATE", &self.DEPLOYMENT_DATE());
      ds.field("MANEUVERABLE", &self.MANEUVERABLE());
      ds.field("SIZE", &self.SIZE());
      ds.field("MASS", &self.MASS());
      ds.field("MASS_TYPE", &self.MASS_TYPE());
      ds.field("PAYLOADS", &self.PAYLOADS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CATT {
  pub OBJECT_NAME: Option<String>,
  pub OBJECT_ID: Option<String>,
  pub NORAD_CAT_ID: u32,
  pub OBJECT_TYPE: objectType,
  pub OPS_STATUS_CODE: opsStatusCode,
  pub OWNER: Option<String>,
  pub LAUNCH_DATE: Option<String>,
  pub LAUNCH_SITE: Option<String>,
  pub DECAY_DATE: Option<String>,
  pub PERIOD: f64,
  pub INCLINATION: f64,
  pub APOGEE: f64,
  pub PERIGEE: f64,
  pub RCS: f64,
  pub DATA_STATUS_CODE: dataStatusCode,
  pub ORBIT_CENTER: Option<String>,
  pub ORBIT_TYPE: orbitType,
  pub DEPLOYMENT_DATE: Option<String>,
  pub MANEUVERABLE: bool,
  pub SIZE: f64,
  pub MASS: f64,
  pub MASS_TYPE: massType,
  pub PAYLOADS: Option<Vec<PLDT>>,
}
impl Default for CATT {
  fn default() -> Self {
    Self {
      OBJECT_NAME: None,
      OBJECT_ID: None,
      NORAD_CAT_ID: 0,
      OBJECT_TYPE: objectType::UNKNOWN,
      OPS_STATUS_CODE: opsStatusCode::UNKNOWN,
      OWNER: None,
      LAUNCH_DATE: None,
      LAUNCH_SITE: None,
      DECAY_DATE: None,
      PERIOD: 0.0,
      INCLINATION: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      RCS: 0.0,
      DATA_STATUS_CODE: dataStatusCode::NO_CURRENT_ELEMENTS,
      ORBIT_CENTER: None,
      ORBIT_TYPE: orbitType::ORBIT,
      DEPLOYMENT_DATE: None,
      MANEUVERABLE: false,
      SIZE: 0.0,
      MASS: 0.0,
      MASS_TYPE: massType::DRY,
      PAYLOADS: None,
    }
  }
}
impl CATT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CAT<'b>> {
    let OBJECT_NAME = self.OBJECT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_ID = self.OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID;
    let OBJECT_TYPE = self.OBJECT_TYPE;
    let OPS_STATUS_CODE = self.OPS_STATUS_CODE;
    let OWNER = self.OWNER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_DATE = self.LAUNCH_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_SITE = self.LAUNCH_SITE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DECAY_DATE = self.DECAY_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PERIOD = self.PERIOD;
    let INCLINATION = self.INCLINATION;
    let APOGEE = self.APOGEE;
    let PERIGEE = self.PERIGEE;
    let RCS = self.RCS;
    let DATA_STATUS_CODE = self.DATA_STATUS_CODE;
    let ORBIT_CENTER = self.ORBIT_CENTER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORBIT_TYPE = self.ORBIT_TYPE;
    let DEPLOYMENT_DATE = self.DEPLOYMENT_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MANEUVERABLE = self.MANEUVERABLE;
    let SIZE = self.SIZE;
    let MASS = self.MASS;
    let MASS_TYPE = self.MASS_TYPE;
    let PAYLOADS = self.PAYLOADS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    CAT::create(_fbb, &CATArgs{
      OBJECT_NAME,
      OBJECT_ID,
      NORAD_CAT_ID,
      OBJECT_TYPE,
      OPS_STATUS_CODE,
      OWNER,
      LAUNCH_DATE,
      LAUNCH_SITE,
      DECAY_DATE,
      PERIOD,
      INCLINATION,
      APOGEE,
      PERIGEE,
      RCS,
      DATA_STATUS_CODE,
      ORBIT_CENTER,
      ORBIT_TYPE,
      DEPLOYMENT_DATE,
      MANEUVERABLE,
      SIZE,
      MASS,
      MASS_TYPE,
      PAYLOADS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CAT`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CAT_unchecked`.
pub fn root_as_CAT(buf: &[u8]) -> Result<CAT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CAT>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CAT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_CAT_unchecked`.
pub fn size_prefixed_root_as_CAT(buf: &[u8]) -> Result<CAT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CAT>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CAT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CAT_unchecked`.
pub fn root_as_CAT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CAT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CAT<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CAT` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CAT_unchecked`.
pub fn size_prefixed_root_as_CAT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CAT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CAT<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CAT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CAT`.
pub unsafe fn root_as_CAT_unchecked(buf: &[u8]) -> CAT {
  flatbuffers::root_unchecked::<CAT>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CAT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CAT`.
pub unsafe fn size_prefixed_root_as_CAT_unchecked(buf: &[u8]) -> CAT {
  flatbuffers::size_prefixed_root_unchecked::<CAT>(buf)
}
pub const CAT_IDENTIFIER: &str = "$CAT";

#[inline]
pub fn CAT_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CAT_IDENTIFIER, false)
}

#[inline]
pub fn CAT_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CAT_IDENTIFIER, true)
}

#[inline]
pub fn finish_CAT_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<CAT<'a>>) {
  fbb.finish(root, Some(CAT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_CAT_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<CAT<'a>>) {
  fbb.finish_size_prefixed(root, Some(CAT_IDENTIFIER));
}
