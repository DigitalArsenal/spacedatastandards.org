// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum SEOOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Space Environment Observation
pub struct SEO<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SEO<'a> {
  type Inner = SEO<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SEO<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_GEN_SYSTEM: flatbuffers::VOffsetT = 8;
  pub const VT_EXTERNAL_ID: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_GEN_TIME: flatbuffers::VOffsetT = 14;
  pub const VT_FORECAST: flatbuffers::VOffsetT = 16;
  pub const VT_DERIVED: flatbuffers::VOffsetT = 18;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 20;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 22;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 24;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 26;
  pub const VT_OBSERVATORY_TYPE: flatbuffers::VOffsetT = 28;
  pub const VT_OBSERVATORY_NAME: flatbuffers::VOffsetT = 30;
  pub const VT_OBSERVATORY_NOTES: flatbuffers::VOffsetT = 32;
  pub const VT_INSTRUMENT_TYPE: flatbuffers::VOffsetT = 34;
  pub const VT_LAT: flatbuffers::VOffsetT = 36;
  pub const VT_LON: flatbuffers::VOffsetT = 38;
  pub const VT_ALT: flatbuffers::VOffsetT = 40;
  pub const VT_SEN_REFERENCE_FRAME: flatbuffers::VOffsetT = 42;
  pub const VT_SEN_POS: flatbuffers::VOffsetT = 44;
  pub const VT_SEN_VEL: flatbuffers::VOffsetT = 46;
  pub const VT_MEAS_TYPE: flatbuffers::VOffsetT = 48;
  pub const VT_SEN_ENERGY_LEVEL: flatbuffers::VOffsetT = 50;
  pub const VT_OB_SET_ID: flatbuffers::VOffsetT = 52;
  pub const VT_PARTICLE_TYPE: flatbuffers::VOffsetT = 54;
  pub const VT_OB_TIME: flatbuffers::VOffsetT = 56;
  pub const VT_SEO_LIST: flatbuffers::VOffsetT = 58;
  pub const VT_QUALITY: flatbuffers::VOffsetT = 60;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 62;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 64;
  pub const VT_SRC_TYPS: flatbuffers::VOffsetT = 66;
  pub const VT_SRC_IDS: flatbuffers::VOffsetT = 68;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SEO { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SEOArgs<'args>
  ) -> flatbuffers::WIPOffset<SEO<'bldr>> {
    let mut builder = SEOBuilder::new(_fbb);
    builder.add_ALT(args.ALT);
    builder.add_LON(args.LON);
    builder.add_LAT(args.LAT);
    if let Some(x) = args.SRC_IDS { builder.add_SRC_IDS(x); }
    if let Some(x) = args.SRC_TYPS { builder.add_SRC_TYPS(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.QUALITY { builder.add_QUALITY(x); }
    if let Some(x) = args.SEO_LIST { builder.add_SEO_LIST(x); }
    if let Some(x) = args.OB_TIME { builder.add_OB_TIME(x); }
    if let Some(x) = args.PARTICLE_TYPE { builder.add_PARTICLE_TYPE(x); }
    if let Some(x) = args.OB_SET_ID { builder.add_OB_SET_ID(x); }
    if let Some(x) = args.SEN_ENERGY_LEVEL { builder.add_SEN_ENERGY_LEVEL(x); }
    if let Some(x) = args.MEAS_TYPE { builder.add_MEAS_TYPE(x); }
    if let Some(x) = args.SEN_VEL { builder.add_SEN_VEL(x); }
    if let Some(x) = args.SEN_POS { builder.add_SEN_POS(x); }
    if let Some(x) = args.SEN_REFERENCE_FRAME { builder.add_SEN_REFERENCE_FRAME(x); }
    if let Some(x) = args.INSTRUMENT_TYPE { builder.add_INSTRUMENT_TYPE(x); }
    if let Some(x) = args.OBSERVATORY_NOTES { builder.add_OBSERVATORY_NOTES(x); }
    if let Some(x) = args.OBSERVATORY_NAME { builder.add_OBSERVATORY_NAME(x); }
    if let Some(x) = args.OBSERVATORY_TYPE { builder.add_OBSERVATORY_TYPE(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.GEN_TIME { builder.add_GEN_TIME(x); }
    if let Some(x) = args.DATA_TYPE { builder.add_DATA_TYPE(x); }
    if let Some(x) = args.EXTERNAL_ID { builder.add_EXTERNAL_ID(x); }
    if let Some(x) = args.GEN_SYSTEM { builder.add_GEN_SYSTEM(x); }
    if let Some(x) = args.MSG_TYPE { builder.add_MSG_TYPE(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_DERIVED(args.DERIVED);
    builder.add_FORECAST(args.FORECAST);
    builder.finish()
  }

  pub fn unpack(&self) -> SEOT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let MSG_TYPE = self.MSG_TYPE().map(|x| {
      x.to_string()
    });
    let GEN_SYSTEM = self.GEN_SYSTEM().map(|x| {
      x.to_string()
    });
    let EXTERNAL_ID = self.EXTERNAL_ID().map(|x| {
      x.to_string()
    });
    let DATA_TYPE = self.DATA_TYPE().map(|x| {
      x.to_string()
    });
    let GEN_TIME = self.GEN_TIME().map(|x| {
      x.to_string()
    });
    let FORECAST = self.FORECAST();
    let DERIVED = self.DERIVED();
    let SAT_NO = self.SAT_NO();
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let OBSERVATORY_TYPE = self.OBSERVATORY_TYPE().map(|x| {
      x.to_string()
    });
    let OBSERVATORY_NAME = self.OBSERVATORY_NAME().map(|x| {
      x.to_string()
    });
    let OBSERVATORY_NOTES = self.OBSERVATORY_NOTES().map(|x| {
      x.to_string()
    });
    let INSTRUMENT_TYPE = self.INSTRUMENT_TYPE().map(|x| {
      x.to_string()
    });
    let LAT = self.LAT();
    let LON = self.LON();
    let ALT = self.ALT();
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let SEN_POS = self.SEN_POS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SEN_VEL = self.SEN_VEL().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let MEAS_TYPE = self.MEAS_TYPE().map(|x| {
      x.to_string()
    });
    let SEN_ENERGY_LEVEL = self.SEN_ENERGY_LEVEL().map(|x| {
      x.to_string()
    });
    let OB_SET_ID = self.OB_SET_ID().map(|x| {
      x.to_string()
    });
    let PARTICLE_TYPE = self.PARTICLE_TYPE().map(|x| {
      x.to_string()
    });
    let OB_TIME = self.OB_TIME().map(|x| {
      x.to_string()
    });
    let SEO_LIST = self.SEO_LIST().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let QUALITY = self.QUALITY().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let SRC_TYPS = self.SRC_TYPS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SRC_IDS = self.SRC_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    SEOT {
      ID,
      MSG_TYPE,
      GEN_SYSTEM,
      EXTERNAL_ID,
      DATA_TYPE,
      GEN_TIME,
      FORECAST,
      DERIVED,
      SAT_NO,
      ORIG_OBJECT_ID,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OBSERVATORY_TYPE,
      OBSERVATORY_NAME,
      OBSERVATORY_NOTES,
      INSTRUMENT_TYPE,
      LAT,
      LON,
      ALT,
      SEN_REFERENCE_FRAME,
      SEN_POS,
      SEN_VEL,
      MEAS_TYPE,
      SEN_ENERGY_LEVEL,
      OB_SET_ID,
      PARTICLE_TYPE,
      OB_TIME,
      SEO_LIST,
      QUALITY,
      DESCRIPTION,
      DESCRIPTOR,
      SRC_TYPS,
      SRC_IDS,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_ID, None)}
  }
  #[inline]
  pub fn MSG_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_MSG_TYPE, None)}
  }
  #[inline]
  pub fn GEN_SYSTEM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_GEN_SYSTEM, None)}
  }
  #[inline]
  pub fn EXTERNAL_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_EXTERNAL_ID, None)}
  }
  #[inline]
  pub fn DATA_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_DATA_TYPE, None)}
  }
  #[inline]
  pub fn GEN_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_GEN_TIME, None)}
  }
  #[inline]
  pub fn FORECAST(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SEO::VT_FORECAST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn DERIVED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SEO::VT_DERIVED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SEO::VT_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_ORIG_OBJECT_ID, None)}
  }
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_ID_SENSOR, None)}
  }
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_ORIG_SENSOR_ID, None)}
  }
  #[inline]
  pub fn OBSERVATORY_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_OBSERVATORY_TYPE, None)}
  }
  #[inline]
  pub fn OBSERVATORY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_OBSERVATORY_NAME, None)}
  }
  #[inline]
  pub fn OBSERVATORY_NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_OBSERVATORY_NOTES, None)}
  }
  #[inline]
  pub fn INSTRUMENT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_INSTRUMENT_TYPE, None)}
  }
  #[inline]
  pub fn LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEO::VT_LAT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEO::VT_LON, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEO::VT_ALT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEN_REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_SEN_REFERENCE_FRAME, None)}
  }
  #[inline]
  pub fn SEN_POS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SEO::VT_SEN_POS, None)}
  }
  #[inline]
  pub fn SEN_VEL(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SEO::VT_SEN_VEL, None)}
  }
  #[inline]
  pub fn MEAS_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_MEAS_TYPE, None)}
  }
  #[inline]
  pub fn SEN_ENERGY_LEVEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_SEN_ENERGY_LEVEL, None)}
  }
  #[inline]
  pub fn OB_SET_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_OB_SET_ID, None)}
  }
  #[inline]
  pub fn PARTICLE_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_PARTICLE_TYPE, None)}
  }
  #[inline]
  pub fn OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_OB_TIME, None)}
  }
  #[inline]
  pub fn SEO_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SEO::VT_SEO_LIST, None)}
  }
  #[inline]
  pub fn QUALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_QUALITY, None)}
  }
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEO::VT_DESCRIPTOR, None)}
  }
  #[inline]
  pub fn SRC_TYPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SEO::VT_SRC_TYPS, None)}
  }
  #[inline]
  pub fn SRC_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SEO::VT_SRC_IDS, None)}
  }
}

impl flatbuffers::Verifiable for SEO<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_TYPE", Self::VT_MSG_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GEN_SYSTEM", Self::VT_GEN_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXTERNAL_ID", Self::VT_EXTERNAL_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_TYPE", Self::VT_DATA_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GEN_TIME", Self::VT_GEN_TIME, false)?
     .visit_field::<bool>("FORECAST", Self::VT_FORECAST, false)?
     .visit_field::<bool>("DERIVED", Self::VT_DERIVED, false)?
     .visit_field::<i32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVATORY_TYPE", Self::VT_OBSERVATORY_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVATORY_NAME", Self::VT_OBSERVATORY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVATORY_NOTES", Self::VT_OBSERVATORY_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INSTRUMENT_TYPE", Self::VT_INSTRUMENT_TYPE, false)?
     .visit_field::<f64>("LAT", Self::VT_LAT, false)?
     .visit_field::<f64>("LON", Self::VT_LON, false)?
     .visit_field::<f64>("ALT", Self::VT_ALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_REFERENCE_FRAME", Self::VT_SEN_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SEN_POS", Self::VT_SEN_POS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SEN_VEL", Self::VT_SEN_VEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MEAS_TYPE", Self::VT_MEAS_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_ENERGY_LEVEL", Self::VT_SEN_ENERGY_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_SET_ID", Self::VT_OB_SET_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARTICLE_TYPE", Self::VT_PARTICLE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_TIME", Self::VT_OB_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SEO_LIST", Self::VT_SEO_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("QUALITY", Self::VT_QUALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_TYPS", Self::VT_SRC_TYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_IDS", Self::VT_SRC_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SEOArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GEN_SYSTEM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EXTERNAL_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GEN_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FORECAST: bool,
    pub DERIVED: bool,
    pub SAT_NO: i32,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATORY_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATORY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATORY_NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INSTRUMENT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAT: f64,
    pub LON: f64,
    pub ALT: f64,
    pub SEN_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEN_POS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SEN_VEL: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub MEAS_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEN_ENERGY_LEVEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_SET_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARTICLE_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEO_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub QUALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SRC_TYPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SRC_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SEOArgs<'a> {
  #[inline]
  fn default() -> Self {
    SEOArgs {
      ID: None,
      MSG_TYPE: None,
      GEN_SYSTEM: None,
      EXTERNAL_ID: None,
      DATA_TYPE: None,
      GEN_TIME: None,
      FORECAST: false,
      DERIVED: false,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OBSERVATORY_TYPE: None,
      OBSERVATORY_NAME: None,
      OBSERVATORY_NOTES: None,
      INSTRUMENT_TYPE: None,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      SEN_REFERENCE_FRAME: None,
      SEN_POS: None,
      SEN_VEL: None,
      MEAS_TYPE: None,
      SEN_ENERGY_LEVEL: None,
      OB_SET_ID: None,
      PARTICLE_TYPE: None,
      OB_TIME: None,
      SEO_LIST: None,
      QUALITY: None,
      DESCRIPTION: None,
      DESCRIPTOR: None,
      SRC_TYPS: None,
      SRC_IDS: None,
    }
  }
}

pub struct SEOBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SEOBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_ID, ID);
  }
  #[inline]
  pub fn add_MSG_TYPE(&mut self, MSG_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_MSG_TYPE, MSG_TYPE);
  }
  #[inline]
  pub fn add_GEN_SYSTEM(&mut self, GEN_SYSTEM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_GEN_SYSTEM, GEN_SYSTEM);
  }
  #[inline]
  pub fn add_EXTERNAL_ID(&mut self, EXTERNAL_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_EXTERNAL_ID, EXTERNAL_ID);
  }
  #[inline]
  pub fn add_DATA_TYPE(&mut self, DATA_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_DATA_TYPE, DATA_TYPE);
  }
  #[inline]
  pub fn add_GEN_TIME(&mut self, GEN_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_GEN_TIME, GEN_TIME);
  }
  #[inline]
  pub fn add_FORECAST(&mut self, FORECAST: bool) {
    self.fbb_.push_slot::<bool>(SEO::VT_FORECAST, FORECAST, false);
  }
  #[inline]
  pub fn add_DERIVED(&mut self, DERIVED: bool) {
    self.fbb_.push_slot::<bool>(SEO::VT_DERIVED, DERIVED, false);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(SEO::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_OBSERVATORY_TYPE(&mut self, OBSERVATORY_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_OBSERVATORY_TYPE, OBSERVATORY_TYPE);
  }
  #[inline]
  pub fn add_OBSERVATORY_NAME(&mut self, OBSERVATORY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_OBSERVATORY_NAME, OBSERVATORY_NAME);
  }
  #[inline]
  pub fn add_OBSERVATORY_NOTES(&mut self, OBSERVATORY_NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_OBSERVATORY_NOTES, OBSERVATORY_NOTES);
  }
  #[inline]
  pub fn add_INSTRUMENT_TYPE(&mut self, INSTRUMENT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_INSTRUMENT_TYPE, INSTRUMENT_TYPE);
  }
  #[inline]
  pub fn add_LAT(&mut self, LAT: f64) {
    self.fbb_.push_slot::<f64>(SEO::VT_LAT, LAT, 0.0);
  }
  #[inline]
  pub fn add_LON(&mut self, LON: f64) {
    self.fbb_.push_slot::<f64>(SEO::VT_LON, LON, 0.0);
  }
  #[inline]
  pub fn add_ALT(&mut self, ALT: f64) {
    self.fbb_.push_slot::<f64>(SEO::VT_ALT, ALT, 0.0);
  }
  #[inline]
  pub fn add_SEN_REFERENCE_FRAME(&mut self, SEN_REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SEN_REFERENCE_FRAME, SEN_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_SEN_POS(&mut self, SEN_POS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SEN_POS, SEN_POS);
  }
  #[inline]
  pub fn add_SEN_VEL(&mut self, SEN_VEL: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SEN_VEL, SEN_VEL);
  }
  #[inline]
  pub fn add_MEAS_TYPE(&mut self, MEAS_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_MEAS_TYPE, MEAS_TYPE);
  }
  #[inline]
  pub fn add_SEN_ENERGY_LEVEL(&mut self, SEN_ENERGY_LEVEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SEN_ENERGY_LEVEL, SEN_ENERGY_LEVEL);
  }
  #[inline]
  pub fn add_OB_SET_ID(&mut self, OB_SET_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_OB_SET_ID, OB_SET_ID);
  }
  #[inline]
  pub fn add_PARTICLE_TYPE(&mut self, PARTICLE_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_PARTICLE_TYPE, PARTICLE_TYPE);
  }
  #[inline]
  pub fn add_OB_TIME(&mut self, OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_OB_TIME, OB_TIME);
  }
  #[inline]
  pub fn add_SEO_LIST(&mut self, SEO_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SEO_LIST, SEO_LIST);
  }
  #[inline]
  pub fn add_QUALITY(&mut self, QUALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_QUALITY, QUALITY);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_SRC_TYPS(&mut self, SRC_TYPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SRC_TYPS, SRC_TYPS);
  }
  #[inline]
  pub fn add_SRC_IDS(&mut self, SRC_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEO::VT_SRC_IDS, SRC_IDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SEOBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SEOBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SEO<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SEO<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SEO");
      ds.field("ID", &self.ID());
      ds.field("MSG_TYPE", &self.MSG_TYPE());
      ds.field("GEN_SYSTEM", &self.GEN_SYSTEM());
      ds.field("EXTERNAL_ID", &self.EXTERNAL_ID());
      ds.field("DATA_TYPE", &self.DATA_TYPE());
      ds.field("GEN_TIME", &self.GEN_TIME());
      ds.field("FORECAST", &self.FORECAST());
      ds.field("DERIVED", &self.DERIVED());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("OBSERVATORY_TYPE", &self.OBSERVATORY_TYPE());
      ds.field("OBSERVATORY_NAME", &self.OBSERVATORY_NAME());
      ds.field("OBSERVATORY_NOTES", &self.OBSERVATORY_NOTES());
      ds.field("INSTRUMENT_TYPE", &self.INSTRUMENT_TYPE());
      ds.field("LAT", &self.LAT());
      ds.field("LON", &self.LON());
      ds.field("ALT", &self.ALT());
      ds.field("SEN_REFERENCE_FRAME", &self.SEN_REFERENCE_FRAME());
      ds.field("SEN_POS", &self.SEN_POS());
      ds.field("SEN_VEL", &self.SEN_VEL());
      ds.field("MEAS_TYPE", &self.MEAS_TYPE());
      ds.field("SEN_ENERGY_LEVEL", &self.SEN_ENERGY_LEVEL());
      ds.field("OB_SET_ID", &self.OB_SET_ID());
      ds.field("PARTICLE_TYPE", &self.PARTICLE_TYPE());
      ds.field("OB_TIME", &self.OB_TIME());
      ds.field("SEO_LIST", &self.SEO_LIST());
      ds.field("QUALITY", &self.QUALITY());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("SRC_TYPS", &self.SRC_TYPS());
      ds.field("SRC_IDS", &self.SRC_IDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SEOT {
  pub ID: Option<String>,
  pub MSG_TYPE: Option<String>,
  pub GEN_SYSTEM: Option<String>,
  pub EXTERNAL_ID: Option<String>,
  pub DATA_TYPE: Option<String>,
  pub GEN_TIME: Option<String>,
  pub FORECAST: bool,
  pub DERIVED: bool,
  pub SAT_NO: i32,
  pub ORIG_OBJECT_ID: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub OBSERVATORY_TYPE: Option<String>,
  pub OBSERVATORY_NAME: Option<String>,
  pub OBSERVATORY_NOTES: Option<String>,
  pub INSTRUMENT_TYPE: Option<String>,
  pub LAT: f64,
  pub LON: f64,
  pub ALT: f64,
  pub SEN_REFERENCE_FRAME: Option<String>,
  pub SEN_POS: Option<Vec<String>>,
  pub SEN_VEL: Option<Vec<String>>,
  pub MEAS_TYPE: Option<String>,
  pub SEN_ENERGY_LEVEL: Option<String>,
  pub OB_SET_ID: Option<String>,
  pub PARTICLE_TYPE: Option<String>,
  pub OB_TIME: Option<String>,
  pub SEO_LIST: Option<Vec<String>>,
  pub QUALITY: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub DESCRIPTOR: Option<String>,
  pub SRC_TYPS: Option<Vec<String>>,
  pub SRC_IDS: Option<Vec<String>>,
}
impl Default for SEOT {
  fn default() -> Self {
    Self {
      ID: None,
      MSG_TYPE: None,
      GEN_SYSTEM: None,
      EXTERNAL_ID: None,
      DATA_TYPE: None,
      GEN_TIME: None,
      FORECAST: false,
      DERIVED: false,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OBSERVATORY_TYPE: None,
      OBSERVATORY_NAME: None,
      OBSERVATORY_NOTES: None,
      INSTRUMENT_TYPE: None,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      SEN_REFERENCE_FRAME: None,
      SEN_POS: None,
      SEN_VEL: None,
      MEAS_TYPE: None,
      SEN_ENERGY_LEVEL: None,
      OB_SET_ID: None,
      PARTICLE_TYPE: None,
      OB_TIME: None,
      SEO_LIST: None,
      QUALITY: None,
      DESCRIPTION: None,
      DESCRIPTOR: None,
      SRC_TYPS: None,
      SRC_IDS: None,
    }
  }
}
impl SEOT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SEO<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_TYPE = self.MSG_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GEN_SYSTEM = self.GEN_SYSTEM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EXTERNAL_ID = self.EXTERNAL_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_TYPE = self.DATA_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GEN_TIME = self.GEN_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FORECAST = self.FORECAST;
    let DERIVED = self.DERIVED;
    let SAT_NO = self.SAT_NO;
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATORY_TYPE = self.OBSERVATORY_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATORY_NAME = self.OBSERVATORY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATORY_NOTES = self.OBSERVATORY_NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INSTRUMENT_TYPE = self.INSTRUMENT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAT = self.LAT;
    let LON = self.LON;
    let ALT = self.ALT;
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEN_POS = self.SEN_POS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SEN_VEL = self.SEN_VEL.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let MEAS_TYPE = self.MEAS_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEN_ENERGY_LEVEL = self.SEN_ENERGY_LEVEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_SET_ID = self.OB_SET_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARTICLE_TYPE = self.PARTICLE_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_TIME = self.OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEO_LIST = self.SEO_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let QUALITY = self.QUALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SRC_TYPS = self.SRC_TYPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SRC_IDS = self.SRC_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    SEO::create(_fbb, &SEOArgs{
      ID,
      MSG_TYPE,
      GEN_SYSTEM,
      EXTERNAL_ID,
      DATA_TYPE,
      GEN_TIME,
      FORECAST,
      DERIVED,
      SAT_NO,
      ORIG_OBJECT_ID,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OBSERVATORY_TYPE,
      OBSERVATORY_NAME,
      OBSERVATORY_NOTES,
      INSTRUMENT_TYPE,
      LAT,
      LON,
      ALT,
      SEN_REFERENCE_FRAME,
      SEN_POS,
      SEN_VEL,
      MEAS_TYPE,
      SEN_ENERGY_LEVEL,
      OB_SET_ID,
      PARTICLE_TYPE,
      OB_TIME,
      SEO_LIST,
      QUALITY,
      DESCRIPTION,
      DESCRIPTOR,
      SRC_TYPS,
      SRC_IDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SEO`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEO_unchecked`.
pub fn root_as_SEO(buf: &[u8]) -> Result<SEO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SEO>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SEO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SEO_unchecked`.
pub fn size_prefixed_root_as_SEO(buf: &[u8]) -> Result<SEO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SEO>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SEO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEO_unchecked`.
pub fn root_as_SEO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SEO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SEO<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SEO` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEO_unchecked`.
pub fn size_prefixed_root_as_SEO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SEO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SEO<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SEO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SEO`.
pub unsafe fn root_as_SEO_unchecked(buf: &[u8]) -> SEO {
  flatbuffers::root_unchecked::<SEO>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SEO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SEO`.
pub unsafe fn size_prefixed_root_as_SEO_unchecked(buf: &[u8]) -> SEO {
  flatbuffers::size_prefixed_root_unchecked::<SEO>(buf)
}
pub const SEO_IDENTIFIER: &str = "$SEO";

#[inline]
pub fn SEO_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SEO_IDENTIFIER, false)
}

#[inline]
pub fn SEO_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SEO_IDENTIFIER, true)
}

#[inline]
pub fn finish_SEO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SEO<'a>>) {
  fbb.finish(root, Some(SEO_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SEO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SEO<'a>>) {
  fbb.finish_size_prefixed(root, Some(SEO_IDENTIFIER));
}
