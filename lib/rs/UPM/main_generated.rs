// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum CryptoKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CryptoKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CryptoKey<'a> {
  type Inner = CryptoKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CryptoKey<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_XPUB: flatbuffers::VOffsetT = 6;
  pub const VT_PRIVATE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_XPRIV: flatbuffers::VOffsetT = 10;
  pub const VT_KEY_ADDRESS: flatbuffers::VOffsetT = 12;
  pub const VT_ADDRESS_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CryptoKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CryptoKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<CryptoKey<'bldr>> {
    let mut builder = CryptoKeyBuilder::new(_fbb);
    builder.add_ADDRESS_TYPE(args.ADDRESS_TYPE);
    if let Some(x) = args.KEY_ADDRESS { builder.add_KEY_ADDRESS(x); }
    if let Some(x) = args.XPRIV { builder.add_XPRIV(x); }
    if let Some(x) = args.PRIVATE_KEY { builder.add_PRIVATE_KEY(x); }
    if let Some(x) = args.XPUB { builder.add_XPUB(x); }
    if let Some(x) = args.PUBLIC_KEY { builder.add_PUBLIC_KEY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CryptoKeyT {
    let PUBLIC_KEY = self.PUBLIC_KEY().map(|x| {
      x.to_string()
    });
    let XPUB = self.XPUB().map(|x| {
      x.to_string()
    });
    let PRIVATE_KEY = self.PRIVATE_KEY().map(|x| {
      x.to_string()
    });
    let XPRIV = self.XPRIV().map(|x| {
      x.to_string()
    });
    let KEY_ADDRESS = self.KEY_ADDRESS().map(|x| {
      x.to_string()
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE();
    CryptoKeyT {
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    }
  }

  #[inline]
  pub fn PUBLIC_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn XPUB(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPUB, None)}
  }
  #[inline]
  pub fn PRIVATE_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PRIVATE_KEY, None)}
  }
  #[inline]
  pub fn XPRIV(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPRIV, None)}
  }
  #[inline]
  pub fn KEY_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_KEY_ADDRESS, None)}
  }
  #[inline]
  pub fn ADDRESS_TYPE(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CryptoKey::VT_ADDRESS_TYPE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CryptoKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PUBLIC_KEY", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPUB", Self::VT_XPUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PRIVATE_KEY", Self::VT_PRIVATE_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPRIV", Self::VT_XPRIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEY_ADDRESS", Self::VT_KEY_ADDRESS, false)?
     .visit_field::<i32>("ADDRESS_TYPE", Self::VT_ADDRESS_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CryptoKeyArgs<'a> {
    pub PUBLIC_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPUB: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIVATE_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPRIV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_TYPE: i32,
}
impl<'a> Default for CryptoKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CryptoKeyArgs {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: 0,
    }
  }
}

pub struct CryptoKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CryptoKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_PUBLIC_KEY(&mut self, PUBLIC_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  #[inline]
  pub fn add_XPUB(&mut self, XPUB: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPUB, XPUB);
  }
  #[inline]
  pub fn add_PRIVATE_KEY(&mut self, PRIVATE_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  #[inline]
  pub fn add_XPRIV(&mut self, XPRIV: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPRIV, XPRIV);
  }
  #[inline]
  pub fn add_KEY_ADDRESS(&mut self, KEY_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  #[inline]
  pub fn add_ADDRESS_TYPE(&mut self, ADDRESS_TYPE: i32) {
    self.fbb_.push_slot::<i32>(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CryptoKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CryptoKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CryptoKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CryptoKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CryptoKey");
      ds.field("PUBLIC_KEY", &self.PUBLIC_KEY());
      ds.field("XPUB", &self.XPUB());
      ds.field("PRIVATE_KEY", &self.PRIVATE_KEY());
      ds.field("XPRIV", &self.XPRIV());
      ds.field("KEY_ADDRESS", &self.KEY_ADDRESS());
      ds.field("ADDRESS_TYPE", &self.ADDRESS_TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CryptoKeyT {
  pub PUBLIC_KEY: Option<String>,
  pub XPUB: Option<String>,
  pub PRIVATE_KEY: Option<String>,
  pub XPRIV: Option<String>,
  pub KEY_ADDRESS: Option<String>,
  pub ADDRESS_TYPE: i32,
}
impl Default for CryptoKeyT {
  fn default() -> Self {
    Self {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: 0,
    }
  }
}
impl CryptoKeyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CryptoKey<'b>> {
    let PUBLIC_KEY = self.PUBLIC_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPUB = self.XPUB.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIVATE_KEY = self.PRIVATE_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPRIV = self.XPRIV.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY_ADDRESS = self.KEY_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE;
    CryptoKey::create(_fbb, &CryptoKeyArgs{
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    })
  }
}
pub enum ContactPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContactPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContactPoint<'a> {
  type Inner = ContactPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContactPoint<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_CONTACT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 8;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 10;
  pub const VT_CONTACT_OPTION: flatbuffers::VOffsetT = 12;
  pub const VT_AREA_SERVED: flatbuffers::VOffsetT = 14;
  pub const VT_AVAILABLE_LANGUAGE: flatbuffers::VOffsetT = 16;
  pub const VT_ADDRESS_COUNTRY: flatbuffers::VOffsetT = 18;
  pub const VT_ADDRESS_REGION: flatbuffers::VOffsetT = 20;
  pub const VT_ADDRESS_LOCALITY: flatbuffers::VOffsetT = 22;
  pub const VT_POSTAL_CODE: flatbuffers::VOffsetT = 24;
  pub const VT_STREET_ADDRESS: flatbuffers::VOffsetT = 26;
  pub const VT_POST_OFFICE_BOX_NUMBER: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContactPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContactPointArgs<'args>
  ) -> flatbuffers::WIPOffset<ContactPoint<'bldr>> {
    let mut builder = ContactPointBuilder::new(_fbb);
    if let Some(x) = args.POST_OFFICE_BOX_NUMBER { builder.add_POST_OFFICE_BOX_NUMBER(x); }
    if let Some(x) = args.STREET_ADDRESS { builder.add_STREET_ADDRESS(x); }
    if let Some(x) = args.POSTAL_CODE { builder.add_POSTAL_CODE(x); }
    if let Some(x) = args.ADDRESS_LOCALITY { builder.add_ADDRESS_LOCALITY(x); }
    if let Some(x) = args.ADDRESS_REGION { builder.add_ADDRESS_REGION(x); }
    if let Some(x) = args.ADDRESS_COUNTRY { builder.add_ADDRESS_COUNTRY(x); }
    if let Some(x) = args.AVAILABLE_LANGUAGE { builder.add_AVAILABLE_LANGUAGE(x); }
    if let Some(x) = args.AREA_SERVED { builder.add_AREA_SERVED(x); }
    if let Some(x) = args.CONTACT_OPTION { builder.add_CONTACT_OPTION(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.CONTACT_TYPE { builder.add_CONTACT_TYPE(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContactPointT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CONTACT_TYPE = self.CONTACT_TYPE().map(|x| {
      x.to_string()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let CONTACT_OPTION = self.CONTACT_OPTION().map(|x| {
      x.to_string()
    });
    let AREA_SERVED = self.AREA_SERVED().map(|x| {
      x.to_string()
    });
    let AVAILABLE_LANGUAGE = self.AVAILABLE_LANGUAGE().map(|x| {
      x.to_string()
    });
    let ADDRESS_COUNTRY = self.ADDRESS_COUNTRY().map(|x| {
      x.to_string()
    });
    let ADDRESS_REGION = self.ADDRESS_REGION().map(|x| {
      x.to_string()
    });
    let ADDRESS_LOCALITY = self.ADDRESS_LOCALITY().map(|x| {
      x.to_string()
    });
    let POSTAL_CODE = self.POSTAL_CODE().map(|x| {
      x.to_string()
    });
    let STREET_ADDRESS = self.STREET_ADDRESS().map(|x| {
      x.to_string()
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER().map(|x| {
      x.to_string()
    });
    ContactPointT {
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER,
    }
  }

  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_NAME, None)}
  }
  #[inline]
  pub fn CONTACT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_CONTACT_TYPE, None)}
  }
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_EMAIL, None)}
  }
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_TELEPHONE, None)}
  }
  #[inline]
  pub fn CONTACT_OPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_CONTACT_OPTION, None)}
  }
  #[inline]
  pub fn AREA_SERVED(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_AREA_SERVED, None)}
  }
  #[inline]
  pub fn AVAILABLE_LANGUAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_AVAILABLE_LANGUAGE, None)}
  }
  #[inline]
  pub fn ADDRESS_COUNTRY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_COUNTRY, None)}
  }
  #[inline]
  pub fn ADDRESS_REGION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_REGION, None)}
  }
  #[inline]
  pub fn ADDRESS_LOCALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_LOCALITY, None)}
  }
  #[inline]
  pub fn POSTAL_CODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_POSTAL_CODE, None)}
  }
  #[inline]
  pub fn STREET_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_STREET_ADDRESS, None)}
  }
  #[inline]
  pub fn POST_OFFICE_BOX_NUMBER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_POST_OFFICE_BOX_NUMBER, None)}
  }
}

impl flatbuffers::Verifiable for ContactPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTACT_TYPE", Self::VT_CONTACT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTACT_OPTION", Self::VT_CONTACT_OPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AREA_SERVED", Self::VT_AREA_SERVED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AVAILABLE_LANGUAGE", Self::VT_AVAILABLE_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_COUNTRY", Self::VT_ADDRESS_COUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_REGION", Self::VT_ADDRESS_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_LOCALITY", Self::VT_ADDRESS_LOCALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSTAL_CODE", Self::VT_POSTAL_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STREET_ADDRESS", Self::VT_STREET_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POST_OFFICE_BOX_NUMBER", Self::VT_POST_OFFICE_BOX_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct ContactPointArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTACT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTACT_OPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AREA_SERVED: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AVAILABLE_LANGUAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_COUNTRY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_REGION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_LOCALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSTAL_CODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STREET_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POST_OFFICE_BOX_NUMBER: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContactPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactPointArgs {
      NAME: None,
      CONTACT_TYPE: None,
      EMAIL: None,
      TELEPHONE: None,
      CONTACT_OPTION: None,
      AREA_SERVED: None,
      AVAILABLE_LANGUAGE: None,
      ADDRESS_COUNTRY: None,
      ADDRESS_REGION: None,
      ADDRESS_LOCALITY: None,
      POSTAL_CODE: None,
      STREET_ADDRESS: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}

pub struct ContactPointBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContactPointBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CONTACT_TYPE(&mut self, CONTACT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_CONTACT_TYPE, CONTACT_TYPE);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_CONTACT_OPTION(&mut self, CONTACT_OPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_CONTACT_OPTION, CONTACT_OPTION);
  }
  #[inline]
  pub fn add_AREA_SERVED(&mut self, AREA_SERVED: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_AREA_SERVED, AREA_SERVED);
  }
  #[inline]
  pub fn add_AVAILABLE_LANGUAGE(&mut self, AVAILABLE_LANGUAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_AVAILABLE_LANGUAGE, AVAILABLE_LANGUAGE);
  }
  #[inline]
  pub fn add_ADDRESS_COUNTRY(&mut self, ADDRESS_COUNTRY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_COUNTRY, ADDRESS_COUNTRY);
  }
  #[inline]
  pub fn add_ADDRESS_REGION(&mut self, ADDRESS_REGION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_REGION, ADDRESS_REGION);
  }
  #[inline]
  pub fn add_ADDRESS_LOCALITY(&mut self, ADDRESS_LOCALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_LOCALITY, ADDRESS_LOCALITY);
  }
  #[inline]
  pub fn add_POSTAL_CODE(&mut self, POSTAL_CODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_POSTAL_CODE, POSTAL_CODE);
  }
  #[inline]
  pub fn add_STREET_ADDRESS(&mut self, STREET_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_STREET_ADDRESS, STREET_ADDRESS);
  }
  #[inline]
  pub fn add_POST_OFFICE_BOX_NUMBER(&mut self, POST_OFFICE_BOX_NUMBER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContactPointBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContactPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContactPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContactPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContactPoint");
      ds.field("NAME", &self.NAME());
      ds.field("CONTACT_TYPE", &self.CONTACT_TYPE());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("CONTACT_OPTION", &self.CONTACT_OPTION());
      ds.field("AREA_SERVED", &self.AREA_SERVED());
      ds.field("AVAILABLE_LANGUAGE", &self.AVAILABLE_LANGUAGE());
      ds.field("ADDRESS_COUNTRY", &self.ADDRESS_COUNTRY());
      ds.field("ADDRESS_REGION", &self.ADDRESS_REGION());
      ds.field("ADDRESS_LOCALITY", &self.ADDRESS_LOCALITY());
      ds.field("POSTAL_CODE", &self.POSTAL_CODE());
      ds.field("STREET_ADDRESS", &self.STREET_ADDRESS());
      ds.field("POST_OFFICE_BOX_NUMBER", &self.POST_OFFICE_BOX_NUMBER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContactPointT {
  pub NAME: Option<String>,
  pub CONTACT_TYPE: Option<String>,
  pub EMAIL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub CONTACT_OPTION: Option<String>,
  pub AREA_SERVED: Option<String>,
  pub AVAILABLE_LANGUAGE: Option<String>,
  pub ADDRESS_COUNTRY: Option<String>,
  pub ADDRESS_REGION: Option<String>,
  pub ADDRESS_LOCALITY: Option<String>,
  pub POSTAL_CODE: Option<String>,
  pub STREET_ADDRESS: Option<String>,
  pub POST_OFFICE_BOX_NUMBER: Option<String>,
}
impl Default for ContactPointT {
  fn default() -> Self {
    Self {
      NAME: None,
      CONTACT_TYPE: None,
      EMAIL: None,
      TELEPHONE: None,
      CONTACT_OPTION: None,
      AREA_SERVED: None,
      AVAILABLE_LANGUAGE: None,
      ADDRESS_COUNTRY: None,
      ADDRESS_REGION: None,
      ADDRESS_LOCALITY: None,
      POSTAL_CODE: None,
      STREET_ADDRESS: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}
impl ContactPointT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ContactPoint<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTACT_TYPE = self.CONTACT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTACT_OPTION = self.CONTACT_OPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AREA_SERVED = self.AREA_SERVED.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AVAILABLE_LANGUAGE = self.AVAILABLE_LANGUAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_COUNTRY = self.ADDRESS_COUNTRY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_REGION = self.ADDRESS_REGION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_LOCALITY = self.ADDRESS_LOCALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSTAL_CODE = self.POSTAL_CODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STREET_ADDRESS = self.STREET_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ContactPoint::create(_fbb, &ContactPointArgs{
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER,
    })
  }
}
pub enum OrganizationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Organization<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Organization<'a> {
  type Inner = Organization<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Organization<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LEGAL_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Organization { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OrganizationArgs<'args>
  ) -> flatbuffers::WIPOffset<Organization<'bldr>> {
    let mut builder = OrganizationBuilder::new(_fbb);
    if let Some(x) = args.LEGAL_NAME { builder.add_LEGAL_NAME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OrganizationT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let LEGAL_NAME = self.LEGAL_NAME().map(|x| {
      x.to_string()
    });
    OrganizationT {
      NAME,
      LEGAL_NAME,
    }
  }

  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Organization::VT_NAME, None)}
  }
  #[inline]
  pub fn LEGAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Organization::VT_LEGAL_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Organization<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LEGAL_NAME", Self::VT_LEGAL_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct OrganizationArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LEGAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OrganizationArgs<'a> {
  #[inline]
  fn default() -> Self {
    OrganizationArgs {
      NAME: None,
      LEGAL_NAME: None,
    }
  }
}

pub struct OrganizationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OrganizationBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Organization::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_LEGAL_NAME(&mut self, LEGAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Organization::VT_LEGAL_NAME, LEGAL_NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OrganizationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OrganizationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Organization<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Organization<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Organization");
      ds.field("NAME", &self.NAME());
      ds.field("LEGAL_NAME", &self.LEGAL_NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OrganizationT {
  pub NAME: Option<String>,
  pub LEGAL_NAME: Option<String>,
}
impl Default for OrganizationT {
  fn default() -> Self {
    Self {
      NAME: None,
      LEGAL_NAME: None,
    }
  }
}
impl OrganizationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Organization<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LEGAL_NAME = self.LEGAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Organization::create(_fbb, &OrganizationArgs{
      NAME,
      LEGAL_NAME,
    })
  }
}
pub enum OccupationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Occupation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Occupation<'a> {
  type Inner = Occupation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Occupation<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Occupation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OccupationArgs<'args>
  ) -> flatbuffers::WIPOffset<Occupation<'bldr>> {
    let mut builder = OccupationBuilder::new(_fbb);
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OccupationT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    OccupationT {
      NAME,
    }
  }

  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Occupation::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Occupation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct OccupationArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OccupationArgs<'a> {
  #[inline]
  fn default() -> Self {
    OccupationArgs {
      NAME: None,
    }
  }
}

pub struct OccupationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OccupationBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Occupation::VT_NAME, NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OccupationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OccupationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Occupation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Occupation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Occupation");
      ds.field("NAME", &self.NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OccupationT {
  pub NAME: Option<String>,
}
impl Default for OccupationT {
  fn default() -> Self {
    Self {
      NAME: None,
    }
  }
}
impl OccupationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Occupation<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Occupation::create(_fbb, &OccupationArgs{
      NAME,
    })
  }
}
pub enum UPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// User Profile Message
pub struct UPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UPM<'a> {
  type Inner = UPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UPM<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ALTERNATE_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;
  pub const VT_SAME_AS: flatbuffers::VOffsetT = 12;
  pub const VT_URL: flatbuffers::VOffsetT = 14;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 16;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 18;
  pub const VT_KEY: flatbuffers::VOffsetT = 20;
  pub const VT_CONTACT_POINT: flatbuffers::VOffsetT = 22;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 24;
  pub const VT_JOB_TITLE: flatbuffers::VOffsetT = 26;
  pub const VT_AFFILIATION: flatbuffers::VOffsetT = 28;
  pub const VT_HAS_OCCUPATION: flatbuffers::VOffsetT = 30;
  pub const VT_FAMILY_NAME: flatbuffers::VOffsetT = 32;
  pub const VT_GIVEN_NAME: flatbuffers::VOffsetT = 34;
  pub const VT_ADDITIONAL_NAME: flatbuffers::VOffsetT = 36;
  pub const VT_HONORIFIC_PREFIX: flatbuffers::VOffsetT = 38;
  pub const VT_HONORIFIC_SUFFIX: flatbuffers::VOffsetT = 40;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UPMArgs<'args>
  ) -> flatbuffers::WIPOffset<UPM<'bldr>> {
    let mut builder = UPMBuilder::new(_fbb);
    if let Some(x) = args.HONORIFIC_SUFFIX { builder.add_HONORIFIC_SUFFIX(x); }
    if let Some(x) = args.HONORIFIC_PREFIX { builder.add_HONORIFIC_PREFIX(x); }
    if let Some(x) = args.ADDITIONAL_NAME { builder.add_ADDITIONAL_NAME(x); }
    if let Some(x) = args.GIVEN_NAME { builder.add_GIVEN_NAME(x); }
    if let Some(x) = args.FAMILY_NAME { builder.add_FAMILY_NAME(x); }
    if let Some(x) = args.HAS_OCCUPATION { builder.add_HAS_OCCUPATION(x); }
    if let Some(x) = args.AFFILIATION { builder.add_AFFILIATION(x); }
    if let Some(x) = args.JOB_TITLE { builder.add_JOB_TITLE(x); }
    if let Some(x) = args.ADDRESS { builder.add_ADDRESS(x); }
    if let Some(x) = args.CONTACT_POINT { builder.add_CONTACT_POINT(x); }
    if let Some(x) = args.KEY { builder.add_KEY(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.URL { builder.add_URL(x); }
    if let Some(x) = args.SAME_AS { builder.add_SAME_AS(x); }
    if let Some(x) = args.IMAGE { builder.add_IMAGE(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.ALTERNATE_NAME { builder.add_ALTERNATE_NAME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UPMT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ALTERNATE_NAME = self.ALTERNATE_NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let IMAGE = self.IMAGE().map(|x| {
      x.to_string()
    });
    let SAME_AS = self.SAME_AS().map(|x| {
      x.to_string()
    });
    let URL = self.URL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let KEY = self.KEY().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let CONTACT_POINT = self.CONTACT_POINT().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ADDRESS = self.ADDRESS().map(|x| {
      Box::new(x.unpack())
    });
    let JOB_TITLE = self.JOB_TITLE().map(|x| {
      x.to_string()
    });
    let AFFILIATION = self.AFFILIATION().map(|x| {
      Box::new(x.unpack())
    });
    let HAS_OCCUPATION = self.HAS_OCCUPATION().map(|x| {
      Box::new(x.unpack())
    });
    let FAMILY_NAME = self.FAMILY_NAME().map(|x| {
      x.to_string()
    });
    let GIVEN_NAME = self.GIVEN_NAME().map(|x| {
      x.to_string()
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME().map(|x| {
      x.to_string()
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX().map(|x| {
      x.to_string()
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX().map(|x| {
      x.to_string()
    });
    UPMT {
      NAME,
      ALTERNATE_NAME,
      DESCRIPTION,
      IMAGE,
      SAME_AS,
      URL,
      TELEPHONE,
      EMAIL,
      KEY,
      CONTACT_POINT,
      ADDRESS,
      JOB_TITLE,
      AFFILIATION,
      HAS_OCCUPATION,
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
    }
  }

  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_NAME, None)}
  }
  #[inline]
  pub fn ALTERNATE_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_ALTERNATE_NAME, None)}
  }
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn IMAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_IMAGE, None)}
  }
  #[inline]
  pub fn SAME_AS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_SAME_AS, None)}
  }
  #[inline]
  pub fn URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_URL, None)}
  }
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_TELEPHONE, None)}
  }
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_EMAIL, None)}
  }
  #[inline]
  pub fn KEY(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey>>>>(UPM::VT_KEY, None)}
  }
  #[inline]
  pub fn CONTACT_POINT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint>>>>(UPM::VT_CONTACT_POINT, None)}
  }
  #[inline]
  pub fn ADDRESS(&self) -> Option<ContactPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContactPoint>>(UPM::VT_ADDRESS, None)}
  }
  #[inline]
  pub fn JOB_TITLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_JOB_TITLE, None)}
  }
  #[inline]
  pub fn AFFILIATION(&self) -> Option<Organization<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Organization>>(UPM::VT_AFFILIATION, None)}
  }
  #[inline]
  pub fn HAS_OCCUPATION(&self) -> Option<Occupation<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Occupation>>(UPM::VT_HAS_OCCUPATION, None)}
  }
  #[inline]
  pub fn FAMILY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_FAMILY_NAME, None)}
  }
  #[inline]
  pub fn GIVEN_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_GIVEN_NAME, None)}
  }
  #[inline]
  pub fn ADDITIONAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_ADDITIONAL_NAME, None)}
  }
  #[inline]
  pub fn HONORIFIC_PREFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_HONORIFIC_PREFIX, None)}
  }
  #[inline]
  pub fn HONORIFIC_SUFFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UPM::VT_HONORIFIC_SUFFIX, None)}
  }
}

impl flatbuffers::Verifiable for UPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALTERNATE_NAME", Self::VT_ALTERNATE_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMAGE", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SAME_AS", Self::VT_SAME_AS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("URL", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CryptoKey>>>>("KEY", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContactPoint>>>>("CONTACT_POINT", Self::VT_CONTACT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContactPoint>>("ADDRESS", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JOB_TITLE", Self::VT_JOB_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Organization>>("AFFILIATION", Self::VT_AFFILIATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Occupation>>("HAS_OCCUPATION", Self::VT_HAS_OCCUPATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FAMILY_NAME", Self::VT_FAMILY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GIVEN_NAME", Self::VT_GIVEN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDITIONAL_NAME", Self::VT_ADDITIONAL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_PREFIX", Self::VT_HONORIFIC_PREFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_SUFFIX", Self::VT_HONORIFIC_SUFFIX, false)?
     .finish();
    Ok(())
  }
}
pub struct UPMArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALTERNATE_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAME_AS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>>>,
    pub CONTACT_POINT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint<'a>>>>>,
    pub ADDRESS: Option<flatbuffers::WIPOffset<ContactPoint<'a>>>,
    pub JOB_TITLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AFFILIATION: Option<flatbuffers::WIPOffset<Organization<'a>>>,
    pub HAS_OCCUPATION: Option<flatbuffers::WIPOffset<Occupation<'a>>>,
    pub FAMILY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GIVEN_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDITIONAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_PREFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_SUFFIX: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    UPMArgs {
      NAME: None,
      ALTERNATE_NAME: None,
      DESCRIPTION: None,
      IMAGE: None,
      SAME_AS: None,
      URL: None,
      TELEPHONE: None,
      EMAIL: None,
      KEY: None,
      CONTACT_POINT: None,
      ADDRESS: None,
      JOB_TITLE: None,
      AFFILIATION: None,
      HAS_OCCUPATION: None,
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
    }
  }
}

pub struct UPMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UPMBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ALTERNATE_NAME(&mut self, ALTERNATE_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_ALTERNATE_NAME, ALTERNATE_NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_IMAGE(&mut self, IMAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_IMAGE, IMAGE);
  }
  #[inline]
  pub fn add_SAME_AS(&mut self, SAME_AS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_SAME_AS, SAME_AS);
  }
  #[inline]
  pub fn add_URL(&mut self, URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_URL, URL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_KEY(&mut self, KEY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CryptoKey<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_KEY, KEY);
  }
  #[inline]
  pub fn add_CONTACT_POINT(&mut self, CONTACT_POINT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContactPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_CONTACT_POINT, CONTACT_POINT);
  }
  #[inline]
  pub fn add_ADDRESS(&mut self, ADDRESS: flatbuffers::WIPOffset<ContactPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContactPoint>>(UPM::VT_ADDRESS, ADDRESS);
  }
  #[inline]
  pub fn add_JOB_TITLE(&mut self, JOB_TITLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_JOB_TITLE, JOB_TITLE);
  }
  #[inline]
  pub fn add_AFFILIATION(&mut self, AFFILIATION: flatbuffers::WIPOffset<Organization<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Organization>>(UPM::VT_AFFILIATION, AFFILIATION);
  }
  #[inline]
  pub fn add_HAS_OCCUPATION(&mut self, HAS_OCCUPATION: flatbuffers::WIPOffset<Occupation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Occupation>>(UPM::VT_HAS_OCCUPATION, HAS_OCCUPATION);
  }
  #[inline]
  pub fn add_FAMILY_NAME(&mut self, FAMILY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_FAMILY_NAME, FAMILY_NAME);
  }
  #[inline]
  pub fn add_GIVEN_NAME(&mut self, GIVEN_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_GIVEN_NAME, GIVEN_NAME);
  }
  #[inline]
  pub fn add_ADDITIONAL_NAME(&mut self, ADDITIONAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  #[inline]
  pub fn add_HONORIFIC_PREFIX(&mut self, HONORIFIC_PREFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  #[inline]
  pub fn add_HONORIFIC_SUFFIX(&mut self, HONORIFIC_SUFFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPM::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UPMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UPM");
      ds.field("NAME", &self.NAME());
      ds.field("ALTERNATE_NAME", &self.ALTERNATE_NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("IMAGE", &self.IMAGE());
      ds.field("SAME_AS", &self.SAME_AS());
      ds.field("URL", &self.URL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("KEY", &self.KEY());
      ds.field("CONTACT_POINT", &self.CONTACT_POINT());
      ds.field("ADDRESS", &self.ADDRESS());
      ds.field("JOB_TITLE", &self.JOB_TITLE());
      ds.field("AFFILIATION", &self.AFFILIATION());
      ds.field("HAS_OCCUPATION", &self.HAS_OCCUPATION());
      ds.field("FAMILY_NAME", &self.FAMILY_NAME());
      ds.field("GIVEN_NAME", &self.GIVEN_NAME());
      ds.field("ADDITIONAL_NAME", &self.ADDITIONAL_NAME());
      ds.field("HONORIFIC_PREFIX", &self.HONORIFIC_PREFIX());
      ds.field("HONORIFIC_SUFFIX", &self.HONORIFIC_SUFFIX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UPMT {
  pub NAME: Option<String>,
  pub ALTERNATE_NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub IMAGE: Option<String>,
  pub SAME_AS: Option<String>,
  pub URL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub EMAIL: Option<String>,
  pub KEY: Option<Vec<CryptoKeyT>>,
  pub CONTACT_POINT: Option<Vec<ContactPointT>>,
  pub ADDRESS: Option<Box<ContactPointT>>,
  pub JOB_TITLE: Option<String>,
  pub AFFILIATION: Option<Box<OrganizationT>>,
  pub HAS_OCCUPATION: Option<Box<OccupationT>>,
  pub FAMILY_NAME: Option<String>,
  pub GIVEN_NAME: Option<String>,
  pub ADDITIONAL_NAME: Option<String>,
  pub HONORIFIC_PREFIX: Option<String>,
  pub HONORIFIC_SUFFIX: Option<String>,
}
impl Default for UPMT {
  fn default() -> Self {
    Self {
      NAME: None,
      ALTERNATE_NAME: None,
      DESCRIPTION: None,
      IMAGE: None,
      SAME_AS: None,
      URL: None,
      TELEPHONE: None,
      EMAIL: None,
      KEY: None,
      CONTACT_POINT: None,
      ADDRESS: None,
      JOB_TITLE: None,
      AFFILIATION: None,
      HAS_OCCUPATION: None,
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
    }
  }
}
impl UPMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UPM<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALTERNATE_NAME = self.ALTERNATE_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMAGE = self.IMAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAME_AS = self.SAME_AS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let URL = self.URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY = self.KEY.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let CONTACT_POINT = self.CONTACT_POINT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ADDRESS = self.ADDRESS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let JOB_TITLE = self.JOB_TITLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AFFILIATION = self.AFFILIATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let HAS_OCCUPATION = self.HAS_OCCUPATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let FAMILY_NAME = self.FAMILY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GIVEN_NAME = self.GIVEN_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    UPM::create(_fbb, &UPMArgs{
      NAME,
      ALTERNATE_NAME,
      DESCRIPTION,
      IMAGE,
      SAME_AS,
      URL,
      TELEPHONE,
      EMAIL,
      KEY,
      CONTACT_POINT,
      ADDRESS,
      JOB_TITLE,
      AFFILIATION,
      HAS_OCCUPATION,
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
    })
  }
}
pub enum UPMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UPMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UPMCOLLECTION<'a> {
  type Inner = UPMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UPMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UPMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UPMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<UPMCOLLECTION<'bldr>> {
    let mut builder = UPMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UPMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    UPMCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM>>>>(UPMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for UPMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UPM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct UPMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>>>,
}
impl<'a> Default for UPMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    UPMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct UPMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UPMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UPMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UPMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UPMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UPMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UPMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UPMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UPMCOLLECTIONT {
  pub RECORDS: Option<Vec<UPMT>>,
}
impl Default for UPMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl UPMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UPMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    UPMCOLLECTION::create(_fbb, &UPMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `UPM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_UPM_unchecked`.
pub fn root_as_UPM(buf: &[u8]) -> Result<UPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<UPM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `UPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_UPM_unchecked`.
pub fn size_prefixed_root_as_UPM(buf: &[u8]) -> Result<UPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<UPM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `UPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_UPM_unchecked`.
pub fn root_as_UPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<UPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<UPM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `UPM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_UPM_unchecked`.
pub fn size_prefixed_root_as_UPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<UPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<UPM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a UPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `UPM`.
pub unsafe fn root_as_UPM_unchecked(buf: &[u8]) -> UPM {
  flatbuffers::root_unchecked::<UPM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed UPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `UPM`.
pub unsafe fn size_prefixed_root_as_UPM_unchecked(buf: &[u8]) -> UPM {
  flatbuffers::size_prefixed_root_unchecked::<UPM>(buf)
}
pub const UPM_IDENTIFIER: &str = "$UPM";

#[inline]
pub fn UPM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, UPM_IDENTIFIER, false)
}

#[inline]
pub fn UPM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, UPM_IDENTIFIER, true)
}

#[inline]
pub fn finish_UPM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<UPM<'a>>) {
  fbb.finish(root, Some(UPM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_UPM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<UPM<'a>>) {
  fbb.finish_size_prefixed(root, Some(UPM_IDENTIFIER));
}
