// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum LNDOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Launch Detection
pub struct LND<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LND<'a> {
  type Inner = LND<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LND<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LAUNCH_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_LAUNCH_LATITUDE: flatbuffers::VOffsetT = 10;
  pub const VT_LAUNCH_LONGITUDE: flatbuffers::VOffsetT = 12;
  pub const VT_LAUNCH_AZIMUTH: flatbuffers::VOffsetT = 14;
  pub const VT_RAAN: flatbuffers::VOffsetT = 16;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 18;
  pub const VT_OBSERVATION_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_OBSERVATION_LATITUDE: flatbuffers::VOffsetT = 22;
  pub const VT_OBSERVATION_LONGITUDE: flatbuffers::VOffsetT = 24;
  pub const VT_OBSERVATION_ALTITUDE: flatbuffers::VOffsetT = 26;
  pub const VT_STEREO_FLAG: flatbuffers::VOffsetT = 28;
  pub const VT_HIGH_ZENITH_AZIMUTH: flatbuffers::VOffsetT = 30;
  pub const VT_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 32;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 34;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 36;
  pub const VT_TAGS: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LND { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LNDArgs<'args>
  ) -> flatbuffers::WIPOffset<LND<'bldr>> {
    let mut builder = LNDBuilder::new(_fbb);
    builder.add_OBSERVATION_ALTITUDE(args.OBSERVATION_ALTITUDE);
    builder.add_OBSERVATION_LONGITUDE(args.OBSERVATION_LONGITUDE);
    builder.add_OBSERVATION_LATITUDE(args.OBSERVATION_LATITUDE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_RAAN(args.RAAN);
    builder.add_LAUNCH_AZIMUTH(args.LAUNCH_AZIMUTH);
    builder.add_LAUNCH_LONGITUDE(args.LAUNCH_LONGITUDE);
    builder.add_LAUNCH_LATITUDE(args.LAUNCH_LATITUDE);
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    if let Some(x) = args.EVENT_ID { builder.add_EVENT_ID(x); }
    builder.add_SEQUENCE_NUMBER(args.SEQUENCE_NUMBER);
    if let Some(x) = args.OBSERVATION_TIME { builder.add_OBSERVATION_TIME(x); }
    if let Some(x) = args.MESSAGE_TYPE { builder.add_MESSAGE_TYPE(x); }
    if let Some(x) = args.LAUNCH_TIME { builder.add_LAUNCH_TIME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_HIGH_ZENITH_AZIMUTH(args.HIGH_ZENITH_AZIMUTH);
    builder.add_STEREO_FLAG(args.STEREO_FLAG);
    builder.finish()
  }

  pub fn unpack(&self) -> LNDT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let LAUNCH_TIME = self.LAUNCH_TIME().map(|x| {
      x.to_string()
    });
    let MESSAGE_TYPE = self.MESSAGE_TYPE().map(|x| {
      x.to_string()
    });
    let LAUNCH_LATITUDE = self.LAUNCH_LATITUDE();
    let LAUNCH_LONGITUDE = self.LAUNCH_LONGITUDE();
    let LAUNCH_AZIMUTH = self.LAUNCH_AZIMUTH();
    let RAAN = self.RAAN();
    let INCLINATION = self.INCLINATION();
    let OBSERVATION_TIME = self.OBSERVATION_TIME().map(|x| {
      x.to_string()
    });
    let OBSERVATION_LATITUDE = self.OBSERVATION_LATITUDE();
    let OBSERVATION_LONGITUDE = self.OBSERVATION_LONGITUDE();
    let OBSERVATION_ALTITUDE = self.OBSERVATION_ALTITUDE();
    let STEREO_FLAG = self.STEREO_FLAG();
    let HIGH_ZENITH_AZIMUTH = self.HIGH_ZENITH_AZIMUTH();
    let SEQUENCE_NUMBER = self.SEQUENCE_NUMBER();
    let EVENT_ID = self.EVENT_ID().map(|x| {
      x.to_string()
    });
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    LNDT {
      ID,
      LAUNCH_TIME,
      MESSAGE_TYPE,
      LAUNCH_LATITUDE,
      LAUNCH_LONGITUDE,
      LAUNCH_AZIMUTH,
      RAAN,
      INCLINATION,
      OBSERVATION_TIME,
      OBSERVATION_LATITUDE,
      OBSERVATION_LONGITUDE,
      OBSERVATION_ALTITUDE,
      STEREO_FLAG,
      HIGH_ZENITH_AZIMUTH,
      SEQUENCE_NUMBER,
      EVENT_ID,
      DESCRIPTOR,
      TAGS,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_ID, None)}
  }
  #[inline]
  pub fn LAUNCH_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_LAUNCH_TIME, None)}
  }
  #[inline]
  pub fn MESSAGE_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_MESSAGE_TYPE, None)}
  }
  #[inline]
  pub fn LAUNCH_LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_LATITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_LONGITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LAUNCH_AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_AZIMUTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_RAAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OBSERVATION_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_OBSERVATION_TIME, None)}
  }
  #[inline]
  pub fn OBSERVATION_LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_LATITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OBSERVATION_LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_LONGITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OBSERVATION_ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_ALTITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn STEREO_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LND::VT_STEREO_FLAG, Some(false)).unwrap()}
  }
  #[inline]
  pub fn HIGH_ZENITH_AZIMUTH(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LND::VT_HIGH_ZENITH_AZIMUTH, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SEQUENCE_NUMBER(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LND::VT_SEQUENCE_NUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EVENT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_EVENT_ID, None)}
  }
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_DESCRIPTOR, None)}
  }
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LND::VT_TAGS, None)}
  }
}

impl flatbuffers::Verifiable for LND<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_TIME", Self::VT_LAUNCH_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MESSAGE_TYPE", Self::VT_MESSAGE_TYPE, false)?
     .visit_field::<f64>("LAUNCH_LATITUDE", Self::VT_LAUNCH_LATITUDE, false)?
     .visit_field::<f64>("LAUNCH_LONGITUDE", Self::VT_LAUNCH_LONGITUDE, false)?
     .visit_field::<f64>("LAUNCH_AZIMUTH", Self::VT_LAUNCH_AZIMUTH, false)?
     .visit_field::<f64>("RAAN", Self::VT_RAAN, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVATION_TIME", Self::VT_OBSERVATION_TIME, false)?
     .visit_field::<f64>("OBSERVATION_LATITUDE", Self::VT_OBSERVATION_LATITUDE, false)?
     .visit_field::<f64>("OBSERVATION_LONGITUDE", Self::VT_OBSERVATION_LONGITUDE, false)?
     .visit_field::<f64>("OBSERVATION_ALTITUDE", Self::VT_OBSERVATION_ALTITUDE, false)?
     .visit_field::<bool>("STEREO_FLAG", Self::VT_STEREO_FLAG, false)?
     .visit_field::<bool>("HIGH_ZENITH_AZIMUTH", Self::VT_HIGH_ZENITH_AZIMUTH, false)?
     .visit_field::<i32>("SEQUENCE_NUMBER", Self::VT_SEQUENCE_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EVENT_ID", Self::VT_EVENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct LNDArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MESSAGE_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_LATITUDE: f64,
    pub LAUNCH_LONGITUDE: f64,
    pub LAUNCH_AZIMUTH: f64,
    pub RAAN: f64,
    pub INCLINATION: f64,
    pub OBSERVATION_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATION_LATITUDE: f64,
    pub OBSERVATION_LONGITUDE: f64,
    pub OBSERVATION_ALTITUDE: f64,
    pub STEREO_FLAG: bool,
    pub HIGH_ZENITH_AZIMUTH: bool,
    pub SEQUENCE_NUMBER: i32,
    pub EVENT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LNDArgs<'a> {
  #[inline]
  fn default() -> Self {
    LNDArgs {
      ID: None,
      LAUNCH_TIME: None,
      MESSAGE_TYPE: None,
      LAUNCH_LATITUDE: 0.0,
      LAUNCH_LONGITUDE: 0.0,
      LAUNCH_AZIMUTH: 0.0,
      RAAN: 0.0,
      INCLINATION: 0.0,
      OBSERVATION_TIME: None,
      OBSERVATION_LATITUDE: 0.0,
      OBSERVATION_LONGITUDE: 0.0,
      OBSERVATION_ALTITUDE: 0.0,
      STEREO_FLAG: false,
      HIGH_ZENITH_AZIMUTH: false,
      SEQUENCE_NUMBER: 0,
      EVENT_ID: None,
      DESCRIPTOR: None,
      TAGS: None,
    }
  }
}

pub struct LNDBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LNDBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_ID, ID);
  }
  #[inline]
  pub fn add_LAUNCH_TIME(&mut self, LAUNCH_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_LAUNCH_TIME, LAUNCH_TIME);
  }
  #[inline]
  pub fn add_MESSAGE_TYPE(&mut self, MESSAGE_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_MESSAGE_TYPE, MESSAGE_TYPE);
  }
  #[inline]
  pub fn add_LAUNCH_LATITUDE(&mut self, LAUNCH_LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_LATITUDE, LAUNCH_LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_LONGITUDE(&mut self, LAUNCH_LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_LONGITUDE, LAUNCH_LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_AZIMUTH(&mut self, LAUNCH_AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_AZIMUTH, LAUNCH_AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_RAAN(&mut self, RAAN: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_RAAN, RAAN, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_TIME(&mut self, OBSERVATION_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_OBSERVATION_TIME, OBSERVATION_TIME);
  }
  #[inline]
  pub fn add_OBSERVATION_LATITUDE(&mut self, OBSERVATION_LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_LATITUDE, OBSERVATION_LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_LONGITUDE(&mut self, OBSERVATION_LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_LONGITUDE, OBSERVATION_LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_ALTITUDE(&mut self, OBSERVATION_ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_ALTITUDE, OBSERVATION_ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_STEREO_FLAG(&mut self, STEREO_FLAG: bool) {
    self.fbb_.push_slot::<bool>(LND::VT_STEREO_FLAG, STEREO_FLAG, false);
  }
  #[inline]
  pub fn add_HIGH_ZENITH_AZIMUTH(&mut self, HIGH_ZENITH_AZIMUTH: bool) {
    self.fbb_.push_slot::<bool>(LND::VT_HIGH_ZENITH_AZIMUTH, HIGH_ZENITH_AZIMUTH, false);
  }
  #[inline]
  pub fn add_SEQUENCE_NUMBER(&mut self, SEQUENCE_NUMBER: i32) {
    self.fbb_.push_slot::<i32>(LND::VT_SEQUENCE_NUMBER, SEQUENCE_NUMBER, 0);
  }
  #[inline]
  pub fn add_EVENT_ID(&mut self, EVENT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_EVENT_ID, EVENT_ID);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LNDBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LNDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LND<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LND<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LND");
      ds.field("ID", &self.ID());
      ds.field("LAUNCH_TIME", &self.LAUNCH_TIME());
      ds.field("MESSAGE_TYPE", &self.MESSAGE_TYPE());
      ds.field("LAUNCH_LATITUDE", &self.LAUNCH_LATITUDE());
      ds.field("LAUNCH_LONGITUDE", &self.LAUNCH_LONGITUDE());
      ds.field("LAUNCH_AZIMUTH", &self.LAUNCH_AZIMUTH());
      ds.field("RAAN", &self.RAAN());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("OBSERVATION_TIME", &self.OBSERVATION_TIME());
      ds.field("OBSERVATION_LATITUDE", &self.OBSERVATION_LATITUDE());
      ds.field("OBSERVATION_LONGITUDE", &self.OBSERVATION_LONGITUDE());
      ds.field("OBSERVATION_ALTITUDE", &self.OBSERVATION_ALTITUDE());
      ds.field("STEREO_FLAG", &self.STEREO_FLAG());
      ds.field("HIGH_ZENITH_AZIMUTH", &self.HIGH_ZENITH_AZIMUTH());
      ds.field("SEQUENCE_NUMBER", &self.SEQUENCE_NUMBER());
      ds.field("EVENT_ID", &self.EVENT_ID());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("TAGS", &self.TAGS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LNDT {
  pub ID: Option<String>,
  pub LAUNCH_TIME: Option<String>,
  pub MESSAGE_TYPE: Option<String>,
  pub LAUNCH_LATITUDE: f64,
  pub LAUNCH_LONGITUDE: f64,
  pub LAUNCH_AZIMUTH: f64,
  pub RAAN: f64,
  pub INCLINATION: f64,
  pub OBSERVATION_TIME: Option<String>,
  pub OBSERVATION_LATITUDE: f64,
  pub OBSERVATION_LONGITUDE: f64,
  pub OBSERVATION_ALTITUDE: f64,
  pub STEREO_FLAG: bool,
  pub HIGH_ZENITH_AZIMUTH: bool,
  pub SEQUENCE_NUMBER: i32,
  pub EVENT_ID: Option<String>,
  pub DESCRIPTOR: Option<String>,
  pub TAGS: Option<Vec<String>>,
}
impl Default for LNDT {
  fn default() -> Self {
    Self {
      ID: None,
      LAUNCH_TIME: None,
      MESSAGE_TYPE: None,
      LAUNCH_LATITUDE: 0.0,
      LAUNCH_LONGITUDE: 0.0,
      LAUNCH_AZIMUTH: 0.0,
      RAAN: 0.0,
      INCLINATION: 0.0,
      OBSERVATION_TIME: None,
      OBSERVATION_LATITUDE: 0.0,
      OBSERVATION_LONGITUDE: 0.0,
      OBSERVATION_ALTITUDE: 0.0,
      STEREO_FLAG: false,
      HIGH_ZENITH_AZIMUTH: false,
      SEQUENCE_NUMBER: 0,
      EVENT_ID: None,
      DESCRIPTOR: None,
      TAGS: None,
    }
  }
}
impl LNDT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LND<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_TIME = self.LAUNCH_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MESSAGE_TYPE = self.MESSAGE_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_LATITUDE = self.LAUNCH_LATITUDE;
    let LAUNCH_LONGITUDE = self.LAUNCH_LONGITUDE;
    let LAUNCH_AZIMUTH = self.LAUNCH_AZIMUTH;
    let RAAN = self.RAAN;
    let INCLINATION = self.INCLINATION;
    let OBSERVATION_TIME = self.OBSERVATION_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATION_LATITUDE = self.OBSERVATION_LATITUDE;
    let OBSERVATION_LONGITUDE = self.OBSERVATION_LONGITUDE;
    let OBSERVATION_ALTITUDE = self.OBSERVATION_ALTITUDE;
    let STEREO_FLAG = self.STEREO_FLAG;
    let HIGH_ZENITH_AZIMUTH = self.HIGH_ZENITH_AZIMUTH;
    let SEQUENCE_NUMBER = self.SEQUENCE_NUMBER;
    let EVENT_ID = self.EVENT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    LND::create(_fbb, &LNDArgs{
      ID,
      LAUNCH_TIME,
      MESSAGE_TYPE,
      LAUNCH_LATITUDE,
      LAUNCH_LONGITUDE,
      LAUNCH_AZIMUTH,
      RAAN,
      INCLINATION,
      OBSERVATION_TIME,
      OBSERVATION_LATITUDE,
      OBSERVATION_LONGITUDE,
      OBSERVATION_ALTITUDE,
      STEREO_FLAG,
      HIGH_ZENITH_AZIMUTH,
      SEQUENCE_NUMBER,
      EVENT_ID,
      DESCRIPTOR,
      TAGS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LND`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn root_as_LND(buf: &[u8]) -> Result<LND, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LND>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LND` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_LND_unchecked`.
pub fn size_prefixed_root_as_LND(buf: &[u8]) -> Result<LND, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LND>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LND` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn root_as_LND_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LND<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LND<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LND` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn size_prefixed_root_as_LND_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LND<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LND<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LND and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LND`.
pub unsafe fn root_as_LND_unchecked(buf: &[u8]) -> LND {
  flatbuffers::root_unchecked::<LND>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LND and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LND`.
pub unsafe fn size_prefixed_root_as_LND_unchecked(buf: &[u8]) -> LND {
  flatbuffers::size_prefixed_root_unchecked::<LND>(buf)
}
pub const LND_IDENTIFIER: &str = "$LND";

#[inline]
pub fn LND_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LND_IDENTIFIER, false)
}

#[inline]
pub fn LND_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LND_IDENTIFIER, true)
}

#[inline]
pub fn finish_LND_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LND<'a>>) {
  fbb.finish(root, Some(LND_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_LND_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LND<'a>>) {
  fbb.finish_size_prefixed(root, Some(LND_IDENTIFIER));
}
