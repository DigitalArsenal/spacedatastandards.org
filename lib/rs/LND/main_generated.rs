// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LAUNCH_DETECTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LAUNCH_DETECTION_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LAUNCH_DETECTION_TYPE: [launchDetectionType; 6] = [
  launchDetectionType::IR_DETECT,
  launchDetectionType::RADAR_DETECT,
  launchDetectionType::OPTICAL_DETECT,
  launchDetectionType::ELINT_DETECT,
  launchDetectionType::COMBINED,
  launchDetectionType::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct launchDetectionType(pub i8);
#[allow(non_upper_case_globals)]
impl launchDetectionType {
  pub const IR_DETECT: Self = Self(0);
  pub const RADAR_DETECT: Self = Self(1);
  pub const OPTICAL_DETECT: Self = Self(2);
  pub const ELINT_DETECT: Self = Self(3);
  pub const COMBINED: Self = Self(4);
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IR_DETECT,
    Self::RADAR_DETECT,
    Self::OPTICAL_DETECT,
    Self::ELINT_DETECT,
    Self::COMBINED,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::IR_DETECT => Some("IR_DETECT"),
      Self::RADAR_DETECT => Some("RADAR_DETECT"),
      Self::OPTICAL_DETECT => Some("OPTICAL_DETECT"),
      Self::ELINT_DETECT => Some("ELINT_DETECT"),
      Self::COMBINED => Some("COMBINED"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for launchDetectionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for launchDetectionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for launchDetectionType {
    type Output = launchDetectionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for launchDetectionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for launchDetectionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for launchDetectionType {}
pub enum LNDOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Launch Detection
pub struct LND<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LND<'a> {
  type Inner = LND<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LND<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_EVENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DETECTION_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_LAUNCH_TIME: flatbuffers::VOffsetT = 12;
  pub const VT_LAUNCH_LATITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_LAUNCH_LONGITUDE: flatbuffers::VOffsetT = 16;
  pub const VT_LAUNCH_AZIMUTH: flatbuffers::VOffsetT = 18;
  pub const VT_RAAN: flatbuffers::VOffsetT = 20;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 22;
  pub const VT_OBSERVATION_TIME: flatbuffers::VOffsetT = 24;
  pub const VT_OBSERVATION_LATITUDE: flatbuffers::VOffsetT = 26;
  pub const VT_OBSERVATION_LONGITUDE: flatbuffers::VOffsetT = 28;
  pub const VT_OBSERVATION_ALTITUDE: flatbuffers::VOffsetT = 30;
  pub const VT_STEREO_FLAG: flatbuffers::VOffsetT = 32;
  pub const VT_HIGH_ZENITH_AZIMUTH: flatbuffers::VOffsetT = 34;
  pub const VT_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 36;
  pub const VT_LAUNCH_SITE_ID: flatbuffers::VOffsetT = 38;
  pub const VT_LAUNCH_VEHICLE: flatbuffers::VOffsetT = 40;
  pub const VT_TRAJECTORY_TYPE: flatbuffers::VOffsetT = 42;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 44;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 46;
  pub const VT_TAGS: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LND { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LNDArgs<'args>
  ) -> flatbuffers::WIPOffset<LND<'bldr>> {
    let mut builder = LNDBuilder::new(_fbb);
    builder.add_CONFIDENCE(args.CONFIDENCE);
    builder.add_OBSERVATION_ALTITUDE(args.OBSERVATION_ALTITUDE);
    builder.add_OBSERVATION_LONGITUDE(args.OBSERVATION_LONGITUDE);
    builder.add_OBSERVATION_LATITUDE(args.OBSERVATION_LATITUDE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_RAAN(args.RAAN);
    builder.add_LAUNCH_AZIMUTH(args.LAUNCH_AZIMUTH);
    builder.add_LAUNCH_LONGITUDE(args.LAUNCH_LONGITUDE);
    builder.add_LAUNCH_LATITUDE(args.LAUNCH_LATITUDE);
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    if let Some(x) = args.TRAJECTORY_TYPE { builder.add_TRAJECTORY_TYPE(x); }
    if let Some(x) = args.LAUNCH_VEHICLE { builder.add_LAUNCH_VEHICLE(x); }
    if let Some(x) = args.LAUNCH_SITE_ID { builder.add_LAUNCH_SITE_ID(x); }
    if let Some(x) = args.OBSERVATION_TIME { builder.add_OBSERVATION_TIME(x); }
    if let Some(x) = args.LAUNCH_TIME { builder.add_LAUNCH_TIME(x); }
    if let Some(x) = args.MESSAGE_TYPE { builder.add_MESSAGE_TYPE(x); }
    if let Some(x) = args.EVENT_ID { builder.add_EVENT_ID(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_SEQUENCE_NUMBER(args.SEQUENCE_NUMBER);
    builder.add_HIGH_ZENITH_AZIMUTH(args.HIGH_ZENITH_AZIMUTH);
    builder.add_STEREO_FLAG(args.STEREO_FLAG);
    builder.add_DETECTION_TYPE(args.DETECTION_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> LNDT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let EVENT_ID = self.EVENT_ID().map(|x| {
      x.to_string()
    });
    let DETECTION_TYPE = self.DETECTION_TYPE();
    let MESSAGE_TYPE = self.MESSAGE_TYPE().map(|x| {
      x.to_string()
    });
    let LAUNCH_TIME = self.LAUNCH_TIME().map(|x| {
      x.to_string()
    });
    let LAUNCH_LATITUDE = self.LAUNCH_LATITUDE();
    let LAUNCH_LONGITUDE = self.LAUNCH_LONGITUDE();
    let LAUNCH_AZIMUTH = self.LAUNCH_AZIMUTH();
    let RAAN = self.RAAN();
    let INCLINATION = self.INCLINATION();
    let OBSERVATION_TIME = self.OBSERVATION_TIME().map(|x| {
      x.to_string()
    });
    let OBSERVATION_LATITUDE = self.OBSERVATION_LATITUDE();
    let OBSERVATION_LONGITUDE = self.OBSERVATION_LONGITUDE();
    let OBSERVATION_ALTITUDE = self.OBSERVATION_ALTITUDE();
    let STEREO_FLAG = self.STEREO_FLAG();
    let HIGH_ZENITH_AZIMUTH = self.HIGH_ZENITH_AZIMUTH();
    let SEQUENCE_NUMBER = self.SEQUENCE_NUMBER();
    let LAUNCH_SITE_ID = self.LAUNCH_SITE_ID().map(|x| {
      x.to_string()
    });
    let LAUNCH_VEHICLE = self.LAUNCH_VEHICLE().map(|x| {
      x.to_string()
    });
    let TRAJECTORY_TYPE = self.TRAJECTORY_TYPE().map(|x| {
      x.to_string()
    });
    let CONFIDENCE = self.CONFIDENCE();
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    LNDT {
      ID,
      EVENT_ID,
      DETECTION_TYPE,
      MESSAGE_TYPE,
      LAUNCH_TIME,
      LAUNCH_LATITUDE,
      LAUNCH_LONGITUDE,
      LAUNCH_AZIMUTH,
      RAAN,
      INCLINATION,
      OBSERVATION_TIME,
      OBSERVATION_LATITUDE,
      OBSERVATION_LONGITUDE,
      OBSERVATION_ALTITUDE,
      STEREO_FLAG,
      HIGH_ZENITH_AZIMUTH,
      SEQUENCE_NUMBER,
      LAUNCH_SITE_ID,
      LAUNCH_VEHICLE,
      TRAJECTORY_TYPE,
      CONFIDENCE,
      DESCRIPTOR,
      TAGS,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_ID, None)}
  }
  /// Detection event identifier
  #[inline]
  pub fn EVENT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_EVENT_ID, None)}
  }
  /// Detection type
  #[inline]
  pub fn DETECTION_TYPE(&self) -> launchDetectionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<launchDetectionType>(LND::VT_DETECTION_TYPE, Some(launchDetectionType::IR_DETECT)).unwrap()}
  }
  /// Detection message type code
  #[inline]
  pub fn MESSAGE_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_MESSAGE_TYPE, None)}
  }
  /// Time of launch detection (ISO 8601)
  #[inline]
  pub fn LAUNCH_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_LAUNCH_TIME, None)}
  }
  /// Launch site latitude (degrees)
  #[inline]
  pub fn LAUNCH_LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Launch site longitude (degrees)
  #[inline]
  pub fn LAUNCH_LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Launch azimuth (degrees from north)
  #[inline]
  pub fn LAUNCH_AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_LAUNCH_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// Estimated RAAN (degrees)
  #[inline]
  pub fn RAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_RAAN, Some(0.0)).unwrap()}
  }
  /// Estimated inclination (degrees)
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  /// Time of trajectory observation (ISO 8601)
  #[inline]
  pub fn OBSERVATION_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_OBSERVATION_TIME, None)}
  }
  /// Observation point latitude (degrees)
  #[inline]
  pub fn OBSERVATION_LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Observation point longitude (degrees)
  #[inline]
  pub fn OBSERVATION_LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Observation point altitude (km)
  #[inline]
  pub fn OBSERVATION_ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_OBSERVATION_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// True if stereo observation (multiple sensors)
  #[inline]
  pub fn STEREO_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LND::VT_STEREO_FLAG, Some(false)).unwrap()}
  }
  /// True if high zenith angle observation
  #[inline]
  pub fn HIGH_ZENITH_AZIMUTH(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LND::VT_HIGH_ZENITH_AZIMUTH, Some(false)).unwrap()}
  }
  /// Sequence number in detection chain
  #[inline]
  pub fn SEQUENCE_NUMBER(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(LND::VT_SEQUENCE_NUMBER, Some(0)).unwrap()}
  }
  /// Launch site identifier
  #[inline]
  pub fn LAUNCH_SITE_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_LAUNCH_SITE_ID, None)}
  }
  /// Launch vehicle type (if identified)
  #[inline]
  pub fn LAUNCH_VEHICLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_LAUNCH_VEHICLE, None)}
  }
  /// Estimated trajectory type
  #[inline]
  pub fn TRAJECTORY_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_TRAJECTORY_TYPE, None)}
  }
  /// Detection confidence (0-1)
  #[inline]
  pub fn CONFIDENCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LND::VT_CONFIDENCE, Some(0.0)).unwrap()}
  }
  /// Event descriptor
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LND::VT_DESCRIPTOR, None)}
  }
  /// Associated tags
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LND::VT_TAGS, None)}
  }
}

impl flatbuffers::Verifiable for LND<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EVENT_ID", Self::VT_EVENT_ID, false)?
     .visit_field::<launchDetectionType>("DETECTION_TYPE", Self::VT_DETECTION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MESSAGE_TYPE", Self::VT_MESSAGE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_TIME", Self::VT_LAUNCH_TIME, false)?
     .visit_field::<f64>("LAUNCH_LATITUDE", Self::VT_LAUNCH_LATITUDE, false)?
     .visit_field::<f64>("LAUNCH_LONGITUDE", Self::VT_LAUNCH_LONGITUDE, false)?
     .visit_field::<f64>("LAUNCH_AZIMUTH", Self::VT_LAUNCH_AZIMUTH, false)?
     .visit_field::<f64>("RAAN", Self::VT_RAAN, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBSERVATION_TIME", Self::VT_OBSERVATION_TIME, false)?
     .visit_field::<f64>("OBSERVATION_LATITUDE", Self::VT_OBSERVATION_LATITUDE, false)?
     .visit_field::<f64>("OBSERVATION_LONGITUDE", Self::VT_OBSERVATION_LONGITUDE, false)?
     .visit_field::<f64>("OBSERVATION_ALTITUDE", Self::VT_OBSERVATION_ALTITUDE, false)?
     .visit_field::<bool>("STEREO_FLAG", Self::VT_STEREO_FLAG, false)?
     .visit_field::<bool>("HIGH_ZENITH_AZIMUTH", Self::VT_HIGH_ZENITH_AZIMUTH, false)?
     .visit_field::<u16>("SEQUENCE_NUMBER", Self::VT_SEQUENCE_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_SITE_ID", Self::VT_LAUNCH_SITE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_VEHICLE", Self::VT_LAUNCH_VEHICLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRAJECTORY_TYPE", Self::VT_TRAJECTORY_TYPE, false)?
     .visit_field::<f64>("CONFIDENCE", Self::VT_CONFIDENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct LNDArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EVENT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DETECTION_TYPE: launchDetectionType,
    pub MESSAGE_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_LATITUDE: f64,
    pub LAUNCH_LONGITUDE: f64,
    pub LAUNCH_AZIMUTH: f64,
    pub RAAN: f64,
    pub INCLINATION: f64,
    pub OBSERVATION_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATION_LATITUDE: f64,
    pub OBSERVATION_LONGITUDE: f64,
    pub OBSERVATION_ALTITUDE: f64,
    pub STEREO_FLAG: bool,
    pub HIGH_ZENITH_AZIMUTH: bool,
    pub SEQUENCE_NUMBER: u16,
    pub LAUNCH_SITE_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_VEHICLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRAJECTORY_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONFIDENCE: f64,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LNDArgs<'a> {
  #[inline]
  fn default() -> Self {
    LNDArgs {
      ID: None,
      EVENT_ID: None,
      DETECTION_TYPE: launchDetectionType::IR_DETECT,
      MESSAGE_TYPE: None,
      LAUNCH_TIME: None,
      LAUNCH_LATITUDE: 0.0,
      LAUNCH_LONGITUDE: 0.0,
      LAUNCH_AZIMUTH: 0.0,
      RAAN: 0.0,
      INCLINATION: 0.0,
      OBSERVATION_TIME: None,
      OBSERVATION_LATITUDE: 0.0,
      OBSERVATION_LONGITUDE: 0.0,
      OBSERVATION_ALTITUDE: 0.0,
      STEREO_FLAG: false,
      HIGH_ZENITH_AZIMUTH: false,
      SEQUENCE_NUMBER: 0,
      LAUNCH_SITE_ID: None,
      LAUNCH_VEHICLE: None,
      TRAJECTORY_TYPE: None,
      CONFIDENCE: 0.0,
      DESCRIPTOR: None,
      TAGS: None,
    }
  }
}

pub struct LNDBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LNDBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_ID, ID);
  }
  #[inline]
  pub fn add_EVENT_ID(&mut self, EVENT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_EVENT_ID, EVENT_ID);
  }
  #[inline]
  pub fn add_DETECTION_TYPE(&mut self, DETECTION_TYPE: launchDetectionType) {
    self.fbb_.push_slot::<launchDetectionType>(LND::VT_DETECTION_TYPE, DETECTION_TYPE, launchDetectionType::IR_DETECT);
  }
  #[inline]
  pub fn add_MESSAGE_TYPE(&mut self, MESSAGE_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_MESSAGE_TYPE, MESSAGE_TYPE);
  }
  #[inline]
  pub fn add_LAUNCH_TIME(&mut self, LAUNCH_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_LAUNCH_TIME, LAUNCH_TIME);
  }
  #[inline]
  pub fn add_LAUNCH_LATITUDE(&mut self, LAUNCH_LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_LATITUDE, LAUNCH_LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_LONGITUDE(&mut self, LAUNCH_LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_LONGITUDE, LAUNCH_LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LAUNCH_AZIMUTH(&mut self, LAUNCH_AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_LAUNCH_AZIMUTH, LAUNCH_AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_RAAN(&mut self, RAAN: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_RAAN, RAAN, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_TIME(&mut self, OBSERVATION_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_OBSERVATION_TIME, OBSERVATION_TIME);
  }
  #[inline]
  pub fn add_OBSERVATION_LATITUDE(&mut self, OBSERVATION_LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_LATITUDE, OBSERVATION_LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_LONGITUDE(&mut self, OBSERVATION_LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_LONGITUDE, OBSERVATION_LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_OBSERVATION_ALTITUDE(&mut self, OBSERVATION_ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_OBSERVATION_ALTITUDE, OBSERVATION_ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_STEREO_FLAG(&mut self, STEREO_FLAG: bool) {
    self.fbb_.push_slot::<bool>(LND::VT_STEREO_FLAG, STEREO_FLAG, false);
  }
  #[inline]
  pub fn add_HIGH_ZENITH_AZIMUTH(&mut self, HIGH_ZENITH_AZIMUTH: bool) {
    self.fbb_.push_slot::<bool>(LND::VT_HIGH_ZENITH_AZIMUTH, HIGH_ZENITH_AZIMUTH, false);
  }
  #[inline]
  pub fn add_SEQUENCE_NUMBER(&mut self, SEQUENCE_NUMBER: u16) {
    self.fbb_.push_slot::<u16>(LND::VT_SEQUENCE_NUMBER, SEQUENCE_NUMBER, 0);
  }
  #[inline]
  pub fn add_LAUNCH_SITE_ID(&mut self, LAUNCH_SITE_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_LAUNCH_SITE_ID, LAUNCH_SITE_ID);
  }
  #[inline]
  pub fn add_LAUNCH_VEHICLE(&mut self, LAUNCH_VEHICLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_LAUNCH_VEHICLE, LAUNCH_VEHICLE);
  }
  #[inline]
  pub fn add_TRAJECTORY_TYPE(&mut self, TRAJECTORY_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_TRAJECTORY_TYPE, TRAJECTORY_TYPE);
  }
  #[inline]
  pub fn add_CONFIDENCE(&mut self, CONFIDENCE: f64) {
    self.fbb_.push_slot::<f64>(LND::VT_CONFIDENCE, CONFIDENCE, 0.0);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LND::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LNDBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LNDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LND<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LND<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LND");
      ds.field("ID", &self.ID());
      ds.field("EVENT_ID", &self.EVENT_ID());
      ds.field("DETECTION_TYPE", &self.DETECTION_TYPE());
      ds.field("MESSAGE_TYPE", &self.MESSAGE_TYPE());
      ds.field("LAUNCH_TIME", &self.LAUNCH_TIME());
      ds.field("LAUNCH_LATITUDE", &self.LAUNCH_LATITUDE());
      ds.field("LAUNCH_LONGITUDE", &self.LAUNCH_LONGITUDE());
      ds.field("LAUNCH_AZIMUTH", &self.LAUNCH_AZIMUTH());
      ds.field("RAAN", &self.RAAN());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("OBSERVATION_TIME", &self.OBSERVATION_TIME());
      ds.field("OBSERVATION_LATITUDE", &self.OBSERVATION_LATITUDE());
      ds.field("OBSERVATION_LONGITUDE", &self.OBSERVATION_LONGITUDE());
      ds.field("OBSERVATION_ALTITUDE", &self.OBSERVATION_ALTITUDE());
      ds.field("STEREO_FLAG", &self.STEREO_FLAG());
      ds.field("HIGH_ZENITH_AZIMUTH", &self.HIGH_ZENITH_AZIMUTH());
      ds.field("SEQUENCE_NUMBER", &self.SEQUENCE_NUMBER());
      ds.field("LAUNCH_SITE_ID", &self.LAUNCH_SITE_ID());
      ds.field("LAUNCH_VEHICLE", &self.LAUNCH_VEHICLE());
      ds.field("TRAJECTORY_TYPE", &self.TRAJECTORY_TYPE());
      ds.field("CONFIDENCE", &self.CONFIDENCE());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("TAGS", &self.TAGS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LNDT {
  pub ID: Option<String>,
  pub EVENT_ID: Option<String>,
  pub DETECTION_TYPE: launchDetectionType,
  pub MESSAGE_TYPE: Option<String>,
  pub LAUNCH_TIME: Option<String>,
  pub LAUNCH_LATITUDE: f64,
  pub LAUNCH_LONGITUDE: f64,
  pub LAUNCH_AZIMUTH: f64,
  pub RAAN: f64,
  pub INCLINATION: f64,
  pub OBSERVATION_TIME: Option<String>,
  pub OBSERVATION_LATITUDE: f64,
  pub OBSERVATION_LONGITUDE: f64,
  pub OBSERVATION_ALTITUDE: f64,
  pub STEREO_FLAG: bool,
  pub HIGH_ZENITH_AZIMUTH: bool,
  pub SEQUENCE_NUMBER: u16,
  pub LAUNCH_SITE_ID: Option<String>,
  pub LAUNCH_VEHICLE: Option<String>,
  pub TRAJECTORY_TYPE: Option<String>,
  pub CONFIDENCE: f64,
  pub DESCRIPTOR: Option<String>,
  pub TAGS: Option<Vec<String>>,
}
impl Default for LNDT {
  fn default() -> Self {
    Self {
      ID: None,
      EVENT_ID: None,
      DETECTION_TYPE: launchDetectionType::IR_DETECT,
      MESSAGE_TYPE: None,
      LAUNCH_TIME: None,
      LAUNCH_LATITUDE: 0.0,
      LAUNCH_LONGITUDE: 0.0,
      LAUNCH_AZIMUTH: 0.0,
      RAAN: 0.0,
      INCLINATION: 0.0,
      OBSERVATION_TIME: None,
      OBSERVATION_LATITUDE: 0.0,
      OBSERVATION_LONGITUDE: 0.0,
      OBSERVATION_ALTITUDE: 0.0,
      STEREO_FLAG: false,
      HIGH_ZENITH_AZIMUTH: false,
      SEQUENCE_NUMBER: 0,
      LAUNCH_SITE_ID: None,
      LAUNCH_VEHICLE: None,
      TRAJECTORY_TYPE: None,
      CONFIDENCE: 0.0,
      DESCRIPTOR: None,
      TAGS: None,
    }
  }
}
impl LNDT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LND<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EVENT_ID = self.EVENT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DETECTION_TYPE = self.DETECTION_TYPE;
    let MESSAGE_TYPE = self.MESSAGE_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_TIME = self.LAUNCH_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_LATITUDE = self.LAUNCH_LATITUDE;
    let LAUNCH_LONGITUDE = self.LAUNCH_LONGITUDE;
    let LAUNCH_AZIMUTH = self.LAUNCH_AZIMUTH;
    let RAAN = self.RAAN;
    let INCLINATION = self.INCLINATION;
    let OBSERVATION_TIME = self.OBSERVATION_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATION_LATITUDE = self.OBSERVATION_LATITUDE;
    let OBSERVATION_LONGITUDE = self.OBSERVATION_LONGITUDE;
    let OBSERVATION_ALTITUDE = self.OBSERVATION_ALTITUDE;
    let STEREO_FLAG = self.STEREO_FLAG;
    let HIGH_ZENITH_AZIMUTH = self.HIGH_ZENITH_AZIMUTH;
    let SEQUENCE_NUMBER = self.SEQUENCE_NUMBER;
    let LAUNCH_SITE_ID = self.LAUNCH_SITE_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_VEHICLE = self.LAUNCH_VEHICLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRAJECTORY_TYPE = self.TRAJECTORY_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONFIDENCE = self.CONFIDENCE;
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    LND::create(_fbb, &LNDArgs{
      ID,
      EVENT_ID,
      DETECTION_TYPE,
      MESSAGE_TYPE,
      LAUNCH_TIME,
      LAUNCH_LATITUDE,
      LAUNCH_LONGITUDE,
      LAUNCH_AZIMUTH,
      RAAN,
      INCLINATION,
      OBSERVATION_TIME,
      OBSERVATION_LATITUDE,
      OBSERVATION_LONGITUDE,
      OBSERVATION_ALTITUDE,
      STEREO_FLAG,
      HIGH_ZENITH_AZIMUTH,
      SEQUENCE_NUMBER,
      LAUNCH_SITE_ID,
      LAUNCH_VEHICLE,
      TRAJECTORY_TYPE,
      CONFIDENCE,
      DESCRIPTOR,
      TAGS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LND`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn root_as_LND(buf: &[u8]) -> Result<LND, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LND>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LND` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_LND_unchecked`.
pub fn size_prefixed_root_as_LND(buf: &[u8]) -> Result<LND, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LND>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LND` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn root_as_LND_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LND<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LND<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LND` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LND_unchecked`.
pub fn size_prefixed_root_as_LND_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LND<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LND<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LND and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LND`.
pub unsafe fn root_as_LND_unchecked(buf: &[u8]) -> LND {
  flatbuffers::root_unchecked::<LND>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LND and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LND`.
pub unsafe fn size_prefixed_root_as_LND_unchecked(buf: &[u8]) -> LND {
  flatbuffers::size_prefixed_root_unchecked::<LND>(buf)
}
pub const LND_IDENTIFIER: &str = "$LND";

#[inline]
pub fn LND_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LND_IDENTIFIER, false)
}

#[inline]
pub fn LND_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LND_IDENTIFIER, true)
}

#[inline]
pub fn finish_LND_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<LND<'a>>) {
  fbb.finish(root, Some(LND_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_LND_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<LND<'a>>) {
  fbb.finish_size_prefixed(root, Some(LND_IDENTIFIER));
}
