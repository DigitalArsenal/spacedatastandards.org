// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_LAYER: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_LAYER: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_LAYER: [ionoLayer; 7] = [
  ionoLayer::D,
  ionoLayer::E,
  ionoLayer::ES,
  ionoLayer::F,
  ionoLayer::F1,
  ionoLayer::F2,
  ionoLayer::TOPSIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ionoLayer(pub i8);
#[allow(non_upper_case_globals)]
impl ionoLayer {
  pub const D: Self = Self(0);
  pub const E: Self = Self(1);
  pub const ES: Self = Self(2);
  pub const F: Self = Self(3);
  pub const F1: Self = Self(4);
  pub const F2: Self = Self(5);
  pub const TOPSIDE: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::D,
    Self::E,
    Self::ES,
    Self::F,
    Self::F1,
    Self::F2,
    Self::TOPSIDE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::D => Some("D"),
      Self::E => Some("E"),
      Self::ES => Some("ES"),
      Self::F => Some("F"),
      Self::F1 => Some("F1"),
      Self::F2 => Some("F2"),
      Self::TOPSIDE => Some("TOPSIDE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ionoLayer {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ionoLayer {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ionoLayer {
    type Output = ionoLayer;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ionoLayer {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ionoLayer {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ionoLayer {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IONO_SOURCE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IONO_SOURCE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IONO_SOURCE: [ionoSource; 7] = [
  ionoSource::IONOSONDE,
  ionoSource::GPS_TEC,
  ionoSource::BEACON,
  ionoSource::ISR,
  ionoSource::ALTIMETER,
  ionoSource::RADIO_OCCULTATION,
  ionoSource::MODEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ionoSource(pub i8);
#[allow(non_upper_case_globals)]
impl ionoSource {
  pub const IONOSONDE: Self = Self(0);
  pub const GPS_TEC: Self = Self(1);
  pub const BEACON: Self = Self(2);
  pub const ISR: Self = Self(3);
  pub const ALTIMETER: Self = Self(4);
  pub const RADIO_OCCULTATION: Self = Self(5);
  pub const MODEL: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IONOSONDE,
    Self::GPS_TEC,
    Self::BEACON,
    Self::ISR,
    Self::ALTIMETER,
    Self::RADIO_OCCULTATION,
    Self::MODEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::IONOSONDE => Some("IONOSONDE"),
      Self::GPS_TEC => Some("GPS_TEC"),
      Self::BEACON => Some("BEACON"),
      Self::ISR => Some("ISR"),
      Self::ALTIMETER => Some("ALTIMETER"),
      Self::RADIO_OCCULTATION => Some("RADIO_OCCULTATION"),
      Self::MODEL => Some("MODEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ionoSource {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ionoSource {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ionoSource {
    type Output = ionoSource;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ionoSource {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ionoSource {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ionoSource {}
pub enum ionoDataPointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ionospheric Observation Data Point
pub struct ionoDataPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ionoDataPoint<'a> {
  type Inner = ionoDataPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ionoDataPoint<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_LAYER: flatbuffers::VOffsetT = 6;
  pub const VT_CRITICAL_FREQ: flatbuffers::VOffsetT = 8;
  pub const VT_VIRTUAL_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_TRUE_HEIGHT: flatbuffers::VOffsetT = 12;
  pub const VT_PEAK_DENSITY: flatbuffers::VOffsetT = 14;
  pub const VT_TEC: flatbuffers::VOffsetT = 16;
  pub const VT_TEC_UNCERTAINTY: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ionoDataPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ionoDataPointArgs<'args>
  ) -> flatbuffers::WIPOffset<ionoDataPoint<'bldr>> {
    let mut builder = ionoDataPointBuilder::new(_fbb);
    builder.add_TEC_UNCERTAINTY(args.TEC_UNCERTAINTY);
    builder.add_TEC(args.TEC);
    builder.add_PEAK_DENSITY(args.PEAK_DENSITY);
    builder.add_TRUE_HEIGHT(args.TRUE_HEIGHT);
    builder.add_VIRTUAL_HEIGHT(args.VIRTUAL_HEIGHT);
    builder.add_CRITICAL_FREQ(args.CRITICAL_FREQ);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.add_LAYER(args.LAYER);
    builder.finish()
  }

  pub fn unpack(&self) -> ionoDataPointT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let LAYER = self.LAYER();
    let CRITICAL_FREQ = self.CRITICAL_FREQ();
    let VIRTUAL_HEIGHT = self.VIRTUAL_HEIGHT();
    let TRUE_HEIGHT = self.TRUE_HEIGHT();
    let PEAK_DENSITY = self.PEAK_DENSITY();
    let TEC = self.TEC();
    let TEC_UNCERTAINTY = self.TEC_UNCERTAINTY();
    ionoDataPointT {
      EPOCH,
      LAYER,
      CRITICAL_FREQ,
      VIRTUAL_HEIGHT,
      TRUE_HEIGHT,
      PEAK_DENSITY,
      TEC,
      TEC_UNCERTAINTY,
    }
  }

  /// Observation epoch (ISO 8601)
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ionoDataPoint::VT_EPOCH, None)}
  }
  /// Ionospheric layer
  #[inline]
  pub fn LAYER(&self) -> ionoLayer {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ionoLayer>(ionoDataPoint::VT_LAYER, Some(ionoLayer::D)).unwrap()}
  }
  /// Critical frequency in MHz
  #[inline]
  pub fn CRITICAL_FREQ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_CRITICAL_FREQ, Some(0.0)).unwrap()}
  }
  /// Virtual height in km
  #[inline]
  pub fn VIRTUAL_HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_VIRTUAL_HEIGHT, Some(0.0)).unwrap()}
  }
  /// True height in km
  #[inline]
  pub fn TRUE_HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_TRUE_HEIGHT, Some(0.0)).unwrap()}
  }
  /// Peak electron density in electrons/m^3
  #[inline]
  pub fn PEAK_DENSITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_PEAK_DENSITY, Some(0.0)).unwrap()}
  }
  /// Total electron content in TECU
  #[inline]
  pub fn TEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_TEC, Some(0.0)).unwrap()}
  }
  /// TEC uncertainty in TECU
  #[inline]
  pub fn TEC_UNCERTAINTY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ionoDataPoint::VT_TEC_UNCERTAINTY, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ionoDataPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<ionoLayer>("LAYER", Self::VT_LAYER, false)?
     .visit_field::<f64>("CRITICAL_FREQ", Self::VT_CRITICAL_FREQ, false)?
     .visit_field::<f64>("VIRTUAL_HEIGHT", Self::VT_VIRTUAL_HEIGHT, false)?
     .visit_field::<f64>("TRUE_HEIGHT", Self::VT_TRUE_HEIGHT, false)?
     .visit_field::<f64>("PEAK_DENSITY", Self::VT_PEAK_DENSITY, false)?
     .visit_field::<f64>("TEC", Self::VT_TEC, false)?
     .visit_field::<f64>("TEC_UNCERTAINTY", Self::VT_TEC_UNCERTAINTY, false)?
     .finish();
    Ok(())
  }
}
pub struct ionoDataPointArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAYER: ionoLayer,
    pub CRITICAL_FREQ: f64,
    pub VIRTUAL_HEIGHT: f64,
    pub TRUE_HEIGHT: f64,
    pub PEAK_DENSITY: f64,
    pub TEC: f64,
    pub TEC_UNCERTAINTY: f64,
}
impl<'a> Default for ionoDataPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    ionoDataPointArgs {
      EPOCH: None,
      LAYER: ionoLayer::D,
      CRITICAL_FREQ: 0.0,
      VIRTUAL_HEIGHT: 0.0,
      TRUE_HEIGHT: 0.0,
      PEAK_DENSITY: 0.0,
      TEC: 0.0,
      TEC_UNCERTAINTY: 0.0,
    }
  }
}

pub struct ionoDataPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ionoDataPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ionoDataPoint::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_LAYER(&mut self, LAYER: ionoLayer) {
    self.fbb_.push_slot::<ionoLayer>(ionoDataPoint::VT_LAYER, LAYER, ionoLayer::D);
  }
  #[inline]
  pub fn add_CRITICAL_FREQ(&mut self, CRITICAL_FREQ: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_CRITICAL_FREQ, CRITICAL_FREQ, 0.0);
  }
  #[inline]
  pub fn add_VIRTUAL_HEIGHT(&mut self, VIRTUAL_HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_VIRTUAL_HEIGHT, VIRTUAL_HEIGHT, 0.0);
  }
  #[inline]
  pub fn add_TRUE_HEIGHT(&mut self, TRUE_HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_TRUE_HEIGHT, TRUE_HEIGHT, 0.0);
  }
  #[inline]
  pub fn add_PEAK_DENSITY(&mut self, PEAK_DENSITY: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_PEAK_DENSITY, PEAK_DENSITY, 0.0);
  }
  #[inline]
  pub fn add_TEC(&mut self, TEC: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_TEC, TEC, 0.0);
  }
  #[inline]
  pub fn add_TEC_UNCERTAINTY(&mut self, TEC_UNCERTAINTY: f64) {
    self.fbb_.push_slot::<f64>(ionoDataPoint::VT_TEC_UNCERTAINTY, TEC_UNCERTAINTY, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ionoDataPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ionoDataPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ionoDataPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ionoDataPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ionoDataPoint");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("LAYER", &self.LAYER());
      ds.field("CRITICAL_FREQ", &self.CRITICAL_FREQ());
      ds.field("VIRTUAL_HEIGHT", &self.VIRTUAL_HEIGHT());
      ds.field("TRUE_HEIGHT", &self.TRUE_HEIGHT());
      ds.field("PEAK_DENSITY", &self.PEAK_DENSITY());
      ds.field("TEC", &self.TEC());
      ds.field("TEC_UNCERTAINTY", &self.TEC_UNCERTAINTY());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ionoDataPointT {
  pub EPOCH: Option<String>,
  pub LAYER: ionoLayer,
  pub CRITICAL_FREQ: f64,
  pub VIRTUAL_HEIGHT: f64,
  pub TRUE_HEIGHT: f64,
  pub PEAK_DENSITY: f64,
  pub TEC: f64,
  pub TEC_UNCERTAINTY: f64,
}
impl Default for ionoDataPointT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      LAYER: ionoLayer::D,
      CRITICAL_FREQ: 0.0,
      VIRTUAL_HEIGHT: 0.0,
      TRUE_HEIGHT: 0.0,
      PEAK_DENSITY: 0.0,
      TEC: 0.0,
      TEC_UNCERTAINTY: 0.0,
    }
  }
}
impl ionoDataPointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ionoDataPoint<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAYER = self.LAYER;
    let CRITICAL_FREQ = self.CRITICAL_FREQ;
    let VIRTUAL_HEIGHT = self.VIRTUAL_HEIGHT;
    let TRUE_HEIGHT = self.TRUE_HEIGHT;
    let PEAK_DENSITY = self.PEAK_DENSITY;
    let TEC = self.TEC;
    let TEC_UNCERTAINTY = self.TEC_UNCERTAINTY;
    ionoDataPoint::create(_fbb, &ionoDataPointArgs{
      EPOCH,
      LAYER,
      CRITICAL_FREQ,
      VIRTUAL_HEIGHT,
      TRUE_HEIGHT,
      PEAK_DENSITY,
      TEC,
      TEC_UNCERTAINTY,
    })
  }
}
pub enum ionoDensityProfileOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ionospheric Electron Density Profile
pub struct ionoDensityProfile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ionoDensityProfile<'a> {
  type Inner = ionoDensityProfile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ionoDensityProfile<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_ALTITUDES: flatbuffers::VOffsetT = 6;
  pub const VT_DENSITIES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ionoDensityProfile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ionoDensityProfileArgs<'args>
  ) -> flatbuffers::WIPOffset<ionoDensityProfile<'bldr>> {
    let mut builder = ionoDensityProfileBuilder::new(_fbb);
    if let Some(x) = args.DENSITIES { builder.add_DENSITIES(x); }
    if let Some(x) = args.ALTITUDES { builder.add_ALTITUDES(x); }
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ionoDensityProfileT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let ALTITUDES = self.ALTITUDES().map(|x| {
      x.into_iter().collect()
    });
    let DENSITIES = self.DENSITIES().map(|x| {
      x.into_iter().collect()
    });
    ionoDensityProfileT {
      EPOCH,
      ALTITUDES,
      DENSITIES,
    }
  }

  /// Observation epoch (ISO 8601)
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ionoDensityProfile::VT_EPOCH, None)}
  }
  /// Altitudes in km
  #[inline]
  pub fn ALTITUDES(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ionoDensityProfile::VT_ALTITUDES, None)}
  }
  /// Electron densities at each altitude in electrons/m^3
  #[inline]
  pub fn DENSITIES(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ionoDensityProfile::VT_DENSITIES, None)}
  }
}

impl flatbuffers::Verifiable for ionoDensityProfile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("ALTITUDES", Self::VT_ALTITUDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("DENSITIES", Self::VT_DENSITIES, false)?
     .finish();
    Ok(())
  }
}
pub struct ionoDensityProfileArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALTITUDES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub DENSITIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for ionoDensityProfileArgs<'a> {
  #[inline]
  fn default() -> Self {
    ionoDensityProfileArgs {
      EPOCH: None,
      ALTITUDES: None,
      DENSITIES: None,
    }
  }
}

pub struct ionoDensityProfileBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ionoDensityProfileBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ionoDensityProfile::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_ALTITUDES(&mut self, ALTITUDES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ionoDensityProfile::VT_ALTITUDES, ALTITUDES);
  }
  #[inline]
  pub fn add_DENSITIES(&mut self, DENSITIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ionoDensityProfile::VT_DENSITIES, DENSITIES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ionoDensityProfileBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ionoDensityProfileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ionoDensityProfile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ionoDensityProfile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ionoDensityProfile");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("ALTITUDES", &self.ALTITUDES());
      ds.field("DENSITIES", &self.DENSITIES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ionoDensityProfileT {
  pub EPOCH: Option<String>,
  pub ALTITUDES: Option<Vec<f64>>,
  pub DENSITIES: Option<Vec<f64>>,
}
impl Default for ionoDensityProfileT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      ALTITUDES: None,
      DENSITIES: None,
    }
  }
}
impl ionoDensityProfileT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ionoDensityProfile<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALTITUDES = self.ALTITUDES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let DENSITIES = self.DENSITIES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ionoDensityProfile::create(_fbb, &ionoDensityProfileArgs{
      EPOCH,
      ALTITUDES,
      DENSITIES,
    })
  }
}
pub enum IONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ionospheric Observation
pub struct ION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ION<'a> {
  type Inner = ION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ION<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
  pub const VT_STATION_ID: flatbuffers::VOffsetT = 8;
  pub const VT_STATION_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 12;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 16;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 18;
  pub const VT_STOP_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_FOF2: flatbuffers::VOffsetT = 22;
  pub const VT_FOF1: flatbuffers::VOffsetT = 24;
  pub const VT_FOE: flatbuffers::VOffsetT = 26;
  pub const VT_FOES: flatbuffers::VOffsetT = 28;
  pub const VT_HMF2: flatbuffers::VOffsetT = 30;
  pub const VT_HMF1: flatbuffers::VOffsetT = 32;
  pub const VT_HME: flatbuffers::VOffsetT = 34;
  pub const VT_NMF2: flatbuffers::VOffsetT = 36;
  pub const VT_VTEC: flatbuffers::VOffsetT = 38;
  pub const VT_STEC: flatbuffers::VOffsetT = 40;
  pub const VT_S4: flatbuffers::VOffsetT = 42;
  pub const VT_DATA_POINTS: flatbuffers::VOffsetT = 44;
  pub const VT_DENSITY_PROFILES: flatbuffers::VOffsetT = 46;
  pub const VT_QUALITY: flatbuffers::VOffsetT = 48;
  pub const VT_NOTES: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IONArgs<'args>
  ) -> flatbuffers::WIPOffset<ION<'bldr>> {
    let mut builder = IONBuilder::new(_fbb);
    builder.add_S4(args.S4);
    builder.add_STEC(args.STEC);
    builder.add_VTEC(args.VTEC);
    builder.add_NMF2(args.NMF2);
    builder.add_HME(args.HME);
    builder.add_HMF1(args.HMF1);
    builder.add_HMF2(args.HMF2);
    builder.add_FOES(args.FOES);
    builder.add_FOE(args.FOE);
    builder.add_FOF1(args.FOF1);
    builder.add_FOF2(args.FOF2);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.DENSITY_PROFILES { builder.add_DENSITY_PROFILES(x); }
    if let Some(x) = args.DATA_POINTS { builder.add_DATA_POINTS(x); }
    if let Some(x) = args.STOP_TIME { builder.add_STOP_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.STATION_NAME { builder.add_STATION_NAME(x); }
    if let Some(x) = args.STATION_ID { builder.add_STATION_ID(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_QUALITY(args.QUALITY);
    builder.add_SOURCE(args.SOURCE);
    builder.finish()
  }

  pub fn unpack(&self) -> IONT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE();
    let STATION_ID = self.STATION_ID().map(|x| {
      x.to_string()
    });
    let STATION_NAME = self.STATION_NAME().map(|x| {
      x.to_string()
    });
    let LATITUDE = self.LATITUDE();
    let LONGITUDE = self.LONGITUDE();
    let ALTITUDE = self.ALTITUDE();
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let STOP_TIME = self.STOP_TIME().map(|x| {
      x.to_string()
    });
    let FOF2 = self.FOF2();
    let FOF1 = self.FOF1();
    let FOE = self.FOE();
    let FOES = self.FOES();
    let HMF2 = self.HMF2();
    let HMF1 = self.HMF1();
    let HME = self.HME();
    let NMF2 = self.NMF2();
    let VTEC = self.VTEC();
    let STEC = self.STEC();
    let S4 = self.S4();
    let DATA_POINTS = self.DATA_POINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DENSITY_PROFILES = self.DENSITY_PROFILES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let QUALITY = self.QUALITY();
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    IONT {
      ID,
      SOURCE,
      STATION_ID,
      STATION_NAME,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      START_TIME,
      STOP_TIME,
      FOF2,
      FOF1,
      FOE,
      FOES,
      HMF2,
      HMF1,
      HME,
      NMF2,
      VTEC,
      STEC,
      S4,
      DATA_POINTS,
      DENSITY_PROFILES,
      QUALITY,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_ID, None)}
  }
  /// Data source type
  #[inline]
  pub fn SOURCE(&self) -> ionoSource {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ionoSource>(ION::VT_SOURCE, Some(ionoSource::IONOSONDE)).unwrap()}
  }
  /// Station or sensor identifier
  #[inline]
  pub fn STATION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_STATION_ID, None)}
  }
  /// Station name
  #[inline]
  pub fn STATION_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_STATION_NAME, None)}
  }
  /// Station geodetic latitude in degrees
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Station geodetic longitude in degrees
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Station altitude in meters
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Observation start time (ISO 8601)
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_START_TIME, None)}
  }
  /// Observation stop time (ISO 8601)
  #[inline]
  pub fn STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_STOP_TIME, None)}
  }
  /// foF2 critical frequency in MHz
  #[inline]
  pub fn FOF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_FOF2, Some(0.0)).unwrap()}
  }
  /// foF1 critical frequency in MHz
  #[inline]
  pub fn FOF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_FOF1, Some(0.0)).unwrap()}
  }
  /// foE critical frequency in MHz
  #[inline]
  pub fn FOE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_FOE, Some(0.0)).unwrap()}
  }
  /// foEs sporadic E critical frequency in MHz
  #[inline]
  pub fn FOES(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_FOES, Some(0.0)).unwrap()}
  }
  /// hmF2 peak height of F2 layer in km
  #[inline]
  pub fn HMF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_HMF2, Some(0.0)).unwrap()}
  }
  /// hmF1 peak height of F1 layer in km
  #[inline]
  pub fn HMF1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_HMF1, Some(0.0)).unwrap()}
  }
  /// hmE peak height of E layer in km
  #[inline]
  pub fn HME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_HME, Some(0.0)).unwrap()}
  }
  /// NmF2 peak density of F2 layer in electrons/m^3
  #[inline]
  pub fn NMF2(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_NMF2, Some(0.0)).unwrap()}
  }
  /// Vertical TEC in TECU
  #[inline]
  pub fn VTEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_VTEC, Some(0.0)).unwrap()}
  }
  /// Slant TEC in TECU
  #[inline]
  pub fn STEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_STEC, Some(0.0)).unwrap()}
  }
  /// Scintillation index S4
  #[inline]
  pub fn S4(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ION::VT_S4, Some(0.0)).unwrap()}
  }
  /// Observation data points
  #[inline]
  pub fn DATA_POINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDataPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDataPoint>>>>(ION::VT_DATA_POINTS, None)}
  }
  /// Electron density profiles
  #[inline]
  pub fn DENSITY_PROFILES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDensityProfile<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDensityProfile>>>>(ION::VT_DENSITY_PROFILES, None)}
  }
  /// Data quality indicator (0-9, 9=best)
  #[inline]
  pub fn QUALITY(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ION::VT_QUALITY, Some(0)).unwrap()}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ION::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for ION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<ionoSource>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STATION_ID", Self::VT_STATION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STATION_NAME", Self::VT_STATION_NAME, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STOP_TIME", Self::VT_STOP_TIME, false)?
     .visit_field::<f64>("FOF2", Self::VT_FOF2, false)?
     .visit_field::<f64>("FOF1", Self::VT_FOF1, false)?
     .visit_field::<f64>("FOE", Self::VT_FOE, false)?
     .visit_field::<f64>("FOES", Self::VT_FOES, false)?
     .visit_field::<f64>("HMF2", Self::VT_HMF2, false)?
     .visit_field::<f64>("HMF1", Self::VT_HMF1, false)?
     .visit_field::<f64>("HME", Self::VT_HME, false)?
     .visit_field::<f64>("NMF2", Self::VT_NMF2, false)?
     .visit_field::<f64>("VTEC", Self::VT_VTEC, false)?
     .visit_field::<f64>("STEC", Self::VT_STEC, false)?
     .visit_field::<f64>("S4", Self::VT_S4, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ionoDataPoint>>>>("DATA_POINTS", Self::VT_DATA_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ionoDensityProfile>>>>("DENSITY_PROFILES", Self::VT_DENSITY_PROFILES, false)?
     .visit_field::<u8>("QUALITY", Self::VT_QUALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct IONArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: ionoSource,
    pub STATION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STATION_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LATITUDE: f64,
    pub LONGITUDE: f64,
    pub ALTITUDE: f64,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FOF2: f64,
    pub FOF1: f64,
    pub FOE: f64,
    pub FOES: f64,
    pub HMF2: f64,
    pub HMF1: f64,
    pub HME: f64,
    pub NMF2: f64,
    pub VTEC: f64,
    pub STEC: f64,
    pub S4: f64,
    pub DATA_POINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDataPoint<'a>>>>>,
    pub DENSITY_PROFILES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ionoDensityProfile<'a>>>>>,
    pub QUALITY: u8,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for IONArgs<'a> {
  #[inline]
  fn default() -> Self {
    IONArgs {
      ID: None,
      SOURCE: ionoSource::IONOSONDE,
      STATION_ID: None,
      STATION_NAME: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      START_TIME: None,
      STOP_TIME: None,
      FOF2: 0.0,
      FOF1: 0.0,
      FOE: 0.0,
      FOES: 0.0,
      HMF2: 0.0,
      HMF1: 0.0,
      HME: 0.0,
      NMF2: 0.0,
      VTEC: 0.0,
      STEC: 0.0,
      S4: 0.0,
      DATA_POINTS: None,
      DENSITY_PROFILES: None,
      QUALITY: 0,
      NOTES: None,
    }
  }
}

pub struct IONBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IONBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_ID, ID);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: ionoSource) {
    self.fbb_.push_slot::<ionoSource>(ION::VT_SOURCE, SOURCE, ionoSource::IONOSONDE);
  }
  #[inline]
  pub fn add_STATION_ID(&mut self, STATION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_STATION_ID, STATION_ID);
  }
  #[inline]
  pub fn add_STATION_NAME(&mut self, STATION_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_STATION_NAME, STATION_NAME);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_STOP_TIME(&mut self, STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_STOP_TIME, STOP_TIME);
  }
  #[inline]
  pub fn add_FOF2(&mut self, FOF2: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_FOF2, FOF2, 0.0);
  }
  #[inline]
  pub fn add_FOF1(&mut self, FOF1: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_FOF1, FOF1, 0.0);
  }
  #[inline]
  pub fn add_FOE(&mut self, FOE: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_FOE, FOE, 0.0);
  }
  #[inline]
  pub fn add_FOES(&mut self, FOES: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_FOES, FOES, 0.0);
  }
  #[inline]
  pub fn add_HMF2(&mut self, HMF2: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_HMF2, HMF2, 0.0);
  }
  #[inline]
  pub fn add_HMF1(&mut self, HMF1: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_HMF1, HMF1, 0.0);
  }
  #[inline]
  pub fn add_HME(&mut self, HME: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_HME, HME, 0.0);
  }
  #[inline]
  pub fn add_NMF2(&mut self, NMF2: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_NMF2, NMF2, 0.0);
  }
  #[inline]
  pub fn add_VTEC(&mut self, VTEC: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_VTEC, VTEC, 0.0);
  }
  #[inline]
  pub fn add_STEC(&mut self, STEC: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_STEC, STEC, 0.0);
  }
  #[inline]
  pub fn add_S4(&mut self, S4: f64) {
    self.fbb_.push_slot::<f64>(ION::VT_S4, S4, 0.0);
  }
  #[inline]
  pub fn add_DATA_POINTS(&mut self, DATA_POINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ionoDataPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_DATA_POINTS, DATA_POINTS);
  }
  #[inline]
  pub fn add_DENSITY_PROFILES(&mut self, DENSITY_PROFILES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ionoDensityProfile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_DENSITY_PROFILES, DENSITY_PROFILES);
  }
  #[inline]
  pub fn add_QUALITY(&mut self, QUALITY: u8) {
    self.fbb_.push_slot::<u8>(ION::VT_QUALITY, QUALITY, 0);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ION::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IONBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ION");
      ds.field("ID", &self.ID());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("STATION_ID", &self.STATION_ID());
      ds.field("STATION_NAME", &self.STATION_NAME());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("STOP_TIME", &self.STOP_TIME());
      ds.field("FOF2", &self.FOF2());
      ds.field("FOF1", &self.FOF1());
      ds.field("FOE", &self.FOE());
      ds.field("FOES", &self.FOES());
      ds.field("HMF2", &self.HMF2());
      ds.field("HMF1", &self.HMF1());
      ds.field("HME", &self.HME());
      ds.field("NMF2", &self.NMF2());
      ds.field("VTEC", &self.VTEC());
      ds.field("STEC", &self.STEC());
      ds.field("S4", &self.S4());
      ds.field("DATA_POINTS", &self.DATA_POINTS());
      ds.field("DENSITY_PROFILES", &self.DENSITY_PROFILES());
      ds.field("QUALITY", &self.QUALITY());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IONT {
  pub ID: Option<String>,
  pub SOURCE: ionoSource,
  pub STATION_ID: Option<String>,
  pub STATION_NAME: Option<String>,
  pub LATITUDE: f64,
  pub LONGITUDE: f64,
  pub ALTITUDE: f64,
  pub START_TIME: Option<String>,
  pub STOP_TIME: Option<String>,
  pub FOF2: f64,
  pub FOF1: f64,
  pub FOE: f64,
  pub FOES: f64,
  pub HMF2: f64,
  pub HMF1: f64,
  pub HME: f64,
  pub NMF2: f64,
  pub VTEC: f64,
  pub STEC: f64,
  pub S4: f64,
  pub DATA_POINTS: Option<Vec<ionoDataPointT>>,
  pub DENSITY_PROFILES: Option<Vec<ionoDensityProfileT>>,
  pub QUALITY: u8,
  pub NOTES: Option<String>,
}
impl Default for IONT {
  fn default() -> Self {
    Self {
      ID: None,
      SOURCE: ionoSource::IONOSONDE,
      STATION_ID: None,
      STATION_NAME: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      START_TIME: None,
      STOP_TIME: None,
      FOF2: 0.0,
      FOF1: 0.0,
      FOE: 0.0,
      FOES: 0.0,
      HMF2: 0.0,
      HMF1: 0.0,
      HME: 0.0,
      NMF2: 0.0,
      VTEC: 0.0,
      STEC: 0.0,
      S4: 0.0,
      DATA_POINTS: None,
      DENSITY_PROFILES: None,
      QUALITY: 0,
      NOTES: None,
    }
  }
}
impl IONT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ION<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE;
    let STATION_ID = self.STATION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STATION_NAME = self.STATION_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LATITUDE = self.LATITUDE;
    let LONGITUDE = self.LONGITUDE;
    let ALTITUDE = self.ALTITUDE;
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STOP_TIME = self.STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FOF2 = self.FOF2;
    let FOF1 = self.FOF1;
    let FOE = self.FOE;
    let FOES = self.FOES;
    let HMF2 = self.HMF2;
    let HMF1 = self.HMF1;
    let HME = self.HME;
    let NMF2 = self.NMF2;
    let VTEC = self.VTEC;
    let STEC = self.STEC;
    let S4 = self.S4;
    let DATA_POINTS = self.DATA_POINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DENSITY_PROFILES = self.DENSITY_PROFILES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let QUALITY = self.QUALITY;
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ION::create(_fbb, &IONArgs{
      ID,
      SOURCE,
      STATION_ID,
      STATION_NAME,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      START_TIME,
      STOP_TIME,
      FOF2,
      FOF1,
      FOE,
      FOES,
      HMF2,
      HMF1,
      HME,
      NMF2,
      VTEC,
      STEC,
      S4,
      DATA_POINTS,
      DENSITY_PROFILES,
      QUALITY,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ION`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ION_unchecked`.
pub fn root_as_ION(buf: &[u8]) -> Result<ION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ION>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ION_unchecked`.
pub fn size_prefixed_root_as_ION(buf: &[u8]) -> Result<ION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ION>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ION_unchecked`.
pub fn root_as_ION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ION<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ION` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ION_unchecked`.
pub fn size_prefixed_root_as_ION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ION<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ION`.
pub unsafe fn root_as_ION_unchecked(buf: &[u8]) -> ION {
  flatbuffers::root_unchecked::<ION>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ION`.
pub unsafe fn size_prefixed_root_as_ION_unchecked(buf: &[u8]) -> ION {
  flatbuffers::size_prefixed_root_unchecked::<ION>(buf)
}
pub const ION_IDENTIFIER: &str = "$ION";

#[inline]
pub fn ION_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ION_IDENTIFIER, false)
}

#[inline]
pub fn ION_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ION_IDENTIFIER, true)
}

#[inline]
pub fn finish_ION_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ION<'a>>) {
  fbb.finish(root, Some(ION_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ION_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ION<'a>>) {
  fbb.finish_size_prefixed(root, Some(ION_IDENTIFIER));
}
