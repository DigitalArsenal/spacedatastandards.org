// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_THRUSTER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_THRUSTER_TYPE: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_THRUSTER_TYPE: [thrusterType; 13] = [
  thrusterType::CHEMICAL_MONO,
  thrusterType::CHEMICAL_BI,
  thrusterType::COLD_GAS,
  thrusterType::ELECTRIC_HALL,
  thrusterType::ELECTRIC_ION,
  thrusterType::ELECTRIC_PPT,
  thrusterType::ELECTRIC_ARCJET,
  thrusterType::ELECTRIC_RESISTOJET,
  thrusterType::ELECTRIC_COLLOID,
  thrusterType::SOLID,
  thrusterType::HYBRID,
  thrusterType::NUCLEAR_THERMAL,
  thrusterType::SOLAR_THERMAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct thrusterType(pub i8);
#[allow(non_upper_case_globals)]
impl thrusterType {
  pub const CHEMICAL_MONO: Self = Self(0);
  pub const CHEMICAL_BI: Self = Self(1);
  pub const COLD_GAS: Self = Self(2);
  pub const ELECTRIC_HALL: Self = Self(3);
  pub const ELECTRIC_ION: Self = Self(4);
  pub const ELECTRIC_PPT: Self = Self(5);
  pub const ELECTRIC_ARCJET: Self = Self(6);
  pub const ELECTRIC_RESISTOJET: Self = Self(7);
  pub const ELECTRIC_COLLOID: Self = Self(8);
  pub const SOLID: Self = Self(9);
  pub const HYBRID: Self = Self(10);
  pub const NUCLEAR_THERMAL: Self = Self(11);
  pub const SOLAR_THERMAL: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CHEMICAL_MONO,
    Self::CHEMICAL_BI,
    Self::COLD_GAS,
    Self::ELECTRIC_HALL,
    Self::ELECTRIC_ION,
    Self::ELECTRIC_PPT,
    Self::ELECTRIC_ARCJET,
    Self::ELECTRIC_RESISTOJET,
    Self::ELECTRIC_COLLOID,
    Self::SOLID,
    Self::HYBRID,
    Self::NUCLEAR_THERMAL,
    Self::SOLAR_THERMAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CHEMICAL_MONO => Some("CHEMICAL_MONO"),
      Self::CHEMICAL_BI => Some("CHEMICAL_BI"),
      Self::COLD_GAS => Some("COLD_GAS"),
      Self::ELECTRIC_HALL => Some("ELECTRIC_HALL"),
      Self::ELECTRIC_ION => Some("ELECTRIC_ION"),
      Self::ELECTRIC_PPT => Some("ELECTRIC_PPT"),
      Self::ELECTRIC_ARCJET => Some("ELECTRIC_ARCJET"),
      Self::ELECTRIC_RESISTOJET => Some("ELECTRIC_RESISTOJET"),
      Self::ELECTRIC_COLLOID => Some("ELECTRIC_COLLOID"),
      Self::SOLID => Some("SOLID"),
      Self::HYBRID => Some("HYBRID"),
      Self::NUCLEAR_THERMAL => Some("NUCLEAR_THERMAL"),
      Self::SOLAR_THERMAL => Some("SOLAR_THERMAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for thrusterType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for thrusterType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for thrusterType {
    type Output = thrusterType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for thrusterType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for thrusterType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for thrusterType {}
pub enum OOTOffset {}
#[derive(Copy, Clone, PartialEq)]

/// On-Orbit Thruster
pub struct OOT<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OOT<'a> {
  type Inner = OOT<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OOT<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ID_ON_ORBIT: flatbuffers::VOffsetT = 6;
  pub const VT_ID_THRUSTER: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_QUANTITY: flatbuffers::VOffsetT = 14;
  pub const VT_THRUST: flatbuffers::VOffsetT = 16;
  pub const VT_ISP: flatbuffers::VOffsetT = 18;
  pub const VT_PROPELLANT: flatbuffers::VOffsetT = 20;
  pub const VT_PROPELLANT_MASS: flatbuffers::VOffsetT = 22;
  pub const VT_PROPELLANT_REMAINING: flatbuffers::VOffsetT = 24;
  pub const VT_DELTA_V_TOTAL: flatbuffers::VOffsetT = 26;
  pub const VT_DELTA_V_REMAINING: flatbuffers::VOffsetT = 28;
  pub const VT_TOTAL_IMPULSE: flatbuffers::VOffsetT = 30;
  pub const VT_MASS: flatbuffers::VOffsetT = 32;
  pub const VT_PURPOSE: flatbuffers::VOffsetT = 34;
  pub const VT_NOTES: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OOT { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OOTArgs<'args>
  ) -> flatbuffers::WIPOffset<OOT<'bldr>> {
    let mut builder = OOTBuilder::new(_fbb);
    builder.add_MASS(args.MASS);
    builder.add_TOTAL_IMPULSE(args.TOTAL_IMPULSE);
    builder.add_DELTA_V_REMAINING(args.DELTA_V_REMAINING);
    builder.add_DELTA_V_TOTAL(args.DELTA_V_TOTAL);
    builder.add_PROPELLANT_REMAINING(args.PROPELLANT_REMAINING);
    builder.add_PROPELLANT_MASS(args.PROPELLANT_MASS);
    builder.add_ISP(args.ISP);
    builder.add_THRUST(args.THRUST);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.PURPOSE { builder.add_PURPOSE(x); }
    if let Some(x) = args.PROPELLANT { builder.add_PROPELLANT(x); }
    builder.add_QUANTITY(args.QUANTITY);
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID_THRUSTER { builder.add_ID_THRUSTER(x); }
    if let Some(x) = args.ID_ON_ORBIT { builder.add_ID_ON_ORBIT(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> OOTT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT().map(|x| {
      x.to_string()
    });
    let ID_THRUSTER = self.ID_THRUSTER().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE();
    let QUANTITY = self.QUANTITY();
    let THRUST = self.THRUST();
    let ISP = self.ISP();
    let PROPELLANT = self.PROPELLANT().map(|x| {
      x.to_string()
    });
    let PROPELLANT_MASS = self.PROPELLANT_MASS();
    let PROPELLANT_REMAINING = self.PROPELLANT_REMAINING();
    let DELTA_V_TOTAL = self.DELTA_V_TOTAL();
    let DELTA_V_REMAINING = self.DELTA_V_REMAINING();
    let TOTAL_IMPULSE = self.TOTAL_IMPULSE();
    let MASS = self.MASS();
    let PURPOSE = self.PURPOSE().map(|x| {
      x.to_string()
    });
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    OOTT {
      ID,
      ID_ON_ORBIT,
      ID_THRUSTER,
      NAME,
      TYPE,
      QUANTITY,
      THRUST,
      ISP,
      PROPELLANT,
      PROPELLANT_MASS,
      PROPELLANT_REMAINING,
      DELTA_V_TOTAL,
      DELTA_V_REMAINING,
      TOTAL_IMPULSE,
      MASS,
      PURPOSE,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_ID, None)}
  }
  /// Reference to parent on-orbit object
  #[inline]
  pub fn ID_ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_ID_ON_ORBIT, None)}
  }
  /// Reference to thruster specification
  #[inline]
  pub fn ID_THRUSTER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_ID_THRUSTER, None)}
  }
  /// Thruster name or designation
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_NAME, None)}
  }
  /// Thruster type
  #[inline]
  pub fn TYPE(&self) -> thrusterType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<thrusterType>(OOT::VT_TYPE, Some(thrusterType::CHEMICAL_MONO)).unwrap()}
  }
  /// Number of thrusters of this type
  #[inline]
  pub fn QUANTITY(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OOT::VT_QUANTITY, Some(0)).unwrap()}
  }
  /// Thrust output in Newtons
  #[inline]
  pub fn THRUST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_THRUST, Some(0.0)).unwrap()}
  }
  /// Specific impulse in seconds
  #[inline]
  pub fn ISP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_ISP, Some(0.0)).unwrap()}
  }
  /// Propellant type (e.g., HYDRAZINE, XENON, KRYPTON, MMH_NTO, N2, GN2)
  #[inline]
  pub fn PROPELLANT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_PROPELLANT, None)}
  }
  /// Total propellant mass in kg
  #[inline]
  pub fn PROPELLANT_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_PROPELLANT_MASS, Some(0.0)).unwrap()}
  }
  /// Remaining propellant mass in kg
  #[inline]
  pub fn PROPELLANT_REMAINING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_PROPELLANT_REMAINING, Some(0.0)).unwrap()}
  }
  /// Total delta-V capability in m/s
  #[inline]
  pub fn DELTA_V_TOTAL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_DELTA_V_TOTAL, Some(0.0)).unwrap()}
  }
  /// Remaining delta-V in m/s
  #[inline]
  pub fn DELTA_V_REMAINING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_DELTA_V_REMAINING, Some(0.0)).unwrap()}
  }
  /// Total impulse in Newton-seconds
  #[inline]
  pub fn TOTAL_IMPULSE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_TOTAL_IMPULSE, Some(0.0)).unwrap()}
  }
  /// Thruster dry mass in kg
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOT::VT_MASS, Some(0.0)).unwrap()}
  }
  /// Purpose (e.g., ORBIT_RAISING, STATION_KEEPING, ATTITUDE_CONTROL, DEORBIT)
  #[inline]
  pub fn PURPOSE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_PURPOSE, None)}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOT::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for OOT<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_ON_ORBIT", Self::VT_ID_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_THRUSTER", Self::VT_ID_THRUSTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<thrusterType>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<u32>("QUANTITY", Self::VT_QUANTITY, false)?
     .visit_field::<f64>("THRUST", Self::VT_THRUST, false)?
     .visit_field::<f64>("ISP", Self::VT_ISP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROPELLANT", Self::VT_PROPELLANT, false)?
     .visit_field::<f64>("PROPELLANT_MASS", Self::VT_PROPELLANT_MASS, false)?
     .visit_field::<f64>("PROPELLANT_REMAINING", Self::VT_PROPELLANT_REMAINING, false)?
     .visit_field::<f64>("DELTA_V_TOTAL", Self::VT_DELTA_V_TOTAL, false)?
     .visit_field::<f64>("DELTA_V_REMAINING", Self::VT_DELTA_V_REMAINING, false)?
     .visit_field::<f64>("TOTAL_IMPULSE", Self::VT_TOTAL_IMPULSE, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PURPOSE", Self::VT_PURPOSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct OOTArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_THRUSTER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: thrusterType,
    pub QUANTITY: u32,
    pub THRUST: f64,
    pub ISP: f64,
    pub PROPELLANT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROPELLANT_MASS: f64,
    pub PROPELLANT_REMAINING: f64,
    pub DELTA_V_TOTAL: f64,
    pub DELTA_V_REMAINING: f64,
    pub TOTAL_IMPULSE: f64,
    pub MASS: f64,
    pub PURPOSE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OOTArgs<'a> {
  #[inline]
  fn default() -> Self {
    OOTArgs {
      ID: None,
      ID_ON_ORBIT: None,
      ID_THRUSTER: None,
      NAME: None,
      TYPE: thrusterType::CHEMICAL_MONO,
      QUANTITY: 0,
      THRUST: 0.0,
      ISP: 0.0,
      PROPELLANT: None,
      PROPELLANT_MASS: 0.0,
      PROPELLANT_REMAINING: 0.0,
      DELTA_V_TOTAL: 0.0,
      DELTA_V_REMAINING: 0.0,
      TOTAL_IMPULSE: 0.0,
      MASS: 0.0,
      PURPOSE: None,
      NOTES: None,
    }
  }
}

pub struct OOTBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OOTBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_ID, ID);
  }
  #[inline]
  pub fn add_ID_ON_ORBIT(&mut self, ID_ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  #[inline]
  pub fn add_ID_THRUSTER(&mut self, ID_THRUSTER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_ID_THRUSTER, ID_THRUSTER);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: thrusterType) {
    self.fbb_.push_slot::<thrusterType>(OOT::VT_TYPE, TYPE, thrusterType::CHEMICAL_MONO);
  }
  #[inline]
  pub fn add_QUANTITY(&mut self, QUANTITY: u32) {
    self.fbb_.push_slot::<u32>(OOT::VT_QUANTITY, QUANTITY, 0);
  }
  #[inline]
  pub fn add_THRUST(&mut self, THRUST: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_THRUST, THRUST, 0.0);
  }
  #[inline]
  pub fn add_ISP(&mut self, ISP: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_ISP, ISP, 0.0);
  }
  #[inline]
  pub fn add_PROPELLANT(&mut self, PROPELLANT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_PROPELLANT, PROPELLANT);
  }
  #[inline]
  pub fn add_PROPELLANT_MASS(&mut self, PROPELLANT_MASS: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_PROPELLANT_MASS, PROPELLANT_MASS, 0.0);
  }
  #[inline]
  pub fn add_PROPELLANT_REMAINING(&mut self, PROPELLANT_REMAINING: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_PROPELLANT_REMAINING, PROPELLANT_REMAINING, 0.0);
  }
  #[inline]
  pub fn add_DELTA_V_TOTAL(&mut self, DELTA_V_TOTAL: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_DELTA_V_TOTAL, DELTA_V_TOTAL, 0.0);
  }
  #[inline]
  pub fn add_DELTA_V_REMAINING(&mut self, DELTA_V_REMAINING: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_DELTA_V_REMAINING, DELTA_V_REMAINING, 0.0);
  }
  #[inline]
  pub fn add_TOTAL_IMPULSE(&mut self, TOTAL_IMPULSE: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_TOTAL_IMPULSE, TOTAL_IMPULSE, 0.0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(OOT::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_PURPOSE(&mut self, PURPOSE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_PURPOSE, PURPOSE);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOT::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OOTBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OOTBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OOT<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OOT<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OOT");
      ds.field("ID", &self.ID());
      ds.field("ID_ON_ORBIT", &self.ID_ON_ORBIT());
      ds.field("ID_THRUSTER", &self.ID_THRUSTER());
      ds.field("NAME", &self.NAME());
      ds.field("TYPE", &self.TYPE());
      ds.field("QUANTITY", &self.QUANTITY());
      ds.field("THRUST", &self.THRUST());
      ds.field("ISP", &self.ISP());
      ds.field("PROPELLANT", &self.PROPELLANT());
      ds.field("PROPELLANT_MASS", &self.PROPELLANT_MASS());
      ds.field("PROPELLANT_REMAINING", &self.PROPELLANT_REMAINING());
      ds.field("DELTA_V_TOTAL", &self.DELTA_V_TOTAL());
      ds.field("DELTA_V_REMAINING", &self.DELTA_V_REMAINING());
      ds.field("TOTAL_IMPULSE", &self.TOTAL_IMPULSE());
      ds.field("MASS", &self.MASS());
      ds.field("PURPOSE", &self.PURPOSE());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OOTT {
  pub ID: Option<String>,
  pub ID_ON_ORBIT: Option<String>,
  pub ID_THRUSTER: Option<String>,
  pub NAME: Option<String>,
  pub TYPE: thrusterType,
  pub QUANTITY: u32,
  pub THRUST: f64,
  pub ISP: f64,
  pub PROPELLANT: Option<String>,
  pub PROPELLANT_MASS: f64,
  pub PROPELLANT_REMAINING: f64,
  pub DELTA_V_TOTAL: f64,
  pub DELTA_V_REMAINING: f64,
  pub TOTAL_IMPULSE: f64,
  pub MASS: f64,
  pub PURPOSE: Option<String>,
  pub NOTES: Option<String>,
}
impl Default for OOTT {
  fn default() -> Self {
    Self {
      ID: None,
      ID_ON_ORBIT: None,
      ID_THRUSTER: None,
      NAME: None,
      TYPE: thrusterType::CHEMICAL_MONO,
      QUANTITY: 0,
      THRUST: 0.0,
      ISP: 0.0,
      PROPELLANT: None,
      PROPELLANT_MASS: 0.0,
      PROPELLANT_REMAINING: 0.0,
      DELTA_V_TOTAL: 0.0,
      DELTA_V_REMAINING: 0.0,
      TOTAL_IMPULSE: 0.0,
      MASS: 0.0,
      PURPOSE: None,
      NOTES: None,
    }
  }
}
impl OOTT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OOT<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_THRUSTER = self.ID_THRUSTER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE;
    let QUANTITY = self.QUANTITY;
    let THRUST = self.THRUST;
    let ISP = self.ISP;
    let PROPELLANT = self.PROPELLANT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROPELLANT_MASS = self.PROPELLANT_MASS;
    let PROPELLANT_REMAINING = self.PROPELLANT_REMAINING;
    let DELTA_V_TOTAL = self.DELTA_V_TOTAL;
    let DELTA_V_REMAINING = self.DELTA_V_REMAINING;
    let TOTAL_IMPULSE = self.TOTAL_IMPULSE;
    let MASS = self.MASS;
    let PURPOSE = self.PURPOSE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OOT::create(_fbb, &OOTArgs{
      ID,
      ID_ON_ORBIT,
      ID_THRUSTER,
      NAME,
      TYPE,
      QUANTITY,
      THRUST,
      ISP,
      PROPELLANT,
      PROPELLANT_MASS,
      PROPELLANT_REMAINING,
      DELTA_V_TOTAL,
      DELTA_V_REMAINING,
      TOTAL_IMPULSE,
      MASS,
      PURPOSE,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OOT`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOT_unchecked`.
pub fn root_as_OOT(buf: &[u8]) -> Result<OOT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OOT>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OOT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OOT_unchecked`.
pub fn size_prefixed_root_as_OOT(buf: &[u8]) -> Result<OOT, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OOT>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OOT` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOT_unchecked`.
pub fn root_as_OOT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OOT<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OOT` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOT_unchecked`.
pub fn size_prefixed_root_as_OOT_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOT<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OOT<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OOT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OOT`.
pub unsafe fn root_as_OOT_unchecked(buf: &[u8]) -> OOT {
  flatbuffers::root_unchecked::<OOT>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OOT and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OOT`.
pub unsafe fn size_prefixed_root_as_OOT_unchecked(buf: &[u8]) -> OOT {
  flatbuffers::size_prefixed_root_unchecked::<OOT>(buf)
}
pub const OOT_IDENTIFIER: &str = "$OOT";

#[inline]
pub fn OOT_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOT_IDENTIFIER, false)
}

#[inline]
pub fn OOT_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOT_IDENTIFIER, true)
}

#[inline]
pub fn finish_OOT_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OOT<'a>>) {
  fbb.finish(root, Some(OOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OOT_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OOT<'a>>) {
  fbb.finish_size_prefixed(root, Some(OOT_IDENTIFIER));
}
