// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLALTITUDE_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLALTITUDE_MODE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLALTITUDE_MODE: [KMLAltitudeMode; 5] = [
  KMLAltitudeMode::CLAMP_TO_GROUND,
  KMLAltitudeMode::RELATIVE_TO_GROUND,
  KMLAltitudeMode::ABSOLUTE,
  KMLAltitudeMode::CLAMP_TO_SEA_FLOOR,
  KMLAltitudeMode::RELATIVE_TO_SEA_FLOOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLAltitudeMode(pub i8);
#[allow(non_upper_case_globals)]
impl KMLAltitudeMode {
  /// Altitude relative to ground surface
  pub const CLAMP_TO_GROUND: Self = Self(0);
  /// Altitude relative to ground elevation
  pub const RELATIVE_TO_GROUND: Self = Self(1);
  /// Altitude as absolute meters above WGS84 ellipsoid
  pub const ABSOLUTE: Self = Self(2);
  /// Clamp to sea floor
  pub const CLAMP_TO_SEA_FLOOR: Self = Self(3);
  /// Relative to sea floor
  pub const RELATIVE_TO_SEA_FLOOR: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CLAMP_TO_GROUND,
    Self::RELATIVE_TO_GROUND,
    Self::ABSOLUTE,
    Self::CLAMP_TO_SEA_FLOOR,
    Self::RELATIVE_TO_SEA_FLOOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CLAMP_TO_GROUND => Some("CLAMP_TO_GROUND"),
      Self::RELATIVE_TO_GROUND => Some("RELATIVE_TO_GROUND"),
      Self::ABSOLUTE => Some("ABSOLUTE"),
      Self::CLAMP_TO_SEA_FLOOR => Some("CLAMP_TO_SEA_FLOOR"),
      Self::RELATIVE_TO_SEA_FLOOR => Some("RELATIVE_TO_SEA_FLOOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLAltitudeMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLAltitudeMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLAltitudeMode {
    type Output = KMLAltitudeMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLAltitudeMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLAltitudeMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLAltitudeMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLCOLOR_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLCOLOR_MODE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLCOLOR_MODE: [KMLColorMode; 2] = [
  KMLColorMode::NORMAL,
  KMLColorMode::RANDOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLColorMode(pub i8);
#[allow(non_upper_case_globals)]
impl KMLColorMode {
  pub const NORMAL: Self = Self(0);
  pub const RANDOM: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::RANDOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::RANDOM => Some("RANDOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLColorMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLColorMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLColorMode {
    type Output = KMLColorMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLColorMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLColorMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLColorMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLSTYLE_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLSTYLE_STATE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLSTYLE_STATE: [KMLStyleState; 2] = [
  KMLStyleState::NORMAL,
  KMLStyleState::HIGHLIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLStyleState(pub i8);
#[allow(non_upper_case_globals)]
impl KMLStyleState {
  pub const NORMAL: Self = Self(0);
  pub const HIGHLIGHT: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::HIGHLIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::HIGHLIGHT => Some("HIGHLIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLStyleState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLStyleState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLStyleState {
    type Output = KMLStyleState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLStyleState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLStyleState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLStyleState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLUNITS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLUNITS: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLUNITS: [KMLUnits; 3] = [
  KMLUnits::PIXELS,
  KMLUnits::FRACTION,
  KMLUnits::INSET_PIXELS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLUnits(pub i8);
#[allow(non_upper_case_globals)]
impl KMLUnits {
  pub const PIXELS: Self = Self(0);
  pub const FRACTION: Self = Self(1);
  pub const INSET_PIXELS: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PIXELS,
    Self::FRACTION,
    Self::INSET_PIXELS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PIXELS => Some("PIXELS"),
      Self::FRACTION => Some("FRACTION"),
      Self::INSET_PIXELS => Some("INSET_PIXELS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLUnits {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLUnits {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLUnits {
    type Output = KMLUnits;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLUnits {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLUnits {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLUnits {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLREFRESH_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLREFRESH_MODE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLREFRESH_MODE: [KMLRefreshMode; 3] = [
  KMLRefreshMode::ON_CHANGE,
  KMLRefreshMode::ON_INTERVAL,
  KMLRefreshMode::ON_EXPIRE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLRefreshMode(pub i8);
#[allow(non_upper_case_globals)]
impl KMLRefreshMode {
  pub const ON_CHANGE: Self = Self(0);
  pub const ON_INTERVAL: Self = Self(1);
  pub const ON_EXPIRE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ON_CHANGE,
    Self::ON_INTERVAL,
    Self::ON_EXPIRE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ON_CHANGE => Some("ON_CHANGE"),
      Self::ON_INTERVAL => Some("ON_INTERVAL"),
      Self::ON_EXPIRE => Some("ON_EXPIRE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLRefreshMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLRefreshMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLRefreshMode {
    type Output = KMLRefreshMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLRefreshMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLRefreshMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLRefreshMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KMLVIEW_REFRESH_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KMLVIEW_REFRESH_MODE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KMLVIEW_REFRESH_MODE: [KMLViewRefreshMode; 4] = [
  KMLViewRefreshMode::NEVER,
  KMLViewRefreshMode::ON_STOP,
  KMLViewRefreshMode::ON_REQUEST,
  KMLViewRefreshMode::ON_REGION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KMLViewRefreshMode(pub i8);
#[allow(non_upper_case_globals)]
impl KMLViewRefreshMode {
  pub const NEVER: Self = Self(0);
  pub const ON_STOP: Self = Self(1);
  pub const ON_REQUEST: Self = Self(2);
  pub const ON_REGION: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NEVER,
    Self::ON_STOP,
    Self::ON_REQUEST,
    Self::ON_REGION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NEVER => Some("NEVER"),
      Self::ON_STOP => Some("ON_STOP"),
      Self::ON_REQUEST => Some("ON_REQUEST"),
      Self::ON_REGION => Some("ON_REGION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KMLViewRefreshMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KMLViewRefreshMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KMLViewRefreshMode {
    type Output = KMLViewRefreshMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KMLViewRefreshMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KMLViewRefreshMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KMLViewRefreshMode {}
pub enum KMLCoordinateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// KML coordinate (longitude, latitude, optional altitude)
pub struct KMLCoordinate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLCoordinate<'a> {
  type Inner = KMLCoordinate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLCoordinate<'a> {
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLCoordinate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLCoordinateArgs
  ) -> flatbuffers::WIPOffset<KMLCoordinate<'bldr>> {
    let mut builder = KMLCoordinateBuilder::new(_fbb);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLCoordinateT {
    let LONGITUDE = self.LONGITUDE();
    let LATITUDE = self.LATITUDE();
    let ALTITUDE = self.ALTITUDE();
    KMLCoordinateT {
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
    }
  }

  /// Longitude in decimal degrees
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCoordinate::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Latitude in decimal degrees
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCoordinate::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude in meters
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCoordinate::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLCoordinate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLCoordinateArgs {
    pub LONGITUDE: f64,
    pub LATITUDE: f64,
    pub ALTITUDE: f64,
}
impl<'a> Default for KMLCoordinateArgs {
  #[inline]
  fn default() -> Self {
    KMLCoordinateArgs {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
    }
  }
}

pub struct KMLCoordinateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLCoordinateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCoordinate::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCoordinate::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCoordinate::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLCoordinateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLCoordinateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLCoordinate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLCoordinate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLCoordinate");
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLCoordinateT {
  pub LONGITUDE: f64,
  pub LATITUDE: f64,
  pub ALTITUDE: f64,
}
impl Default for KMLCoordinateT {
  fn default() -> Self {
    Self {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
    }
  }
}
impl KMLCoordinateT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLCoordinate<'b>> {
    let LONGITUDE = self.LONGITUDE;
    let LATITUDE = self.LATITUDE;
    let ALTITUDE = self.ALTITUDE;
    KMLCoordinate::create(_fbb, &KMLCoordinateArgs{
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
    })
  }
}
pub enum KMLLookAtOffset {}
#[derive(Copy, Clone, PartialEq)]

/// LookAt viewpoint
pub struct KMLLookAt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLLookAt<'a> {
  type Inner = KMLLookAt<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLLookAt<'a> {
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 8;
  pub const VT_HEADING: flatbuffers::VOffsetT = 10;
  pub const VT_TILT: flatbuffers::VOffsetT = 12;
  pub const VT_RANGE: flatbuffers::VOffsetT = 14;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLLookAt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLLookAtArgs
  ) -> flatbuffers::WIPOffset<KMLLookAt<'bldr>> {
    let mut builder = KMLLookAtBuilder::new(_fbb);
    builder.add_RANGE(args.RANGE);
    builder.add_TILT(args.TILT);
    builder.add_HEADING(args.HEADING);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLLookAtT {
    let LONGITUDE = self.LONGITUDE();
    let LATITUDE = self.LATITUDE();
    let ALTITUDE = self.ALTITUDE();
    let HEADING = self.HEADING();
    let TILT = self.TILT();
    let RANGE = self.RANGE();
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    KMLLookAtT {
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HEADING,
      TILT,
      RANGE,
      ALTITUDE_MODE,
    }
  }

  /// Longitude of the point being looked at
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Latitude of the point being looked at
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude of the point being looked at
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Heading in degrees (0=North)
  #[inline]
  pub fn HEADING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_HEADING, Some(0.0)).unwrap()}
  }
  /// Tilt in degrees from vertical (0=straight down)
  #[inline]
  pub fn TILT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_TILT, Some(0.0)).unwrap()}
  }
  /// Range in meters from the point
  #[inline]
  pub fn RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLookAt::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLLookAt::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLLookAt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<f64>("HEADING", Self::VT_HEADING, false)?
     .visit_field::<f64>("TILT", Self::VT_TILT, false)?
     .visit_field::<f64>("RANGE", Self::VT_RANGE, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLLookAtArgs {
    pub LONGITUDE: f64,
    pub LATITUDE: f64,
    pub ALTITUDE: f64,
    pub HEADING: f64,
    pub TILT: f64,
    pub RANGE: f64,
    pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl<'a> Default for KMLLookAtArgs {
  #[inline]
  fn default() -> Self {
    KMLLookAtArgs {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HEADING: 0.0,
      TILT: 0.0,
      RANGE: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}

pub struct KMLLookAtBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLLookAtBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_HEADING(&mut self, HEADING: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_HEADING, HEADING, 0.0);
  }
  #[inline]
  pub fn add_TILT(&mut self, TILT: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_TILT, TILT, 0.0);
  }
  #[inline]
  pub fn add_RANGE(&mut self, RANGE: f64) {
    self.fbb_.push_slot::<f64>(KMLLookAt::VT_RANGE, RANGE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLLookAt::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLLookAtBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLLookAtBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLLookAt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLLookAt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLLookAt");
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("HEADING", &self.HEADING());
      ds.field("TILT", &self.TILT());
      ds.field("RANGE", &self.RANGE());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLLookAtT {
  pub LONGITUDE: f64,
  pub LATITUDE: f64,
  pub ALTITUDE: f64,
  pub HEADING: f64,
  pub TILT: f64,
  pub RANGE: f64,
  pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl Default for KMLLookAtT {
  fn default() -> Self {
    Self {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HEADING: 0.0,
      TILT: 0.0,
      RANGE: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}
impl KMLLookAtT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLLookAt<'b>> {
    let LONGITUDE = self.LONGITUDE;
    let LATITUDE = self.LATITUDE;
    let ALTITUDE = self.ALTITUDE;
    let HEADING = self.HEADING;
    let TILT = self.TILT;
    let RANGE = self.RANGE;
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    KMLLookAt::create(_fbb, &KMLLookAtArgs{
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HEADING,
      TILT,
      RANGE,
      ALTITUDE_MODE,
    })
  }
}
pub enum KMLCameraOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Camera viewpoint
pub struct KMLCamera<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLCamera<'a> {
  type Inner = KMLCamera<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLCamera<'a> {
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 8;
  pub const VT_HEADING: flatbuffers::VOffsetT = 10;
  pub const VT_TILT: flatbuffers::VOffsetT = 12;
  pub const VT_ROLL: flatbuffers::VOffsetT = 14;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLCamera { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLCameraArgs
  ) -> flatbuffers::WIPOffset<KMLCamera<'bldr>> {
    let mut builder = KMLCameraBuilder::new(_fbb);
    builder.add_ROLL(args.ROLL);
    builder.add_TILT(args.TILT);
    builder.add_HEADING(args.HEADING);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLCameraT {
    let LONGITUDE = self.LONGITUDE();
    let LATITUDE = self.LATITUDE();
    let ALTITUDE = self.ALTITUDE();
    let HEADING = self.HEADING();
    let TILT = self.TILT();
    let ROLL = self.ROLL();
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    KMLCameraT {
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HEADING,
      TILT,
      ROLL,
      ALTITUDE_MODE,
    }
  }

  /// Camera longitude
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Camera latitude
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Camera altitude
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Heading in degrees (0=North)
  #[inline]
  pub fn HEADING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_HEADING, Some(0.0)).unwrap()}
  }
  /// Tilt in degrees from vertical
  #[inline]
  pub fn TILT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_TILT, Some(0.0)).unwrap()}
  }
  /// Roll in degrees
  #[inline]
  pub fn ROLL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLCamera::VT_ROLL, Some(0.0)).unwrap()}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLCamera::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLCamera<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<f64>("HEADING", Self::VT_HEADING, false)?
     .visit_field::<f64>("TILT", Self::VT_TILT, false)?
     .visit_field::<f64>("ROLL", Self::VT_ROLL, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLCameraArgs {
    pub LONGITUDE: f64,
    pub LATITUDE: f64,
    pub ALTITUDE: f64,
    pub HEADING: f64,
    pub TILT: f64,
    pub ROLL: f64,
    pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl<'a> Default for KMLCameraArgs {
  #[inline]
  fn default() -> Self {
    KMLCameraArgs {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HEADING: 0.0,
      TILT: 0.0,
      ROLL: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}

pub struct KMLCameraBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLCameraBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_HEADING(&mut self, HEADING: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_HEADING, HEADING, 0.0);
  }
  #[inline]
  pub fn add_TILT(&mut self, TILT: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_TILT, TILT, 0.0);
  }
  #[inline]
  pub fn add_ROLL(&mut self, ROLL: f64) {
    self.fbb_.push_slot::<f64>(KMLCamera::VT_ROLL, ROLL, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLCamera::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLCameraBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLCameraBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLCamera<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLCamera<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLCamera");
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("HEADING", &self.HEADING());
      ds.field("TILT", &self.TILT());
      ds.field("ROLL", &self.ROLL());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLCameraT {
  pub LONGITUDE: f64,
  pub LATITUDE: f64,
  pub ALTITUDE: f64,
  pub HEADING: f64,
  pub TILT: f64,
  pub ROLL: f64,
  pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl Default for KMLCameraT {
  fn default() -> Self {
    Self {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HEADING: 0.0,
      TILT: 0.0,
      ROLL: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}
impl KMLCameraT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLCamera<'b>> {
    let LONGITUDE = self.LONGITUDE;
    let LATITUDE = self.LATITUDE;
    let ALTITUDE = self.ALTITUDE;
    let HEADING = self.HEADING;
    let TILT = self.TILT;
    let ROLL = self.ROLL;
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    KMLCamera::create(_fbb, &KMLCameraArgs{
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HEADING,
      TILT,
      ROLL,
      ALTITUDE_MODE,
    })
  }
}
pub enum KMLIconStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Icon style
pub struct KMLIconStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLIconStyle<'a> {
  type Inner = KMLIconStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLIconStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_HEADING: flatbuffers::VOffsetT = 10;
  pub const VT_ICON_HREF: flatbuffers::VOffsetT = 12;
  pub const VT_HOTSPOT_X: flatbuffers::VOffsetT = 14;
  pub const VT_HOTSPOT_Y: flatbuffers::VOffsetT = 16;
  pub const VT_HOTSPOT_X_UNITS: flatbuffers::VOffsetT = 18;
  pub const VT_HOTSPOT_Y_UNITS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLIconStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLIconStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLIconStyle<'bldr>> {
    let mut builder = KMLIconStyleBuilder::new(_fbb);
    builder.add_HOTSPOT_Y(args.HOTSPOT_Y);
    builder.add_HOTSPOT_X(args.HOTSPOT_X);
    builder.add_HEADING(args.HEADING);
    builder.add_SCALE(args.SCALE);
    if let Some(x) = args.ICON_HREF { builder.add_ICON_HREF(x); }
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_HOTSPOT_Y_UNITS(args.HOTSPOT_Y_UNITS);
    builder.add_HOTSPOT_X_UNITS(args.HOTSPOT_X_UNITS);
    builder.add_COLOR_MODE(args.COLOR_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLIconStyleT {
    let COLOR = self.COLOR().map(|x| {
      x.to_string()
    });
    let COLOR_MODE = self.COLOR_MODE();
    let SCALE = self.SCALE();
    let HEADING = self.HEADING();
    let ICON_HREF = self.ICON_HREF().map(|x| {
      x.to_string()
    });
    let HOTSPOT_X = self.HOTSPOT_X();
    let HOTSPOT_Y = self.HOTSPOT_Y();
    let HOTSPOT_X_UNITS = self.HOTSPOT_X_UNITS();
    let HOTSPOT_Y_UNITS = self.HOTSPOT_Y_UNITS();
    KMLIconStyleT {
      COLOR,
      COLOR_MODE,
      SCALE,
      HEADING,
      ICON_HREF,
      HOTSPOT_X,
      HOTSPOT_Y,
      HOTSPOT_X_UNITS,
      HOTSPOT_Y_UNITS,
    }
  }

  /// KML color in aabbggrr hex format
  #[inline]
  pub fn COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLIconStyle::VT_COLOR, None)}
  }
  /// Color mode
  #[inline]
  pub fn COLOR_MODE(&self) -> KMLColorMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLColorMode>(KMLIconStyle::VT_COLOR_MODE, Some(KMLColorMode::NORMAL)).unwrap()}
  }
  /// Scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLIconStyle::VT_SCALE, Some(0.0)).unwrap()}
  }
  /// Heading in degrees
  #[inline]
  pub fn HEADING(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLIconStyle::VT_HEADING, Some(0.0)).unwrap()}
  }
  /// Icon href (URL)
  #[inline]
  pub fn ICON_HREF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLIconStyle::VT_ICON_HREF, None)}
  }
  /// Hot spot X value
  #[inline]
  pub fn HOTSPOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLIconStyle::VT_HOTSPOT_X, Some(0.0)).unwrap()}
  }
  /// Hot spot Y value
  #[inline]
  pub fn HOTSPOT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLIconStyle::VT_HOTSPOT_Y, Some(0.0)).unwrap()}
  }
  /// Hot spot X units
  #[inline]
  pub fn HOTSPOT_X_UNITS(&self) -> KMLUnits {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLUnits>(KMLIconStyle::VT_HOTSPOT_X_UNITS, Some(KMLUnits::PIXELS)).unwrap()}
  }
  /// Hot spot Y units
  #[inline]
  pub fn HOTSPOT_Y_UNITS(&self) -> KMLUnits {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLUnits>(KMLIconStyle::VT_HOTSPOT_Y_UNITS, Some(KMLUnits::PIXELS)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLIconStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<KMLColorMode>("COLOR_MODE", Self::VT_COLOR_MODE, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .visit_field::<f64>("HEADING", Self::VT_HEADING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ICON_HREF", Self::VT_ICON_HREF, false)?
     .visit_field::<f64>("HOTSPOT_X", Self::VT_HOTSPOT_X, false)?
     .visit_field::<f64>("HOTSPOT_Y", Self::VT_HOTSPOT_Y, false)?
     .visit_field::<KMLUnits>("HOTSPOT_X_UNITS", Self::VT_HOTSPOT_X_UNITS, false)?
     .visit_field::<KMLUnits>("HOTSPOT_Y_UNITS", Self::VT_HOTSPOT_Y_UNITS, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLIconStyleArgs<'a> {
    pub COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR_MODE: KMLColorMode,
    pub SCALE: f64,
    pub HEADING: f64,
    pub ICON_HREF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HOTSPOT_X: f64,
    pub HOTSPOT_Y: f64,
    pub HOTSPOT_X_UNITS: KMLUnits,
    pub HOTSPOT_Y_UNITS: KMLUnits,
}
impl<'a> Default for KMLIconStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLIconStyleArgs {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      SCALE: 0.0,
      HEADING: 0.0,
      ICON_HREF: None,
      HOTSPOT_X: 0.0,
      HOTSPOT_Y: 0.0,
      HOTSPOT_X_UNITS: KMLUnits::PIXELS,
      HOTSPOT_Y_UNITS: KMLUnits::PIXELS,
    }
  }
}

pub struct KMLIconStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLIconStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLIconStyle::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_COLOR_MODE(&mut self, COLOR_MODE: KMLColorMode) {
    self.fbb_.push_slot::<KMLColorMode>(KMLIconStyle::VT_COLOR_MODE, COLOR_MODE, KMLColorMode::NORMAL);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(KMLIconStyle::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn add_HEADING(&mut self, HEADING: f64) {
    self.fbb_.push_slot::<f64>(KMLIconStyle::VT_HEADING, HEADING, 0.0);
  }
  #[inline]
  pub fn add_ICON_HREF(&mut self, ICON_HREF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLIconStyle::VT_ICON_HREF, ICON_HREF);
  }
  #[inline]
  pub fn add_HOTSPOT_X(&mut self, HOTSPOT_X: f64) {
    self.fbb_.push_slot::<f64>(KMLIconStyle::VT_HOTSPOT_X, HOTSPOT_X, 0.0);
  }
  #[inline]
  pub fn add_HOTSPOT_Y(&mut self, HOTSPOT_Y: f64) {
    self.fbb_.push_slot::<f64>(KMLIconStyle::VT_HOTSPOT_Y, HOTSPOT_Y, 0.0);
  }
  #[inline]
  pub fn add_HOTSPOT_X_UNITS(&mut self, HOTSPOT_X_UNITS: KMLUnits) {
    self.fbb_.push_slot::<KMLUnits>(KMLIconStyle::VT_HOTSPOT_X_UNITS, HOTSPOT_X_UNITS, KMLUnits::PIXELS);
  }
  #[inline]
  pub fn add_HOTSPOT_Y_UNITS(&mut self, HOTSPOT_Y_UNITS: KMLUnits) {
    self.fbb_.push_slot::<KMLUnits>(KMLIconStyle::VT_HOTSPOT_Y_UNITS, HOTSPOT_Y_UNITS, KMLUnits::PIXELS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLIconStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLIconStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLIconStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLIconStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLIconStyle");
      ds.field("COLOR", &self.COLOR());
      ds.field("COLOR_MODE", &self.COLOR_MODE());
      ds.field("SCALE", &self.SCALE());
      ds.field("HEADING", &self.HEADING());
      ds.field("ICON_HREF", &self.ICON_HREF());
      ds.field("HOTSPOT_X", &self.HOTSPOT_X());
      ds.field("HOTSPOT_Y", &self.HOTSPOT_Y());
      ds.field("HOTSPOT_X_UNITS", &self.HOTSPOT_X_UNITS());
      ds.field("HOTSPOT_Y_UNITS", &self.HOTSPOT_Y_UNITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLIconStyleT {
  pub COLOR: Option<String>,
  pub COLOR_MODE: KMLColorMode,
  pub SCALE: f64,
  pub HEADING: f64,
  pub ICON_HREF: Option<String>,
  pub HOTSPOT_X: f64,
  pub HOTSPOT_Y: f64,
  pub HOTSPOT_X_UNITS: KMLUnits,
  pub HOTSPOT_Y_UNITS: KMLUnits,
}
impl Default for KMLIconStyleT {
  fn default() -> Self {
    Self {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      SCALE: 0.0,
      HEADING: 0.0,
      ICON_HREF: None,
      HOTSPOT_X: 0.0,
      HOTSPOT_Y: 0.0,
      HOTSPOT_X_UNITS: KMLUnits::PIXELS,
      HOTSPOT_Y_UNITS: KMLUnits::PIXELS,
    }
  }
}
impl KMLIconStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLIconStyle<'b>> {
    let COLOR = self.COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR_MODE = self.COLOR_MODE;
    let SCALE = self.SCALE;
    let HEADING = self.HEADING;
    let ICON_HREF = self.ICON_HREF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HOTSPOT_X = self.HOTSPOT_X;
    let HOTSPOT_Y = self.HOTSPOT_Y;
    let HOTSPOT_X_UNITS = self.HOTSPOT_X_UNITS;
    let HOTSPOT_Y_UNITS = self.HOTSPOT_Y_UNITS;
    KMLIconStyle::create(_fbb, &KMLIconStyleArgs{
      COLOR,
      COLOR_MODE,
      SCALE,
      HEADING,
      ICON_HREF,
      HOTSPOT_X,
      HOTSPOT_Y,
      HOTSPOT_X_UNITS,
      HOTSPOT_Y_UNITS,
    })
  }
}
pub enum KMLLineStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Line style
pub struct KMLLineStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLLineStyle<'a> {
  type Inner = KMLLineStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLLineStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLLineStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLLineStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLLineStyle<'bldr>> {
    let mut builder = KMLLineStyleBuilder::new(_fbb);
    builder.add_WIDTH(args.WIDTH);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_COLOR_MODE(args.COLOR_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLLineStyleT {
    let COLOR = self.COLOR().map(|x| {
      x.to_string()
    });
    let COLOR_MODE = self.COLOR_MODE();
    let WIDTH = self.WIDTH();
    KMLLineStyleT {
      COLOR,
      COLOR_MODE,
      WIDTH,
    }
  }

  /// KML color in aabbggrr hex format
  #[inline]
  pub fn COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLLineStyle::VT_COLOR, None)}
  }
  /// Color mode
  #[inline]
  pub fn COLOR_MODE(&self) -> KMLColorMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLColorMode>(KMLLineStyle::VT_COLOR_MODE, Some(KMLColorMode::NORMAL)).unwrap()}
  }
  /// Width in pixels
  #[inline]
  pub fn WIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLineStyle::VT_WIDTH, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLLineStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<KMLColorMode>("COLOR_MODE", Self::VT_COLOR_MODE, false)?
     .visit_field::<f64>("WIDTH", Self::VT_WIDTH, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLLineStyleArgs<'a> {
    pub COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR_MODE: KMLColorMode,
    pub WIDTH: f64,
}
impl<'a> Default for KMLLineStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLLineStyleArgs {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      WIDTH: 0.0,
    }
  }
}

pub struct KMLLineStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLLineStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLLineStyle::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_COLOR_MODE(&mut self, COLOR_MODE: KMLColorMode) {
    self.fbb_.push_slot::<KMLColorMode>(KMLLineStyle::VT_COLOR_MODE, COLOR_MODE, KMLColorMode::NORMAL);
  }
  #[inline]
  pub fn add_WIDTH(&mut self, WIDTH: f64) {
    self.fbb_.push_slot::<f64>(KMLLineStyle::VT_WIDTH, WIDTH, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLLineStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLLineStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLLineStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLLineStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLLineStyle");
      ds.field("COLOR", &self.COLOR());
      ds.field("COLOR_MODE", &self.COLOR_MODE());
      ds.field("WIDTH", &self.WIDTH());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLLineStyleT {
  pub COLOR: Option<String>,
  pub COLOR_MODE: KMLColorMode,
  pub WIDTH: f64,
}
impl Default for KMLLineStyleT {
  fn default() -> Self {
    Self {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      WIDTH: 0.0,
    }
  }
}
impl KMLLineStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLLineStyle<'b>> {
    let COLOR = self.COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR_MODE = self.COLOR_MODE;
    let WIDTH = self.WIDTH;
    KMLLineStyle::create(_fbb, &KMLLineStyleArgs{
      COLOR,
      COLOR_MODE,
      WIDTH,
    })
  }
}
pub enum KMLPolyStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Polygon style
pub struct KMLPolyStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLPolyStyle<'a> {
  type Inner = KMLPolyStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLPolyStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_FILL: flatbuffers::VOffsetT = 8;
  pub const VT_OUTLINE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLPolyStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLPolyStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLPolyStyle<'bldr>> {
    let mut builder = KMLPolyStyleBuilder::new(_fbb);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_OUTLINE(args.OUTLINE);
    builder.add_FILL(args.FILL);
    builder.add_COLOR_MODE(args.COLOR_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLPolyStyleT {
    let COLOR = self.COLOR().map(|x| {
      x.to_string()
    });
    let COLOR_MODE = self.COLOR_MODE();
    let FILL = self.FILL();
    let OUTLINE = self.OUTLINE();
    KMLPolyStyleT {
      COLOR,
      COLOR_MODE,
      FILL,
      OUTLINE,
    }
  }

  /// KML color in aabbggrr hex format
  #[inline]
  pub fn COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLPolyStyle::VT_COLOR, None)}
  }
  /// Color mode
  #[inline]
  pub fn COLOR_MODE(&self) -> KMLColorMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLColorMode>(KMLPolyStyle::VT_COLOR_MODE, Some(KMLColorMode::NORMAL)).unwrap()}
  }
  /// Whether to fill
  #[inline]
  pub fn FILL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPolyStyle::VT_FILL, Some(false)).unwrap()}
  }
  /// Whether to outline
  #[inline]
  pub fn OUTLINE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPolyStyle::VT_OUTLINE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLPolyStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<KMLColorMode>("COLOR_MODE", Self::VT_COLOR_MODE, false)?
     .visit_field::<bool>("FILL", Self::VT_FILL, false)?
     .visit_field::<bool>("OUTLINE", Self::VT_OUTLINE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLPolyStyleArgs<'a> {
    pub COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR_MODE: KMLColorMode,
    pub FILL: bool,
    pub OUTLINE: bool,
}
impl<'a> Default for KMLPolyStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLPolyStyleArgs {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      FILL: false,
      OUTLINE: false,
    }
  }
}

pub struct KMLPolyStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLPolyStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPolyStyle::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_COLOR_MODE(&mut self, COLOR_MODE: KMLColorMode) {
    self.fbb_.push_slot::<KMLColorMode>(KMLPolyStyle::VT_COLOR_MODE, COLOR_MODE, KMLColorMode::NORMAL);
  }
  #[inline]
  pub fn add_FILL(&mut self, FILL: bool) {
    self.fbb_.push_slot::<bool>(KMLPolyStyle::VT_FILL, FILL, false);
  }
  #[inline]
  pub fn add_OUTLINE(&mut self, OUTLINE: bool) {
    self.fbb_.push_slot::<bool>(KMLPolyStyle::VT_OUTLINE, OUTLINE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLPolyStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLPolyStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLPolyStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLPolyStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLPolyStyle");
      ds.field("COLOR", &self.COLOR());
      ds.field("COLOR_MODE", &self.COLOR_MODE());
      ds.field("FILL", &self.FILL());
      ds.field("OUTLINE", &self.OUTLINE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLPolyStyleT {
  pub COLOR: Option<String>,
  pub COLOR_MODE: KMLColorMode,
  pub FILL: bool,
  pub OUTLINE: bool,
}
impl Default for KMLPolyStyleT {
  fn default() -> Self {
    Self {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      FILL: false,
      OUTLINE: false,
    }
  }
}
impl KMLPolyStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLPolyStyle<'b>> {
    let COLOR = self.COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR_MODE = self.COLOR_MODE;
    let FILL = self.FILL;
    let OUTLINE = self.OUTLINE;
    KMLPolyStyle::create(_fbb, &KMLPolyStyleArgs{
      COLOR,
      COLOR_MODE,
      FILL,
      OUTLINE,
    })
  }
}
pub enum KMLLabelStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Label style
pub struct KMLLabelStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLLabelStyle<'a> {
  type Inner = KMLLabelStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLLabelStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLLabelStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLLabelStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLLabelStyle<'bldr>> {
    let mut builder = KMLLabelStyleBuilder::new(_fbb);
    builder.add_SCALE(args.SCALE);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_COLOR_MODE(args.COLOR_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLLabelStyleT {
    let COLOR = self.COLOR().map(|x| {
      x.to_string()
    });
    let COLOR_MODE = self.COLOR_MODE();
    let SCALE = self.SCALE();
    KMLLabelStyleT {
      COLOR,
      COLOR_MODE,
      SCALE,
    }
  }

  /// KML color in aabbggrr hex format
  #[inline]
  pub fn COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLLabelStyle::VT_COLOR, None)}
  }
  /// Color mode
  #[inline]
  pub fn COLOR_MODE(&self) -> KMLColorMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLColorMode>(KMLLabelStyle::VT_COLOR_MODE, Some(KMLColorMode::NORMAL)).unwrap()}
  }
  /// Scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLLabelStyle::VT_SCALE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLLabelStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<KMLColorMode>("COLOR_MODE", Self::VT_COLOR_MODE, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLLabelStyleArgs<'a> {
    pub COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR_MODE: KMLColorMode,
    pub SCALE: f64,
}
impl<'a> Default for KMLLabelStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLLabelStyleArgs {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      SCALE: 0.0,
    }
  }
}

pub struct KMLLabelStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLLabelStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLLabelStyle::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_COLOR_MODE(&mut self, COLOR_MODE: KMLColorMode) {
    self.fbb_.push_slot::<KMLColorMode>(KMLLabelStyle::VT_COLOR_MODE, COLOR_MODE, KMLColorMode::NORMAL);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(KMLLabelStyle::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLLabelStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLLabelStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLLabelStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLLabelStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLLabelStyle");
      ds.field("COLOR", &self.COLOR());
      ds.field("COLOR_MODE", &self.COLOR_MODE());
      ds.field("SCALE", &self.SCALE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLLabelStyleT {
  pub COLOR: Option<String>,
  pub COLOR_MODE: KMLColorMode,
  pub SCALE: f64,
}
impl Default for KMLLabelStyleT {
  fn default() -> Self {
    Self {
      COLOR: None,
      COLOR_MODE: KMLColorMode::NORMAL,
      SCALE: 0.0,
    }
  }
}
impl KMLLabelStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLLabelStyle<'b>> {
    let COLOR = self.COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR_MODE = self.COLOR_MODE;
    let SCALE = self.SCALE;
    KMLLabelStyle::create(_fbb, &KMLLabelStyleArgs{
      COLOR,
      COLOR_MODE,
      SCALE,
    })
  }
}
pub enum KMLBalloonStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Balloon style
pub struct KMLBalloonStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLBalloonStyle<'a> {
  type Inner = KMLBalloonStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLBalloonStyle<'a> {
  pub const VT_BG_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT_COLOR: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLBalloonStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLBalloonStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLBalloonStyle<'bldr>> {
    let mut builder = KMLBalloonStyleBuilder::new(_fbb);
    if let Some(x) = args.TEXT { builder.add_TEXT(x); }
    if let Some(x) = args.TEXT_COLOR { builder.add_TEXT_COLOR(x); }
    if let Some(x) = args.BG_COLOR { builder.add_BG_COLOR(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLBalloonStyleT {
    let BG_COLOR = self.BG_COLOR().map(|x| {
      x.to_string()
    });
    let TEXT_COLOR = self.TEXT_COLOR().map(|x| {
      x.to_string()
    });
    let TEXT = self.TEXT().map(|x| {
      x.to_string()
    });
    KMLBalloonStyleT {
      BG_COLOR,
      TEXT_COLOR,
      TEXT,
    }
  }

  /// Background color in aabbggrr hex format
  #[inline]
  pub fn BG_COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLBalloonStyle::VT_BG_COLOR, None)}
  }
  /// Text color in aabbggrr hex format
  #[inline]
  pub fn TEXT_COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLBalloonStyle::VT_TEXT_COLOR, None)}
  }
  /// Balloon text template (supports $[name], $[description])
  #[inline]
  pub fn TEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLBalloonStyle::VT_TEXT, None)}
  }
}

impl flatbuffers::Verifiable for KMLBalloonStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BG_COLOR", Self::VT_BG_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TEXT_COLOR", Self::VT_TEXT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TEXT", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLBalloonStyleArgs<'a> {
    pub BG_COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TEXT_COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TEXT: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KMLBalloonStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLBalloonStyleArgs {
      BG_COLOR: None,
      TEXT_COLOR: None,
      TEXT: None,
    }
  }
}

pub struct KMLBalloonStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLBalloonStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_BG_COLOR(&mut self, BG_COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLBalloonStyle::VT_BG_COLOR, BG_COLOR);
  }
  #[inline]
  pub fn add_TEXT_COLOR(&mut self, TEXT_COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLBalloonStyle::VT_TEXT_COLOR, TEXT_COLOR);
  }
  #[inline]
  pub fn add_TEXT(&mut self, TEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLBalloonStyle::VT_TEXT, TEXT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLBalloonStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLBalloonStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLBalloonStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLBalloonStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLBalloonStyle");
      ds.field("BG_COLOR", &self.BG_COLOR());
      ds.field("TEXT_COLOR", &self.TEXT_COLOR());
      ds.field("TEXT", &self.TEXT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLBalloonStyleT {
  pub BG_COLOR: Option<String>,
  pub TEXT_COLOR: Option<String>,
  pub TEXT: Option<String>,
}
impl Default for KMLBalloonStyleT {
  fn default() -> Self {
    Self {
      BG_COLOR: None,
      TEXT_COLOR: None,
      TEXT: None,
    }
  }
}
impl KMLBalloonStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLBalloonStyle<'b>> {
    let BG_COLOR = self.BG_COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TEXT_COLOR = self.TEXT_COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TEXT = self.TEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    KMLBalloonStyle::create(_fbb, &KMLBalloonStyleArgs{
      BG_COLOR,
      TEXT_COLOR,
      TEXT,
    })
  }
}
pub enum KMLStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Style definition
pub struct KMLStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLStyle<'a> {
  type Inner = KMLStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ICON_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_LABEL_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_LINE_STYLE: flatbuffers::VOffsetT = 10;
  pub const VT_POLY_STYLE: flatbuffers::VOffsetT = 12;
  pub const VT_BALLOON_STYLE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLStyle<'bldr>> {
    let mut builder = KMLStyleBuilder::new(_fbb);
    if let Some(x) = args.BALLOON_STYLE { builder.add_BALLOON_STYLE(x); }
    if let Some(x) = args.POLY_STYLE { builder.add_POLY_STYLE(x); }
    if let Some(x) = args.LINE_STYLE { builder.add_LINE_STYLE(x); }
    if let Some(x) = args.LABEL_STYLE { builder.add_LABEL_STYLE(x); }
    if let Some(x) = args.ICON_STYLE { builder.add_ICON_STYLE(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLStyleT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let ICON_STYLE = self.ICON_STYLE().map(|x| {
      Box::new(x.unpack())
    });
    let LABEL_STYLE = self.LABEL_STYLE().map(|x| {
      Box::new(x.unpack())
    });
    let LINE_STYLE = self.LINE_STYLE().map(|x| {
      Box::new(x.unpack())
    });
    let POLY_STYLE = self.POLY_STYLE().map(|x| {
      Box::new(x.unpack())
    });
    let BALLOON_STYLE = self.BALLOON_STYLE().map(|x| {
      Box::new(x.unpack())
    });
    KMLStyleT {
      ID,
      ICON_STYLE,
      LABEL_STYLE,
      LINE_STYLE,
      POLY_STYLE,
      BALLOON_STYLE,
    }
  }

  /// Style identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLStyle::VT_ID, None)}
  }
  /// Icon style
  #[inline]
  pub fn ICON_STYLE(&self) -> Option<KMLIconStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLIconStyle>>(KMLStyle::VT_ICON_STYLE, None)}
  }
  /// Label style
  #[inline]
  pub fn LABEL_STYLE(&self) -> Option<KMLLabelStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLLabelStyle>>(KMLStyle::VT_LABEL_STYLE, None)}
  }
  /// Line style
  #[inline]
  pub fn LINE_STYLE(&self) -> Option<KMLLineStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLLineStyle>>(KMLStyle::VT_LINE_STYLE, None)}
  }
  /// Polygon style
  #[inline]
  pub fn POLY_STYLE(&self) -> Option<KMLPolyStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLPolyStyle>>(KMLStyle::VT_POLY_STYLE, None)}
  }
  /// Balloon style
  #[inline]
  pub fn BALLOON_STYLE(&self) -> Option<KMLBalloonStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLBalloonStyle>>(KMLStyle::VT_BALLOON_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for KMLStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLIconStyle>>("ICON_STYLE", Self::VT_ICON_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLLabelStyle>>("LABEL_STYLE", Self::VT_LABEL_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLLineStyle>>("LINE_STYLE", Self::VT_LINE_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLPolyStyle>>("POLY_STYLE", Self::VT_POLY_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLBalloonStyle>>("BALLOON_STYLE", Self::VT_BALLOON_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLStyleArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ICON_STYLE: Option<flatbuffers::WIPOffset<KMLIconStyle<'a>>>,
    pub LABEL_STYLE: Option<flatbuffers::WIPOffset<KMLLabelStyle<'a>>>,
    pub LINE_STYLE: Option<flatbuffers::WIPOffset<KMLLineStyle<'a>>>,
    pub POLY_STYLE: Option<flatbuffers::WIPOffset<KMLPolyStyle<'a>>>,
    pub BALLOON_STYLE: Option<flatbuffers::WIPOffset<KMLBalloonStyle<'a>>>,
}
impl<'a> Default for KMLStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLStyleArgs {
      ID: None,
      ICON_STYLE: None,
      LABEL_STYLE: None,
      LINE_STYLE: None,
      POLY_STYLE: None,
      BALLOON_STYLE: None,
    }
  }
}

pub struct KMLStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLStyle::VT_ID, ID);
  }
  #[inline]
  pub fn add_ICON_STYLE(&mut self, ICON_STYLE: flatbuffers::WIPOffset<KMLIconStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLIconStyle>>(KMLStyle::VT_ICON_STYLE, ICON_STYLE);
  }
  #[inline]
  pub fn add_LABEL_STYLE(&mut self, LABEL_STYLE: flatbuffers::WIPOffset<KMLLabelStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLLabelStyle>>(KMLStyle::VT_LABEL_STYLE, LABEL_STYLE);
  }
  #[inline]
  pub fn add_LINE_STYLE(&mut self, LINE_STYLE: flatbuffers::WIPOffset<KMLLineStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLLineStyle>>(KMLStyle::VT_LINE_STYLE, LINE_STYLE);
  }
  #[inline]
  pub fn add_POLY_STYLE(&mut self, POLY_STYLE: flatbuffers::WIPOffset<KMLPolyStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLPolyStyle>>(KMLStyle::VT_POLY_STYLE, POLY_STYLE);
  }
  #[inline]
  pub fn add_BALLOON_STYLE(&mut self, BALLOON_STYLE: flatbuffers::WIPOffset<KMLBalloonStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLBalloonStyle>>(KMLStyle::VT_BALLOON_STYLE, BALLOON_STYLE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLStyle");
      ds.field("ID", &self.ID());
      ds.field("ICON_STYLE", &self.ICON_STYLE());
      ds.field("LABEL_STYLE", &self.LABEL_STYLE());
      ds.field("LINE_STYLE", &self.LINE_STYLE());
      ds.field("POLY_STYLE", &self.POLY_STYLE());
      ds.field("BALLOON_STYLE", &self.BALLOON_STYLE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLStyleT {
  pub ID: Option<String>,
  pub ICON_STYLE: Option<Box<KMLIconStyleT>>,
  pub LABEL_STYLE: Option<Box<KMLLabelStyleT>>,
  pub LINE_STYLE: Option<Box<KMLLineStyleT>>,
  pub POLY_STYLE: Option<Box<KMLPolyStyleT>>,
  pub BALLOON_STYLE: Option<Box<KMLBalloonStyleT>>,
}
impl Default for KMLStyleT {
  fn default() -> Self {
    Self {
      ID: None,
      ICON_STYLE: None,
      LABEL_STYLE: None,
      LINE_STYLE: None,
      POLY_STYLE: None,
      BALLOON_STYLE: None,
    }
  }
}
impl KMLStyleT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLStyle<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ICON_STYLE = self.ICON_STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let LABEL_STYLE = self.LABEL_STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let LINE_STYLE = self.LINE_STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POLY_STYLE = self.POLY_STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let BALLOON_STYLE = self.BALLOON_STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    KMLStyle::create(_fbb, &KMLStyleArgs{
      ID,
      ICON_STYLE,
      LABEL_STYLE,
      LINE_STYLE,
      POLY_STYLE,
      BALLOON_STYLE,
    })
  }
}
pub enum KMLStyleMapPairOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Style map pair
pub struct KMLStyleMapPair<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLStyleMapPair<'a> {
  type Inner = KMLStyleMapPair<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLStyleMapPair<'a> {
  pub const VT_STATE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE_URL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLStyleMapPair { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLStyleMapPairArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLStyleMapPair<'bldr>> {
    let mut builder = KMLStyleMapPairBuilder::new(_fbb);
    if let Some(x) = args.STYLE_URL { builder.add_STYLE_URL(x); }
    builder.add_STATE(args.STATE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLStyleMapPairT {
    let STATE = self.STATE();
    let STYLE_URL = self.STYLE_URL().map(|x| {
      x.to_string()
    });
    KMLStyleMapPairT {
      STATE,
      STYLE_URL,
    }
  }

  /// State (normal or highlight)
  #[inline]
  pub fn STATE(&self) -> KMLStyleState {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLStyleState>(KMLStyleMapPair::VT_STATE, Some(KMLStyleState::NORMAL)).unwrap()}
  }
  /// Style URL or inline style ID
  #[inline]
  pub fn STYLE_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLStyleMapPair::VT_STYLE_URL, None)}
  }
}

impl flatbuffers::Verifiable for KMLStyleMapPair<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<KMLStyleState>("STATE", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STYLE_URL", Self::VT_STYLE_URL, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLStyleMapPairArgs<'a> {
    pub STATE: KMLStyleState,
    pub STYLE_URL: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KMLStyleMapPairArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLStyleMapPairArgs {
      STATE: KMLStyleState::NORMAL,
      STYLE_URL: None,
    }
  }
}

pub struct KMLStyleMapPairBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLStyleMapPairBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_STATE(&mut self, STATE: KMLStyleState) {
    self.fbb_.push_slot::<KMLStyleState>(KMLStyleMapPair::VT_STATE, STATE, KMLStyleState::NORMAL);
  }
  #[inline]
  pub fn add_STYLE_URL(&mut self, STYLE_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLStyleMapPair::VT_STYLE_URL, STYLE_URL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLStyleMapPairBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLStyleMapPairBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLStyleMapPair<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLStyleMapPair<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLStyleMapPair");
      ds.field("STATE", &self.STATE());
      ds.field("STYLE_URL", &self.STYLE_URL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLStyleMapPairT {
  pub STATE: KMLStyleState,
  pub STYLE_URL: Option<String>,
}
impl Default for KMLStyleMapPairT {
  fn default() -> Self {
    Self {
      STATE: KMLStyleState::NORMAL,
      STYLE_URL: None,
    }
  }
}
impl KMLStyleMapPairT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLStyleMapPair<'b>> {
    let STATE = self.STATE;
    let STYLE_URL = self.STYLE_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    KMLStyleMapPair::create(_fbb, &KMLStyleMapPairArgs{
      STATE,
      STYLE_URL,
    })
  }
}
pub enum KMLStyleMapOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Style map (normal/highlight pair)
pub struct KMLStyleMap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLStyleMap<'a> {
  type Inner = KMLStyleMap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLStyleMap<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PAIRS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLStyleMap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLStyleMapArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLStyleMap<'bldr>> {
    let mut builder = KMLStyleMapBuilder::new(_fbb);
    if let Some(x) = args.PAIRS { builder.add_PAIRS(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLStyleMapT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let PAIRS = self.PAIRS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLStyleMapT {
      ID,
      PAIRS,
    }
  }

  /// Style map identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLStyleMap::VT_ID, None)}
  }
  /// Pairs
  #[inline]
  pub fn PAIRS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMapPair<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMapPair>>>>(KMLStyleMap::VT_PAIRS, None)}
  }
}

impl flatbuffers::Verifiable for KMLStyleMap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLStyleMapPair>>>>("PAIRS", Self::VT_PAIRS, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLStyleMapArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PAIRS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMapPair<'a>>>>>,
}
impl<'a> Default for KMLStyleMapArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLStyleMapArgs {
      ID: None,
      PAIRS: None,
    }
  }
}

pub struct KMLStyleMapBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLStyleMapBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLStyleMap::VT_ID, ID);
  }
  #[inline]
  pub fn add_PAIRS(&mut self, PAIRS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLStyleMapPair<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLStyleMap::VT_PAIRS, PAIRS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLStyleMapBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLStyleMapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLStyleMap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLStyleMap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLStyleMap");
      ds.field("ID", &self.ID());
      ds.field("PAIRS", &self.PAIRS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLStyleMapT {
  pub ID: Option<String>,
  pub PAIRS: Option<Vec<KMLStyleMapPairT>>,
}
impl Default for KMLStyleMapT {
  fn default() -> Self {
    Self {
      ID: None,
      PAIRS: None,
    }
  }
}
impl KMLStyleMapT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLStyleMap<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PAIRS = self.PAIRS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KMLStyleMap::create(_fbb, &KMLStyleMapArgs{
      ID,
      PAIRS,
    })
  }
}
pub enum KMLPointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Point geometry
pub struct KMLPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLPoint<'a> {
  type Inner = KMLPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLPoint<'a> {
  pub const VT_COORDINATES: flatbuffers::VOffsetT = 4;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_EXTRUDE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLPointArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLPoint<'bldr>> {
    let mut builder = KMLPointBuilder::new(_fbb);
    if let Some(x) = args.COORDINATES { builder.add_COORDINATES(x); }
    builder.add_EXTRUDE(args.EXTRUDE);
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLPointT {
    let COORDINATES = self.COORDINATES().map(|x| {
      Box::new(x.unpack())
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    let EXTRUDE = self.EXTRUDE();
    KMLPointT {
      COORDINATES,
      ALTITUDE_MODE,
      EXTRUDE,
    }
  }

  /// Coordinate
  #[inline]
  pub fn COORDINATES(&self) -> Option<KMLCoordinate<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLCoordinate>>(KMLPoint::VT_COORDINATES, None)}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLPoint::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
  /// Whether to extrude to ground
  #[inline]
  pub fn EXTRUDE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPoint::VT_EXTRUDE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLCoordinate>>("COORDINATES", Self::VT_COORDINATES, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .visit_field::<bool>("EXTRUDE", Self::VT_EXTRUDE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLPointArgs<'a> {
    pub COORDINATES: Option<flatbuffers::WIPOffset<KMLCoordinate<'a>>>,
    pub ALTITUDE_MODE: KMLAltitudeMode,
    pub EXTRUDE: bool,
}
impl<'a> Default for KMLPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLPointArgs {
      COORDINATES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
    }
  }
}

pub struct KMLPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COORDINATES(&mut self, COORDINATES: flatbuffers::WIPOffset<KMLCoordinate<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLCoordinate>>(KMLPoint::VT_COORDINATES, COORDINATES);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLPoint::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn add_EXTRUDE(&mut self, EXTRUDE: bool) {
    self.fbb_.push_slot::<bool>(KMLPoint::VT_EXTRUDE, EXTRUDE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLPoint");
      ds.field("COORDINATES", &self.COORDINATES());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.field("EXTRUDE", &self.EXTRUDE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLPointT {
  pub COORDINATES: Option<Box<KMLCoordinateT>>,
  pub ALTITUDE_MODE: KMLAltitudeMode,
  pub EXTRUDE: bool,
}
impl Default for KMLPointT {
  fn default() -> Self {
    Self {
      COORDINATES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
    }
  }
}
impl KMLPointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLPoint<'b>> {
    let COORDINATES = self.COORDINATES.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    let EXTRUDE = self.EXTRUDE;
    KMLPoint::create(_fbb, &KMLPointArgs{
      COORDINATES,
      ALTITUDE_MODE,
      EXTRUDE,
    })
  }
}
pub enum KMLLineStringOffset {}
#[derive(Copy, Clone, PartialEq)]

/// LineString geometry
pub struct KMLLineString<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLLineString<'a> {
  type Inner = KMLLineString<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLLineString<'a> {
  pub const VT_COORDINATES: flatbuffers::VOffsetT = 4;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_EXTRUDE: flatbuffers::VOffsetT = 8;
  pub const VT_TESSELLATE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLLineString { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLLineStringArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLLineString<'bldr>> {
    let mut builder = KMLLineStringBuilder::new(_fbb);
    if let Some(x) = args.COORDINATES { builder.add_COORDINATES(x); }
    builder.add_TESSELLATE(args.TESSELLATE);
    builder.add_EXTRUDE(args.EXTRUDE);
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLLineStringT {
    let COORDINATES = self.COORDINATES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    let EXTRUDE = self.EXTRUDE();
    let TESSELLATE = self.TESSELLATE();
    KMLLineStringT {
      COORDINATES,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE,
    }
  }

  /// Coordinates
  #[inline]
  pub fn COORDINATES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate>>>>(KMLLineString::VT_COORDINATES, None)}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLLineString::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
  /// Whether to extrude to ground
  #[inline]
  pub fn EXTRUDE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLLineString::VT_EXTRUDE, Some(false)).unwrap()}
  }
  /// Whether to tessellate (follow terrain)
  #[inline]
  pub fn TESSELLATE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLLineString::VT_TESSELLATE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLLineString<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLCoordinate>>>>("COORDINATES", Self::VT_COORDINATES, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .visit_field::<bool>("EXTRUDE", Self::VT_EXTRUDE, false)?
     .visit_field::<bool>("TESSELLATE", Self::VT_TESSELLATE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLLineStringArgs<'a> {
    pub COORDINATES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate<'a>>>>>,
    pub ALTITUDE_MODE: KMLAltitudeMode,
    pub EXTRUDE: bool,
    pub TESSELLATE: bool,
}
impl<'a> Default for KMLLineStringArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLLineStringArgs {
      COORDINATES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
      TESSELLATE: false,
    }
  }
}

pub struct KMLLineStringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLLineStringBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COORDINATES(&mut self, COORDINATES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLCoordinate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLLineString::VT_COORDINATES, COORDINATES);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLLineString::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn add_EXTRUDE(&mut self, EXTRUDE: bool) {
    self.fbb_.push_slot::<bool>(KMLLineString::VT_EXTRUDE, EXTRUDE, false);
  }
  #[inline]
  pub fn add_TESSELLATE(&mut self, TESSELLATE: bool) {
    self.fbb_.push_slot::<bool>(KMLLineString::VT_TESSELLATE, TESSELLATE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLLineStringBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLLineStringBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLLineString<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLLineString<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLLineString");
      ds.field("COORDINATES", &self.COORDINATES());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.field("EXTRUDE", &self.EXTRUDE());
      ds.field("TESSELLATE", &self.TESSELLATE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLLineStringT {
  pub COORDINATES: Option<Vec<KMLCoordinateT>>,
  pub ALTITUDE_MODE: KMLAltitudeMode,
  pub EXTRUDE: bool,
  pub TESSELLATE: bool,
}
impl Default for KMLLineStringT {
  fn default() -> Self {
    Self {
      COORDINATES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
      TESSELLATE: false,
    }
  }
}
impl KMLLineStringT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLLineString<'b>> {
    let COORDINATES = self.COORDINATES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    let EXTRUDE = self.EXTRUDE;
    let TESSELLATE = self.TESSELLATE;
    KMLLineString::create(_fbb, &KMLLineStringArgs{
      COORDINATES,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE,
    })
  }
}
pub enum KMLLinearRingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// LinearRing geometry
pub struct KMLLinearRing<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLLinearRing<'a> {
  type Inner = KMLLinearRing<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLLinearRing<'a> {
  pub const VT_COORDINATES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLLinearRing { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLLinearRingArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLLinearRing<'bldr>> {
    let mut builder = KMLLinearRingBuilder::new(_fbb);
    if let Some(x) = args.COORDINATES { builder.add_COORDINATES(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLLinearRingT {
    let COORDINATES = self.COORDINATES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLLinearRingT {
      COORDINATES,
    }
  }

  /// Coordinates (first = last to close the ring)
  #[inline]
  pub fn COORDINATES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate>>>>(KMLLinearRing::VT_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for KMLLinearRing<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLCoordinate>>>>("COORDINATES", Self::VT_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLLinearRingArgs<'a> {
    pub COORDINATES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLCoordinate<'a>>>>>,
}
impl<'a> Default for KMLLinearRingArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLLinearRingArgs {
      COORDINATES: None,
    }
  }
}

pub struct KMLLinearRingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLLinearRingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COORDINATES(&mut self, COORDINATES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLCoordinate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLLinearRing::VT_COORDINATES, COORDINATES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLLinearRingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLLinearRingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLLinearRing<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLLinearRing<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLLinearRing");
      ds.field("COORDINATES", &self.COORDINATES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLLinearRingT {
  pub COORDINATES: Option<Vec<KMLCoordinateT>>,
}
impl Default for KMLLinearRingT {
  fn default() -> Self {
    Self {
      COORDINATES: None,
    }
  }
}
impl KMLLinearRingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLLinearRing<'b>> {
    let COORDINATES = self.COORDINATES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KMLLinearRing::create(_fbb, &KMLLinearRingArgs{
      COORDINATES,
    })
  }
}
pub enum KMLPolygonOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Polygon geometry
pub struct KMLPolygon<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLPolygon<'a> {
  type Inner = KMLPolygon<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLPolygon<'a> {
  pub const VT_OUTER_BOUNDARY: flatbuffers::VOffsetT = 4;
  pub const VT_INNER_BOUNDARIES: flatbuffers::VOffsetT = 6;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 8;
  pub const VT_EXTRUDE: flatbuffers::VOffsetT = 10;
  pub const VT_TESSELLATE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLPolygon { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLPolygonArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLPolygon<'bldr>> {
    let mut builder = KMLPolygonBuilder::new(_fbb);
    if let Some(x) = args.INNER_BOUNDARIES { builder.add_INNER_BOUNDARIES(x); }
    if let Some(x) = args.OUTER_BOUNDARY { builder.add_OUTER_BOUNDARY(x); }
    builder.add_TESSELLATE(args.TESSELLATE);
    builder.add_EXTRUDE(args.EXTRUDE);
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLPolygonT {
    let OUTER_BOUNDARY = self.OUTER_BOUNDARY().map(|x| {
      Box::new(x.unpack())
    });
    let INNER_BOUNDARIES = self.INNER_BOUNDARIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    let EXTRUDE = self.EXTRUDE();
    let TESSELLATE = self.TESSELLATE();
    KMLPolygonT {
      OUTER_BOUNDARY,
      INNER_BOUNDARIES,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE,
    }
  }

  /// Outer boundary
  #[inline]
  pub fn OUTER_BOUNDARY(&self) -> Option<KMLLinearRing<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLLinearRing>>(KMLPolygon::VT_OUTER_BOUNDARY, None)}
  }
  /// Inner boundaries (holes)
  #[inline]
  pub fn INNER_BOUNDARIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLinearRing<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLinearRing>>>>(KMLPolygon::VT_INNER_BOUNDARIES, None)}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLPolygon::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
  /// Whether to extrude to ground
  #[inline]
  pub fn EXTRUDE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPolygon::VT_EXTRUDE, Some(false)).unwrap()}
  }
  /// Whether to tessellate
  #[inline]
  pub fn TESSELLATE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPolygon::VT_TESSELLATE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLPolygon<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLLinearRing>>("OUTER_BOUNDARY", Self::VT_OUTER_BOUNDARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLLinearRing>>>>("INNER_BOUNDARIES", Self::VT_INNER_BOUNDARIES, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .visit_field::<bool>("EXTRUDE", Self::VT_EXTRUDE, false)?
     .visit_field::<bool>("TESSELLATE", Self::VT_TESSELLATE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLPolygonArgs<'a> {
    pub OUTER_BOUNDARY: Option<flatbuffers::WIPOffset<KMLLinearRing<'a>>>,
    pub INNER_BOUNDARIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLinearRing<'a>>>>>,
    pub ALTITUDE_MODE: KMLAltitudeMode,
    pub EXTRUDE: bool,
    pub TESSELLATE: bool,
}
impl<'a> Default for KMLPolygonArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLPolygonArgs {
      OUTER_BOUNDARY: None,
      INNER_BOUNDARIES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
      TESSELLATE: false,
    }
  }
}

pub struct KMLPolygonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLPolygonBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_OUTER_BOUNDARY(&mut self, OUTER_BOUNDARY: flatbuffers::WIPOffset<KMLLinearRing<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLLinearRing>>(KMLPolygon::VT_OUTER_BOUNDARY, OUTER_BOUNDARY);
  }
  #[inline]
  pub fn add_INNER_BOUNDARIES(&mut self, INNER_BOUNDARIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLLinearRing<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPolygon::VT_INNER_BOUNDARIES, INNER_BOUNDARIES);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLPolygon::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn add_EXTRUDE(&mut self, EXTRUDE: bool) {
    self.fbb_.push_slot::<bool>(KMLPolygon::VT_EXTRUDE, EXTRUDE, false);
  }
  #[inline]
  pub fn add_TESSELLATE(&mut self, TESSELLATE: bool) {
    self.fbb_.push_slot::<bool>(KMLPolygon::VT_TESSELLATE, TESSELLATE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLPolygonBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLPolygonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLPolygon<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLPolygon<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLPolygon");
      ds.field("OUTER_BOUNDARY", &self.OUTER_BOUNDARY());
      ds.field("INNER_BOUNDARIES", &self.INNER_BOUNDARIES());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.field("EXTRUDE", &self.EXTRUDE());
      ds.field("TESSELLATE", &self.TESSELLATE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLPolygonT {
  pub OUTER_BOUNDARY: Option<Box<KMLLinearRingT>>,
  pub INNER_BOUNDARIES: Option<Vec<KMLLinearRingT>>,
  pub ALTITUDE_MODE: KMLAltitudeMode,
  pub EXTRUDE: bool,
  pub TESSELLATE: bool,
}
impl Default for KMLPolygonT {
  fn default() -> Self {
    Self {
      OUTER_BOUNDARY: None,
      INNER_BOUNDARIES: None,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
      EXTRUDE: false,
      TESSELLATE: false,
    }
  }
}
impl KMLPolygonT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLPolygon<'b>> {
    let OUTER_BOUNDARY = self.OUTER_BOUNDARY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INNER_BOUNDARIES = self.INNER_BOUNDARIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    let EXTRUDE = self.EXTRUDE;
    let TESSELLATE = self.TESSELLATE;
    KMLPolygon::create(_fbb, &KMLPolygonArgs{
      OUTER_BOUNDARY,
      INNER_BOUNDARIES,
      ALTITUDE_MODE,
      EXTRUDE,
      TESSELLATE,
    })
  }
}
pub enum KMLMultiGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// MultiGeometry
pub struct KMLMultiGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLMultiGeometry<'a> {
  type Inner = KMLMultiGeometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLMultiGeometry<'a> {
  pub const VT_POINTS: flatbuffers::VOffsetT = 4;
  pub const VT_LINE_STRINGS: flatbuffers::VOffsetT = 6;
  pub const VT_POLYGONS: flatbuffers::VOffsetT = 8;
  pub const VT_MULTI_GEOMETRIES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLMultiGeometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLMultiGeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLMultiGeometry<'bldr>> {
    let mut builder = KMLMultiGeometryBuilder::new(_fbb);
    if let Some(x) = args.MULTI_GEOMETRIES { builder.add_MULTI_GEOMETRIES(x); }
    if let Some(x) = args.POLYGONS { builder.add_POLYGONS(x); }
    if let Some(x) = args.LINE_STRINGS { builder.add_LINE_STRINGS(x); }
    if let Some(x) = args.POINTS { builder.add_POINTS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLMultiGeometryT {
    let POINTS = self.POINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let LINE_STRINGS = self.LINE_STRINGS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let POLYGONS = self.POLYGONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let MULTI_GEOMETRIES = self.MULTI_GEOMETRIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLMultiGeometryT {
      POINTS,
      LINE_STRINGS,
      POLYGONS,
      MULTI_GEOMETRIES,
    }
  }

  /// Child points
  #[inline]
  pub fn POINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPoint>>>>(KMLMultiGeometry::VT_POINTS, None)}
  }
  /// Child line strings
  #[inline]
  pub fn LINE_STRINGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLineString<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLineString>>>>(KMLMultiGeometry::VT_LINE_STRINGS, None)}
  }
  /// Child polygons
  #[inline]
  pub fn POLYGONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPolygon<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPolygon>>>>(KMLMultiGeometry::VT_POLYGONS, None)}
  }
  /// Nested multi-geometries
  #[inline]
  pub fn MULTI_GEOMETRIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLMultiGeometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLMultiGeometry>>>>(KMLMultiGeometry::VT_MULTI_GEOMETRIES, None)}
  }
}

impl flatbuffers::Verifiable for KMLMultiGeometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLPoint>>>>("POINTS", Self::VT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLLineString>>>>("LINE_STRINGS", Self::VT_LINE_STRINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLPolygon>>>>("POLYGONS", Self::VT_POLYGONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLMultiGeometry>>>>("MULTI_GEOMETRIES", Self::VT_MULTI_GEOMETRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLMultiGeometryArgs<'a> {
    pub POINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPoint<'a>>>>>,
    pub LINE_STRINGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLLineString<'a>>>>>,
    pub POLYGONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPolygon<'a>>>>>,
    pub MULTI_GEOMETRIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLMultiGeometry<'a>>>>>,
}
impl<'a> Default for KMLMultiGeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLMultiGeometryArgs {
      POINTS: None,
      LINE_STRINGS: None,
      POLYGONS: None,
      MULTI_GEOMETRIES: None,
    }
  }
}

pub struct KMLMultiGeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLMultiGeometryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POINTS(&mut self, POINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLMultiGeometry::VT_POINTS, POINTS);
  }
  #[inline]
  pub fn add_LINE_STRINGS(&mut self, LINE_STRINGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLLineString<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLMultiGeometry::VT_LINE_STRINGS, LINE_STRINGS);
  }
  #[inline]
  pub fn add_POLYGONS(&mut self, POLYGONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLPolygon<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLMultiGeometry::VT_POLYGONS, POLYGONS);
  }
  #[inline]
  pub fn add_MULTI_GEOMETRIES(&mut self, MULTI_GEOMETRIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLMultiGeometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLMultiGeometry::VT_MULTI_GEOMETRIES, MULTI_GEOMETRIES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLMultiGeometryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLMultiGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLMultiGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLMultiGeometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLMultiGeometry");
      ds.field("POINTS", &self.POINTS());
      ds.field("LINE_STRINGS", &self.LINE_STRINGS());
      ds.field("POLYGONS", &self.POLYGONS());
      ds.field("MULTI_GEOMETRIES", &self.MULTI_GEOMETRIES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLMultiGeometryT {
  pub POINTS: Option<Vec<KMLPointT>>,
  pub LINE_STRINGS: Option<Vec<KMLLineStringT>>,
  pub POLYGONS: Option<Vec<KMLPolygonT>>,
  pub MULTI_GEOMETRIES: Option<Vec<KMLMultiGeometryT>>,
}
impl Default for KMLMultiGeometryT {
  fn default() -> Self {
    Self {
      POINTS: None,
      LINE_STRINGS: None,
      POLYGONS: None,
      MULTI_GEOMETRIES: None,
    }
  }
}
impl KMLMultiGeometryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLMultiGeometry<'b>> {
    let POINTS = self.POINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let LINE_STRINGS = self.LINE_STRINGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let POLYGONS = self.POLYGONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let MULTI_GEOMETRIES = self.MULTI_GEOMETRIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KMLMultiGeometry::create(_fbb, &KMLMultiGeometryArgs{
      POINTS,
      LINE_STRINGS,
      POLYGONS,
      MULTI_GEOMETRIES,
    })
  }
}
pub enum KMLTimeSpanOffset {}
#[derive(Copy, Clone, PartialEq)]

/// TimeSpan
pub struct KMLTimeSpan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLTimeSpan<'a> {
  type Inner = KMLTimeSpan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLTimeSpan<'a> {
  pub const VT_BEGIN: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLTimeSpan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLTimeSpanArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLTimeSpan<'bldr>> {
    let mut builder = KMLTimeSpanBuilder::new(_fbb);
    if let Some(x) = args.END { builder.add_END(x); }
    if let Some(x) = args.BEGIN { builder.add_BEGIN(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLTimeSpanT {
    let BEGIN = self.BEGIN().map(|x| {
      x.to_string()
    });
    let END = self.END().map(|x| {
      x.to_string()
    });
    KMLTimeSpanT {
      BEGIN,
      END,
    }
  }

  /// Begin time (ISO 8601)
  #[inline]
  pub fn BEGIN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLTimeSpan::VT_BEGIN, None)}
  }
  /// End time (ISO 8601)
  #[inline]
  pub fn END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLTimeSpan::VT_END, None)}
  }
}

impl flatbuffers::Verifiable for KMLTimeSpan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BEGIN", Self::VT_BEGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLTimeSpanArgs<'a> {
    pub BEGIN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KMLTimeSpanArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLTimeSpanArgs {
      BEGIN: None,
      END: None,
    }
  }
}

pub struct KMLTimeSpanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLTimeSpanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_BEGIN(&mut self, BEGIN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLTimeSpan::VT_BEGIN, BEGIN);
  }
  #[inline]
  pub fn add_END(&mut self, END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLTimeSpan::VT_END, END);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLTimeSpanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLTimeSpanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLTimeSpan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLTimeSpan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLTimeSpan");
      ds.field("BEGIN", &self.BEGIN());
      ds.field("END", &self.END());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLTimeSpanT {
  pub BEGIN: Option<String>,
  pub END: Option<String>,
}
impl Default for KMLTimeSpanT {
  fn default() -> Self {
    Self {
      BEGIN: None,
      END: None,
    }
  }
}
impl KMLTimeSpanT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLTimeSpan<'b>> {
    let BEGIN = self.BEGIN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END = self.END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    KMLTimeSpan::create(_fbb, &KMLTimeSpanArgs{
      BEGIN,
      END,
    })
  }
}
pub enum KMLTimeStampOffset {}
#[derive(Copy, Clone, PartialEq)]

/// TimeStamp
pub struct KMLTimeStamp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLTimeStamp<'a> {
  type Inner = KMLTimeStamp<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLTimeStamp<'a> {
  pub const VT_WHEN: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLTimeStamp { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLTimeStampArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLTimeStamp<'bldr>> {
    let mut builder = KMLTimeStampBuilder::new(_fbb);
    if let Some(x) = args.WHEN { builder.add_WHEN(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLTimeStampT {
    let WHEN = self.WHEN().map(|x| {
      x.to_string()
    });
    KMLTimeStampT {
      WHEN,
    }
  }

  /// Time (ISO 8601)
  #[inline]
  pub fn WHEN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLTimeStamp::VT_WHEN, None)}
  }
}

impl flatbuffers::Verifiable for KMLTimeStamp<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WHEN", Self::VT_WHEN, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLTimeStampArgs<'a> {
    pub WHEN: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KMLTimeStampArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLTimeStampArgs {
      WHEN: None,
    }
  }
}

pub struct KMLTimeStampBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLTimeStampBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_WHEN(&mut self, WHEN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLTimeStamp::VT_WHEN, WHEN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLTimeStampBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLTimeStampBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLTimeStamp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLTimeStamp<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLTimeStamp");
      ds.field("WHEN", &self.WHEN());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLTimeStampT {
  pub WHEN: Option<String>,
}
impl Default for KMLTimeStampT {
  fn default() -> Self {
    Self {
      WHEN: None,
    }
  }
}
impl KMLTimeStampT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLTimeStamp<'b>> {
    let WHEN = self.WHEN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    KMLTimeStamp::create(_fbb, &KMLTimeStampArgs{
      WHEN,
    })
  }
}
pub enum KMLDataOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Extended data key-value pair
pub struct KMLData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLData<'a> {
  type Inner = KMLData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLData<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DISPLAY_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLDataArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLData<'bldr>> {
    let mut builder = KMLDataBuilder::new(_fbb);
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    if let Some(x) = args.DISPLAY_NAME { builder.add_DISPLAY_NAME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> KMLDataT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DISPLAY_NAME = self.DISPLAY_NAME().map(|x| {
      x.to_string()
    });
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    KMLDataT {
      NAME,
      DISPLAY_NAME,
      VALUE,
    }
  }

  /// Data name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLData::VT_NAME, None)}
  }
  /// Display name
  #[inline]
  pub fn DISPLAY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLData::VT_DISPLAY_NAME, None)}
  }
  /// Data value
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLData::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for KMLData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DISPLAY_NAME", Self::VT_DISPLAY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLDataArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DISPLAY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for KMLDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLDataArgs {
      NAME: None,
      DISPLAY_NAME: None,
      VALUE: None,
    }
  }
}

pub struct KMLDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLData::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DISPLAY_NAME(&mut self, DISPLAY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLData::VT_DISPLAY_NAME, DISPLAY_NAME);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLData::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLData");
      ds.field("NAME", &self.NAME());
      ds.field("DISPLAY_NAME", &self.DISPLAY_NAME());
      ds.field("VALUE", &self.VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLDataT {
  pub NAME: Option<String>,
  pub DISPLAY_NAME: Option<String>,
  pub VALUE: Option<String>,
}
impl Default for KMLDataT {
  fn default() -> Self {
    Self {
      NAME: None,
      DISPLAY_NAME: None,
      VALUE: None,
    }
  }
}
impl KMLDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLData<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DISPLAY_NAME = self.DISPLAY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    KMLData::create(_fbb, &KMLDataArgs{
      NAME,
      DISPLAY_NAME,
      VALUE,
    })
  }
}
pub enum KMLNetworkLinkOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Network link
pub struct KMLNetworkLink<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLNetworkLink<'a> {
  type Inner = KMLNetworkLink<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLNetworkLink<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 6;
  pub const VT_HREF: flatbuffers::VOffsetT = 8;
  pub const VT_REFRESH_MODE: flatbuffers::VOffsetT = 10;
  pub const VT_REFRESH_INTERVAL: flatbuffers::VOffsetT = 12;
  pub const VT_VIEW_REFRESH_MODE: flatbuffers::VOffsetT = 14;
  pub const VT_VIEW_REFRESH_TIME: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLNetworkLink { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLNetworkLinkArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLNetworkLink<'bldr>> {
    let mut builder = KMLNetworkLinkBuilder::new(_fbb);
    builder.add_VIEW_REFRESH_TIME(args.VIEW_REFRESH_TIME);
    builder.add_REFRESH_INTERVAL(args.REFRESH_INTERVAL);
    if let Some(x) = args.HREF { builder.add_HREF(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_VIEW_REFRESH_MODE(args.VIEW_REFRESH_MODE);
    builder.add_REFRESH_MODE(args.REFRESH_MODE);
    builder.add_VISIBILITY(args.VISIBILITY);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLNetworkLinkT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let VISIBILITY = self.VISIBILITY();
    let HREF = self.HREF().map(|x| {
      x.to_string()
    });
    let REFRESH_MODE = self.REFRESH_MODE();
    let REFRESH_INTERVAL = self.REFRESH_INTERVAL();
    let VIEW_REFRESH_MODE = self.VIEW_REFRESH_MODE();
    let VIEW_REFRESH_TIME = self.VIEW_REFRESH_TIME();
    KMLNetworkLinkT {
      NAME,
      VISIBILITY,
      HREF,
      REFRESH_MODE,
      REFRESH_INTERVAL,
      VIEW_REFRESH_MODE,
      VIEW_REFRESH_TIME,
    }
  }

  /// Name of the network link
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLNetworkLink::VT_NAME, None)}
  }
  /// Whether the link is visible
  #[inline]
  pub fn VISIBILITY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLNetworkLink::VT_VISIBILITY, Some(false)).unwrap()}
  }
  /// Link URL
  #[inline]
  pub fn HREF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLNetworkLink::VT_HREF, None)}
  }
  /// Refresh mode
  #[inline]
  pub fn REFRESH_MODE(&self) -> KMLRefreshMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLRefreshMode>(KMLNetworkLink::VT_REFRESH_MODE, Some(KMLRefreshMode::ON_CHANGE)).unwrap()}
  }
  /// Refresh interval in seconds
  #[inline]
  pub fn REFRESH_INTERVAL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLNetworkLink::VT_REFRESH_INTERVAL, Some(0.0)).unwrap()}
  }
  /// View refresh mode
  #[inline]
  pub fn VIEW_REFRESH_MODE(&self) -> KMLViewRefreshMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLViewRefreshMode>(KMLNetworkLink::VT_VIEW_REFRESH_MODE, Some(KMLViewRefreshMode::NEVER)).unwrap()}
  }
  /// View refresh time in seconds
  #[inline]
  pub fn VIEW_REFRESH_TIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLNetworkLink::VT_VIEW_REFRESH_TIME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLNetworkLink<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<bool>("VISIBILITY", Self::VT_VISIBILITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HREF", Self::VT_HREF, false)?
     .visit_field::<KMLRefreshMode>("REFRESH_MODE", Self::VT_REFRESH_MODE, false)?
     .visit_field::<f64>("REFRESH_INTERVAL", Self::VT_REFRESH_INTERVAL, false)?
     .visit_field::<KMLViewRefreshMode>("VIEW_REFRESH_MODE", Self::VT_VIEW_REFRESH_MODE, false)?
     .visit_field::<f64>("VIEW_REFRESH_TIME", Self::VT_VIEW_REFRESH_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLNetworkLinkArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISIBILITY: bool,
    pub HREF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REFRESH_MODE: KMLRefreshMode,
    pub REFRESH_INTERVAL: f64,
    pub VIEW_REFRESH_MODE: KMLViewRefreshMode,
    pub VIEW_REFRESH_TIME: f64,
}
impl<'a> Default for KMLNetworkLinkArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLNetworkLinkArgs {
      NAME: None,
      VISIBILITY: false,
      HREF: None,
      REFRESH_MODE: KMLRefreshMode::ON_CHANGE,
      REFRESH_INTERVAL: 0.0,
      VIEW_REFRESH_MODE: KMLViewRefreshMode::NEVER,
      VIEW_REFRESH_TIME: 0.0,
    }
  }
}

pub struct KMLNetworkLinkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLNetworkLinkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLNetworkLink::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_VISIBILITY(&mut self, VISIBILITY: bool) {
    self.fbb_.push_slot::<bool>(KMLNetworkLink::VT_VISIBILITY, VISIBILITY, false);
  }
  #[inline]
  pub fn add_HREF(&mut self, HREF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLNetworkLink::VT_HREF, HREF);
  }
  #[inline]
  pub fn add_REFRESH_MODE(&mut self, REFRESH_MODE: KMLRefreshMode) {
    self.fbb_.push_slot::<KMLRefreshMode>(KMLNetworkLink::VT_REFRESH_MODE, REFRESH_MODE, KMLRefreshMode::ON_CHANGE);
  }
  #[inline]
  pub fn add_REFRESH_INTERVAL(&mut self, REFRESH_INTERVAL: f64) {
    self.fbb_.push_slot::<f64>(KMLNetworkLink::VT_REFRESH_INTERVAL, REFRESH_INTERVAL, 0.0);
  }
  #[inline]
  pub fn add_VIEW_REFRESH_MODE(&mut self, VIEW_REFRESH_MODE: KMLViewRefreshMode) {
    self.fbb_.push_slot::<KMLViewRefreshMode>(KMLNetworkLink::VT_VIEW_REFRESH_MODE, VIEW_REFRESH_MODE, KMLViewRefreshMode::NEVER);
  }
  #[inline]
  pub fn add_VIEW_REFRESH_TIME(&mut self, VIEW_REFRESH_TIME: f64) {
    self.fbb_.push_slot::<f64>(KMLNetworkLink::VT_VIEW_REFRESH_TIME, VIEW_REFRESH_TIME, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLNetworkLinkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLNetworkLinkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLNetworkLink<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLNetworkLink<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLNetworkLink");
      ds.field("NAME", &self.NAME());
      ds.field("VISIBILITY", &self.VISIBILITY());
      ds.field("HREF", &self.HREF());
      ds.field("REFRESH_MODE", &self.REFRESH_MODE());
      ds.field("REFRESH_INTERVAL", &self.REFRESH_INTERVAL());
      ds.field("VIEW_REFRESH_MODE", &self.VIEW_REFRESH_MODE());
      ds.field("VIEW_REFRESH_TIME", &self.VIEW_REFRESH_TIME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLNetworkLinkT {
  pub NAME: Option<String>,
  pub VISIBILITY: bool,
  pub HREF: Option<String>,
  pub REFRESH_MODE: KMLRefreshMode,
  pub REFRESH_INTERVAL: f64,
  pub VIEW_REFRESH_MODE: KMLViewRefreshMode,
  pub VIEW_REFRESH_TIME: f64,
}
impl Default for KMLNetworkLinkT {
  fn default() -> Self {
    Self {
      NAME: None,
      VISIBILITY: false,
      HREF: None,
      REFRESH_MODE: KMLRefreshMode::ON_CHANGE,
      REFRESH_INTERVAL: 0.0,
      VIEW_REFRESH_MODE: KMLViewRefreshMode::NEVER,
      VIEW_REFRESH_TIME: 0.0,
    }
  }
}
impl KMLNetworkLinkT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLNetworkLink<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISIBILITY = self.VISIBILITY;
    let HREF = self.HREF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REFRESH_MODE = self.REFRESH_MODE;
    let REFRESH_INTERVAL = self.REFRESH_INTERVAL;
    let VIEW_REFRESH_MODE = self.VIEW_REFRESH_MODE;
    let VIEW_REFRESH_TIME = self.VIEW_REFRESH_TIME;
    KMLNetworkLink::create(_fbb, &KMLNetworkLinkArgs{
      NAME,
      VISIBILITY,
      HREF,
      REFRESH_MODE,
      REFRESH_INTERVAL,
      VIEW_REFRESH_MODE,
      VIEW_REFRESH_TIME,
    })
  }
}
pub enum KMLGroundOverlayOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ground overlay
pub struct KMLGroundOverlay<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLGroundOverlay<'a> {
  type Inner = KMLGroundOverlay<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLGroundOverlay<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 8;
  pub const VT_ICON_HREF: flatbuffers::VOffsetT = 10;
  pub const VT_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_NORTH: flatbuffers::VOffsetT = 14;
  pub const VT_SOUTH: flatbuffers::VOffsetT = 16;
  pub const VT_EAST: flatbuffers::VOffsetT = 18;
  pub const VT_WEST: flatbuffers::VOffsetT = 20;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 22;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 24;
  pub const VT_ALTITUDE_MODE: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLGroundOverlay { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLGroundOverlayArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLGroundOverlay<'bldr>> {
    let mut builder = KMLGroundOverlayBuilder::new(_fbb);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_ROTATION(args.ROTATION);
    builder.add_WEST(args.WEST);
    builder.add_EAST(args.EAST);
    builder.add_SOUTH(args.SOUTH);
    builder.add_NORTH(args.NORTH);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    if let Some(x) = args.ICON_HREF { builder.add_ICON_HREF(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_ALTITUDE_MODE(args.ALTITUDE_MODE);
    builder.add_VISIBILITY(args.VISIBILITY);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLGroundOverlayT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let VISIBILITY = self.VISIBILITY();
    let ICON_HREF = self.ICON_HREF().map(|x| {
      x.to_string()
    });
    let COLOR = self.COLOR().map(|x| {
      x.to_string()
    });
    let NORTH = self.NORTH();
    let SOUTH = self.SOUTH();
    let EAST = self.EAST();
    let WEST = self.WEST();
    let ROTATION = self.ROTATION();
    let ALTITUDE = self.ALTITUDE();
    let ALTITUDE_MODE = self.ALTITUDE_MODE();
    KMLGroundOverlayT {
      NAME,
      DESCRIPTION,
      VISIBILITY,
      ICON_HREF,
      COLOR,
      NORTH,
      SOUTH,
      EAST,
      WEST,
      ROTATION,
      ALTITUDE,
      ALTITUDE_MODE,
    }
  }

  /// Name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLGroundOverlay::VT_NAME, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLGroundOverlay::VT_DESCRIPTION, None)}
  }
  /// Visibility
  #[inline]
  pub fn VISIBILITY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLGroundOverlay::VT_VISIBILITY, Some(false)).unwrap()}
  }
  /// Icon/image URL
  #[inline]
  pub fn ICON_HREF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLGroundOverlay::VT_ICON_HREF, None)}
  }
  /// Color in aabbggrr hex format
  #[inline]
  pub fn COLOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLGroundOverlay::VT_COLOR, None)}
  }
  /// North latitude of bounding box
  #[inline]
  pub fn NORTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_NORTH, Some(0.0)).unwrap()}
  }
  /// South latitude of bounding box
  #[inline]
  pub fn SOUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_SOUTH, Some(0.0)).unwrap()}
  }
  /// East longitude of bounding box
  #[inline]
  pub fn EAST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_EAST, Some(0.0)).unwrap()}
  }
  /// West longitude of bounding box
  #[inline]
  pub fn WEST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_WEST, Some(0.0)).unwrap()}
  }
  /// Rotation in degrees
  #[inline]
  pub fn ROTATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_ROTATION, Some(0.0)).unwrap()}
  }
  /// Altitude in meters
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(KMLGroundOverlay::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude mode
  #[inline]
  pub fn ALTITUDE_MODE(&self) -> KMLAltitudeMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KMLAltitudeMode>(KMLGroundOverlay::VT_ALTITUDE_MODE, Some(KMLAltitudeMode::CLAMP_TO_GROUND)).unwrap()}
  }
}

impl flatbuffers::Verifiable for KMLGroundOverlay<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("VISIBILITY", Self::VT_VISIBILITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ICON_HREF", Self::VT_ICON_HREF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<f64>("NORTH", Self::VT_NORTH, false)?
     .visit_field::<f64>("SOUTH", Self::VT_SOUTH, false)?
     .visit_field::<f64>("EAST", Self::VT_EAST, false)?
     .visit_field::<f64>("WEST", Self::VT_WEST, false)?
     .visit_field::<f64>("ROTATION", Self::VT_ROTATION, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<KMLAltitudeMode>("ALTITUDE_MODE", Self::VT_ALTITUDE_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLGroundOverlayArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISIBILITY: bool,
    pub ICON_HREF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NORTH: f64,
    pub SOUTH: f64,
    pub EAST: f64,
    pub WEST: f64,
    pub ROTATION: f64,
    pub ALTITUDE: f64,
    pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl<'a> Default for KMLGroundOverlayArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLGroundOverlayArgs {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      ICON_HREF: None,
      COLOR: None,
      NORTH: 0.0,
      SOUTH: 0.0,
      EAST: 0.0,
      WEST: 0.0,
      ROTATION: 0.0,
      ALTITUDE: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}

pub struct KMLGroundOverlayBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLGroundOverlayBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLGroundOverlay::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLGroundOverlay::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_VISIBILITY(&mut self, VISIBILITY: bool) {
    self.fbb_.push_slot::<bool>(KMLGroundOverlay::VT_VISIBILITY, VISIBILITY, false);
  }
  #[inline]
  pub fn add_ICON_HREF(&mut self, ICON_HREF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLGroundOverlay::VT_ICON_HREF, ICON_HREF);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLGroundOverlay::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_NORTH(&mut self, NORTH: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_NORTH, NORTH, 0.0);
  }
  #[inline]
  pub fn add_SOUTH(&mut self, SOUTH: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_SOUTH, SOUTH, 0.0);
  }
  #[inline]
  pub fn add_EAST(&mut self, EAST: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_EAST, EAST, 0.0);
  }
  #[inline]
  pub fn add_WEST(&mut self, WEST: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_WEST, WEST, 0.0);
  }
  #[inline]
  pub fn add_ROTATION(&mut self, ROTATION: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_ROTATION, ROTATION, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(KMLGroundOverlay::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE_MODE(&mut self, ALTITUDE_MODE: KMLAltitudeMode) {
    self.fbb_.push_slot::<KMLAltitudeMode>(KMLGroundOverlay::VT_ALTITUDE_MODE, ALTITUDE_MODE, KMLAltitudeMode::CLAMP_TO_GROUND);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLGroundOverlayBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLGroundOverlayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLGroundOverlay<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLGroundOverlay<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLGroundOverlay");
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("VISIBILITY", &self.VISIBILITY());
      ds.field("ICON_HREF", &self.ICON_HREF());
      ds.field("COLOR", &self.COLOR());
      ds.field("NORTH", &self.NORTH());
      ds.field("SOUTH", &self.SOUTH());
      ds.field("EAST", &self.EAST());
      ds.field("WEST", &self.WEST());
      ds.field("ROTATION", &self.ROTATION());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("ALTITUDE_MODE", &self.ALTITUDE_MODE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLGroundOverlayT {
  pub NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub VISIBILITY: bool,
  pub ICON_HREF: Option<String>,
  pub COLOR: Option<String>,
  pub NORTH: f64,
  pub SOUTH: f64,
  pub EAST: f64,
  pub WEST: f64,
  pub ROTATION: f64,
  pub ALTITUDE: f64,
  pub ALTITUDE_MODE: KMLAltitudeMode,
}
impl Default for KMLGroundOverlayT {
  fn default() -> Self {
    Self {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      ICON_HREF: None,
      COLOR: None,
      NORTH: 0.0,
      SOUTH: 0.0,
      EAST: 0.0,
      WEST: 0.0,
      ROTATION: 0.0,
      ALTITUDE: 0.0,
      ALTITUDE_MODE: KMLAltitudeMode::CLAMP_TO_GROUND,
    }
  }
}
impl KMLGroundOverlayT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLGroundOverlay<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISIBILITY = self.VISIBILITY;
    let ICON_HREF = self.ICON_HREF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLOR = self.COLOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NORTH = self.NORTH;
    let SOUTH = self.SOUTH;
    let EAST = self.EAST;
    let WEST = self.WEST;
    let ROTATION = self.ROTATION;
    let ALTITUDE = self.ALTITUDE;
    let ALTITUDE_MODE = self.ALTITUDE_MODE;
    KMLGroundOverlay::create(_fbb, &KMLGroundOverlayArgs{
      NAME,
      DESCRIPTION,
      VISIBILITY,
      ICON_HREF,
      COLOR,
      NORTH,
      SOUTH,
      EAST,
      WEST,
      ROTATION,
      ALTITUDE,
      ALTITUDE_MODE,
    })
  }
}
pub enum KMLPlacemarkOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Placemark feature
pub struct KMLPlacemark<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLPlacemark<'a> {
  type Inner = KMLPlacemark<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLPlacemark<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 8;
  pub const VT_STYLE_URL: flatbuffers::VOffsetT = 10;
  pub const VT_STYLE: flatbuffers::VOffsetT = 12;
  pub const VT_SNIPPET: flatbuffers::VOffsetT = 14;
  pub const VT_POINT: flatbuffers::VOffsetT = 16;
  pub const VT_LINE_STRING: flatbuffers::VOffsetT = 18;
  pub const VT_POLYGON: flatbuffers::VOffsetT = 20;
  pub const VT_MULTI_GEOMETRY: flatbuffers::VOffsetT = 22;
  pub const VT_LOOK_AT: flatbuffers::VOffsetT = 24;
  pub const VT_CAMERA: flatbuffers::VOffsetT = 26;
  pub const VT_TIME_SPAN: flatbuffers::VOffsetT = 28;
  pub const VT_TIME_STAMP: flatbuffers::VOffsetT = 30;
  pub const VT_EXTENDED_DATA: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLPlacemark { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLPlacemarkArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLPlacemark<'bldr>> {
    let mut builder = KMLPlacemarkBuilder::new(_fbb);
    if let Some(x) = args.EXTENDED_DATA { builder.add_EXTENDED_DATA(x); }
    if let Some(x) = args.TIME_STAMP { builder.add_TIME_STAMP(x); }
    if let Some(x) = args.TIME_SPAN { builder.add_TIME_SPAN(x); }
    if let Some(x) = args.CAMERA { builder.add_CAMERA(x); }
    if let Some(x) = args.LOOK_AT { builder.add_LOOK_AT(x); }
    if let Some(x) = args.MULTI_GEOMETRY { builder.add_MULTI_GEOMETRY(x); }
    if let Some(x) = args.POLYGON { builder.add_POLYGON(x); }
    if let Some(x) = args.LINE_STRING { builder.add_LINE_STRING(x); }
    if let Some(x) = args.POINT { builder.add_POINT(x); }
    if let Some(x) = args.SNIPPET { builder.add_SNIPPET(x); }
    if let Some(x) = args.STYLE { builder.add_STYLE(x); }
    if let Some(x) = args.STYLE_URL { builder.add_STYLE_URL(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_VISIBILITY(args.VISIBILITY);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLPlacemarkT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let VISIBILITY = self.VISIBILITY();
    let STYLE_URL = self.STYLE_URL().map(|x| {
      x.to_string()
    });
    let STYLE = self.STYLE().map(|x| {
      Box::new(x.unpack())
    });
    let SNIPPET = self.SNIPPET().map(|x| {
      x.to_string()
    });
    let POINT = self.POINT().map(|x| {
      Box::new(x.unpack())
    });
    let LINE_STRING = self.LINE_STRING().map(|x| {
      Box::new(x.unpack())
    });
    let POLYGON = self.POLYGON().map(|x| {
      Box::new(x.unpack())
    });
    let MULTI_GEOMETRY = self.MULTI_GEOMETRY().map(|x| {
      Box::new(x.unpack())
    });
    let LOOK_AT = self.LOOK_AT().map(|x| {
      Box::new(x.unpack())
    });
    let CAMERA = self.CAMERA().map(|x| {
      Box::new(x.unpack())
    });
    let TIME_SPAN = self.TIME_SPAN().map(|x| {
      Box::new(x.unpack())
    });
    let TIME_STAMP = self.TIME_STAMP().map(|x| {
      Box::new(x.unpack())
    });
    let EXTENDED_DATA = self.EXTENDED_DATA().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLPlacemarkT {
      NAME,
      DESCRIPTION,
      VISIBILITY,
      STYLE_URL,
      STYLE,
      SNIPPET,
      POINT,
      LINE_STRING,
      POLYGON,
      MULTI_GEOMETRY,
      LOOK_AT,
      CAMERA,
      TIME_SPAN,
      TIME_STAMP,
      EXTENDED_DATA,
    }
  }

  /// Placemark name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLPlacemark::VT_NAME, None)}
  }
  /// Description (may contain HTML)
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLPlacemark::VT_DESCRIPTION, None)}
  }
  /// Visibility flag
  #[inline]
  pub fn VISIBILITY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLPlacemark::VT_VISIBILITY, Some(false)).unwrap()}
  }
  /// Style URL reference
  #[inline]
  pub fn STYLE_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLPlacemark::VT_STYLE_URL, None)}
  }
  /// Inline style
  #[inline]
  pub fn STYLE(&self) -> Option<KMLStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLStyle>>(KMLPlacemark::VT_STYLE, None)}
  }
  /// Snippet (short description)
  #[inline]
  pub fn SNIPPET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLPlacemark::VT_SNIPPET, None)}
  }
  /// Point geometry
  #[inline]
  pub fn POINT(&self) -> Option<KMLPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLPoint>>(KMLPlacemark::VT_POINT, None)}
  }
  /// LineString geometry
  #[inline]
  pub fn LINE_STRING(&self) -> Option<KMLLineString<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLLineString>>(KMLPlacemark::VT_LINE_STRING, None)}
  }
  /// Polygon geometry
  #[inline]
  pub fn POLYGON(&self) -> Option<KMLPolygon<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLPolygon>>(KMLPlacemark::VT_POLYGON, None)}
  }
  /// MultiGeometry
  #[inline]
  pub fn MULTI_GEOMETRY(&self) -> Option<KMLMultiGeometry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLMultiGeometry>>(KMLPlacemark::VT_MULTI_GEOMETRY, None)}
  }
  /// LookAt viewpoint
  #[inline]
  pub fn LOOK_AT(&self) -> Option<KMLLookAt<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLLookAt>>(KMLPlacemark::VT_LOOK_AT, None)}
  }
  /// Camera viewpoint
  #[inline]
  pub fn CAMERA(&self) -> Option<KMLCamera<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLCamera>>(KMLPlacemark::VT_CAMERA, None)}
  }
  /// TimeSpan
  #[inline]
  pub fn TIME_SPAN(&self) -> Option<KMLTimeSpan<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLTimeSpan>>(KMLPlacemark::VT_TIME_SPAN, None)}
  }
  /// TimeStamp
  #[inline]
  pub fn TIME_STAMP(&self) -> Option<KMLTimeStamp<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<KMLTimeStamp>>(KMLPlacemark::VT_TIME_STAMP, None)}
  }
  /// Extended data
  #[inline]
  pub fn EXTENDED_DATA(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLData>>>>(KMLPlacemark::VT_EXTENDED_DATA, None)}
  }
}

impl flatbuffers::Verifiable for KMLPlacemark<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("VISIBILITY", Self::VT_VISIBILITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STYLE_URL", Self::VT_STYLE_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLStyle>>("STYLE", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SNIPPET", Self::VT_SNIPPET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLPoint>>("POINT", Self::VT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLLineString>>("LINE_STRING", Self::VT_LINE_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLPolygon>>("POLYGON", Self::VT_POLYGON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLMultiGeometry>>("MULTI_GEOMETRY", Self::VT_MULTI_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLLookAt>>("LOOK_AT", Self::VT_LOOK_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLCamera>>("CAMERA", Self::VT_CAMERA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLTimeSpan>>("TIME_SPAN", Self::VT_TIME_SPAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<KMLTimeStamp>>("TIME_STAMP", Self::VT_TIME_STAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLData>>>>("EXTENDED_DATA", Self::VT_EXTENDED_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLPlacemarkArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISIBILITY: bool,
    pub STYLE_URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STYLE: Option<flatbuffers::WIPOffset<KMLStyle<'a>>>,
    pub SNIPPET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POINT: Option<flatbuffers::WIPOffset<KMLPoint<'a>>>,
    pub LINE_STRING: Option<flatbuffers::WIPOffset<KMLLineString<'a>>>,
    pub POLYGON: Option<flatbuffers::WIPOffset<KMLPolygon<'a>>>,
    pub MULTI_GEOMETRY: Option<flatbuffers::WIPOffset<KMLMultiGeometry<'a>>>,
    pub LOOK_AT: Option<flatbuffers::WIPOffset<KMLLookAt<'a>>>,
    pub CAMERA: Option<flatbuffers::WIPOffset<KMLCamera<'a>>>,
    pub TIME_SPAN: Option<flatbuffers::WIPOffset<KMLTimeSpan<'a>>>,
    pub TIME_STAMP: Option<flatbuffers::WIPOffset<KMLTimeStamp<'a>>>,
    pub EXTENDED_DATA: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLData<'a>>>>>,
}
impl<'a> Default for KMLPlacemarkArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLPlacemarkArgs {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      STYLE_URL: None,
      STYLE: None,
      SNIPPET: None,
      POINT: None,
      LINE_STRING: None,
      POLYGON: None,
      MULTI_GEOMETRY: None,
      LOOK_AT: None,
      CAMERA: None,
      TIME_SPAN: None,
      TIME_STAMP: None,
      EXTENDED_DATA: None,
    }
  }
}

pub struct KMLPlacemarkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLPlacemarkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPlacemark::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPlacemark::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_VISIBILITY(&mut self, VISIBILITY: bool) {
    self.fbb_.push_slot::<bool>(KMLPlacemark::VT_VISIBILITY, VISIBILITY, false);
  }
  #[inline]
  pub fn add_STYLE_URL(&mut self, STYLE_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPlacemark::VT_STYLE_URL, STYLE_URL);
  }
  #[inline]
  pub fn add_STYLE(&mut self, STYLE: flatbuffers::WIPOffset<KMLStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLStyle>>(KMLPlacemark::VT_STYLE, STYLE);
  }
  #[inline]
  pub fn add_SNIPPET(&mut self, SNIPPET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPlacemark::VT_SNIPPET, SNIPPET);
  }
  #[inline]
  pub fn add_POINT(&mut self, POINT: flatbuffers::WIPOffset<KMLPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLPoint>>(KMLPlacemark::VT_POINT, POINT);
  }
  #[inline]
  pub fn add_LINE_STRING(&mut self, LINE_STRING: flatbuffers::WIPOffset<KMLLineString<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLLineString>>(KMLPlacemark::VT_LINE_STRING, LINE_STRING);
  }
  #[inline]
  pub fn add_POLYGON(&mut self, POLYGON: flatbuffers::WIPOffset<KMLPolygon<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLPolygon>>(KMLPlacemark::VT_POLYGON, POLYGON);
  }
  #[inline]
  pub fn add_MULTI_GEOMETRY(&mut self, MULTI_GEOMETRY: flatbuffers::WIPOffset<KMLMultiGeometry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLMultiGeometry>>(KMLPlacemark::VT_MULTI_GEOMETRY, MULTI_GEOMETRY);
  }
  #[inline]
  pub fn add_LOOK_AT(&mut self, LOOK_AT: flatbuffers::WIPOffset<KMLLookAt<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLLookAt>>(KMLPlacemark::VT_LOOK_AT, LOOK_AT);
  }
  #[inline]
  pub fn add_CAMERA(&mut self, CAMERA: flatbuffers::WIPOffset<KMLCamera<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLCamera>>(KMLPlacemark::VT_CAMERA, CAMERA);
  }
  #[inline]
  pub fn add_TIME_SPAN(&mut self, TIME_SPAN: flatbuffers::WIPOffset<KMLTimeSpan<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLTimeSpan>>(KMLPlacemark::VT_TIME_SPAN, TIME_SPAN);
  }
  #[inline]
  pub fn add_TIME_STAMP(&mut self, TIME_STAMP: flatbuffers::WIPOffset<KMLTimeStamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<KMLTimeStamp>>(KMLPlacemark::VT_TIME_STAMP, TIME_STAMP);
  }
  #[inline]
  pub fn add_EXTENDED_DATA(&mut self, EXTENDED_DATA: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLPlacemark::VT_EXTENDED_DATA, EXTENDED_DATA);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLPlacemarkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLPlacemarkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLPlacemark<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLPlacemark<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLPlacemark");
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("VISIBILITY", &self.VISIBILITY());
      ds.field("STYLE_URL", &self.STYLE_URL());
      ds.field("STYLE", &self.STYLE());
      ds.field("SNIPPET", &self.SNIPPET());
      ds.field("POINT", &self.POINT());
      ds.field("LINE_STRING", &self.LINE_STRING());
      ds.field("POLYGON", &self.POLYGON());
      ds.field("MULTI_GEOMETRY", &self.MULTI_GEOMETRY());
      ds.field("LOOK_AT", &self.LOOK_AT());
      ds.field("CAMERA", &self.CAMERA());
      ds.field("TIME_SPAN", &self.TIME_SPAN());
      ds.field("TIME_STAMP", &self.TIME_STAMP());
      ds.field("EXTENDED_DATA", &self.EXTENDED_DATA());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLPlacemarkT {
  pub NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub VISIBILITY: bool,
  pub STYLE_URL: Option<String>,
  pub STYLE: Option<Box<KMLStyleT>>,
  pub SNIPPET: Option<String>,
  pub POINT: Option<Box<KMLPointT>>,
  pub LINE_STRING: Option<Box<KMLLineStringT>>,
  pub POLYGON: Option<Box<KMLPolygonT>>,
  pub MULTI_GEOMETRY: Option<Box<KMLMultiGeometryT>>,
  pub LOOK_AT: Option<Box<KMLLookAtT>>,
  pub CAMERA: Option<Box<KMLCameraT>>,
  pub TIME_SPAN: Option<Box<KMLTimeSpanT>>,
  pub TIME_STAMP: Option<Box<KMLTimeStampT>>,
  pub EXTENDED_DATA: Option<Vec<KMLDataT>>,
}
impl Default for KMLPlacemarkT {
  fn default() -> Self {
    Self {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      STYLE_URL: None,
      STYLE: None,
      SNIPPET: None,
      POINT: None,
      LINE_STRING: None,
      POLYGON: None,
      MULTI_GEOMETRY: None,
      LOOK_AT: None,
      CAMERA: None,
      TIME_SPAN: None,
      TIME_STAMP: None,
      EXTENDED_DATA: None,
    }
  }
}
impl KMLPlacemarkT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLPlacemark<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISIBILITY = self.VISIBILITY;
    let STYLE_URL = self.STYLE_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STYLE = self.STYLE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SNIPPET = self.SNIPPET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POINT = self.POINT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let LINE_STRING = self.LINE_STRING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POLYGON = self.POLYGON.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let MULTI_GEOMETRY = self.MULTI_GEOMETRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let LOOK_AT = self.LOOK_AT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CAMERA = self.CAMERA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let TIME_SPAN = self.TIME_SPAN.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let TIME_STAMP = self.TIME_STAMP.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let EXTENDED_DATA = self.EXTENDED_DATA.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KMLPlacemark::create(_fbb, &KMLPlacemarkArgs{
      NAME,
      DESCRIPTION,
      VISIBILITY,
      STYLE_URL,
      STYLE,
      SNIPPET,
      POINT,
      LINE_STRING,
      POLYGON,
      MULTI_GEOMETRY,
      LOOK_AT,
      CAMERA,
      TIME_SPAN,
      TIME_STAMP,
      EXTENDED_DATA,
    })
  }
}
pub enum KMLFolderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Folder container
pub struct KMLFolder<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KMLFolder<'a> {
  type Inner = KMLFolder<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KMLFolder<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 8;
  pub const VT_OPEN: flatbuffers::VOffsetT = 10;
  pub const VT_PLACEMARKS: flatbuffers::VOffsetT = 12;
  pub const VT_FOLDERS: flatbuffers::VOffsetT = 14;
  pub const VT_NETWORK_LINKS: flatbuffers::VOffsetT = 16;
  pub const VT_GROUND_OVERLAYS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KMLFolder { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLFolderArgs<'args>
  ) -> flatbuffers::WIPOffset<KMLFolder<'bldr>> {
    let mut builder = KMLFolderBuilder::new(_fbb);
    if let Some(x) = args.GROUND_OVERLAYS { builder.add_GROUND_OVERLAYS(x); }
    if let Some(x) = args.NETWORK_LINKS { builder.add_NETWORK_LINKS(x); }
    if let Some(x) = args.FOLDERS { builder.add_FOLDERS(x); }
    if let Some(x) = args.PLACEMARKS { builder.add_PLACEMARKS(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_OPEN(args.OPEN);
    builder.add_VISIBILITY(args.VISIBILITY);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLFolderT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let VISIBILITY = self.VISIBILITY();
    let OPEN = self.OPEN();
    let PLACEMARKS = self.PLACEMARKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let FOLDERS = self.FOLDERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NETWORK_LINKS = self.NETWORK_LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let GROUND_OVERLAYS = self.GROUND_OVERLAYS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLFolderT {
      NAME,
      DESCRIPTION,
      VISIBILITY,
      OPEN,
      PLACEMARKS,
      FOLDERS,
      NETWORK_LINKS,
      GROUND_OVERLAYS,
    }
  }

  /// Folder name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLFolder::VT_NAME, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KMLFolder::VT_DESCRIPTION, None)}
  }
  /// Visibility flag
  #[inline]
  pub fn VISIBILITY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLFolder::VT_VISIBILITY, Some(false)).unwrap()}
  }
  /// Whether folder is open in tree view
  #[inline]
  pub fn OPEN(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KMLFolder::VT_OPEN, Some(false)).unwrap()}
  }
  /// Placemarks in this folder
  #[inline]
  pub fn PLACEMARKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark>>>>(KMLFolder::VT_PLACEMARKS, None)}
  }
  /// Sub-folders
  #[inline]
  pub fn FOLDERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder>>>>(KMLFolder::VT_FOLDERS, None)}
  }
  /// Network links
  #[inline]
  pub fn NETWORK_LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink>>>>(KMLFolder::VT_NETWORK_LINKS, None)}
  }
  /// Ground overlays
  #[inline]
  pub fn GROUND_OVERLAYS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay>>>>(KMLFolder::VT_GROUND_OVERLAYS, None)}
  }
}

impl flatbuffers::Verifiable for KMLFolder<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("VISIBILITY", Self::VT_VISIBILITY, false)?
     .visit_field::<bool>("OPEN", Self::VT_OPEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLPlacemark>>>>("PLACEMARKS", Self::VT_PLACEMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLFolder>>>>("FOLDERS", Self::VT_FOLDERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLNetworkLink>>>>("NETWORK_LINKS", Self::VT_NETWORK_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLGroundOverlay>>>>("GROUND_OVERLAYS", Self::VT_GROUND_OVERLAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLFolderArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISIBILITY: bool,
    pub OPEN: bool,
    pub PLACEMARKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark<'a>>>>>,
    pub FOLDERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder<'a>>>>>,
    pub NETWORK_LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink<'a>>>>>,
    pub GROUND_OVERLAYS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay<'a>>>>>,
}
impl<'a> Default for KMLFolderArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLFolderArgs {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      OPEN: false,
      PLACEMARKS: None,
      FOLDERS: None,
      NETWORK_LINKS: None,
      GROUND_OVERLAYS: None,
    }
  }
}

pub struct KMLFolderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLFolderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_VISIBILITY(&mut self, VISIBILITY: bool) {
    self.fbb_.push_slot::<bool>(KMLFolder::VT_VISIBILITY, VISIBILITY, false);
  }
  #[inline]
  pub fn add_OPEN(&mut self, OPEN: bool) {
    self.fbb_.push_slot::<bool>(KMLFolder::VT_OPEN, OPEN, false);
  }
  #[inline]
  pub fn add_PLACEMARKS(&mut self, PLACEMARKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLPlacemark<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_PLACEMARKS, PLACEMARKS);
  }
  #[inline]
  pub fn add_FOLDERS(&mut self, FOLDERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLFolder<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_FOLDERS, FOLDERS);
  }
  #[inline]
  pub fn add_NETWORK_LINKS(&mut self, NETWORK_LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLNetworkLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_NETWORK_LINKS, NETWORK_LINKS);
  }
  #[inline]
  pub fn add_GROUND_OVERLAYS(&mut self, GROUND_OVERLAYS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLGroundOverlay<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KMLFolder::VT_GROUND_OVERLAYS, GROUND_OVERLAYS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLFolderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLFolderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KMLFolder<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KMLFolder<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KMLFolder");
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("VISIBILITY", &self.VISIBILITY());
      ds.field("OPEN", &self.OPEN());
      ds.field("PLACEMARKS", &self.PLACEMARKS());
      ds.field("FOLDERS", &self.FOLDERS());
      ds.field("NETWORK_LINKS", &self.NETWORK_LINKS());
      ds.field("GROUND_OVERLAYS", &self.GROUND_OVERLAYS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLFolderT {
  pub NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub VISIBILITY: bool,
  pub OPEN: bool,
  pub PLACEMARKS: Option<Vec<KMLPlacemarkT>>,
  pub FOLDERS: Option<Vec<KMLFolderT>>,
  pub NETWORK_LINKS: Option<Vec<KMLNetworkLinkT>>,
  pub GROUND_OVERLAYS: Option<Vec<KMLGroundOverlayT>>,
}
impl Default for KMLFolderT {
  fn default() -> Self {
    Self {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      OPEN: false,
      PLACEMARKS: None,
      FOLDERS: None,
      NETWORK_LINKS: None,
      GROUND_OVERLAYS: None,
    }
  }
}
impl KMLFolderT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KMLFolder<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISIBILITY = self.VISIBILITY;
    let OPEN = self.OPEN;
    let PLACEMARKS = self.PLACEMARKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let FOLDERS = self.FOLDERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NETWORK_LINKS = self.NETWORK_LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let GROUND_OVERLAYS = self.GROUND_OVERLAYS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KMLFolder::create(_fbb, &KMLFolderArgs{
      NAME,
      DESCRIPTION,
      VISIBILITY,
      OPEN,
      PLACEMARKS,
      FOLDERS,
      NETWORK_LINKS,
      GROUND_OVERLAYS,
    })
  }
}
pub enum KMLOffset {}
#[derive(Copy, Clone, PartialEq)]

/// KML Document
pub struct KML<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for KML<'a> {
  type Inner = KML<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> KML<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBILITY: flatbuffers::VOffsetT = 8;
  pub const VT_OPEN: flatbuffers::VOffsetT = 10;
  pub const VT_STYLES: flatbuffers::VOffsetT = 12;
  pub const VT_STYLE_MAPS: flatbuffers::VOffsetT = 14;
  pub const VT_PLACEMARKS: flatbuffers::VOffsetT = 16;
  pub const VT_FOLDERS: flatbuffers::VOffsetT = 18;
  pub const VT_NETWORK_LINKS: flatbuffers::VOffsetT = 20;
  pub const VT_GROUND_OVERLAYS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    KML { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args KMLArgs<'args>
  ) -> flatbuffers::WIPOffset<KML<'bldr>> {
    let mut builder = KMLBuilder::new(_fbb);
    if let Some(x) = args.GROUND_OVERLAYS { builder.add_GROUND_OVERLAYS(x); }
    if let Some(x) = args.NETWORK_LINKS { builder.add_NETWORK_LINKS(x); }
    if let Some(x) = args.FOLDERS { builder.add_FOLDERS(x); }
    if let Some(x) = args.PLACEMARKS { builder.add_PLACEMARKS(x); }
    if let Some(x) = args.STYLE_MAPS { builder.add_STYLE_MAPS(x); }
    if let Some(x) = args.STYLES { builder.add_STYLES(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_OPEN(args.OPEN);
    builder.add_VISIBILITY(args.VISIBILITY);
    builder.finish()
  }

  pub fn unpack(&self) -> KMLT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let VISIBILITY = self.VISIBILITY();
    let OPEN = self.OPEN();
    let STYLES = self.STYLES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let STYLE_MAPS = self.STYLE_MAPS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let PLACEMARKS = self.PLACEMARKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let FOLDERS = self.FOLDERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NETWORK_LINKS = self.NETWORK_LINKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let GROUND_OVERLAYS = self.GROUND_OVERLAYS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    KMLT {
      NAME,
      DESCRIPTION,
      VISIBILITY,
      OPEN,
      STYLES,
      STYLE_MAPS,
      PLACEMARKS,
      FOLDERS,
      NETWORK_LINKS,
      GROUND_OVERLAYS,
    }
  }

  /// Document name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KML::VT_NAME, None)}
  }
  /// Document description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KML::VT_DESCRIPTION, None)}
  }
  /// Whether document is visible
  #[inline]
  pub fn VISIBILITY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KML::VT_VISIBILITY, Some(false)).unwrap()}
  }
  /// Whether document is open in tree view
  #[inline]
  pub fn OPEN(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(KML::VT_OPEN, Some(false)).unwrap()}
  }
  /// Shared styles
  #[inline]
  pub fn STYLES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyle>>>>(KML::VT_STYLES, None)}
  }
  /// Style maps
  #[inline]
  pub fn STYLE_MAPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMap<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMap>>>>(KML::VT_STYLE_MAPS, None)}
  }
  /// Top-level placemarks
  #[inline]
  pub fn PLACEMARKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark>>>>(KML::VT_PLACEMARKS, None)}
  }
  /// Top-level folders
  #[inline]
  pub fn FOLDERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder>>>>(KML::VT_FOLDERS, None)}
  }
  /// Network links
  #[inline]
  pub fn NETWORK_LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink>>>>(KML::VT_NETWORK_LINKS, None)}
  }
  /// Ground overlays
  #[inline]
  pub fn GROUND_OVERLAYS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay>>>>(KML::VT_GROUND_OVERLAYS, None)}
  }
}

impl flatbuffers::Verifiable for KML<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("VISIBILITY", Self::VT_VISIBILITY, false)?
     .visit_field::<bool>("OPEN", Self::VT_OPEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLStyle>>>>("STYLES", Self::VT_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLStyleMap>>>>("STYLE_MAPS", Self::VT_STYLE_MAPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLPlacemark>>>>("PLACEMARKS", Self::VT_PLACEMARKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLFolder>>>>("FOLDERS", Self::VT_FOLDERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLNetworkLink>>>>("NETWORK_LINKS", Self::VT_NETWORK_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<KMLGroundOverlay>>>>("GROUND_OVERLAYS", Self::VT_GROUND_OVERLAYS, false)?
     .finish();
    Ok(())
  }
}
pub struct KMLArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VISIBILITY: bool,
    pub OPEN: bool,
    pub STYLES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyle<'a>>>>>,
    pub STYLE_MAPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLStyleMap<'a>>>>>,
    pub PLACEMARKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLPlacemark<'a>>>>>,
    pub FOLDERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLFolder<'a>>>>>,
    pub NETWORK_LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLNetworkLink<'a>>>>>,
    pub GROUND_OVERLAYS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<KMLGroundOverlay<'a>>>>>,
}
impl<'a> Default for KMLArgs<'a> {
  #[inline]
  fn default() -> Self {
    KMLArgs {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      OPEN: false,
      STYLES: None,
      STYLE_MAPS: None,
      PLACEMARKS: None,
      FOLDERS: None,
      NETWORK_LINKS: None,
      GROUND_OVERLAYS: None,
    }
  }
}

pub struct KMLBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> KMLBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_VISIBILITY(&mut self, VISIBILITY: bool) {
    self.fbb_.push_slot::<bool>(KML::VT_VISIBILITY, VISIBILITY, false);
  }
  #[inline]
  pub fn add_OPEN(&mut self, OPEN: bool) {
    self.fbb_.push_slot::<bool>(KML::VT_OPEN, OPEN, false);
  }
  #[inline]
  pub fn add_STYLES(&mut self, STYLES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_STYLES, STYLES);
  }
  #[inline]
  pub fn add_STYLE_MAPS(&mut self, STYLE_MAPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLStyleMap<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_STYLE_MAPS, STYLE_MAPS);
  }
  #[inline]
  pub fn add_PLACEMARKS(&mut self, PLACEMARKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLPlacemark<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_PLACEMARKS, PLACEMARKS);
  }
  #[inline]
  pub fn add_FOLDERS(&mut self, FOLDERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLFolder<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_FOLDERS, FOLDERS);
  }
  #[inline]
  pub fn add_NETWORK_LINKS(&mut self, NETWORK_LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLNetworkLink<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_NETWORK_LINKS, NETWORK_LINKS);
  }
  #[inline]
  pub fn add_GROUND_OVERLAYS(&mut self, GROUND_OVERLAYS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KMLGroundOverlay<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KML::VT_GROUND_OVERLAYS, GROUND_OVERLAYS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> KMLBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    KMLBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<KML<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for KML<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("KML");
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("VISIBILITY", &self.VISIBILITY());
      ds.field("OPEN", &self.OPEN());
      ds.field("STYLES", &self.STYLES());
      ds.field("STYLE_MAPS", &self.STYLE_MAPS());
      ds.field("PLACEMARKS", &self.PLACEMARKS());
      ds.field("FOLDERS", &self.FOLDERS());
      ds.field("NETWORK_LINKS", &self.NETWORK_LINKS());
      ds.field("GROUND_OVERLAYS", &self.GROUND_OVERLAYS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct KMLT {
  pub NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub VISIBILITY: bool,
  pub OPEN: bool,
  pub STYLES: Option<Vec<KMLStyleT>>,
  pub STYLE_MAPS: Option<Vec<KMLStyleMapT>>,
  pub PLACEMARKS: Option<Vec<KMLPlacemarkT>>,
  pub FOLDERS: Option<Vec<KMLFolderT>>,
  pub NETWORK_LINKS: Option<Vec<KMLNetworkLinkT>>,
  pub GROUND_OVERLAYS: Option<Vec<KMLGroundOverlayT>>,
}
impl Default for KMLT {
  fn default() -> Self {
    Self {
      NAME: None,
      DESCRIPTION: None,
      VISIBILITY: false,
      OPEN: false,
      STYLES: None,
      STYLE_MAPS: None,
      PLACEMARKS: None,
      FOLDERS: None,
      NETWORK_LINKS: None,
      GROUND_OVERLAYS: None,
    }
  }
}
impl KMLT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<KML<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VISIBILITY = self.VISIBILITY;
    let OPEN = self.OPEN;
    let STYLES = self.STYLES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let STYLE_MAPS = self.STYLE_MAPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let PLACEMARKS = self.PLACEMARKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let FOLDERS = self.FOLDERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NETWORK_LINKS = self.NETWORK_LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let GROUND_OVERLAYS = self.GROUND_OVERLAYS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    KML::create(_fbb, &KMLArgs{
      NAME,
      DESCRIPTION,
      VISIBILITY,
      OPEN,
      STYLES,
      STYLE_MAPS,
      PLACEMARKS,
      FOLDERS,
      NETWORK_LINKS,
      GROUND_OVERLAYS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `KML`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_KML_unchecked`.
pub fn root_as_KML(buf: &[u8]) -> Result<KML, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<KML>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `KML` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_KML_unchecked`.
pub fn size_prefixed_root_as_KML(buf: &[u8]) -> Result<KML, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<KML>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `KML` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_KML_unchecked`.
pub fn root_as_KML_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<KML<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<KML<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `KML` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_KML_unchecked`.
pub fn size_prefixed_root_as_KML_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<KML<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<KML<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a KML and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `KML`.
pub unsafe fn root_as_KML_unchecked(buf: &[u8]) -> KML {
  flatbuffers::root_unchecked::<KML>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed KML and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `KML`.
pub unsafe fn size_prefixed_root_as_KML_unchecked(buf: &[u8]) -> KML {
  flatbuffers::size_prefixed_root_unchecked::<KML>(buf)
}
pub const KML_IDENTIFIER: &str = "$KML";

#[inline]
pub fn KML_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, KML_IDENTIFIER, false)
}

#[inline]
pub fn KML_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, KML_IDENTIFIER, true)
}

#[inline]
pub fn finish_KML_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<KML<'a>>) {
  fbb.finish(root, Some(KML_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_KML_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<KML<'a>>) {
  fbb.finish_size_prefixed(root, Some(KML_IDENTIFIER));
}
