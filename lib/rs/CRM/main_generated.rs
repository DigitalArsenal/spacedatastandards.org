// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum CRMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection Request Message
pub struct CRM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CRM<'a> {
  type Inner = CRM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CRM<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CLASSIFICATION: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ID_PLAN: flatbuffers::VOffsetT = 10;
  pub const VT_PLAN_INDEX: flatbuffers::VOffsetT = 12;
  pub const VT_TASK_ID: flatbuffers::VOffsetT = 14;
  pub const VT_DWELL_ID: flatbuffers::VOffsetT = 16;
  pub const VT_EXTERNAL_ID: flatbuffers::VOffsetT = 18;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 20;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 22;
  pub const VT_OB_TYPE: flatbuffers::VOffsetT = 24;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 26;
  pub const VT_TASK_CATEGORY: flatbuffers::VOffsetT = 28;
  pub const VT_SUFFIX: flatbuffers::VOffsetT = 30;
  pub const VT_UCT_FOLLOW_UP: flatbuffers::VOffsetT = 32;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 34;
  pub const VT_END_TIME: flatbuffers::VOffsetT = 36;
  pub const VT_NORAD_CAT_ID: flatbuffers::VOffsetT = 38;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 40;
  pub const VT_TASK_GROUP: flatbuffers::VOffsetT = 42;
  pub const VT_IRON: flatbuffers::VOffsetT = 44;
  pub const VT_ORBIT_REGIME: flatbuffers::VOffsetT = 46;
  pub const VT_TARGET_SIZE: flatbuffers::VOffsetT = 48;
  pub const VT_RCS_MIN: flatbuffers::VOffsetT = 50;
  pub const VT_RCS: flatbuffers::VOffsetT = 52;
  pub const VT_RCS_MAX: flatbuffers::VOffsetT = 54;
  pub const VT_FREQ_MIN: flatbuffers::VOffsetT = 56;
  pub const VT_FREQ: flatbuffers::VOffsetT = 58;
  pub const VT_FREQ_MAX: flatbuffers::VOffsetT = 60;
  pub const VT_POLARIZATION: flatbuffers::VOffsetT = 62;
  pub const VT_VIS_MAG_MIN: flatbuffers::VOffsetT = 64;
  pub const VT_VIS_MAG: flatbuffers::VOffsetT = 66;
  pub const VT_VIS_MAG_MAX: flatbuffers::VOffsetT = 68;
  pub const VT_SPECTRAL_MODEL: flatbuffers::VOffsetT = 70;
  pub const VT_REFLECTANCE: flatbuffers::VOffsetT = 72;
  pub const VT_IRRADIANCE: flatbuffers::VOffsetT = 74;
  pub const VT_NUM_FRAMES: flatbuffers::VOffsetT = 76;
  pub const VT_FRAME_RATE: flatbuffers::VOffsetT = 78;
  pub const VT_INTEGRATION_TIME: flatbuffers::VOffsetT = 80;
  pub const VT_NUM_TRACKS: flatbuffers::VOffsetT = 82;
  pub const VT_NUM_OBS: flatbuffers::VOffsetT = 84;
  pub const VT_DURATION: flatbuffers::VOffsetT = 86;
  pub const VT_SRCH_PATTERN: flatbuffers::VOffsetT = 88;
  pub const VT_SCENARIO: flatbuffers::VOffsetT = 90;
  pub const VT_ID_ELSET: flatbuffers::VOffsetT = 92;
  pub const VT_ID_MANIFOLD: flatbuffers::VOffsetT = 94;
  pub const VT_ID_STATE_VECTOR: flatbuffers::VOffsetT = 96;
  pub const VT_ES_ID: flatbuffers::VOffsetT = 98;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 100;
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 102;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 104;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 106;
  pub const VT_RAAN: flatbuffers::VOffsetT = 108;
  pub const VT_ARG_OF_PERIGEE: flatbuffers::VOffsetT = 110;
  pub const VT_MEAN_ANOMALY: flatbuffers::VOffsetT = 112;
  pub const VT_RA: flatbuffers::VOffsetT = 114;
  pub const VT_DEC: flatbuffers::VOffsetT = 116;
  pub const VT_AZ: flatbuffers::VOffsetT = 118;
  pub const VT_EL: flatbuffers::VOffsetT = 120;
  pub const VT_RANGE: flatbuffers::VOffsetT = 122;
  pub const VT_EXTENT_AZ: flatbuffers::VOffsetT = 124;
  pub const VT_EXTENT_EL: flatbuffers::VOffsetT = 126;
  pub const VT_EXTENT_RANGE: flatbuffers::VOffsetT = 128;
  pub const VT_LAT: flatbuffers::VOffsetT = 130;
  pub const VT_LON: flatbuffers::VOffsetT = 132;
  pub const VT_ALT: flatbuffers::VOffsetT = 134;
  pub const VT_STOP_LAT: flatbuffers::VOffsetT = 136;
  pub const VT_STOP_LON: flatbuffers::VOffsetT = 138;
  pub const VT_STOP_ALT: flatbuffers::VOffsetT = 140;
  pub const VT_SRCH_INC: flatbuffers::VOffsetT = 142;
  pub const VT_X_ANGLE: flatbuffers::VOffsetT = 144;
  pub const VT_Y_ANGLE: flatbuffers::VOffsetT = 146;
  pub const VT_ORIENT_ANGLE: flatbuffers::VOffsetT = 148;
  pub const VT_CUSTOMER: flatbuffers::VOffsetT = 150;
  pub const VT_NOTES: flatbuffers::VOffsetT = 152;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 154;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 156;
  pub const VT_DATA_MODE: flatbuffers::VOffsetT = 158;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CRM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CRMArgs<'args>
  ) -> flatbuffers::WIPOffset<CRM<'bldr>> {
    let mut builder = CRMBuilder::new(_fbb);
    builder.add_ORIENT_ANGLE(args.ORIENT_ANGLE);
    builder.add_Y_ANGLE(args.Y_ANGLE);
    builder.add_X_ANGLE(args.X_ANGLE);
    builder.add_SRCH_INC(args.SRCH_INC);
    builder.add_STOP_ALT(args.STOP_ALT);
    builder.add_STOP_LON(args.STOP_LON);
    builder.add_STOP_LAT(args.STOP_LAT);
    builder.add_ALT(args.ALT);
    builder.add_LON(args.LON);
    builder.add_LAT(args.LAT);
    builder.add_EXTENT_RANGE(args.EXTENT_RANGE);
    builder.add_EXTENT_EL(args.EXTENT_EL);
    builder.add_EXTENT_AZ(args.EXTENT_AZ);
    builder.add_RANGE(args.RANGE);
    builder.add_EL(args.EL);
    builder.add_AZ(args.AZ);
    builder.add_DEC(args.DEC);
    builder.add_RA(args.RA);
    builder.add_MEAN_ANOMALY(args.MEAN_ANOMALY);
    builder.add_ARG_OF_PERIGEE(args.ARG_OF_PERIGEE);
    builder.add_RAAN(args.RAAN);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    builder.add_INTEGRATION_TIME(args.INTEGRATION_TIME);
    builder.add_FRAME_RATE(args.FRAME_RATE);
    builder.add_IRRADIANCE(args.IRRADIANCE);
    builder.add_REFLECTANCE(args.REFLECTANCE);
    builder.add_VIS_MAG_MAX(args.VIS_MAG_MAX);
    builder.add_VIS_MAG(args.VIS_MAG);
    builder.add_VIS_MAG_MIN(args.VIS_MAG_MIN);
    builder.add_FREQ_MAX(args.FREQ_MAX);
    builder.add_FREQ(args.FREQ);
    builder.add_FREQ_MIN(args.FREQ_MIN);
    builder.add_RCS_MAX(args.RCS_MAX);
    builder.add_RCS(args.RCS);
    builder.add_RCS_MIN(args.RCS_MIN);
    builder.add_TARGET_SIZE(args.TARGET_SIZE);
    if let Some(x) = args.DATA_MODE { builder.add_DATA_MODE(x); }
    if let Some(x) = args.ORIGIN { builder.add_ORIGIN(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.CUSTOMER { builder.add_CUSTOMER(x); }
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    if let Some(x) = args.ES_ID { builder.add_ES_ID(x); }
    if let Some(x) = args.ID_STATE_VECTOR { builder.add_ID_STATE_VECTOR(x); }
    if let Some(x) = args.ID_MANIFOLD { builder.add_ID_MANIFOLD(x); }
    if let Some(x) = args.ID_ELSET { builder.add_ID_ELSET(x); }
    if let Some(x) = args.SCENARIO { builder.add_SCENARIO(x); }
    if let Some(x) = args.SRCH_PATTERN { builder.add_SRCH_PATTERN(x); }
    builder.add_DURATION(args.DURATION);
    builder.add_NUM_OBS(args.NUM_OBS);
    builder.add_NUM_TRACKS(args.NUM_TRACKS);
    builder.add_NUM_FRAMES(args.NUM_FRAMES);
    if let Some(x) = args.SPECTRAL_MODEL { builder.add_SPECTRAL_MODEL(x); }
    if let Some(x) = args.POLARIZATION { builder.add_POLARIZATION(x); }
    if let Some(x) = args.ORBIT_REGIME { builder.add_ORBIT_REGIME(x); }
    builder.add_IRON(args.IRON);
    if let Some(x) = args.TASK_GROUP { builder.add_TASK_GROUP(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    builder.add_NORAD_CAT_ID(args.NORAD_CAT_ID);
    if let Some(x) = args.END_TIME { builder.add_END_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.SUFFIX { builder.add_SUFFIX(x); }
    builder.add_TASK_CATEGORY(args.TASK_CATEGORY);
    if let Some(x) = args.PRIORITY { builder.add_PRIORITY(x); }
    if let Some(x) = args.OB_TYPE { builder.add_OB_TYPE(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.EXTERNAL_ID { builder.add_EXTERNAL_ID(x); }
    if let Some(x) = args.DWELL_ID { builder.add_DWELL_ID(x); }
    if let Some(x) = args.TASK_ID { builder.add_TASK_ID(x); }
    builder.add_PLAN_INDEX(args.PLAN_INDEX);
    if let Some(x) = args.ID_PLAN { builder.add_ID_PLAN(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.CLASSIFICATION { builder.add_CLASSIFICATION(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_UCT_FOLLOW_UP(args.UCT_FOLLOW_UP);
    builder.finish()
  }

  pub fn unpack(&self) -> CRMT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let CLASSIFICATION = self.CLASSIFICATION().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let ID_PLAN = self.ID_PLAN().map(|x| {
      x.to_string()
    });
    let PLAN_INDEX = self.PLAN_INDEX();
    let TASK_ID = self.TASK_ID().map(|x| {
      x.to_string()
    });
    let DWELL_ID = self.DWELL_ID().map(|x| {
      x.to_string()
    });
    let EXTERNAL_ID = self.EXTERNAL_ID().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let OB_TYPE = self.OB_TYPE().map(|x| {
      x.to_string()
    });
    let PRIORITY = self.PRIORITY().map(|x| {
      x.to_string()
    });
    let TASK_CATEGORY = self.TASK_CATEGORY();
    let SUFFIX = self.SUFFIX().map(|x| {
      x.to_string()
    });
    let UCT_FOLLOW_UP = self.UCT_FOLLOW_UP();
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let END_TIME = self.END_TIME().map(|x| {
      x.to_string()
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID();
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let TASK_GROUP = self.TASK_GROUP().map(|x| {
      x.to_string()
    });
    let IRON = self.IRON();
    let ORBIT_REGIME = self.ORBIT_REGIME().map(|x| {
      x.to_string()
    });
    let TARGET_SIZE = self.TARGET_SIZE();
    let RCS_MIN = self.RCS_MIN();
    let RCS = self.RCS();
    let RCS_MAX = self.RCS_MAX();
    let FREQ_MIN = self.FREQ_MIN();
    let FREQ = self.FREQ();
    let FREQ_MAX = self.FREQ_MAX();
    let POLARIZATION = self.POLARIZATION().map(|x| {
      x.to_string()
    });
    let VIS_MAG_MIN = self.VIS_MAG_MIN();
    let VIS_MAG = self.VIS_MAG();
    let VIS_MAG_MAX = self.VIS_MAG_MAX();
    let SPECTRAL_MODEL = self.SPECTRAL_MODEL().map(|x| {
      x.to_string()
    });
    let REFLECTANCE = self.REFLECTANCE();
    let IRRADIANCE = self.IRRADIANCE();
    let NUM_FRAMES = self.NUM_FRAMES();
    let FRAME_RATE = self.FRAME_RATE();
    let INTEGRATION_TIME = self.INTEGRATION_TIME();
    let NUM_TRACKS = self.NUM_TRACKS();
    let NUM_OBS = self.NUM_OBS();
    let DURATION = self.DURATION();
    let SRCH_PATTERN = self.SRCH_PATTERN().map(|x| {
      x.to_string()
    });
    let SCENARIO = self.SCENARIO().map(|x| {
      x.to_string()
    });
    let ID_ELSET = self.ID_ELSET().map(|x| {
      x.to_string()
    });
    let ID_MANIFOLD = self.ID_MANIFOLD().map(|x| {
      x.to_string()
    });
    let ID_STATE_VECTOR = self.ID_STATE_VECTOR().map(|x| {
      x.to_string()
    });
    let ES_ID = self.ES_ID().map(|x| {
      x.to_string()
    });
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RAAN = self.RAAN();
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE();
    let MEAN_ANOMALY = self.MEAN_ANOMALY();
    let RA = self.RA();
    let DEC = self.DEC();
    let AZ = self.AZ();
    let EL = self.EL();
    let RANGE = self.RANGE();
    let EXTENT_AZ = self.EXTENT_AZ();
    let EXTENT_EL = self.EXTENT_EL();
    let EXTENT_RANGE = self.EXTENT_RANGE();
    let LAT = self.LAT();
    let LON = self.LON();
    let ALT = self.ALT();
    let STOP_LAT = self.STOP_LAT();
    let STOP_LON = self.STOP_LON();
    let STOP_ALT = self.STOP_ALT();
    let SRCH_INC = self.SRCH_INC();
    let X_ANGLE = self.X_ANGLE();
    let Y_ANGLE = self.Y_ANGLE();
    let ORIENT_ANGLE = self.ORIENT_ANGLE();
    let CUSTOMER = self.CUSTOMER().map(|x| {
      x.to_string()
    });
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let ORIGIN = self.ORIGIN().map(|x| {
      x.to_string()
    });
    let DATA_MODE = self.DATA_MODE().map(|x| {
      x.to_string()
    });
    CRMT {
      ID,
      CLASSIFICATION,
      TYPE,
      ID_PLAN,
      PLAN_INDEX,
      TASK_ID,
      DWELL_ID,
      EXTERNAL_ID,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OB_TYPE,
      PRIORITY,
      TASK_CATEGORY,
      SUFFIX,
      UCT_FOLLOW_UP,
      START_TIME,
      END_TIME,
      NORAD_CAT_ID,
      ORIG_OBJECT_ID,
      TASK_GROUP,
      IRON,
      ORBIT_REGIME,
      TARGET_SIZE,
      RCS_MIN,
      RCS,
      RCS_MAX,
      FREQ_MIN,
      FREQ,
      FREQ_MAX,
      POLARIZATION,
      VIS_MAG_MIN,
      VIS_MAG,
      VIS_MAG_MAX,
      SPECTRAL_MODEL,
      REFLECTANCE,
      IRRADIANCE,
      NUM_FRAMES,
      FRAME_RATE,
      INTEGRATION_TIME,
      NUM_TRACKS,
      NUM_OBS,
      DURATION,
      SRCH_PATTERN,
      SCENARIO,
      ID_ELSET,
      ID_MANIFOLD,
      ID_STATE_VECTOR,
      ES_ID,
      EPOCH,
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      RA,
      DEC,
      AZ,
      EL,
      RANGE,
      EXTENT_AZ,
      EXTENT_EL,
      EXTENT_RANGE,
      LAT,
      LON,
      ALT,
      STOP_LAT,
      STOP_LON,
      STOP_ALT,
      SRCH_INC,
      X_ANGLE,
      Y_ANGLE,
      ORIENT_ANGLE,
      CUSTOMER,
      NOTES,
      SOURCE,
      ORIGIN,
      DATA_MODE,
    }
  }

  /// Unique identifier of the record, auto-generated by the system.
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID, None)}
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  #[inline]
  pub fn CLASSIFICATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_CLASSIFICATION, None)}
  }
  /// The type of this collect or contact request.
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_TYPE, None)}
  }
  /// Unique identifier of the parent plan or schedule associated with this request.
  #[inline]
  pub fn ID_PLAN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID_PLAN, None)}
  }
  /// Index number for records within a collection plan or schedule.
  #[inline]
  pub fn PLAN_INDEX(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_PLAN_INDEX, Some(0)).unwrap()}
  }
  /// Task ID associated with this request.
  #[inline]
  pub fn TASK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_TASK_ID, None)}
  }
  /// The dwell ID associated with this request.
  #[inline]
  pub fn DWELL_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_DWELL_ID, None)}
  }
  /// Optional ID from external systems.
  #[inline]
  pub fn EXTERNAL_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_EXTERNAL_ID, None)}
  }
  /// Unique identifier of the requested/scheduled/planned sensor associated with this request.
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID_SENSOR, None)}
  }
  /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request.
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ORIG_SENSOR_ID, None)}
  }
  /// Optional type of observation requested.
  #[inline]
  pub fn OB_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_OB_TYPE, None)}
  }
  /// The priority of the collect request.
  #[inline]
  pub fn PRIORITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_PRIORITY, None)}
  }
  /// The tasking category associated with this request.
  #[inline]
  pub fn TASK_CATEGORY(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_TASK_CATEGORY, Some(0)).unwrap()}
  }
  /// The tasking suffix associated with this request.
  #[inline]
  pub fn SUFFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_SUFFIX, None)}
  }
  /// Boolean indicating that this collect request is UCT follow-up.
  #[inline]
  pub fn UCT_FOLLOW_UP(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CRM::VT_UCT_FOLLOW_UP, Some(false)).unwrap()}
  }
  /// The start time of the collect or contact request window, in ISO 8601 UTC format.
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_START_TIME, None)}
  }
  /// The end time of the collect or contact request window, in ISO 8601 UTC format.
  #[inline]
  pub fn END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_END_TIME, None)}
  }
  /// Satellite/catalog number of the target on-orbit object for this request.
  #[inline]
  pub fn NORAD_CAT_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CRM::VT_NORAD_CAT_ID, Some(0)).unwrap()}
  }
  /// Optional identifier provided by the data source to indicate the target object of this request.
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ORIG_OBJECT_ID, None)}
  }
  /// The tasking group to which the target object is assigned.
  #[inline]
  pub fn TASK_GROUP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_TASK_GROUP, None)}
  }
  /// Inter-Range Operations Number.
  #[inline]
  pub fn IRON(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_IRON, Some(0)).unwrap()}
  }
  /// The orbit regime of the target.
  #[inline]
  pub fn ORBIT_REGIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ORBIT_REGIME, None)}
  }
  /// The minimum object (diameter) size, in meters, to be reported.
  #[inline]
  pub fn TARGET_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_TARGET_SIZE, Some(0.0)).unwrap()}
  }
  /// The minimum Radar Cross-Section of the target, in m^2.
  #[inline]
  pub fn RCS_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RCS_MIN, Some(0.0)).unwrap()}
  }
  /// The Radar Cross-Section of the target, in m^2.
  #[inline]
  pub fn RCS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RCS, Some(0.0)).unwrap()}
  }
  /// The maximum Radar Cross-Section of the target, in m^2.
  #[inline]
  pub fn RCS_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RCS_MAX, Some(0.0)).unwrap()}
  }
  /// The minimum frequency of interest, in MHz.
  #[inline]
  pub fn FREQ_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_FREQ_MIN, Some(0.0)).unwrap()}
  }
  /// The estimated or expected emission frequency of the target, in MHz.
  #[inline]
  pub fn FREQ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_FREQ, Some(0.0)).unwrap()}
  }
  /// The maximum frequency of interest, in MHz.
  #[inline]
  pub fn FREQ_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_FREQ_MAX, Some(0.0)).unwrap()}
  }
  /// The RF polarization.
  #[inline]
  pub fn POLARIZATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_POLARIZATION, None)}
  }
  /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).
  #[inline]
  pub fn VIS_MAG_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_VIS_MAG_MIN, Some(0.0)).unwrap()}
  }
  /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
  #[inline]
  pub fn VIS_MAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_VIS_MAG, Some(0.0)).unwrap()}
  }
  /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
  #[inline]
  pub fn VIS_MAG_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_VIS_MAG_MAX, Some(0.0)).unwrap()}
  }
  /// The spectral model used for the irradiance calculation.
  #[inline]
  pub fn SPECTRAL_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_SPECTRAL_MODEL, None)}
  }
  /// The fraction of solar energy reflected from target.
  #[inline]
  pub fn REFLECTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_REFLECTANCE, Some(0.0)).unwrap()}
  }
  /// The target object irradiance value.
  #[inline]
  pub fn IRRADIANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_IRRADIANCE, Some(0.0)).unwrap()}
  }
  /// For optical sensors, the requested number of frames to capture at each sensor step.
  #[inline]
  pub fn NUM_FRAMES(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_NUM_FRAMES, Some(0)).unwrap()}
  }
  /// For optical sensors, the frame rate of the camera, in Hz.
  #[inline]
  pub fn FRAME_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_FRAME_RATE, Some(0.0)).unwrap()}
  }
  /// For optical sensors, the integration time per camera frame, in milliseconds.
  #[inline]
  pub fn INTEGRATION_TIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_INTEGRATION_TIME, Some(0.0)).unwrap()}
  }
  /// The number of requested tracks on the target.
  #[inline]
  pub fn NUM_TRACKS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_NUM_TRACKS, Some(0)).unwrap()}
  }
  /// The number of requested observations on the target.
  #[inline]
  pub fn NUM_OBS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_NUM_OBS, Some(0)).unwrap()}
  }
  /// The duration of the collect request, in seconds.
  #[inline]
  pub fn DURATION(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(CRM::VT_DURATION, Some(0)).unwrap()}
  }
  /// The search pattern to be executed for this request.
  #[inline]
  pub fn SRCH_PATTERN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_SRCH_PATTERN, None)}
  }
  /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
  #[inline]
  pub fn SCENARIO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_SCENARIO, None)}
  }
  /// ID of the Elset of the object associated with this request.
  #[inline]
  pub fn ID_ELSET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID_ELSET, None)}
  }
  /// ID of the Manifold Elset of the object associated with this request.
  #[inline]
  pub fn ID_MANIFOLD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID_MANIFOLD, None)}
  }
  /// ID of the State Vector of the object or central vector associated with this request.
  #[inline]
  pub fn ID_STATE_VECTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ID_STATE_VECTOR, None)}
  }
  /// ID of the Ephemeris Set of the object associated with this request.
  #[inline]
  pub fn ES_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ES_ID, None)}
  }
  /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_EPOCH, None)}
  }
  /// The average of the periapsis and apoapsis distances, in kilometers.
  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  /// The orbital eccentricity of an astronomical object.
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  /// The angle, in degrees, between the equator and the orbit plane.
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  /// Right ascension of the ascending node, in degrees.
  #[inline]
  pub fn RAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RAAN, Some(0.0)).unwrap()}
  }
  /// The argument of perigee, in degrees.
  #[inline]
  pub fn ARG_OF_PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_ARG_OF_PERIGEE, Some(0.0)).unwrap()}
  }
  /// The mean anomaly defines the angular position, in degrees, of the object on its orbital path.
  #[inline]
  pub fn MEAN_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_MEAN_ANOMALY, Some(0.0)).unwrap()}
  }
  /// The expected or directed right ascension angle, in degrees.
  #[inline]
  pub fn RA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RA, Some(0.0)).unwrap()}
  }
  /// The expected or directed declination angle, in degrees.
  #[inline]
  pub fn DEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_DEC, Some(0.0)).unwrap()}
  }
  /// The expected or directed azimuth angle, in degrees.
  #[inline]
  pub fn AZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_AZ, Some(0.0)).unwrap()}
  }
  /// The expected or directed elevation angle, in degrees.
  #[inline]
  pub fn EL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_EL, Some(0.0)).unwrap()}
  }
  /// The expected acquisition range or defined center range, in km.
  #[inline]
  pub fn RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// The extent of the azimuth angle, in degrees, from center azimuth.
  #[inline]
  pub fn EXTENT_AZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_EXTENT_AZ, Some(0.0)).unwrap()}
  }
  /// The extent of the elevation angle, in degrees, from center elevation.
  #[inline]
  pub fn EXTENT_EL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_EXTENT_EL, Some(0.0)).unwrap()}
  }
  /// The extent of the range, in km, from center range.
  #[inline]
  pub fn EXTENT_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_EXTENT_RANGE, Some(0.0)).unwrap()}
  }
  /// WGS-84 latitude, in degrees.
  #[inline]
  pub fn LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_LAT, Some(0.0)).unwrap()}
  }
  /// WGS-84 longitude, in degrees.
  #[inline]
  pub fn LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_LON, Some(0.0)).unwrap()}
  }
  /// Height above WGS-84 ellipsoid (HAE), in kilometers.
  #[inline]
  pub fn ALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_ALT, Some(0.0)).unwrap()}
  }
  /// The stopping WGS-84 latitude of a volume definition, in degrees.
  #[inline]
  pub fn STOP_LAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_STOP_LAT, Some(0.0)).unwrap()}
  }
  /// The stopping WGS-84 longitude of a volume definition, in degrees.
  #[inline]
  pub fn STOP_LON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_STOP_LON, Some(0.0)).unwrap()}
  }
  /// The stopping HAE WGS-84 height above ellipsoid (HAE), in kilometers.
  #[inline]
  pub fn STOP_ALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_STOP_ALT, Some(0.0)).unwrap()}
  }
  /// The maximum inclination, in degrees, to be used in search operations.
  #[inline]
  pub fn SRCH_INC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_SRCH_INC, Some(0.0)).unwrap()}
  }
  /// The angular distance, in degrees, in the sensor-x direction from scan center.
  #[inline]
  pub fn X_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_X_ANGLE, Some(0.0)).unwrap()}
  }
  /// The angular distance, in degrees, in the sensor-y direction from scan center.
  #[inline]
  pub fn Y_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_Y_ANGLE, Some(0.0)).unwrap()}
  }
  /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.
  #[inline]
  pub fn ORIENT_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CRM::VT_ORIENT_ANGLE, Some(0.0)).unwrap()}
  }
  /// The customer for this request.
  #[inline]
  pub fn CUSTOMER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_CUSTOMER, None)}
  }
  /// Notes or comments associated with this request.
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_NOTES, None)}
  }
  ///  Source of the data.
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_SOURCE, None)}
  }
  ///  Originating system or organization which produced the data, if different from the source.
  #[inline]
  pub fn ORIGIN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_ORIGIN, None)}
  }
  ///  Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data.
  #[inline]
  pub fn DATA_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CRM::VT_DATA_MODE, None)}
  }
}

impl flatbuffers::Verifiable for CRM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION", Self::VT_CLASSIFICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_PLAN", Self::VT_ID_PLAN, false)?
     .visit_field::<i32>("PLAN_INDEX", Self::VT_PLAN_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TASK_ID", Self::VT_TASK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DWELL_ID", Self::VT_DWELL_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXTERNAL_ID", Self::VT_EXTERNAL_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_TYPE", Self::VT_OB_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PRIORITY", Self::VT_PRIORITY, false)?
     .visit_field::<i32>("TASK_CATEGORY", Self::VT_TASK_CATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUFFIX", Self::VT_SUFFIX, false)?
     .visit_field::<bool>("UCT_FOLLOW_UP", Self::VT_UCT_FOLLOW_UP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END_TIME", Self::VT_END_TIME, false)?
     .visit_field::<u32>("NORAD_CAT_ID", Self::VT_NORAD_CAT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TASK_GROUP", Self::VT_TASK_GROUP, false)?
     .visit_field::<i32>("IRON", Self::VT_IRON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORBIT_REGIME", Self::VT_ORBIT_REGIME, false)?
     .visit_field::<f64>("TARGET_SIZE", Self::VT_TARGET_SIZE, false)?
     .visit_field::<f64>("RCS_MIN", Self::VT_RCS_MIN, false)?
     .visit_field::<f64>("RCS", Self::VT_RCS, false)?
     .visit_field::<f64>("RCS_MAX", Self::VT_RCS_MAX, false)?
     .visit_field::<f64>("FREQ_MIN", Self::VT_FREQ_MIN, false)?
     .visit_field::<f64>("FREQ", Self::VT_FREQ, false)?
     .visit_field::<f64>("FREQ_MAX", Self::VT_FREQ_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POLARIZATION", Self::VT_POLARIZATION, false)?
     .visit_field::<f64>("VIS_MAG_MIN", Self::VT_VIS_MAG_MIN, false)?
     .visit_field::<f64>("VIS_MAG", Self::VT_VIS_MAG, false)?
     .visit_field::<f64>("VIS_MAG_MAX", Self::VT_VIS_MAG_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SPECTRAL_MODEL", Self::VT_SPECTRAL_MODEL, false)?
     .visit_field::<f64>("REFLECTANCE", Self::VT_REFLECTANCE, false)?
     .visit_field::<f64>("IRRADIANCE", Self::VT_IRRADIANCE, false)?
     .visit_field::<i32>("NUM_FRAMES", Self::VT_NUM_FRAMES, false)?
     .visit_field::<f64>("FRAME_RATE", Self::VT_FRAME_RATE, false)?
     .visit_field::<f64>("INTEGRATION_TIME", Self::VT_INTEGRATION_TIME, false)?
     .visit_field::<i32>("NUM_TRACKS", Self::VT_NUM_TRACKS, false)?
     .visit_field::<i32>("NUM_OBS", Self::VT_NUM_OBS, false)?
     .visit_field::<i32>("DURATION", Self::VT_DURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SRCH_PATTERN", Self::VT_SRCH_PATTERN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SCENARIO", Self::VT_SCENARIO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_ELSET", Self::VT_ID_ELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_MANIFOLD", Self::VT_ID_MANIFOLD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_STATE_VECTOR", Self::VT_ID_STATE_VECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ES_ID", Self::VT_ES_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RAAN", Self::VT_RAAN, false)?
     .visit_field::<f64>("ARG_OF_PERIGEE", Self::VT_ARG_OF_PERIGEE, false)?
     .visit_field::<f64>("MEAN_ANOMALY", Self::VT_MEAN_ANOMALY, false)?
     .visit_field::<f64>("RA", Self::VT_RA, false)?
     .visit_field::<f64>("DEC", Self::VT_DEC, false)?
     .visit_field::<f64>("AZ", Self::VT_AZ, false)?
     .visit_field::<f64>("EL", Self::VT_EL, false)?
     .visit_field::<f64>("RANGE", Self::VT_RANGE, false)?
     .visit_field::<f64>("EXTENT_AZ", Self::VT_EXTENT_AZ, false)?
     .visit_field::<f64>("EXTENT_EL", Self::VT_EXTENT_EL, false)?
     .visit_field::<f64>("EXTENT_RANGE", Self::VT_EXTENT_RANGE, false)?
     .visit_field::<f64>("LAT", Self::VT_LAT, false)?
     .visit_field::<f64>("LON", Self::VT_LON, false)?
     .visit_field::<f64>("ALT", Self::VT_ALT, false)?
     .visit_field::<f64>("STOP_LAT", Self::VT_STOP_LAT, false)?
     .visit_field::<f64>("STOP_LON", Self::VT_STOP_LON, false)?
     .visit_field::<f64>("STOP_ALT", Self::VT_STOP_ALT, false)?
     .visit_field::<f64>("SRCH_INC", Self::VT_SRCH_INC, false)?
     .visit_field::<f64>("X_ANGLE", Self::VT_X_ANGLE, false)?
     .visit_field::<f64>("Y_ANGLE", Self::VT_Y_ANGLE, false)?
     .visit_field::<f64>("ORIENT_ANGLE", Self::VT_ORIENT_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CUSTOMER", Self::VT_CUSTOMER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGIN", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATA_MODE", Self::VT_DATA_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct CRMArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLASSIFICATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_PLAN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PLAN_INDEX: i32,
    pub TASK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DWELL_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EXTERNAL_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIORITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TASK_CATEGORY: i32,
    pub SUFFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UCT_FOLLOW_UP: bool,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NORAD_CAT_ID: u32,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TASK_GROUP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IRON: i32,
    pub ORBIT_REGIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TARGET_SIZE: f64,
    pub RCS_MIN: f64,
    pub RCS: f64,
    pub RCS_MAX: f64,
    pub FREQ_MIN: f64,
    pub FREQ: f64,
    pub FREQ_MAX: f64,
    pub POLARIZATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VIS_MAG_MIN: f64,
    pub VIS_MAG: f64,
    pub VIS_MAG_MAX: f64,
    pub SPECTRAL_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REFLECTANCE: f64,
    pub IRRADIANCE: f64,
    pub NUM_FRAMES: i32,
    pub FRAME_RATE: f64,
    pub INTEGRATION_TIME: f64,
    pub NUM_TRACKS: i32,
    pub NUM_OBS: i32,
    pub DURATION: i32,
    pub SRCH_PATTERN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCENARIO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_ELSET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_MANIFOLD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_STATE_VECTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ES_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEMI_MAJOR_AXIS: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RAAN: f64,
    pub ARG_OF_PERIGEE: f64,
    pub MEAN_ANOMALY: f64,
    pub RA: f64,
    pub DEC: f64,
    pub AZ: f64,
    pub EL: f64,
    pub RANGE: f64,
    pub EXTENT_AZ: f64,
    pub EXTENT_EL: f64,
    pub EXTENT_RANGE: f64,
    pub LAT: f64,
    pub LON: f64,
    pub ALT: f64,
    pub STOP_LAT: f64,
    pub STOP_LON: f64,
    pub STOP_ALT: f64,
    pub SRCH_INC: f64,
    pub X_ANGLE: f64,
    pub Y_ANGLE: f64,
    pub ORIENT_ANGLE: f64,
    pub CUSTOMER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGIN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CRMArgs<'a> {
  #[inline]
  fn default() -> Self {
    CRMArgs {
      ID: None,
      CLASSIFICATION: None,
      TYPE: None,
      ID_PLAN: None,
      PLAN_INDEX: 0,
      TASK_ID: None,
      DWELL_ID: None,
      EXTERNAL_ID: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OB_TYPE: None,
      PRIORITY: None,
      TASK_CATEGORY: 0,
      SUFFIX: None,
      UCT_FOLLOW_UP: false,
      START_TIME: None,
      END_TIME: None,
      NORAD_CAT_ID: 0,
      ORIG_OBJECT_ID: None,
      TASK_GROUP: None,
      IRON: 0,
      ORBIT_REGIME: None,
      TARGET_SIZE: 0.0,
      RCS_MIN: 0.0,
      RCS: 0.0,
      RCS_MAX: 0.0,
      FREQ_MIN: 0.0,
      FREQ: 0.0,
      FREQ_MAX: 0.0,
      POLARIZATION: None,
      VIS_MAG_MIN: 0.0,
      VIS_MAG: 0.0,
      VIS_MAG_MAX: 0.0,
      SPECTRAL_MODEL: None,
      REFLECTANCE: 0.0,
      IRRADIANCE: 0.0,
      NUM_FRAMES: 0,
      FRAME_RATE: 0.0,
      INTEGRATION_TIME: 0.0,
      NUM_TRACKS: 0,
      NUM_OBS: 0,
      DURATION: 0,
      SRCH_PATTERN: None,
      SCENARIO: None,
      ID_ELSET: None,
      ID_MANIFOLD: None,
      ID_STATE_VECTOR: None,
      ES_ID: None,
      EPOCH: None,
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      RA: 0.0,
      DEC: 0.0,
      AZ: 0.0,
      EL: 0.0,
      RANGE: 0.0,
      EXTENT_AZ: 0.0,
      EXTENT_EL: 0.0,
      EXTENT_RANGE: 0.0,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      STOP_LAT: 0.0,
      STOP_LON: 0.0,
      STOP_ALT: 0.0,
      SRCH_INC: 0.0,
      X_ANGLE: 0.0,
      Y_ANGLE: 0.0,
      ORIENT_ANGLE: 0.0,
      CUSTOMER: None,
      NOTES: None,
      SOURCE: None,
      ORIGIN: None,
      DATA_MODE: None,
    }
  }
}

pub struct CRMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CRMBuilder<'a, 'b> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID, ID);
  }
  #[inline]
  pub fn add_CLASSIFICATION(&mut self, CLASSIFICATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_CLASSIFICATION, CLASSIFICATION);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_ID_PLAN(&mut self, ID_PLAN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID_PLAN, ID_PLAN);
  }
  #[inline]
  pub fn add_PLAN_INDEX(&mut self, PLAN_INDEX: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_PLAN_INDEX, PLAN_INDEX, 0);
  }
  #[inline]
  pub fn add_TASK_ID(&mut self, TASK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_TASK_ID, TASK_ID);
  }
  #[inline]
  pub fn add_DWELL_ID(&mut self, DWELL_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_DWELL_ID, DWELL_ID);
  }
  #[inline]
  pub fn add_EXTERNAL_ID(&mut self, EXTERNAL_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_EXTERNAL_ID, EXTERNAL_ID);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_OB_TYPE(&mut self, OB_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_OB_TYPE, OB_TYPE);
  }
  #[inline]
  pub fn add_PRIORITY(&mut self, PRIORITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_PRIORITY, PRIORITY);
  }
  #[inline]
  pub fn add_TASK_CATEGORY(&mut self, TASK_CATEGORY: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_TASK_CATEGORY, TASK_CATEGORY, 0);
  }
  #[inline]
  pub fn add_SUFFIX(&mut self, SUFFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_SUFFIX, SUFFIX);
  }
  #[inline]
  pub fn add_UCT_FOLLOW_UP(&mut self, UCT_FOLLOW_UP: bool) {
    self.fbb_.push_slot::<bool>(CRM::VT_UCT_FOLLOW_UP, UCT_FOLLOW_UP, false);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_END_TIME(&mut self, END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_END_TIME, END_TIME);
  }
  #[inline]
  pub fn add_NORAD_CAT_ID(&mut self, NORAD_CAT_ID: u32) {
    self.fbb_.push_slot::<u32>(CRM::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_TASK_GROUP(&mut self, TASK_GROUP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_TASK_GROUP, TASK_GROUP);
  }
  #[inline]
  pub fn add_IRON(&mut self, IRON: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_IRON, IRON, 0);
  }
  #[inline]
  pub fn add_ORBIT_REGIME(&mut self, ORBIT_REGIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ORBIT_REGIME, ORBIT_REGIME);
  }
  #[inline]
  pub fn add_TARGET_SIZE(&mut self, TARGET_SIZE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_TARGET_SIZE, TARGET_SIZE, 0.0);
  }
  #[inline]
  pub fn add_RCS_MIN(&mut self, RCS_MIN: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RCS_MIN, RCS_MIN, 0.0);
  }
  #[inline]
  pub fn add_RCS(&mut self, RCS: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RCS, RCS, 0.0);
  }
  #[inline]
  pub fn add_RCS_MAX(&mut self, RCS_MAX: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RCS_MAX, RCS_MAX, 0.0);
  }
  #[inline]
  pub fn add_FREQ_MIN(&mut self, FREQ_MIN: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_FREQ_MIN, FREQ_MIN, 0.0);
  }
  #[inline]
  pub fn add_FREQ(&mut self, FREQ: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_FREQ, FREQ, 0.0);
  }
  #[inline]
  pub fn add_FREQ_MAX(&mut self, FREQ_MAX: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_FREQ_MAX, FREQ_MAX, 0.0);
  }
  #[inline]
  pub fn add_POLARIZATION(&mut self, POLARIZATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_POLARIZATION, POLARIZATION);
  }
  #[inline]
  pub fn add_VIS_MAG_MIN(&mut self, VIS_MAG_MIN: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_VIS_MAG_MIN, VIS_MAG_MIN, 0.0);
  }
  #[inline]
  pub fn add_VIS_MAG(&mut self, VIS_MAG: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_VIS_MAG, VIS_MAG, 0.0);
  }
  #[inline]
  pub fn add_VIS_MAG_MAX(&mut self, VIS_MAG_MAX: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_VIS_MAG_MAX, VIS_MAG_MAX, 0.0);
  }
  #[inline]
  pub fn add_SPECTRAL_MODEL(&mut self, SPECTRAL_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_SPECTRAL_MODEL, SPECTRAL_MODEL);
  }
  #[inline]
  pub fn add_REFLECTANCE(&mut self, REFLECTANCE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_REFLECTANCE, REFLECTANCE, 0.0);
  }
  #[inline]
  pub fn add_IRRADIANCE(&mut self, IRRADIANCE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_IRRADIANCE, IRRADIANCE, 0.0);
  }
  #[inline]
  pub fn add_NUM_FRAMES(&mut self, NUM_FRAMES: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_NUM_FRAMES, NUM_FRAMES, 0);
  }
  #[inline]
  pub fn add_FRAME_RATE(&mut self, FRAME_RATE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_FRAME_RATE, FRAME_RATE, 0.0);
  }
  #[inline]
  pub fn add_INTEGRATION_TIME(&mut self, INTEGRATION_TIME: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_INTEGRATION_TIME, INTEGRATION_TIME, 0.0);
  }
  #[inline]
  pub fn add_NUM_TRACKS(&mut self, NUM_TRACKS: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_NUM_TRACKS, NUM_TRACKS, 0);
  }
  #[inline]
  pub fn add_NUM_OBS(&mut self, NUM_OBS: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_NUM_OBS, NUM_OBS, 0);
  }
  #[inline]
  pub fn add_DURATION(&mut self, DURATION: i32) {
    self.fbb_.push_slot::<i32>(CRM::VT_DURATION, DURATION, 0);
  }
  #[inline]
  pub fn add_SRCH_PATTERN(&mut self, SRCH_PATTERN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_SRCH_PATTERN, SRCH_PATTERN);
  }
  #[inline]
  pub fn add_SCENARIO(&mut self, SCENARIO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_SCENARIO, SCENARIO);
  }
  #[inline]
  pub fn add_ID_ELSET(&mut self, ID_ELSET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID_ELSET, ID_ELSET);
  }
  #[inline]
  pub fn add_ID_MANIFOLD(&mut self, ID_MANIFOLD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID_MANIFOLD, ID_MANIFOLD);
  }
  #[inline]
  pub fn add_ID_STATE_VECTOR(&mut self, ID_STATE_VECTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ID_STATE_VECTOR, ID_STATE_VECTOR);
  }
  #[inline]
  pub fn add_ES_ID(&mut self, ES_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ES_ID, ES_ID);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RAAN(&mut self, RAAN: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RAAN, RAAN, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERIGEE(&mut self, ARG_OF_PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_ARG_OF_PERIGEE, ARG_OF_PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ANOMALY(&mut self, MEAN_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_RA(&mut self, RA: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RA, RA, 0.0);
  }
  #[inline]
  pub fn add_DEC(&mut self, DEC: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_DEC, DEC, 0.0);
  }
  #[inline]
  pub fn add_AZ(&mut self, AZ: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_AZ, AZ, 0.0);
  }
  #[inline]
  pub fn add_EL(&mut self, EL: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_EL, EL, 0.0);
  }
  #[inline]
  pub fn add_RANGE(&mut self, RANGE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_RANGE, RANGE, 0.0);
  }
  #[inline]
  pub fn add_EXTENT_AZ(&mut self, EXTENT_AZ: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_EXTENT_AZ, EXTENT_AZ, 0.0);
  }
  #[inline]
  pub fn add_EXTENT_EL(&mut self, EXTENT_EL: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_EXTENT_EL, EXTENT_EL, 0.0);
  }
  #[inline]
  pub fn add_EXTENT_RANGE(&mut self, EXTENT_RANGE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_EXTENT_RANGE, EXTENT_RANGE, 0.0);
  }
  #[inline]
  pub fn add_LAT(&mut self, LAT: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_LAT, LAT, 0.0);
  }
  #[inline]
  pub fn add_LON(&mut self, LON: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_LON, LON, 0.0);
  }
  #[inline]
  pub fn add_ALT(&mut self, ALT: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_ALT, ALT, 0.0);
  }
  #[inline]
  pub fn add_STOP_LAT(&mut self, STOP_LAT: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_STOP_LAT, STOP_LAT, 0.0);
  }
  #[inline]
  pub fn add_STOP_LON(&mut self, STOP_LON: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_STOP_LON, STOP_LON, 0.0);
  }
  #[inline]
  pub fn add_STOP_ALT(&mut self, STOP_ALT: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_STOP_ALT, STOP_ALT, 0.0);
  }
  #[inline]
  pub fn add_SRCH_INC(&mut self, SRCH_INC: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_SRCH_INC, SRCH_INC, 0.0);
  }
  #[inline]
  pub fn add_X_ANGLE(&mut self, X_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_X_ANGLE, X_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_Y_ANGLE(&mut self, Y_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_Y_ANGLE, Y_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_ORIENT_ANGLE(&mut self, ORIENT_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(CRM::VT_ORIENT_ANGLE, ORIENT_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_CUSTOMER(&mut self, CUSTOMER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_CUSTOMER, CUSTOMER);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_ORIGIN(&mut self, ORIGIN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_ORIGIN, ORIGIN);
  }
  #[inline]
  pub fn add_DATA_MODE(&mut self, DATA_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRM::VT_DATA_MODE, DATA_MODE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CRMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CRMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CRM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CRM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CRM");
      ds.field("ID", &self.ID());
      ds.field("CLASSIFICATION", &self.CLASSIFICATION());
      ds.field("TYPE", &self.TYPE());
      ds.field("ID_PLAN", &self.ID_PLAN());
      ds.field("PLAN_INDEX", &self.PLAN_INDEX());
      ds.field("TASK_ID", &self.TASK_ID());
      ds.field("DWELL_ID", &self.DWELL_ID());
      ds.field("EXTERNAL_ID", &self.EXTERNAL_ID());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("OB_TYPE", &self.OB_TYPE());
      ds.field("PRIORITY", &self.PRIORITY());
      ds.field("TASK_CATEGORY", &self.TASK_CATEGORY());
      ds.field("SUFFIX", &self.SUFFIX());
      ds.field("UCT_FOLLOW_UP", &self.UCT_FOLLOW_UP());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("END_TIME", &self.END_TIME());
      ds.field("NORAD_CAT_ID", &self.NORAD_CAT_ID());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("TASK_GROUP", &self.TASK_GROUP());
      ds.field("IRON", &self.IRON());
      ds.field("ORBIT_REGIME", &self.ORBIT_REGIME());
      ds.field("TARGET_SIZE", &self.TARGET_SIZE());
      ds.field("RCS_MIN", &self.RCS_MIN());
      ds.field("RCS", &self.RCS());
      ds.field("RCS_MAX", &self.RCS_MAX());
      ds.field("FREQ_MIN", &self.FREQ_MIN());
      ds.field("FREQ", &self.FREQ());
      ds.field("FREQ_MAX", &self.FREQ_MAX());
      ds.field("POLARIZATION", &self.POLARIZATION());
      ds.field("VIS_MAG_MIN", &self.VIS_MAG_MIN());
      ds.field("VIS_MAG", &self.VIS_MAG());
      ds.field("VIS_MAG_MAX", &self.VIS_MAG_MAX());
      ds.field("SPECTRAL_MODEL", &self.SPECTRAL_MODEL());
      ds.field("REFLECTANCE", &self.REFLECTANCE());
      ds.field("IRRADIANCE", &self.IRRADIANCE());
      ds.field("NUM_FRAMES", &self.NUM_FRAMES());
      ds.field("FRAME_RATE", &self.FRAME_RATE());
      ds.field("INTEGRATION_TIME", &self.INTEGRATION_TIME());
      ds.field("NUM_TRACKS", &self.NUM_TRACKS());
      ds.field("NUM_OBS", &self.NUM_OBS());
      ds.field("DURATION", &self.DURATION());
      ds.field("SRCH_PATTERN", &self.SRCH_PATTERN());
      ds.field("SCENARIO", &self.SCENARIO());
      ds.field("ID_ELSET", &self.ID_ELSET());
      ds.field("ID_MANIFOLD", &self.ID_MANIFOLD());
      ds.field("ID_STATE_VECTOR", &self.ID_STATE_VECTOR());
      ds.field("ES_ID", &self.ES_ID());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RAAN", &self.RAAN());
      ds.field("ARG_OF_PERIGEE", &self.ARG_OF_PERIGEE());
      ds.field("MEAN_ANOMALY", &self.MEAN_ANOMALY());
      ds.field("RA", &self.RA());
      ds.field("DEC", &self.DEC());
      ds.field("AZ", &self.AZ());
      ds.field("EL", &self.EL());
      ds.field("RANGE", &self.RANGE());
      ds.field("EXTENT_AZ", &self.EXTENT_AZ());
      ds.field("EXTENT_EL", &self.EXTENT_EL());
      ds.field("EXTENT_RANGE", &self.EXTENT_RANGE());
      ds.field("LAT", &self.LAT());
      ds.field("LON", &self.LON());
      ds.field("ALT", &self.ALT());
      ds.field("STOP_LAT", &self.STOP_LAT());
      ds.field("STOP_LON", &self.STOP_LON());
      ds.field("STOP_ALT", &self.STOP_ALT());
      ds.field("SRCH_INC", &self.SRCH_INC());
      ds.field("X_ANGLE", &self.X_ANGLE());
      ds.field("Y_ANGLE", &self.Y_ANGLE());
      ds.field("ORIENT_ANGLE", &self.ORIENT_ANGLE());
      ds.field("CUSTOMER", &self.CUSTOMER());
      ds.field("NOTES", &self.NOTES());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("ORIGIN", &self.ORIGIN());
      ds.field("DATA_MODE", &self.DATA_MODE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CRMT {
  pub ID: Option<String>,
  pub CLASSIFICATION: Option<String>,
  pub TYPE: Option<String>,
  pub ID_PLAN: Option<String>,
  pub PLAN_INDEX: i32,
  pub TASK_ID: Option<String>,
  pub DWELL_ID: Option<String>,
  pub EXTERNAL_ID: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub OB_TYPE: Option<String>,
  pub PRIORITY: Option<String>,
  pub TASK_CATEGORY: i32,
  pub SUFFIX: Option<String>,
  pub UCT_FOLLOW_UP: bool,
  pub START_TIME: Option<String>,
  pub END_TIME: Option<String>,
  pub NORAD_CAT_ID: u32,
  pub ORIG_OBJECT_ID: Option<String>,
  pub TASK_GROUP: Option<String>,
  pub IRON: i32,
  pub ORBIT_REGIME: Option<String>,
  pub TARGET_SIZE: f64,
  pub RCS_MIN: f64,
  pub RCS: f64,
  pub RCS_MAX: f64,
  pub FREQ_MIN: f64,
  pub FREQ: f64,
  pub FREQ_MAX: f64,
  pub POLARIZATION: Option<String>,
  pub VIS_MAG_MIN: f64,
  pub VIS_MAG: f64,
  pub VIS_MAG_MAX: f64,
  pub SPECTRAL_MODEL: Option<String>,
  pub REFLECTANCE: f64,
  pub IRRADIANCE: f64,
  pub NUM_FRAMES: i32,
  pub FRAME_RATE: f64,
  pub INTEGRATION_TIME: f64,
  pub NUM_TRACKS: i32,
  pub NUM_OBS: i32,
  pub DURATION: i32,
  pub SRCH_PATTERN: Option<String>,
  pub SCENARIO: Option<String>,
  pub ID_ELSET: Option<String>,
  pub ID_MANIFOLD: Option<String>,
  pub ID_STATE_VECTOR: Option<String>,
  pub ES_ID: Option<String>,
  pub EPOCH: Option<String>,
  pub SEMI_MAJOR_AXIS: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RAAN: f64,
  pub ARG_OF_PERIGEE: f64,
  pub MEAN_ANOMALY: f64,
  pub RA: f64,
  pub DEC: f64,
  pub AZ: f64,
  pub EL: f64,
  pub RANGE: f64,
  pub EXTENT_AZ: f64,
  pub EXTENT_EL: f64,
  pub EXTENT_RANGE: f64,
  pub LAT: f64,
  pub LON: f64,
  pub ALT: f64,
  pub STOP_LAT: f64,
  pub STOP_LON: f64,
  pub STOP_ALT: f64,
  pub SRCH_INC: f64,
  pub X_ANGLE: f64,
  pub Y_ANGLE: f64,
  pub ORIENT_ANGLE: f64,
  pub CUSTOMER: Option<String>,
  pub NOTES: Option<String>,
  pub SOURCE: Option<String>,
  pub ORIGIN: Option<String>,
  pub DATA_MODE: Option<String>,
}
impl Default for CRMT {
  fn default() -> Self {
    Self {
      ID: None,
      CLASSIFICATION: None,
      TYPE: None,
      ID_PLAN: None,
      PLAN_INDEX: 0,
      TASK_ID: None,
      DWELL_ID: None,
      EXTERNAL_ID: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OB_TYPE: None,
      PRIORITY: None,
      TASK_CATEGORY: 0,
      SUFFIX: None,
      UCT_FOLLOW_UP: false,
      START_TIME: None,
      END_TIME: None,
      NORAD_CAT_ID: 0,
      ORIG_OBJECT_ID: None,
      TASK_GROUP: None,
      IRON: 0,
      ORBIT_REGIME: None,
      TARGET_SIZE: 0.0,
      RCS_MIN: 0.0,
      RCS: 0.0,
      RCS_MAX: 0.0,
      FREQ_MIN: 0.0,
      FREQ: 0.0,
      FREQ_MAX: 0.0,
      POLARIZATION: None,
      VIS_MAG_MIN: 0.0,
      VIS_MAG: 0.0,
      VIS_MAG_MAX: 0.0,
      SPECTRAL_MODEL: None,
      REFLECTANCE: 0.0,
      IRRADIANCE: 0.0,
      NUM_FRAMES: 0,
      FRAME_RATE: 0.0,
      INTEGRATION_TIME: 0.0,
      NUM_TRACKS: 0,
      NUM_OBS: 0,
      DURATION: 0,
      SRCH_PATTERN: None,
      SCENARIO: None,
      ID_ELSET: None,
      ID_MANIFOLD: None,
      ID_STATE_VECTOR: None,
      ES_ID: None,
      EPOCH: None,
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      RA: 0.0,
      DEC: 0.0,
      AZ: 0.0,
      EL: 0.0,
      RANGE: 0.0,
      EXTENT_AZ: 0.0,
      EXTENT_EL: 0.0,
      EXTENT_RANGE: 0.0,
      LAT: 0.0,
      LON: 0.0,
      ALT: 0.0,
      STOP_LAT: 0.0,
      STOP_LON: 0.0,
      STOP_ALT: 0.0,
      SRCH_INC: 0.0,
      X_ANGLE: 0.0,
      Y_ANGLE: 0.0,
      ORIENT_ANGLE: 0.0,
      CUSTOMER: None,
      NOTES: None,
      SOURCE: None,
      ORIGIN: None,
      DATA_MODE: None,
    }
  }
}
impl CRMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CRM<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLASSIFICATION = self.CLASSIFICATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_PLAN = self.ID_PLAN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PLAN_INDEX = self.PLAN_INDEX;
    let TASK_ID = self.TASK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DWELL_ID = self.DWELL_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EXTERNAL_ID = self.EXTERNAL_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_TYPE = self.OB_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIORITY = self.PRIORITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TASK_CATEGORY = self.TASK_CATEGORY;
    let SUFFIX = self.SUFFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UCT_FOLLOW_UP = self.UCT_FOLLOW_UP;
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END_TIME = self.END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID;
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TASK_GROUP = self.TASK_GROUP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IRON = self.IRON;
    let ORBIT_REGIME = self.ORBIT_REGIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TARGET_SIZE = self.TARGET_SIZE;
    let RCS_MIN = self.RCS_MIN;
    let RCS = self.RCS;
    let RCS_MAX = self.RCS_MAX;
    let FREQ_MIN = self.FREQ_MIN;
    let FREQ = self.FREQ;
    let FREQ_MAX = self.FREQ_MAX;
    let POLARIZATION = self.POLARIZATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VIS_MAG_MIN = self.VIS_MAG_MIN;
    let VIS_MAG = self.VIS_MAG;
    let VIS_MAG_MAX = self.VIS_MAG_MAX;
    let SPECTRAL_MODEL = self.SPECTRAL_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REFLECTANCE = self.REFLECTANCE;
    let IRRADIANCE = self.IRRADIANCE;
    let NUM_FRAMES = self.NUM_FRAMES;
    let FRAME_RATE = self.FRAME_RATE;
    let INTEGRATION_TIME = self.INTEGRATION_TIME;
    let NUM_TRACKS = self.NUM_TRACKS;
    let NUM_OBS = self.NUM_OBS;
    let DURATION = self.DURATION;
    let SRCH_PATTERN = self.SRCH_PATTERN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCENARIO = self.SCENARIO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_ELSET = self.ID_ELSET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_MANIFOLD = self.ID_MANIFOLD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_STATE_VECTOR = self.ID_STATE_VECTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ES_ID = self.ES_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RAAN = self.RAAN;
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE;
    let MEAN_ANOMALY = self.MEAN_ANOMALY;
    let RA = self.RA;
    let DEC = self.DEC;
    let AZ = self.AZ;
    let EL = self.EL;
    let RANGE = self.RANGE;
    let EXTENT_AZ = self.EXTENT_AZ;
    let EXTENT_EL = self.EXTENT_EL;
    let EXTENT_RANGE = self.EXTENT_RANGE;
    let LAT = self.LAT;
    let LON = self.LON;
    let ALT = self.ALT;
    let STOP_LAT = self.STOP_LAT;
    let STOP_LON = self.STOP_LON;
    let STOP_ALT = self.STOP_ALT;
    let SRCH_INC = self.SRCH_INC;
    let X_ANGLE = self.X_ANGLE;
    let Y_ANGLE = self.Y_ANGLE;
    let ORIENT_ANGLE = self.ORIENT_ANGLE;
    let CUSTOMER = self.CUSTOMER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGIN = self.ORIGIN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_MODE = self.DATA_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CRM::create(_fbb, &CRMArgs{
      ID,
      CLASSIFICATION,
      TYPE,
      ID_PLAN,
      PLAN_INDEX,
      TASK_ID,
      DWELL_ID,
      EXTERNAL_ID,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OB_TYPE,
      PRIORITY,
      TASK_CATEGORY,
      SUFFIX,
      UCT_FOLLOW_UP,
      START_TIME,
      END_TIME,
      NORAD_CAT_ID,
      ORIG_OBJECT_ID,
      TASK_GROUP,
      IRON,
      ORBIT_REGIME,
      TARGET_SIZE,
      RCS_MIN,
      RCS,
      RCS_MAX,
      FREQ_MIN,
      FREQ,
      FREQ_MAX,
      POLARIZATION,
      VIS_MAG_MIN,
      VIS_MAG,
      VIS_MAG_MAX,
      SPECTRAL_MODEL,
      REFLECTANCE,
      IRRADIANCE,
      NUM_FRAMES,
      FRAME_RATE,
      INTEGRATION_TIME,
      NUM_TRACKS,
      NUM_OBS,
      DURATION,
      SRCH_PATTERN,
      SCENARIO,
      ID_ELSET,
      ID_MANIFOLD,
      ID_STATE_VECTOR,
      ES_ID,
      EPOCH,
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      RA,
      DEC,
      AZ,
      EL,
      RANGE,
      EXTENT_AZ,
      EXTENT_EL,
      EXTENT_RANGE,
      LAT,
      LON,
      ALT,
      STOP_LAT,
      STOP_LON,
      STOP_ALT,
      SRCH_INC,
      X_ANGLE,
      Y_ANGLE,
      ORIENT_ANGLE,
      CUSTOMER,
      NOTES,
      SOURCE,
      ORIGIN,
      DATA_MODE,
    })
  }
}
pub enum CRMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of CRM records
pub struct CRMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CRMCOLLECTION<'a> {
  type Inner = CRMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CRMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CRMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CRMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<CRMCOLLECTION<'bldr>> {
    let mut builder = CRMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CRMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    CRMCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CRM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CRM>>>>(CRMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for CRMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CRM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct CRMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CRM<'a>>>>>,
}
impl<'a> Default for CRMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    CRMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct CRMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CRMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CRM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CRMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CRMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CRMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CRMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CRMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CRMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CRMCOLLECTIONT {
  pub RECORDS: Option<Vec<CRMT>>,
}
impl Default for CRMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl CRMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CRMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    CRMCOLLECTION::create(_fbb, &CRMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CRMCOLLECTION`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CRMCOLLECTION_unchecked`.
pub fn root_as_CRMCOLLECTION(buf: &[u8]) -> Result<CRMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CRMCOLLECTION>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CRMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_CRMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_CRMCOLLECTION(buf: &[u8]) -> Result<CRMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CRMCOLLECTION>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CRMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CRMCOLLECTION_unchecked`.
pub fn root_as_CRMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CRMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CRMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CRMCOLLECTION` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CRMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_CRMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CRMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CRMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CRMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CRMCOLLECTION`.
pub unsafe fn root_as_CRMCOLLECTION_unchecked(buf: &[u8]) -> CRMCOLLECTION {
  flatbuffers::root_unchecked::<CRMCOLLECTION>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CRMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CRMCOLLECTION`.
pub unsafe fn size_prefixed_root_as_CRMCOLLECTION_unchecked(buf: &[u8]) -> CRMCOLLECTION {
  flatbuffers::size_prefixed_root_unchecked::<CRMCOLLECTION>(buf)
}
pub const CRMCOLLECTION_IDENTIFIER: &str = "$CRM";

#[inline]
pub fn CRMCOLLECTION_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CRMCOLLECTION_IDENTIFIER, false)
}

#[inline]
pub fn CRMCOLLECTION_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CRMCOLLECTION_IDENTIFIER, true)
}

#[inline]
pub fn finish_CRMCOLLECTION_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<CRMCOLLECTION<'a>>) {
  fbb.finish(root, Some(CRMCOLLECTION_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_CRMCOLLECTION_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<CRMCOLLECTION<'a>>) {
  fbb.finish_size_prefixed(root, Some(CRMCOLLECTION_IDENTIFIER));
}
