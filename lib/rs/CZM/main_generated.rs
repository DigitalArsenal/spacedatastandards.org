// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CZMHEIGHT_REFERENCE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CZMHEIGHT_REFERENCE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CZMHEIGHT_REFERENCE: [CZMHeightReference; 3] = [
  CZMHeightReference::NONE,
  CZMHeightReference::CLAMP_TO_GROUND,
  CZMHeightReference::RELATIVE_TO_GROUND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CZMHeightReference(pub i8);
#[allow(non_upper_case_globals)]
impl CZMHeightReference {
  pub const NONE: Self = Self(0);
  pub const CLAMP_TO_GROUND: Self = Self(1);
  pub const RELATIVE_TO_GROUND: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CLAMP_TO_GROUND,
    Self::RELATIVE_TO_GROUND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CLAMP_TO_GROUND => Some("CLAMP_TO_GROUND"),
      Self::RELATIVE_TO_GROUND => Some("RELATIVE_TO_GROUND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CZMHeightReference {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CZMHeightReference {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CZMHeightReference {
    type Output = CZMHeightReference;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CZMHeightReference {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CZMHeightReference {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CZMHeightReference {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CZMCLASSIFICATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CZMCLASSIFICATION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CZMCLASSIFICATION_TYPE: [CZMClassificationType; 3] = [
  CZMClassificationType::TERRAIN,
  CZMClassificationType::CESIUM_3D_TILE,
  CZMClassificationType::BOTH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CZMClassificationType(pub i8);
#[allow(non_upper_case_globals)]
impl CZMClassificationType {
  pub const TERRAIN: Self = Self(0);
  pub const CESIUM_3D_TILE: Self = Self(1);
  pub const BOTH: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TERRAIN,
    Self::CESIUM_3D_TILE,
    Self::BOTH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TERRAIN => Some("TERRAIN"),
      Self::CESIUM_3D_TILE => Some("CESIUM_3D_TILE"),
      Self::BOTH => Some("BOTH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CZMClassificationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CZMClassificationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CZMClassificationType {
    type Output = CZMClassificationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CZMClassificationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CZMClassificationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CZMClassificationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CZMLABEL_STYLE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CZMLABEL_STYLE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CZMLABEL_STYLE: [CZMLabelStyle; 3] = [
  CZMLabelStyle::FILL,
  CZMLabelStyle::OUTLINE,
  CZMLabelStyle::FILL_AND_OUTLINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CZMLabelStyle(pub i8);
#[allow(non_upper_case_globals)]
impl CZMLabelStyle {
  pub const FILL: Self = Self(0);
  pub const OUTLINE: Self = Self(1);
  pub const FILL_AND_OUTLINE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FILL,
    Self::OUTLINE,
    Self::FILL_AND_OUTLINE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FILL => Some("FILL"),
      Self::OUTLINE => Some("OUTLINE"),
      Self::FILL_AND_OUTLINE => Some("FILL_AND_OUTLINE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CZMLabelStyle {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CZMLabelStyle {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CZMLabelStyle {
    type Output = CZMLabelStyle;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CZMLabelStyle {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CZMLabelStyle {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CZMLabelStyle {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CZMHORIZONTAL_ORIGIN: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CZMHORIZONTAL_ORIGIN: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CZMHORIZONTAL_ORIGIN: [CZMHorizontalOrigin; 3] = [
  CZMHorizontalOrigin::LEFT,
  CZMHorizontalOrigin::CENTER,
  CZMHorizontalOrigin::RIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CZMHorizontalOrigin(pub i8);
#[allow(non_upper_case_globals)]
impl CZMHorizontalOrigin {
  pub const LEFT: Self = Self(0);
  pub const CENTER: Self = Self(1);
  pub const RIGHT: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT,
    Self::CENTER,
    Self::RIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEFT => Some("LEFT"),
      Self::CENTER => Some("CENTER"),
      Self::RIGHT => Some("RIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CZMHorizontalOrigin {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CZMHorizontalOrigin {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CZMHorizontalOrigin {
    type Output = CZMHorizontalOrigin;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CZMHorizontalOrigin {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CZMHorizontalOrigin {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CZMHorizontalOrigin {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CZMVERTICAL_ORIGIN: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CZMVERTICAL_ORIGIN: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CZMVERTICAL_ORIGIN: [CZMVerticalOrigin; 4] = [
  CZMVerticalOrigin::BASELINE,
  CZMVerticalOrigin::BOTTOM,
  CZMVerticalOrigin::CENTER,
  CZMVerticalOrigin::TOP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CZMVerticalOrigin(pub i8);
#[allow(non_upper_case_globals)]
impl CZMVerticalOrigin {
  pub const BASELINE: Self = Self(0);
  pub const BOTTOM: Self = Self(1);
  pub const CENTER: Self = Self(2);
  pub const TOP: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BASELINE,
    Self::BOTTOM,
    Self::CENTER,
    Self::TOP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BASELINE => Some("BASELINE"),
      Self::BOTTOM => Some("BOTTOM"),
      Self::CENTER => Some("CENTER"),
      Self::TOP => Some("TOP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CZMVerticalOrigin {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CZMVerticalOrigin {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CZMVerticalOrigin {
    type Output = CZMVerticalOrigin;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CZMVerticalOrigin {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CZMVerticalOrigin {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CZMVerticalOrigin {}
pub enum CZMIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Time interval for time-dynamic properties
pub struct CZMInterval<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMInterval<'a> {
  type Inner = CZMInterval<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMInterval<'a> {
  pub const VT_INTERVAL: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMInterval { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMIntervalArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMInterval<'bldr>> {
    let mut builder = CZMIntervalBuilder::new(_fbb);
    if let Some(x) = args.INTERVAL { builder.add_INTERVAL(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CZMIntervalT {
    let INTERVAL = self.INTERVAL().map(|x| {
      x.to_string()
    });
    CZMIntervalT {
      INTERVAL,
    }
  }

  /// ISO 8601 interval string (e.g. "2012-03-15T10:00:00Z/2012-03-16T10:00:00Z")
  #[inline]
  pub fn INTERVAL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMInterval::VT_INTERVAL, None)}
  }
}

impl flatbuffers::Verifiable for CZMInterval<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INTERVAL", Self::VT_INTERVAL, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMIntervalArgs<'a> {
    pub INTERVAL: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CZMIntervalArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMIntervalArgs {
      INTERVAL: None,
    }
  }
}

pub struct CZMIntervalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMIntervalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_INTERVAL(&mut self, INTERVAL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMInterval::VT_INTERVAL, INTERVAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMIntervalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMIntervalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMInterval<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMInterval<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMInterval");
      ds.field("INTERVAL", &self.INTERVAL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMIntervalT {
  pub INTERVAL: Option<String>,
}
impl Default for CZMIntervalT {
  fn default() -> Self {
    Self {
      INTERVAL: None,
    }
  }
}
impl CZMIntervalT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMInterval<'b>> {
    let INTERVAL = self.INTERVAL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CZMInterval::create(_fbb, &CZMIntervalArgs{
      INTERVAL,
    })
  }
}
pub enum CZMCartographicDegreesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Cartographic position (longitude, latitude, height in radians/meters)
pub struct CZMCartographicDegrees<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMCartographicDegrees<'a> {
  type Inner = CZMCartographicDegrees<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMCartographicDegrees<'a> {
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMCartographicDegrees { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMCartographicDegreesArgs
  ) -> flatbuffers::WIPOffset<CZMCartographicDegrees<'bldr>> {
    let mut builder = CZMCartographicDegreesBuilder::new(_fbb);
    builder.add_HEIGHT(args.HEIGHT);
    builder.add_LATITUDE(args.LATITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMCartographicDegreesT {
    let LONGITUDE = self.LONGITUDE();
    let LATITUDE = self.LATITUDE();
    let HEIGHT = self.HEIGHT();
    CZMCartographicDegreesT {
      LONGITUDE,
      LATITUDE,
      HEIGHT,
    }
  }

  /// Longitude in degrees
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartographicDegrees::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Latitude in degrees
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartographicDegrees::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Height in meters above WGS84 ellipsoid
  #[inline]
  pub fn HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartographicDegrees::VT_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMCartographicDegrees<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("HEIGHT", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMCartographicDegreesArgs {
    pub LONGITUDE: f64,
    pub LATITUDE: f64,
    pub HEIGHT: f64,
}
impl<'a> Default for CZMCartographicDegreesArgs {
  #[inline]
  fn default() -> Self {
    CZMCartographicDegreesArgs {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      HEIGHT: 0.0,
    }
  }
}

pub struct CZMCartographicDegreesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMCartographicDegreesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(CZMCartographicDegrees::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(CZMCartographicDegrees::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_HEIGHT(&mut self, HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(CZMCartographicDegrees::VT_HEIGHT, HEIGHT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMCartographicDegreesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMCartographicDegreesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMCartographicDegrees<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMCartographicDegrees<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMCartographicDegrees");
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("HEIGHT", &self.HEIGHT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMCartographicDegreesT {
  pub LONGITUDE: f64,
  pub LATITUDE: f64,
  pub HEIGHT: f64,
}
impl Default for CZMCartographicDegreesT {
  fn default() -> Self {
    Self {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      HEIGHT: 0.0,
    }
  }
}
impl CZMCartographicDegreesT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMCartographicDegrees<'b>> {
    let LONGITUDE = self.LONGITUDE;
    let LATITUDE = self.LATITUDE;
    let HEIGHT = self.HEIGHT;
    CZMCartographicDegrees::create(_fbb, &CZMCartographicDegreesArgs{
      LONGITUDE,
      LATITUDE,
      HEIGHT,
    })
  }
}
pub enum CZMCartesianOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Cartesian position (X, Y, Z in meters)
pub struct CZMCartesian<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMCartesian<'a> {
  type Inner = CZMCartesian<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMCartesian<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_Z: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMCartesian { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMCartesianArgs
  ) -> flatbuffers::WIPOffset<CZMCartesian<'bldr>> {
    let mut builder = CZMCartesianBuilder::new(_fbb);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMCartesianT {
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    CZMCartesianT {
      X,
      Y,
      Z,
    }
  }

  /// X component in meters (Earth-fixed)
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartesian::VT_X, Some(0.0)).unwrap()}
  }
  /// Y component in meters (Earth-fixed)
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartesian::VT_Y, Some(0.0)).unwrap()}
  }
  /// Z component in meters (Earth-fixed)
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMCartesian::VT_Z, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMCartesian<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMCartesianArgs {
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
}
impl<'a> Default for CZMCartesianArgs {
  #[inline]
  fn default() -> Self {
    CZMCartesianArgs {
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
    }
  }
}

pub struct CZMCartesianBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMCartesianBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(CZMCartesian::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(CZMCartesian::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(CZMCartesian::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMCartesianBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMCartesianBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMCartesian<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMCartesian<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMCartesian");
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMCartesianT {
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
}
impl Default for CZMCartesianT {
  fn default() -> Self {
    Self {
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
    }
  }
}
impl CZMCartesianT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMCartesian<'b>> {
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    CZMCartesian::create(_fbb, &CZMCartesianArgs{
      X,
      Y,
      Z,
    })
  }
}
pub enum CZMColorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// RGBA color
pub struct CZMColor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMColor<'a> {
  type Inner = CZMColor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMColor<'a> {
  pub const VT_RED: flatbuffers::VOffsetT = 4;
  pub const VT_GREEN: flatbuffers::VOffsetT = 6;
  pub const VT_BLUE: flatbuffers::VOffsetT = 8;
  pub const VT_ALPHA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMColor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMColorArgs
  ) -> flatbuffers::WIPOffset<CZMColor<'bldr>> {
    let mut builder = CZMColorBuilder::new(_fbb);
    builder.add_ALPHA(args.ALPHA);
    builder.add_BLUE(args.BLUE);
    builder.add_GREEN(args.GREEN);
    builder.add_RED(args.RED);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMColorT {
    let RED = self.RED();
    let GREEN = self.GREEN();
    let BLUE = self.BLUE();
    let ALPHA = self.ALPHA();
    CZMColorT {
      RED,
      GREEN,
      BLUE,
      ALPHA,
    }
  }

  /// Red component (0-255)
  #[inline]
  pub fn RED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CZMColor::VT_RED, Some(0)).unwrap()}
  }
  /// Green component (0-255)
  #[inline]
  pub fn GREEN(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CZMColor::VT_GREEN, Some(0)).unwrap()}
  }
  /// Blue component (0-255)
  #[inline]
  pub fn BLUE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CZMColor::VT_BLUE, Some(0)).unwrap()}
  }
  /// Alpha component (0-255)
  #[inline]
  pub fn ALPHA(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CZMColor::VT_ALPHA, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMColor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("RED", Self::VT_RED, false)?
     .visit_field::<u8>("GREEN", Self::VT_GREEN, false)?
     .visit_field::<u8>("BLUE", Self::VT_BLUE, false)?
     .visit_field::<u8>("ALPHA", Self::VT_ALPHA, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMColorArgs {
    pub RED: u8,
    pub GREEN: u8,
    pub BLUE: u8,
    pub ALPHA: u8,
}
impl<'a> Default for CZMColorArgs {
  #[inline]
  fn default() -> Self {
    CZMColorArgs {
      RED: 0,
      GREEN: 0,
      BLUE: 0,
      ALPHA: 0,
    }
  }
}

pub struct CZMColorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMColorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RED(&mut self, RED: u8) {
    self.fbb_.push_slot::<u8>(CZMColor::VT_RED, RED, 0);
  }
  #[inline]
  pub fn add_GREEN(&mut self, GREEN: u8) {
    self.fbb_.push_slot::<u8>(CZMColor::VT_GREEN, GREEN, 0);
  }
  #[inline]
  pub fn add_BLUE(&mut self, BLUE: u8) {
    self.fbb_.push_slot::<u8>(CZMColor::VT_BLUE, BLUE, 0);
  }
  #[inline]
  pub fn add_ALPHA(&mut self, ALPHA: u8) {
    self.fbb_.push_slot::<u8>(CZMColor::VT_ALPHA, ALPHA, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMColorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMColor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMColor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMColor");
      ds.field("RED", &self.RED());
      ds.field("GREEN", &self.GREEN());
      ds.field("BLUE", &self.BLUE());
      ds.field("ALPHA", &self.ALPHA());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMColorT {
  pub RED: u8,
  pub GREEN: u8,
  pub BLUE: u8,
  pub ALPHA: u8,
}
impl Default for CZMColorT {
  fn default() -> Self {
    Self {
      RED: 0,
      GREEN: 0,
      BLUE: 0,
      ALPHA: 0,
    }
  }
}
impl CZMColorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMColor<'b>> {
    let RED = self.RED;
    let GREEN = self.GREEN;
    let BLUE = self.BLUE;
    let ALPHA = self.ALPHA;
    CZMColor::create(_fbb, &CZMColorArgs{
      RED,
      GREEN,
      BLUE,
      ALPHA,
    })
  }
}
pub enum CZMNearFarScalarOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Near/Far scalar for distance-based display
pub struct CZMNearFarScalar<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMNearFarScalar<'a> {
  type Inner = CZMNearFarScalar<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMNearFarScalar<'a> {
  pub const VT_NEAR_DISTANCE: flatbuffers::VOffsetT = 4;
  pub const VT_NEAR_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_FAR_DISTANCE: flatbuffers::VOffsetT = 8;
  pub const VT_FAR_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMNearFarScalar { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMNearFarScalarArgs
  ) -> flatbuffers::WIPOffset<CZMNearFarScalar<'bldr>> {
    let mut builder = CZMNearFarScalarBuilder::new(_fbb);
    builder.add_FAR_VALUE(args.FAR_VALUE);
    builder.add_FAR_DISTANCE(args.FAR_DISTANCE);
    builder.add_NEAR_VALUE(args.NEAR_VALUE);
    builder.add_NEAR_DISTANCE(args.NEAR_DISTANCE);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMNearFarScalarT {
    let NEAR_DISTANCE = self.NEAR_DISTANCE();
    let NEAR_VALUE = self.NEAR_VALUE();
    let FAR_DISTANCE = self.FAR_DISTANCE();
    let FAR_VALUE = self.FAR_VALUE();
    CZMNearFarScalarT {
      NEAR_DISTANCE,
      NEAR_VALUE,
      FAR_DISTANCE,
      FAR_VALUE,
    }
  }

  /// Near distance in meters
  #[inline]
  pub fn NEAR_DISTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMNearFarScalar::VT_NEAR_DISTANCE, Some(0.0)).unwrap()}
  }
  /// Value at near distance
  #[inline]
  pub fn NEAR_VALUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMNearFarScalar::VT_NEAR_VALUE, Some(0.0)).unwrap()}
  }
  /// Far distance in meters
  #[inline]
  pub fn FAR_DISTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMNearFarScalar::VT_FAR_DISTANCE, Some(0.0)).unwrap()}
  }
  /// Value at far distance
  #[inline]
  pub fn FAR_VALUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMNearFarScalar::VT_FAR_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMNearFarScalar<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("NEAR_DISTANCE", Self::VT_NEAR_DISTANCE, false)?
     .visit_field::<f64>("NEAR_VALUE", Self::VT_NEAR_VALUE, false)?
     .visit_field::<f64>("FAR_DISTANCE", Self::VT_FAR_DISTANCE, false)?
     .visit_field::<f64>("FAR_VALUE", Self::VT_FAR_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMNearFarScalarArgs {
    pub NEAR_DISTANCE: f64,
    pub NEAR_VALUE: f64,
    pub FAR_DISTANCE: f64,
    pub FAR_VALUE: f64,
}
impl<'a> Default for CZMNearFarScalarArgs {
  #[inline]
  fn default() -> Self {
    CZMNearFarScalarArgs {
      NEAR_DISTANCE: 0.0,
      NEAR_VALUE: 0.0,
      FAR_DISTANCE: 0.0,
      FAR_VALUE: 0.0,
    }
  }
}

pub struct CZMNearFarScalarBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMNearFarScalarBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NEAR_DISTANCE(&mut self, NEAR_DISTANCE: f64) {
    self.fbb_.push_slot::<f64>(CZMNearFarScalar::VT_NEAR_DISTANCE, NEAR_DISTANCE, 0.0);
  }
  #[inline]
  pub fn add_NEAR_VALUE(&mut self, NEAR_VALUE: f64) {
    self.fbb_.push_slot::<f64>(CZMNearFarScalar::VT_NEAR_VALUE, NEAR_VALUE, 0.0);
  }
  #[inline]
  pub fn add_FAR_DISTANCE(&mut self, FAR_DISTANCE: f64) {
    self.fbb_.push_slot::<f64>(CZMNearFarScalar::VT_FAR_DISTANCE, FAR_DISTANCE, 0.0);
  }
  #[inline]
  pub fn add_FAR_VALUE(&mut self, FAR_VALUE: f64) {
    self.fbb_.push_slot::<f64>(CZMNearFarScalar::VT_FAR_VALUE, FAR_VALUE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMNearFarScalarBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMNearFarScalarBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMNearFarScalar<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMNearFarScalar<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMNearFarScalar");
      ds.field("NEAR_DISTANCE", &self.NEAR_DISTANCE());
      ds.field("NEAR_VALUE", &self.NEAR_VALUE());
      ds.field("FAR_DISTANCE", &self.FAR_DISTANCE());
      ds.field("FAR_VALUE", &self.FAR_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMNearFarScalarT {
  pub NEAR_DISTANCE: f64,
  pub NEAR_VALUE: f64,
  pub FAR_DISTANCE: f64,
  pub FAR_VALUE: f64,
}
impl Default for CZMNearFarScalarT {
  fn default() -> Self {
    Self {
      NEAR_DISTANCE: 0.0,
      NEAR_VALUE: 0.0,
      FAR_DISTANCE: 0.0,
      FAR_VALUE: 0.0,
    }
  }
}
impl CZMNearFarScalarT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMNearFarScalar<'b>> {
    let NEAR_DISTANCE = self.NEAR_DISTANCE;
    let NEAR_VALUE = self.NEAR_VALUE;
    let FAR_DISTANCE = self.FAR_DISTANCE;
    let FAR_VALUE = self.FAR_VALUE;
    CZMNearFarScalar::create(_fbb, &CZMNearFarScalarArgs{
      NEAR_DISTANCE,
      NEAR_VALUE,
      FAR_DISTANCE,
      FAR_VALUE,
    })
  }
}
pub enum CZMBillboardOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Billboard (icon) properties
pub struct CZMBillboard<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMBillboard<'a> {
  type Inner = CZMBillboard<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMBillboard<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_COLOR: flatbuffers::VOffsetT = 10;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 12;
  pub const VT_PIXEL_OFFSET_X: flatbuffers::VOffsetT = 14;
  pub const VT_PIXEL_OFFSET_Y: flatbuffers::VOffsetT = 16;
  pub const VT_HORIZONTAL_ORIGIN: flatbuffers::VOffsetT = 18;
  pub const VT_VERTICAL_ORIGIN: flatbuffers::VOffsetT = 20;
  pub const VT_TRANSLUCENCY_BY_DISTANCE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMBillboard { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMBillboardArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMBillboard<'bldr>> {
    let mut builder = CZMBillboardBuilder::new(_fbb);
    builder.add_PIXEL_OFFSET_Y(args.PIXEL_OFFSET_Y);
    builder.add_PIXEL_OFFSET_X(args.PIXEL_OFFSET_X);
    builder.add_SCALE(args.SCALE);
    if let Some(x) = args.TRANSLUCENCY_BY_DISTANCE { builder.add_TRANSLUCENCY_BY_DISTANCE(x); }
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    if let Some(x) = args.IMAGE { builder.add_IMAGE(x); }
    builder.add_VERTICAL_ORIGIN(args.VERTICAL_ORIGIN);
    builder.add_HORIZONTAL_ORIGIN(args.HORIZONTAL_ORIGIN);
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMBillboardT {
    let SHOW = self.SHOW();
    let IMAGE = self.IMAGE().map(|x| {
      x.to_string()
    });
    let SCALE = self.SCALE();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    let PIXEL_OFFSET_X = self.PIXEL_OFFSET_X();
    let PIXEL_OFFSET_Y = self.PIXEL_OFFSET_Y();
    let HORIZONTAL_ORIGIN = self.HORIZONTAL_ORIGIN();
    let VERTICAL_ORIGIN = self.VERTICAL_ORIGIN();
    let TRANSLUCENCY_BY_DISTANCE = self.TRANSLUCENCY_BY_DISTANCE().map(|x| {
      Box::new(x.unpack())
    });
    CZMBillboardT {
      SHOW,
      IMAGE,
      SCALE,
      COLOR,
      HEIGHT_REFERENCE,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      TRANSLUCENCY_BY_DISTANCE,
    }
  }

  /// Whether the billboard is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMBillboard::VT_SHOW, Some(false)).unwrap()}
  }
  /// URI of the billboard image
  #[inline]
  pub fn IMAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMBillboard::VT_IMAGE, None)}
  }
  /// Scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMBillboard::VT_SCALE, Some(0.0)).unwrap()}
  }
  /// Billboard color tint
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMBillboard::VT_COLOR, None)}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMBillboard::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
  /// Pixel offset X
  #[inline]
  pub fn PIXEL_OFFSET_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMBillboard::VT_PIXEL_OFFSET_X, Some(0.0)).unwrap()}
  }
  /// Pixel offset Y
  #[inline]
  pub fn PIXEL_OFFSET_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMBillboard::VT_PIXEL_OFFSET_Y, Some(0.0)).unwrap()}
  }
  /// Horizontal origin
  #[inline]
  pub fn HORIZONTAL_ORIGIN(&self) -> CZMHorizontalOrigin {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHorizontalOrigin>(CZMBillboard::VT_HORIZONTAL_ORIGIN, Some(CZMHorizontalOrigin::LEFT)).unwrap()}
  }
  /// Vertical origin
  #[inline]
  pub fn VERTICAL_ORIGIN(&self) -> CZMVerticalOrigin {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMVerticalOrigin>(CZMBillboard::VT_VERTICAL_ORIGIN, Some(CZMVerticalOrigin::BASELINE)).unwrap()}
  }
  /// Translucency by distance
  #[inline]
  pub fn TRANSLUCENCY_BY_DISTANCE(&self) -> Option<CZMNearFarScalar<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMNearFarScalar>>(CZMBillboard::VT_TRANSLUCENCY_BY_DISTANCE, None)}
  }
}

impl flatbuffers::Verifiable for CZMBillboard<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMAGE", Self::VT_IMAGE, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .visit_field::<f64>("PIXEL_OFFSET_X", Self::VT_PIXEL_OFFSET_X, false)?
     .visit_field::<f64>("PIXEL_OFFSET_Y", Self::VT_PIXEL_OFFSET_Y, false)?
     .visit_field::<CZMHorizontalOrigin>("HORIZONTAL_ORIGIN", Self::VT_HORIZONTAL_ORIGIN, false)?
     .visit_field::<CZMVerticalOrigin>("VERTICAL_ORIGIN", Self::VT_VERTICAL_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMNearFarScalar>>("TRANSLUCENCY_BY_DISTANCE", Self::VT_TRANSLUCENCY_BY_DISTANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMBillboardArgs<'a> {
    pub SHOW: bool,
    pub IMAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCALE: f64,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub HEIGHT_REFERENCE: CZMHeightReference,
    pub PIXEL_OFFSET_X: f64,
    pub PIXEL_OFFSET_Y: f64,
    pub HORIZONTAL_ORIGIN: CZMHorizontalOrigin,
    pub VERTICAL_ORIGIN: CZMVerticalOrigin,
    pub TRANSLUCENCY_BY_DISTANCE: Option<flatbuffers::WIPOffset<CZMNearFarScalar<'a>>>,
}
impl<'a> Default for CZMBillboardArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMBillboardArgs {
      SHOW: false,
      IMAGE: None,
      SCALE: 0.0,
      COLOR: None,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      PIXEL_OFFSET_X: 0.0,
      PIXEL_OFFSET_Y: 0.0,
      HORIZONTAL_ORIGIN: CZMHorizontalOrigin::LEFT,
      VERTICAL_ORIGIN: CZMVerticalOrigin::BASELINE,
      TRANSLUCENCY_BY_DISTANCE: None,
    }
  }
}

pub struct CZMBillboardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMBillboardBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMBillboard::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_IMAGE(&mut self, IMAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMBillboard::VT_IMAGE, IMAGE);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(CZMBillboard::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMBillboard::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMBillboard::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn add_PIXEL_OFFSET_X(&mut self, PIXEL_OFFSET_X: f64) {
    self.fbb_.push_slot::<f64>(CZMBillboard::VT_PIXEL_OFFSET_X, PIXEL_OFFSET_X, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_OFFSET_Y(&mut self, PIXEL_OFFSET_Y: f64) {
    self.fbb_.push_slot::<f64>(CZMBillboard::VT_PIXEL_OFFSET_Y, PIXEL_OFFSET_Y, 0.0);
  }
  #[inline]
  pub fn add_HORIZONTAL_ORIGIN(&mut self, HORIZONTAL_ORIGIN: CZMHorizontalOrigin) {
    self.fbb_.push_slot::<CZMHorizontalOrigin>(CZMBillboard::VT_HORIZONTAL_ORIGIN, HORIZONTAL_ORIGIN, CZMHorizontalOrigin::LEFT);
  }
  #[inline]
  pub fn add_VERTICAL_ORIGIN(&mut self, VERTICAL_ORIGIN: CZMVerticalOrigin) {
    self.fbb_.push_slot::<CZMVerticalOrigin>(CZMBillboard::VT_VERTICAL_ORIGIN, VERTICAL_ORIGIN, CZMVerticalOrigin::BASELINE);
  }
  #[inline]
  pub fn add_TRANSLUCENCY_BY_DISTANCE(&mut self, TRANSLUCENCY_BY_DISTANCE: flatbuffers::WIPOffset<CZMNearFarScalar<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMNearFarScalar>>(CZMBillboard::VT_TRANSLUCENCY_BY_DISTANCE, TRANSLUCENCY_BY_DISTANCE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMBillboardBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMBillboardBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMBillboard<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMBillboard<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMBillboard");
      ds.field("SHOW", &self.SHOW());
      ds.field("IMAGE", &self.IMAGE());
      ds.field("SCALE", &self.SCALE());
      ds.field("COLOR", &self.COLOR());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.field("PIXEL_OFFSET_X", &self.PIXEL_OFFSET_X());
      ds.field("PIXEL_OFFSET_Y", &self.PIXEL_OFFSET_Y());
      ds.field("HORIZONTAL_ORIGIN", &self.HORIZONTAL_ORIGIN());
      ds.field("VERTICAL_ORIGIN", &self.VERTICAL_ORIGIN());
      ds.field("TRANSLUCENCY_BY_DISTANCE", &self.TRANSLUCENCY_BY_DISTANCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMBillboardT {
  pub SHOW: bool,
  pub IMAGE: Option<String>,
  pub SCALE: f64,
  pub COLOR: Option<Box<CZMColorT>>,
  pub HEIGHT_REFERENCE: CZMHeightReference,
  pub PIXEL_OFFSET_X: f64,
  pub PIXEL_OFFSET_Y: f64,
  pub HORIZONTAL_ORIGIN: CZMHorizontalOrigin,
  pub VERTICAL_ORIGIN: CZMVerticalOrigin,
  pub TRANSLUCENCY_BY_DISTANCE: Option<Box<CZMNearFarScalarT>>,
}
impl Default for CZMBillboardT {
  fn default() -> Self {
    Self {
      SHOW: false,
      IMAGE: None,
      SCALE: 0.0,
      COLOR: None,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      PIXEL_OFFSET_X: 0.0,
      PIXEL_OFFSET_Y: 0.0,
      HORIZONTAL_ORIGIN: CZMHorizontalOrigin::LEFT,
      VERTICAL_ORIGIN: CZMVerticalOrigin::BASELINE,
      TRANSLUCENCY_BY_DISTANCE: None,
    }
  }
}
impl CZMBillboardT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMBillboard<'b>> {
    let SHOW = self.SHOW;
    let IMAGE = self.IMAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCALE = self.SCALE;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    let PIXEL_OFFSET_X = self.PIXEL_OFFSET_X;
    let PIXEL_OFFSET_Y = self.PIXEL_OFFSET_Y;
    let HORIZONTAL_ORIGIN = self.HORIZONTAL_ORIGIN;
    let VERTICAL_ORIGIN = self.VERTICAL_ORIGIN;
    let TRANSLUCENCY_BY_DISTANCE = self.TRANSLUCENCY_BY_DISTANCE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CZMBillboard::create(_fbb, &CZMBillboardArgs{
      SHOW,
      IMAGE,
      SCALE,
      COLOR,
      HEIGHT_REFERENCE,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      TRANSLUCENCY_BY_DISTANCE,
    })
  }
}
pub enum CZMLabelOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Label properties
pub struct CZMLabel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMLabel<'a> {
  type Inner = CZMLabel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMLabel<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT: flatbuffers::VOffsetT = 6;
  pub const VT_FONT: flatbuffers::VOffsetT = 8;
  pub const VT_STYLE: flatbuffers::VOffsetT = 10;
  pub const VT_FILL_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_OUTLINE_COLOR: flatbuffers::VOffsetT = 14;
  pub const VT_OUTLINE_WIDTH: flatbuffers::VOffsetT = 16;
  pub const VT_PIXEL_OFFSET_X: flatbuffers::VOffsetT = 18;
  pub const VT_PIXEL_OFFSET_Y: flatbuffers::VOffsetT = 20;
  pub const VT_SCALE: flatbuffers::VOffsetT = 22;
  pub const VT_HORIZONTAL_ORIGIN: flatbuffers::VOffsetT = 24;
  pub const VT_VERTICAL_ORIGIN: flatbuffers::VOffsetT = 26;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMLabel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMLabelArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMLabel<'bldr>> {
    let mut builder = CZMLabelBuilder::new(_fbb);
    builder.add_SCALE(args.SCALE);
    builder.add_PIXEL_OFFSET_Y(args.PIXEL_OFFSET_Y);
    builder.add_PIXEL_OFFSET_X(args.PIXEL_OFFSET_X);
    builder.add_OUTLINE_WIDTH(args.OUTLINE_WIDTH);
    if let Some(x) = args.OUTLINE_COLOR { builder.add_OUTLINE_COLOR(x); }
    if let Some(x) = args.FILL_COLOR { builder.add_FILL_COLOR(x); }
    if let Some(x) = args.FONT { builder.add_FONT(x); }
    if let Some(x) = args.TEXT { builder.add_TEXT(x); }
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_VERTICAL_ORIGIN(args.VERTICAL_ORIGIN);
    builder.add_HORIZONTAL_ORIGIN(args.HORIZONTAL_ORIGIN);
    builder.add_STYLE(args.STYLE);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMLabelT {
    let SHOW = self.SHOW();
    let TEXT = self.TEXT().map(|x| {
      x.to_string()
    });
    let FONT = self.FONT().map(|x| {
      x.to_string()
    });
    let STYLE = self.STYLE();
    let FILL_COLOR = self.FILL_COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE_COLOR = self.OUTLINE_COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE_WIDTH = self.OUTLINE_WIDTH();
    let PIXEL_OFFSET_X = self.PIXEL_OFFSET_X();
    let PIXEL_OFFSET_Y = self.PIXEL_OFFSET_Y();
    let SCALE = self.SCALE();
    let HORIZONTAL_ORIGIN = self.HORIZONTAL_ORIGIN();
    let VERTICAL_ORIGIN = self.VERTICAL_ORIGIN();
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    CZMLabelT {
      SHOW,
      TEXT,
      FONT,
      STYLE,
      FILL_COLOR,
      OUTLINE_COLOR,
      OUTLINE_WIDTH,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      SCALE,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      HEIGHT_REFERENCE,
    }
  }

  /// Whether the label is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMLabel::VT_SHOW, Some(false)).unwrap()}
  }
  /// Label text
  #[inline]
  pub fn TEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMLabel::VT_TEXT, None)}
  }
  /// Font CSS string (e.g. "12pt Lucida Console")
  #[inline]
  pub fn FONT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMLabel::VT_FONT, None)}
  }
  /// Label style
  #[inline]
  pub fn STYLE(&self) -> CZMLabelStyle {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMLabelStyle>(CZMLabel::VT_STYLE, Some(CZMLabelStyle::FILL)).unwrap()}
  }
  /// Fill color
  #[inline]
  pub fn FILL_COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMLabel::VT_FILL_COLOR, None)}
  }
  /// Outline color
  #[inline]
  pub fn OUTLINE_COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMLabel::VT_OUTLINE_COLOR, None)}
  }
  /// Outline width in pixels
  #[inline]
  pub fn OUTLINE_WIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMLabel::VT_OUTLINE_WIDTH, Some(0.0)).unwrap()}
  }
  /// Pixel offset X
  #[inline]
  pub fn PIXEL_OFFSET_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMLabel::VT_PIXEL_OFFSET_X, Some(0.0)).unwrap()}
  }
  /// Pixel offset Y
  #[inline]
  pub fn PIXEL_OFFSET_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMLabel::VT_PIXEL_OFFSET_Y, Some(0.0)).unwrap()}
  }
  /// Scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMLabel::VT_SCALE, Some(0.0)).unwrap()}
  }
  /// Horizontal origin
  #[inline]
  pub fn HORIZONTAL_ORIGIN(&self) -> CZMHorizontalOrigin {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHorizontalOrigin>(CZMLabel::VT_HORIZONTAL_ORIGIN, Some(CZMHorizontalOrigin::LEFT)).unwrap()}
  }
  /// Vertical origin
  #[inline]
  pub fn VERTICAL_ORIGIN(&self) -> CZMVerticalOrigin {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMVerticalOrigin>(CZMLabel::VT_VERTICAL_ORIGIN, Some(CZMVerticalOrigin::BASELINE)).unwrap()}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMLabel::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMLabel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TEXT", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FONT", Self::VT_FONT, false)?
     .visit_field::<CZMLabelStyle>("STYLE", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("FILL_COLOR", Self::VT_FILL_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("OUTLINE_COLOR", Self::VT_OUTLINE_COLOR, false)?
     .visit_field::<f64>("OUTLINE_WIDTH", Self::VT_OUTLINE_WIDTH, false)?
     .visit_field::<f64>("PIXEL_OFFSET_X", Self::VT_PIXEL_OFFSET_X, false)?
     .visit_field::<f64>("PIXEL_OFFSET_Y", Self::VT_PIXEL_OFFSET_Y, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .visit_field::<CZMHorizontalOrigin>("HORIZONTAL_ORIGIN", Self::VT_HORIZONTAL_ORIGIN, false)?
     .visit_field::<CZMVerticalOrigin>("VERTICAL_ORIGIN", Self::VT_VERTICAL_ORIGIN, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMLabelArgs<'a> {
    pub SHOW: bool,
    pub TEXT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FONT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STYLE: CZMLabelStyle,
    pub FILL_COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE_COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE_WIDTH: f64,
    pub PIXEL_OFFSET_X: f64,
    pub PIXEL_OFFSET_Y: f64,
    pub SCALE: f64,
    pub HORIZONTAL_ORIGIN: CZMHorizontalOrigin,
    pub VERTICAL_ORIGIN: CZMVerticalOrigin,
    pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl<'a> Default for CZMLabelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMLabelArgs {
      SHOW: false,
      TEXT: None,
      FONT: None,
      STYLE: CZMLabelStyle::FILL,
      FILL_COLOR: None,
      OUTLINE_COLOR: None,
      OUTLINE_WIDTH: 0.0,
      PIXEL_OFFSET_X: 0.0,
      PIXEL_OFFSET_Y: 0.0,
      SCALE: 0.0,
      HORIZONTAL_ORIGIN: CZMHorizontalOrigin::LEFT,
      VERTICAL_ORIGIN: CZMVerticalOrigin::BASELINE,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}

pub struct CZMLabelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMLabelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMLabel::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_TEXT(&mut self, TEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMLabel::VT_TEXT, TEXT);
  }
  #[inline]
  pub fn add_FONT(&mut self, FONT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMLabel::VT_FONT, FONT);
  }
  #[inline]
  pub fn add_STYLE(&mut self, STYLE: CZMLabelStyle) {
    self.fbb_.push_slot::<CZMLabelStyle>(CZMLabel::VT_STYLE, STYLE, CZMLabelStyle::FILL);
  }
  #[inline]
  pub fn add_FILL_COLOR(&mut self, FILL_COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMLabel::VT_FILL_COLOR, FILL_COLOR);
  }
  #[inline]
  pub fn add_OUTLINE_COLOR(&mut self, OUTLINE_COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMLabel::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  #[inline]
  pub fn add_OUTLINE_WIDTH(&mut self, OUTLINE_WIDTH: f64) {
    self.fbb_.push_slot::<f64>(CZMLabel::VT_OUTLINE_WIDTH, OUTLINE_WIDTH, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_OFFSET_X(&mut self, PIXEL_OFFSET_X: f64) {
    self.fbb_.push_slot::<f64>(CZMLabel::VT_PIXEL_OFFSET_X, PIXEL_OFFSET_X, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_OFFSET_Y(&mut self, PIXEL_OFFSET_Y: f64) {
    self.fbb_.push_slot::<f64>(CZMLabel::VT_PIXEL_OFFSET_Y, PIXEL_OFFSET_Y, 0.0);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(CZMLabel::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn add_HORIZONTAL_ORIGIN(&mut self, HORIZONTAL_ORIGIN: CZMHorizontalOrigin) {
    self.fbb_.push_slot::<CZMHorizontalOrigin>(CZMLabel::VT_HORIZONTAL_ORIGIN, HORIZONTAL_ORIGIN, CZMHorizontalOrigin::LEFT);
  }
  #[inline]
  pub fn add_VERTICAL_ORIGIN(&mut self, VERTICAL_ORIGIN: CZMVerticalOrigin) {
    self.fbb_.push_slot::<CZMVerticalOrigin>(CZMLabel::VT_VERTICAL_ORIGIN, VERTICAL_ORIGIN, CZMVerticalOrigin::BASELINE);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMLabel::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMLabelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMLabelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMLabel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMLabel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMLabel");
      ds.field("SHOW", &self.SHOW());
      ds.field("TEXT", &self.TEXT());
      ds.field("FONT", &self.FONT());
      ds.field("STYLE", &self.STYLE());
      ds.field("FILL_COLOR", &self.FILL_COLOR());
      ds.field("OUTLINE_COLOR", &self.OUTLINE_COLOR());
      ds.field("OUTLINE_WIDTH", &self.OUTLINE_WIDTH());
      ds.field("PIXEL_OFFSET_X", &self.PIXEL_OFFSET_X());
      ds.field("PIXEL_OFFSET_Y", &self.PIXEL_OFFSET_Y());
      ds.field("SCALE", &self.SCALE());
      ds.field("HORIZONTAL_ORIGIN", &self.HORIZONTAL_ORIGIN());
      ds.field("VERTICAL_ORIGIN", &self.VERTICAL_ORIGIN());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMLabelT {
  pub SHOW: bool,
  pub TEXT: Option<String>,
  pub FONT: Option<String>,
  pub STYLE: CZMLabelStyle,
  pub FILL_COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE_COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE_WIDTH: f64,
  pub PIXEL_OFFSET_X: f64,
  pub PIXEL_OFFSET_Y: f64,
  pub SCALE: f64,
  pub HORIZONTAL_ORIGIN: CZMHorizontalOrigin,
  pub VERTICAL_ORIGIN: CZMVerticalOrigin,
  pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl Default for CZMLabelT {
  fn default() -> Self {
    Self {
      SHOW: false,
      TEXT: None,
      FONT: None,
      STYLE: CZMLabelStyle::FILL,
      FILL_COLOR: None,
      OUTLINE_COLOR: None,
      OUTLINE_WIDTH: 0.0,
      PIXEL_OFFSET_X: 0.0,
      PIXEL_OFFSET_Y: 0.0,
      SCALE: 0.0,
      HORIZONTAL_ORIGIN: CZMHorizontalOrigin::LEFT,
      VERTICAL_ORIGIN: CZMVerticalOrigin::BASELINE,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}
impl CZMLabelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMLabel<'b>> {
    let SHOW = self.SHOW;
    let TEXT = self.TEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FONT = self.FONT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STYLE = self.STYLE;
    let FILL_COLOR = self.FILL_COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE_COLOR = self.OUTLINE_COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE_WIDTH = self.OUTLINE_WIDTH;
    let PIXEL_OFFSET_X = self.PIXEL_OFFSET_X;
    let PIXEL_OFFSET_Y = self.PIXEL_OFFSET_Y;
    let SCALE = self.SCALE;
    let HORIZONTAL_ORIGIN = self.HORIZONTAL_ORIGIN;
    let VERTICAL_ORIGIN = self.VERTICAL_ORIGIN;
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    CZMLabel::create(_fbb, &CZMLabelArgs{
      SHOW,
      TEXT,
      FONT,
      STYLE,
      FILL_COLOR,
      OUTLINE_COLOR,
      OUTLINE_WIDTH,
      PIXEL_OFFSET_X,
      PIXEL_OFFSET_Y,
      SCALE,
      HORIZONTAL_ORIGIN,
      VERTICAL_ORIGIN,
      HEIGHT_REFERENCE,
    })
  }
}
pub enum CZMPointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Point properties
pub struct CZMPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMPoint<'a> {
  type Inner = CZMPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMPoint<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;
  pub const VT_OUTLINE_COLOR: flatbuffers::VOffsetT = 8;
  pub const VT_OUTLINE_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_PIXEL_SIZE: flatbuffers::VOffsetT = 12;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMPointArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMPoint<'bldr>> {
    let mut builder = CZMPointBuilder::new(_fbb);
    builder.add_PIXEL_SIZE(args.PIXEL_SIZE);
    builder.add_OUTLINE_WIDTH(args.OUTLINE_WIDTH);
    if let Some(x) = args.OUTLINE_COLOR { builder.add_OUTLINE_COLOR(x); }
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMPointT {
    let SHOW = self.SHOW();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE_COLOR = self.OUTLINE_COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE_WIDTH = self.OUTLINE_WIDTH();
    let PIXEL_SIZE = self.PIXEL_SIZE();
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    CZMPointT {
      SHOW,
      COLOR,
      OUTLINE_COLOR,
      OUTLINE_WIDTH,
      PIXEL_SIZE,
      HEIGHT_REFERENCE,
    }
  }

  /// Whether the point is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPoint::VT_SHOW, Some(false)).unwrap()}
  }
  /// Point color
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPoint::VT_COLOR, None)}
  }
  /// Outline color
  #[inline]
  pub fn OUTLINE_COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPoint::VT_OUTLINE_COLOR, None)}
  }
  /// Outline width in pixels
  #[inline]
  pub fn OUTLINE_WIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPoint::VT_OUTLINE_WIDTH, Some(0.0)).unwrap()}
  }
  /// Pixel size
  #[inline]
  pub fn PIXEL_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPoint::VT_PIXEL_SIZE, Some(0.0)).unwrap()}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMPoint::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("OUTLINE_COLOR", Self::VT_OUTLINE_COLOR, false)?
     .visit_field::<f64>("OUTLINE_WIDTH", Self::VT_OUTLINE_WIDTH, false)?
     .visit_field::<f64>("PIXEL_SIZE", Self::VT_PIXEL_SIZE, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMPointArgs<'a> {
    pub SHOW: bool,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE_COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE_WIDTH: f64,
    pub PIXEL_SIZE: f64,
    pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl<'a> Default for CZMPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMPointArgs {
      SHOW: false,
      COLOR: None,
      OUTLINE_COLOR: None,
      OUTLINE_WIDTH: 0.0,
      PIXEL_SIZE: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}

pub struct CZMPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMPoint::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPoint::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_OUTLINE_COLOR(&mut self, OUTLINE_COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPoint::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  #[inline]
  pub fn add_OUTLINE_WIDTH(&mut self, OUTLINE_WIDTH: f64) {
    self.fbb_.push_slot::<f64>(CZMPoint::VT_OUTLINE_WIDTH, OUTLINE_WIDTH, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_SIZE(&mut self, PIXEL_SIZE: f64) {
    self.fbb_.push_slot::<f64>(CZMPoint::VT_PIXEL_SIZE, PIXEL_SIZE, 0.0);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMPoint::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMPoint");
      ds.field("SHOW", &self.SHOW());
      ds.field("COLOR", &self.COLOR());
      ds.field("OUTLINE_COLOR", &self.OUTLINE_COLOR());
      ds.field("OUTLINE_WIDTH", &self.OUTLINE_WIDTH());
      ds.field("PIXEL_SIZE", &self.PIXEL_SIZE());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMPointT {
  pub SHOW: bool,
  pub COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE_COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE_WIDTH: f64,
  pub PIXEL_SIZE: f64,
  pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl Default for CZMPointT {
  fn default() -> Self {
    Self {
      SHOW: false,
      COLOR: None,
      OUTLINE_COLOR: None,
      OUTLINE_WIDTH: 0.0,
      PIXEL_SIZE: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}
impl CZMPointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMPoint<'b>> {
    let SHOW = self.SHOW;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE_COLOR = self.OUTLINE_COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE_WIDTH = self.OUTLINE_WIDTH;
    let PIXEL_SIZE = self.PIXEL_SIZE;
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    CZMPoint::create(_fbb, &CZMPointArgs{
      SHOW,
      COLOR,
      OUTLINE_COLOR,
      OUTLINE_WIDTH,
      PIXEL_SIZE,
      HEIGHT_REFERENCE,
    })
  }
}
pub enum CZMPolylineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Polyline properties
pub struct CZMPolyline<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMPolyline<'a> {
  type Inner = CZMPolyline<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMPolyline<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_POSITIONS_CARTOGRAPHIC_DEGREES: flatbuffers::VOffsetT = 6;
  pub const VT_POSITIONS_CARTESIAN: flatbuffers::VOffsetT = 8;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_CLAMP_TO_GROUND: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMPolyline { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMPolylineArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMPolyline<'bldr>> {
    let mut builder = CZMPolylineBuilder::new(_fbb);
    builder.add_WIDTH(args.WIDTH);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    if let Some(x) = args.POSITIONS_CARTESIAN { builder.add_POSITIONS_CARTESIAN(x); }
    if let Some(x) = args.POSITIONS_CARTOGRAPHIC_DEGREES { builder.add_POSITIONS_CARTOGRAPHIC_DEGREES(x); }
    builder.add_CLAMP_TO_GROUND(args.CLAMP_TO_GROUND);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMPolylineT {
    let SHOW = self.SHOW();
    let POSITIONS_CARTOGRAPHIC_DEGREES = self.POSITIONS_CARTOGRAPHIC_DEGREES().map(|x| {
      x.into_iter().collect()
    });
    let POSITIONS_CARTESIAN = self.POSITIONS_CARTESIAN().map(|x| {
      x.into_iter().collect()
    });
    let WIDTH = self.WIDTH();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let CLAMP_TO_GROUND = self.CLAMP_TO_GROUND();
    CZMPolylineT {
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES,
      POSITIONS_CARTESIAN,
      WIDTH,
      COLOR,
      CLAMP_TO_GROUND,
    }
  }

  /// Whether the polyline is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPolyline::VT_SHOW, Some(false)).unwrap()}
  }
  /// Positions as cartographic degrees [lon, lat, height, lon, lat, height, ...]
  #[inline]
  pub fn POSITIONS_CARTOGRAPHIC_DEGREES(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPolyline::VT_POSITIONS_CARTOGRAPHIC_DEGREES, None)}
  }
  /// Positions as Cartesian [X, Y, Z, X, Y, Z, ...]
  #[inline]
  pub fn POSITIONS_CARTESIAN(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPolyline::VT_POSITIONS_CARTESIAN, None)}
  }
  /// Line width in pixels
  #[inline]
  pub fn WIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPolyline::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// Line color (solid color material)
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPolyline::VT_COLOR, None)}
  }
  /// Whether to clamp to ground
  #[inline]
  pub fn CLAMP_TO_GROUND(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPolyline::VT_CLAMP_TO_GROUND, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMPolyline<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITIONS_CARTOGRAPHIC_DEGREES", Self::VT_POSITIONS_CARTOGRAPHIC_DEGREES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITIONS_CARTESIAN", Self::VT_POSITIONS_CARTESIAN, false)?
     .visit_field::<f64>("WIDTH", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<bool>("CLAMP_TO_GROUND", Self::VT_CLAMP_TO_GROUND, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMPolylineArgs<'a> {
    pub SHOW: bool,
    pub POSITIONS_CARTOGRAPHIC_DEGREES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub POSITIONS_CARTESIAN: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub WIDTH: f64,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub CLAMP_TO_GROUND: bool,
}
impl<'a> Default for CZMPolylineArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMPolylineArgs {
      SHOW: false,
      POSITIONS_CARTOGRAPHIC_DEGREES: None,
      POSITIONS_CARTESIAN: None,
      WIDTH: 0.0,
      COLOR: None,
      CLAMP_TO_GROUND: false,
    }
  }
}

pub struct CZMPolylineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMPolylineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMPolyline::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_POSITIONS_CARTOGRAPHIC_DEGREES(&mut self, POSITIONS_CARTOGRAPHIC_DEGREES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPolyline::VT_POSITIONS_CARTOGRAPHIC_DEGREES, POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  #[inline]
  pub fn add_POSITIONS_CARTESIAN(&mut self, POSITIONS_CARTESIAN: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPolyline::VT_POSITIONS_CARTESIAN, POSITIONS_CARTESIAN);
  }
  #[inline]
  pub fn add_WIDTH(&mut self, WIDTH: f64) {
    self.fbb_.push_slot::<f64>(CZMPolyline::VT_WIDTH, WIDTH, 0.0);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPolyline::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_CLAMP_TO_GROUND(&mut self, CLAMP_TO_GROUND: bool) {
    self.fbb_.push_slot::<bool>(CZMPolyline::VT_CLAMP_TO_GROUND, CLAMP_TO_GROUND, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMPolylineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMPolylineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMPolyline<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMPolyline<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMPolyline");
      ds.field("SHOW", &self.SHOW());
      ds.field("POSITIONS_CARTOGRAPHIC_DEGREES", &self.POSITIONS_CARTOGRAPHIC_DEGREES());
      ds.field("POSITIONS_CARTESIAN", &self.POSITIONS_CARTESIAN());
      ds.field("WIDTH", &self.WIDTH());
      ds.field("COLOR", &self.COLOR());
      ds.field("CLAMP_TO_GROUND", &self.CLAMP_TO_GROUND());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMPolylineT {
  pub SHOW: bool,
  pub POSITIONS_CARTOGRAPHIC_DEGREES: Option<Vec<f64>>,
  pub POSITIONS_CARTESIAN: Option<Vec<f64>>,
  pub WIDTH: f64,
  pub COLOR: Option<Box<CZMColorT>>,
  pub CLAMP_TO_GROUND: bool,
}
impl Default for CZMPolylineT {
  fn default() -> Self {
    Self {
      SHOW: false,
      POSITIONS_CARTOGRAPHIC_DEGREES: None,
      POSITIONS_CARTESIAN: None,
      WIDTH: 0.0,
      COLOR: None,
      CLAMP_TO_GROUND: false,
    }
  }
}
impl CZMPolylineT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMPolyline<'b>> {
    let SHOW = self.SHOW;
    let POSITIONS_CARTOGRAPHIC_DEGREES = self.POSITIONS_CARTOGRAPHIC_DEGREES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let POSITIONS_CARTESIAN = self.POSITIONS_CARTESIAN.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let WIDTH = self.WIDTH;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CLAMP_TO_GROUND = self.CLAMP_TO_GROUND;
    CZMPolyline::create(_fbb, &CZMPolylineArgs{
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES,
      POSITIONS_CARTESIAN,
      WIDTH,
      COLOR,
      CLAMP_TO_GROUND,
    })
  }
}
pub enum CZMPolygonOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Polygon properties
pub struct CZMPolygon<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMPolygon<'a> {
  type Inner = CZMPolygon<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMPolygon<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_POSITIONS_CARTOGRAPHIC_DEGREES: flatbuffers::VOffsetT = 6;
  pub const VT_POSITIONS_CARTESIAN: flatbuffers::VOffsetT = 8;
  pub const VT_FILL: flatbuffers::VOffsetT = 10;
  pub const VT_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_OUTLINE: flatbuffers::VOffsetT = 14;
  pub const VT_OUTLINE_COLOR: flatbuffers::VOffsetT = 16;
  pub const VT_EXTRUDED_HEIGHT: flatbuffers::VOffsetT = 18;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 20;
  pub const VT_CLASSIFICATION_TYPE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMPolygon { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMPolygonArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMPolygon<'bldr>> {
    let mut builder = CZMPolygonBuilder::new(_fbb);
    builder.add_EXTRUDED_HEIGHT(args.EXTRUDED_HEIGHT);
    if let Some(x) = args.OUTLINE_COLOR { builder.add_OUTLINE_COLOR(x); }
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    if let Some(x) = args.POSITIONS_CARTESIAN { builder.add_POSITIONS_CARTESIAN(x); }
    if let Some(x) = args.POSITIONS_CARTOGRAPHIC_DEGREES { builder.add_POSITIONS_CARTOGRAPHIC_DEGREES(x); }
    builder.add_CLASSIFICATION_TYPE(args.CLASSIFICATION_TYPE);
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_OUTLINE(args.OUTLINE);
    builder.add_FILL(args.FILL);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMPolygonT {
    let SHOW = self.SHOW();
    let POSITIONS_CARTOGRAPHIC_DEGREES = self.POSITIONS_CARTOGRAPHIC_DEGREES().map(|x| {
      x.into_iter().collect()
    });
    let POSITIONS_CARTESIAN = self.POSITIONS_CARTESIAN().map(|x| {
      x.into_iter().collect()
    });
    let FILL = self.FILL();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE = self.OUTLINE();
    let OUTLINE_COLOR = self.OUTLINE_COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let EXTRUDED_HEIGHT = self.EXTRUDED_HEIGHT();
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    let CLASSIFICATION_TYPE = self.CLASSIFICATION_TYPE();
    CZMPolygonT {
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES,
      POSITIONS_CARTESIAN,
      FILL,
      COLOR,
      OUTLINE,
      OUTLINE_COLOR,
      EXTRUDED_HEIGHT,
      HEIGHT_REFERENCE,
      CLASSIFICATION_TYPE,
    }
  }

  /// Whether the polygon is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPolygon::VT_SHOW, Some(false)).unwrap()}
  }
  /// Positions as cartographic degrees [lon, lat, height, ...]
  #[inline]
  pub fn POSITIONS_CARTOGRAPHIC_DEGREES(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPolygon::VT_POSITIONS_CARTOGRAPHIC_DEGREES, None)}
  }
  /// Positions as Cartesian [X, Y, Z, ...]
  #[inline]
  pub fn POSITIONS_CARTESIAN(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPolygon::VT_POSITIONS_CARTESIAN, None)}
  }
  /// Fill flag
  #[inline]
  pub fn FILL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPolygon::VT_FILL, Some(false)).unwrap()}
  }
  /// Fill color (solid color material)
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPolygon::VT_COLOR, None)}
  }
  /// Outline flag
  #[inline]
  pub fn OUTLINE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPolygon::VT_OUTLINE, Some(false)).unwrap()}
  }
  /// Outline color
  #[inline]
  pub fn OUTLINE_COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPolygon::VT_OUTLINE_COLOR, None)}
  }
  /// Extruded height in meters
  #[inline]
  pub fn EXTRUDED_HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPolygon::VT_EXTRUDED_HEIGHT, Some(0.0)).unwrap()}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMPolygon::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
  /// Classification type
  #[inline]
  pub fn CLASSIFICATION_TYPE(&self) -> CZMClassificationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMClassificationType>(CZMPolygon::VT_CLASSIFICATION_TYPE, Some(CZMClassificationType::TERRAIN)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMPolygon<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITIONS_CARTOGRAPHIC_DEGREES", Self::VT_POSITIONS_CARTOGRAPHIC_DEGREES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITIONS_CARTESIAN", Self::VT_POSITIONS_CARTESIAN, false)?
     .visit_field::<bool>("FILL", Self::VT_FILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<bool>("OUTLINE", Self::VT_OUTLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("OUTLINE_COLOR", Self::VT_OUTLINE_COLOR, false)?
     .visit_field::<f64>("EXTRUDED_HEIGHT", Self::VT_EXTRUDED_HEIGHT, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .visit_field::<CZMClassificationType>("CLASSIFICATION_TYPE", Self::VT_CLASSIFICATION_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMPolygonArgs<'a> {
    pub SHOW: bool,
    pub POSITIONS_CARTOGRAPHIC_DEGREES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub POSITIONS_CARTESIAN: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub FILL: bool,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE: bool,
    pub OUTLINE_COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub EXTRUDED_HEIGHT: f64,
    pub HEIGHT_REFERENCE: CZMHeightReference,
    pub CLASSIFICATION_TYPE: CZMClassificationType,
}
impl<'a> Default for CZMPolygonArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMPolygonArgs {
      SHOW: false,
      POSITIONS_CARTOGRAPHIC_DEGREES: None,
      POSITIONS_CARTESIAN: None,
      FILL: false,
      COLOR: None,
      OUTLINE: false,
      OUTLINE_COLOR: None,
      EXTRUDED_HEIGHT: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      CLASSIFICATION_TYPE: CZMClassificationType::TERRAIN,
    }
  }
}

pub struct CZMPolygonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMPolygonBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMPolygon::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_POSITIONS_CARTOGRAPHIC_DEGREES(&mut self, POSITIONS_CARTOGRAPHIC_DEGREES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPolygon::VT_POSITIONS_CARTOGRAPHIC_DEGREES, POSITIONS_CARTOGRAPHIC_DEGREES);
  }
  #[inline]
  pub fn add_POSITIONS_CARTESIAN(&mut self, POSITIONS_CARTESIAN: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPolygon::VT_POSITIONS_CARTESIAN, POSITIONS_CARTESIAN);
  }
  #[inline]
  pub fn add_FILL(&mut self, FILL: bool) {
    self.fbb_.push_slot::<bool>(CZMPolygon::VT_FILL, FILL, false);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPolygon::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_OUTLINE(&mut self, OUTLINE: bool) {
    self.fbb_.push_slot::<bool>(CZMPolygon::VT_OUTLINE, OUTLINE, false);
  }
  #[inline]
  pub fn add_OUTLINE_COLOR(&mut self, OUTLINE_COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPolygon::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  #[inline]
  pub fn add_EXTRUDED_HEIGHT(&mut self, EXTRUDED_HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(CZMPolygon::VT_EXTRUDED_HEIGHT, EXTRUDED_HEIGHT, 0.0);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMPolygon::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn add_CLASSIFICATION_TYPE(&mut self, CLASSIFICATION_TYPE: CZMClassificationType) {
    self.fbb_.push_slot::<CZMClassificationType>(CZMPolygon::VT_CLASSIFICATION_TYPE, CLASSIFICATION_TYPE, CZMClassificationType::TERRAIN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMPolygonBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMPolygonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMPolygon<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMPolygon<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMPolygon");
      ds.field("SHOW", &self.SHOW());
      ds.field("POSITIONS_CARTOGRAPHIC_DEGREES", &self.POSITIONS_CARTOGRAPHIC_DEGREES());
      ds.field("POSITIONS_CARTESIAN", &self.POSITIONS_CARTESIAN());
      ds.field("FILL", &self.FILL());
      ds.field("COLOR", &self.COLOR());
      ds.field("OUTLINE", &self.OUTLINE());
      ds.field("OUTLINE_COLOR", &self.OUTLINE_COLOR());
      ds.field("EXTRUDED_HEIGHT", &self.EXTRUDED_HEIGHT());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.field("CLASSIFICATION_TYPE", &self.CLASSIFICATION_TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMPolygonT {
  pub SHOW: bool,
  pub POSITIONS_CARTOGRAPHIC_DEGREES: Option<Vec<f64>>,
  pub POSITIONS_CARTESIAN: Option<Vec<f64>>,
  pub FILL: bool,
  pub COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE: bool,
  pub OUTLINE_COLOR: Option<Box<CZMColorT>>,
  pub EXTRUDED_HEIGHT: f64,
  pub HEIGHT_REFERENCE: CZMHeightReference,
  pub CLASSIFICATION_TYPE: CZMClassificationType,
}
impl Default for CZMPolygonT {
  fn default() -> Self {
    Self {
      SHOW: false,
      POSITIONS_CARTOGRAPHIC_DEGREES: None,
      POSITIONS_CARTESIAN: None,
      FILL: false,
      COLOR: None,
      OUTLINE: false,
      OUTLINE_COLOR: None,
      EXTRUDED_HEIGHT: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      CLASSIFICATION_TYPE: CZMClassificationType::TERRAIN,
    }
  }
}
impl CZMPolygonT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMPolygon<'b>> {
    let SHOW = self.SHOW;
    let POSITIONS_CARTOGRAPHIC_DEGREES = self.POSITIONS_CARTOGRAPHIC_DEGREES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let POSITIONS_CARTESIAN = self.POSITIONS_CARTESIAN.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let FILL = self.FILL;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE = self.OUTLINE;
    let OUTLINE_COLOR = self.OUTLINE_COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let EXTRUDED_HEIGHT = self.EXTRUDED_HEIGHT;
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    let CLASSIFICATION_TYPE = self.CLASSIFICATION_TYPE;
    CZMPolygon::create(_fbb, &CZMPolygonArgs{
      SHOW,
      POSITIONS_CARTOGRAPHIC_DEGREES,
      POSITIONS_CARTESIAN,
      FILL,
      COLOR,
      OUTLINE,
      OUTLINE_COLOR,
      EXTRUDED_HEIGHT,
      HEIGHT_REFERENCE,
      CLASSIFICATION_TYPE,
    })
  }
}
pub enum CZMModelOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Model properties (glTF)
pub struct CZMModel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMModel<'a> {
  type Inner = CZMModel<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMModel<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_GLTF: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_MINIMUM_PIXEL_SIZE: flatbuffers::VOffsetT = 10;
  pub const VT_MAXIMUM_SCALE: flatbuffers::VOffsetT = 12;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 14;
  pub const VT_COLOR: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMModel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMModelArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMModel<'bldr>> {
    let mut builder = CZMModelBuilder::new(_fbb);
    builder.add_MAXIMUM_SCALE(args.MAXIMUM_SCALE);
    builder.add_MINIMUM_PIXEL_SIZE(args.MINIMUM_PIXEL_SIZE);
    builder.add_SCALE(args.SCALE);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    if let Some(x) = args.GLTF { builder.add_GLTF(x); }
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMModelT {
    let SHOW = self.SHOW();
    let GLTF = self.GLTF().map(|x| {
      x.to_string()
    });
    let SCALE = self.SCALE();
    let MINIMUM_PIXEL_SIZE = self.MINIMUM_PIXEL_SIZE();
    let MAXIMUM_SCALE = self.MAXIMUM_SCALE();
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    CZMModelT {
      SHOW,
      GLTF,
      SCALE,
      MINIMUM_PIXEL_SIZE,
      MAXIMUM_SCALE,
      HEIGHT_REFERENCE,
      COLOR,
    }
  }

  /// Whether the model is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMModel::VT_SHOW, Some(false)).unwrap()}
  }
  /// URI to the glTF model
  #[inline]
  pub fn GLTF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMModel::VT_GLTF, None)}
  }
  /// Scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMModel::VT_SCALE, Some(0.0)).unwrap()}
  }
  /// Minimum pixel size
  #[inline]
  pub fn MINIMUM_PIXEL_SIZE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMModel::VT_MINIMUM_PIXEL_SIZE, Some(0.0)).unwrap()}
  }
  /// Maximum scale
  #[inline]
  pub fn MAXIMUM_SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMModel::VT_MAXIMUM_SCALE, Some(0.0)).unwrap()}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMModel::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
  /// Color tint
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMModel::VT_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for CZMModel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GLTF", Self::VT_GLTF, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .visit_field::<f64>("MINIMUM_PIXEL_SIZE", Self::VT_MINIMUM_PIXEL_SIZE, false)?
     .visit_field::<f64>("MAXIMUM_SCALE", Self::VT_MAXIMUM_SCALE, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMModelArgs<'a> {
    pub SHOW: bool,
    pub GLTF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCALE: f64,
    pub MINIMUM_PIXEL_SIZE: f64,
    pub MAXIMUM_SCALE: f64,
    pub HEIGHT_REFERENCE: CZMHeightReference,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
}
impl<'a> Default for CZMModelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMModelArgs {
      SHOW: false,
      GLTF: None,
      SCALE: 0.0,
      MINIMUM_PIXEL_SIZE: 0.0,
      MAXIMUM_SCALE: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      COLOR: None,
    }
  }
}

pub struct CZMModelBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMModelBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMModel::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_GLTF(&mut self, GLTF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMModel::VT_GLTF, GLTF);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(CZMModel::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn add_MINIMUM_PIXEL_SIZE(&mut self, MINIMUM_PIXEL_SIZE: f64) {
    self.fbb_.push_slot::<f64>(CZMModel::VT_MINIMUM_PIXEL_SIZE, MINIMUM_PIXEL_SIZE, 0.0);
  }
  #[inline]
  pub fn add_MAXIMUM_SCALE(&mut self, MAXIMUM_SCALE: f64) {
    self.fbb_.push_slot::<f64>(CZMModel::VT_MAXIMUM_SCALE, MAXIMUM_SCALE, 0.0);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMModel::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMModel::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMModelBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMModelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMModel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMModel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMModel");
      ds.field("SHOW", &self.SHOW());
      ds.field("GLTF", &self.GLTF());
      ds.field("SCALE", &self.SCALE());
      ds.field("MINIMUM_PIXEL_SIZE", &self.MINIMUM_PIXEL_SIZE());
      ds.field("MAXIMUM_SCALE", &self.MAXIMUM_SCALE());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.field("COLOR", &self.COLOR());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMModelT {
  pub SHOW: bool,
  pub GLTF: Option<String>,
  pub SCALE: f64,
  pub MINIMUM_PIXEL_SIZE: f64,
  pub MAXIMUM_SCALE: f64,
  pub HEIGHT_REFERENCE: CZMHeightReference,
  pub COLOR: Option<Box<CZMColorT>>,
}
impl Default for CZMModelT {
  fn default() -> Self {
    Self {
      SHOW: false,
      GLTF: None,
      SCALE: 0.0,
      MINIMUM_PIXEL_SIZE: 0.0,
      MAXIMUM_SCALE: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
      COLOR: None,
    }
  }
}
impl CZMModelT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMModel<'b>> {
    let SHOW = self.SHOW;
    let GLTF = self.GLTF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCALE = self.SCALE;
    let MINIMUM_PIXEL_SIZE = self.MINIMUM_PIXEL_SIZE;
    let MAXIMUM_SCALE = self.MAXIMUM_SCALE;
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CZMModel::create(_fbb, &CZMModelArgs{
      SHOW,
      GLTF,
      SCALE,
      MINIMUM_PIXEL_SIZE,
      MAXIMUM_SCALE,
      HEIGHT_REFERENCE,
      COLOR,
    })
  }
}
pub enum CZMPathOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Path properties (orbit trail)
pub struct CZMPath<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMPath<'a> {
  type Inner = CZMPath<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMPath<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_LEAD_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_TRAIL_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_RESOLUTION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMPath { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMPathArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMPath<'bldr>> {
    let mut builder = CZMPathBuilder::new(_fbb);
    builder.add_RESOLUTION(args.RESOLUTION);
    builder.add_WIDTH(args.WIDTH);
    builder.add_TRAIL_TIME(args.TRAIL_TIME);
    builder.add_LEAD_TIME(args.LEAD_TIME);
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMPathT {
    let SHOW = self.SHOW();
    let LEAD_TIME = self.LEAD_TIME();
    let TRAIL_TIME = self.TRAIL_TIME();
    let WIDTH = self.WIDTH();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let RESOLUTION = self.RESOLUTION();
    CZMPathT {
      SHOW,
      LEAD_TIME,
      TRAIL_TIME,
      WIDTH,
      COLOR,
      RESOLUTION,
    }
  }

  /// Whether the path is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMPath::VT_SHOW, Some(false)).unwrap()}
  }
  /// Trail time in seconds (how far behind)
  #[inline]
  pub fn LEAD_TIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPath::VT_LEAD_TIME, Some(0.0)).unwrap()}
  }
  /// Lead time in seconds (how far ahead)
  #[inline]
  pub fn TRAIL_TIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPath::VT_TRAIL_TIME, Some(0.0)).unwrap()}
  }
  /// Line width in pixels
  #[inline]
  pub fn WIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPath::VT_WIDTH, Some(0.0)).unwrap()}
  }
  /// Path color
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMPath::VT_COLOR, None)}
  }
  /// Resolution in seconds
  #[inline]
  pub fn RESOLUTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMPath::VT_RESOLUTION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMPath<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<f64>("LEAD_TIME", Self::VT_LEAD_TIME, false)?
     .visit_field::<f64>("TRAIL_TIME", Self::VT_TRAIL_TIME, false)?
     .visit_field::<f64>("WIDTH", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<f64>("RESOLUTION", Self::VT_RESOLUTION, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMPathArgs<'a> {
    pub SHOW: bool,
    pub LEAD_TIME: f64,
    pub TRAIL_TIME: f64,
    pub WIDTH: f64,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub RESOLUTION: f64,
}
impl<'a> Default for CZMPathArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMPathArgs {
      SHOW: false,
      LEAD_TIME: 0.0,
      TRAIL_TIME: 0.0,
      WIDTH: 0.0,
      COLOR: None,
      RESOLUTION: 0.0,
    }
  }
}

pub struct CZMPathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMPathBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMPath::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_LEAD_TIME(&mut self, LEAD_TIME: f64) {
    self.fbb_.push_slot::<f64>(CZMPath::VT_LEAD_TIME, LEAD_TIME, 0.0);
  }
  #[inline]
  pub fn add_TRAIL_TIME(&mut self, TRAIL_TIME: f64) {
    self.fbb_.push_slot::<f64>(CZMPath::VT_TRAIL_TIME, TRAIL_TIME, 0.0);
  }
  #[inline]
  pub fn add_WIDTH(&mut self, WIDTH: f64) {
    self.fbb_.push_slot::<f64>(CZMPath::VT_WIDTH, WIDTH, 0.0);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMPath::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_RESOLUTION(&mut self, RESOLUTION: f64) {
    self.fbb_.push_slot::<f64>(CZMPath::VT_RESOLUTION, RESOLUTION, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMPathBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMPathBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMPath<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMPath<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMPath");
      ds.field("SHOW", &self.SHOW());
      ds.field("LEAD_TIME", &self.LEAD_TIME());
      ds.field("TRAIL_TIME", &self.TRAIL_TIME());
      ds.field("WIDTH", &self.WIDTH());
      ds.field("COLOR", &self.COLOR());
      ds.field("RESOLUTION", &self.RESOLUTION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMPathT {
  pub SHOW: bool,
  pub LEAD_TIME: f64,
  pub TRAIL_TIME: f64,
  pub WIDTH: f64,
  pub COLOR: Option<Box<CZMColorT>>,
  pub RESOLUTION: f64,
}
impl Default for CZMPathT {
  fn default() -> Self {
    Self {
      SHOW: false,
      LEAD_TIME: 0.0,
      TRAIL_TIME: 0.0,
      WIDTH: 0.0,
      COLOR: None,
      RESOLUTION: 0.0,
    }
  }
}
impl CZMPathT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMPath<'b>> {
    let SHOW = self.SHOW;
    let LEAD_TIME = self.LEAD_TIME;
    let TRAIL_TIME = self.TRAIL_TIME;
    let WIDTH = self.WIDTH;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let RESOLUTION = self.RESOLUTION;
    CZMPath::create(_fbb, &CZMPathArgs{
      SHOW,
      LEAD_TIME,
      TRAIL_TIME,
      WIDTH,
      COLOR,
      RESOLUTION,
    })
  }
}
pub enum CZMEllipseOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ellipse properties (for ground circles/ellipses)
pub struct CZMEllipse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMEllipse<'a> {
  type Inner = CZMEllipse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMEllipse<'a> {
  pub const VT_SHOW: flatbuffers::VOffsetT = 4;
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 6;
  pub const VT_SEMI_MINOR_AXIS: flatbuffers::VOffsetT = 8;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 10;
  pub const VT_FILL: flatbuffers::VOffsetT = 12;
  pub const VT_COLOR: flatbuffers::VOffsetT = 14;
  pub const VT_OUTLINE: flatbuffers::VOffsetT = 16;
  pub const VT_OUTLINE_COLOR: flatbuffers::VOffsetT = 18;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 20;
  pub const VT_HEIGHT_REFERENCE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMEllipse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMEllipseArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMEllipse<'bldr>> {
    let mut builder = CZMEllipseBuilder::new(_fbb);
    builder.add_HEIGHT(args.HEIGHT);
    builder.add_ROTATION(args.ROTATION);
    builder.add_SEMI_MINOR_AXIS(args.SEMI_MINOR_AXIS);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    if let Some(x) = args.OUTLINE_COLOR { builder.add_OUTLINE_COLOR(x); }
    if let Some(x) = args.COLOR { builder.add_COLOR(x); }
    builder.add_HEIGHT_REFERENCE(args.HEIGHT_REFERENCE);
    builder.add_OUTLINE(args.OUTLINE);
    builder.add_FILL(args.FILL);
    builder.add_SHOW(args.SHOW);
    builder.finish()
  }

  pub fn unpack(&self) -> CZMEllipseT {
    let SHOW = self.SHOW();
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let SEMI_MINOR_AXIS = self.SEMI_MINOR_AXIS();
    let ROTATION = self.ROTATION();
    let FILL = self.FILL();
    let COLOR = self.COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let OUTLINE = self.OUTLINE();
    let OUTLINE_COLOR = self.OUTLINE_COLOR().map(|x| {
      Box::new(x.unpack())
    });
    let HEIGHT = self.HEIGHT();
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE();
    CZMEllipseT {
      SHOW,
      SEMI_MAJOR_AXIS,
      SEMI_MINOR_AXIS,
      ROTATION,
      FILL,
      COLOR,
      OUTLINE,
      OUTLINE_COLOR,
      HEIGHT,
      HEIGHT_REFERENCE,
    }
  }

  /// Whether the ellipse is displayed
  #[inline]
  pub fn SHOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMEllipse::VT_SHOW, Some(false)).unwrap()}
  }
  /// Semi-major axis in meters
  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMEllipse::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  /// Semi-minor axis in meters
  #[inline]
  pub fn SEMI_MINOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMEllipse::VT_SEMI_MINOR_AXIS, Some(0.0)).unwrap()}
  }
  /// Rotation from north in radians
  #[inline]
  pub fn ROTATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMEllipse::VT_ROTATION, Some(0.0)).unwrap()}
  }
  /// Fill flag
  #[inline]
  pub fn FILL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMEllipse::VT_FILL, Some(false)).unwrap()}
  }
  /// Fill color
  #[inline]
  pub fn COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMEllipse::VT_COLOR, None)}
  }
  /// Outline flag
  #[inline]
  pub fn OUTLINE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CZMEllipse::VT_OUTLINE, Some(false)).unwrap()}
  }
  /// Outline color
  #[inline]
  pub fn OUTLINE_COLOR(&self) -> Option<CZMColor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMColor>>(CZMEllipse::VT_OUTLINE_COLOR, None)}
  }
  /// Height in meters
  #[inline]
  pub fn HEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZMEllipse::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  /// Height reference
  #[inline]
  pub fn HEIGHT_REFERENCE(&self) -> CZMHeightReference {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CZMHeightReference>(CZMEllipse::VT_HEIGHT_REFERENCE, Some(CZMHeightReference::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CZMEllipse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("SHOW", Self::VT_SHOW, false)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("SEMI_MINOR_AXIS", Self::VT_SEMI_MINOR_AXIS, false)?
     .visit_field::<f64>("ROTATION", Self::VT_ROTATION, false)?
     .visit_field::<bool>("FILL", Self::VT_FILL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("COLOR", Self::VT_COLOR, false)?
     .visit_field::<bool>("OUTLINE", Self::VT_OUTLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMColor>>("OUTLINE_COLOR", Self::VT_OUTLINE_COLOR, false)?
     .visit_field::<f64>("HEIGHT", Self::VT_HEIGHT, false)?
     .visit_field::<CZMHeightReference>("HEIGHT_REFERENCE", Self::VT_HEIGHT_REFERENCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMEllipseArgs<'a> {
    pub SHOW: bool,
    pub SEMI_MAJOR_AXIS: f64,
    pub SEMI_MINOR_AXIS: f64,
    pub ROTATION: f64,
    pub FILL: bool,
    pub COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub OUTLINE: bool,
    pub OUTLINE_COLOR: Option<flatbuffers::WIPOffset<CZMColor<'a>>>,
    pub HEIGHT: f64,
    pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl<'a> Default for CZMEllipseArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMEllipseArgs {
      SHOW: false,
      SEMI_MAJOR_AXIS: 0.0,
      SEMI_MINOR_AXIS: 0.0,
      ROTATION: 0.0,
      FILL: false,
      COLOR: None,
      OUTLINE: false,
      OUTLINE_COLOR: None,
      HEIGHT: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}

pub struct CZMEllipseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMEllipseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SHOW(&mut self, SHOW: bool) {
    self.fbb_.push_slot::<bool>(CZMEllipse::VT_SHOW, SHOW, false);
  }
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(CZMEllipse::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_SEMI_MINOR_AXIS(&mut self, SEMI_MINOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(CZMEllipse::VT_SEMI_MINOR_AXIS, SEMI_MINOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_ROTATION(&mut self, ROTATION: f64) {
    self.fbb_.push_slot::<f64>(CZMEllipse::VT_ROTATION, ROTATION, 0.0);
  }
  #[inline]
  pub fn add_FILL(&mut self, FILL: bool) {
    self.fbb_.push_slot::<bool>(CZMEllipse::VT_FILL, FILL, false);
  }
  #[inline]
  pub fn add_COLOR(&mut self, COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMEllipse::VT_COLOR, COLOR);
  }
  #[inline]
  pub fn add_OUTLINE(&mut self, OUTLINE: bool) {
    self.fbb_.push_slot::<bool>(CZMEllipse::VT_OUTLINE, OUTLINE, false);
  }
  #[inline]
  pub fn add_OUTLINE_COLOR(&mut self, OUTLINE_COLOR: flatbuffers::WIPOffset<CZMColor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMColor>>(CZMEllipse::VT_OUTLINE_COLOR, OUTLINE_COLOR);
  }
  #[inline]
  pub fn add_HEIGHT(&mut self, HEIGHT: f64) {
    self.fbb_.push_slot::<f64>(CZMEllipse::VT_HEIGHT, HEIGHT, 0.0);
  }
  #[inline]
  pub fn add_HEIGHT_REFERENCE(&mut self, HEIGHT_REFERENCE: CZMHeightReference) {
    self.fbb_.push_slot::<CZMHeightReference>(CZMEllipse::VT_HEIGHT_REFERENCE, HEIGHT_REFERENCE, CZMHeightReference::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMEllipseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMEllipseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMEllipse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMEllipse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMEllipse");
      ds.field("SHOW", &self.SHOW());
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("SEMI_MINOR_AXIS", &self.SEMI_MINOR_AXIS());
      ds.field("ROTATION", &self.ROTATION());
      ds.field("FILL", &self.FILL());
      ds.field("COLOR", &self.COLOR());
      ds.field("OUTLINE", &self.OUTLINE());
      ds.field("OUTLINE_COLOR", &self.OUTLINE_COLOR());
      ds.field("HEIGHT", &self.HEIGHT());
      ds.field("HEIGHT_REFERENCE", &self.HEIGHT_REFERENCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMEllipseT {
  pub SHOW: bool,
  pub SEMI_MAJOR_AXIS: f64,
  pub SEMI_MINOR_AXIS: f64,
  pub ROTATION: f64,
  pub FILL: bool,
  pub COLOR: Option<Box<CZMColorT>>,
  pub OUTLINE: bool,
  pub OUTLINE_COLOR: Option<Box<CZMColorT>>,
  pub HEIGHT: f64,
  pub HEIGHT_REFERENCE: CZMHeightReference,
}
impl Default for CZMEllipseT {
  fn default() -> Self {
    Self {
      SHOW: false,
      SEMI_MAJOR_AXIS: 0.0,
      SEMI_MINOR_AXIS: 0.0,
      ROTATION: 0.0,
      FILL: false,
      COLOR: None,
      OUTLINE: false,
      OUTLINE_COLOR: None,
      HEIGHT: 0.0,
      HEIGHT_REFERENCE: CZMHeightReference::NONE,
    }
  }
}
impl CZMEllipseT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMEllipse<'b>> {
    let SHOW = self.SHOW;
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let SEMI_MINOR_AXIS = self.SEMI_MINOR_AXIS;
    let ROTATION = self.ROTATION;
    let FILL = self.FILL;
    let COLOR = self.COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OUTLINE = self.OUTLINE;
    let OUTLINE_COLOR = self.OUTLINE_COLOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let HEIGHT = self.HEIGHT;
    let HEIGHT_REFERENCE = self.HEIGHT_REFERENCE;
    CZMEllipse::create(_fbb, &CZMEllipseArgs{
      SHOW,
      SEMI_MAJOR_AXIS,
      SEMI_MINOR_AXIS,
      ROTATION,
      FILL,
      COLOR,
      OUTLINE,
      OUTLINE_COLOR,
      HEIGHT,
      HEIGHT_REFERENCE,
    })
  }
}
pub enum CZMPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A CZML Packet describing an entity and its properties
pub struct CZMPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZMPacket<'a> {
  type Inner = CZMPacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZMPacket<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PARENT: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_AVAILABILITY: flatbuffers::VOffsetT = 12;
  pub const VT_POSITION_CARTOGRAPHIC_DEGREES: flatbuffers::VOffsetT = 14;
  pub const VT_POSITION_CARTESIAN: flatbuffers::VOffsetT = 16;
  pub const VT_POSITION_EPOCH: flatbuffers::VOffsetT = 18;
  pub const VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY: flatbuffers::VOffsetT = 20;
  pub const VT_POSITION_CARTESIAN_ARRAY: flatbuffers::VOffsetT = 22;
  pub const VT_BILLBOARD: flatbuffers::VOffsetT = 24;
  pub const VT_LABEL: flatbuffers::VOffsetT = 26;
  pub const VT_POINT: flatbuffers::VOffsetT = 28;
  pub const VT_POLYLINE: flatbuffers::VOffsetT = 30;
  pub const VT_POLYGON: flatbuffers::VOffsetT = 32;
  pub const VT_MODEL: flatbuffers::VOffsetT = 34;
  pub const VT_PATH: flatbuffers::VOffsetT = 36;
  pub const VT_ELLIPSE: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZMPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<CZMPacket<'bldr>> {
    let mut builder = CZMPacketBuilder::new(_fbb);
    if let Some(x) = args.ELLIPSE { builder.add_ELLIPSE(x); }
    if let Some(x) = args.PATH { builder.add_PATH(x); }
    if let Some(x) = args.MODEL { builder.add_MODEL(x); }
    if let Some(x) = args.POLYGON { builder.add_POLYGON(x); }
    if let Some(x) = args.POLYLINE { builder.add_POLYLINE(x); }
    if let Some(x) = args.POINT { builder.add_POINT(x); }
    if let Some(x) = args.LABEL { builder.add_LABEL(x); }
    if let Some(x) = args.BILLBOARD { builder.add_BILLBOARD(x); }
    if let Some(x) = args.POSITION_CARTESIAN_ARRAY { builder.add_POSITION_CARTESIAN_ARRAY(x); }
    if let Some(x) = args.POSITION_CARTOGRAPHIC_DEGREES_ARRAY { builder.add_POSITION_CARTOGRAPHIC_DEGREES_ARRAY(x); }
    if let Some(x) = args.POSITION_EPOCH { builder.add_POSITION_EPOCH(x); }
    if let Some(x) = args.POSITION_CARTESIAN { builder.add_POSITION_CARTESIAN(x); }
    if let Some(x) = args.POSITION_CARTOGRAPHIC_DEGREES { builder.add_POSITION_CARTOGRAPHIC_DEGREES(x); }
    if let Some(x) = args.AVAILABILITY { builder.add_AVAILABILITY(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.PARENT { builder.add_PARENT(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CZMPacketT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let PARENT = self.PARENT().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let AVAILABILITY = self.AVAILABILITY().map(|x| {
      x.to_string()
    });
    let POSITION_CARTOGRAPHIC_DEGREES = self.POSITION_CARTOGRAPHIC_DEGREES().map(|x| {
      Box::new(x.unpack())
    });
    let POSITION_CARTESIAN = self.POSITION_CARTESIAN().map(|x| {
      Box::new(x.unpack())
    });
    let POSITION_EPOCH = self.POSITION_EPOCH().map(|x| {
      x.to_string()
    });
    let POSITION_CARTOGRAPHIC_DEGREES_ARRAY = self.POSITION_CARTOGRAPHIC_DEGREES_ARRAY().map(|x| {
      x.into_iter().collect()
    });
    let POSITION_CARTESIAN_ARRAY = self.POSITION_CARTESIAN_ARRAY().map(|x| {
      x.into_iter().collect()
    });
    let BILLBOARD = self.BILLBOARD().map(|x| {
      Box::new(x.unpack())
    });
    let LABEL = self.LABEL().map(|x| {
      Box::new(x.unpack())
    });
    let POINT = self.POINT().map(|x| {
      Box::new(x.unpack())
    });
    let POLYLINE = self.POLYLINE().map(|x| {
      Box::new(x.unpack())
    });
    let POLYGON = self.POLYGON().map(|x| {
      Box::new(x.unpack())
    });
    let MODEL = self.MODEL().map(|x| {
      Box::new(x.unpack())
    });
    let PATH = self.PATH().map(|x| {
      Box::new(x.unpack())
    });
    let ELLIPSE = self.ELLIPSE().map(|x| {
      Box::new(x.unpack())
    });
    CZMPacketT {
      ID,
      NAME,
      PARENT,
      DESCRIPTION,
      AVAILABILITY,
      POSITION_CARTOGRAPHIC_DEGREES,
      POSITION_CARTESIAN,
      POSITION_EPOCH,
      POSITION_CARTOGRAPHIC_DEGREES_ARRAY,
      POSITION_CARTESIAN_ARRAY,
      BILLBOARD,
      LABEL,
      POINT,
      POLYLINE,
      POLYGON,
      MODEL,
      PATH,
      ELLIPSE,
    }
  }

  /// Unique identifier for this object
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_ID, None)}
  }
  /// Human-readable name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_NAME, None)}
  }
  /// Parent packet ID
  #[inline]
  pub fn PARENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_PARENT, None)}
  }
  /// Description (HTML allowed)
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_DESCRIPTION, None)}
  }
  /// Availability interval (ISO 8601 interval)
  #[inline]
  pub fn AVAILABILITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_AVAILABILITY, None)}
  }
  /// Position as cartographic degrees
  #[inline]
  pub fn POSITION_CARTOGRAPHIC_DEGREES(&self) -> Option<CZMCartographicDegrees<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMCartographicDegrees>>(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES, None)}
  }
  /// Position as Cartesian
  #[inline]
  pub fn POSITION_CARTESIAN(&self) -> Option<CZMCartesian<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMCartesian>>(CZMPacket::VT_POSITION_CARTESIAN, None)}
  }
  /// Time-tagged positions [time, lon, lat, height, time, lon, lat, height, ...]
  #[inline]
  pub fn POSITION_EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZMPacket::VT_POSITION_EPOCH, None)}
  }
  /// Time-tagged cartographic degree values
  #[inline]
  pub fn POSITION_CARTOGRAPHIC_DEGREES_ARRAY(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY, None)}
  }
  /// Time-tagged Cartesian values
  #[inline]
  pub fn POSITION_CARTESIAN_ARRAY(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CZMPacket::VT_POSITION_CARTESIAN_ARRAY, None)}
  }
  /// Billboard properties
  #[inline]
  pub fn BILLBOARD(&self) -> Option<CZMBillboard<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMBillboard>>(CZMPacket::VT_BILLBOARD, None)}
  }
  /// Label properties
  #[inline]
  pub fn LABEL(&self) -> Option<CZMLabel<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMLabel>>(CZMPacket::VT_LABEL, None)}
  }
  /// Point properties
  #[inline]
  pub fn POINT(&self) -> Option<CZMPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMPoint>>(CZMPacket::VT_POINT, None)}
  }
  /// Polyline properties
  #[inline]
  pub fn POLYLINE(&self) -> Option<CZMPolyline<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMPolyline>>(CZMPacket::VT_POLYLINE, None)}
  }
  /// Polygon properties
  #[inline]
  pub fn POLYGON(&self) -> Option<CZMPolygon<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMPolygon>>(CZMPacket::VT_POLYGON, None)}
  }
  /// Model properties
  #[inline]
  pub fn MODEL(&self) -> Option<CZMModel<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMModel>>(CZMPacket::VT_MODEL, None)}
  }
  /// Path properties
  #[inline]
  pub fn PATH(&self) -> Option<CZMPath<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMPath>>(CZMPacket::VT_PATH, None)}
  }
  /// Ellipse properties
  #[inline]
  pub fn ELLIPSE(&self) -> Option<CZMEllipse<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CZMEllipse>>(CZMPacket::VT_ELLIPSE, None)}
  }
}

impl flatbuffers::Verifiable for CZMPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARENT", Self::VT_PARENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AVAILABILITY", Self::VT_AVAILABILITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMCartographicDegrees>>("POSITION_CARTOGRAPHIC_DEGREES", Self::VT_POSITION_CARTOGRAPHIC_DEGREES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMCartesian>>("POSITION_CARTESIAN", Self::VT_POSITION_CARTESIAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSITION_EPOCH", Self::VT_POSITION_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITION_CARTOGRAPHIC_DEGREES_ARRAY", Self::VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("POSITION_CARTESIAN_ARRAY", Self::VT_POSITION_CARTESIAN_ARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMBillboard>>("BILLBOARD", Self::VT_BILLBOARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMLabel>>("LABEL", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMPoint>>("POINT", Self::VT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMPolyline>>("POLYLINE", Self::VT_POLYLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMPolygon>>("POLYGON", Self::VT_POLYGON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMModel>>("MODEL", Self::VT_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMPath>>("PATH", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CZMEllipse>>("ELLIPSE", Self::VT_ELLIPSE, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMPacketArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AVAILABILITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSITION_CARTOGRAPHIC_DEGREES: Option<flatbuffers::WIPOffset<CZMCartographicDegrees<'a>>>,
    pub POSITION_CARTESIAN: Option<flatbuffers::WIPOffset<CZMCartesian<'a>>>,
    pub POSITION_EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSITION_CARTOGRAPHIC_DEGREES_ARRAY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub POSITION_CARTESIAN_ARRAY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub BILLBOARD: Option<flatbuffers::WIPOffset<CZMBillboard<'a>>>,
    pub LABEL: Option<flatbuffers::WIPOffset<CZMLabel<'a>>>,
    pub POINT: Option<flatbuffers::WIPOffset<CZMPoint<'a>>>,
    pub POLYLINE: Option<flatbuffers::WIPOffset<CZMPolyline<'a>>>,
    pub POLYGON: Option<flatbuffers::WIPOffset<CZMPolygon<'a>>>,
    pub MODEL: Option<flatbuffers::WIPOffset<CZMModel<'a>>>,
    pub PATH: Option<flatbuffers::WIPOffset<CZMPath<'a>>>,
    pub ELLIPSE: Option<flatbuffers::WIPOffset<CZMEllipse<'a>>>,
}
impl<'a> Default for CZMPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMPacketArgs {
      ID: None,
      NAME: None,
      PARENT: None,
      DESCRIPTION: None,
      AVAILABILITY: None,
      POSITION_CARTOGRAPHIC_DEGREES: None,
      POSITION_CARTESIAN: None,
      POSITION_EPOCH: None,
      POSITION_CARTOGRAPHIC_DEGREES_ARRAY: None,
      POSITION_CARTESIAN_ARRAY: None,
      BILLBOARD: None,
      LABEL: None,
      POINT: None,
      POLYLINE: None,
      POLYGON: None,
      MODEL: None,
      PATH: None,
      ELLIPSE: None,
    }
  }
}

pub struct CZMPacketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMPacketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_ID, ID);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_PARENT(&mut self, PARENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_PARENT, PARENT);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_AVAILABILITY(&mut self, AVAILABILITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_AVAILABILITY, AVAILABILITY);
  }
  #[inline]
  pub fn add_POSITION_CARTOGRAPHIC_DEGREES(&mut self, POSITION_CARTOGRAPHIC_DEGREES: flatbuffers::WIPOffset<CZMCartographicDegrees<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMCartographicDegrees>>(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES, POSITION_CARTOGRAPHIC_DEGREES);
  }
  #[inline]
  pub fn add_POSITION_CARTESIAN(&mut self, POSITION_CARTESIAN: flatbuffers::WIPOffset<CZMCartesian<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMCartesian>>(CZMPacket::VT_POSITION_CARTESIAN, POSITION_CARTESIAN);
  }
  #[inline]
  pub fn add_POSITION_EPOCH(&mut self, POSITION_EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_POSITION_EPOCH, POSITION_EPOCH);
  }
  #[inline]
  pub fn add_POSITION_CARTOGRAPHIC_DEGREES_ARRAY(&mut self, POSITION_CARTOGRAPHIC_DEGREES_ARRAY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_POSITION_CARTOGRAPHIC_DEGREES_ARRAY, POSITION_CARTOGRAPHIC_DEGREES_ARRAY);
  }
  #[inline]
  pub fn add_POSITION_CARTESIAN_ARRAY(&mut self, POSITION_CARTESIAN_ARRAY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZMPacket::VT_POSITION_CARTESIAN_ARRAY, POSITION_CARTESIAN_ARRAY);
  }
  #[inline]
  pub fn add_BILLBOARD(&mut self, BILLBOARD: flatbuffers::WIPOffset<CZMBillboard<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMBillboard>>(CZMPacket::VT_BILLBOARD, BILLBOARD);
  }
  #[inline]
  pub fn add_LABEL(&mut self, LABEL: flatbuffers::WIPOffset<CZMLabel<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMLabel>>(CZMPacket::VT_LABEL, LABEL);
  }
  #[inline]
  pub fn add_POINT(&mut self, POINT: flatbuffers::WIPOffset<CZMPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMPoint>>(CZMPacket::VT_POINT, POINT);
  }
  #[inline]
  pub fn add_POLYLINE(&mut self, POLYLINE: flatbuffers::WIPOffset<CZMPolyline<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMPolyline>>(CZMPacket::VT_POLYLINE, POLYLINE);
  }
  #[inline]
  pub fn add_POLYGON(&mut self, POLYGON: flatbuffers::WIPOffset<CZMPolygon<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMPolygon>>(CZMPacket::VT_POLYGON, POLYGON);
  }
  #[inline]
  pub fn add_MODEL(&mut self, MODEL: flatbuffers::WIPOffset<CZMModel<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMModel>>(CZMPacket::VT_MODEL, MODEL);
  }
  #[inline]
  pub fn add_PATH(&mut self, PATH: flatbuffers::WIPOffset<CZMPath<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMPath>>(CZMPacket::VT_PATH, PATH);
  }
  #[inline]
  pub fn add_ELLIPSE(&mut self, ELLIPSE: flatbuffers::WIPOffset<CZMEllipse<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CZMEllipse>>(CZMPacket::VT_ELLIPSE, ELLIPSE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMPacketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZMPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZMPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZMPacket");
      ds.field("ID", &self.ID());
      ds.field("NAME", &self.NAME());
      ds.field("PARENT", &self.PARENT());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("AVAILABILITY", &self.AVAILABILITY());
      ds.field("POSITION_CARTOGRAPHIC_DEGREES", &self.POSITION_CARTOGRAPHIC_DEGREES());
      ds.field("POSITION_CARTESIAN", &self.POSITION_CARTESIAN());
      ds.field("POSITION_EPOCH", &self.POSITION_EPOCH());
      ds.field("POSITION_CARTOGRAPHIC_DEGREES_ARRAY", &self.POSITION_CARTOGRAPHIC_DEGREES_ARRAY());
      ds.field("POSITION_CARTESIAN_ARRAY", &self.POSITION_CARTESIAN_ARRAY());
      ds.field("BILLBOARD", &self.BILLBOARD());
      ds.field("LABEL", &self.LABEL());
      ds.field("POINT", &self.POINT());
      ds.field("POLYLINE", &self.POLYLINE());
      ds.field("POLYGON", &self.POLYGON());
      ds.field("MODEL", &self.MODEL());
      ds.field("PATH", &self.PATH());
      ds.field("ELLIPSE", &self.ELLIPSE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMPacketT {
  pub ID: Option<String>,
  pub NAME: Option<String>,
  pub PARENT: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub AVAILABILITY: Option<String>,
  pub POSITION_CARTOGRAPHIC_DEGREES: Option<Box<CZMCartographicDegreesT>>,
  pub POSITION_CARTESIAN: Option<Box<CZMCartesianT>>,
  pub POSITION_EPOCH: Option<String>,
  pub POSITION_CARTOGRAPHIC_DEGREES_ARRAY: Option<Vec<f64>>,
  pub POSITION_CARTESIAN_ARRAY: Option<Vec<f64>>,
  pub BILLBOARD: Option<Box<CZMBillboardT>>,
  pub LABEL: Option<Box<CZMLabelT>>,
  pub POINT: Option<Box<CZMPointT>>,
  pub POLYLINE: Option<Box<CZMPolylineT>>,
  pub POLYGON: Option<Box<CZMPolygonT>>,
  pub MODEL: Option<Box<CZMModelT>>,
  pub PATH: Option<Box<CZMPathT>>,
  pub ELLIPSE: Option<Box<CZMEllipseT>>,
}
impl Default for CZMPacketT {
  fn default() -> Self {
    Self {
      ID: None,
      NAME: None,
      PARENT: None,
      DESCRIPTION: None,
      AVAILABILITY: None,
      POSITION_CARTOGRAPHIC_DEGREES: None,
      POSITION_CARTESIAN: None,
      POSITION_EPOCH: None,
      POSITION_CARTOGRAPHIC_DEGREES_ARRAY: None,
      POSITION_CARTESIAN_ARRAY: None,
      BILLBOARD: None,
      LABEL: None,
      POINT: None,
      POLYLINE: None,
      POLYGON: None,
      MODEL: None,
      PATH: None,
      ELLIPSE: None,
    }
  }
}
impl CZMPacketT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZMPacket<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARENT = self.PARENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AVAILABILITY = self.AVAILABILITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSITION_CARTOGRAPHIC_DEGREES = self.POSITION_CARTOGRAPHIC_DEGREES.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POSITION_CARTESIAN = self.POSITION_CARTESIAN.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POSITION_EPOCH = self.POSITION_EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSITION_CARTOGRAPHIC_DEGREES_ARRAY = self.POSITION_CARTOGRAPHIC_DEGREES_ARRAY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let POSITION_CARTESIAN_ARRAY = self.POSITION_CARTESIAN_ARRAY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let BILLBOARD = self.BILLBOARD.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let LABEL = self.LABEL.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POINT = self.POINT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POLYLINE = self.POLYLINE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POLYGON = self.POLYGON.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let MODEL = self.MODEL.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PATH = self.PATH.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ELLIPSE = self.ELLIPSE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CZMPacket::create(_fbb, &CZMPacketArgs{
      ID,
      NAME,
      PARENT,
      DESCRIPTION,
      AVAILABILITY,
      POSITION_CARTOGRAPHIC_DEGREES,
      POSITION_CARTESIAN,
      POSITION_EPOCH,
      POSITION_CARTOGRAPHIC_DEGREES_ARRAY,
      POSITION_CARTESIAN_ARRAY,
      BILLBOARD,
      LABEL,
      POINT,
      POLYLINE,
      POLYGON,
      MODEL,
      PATH,
      ELLIPSE,
    })
  }
}
pub enum CZMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// CZML Document
pub struct CZM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CZM<'a> {
  type Inner = CZM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CZM<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_CLOCK_CURRENT_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_CLOCK_INTERVAL: flatbuffers::VOffsetT = 10;
  pub const VT_CLOCK_MULTIPLIER: flatbuffers::VOffsetT = 12;
  pub const VT_PACKETS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CZM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CZMArgs<'args>
  ) -> flatbuffers::WIPOffset<CZM<'bldr>> {
    let mut builder = CZMBuilder::new(_fbb);
    builder.add_CLOCK_MULTIPLIER(args.CLOCK_MULTIPLIER);
    if let Some(x) = args.PACKETS { builder.add_PACKETS(x); }
    if let Some(x) = args.CLOCK_INTERVAL { builder.add_CLOCK_INTERVAL(x); }
    if let Some(x) = args.CLOCK_CURRENT_TIME { builder.add_CLOCK_CURRENT_TIME(x); }
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CZMT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let VERSION = self.VERSION().map(|x| {
      x.to_string()
    });
    let CLOCK_CURRENT_TIME = self.CLOCK_CURRENT_TIME().map(|x| {
      x.to_string()
    });
    let CLOCK_INTERVAL = self.CLOCK_INTERVAL().map(|x| {
      x.to_string()
    });
    let CLOCK_MULTIPLIER = self.CLOCK_MULTIPLIER();
    let PACKETS = self.PACKETS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    CZMT {
      NAME,
      VERSION,
      CLOCK_CURRENT_TIME,
      CLOCK_INTERVAL,
      CLOCK_MULTIPLIER,
      PACKETS,
    }
  }

  /// Document-level name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZM::VT_NAME, None)}
  }
  /// Document-level version
  #[inline]
  pub fn VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZM::VT_VERSION, None)}
  }
  /// Clock settings - current time (ISO 8601)
  #[inline]
  pub fn CLOCK_CURRENT_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZM::VT_CLOCK_CURRENT_TIME, None)}
  }
  /// Clock settings - interval (ISO 8601 interval)
  #[inline]
  pub fn CLOCK_INTERVAL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CZM::VT_CLOCK_INTERVAL, None)}
  }
  /// Clock settings - multiplier
  #[inline]
  pub fn CLOCK_MULTIPLIER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CZM::VT_CLOCK_MULTIPLIER, Some(0.0)).unwrap()}
  }
  /// All packets in the document
  #[inline]
  pub fn PACKETS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CZMPacket<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CZMPacket>>>>(CZM::VT_PACKETS, None)}
  }
}

impl flatbuffers::Verifiable for CZM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLOCK_CURRENT_TIME", Self::VT_CLOCK_CURRENT_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLOCK_INTERVAL", Self::VT_CLOCK_INTERVAL, false)?
     .visit_field::<f64>("CLOCK_MULTIPLIER", Self::VT_CLOCK_MULTIPLIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CZMPacket>>>>("PACKETS", Self::VT_PACKETS, false)?
     .finish();
    Ok(())
  }
}
pub struct CZMArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLOCK_CURRENT_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLOCK_INTERVAL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLOCK_MULTIPLIER: f64,
    pub PACKETS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CZMPacket<'a>>>>>,
}
impl<'a> Default for CZMArgs<'a> {
  #[inline]
  fn default() -> Self {
    CZMArgs {
      NAME: None,
      VERSION: None,
      CLOCK_CURRENT_TIME: None,
      CLOCK_INTERVAL: None,
      CLOCK_MULTIPLIER: 0.0,
      PACKETS: None,
    }
  }
}

pub struct CZMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CZMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZM::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZM::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_CLOCK_CURRENT_TIME(&mut self, CLOCK_CURRENT_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZM::VT_CLOCK_CURRENT_TIME, CLOCK_CURRENT_TIME);
  }
  #[inline]
  pub fn add_CLOCK_INTERVAL(&mut self, CLOCK_INTERVAL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZM::VT_CLOCK_INTERVAL, CLOCK_INTERVAL);
  }
  #[inline]
  pub fn add_CLOCK_MULTIPLIER(&mut self, CLOCK_MULTIPLIER: f64) {
    self.fbb_.push_slot::<f64>(CZM::VT_CLOCK_MULTIPLIER, CLOCK_MULTIPLIER, 0.0);
  }
  #[inline]
  pub fn add_PACKETS(&mut self, PACKETS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CZMPacket<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CZM::VT_PACKETS, PACKETS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CZMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CZMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CZM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CZM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CZM");
      ds.field("NAME", &self.NAME());
      ds.field("VERSION", &self.VERSION());
      ds.field("CLOCK_CURRENT_TIME", &self.CLOCK_CURRENT_TIME());
      ds.field("CLOCK_INTERVAL", &self.CLOCK_INTERVAL());
      ds.field("CLOCK_MULTIPLIER", &self.CLOCK_MULTIPLIER());
      ds.field("PACKETS", &self.PACKETS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CZMT {
  pub NAME: Option<String>,
  pub VERSION: Option<String>,
  pub CLOCK_CURRENT_TIME: Option<String>,
  pub CLOCK_INTERVAL: Option<String>,
  pub CLOCK_MULTIPLIER: f64,
  pub PACKETS: Option<Vec<CZMPacketT>>,
}
impl Default for CZMT {
  fn default() -> Self {
    Self {
      NAME: None,
      VERSION: None,
      CLOCK_CURRENT_TIME: None,
      CLOCK_INTERVAL: None,
      CLOCK_MULTIPLIER: 0.0,
      PACKETS: None,
    }
  }
}
impl CZMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CZM<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VERSION = self.VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLOCK_CURRENT_TIME = self.CLOCK_CURRENT_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLOCK_INTERVAL = self.CLOCK_INTERVAL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLOCK_MULTIPLIER = self.CLOCK_MULTIPLIER;
    let PACKETS = self.PACKETS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    CZM::create(_fbb, &CZMArgs{
      NAME,
      VERSION,
      CLOCK_CURRENT_TIME,
      CLOCK_INTERVAL,
      CLOCK_MULTIPLIER,
      PACKETS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CZM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CZM_unchecked`.
pub fn root_as_CZM(buf: &[u8]) -> Result<CZM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CZM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CZM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_CZM_unchecked`.
pub fn size_prefixed_root_as_CZM(buf: &[u8]) -> Result<CZM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CZM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CZM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CZM_unchecked`.
pub fn root_as_CZM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CZM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CZM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CZM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CZM_unchecked`.
pub fn size_prefixed_root_as_CZM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CZM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CZM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CZM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CZM`.
pub unsafe fn root_as_CZM_unchecked(buf: &[u8]) -> CZM {
  flatbuffers::root_unchecked::<CZM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CZM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CZM`.
pub unsafe fn size_prefixed_root_as_CZM_unchecked(buf: &[u8]) -> CZM {
  flatbuffers::size_prefixed_root_unchecked::<CZM>(buf)
}
pub const CZM_IDENTIFIER: &str = "$CZM";

#[inline]
pub fn CZM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CZM_IDENTIFIER, false)
}

#[inline]
pub fn CZM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CZM_IDENTIFIER, true)
}

#[inline]
pub fn finish_CZM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CZM<'a>>) {
  fbb.finish(root, Some(CZM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_CZM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CZM<'a>>) {
  fbb.finish_size_prefixed(root, Some(CZM_IDENTIFIER));
}
