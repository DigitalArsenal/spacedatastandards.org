// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MPEOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Minimum Propagatable Element Set
pub struct MPE<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MPE<'a> {
  type Inner = MPE<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MPE<'a> {
  pub const VT_ENTITY_ID: flatbuffers::VOffsetT = 4;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 6;
  pub const VT_MEAN_MOTION: flatbuffers::VOffsetT = 8;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 10;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 12;
  pub const VT_RA_OF_ASC_NODE: flatbuffers::VOffsetT = 14;
  pub const VT_ARG_OF_PERICENTER: flatbuffers::VOffsetT = 16;
  pub const VT_MEAN_ANOMALY: flatbuffers::VOffsetT = 18;
  pub const VT_BSTAR: flatbuffers::VOffsetT = 20;
  pub const VT_MEAN_ELEMENT_THEORY: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MPE { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MPEArgs<'args>
  ) -> flatbuffers::WIPOffset<MPE<'bldr>> {
    let mut builder = MPEBuilder::new(_fbb);
    builder.add_BSTAR(args.BSTAR);
    builder.add_MEAN_ANOMALY(args.MEAN_ANOMALY);
    builder.add_ARG_OF_PERICENTER(args.ARG_OF_PERICENTER);
    builder.add_RA_OF_ASC_NODE(args.RA_OF_ASC_NODE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_MEAN_MOTION(args.MEAN_MOTION);
    builder.add_EPOCH(args.EPOCH);
    if let Some(x) = args.ENTITY_ID { builder.add_ENTITY_ID(x); }
    builder.add_MEAN_ELEMENT_THEORY(args.MEAN_ELEMENT_THEORY);
    builder.finish()
  }

  pub fn unpack(&self) -> MPET {
    let ENTITY_ID = self.ENTITY_ID().map(|x| {
      x.to_string()
    });
    let EPOCH = self.EPOCH();
    let MEAN_MOTION = self.MEAN_MOTION();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE();
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER();
    let MEAN_ANOMALY = self.MEAN_ANOMALY();
    let BSTAR = self.BSTAR();
    let MEAN_ELEMENT_THEORY = self.MEAN_ELEMENT_THEORY();
    MPET {
      ENTITY_ID,
      EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      MEAN_ANOMALY,
      BSTAR,
      MEAN_ELEMENT_THEORY,
    }
  }

  /// Unique ID as a String
  #[inline]
  pub fn ENTITY_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MPE::VT_ENTITY_ID, None)}
  }
  /// Epoch of Mean Keplerian elements. (UNIX TimeStamp)
  #[inline]
  pub fn EPOCH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_EPOCH, Some(0.0)).unwrap()}
  }
  /// Semi-major axis in km or mean motion in rev/day
  #[inline]
  pub fn MEAN_MOTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_MEAN_MOTION, Some(0.0)).unwrap()}
  }
  /// Eccentricity
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  /// Inclination
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  /// Right ascension of ascending node
  #[inline]
  pub fn RA_OF_ASC_NODE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_RA_OF_ASC_NODE, Some(0.0)).unwrap()}
  }
  /// Argument of pericenter
  #[inline]
  pub fn ARG_OF_PERICENTER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_ARG_OF_PERICENTER, Some(0.0)).unwrap()}
  }
  /// Mean anomaly
  #[inline]
  pub fn MEAN_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_MEAN_ANOMALY, Some(0.0)).unwrap()}
  }
  /// SGP/SGP4 drag-like coefficient (in units 1/[Earth radii])
  #[inline]
  pub fn BSTAR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MPE::VT_BSTAR, Some(0.0)).unwrap()}
  }
  /// Description of the Mean Element Theory. (SGP4,DSST,USM)
  #[inline]
  pub fn MEAN_ELEMENT_THEORY(&self) -> meanElementTheory {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<meanElementTheory>(MPE::VT_MEAN_ELEMENT_THEORY, Some(meanElementTheory::SGP4)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MPE<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENTITY_ID", Self::VT_ENTITY_ID, false)?
     .visit_field::<f64>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("MEAN_MOTION", Self::VT_MEAN_MOTION, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RA_OF_ASC_NODE", Self::VT_RA_OF_ASC_NODE, false)?
     .visit_field::<f64>("ARG_OF_PERICENTER", Self::VT_ARG_OF_PERICENTER, false)?
     .visit_field::<f64>("MEAN_ANOMALY", Self::VT_MEAN_ANOMALY, false)?
     .visit_field::<f64>("BSTAR", Self::VT_BSTAR, false)?
     .visit_field::<meanElementTheory>("MEAN_ELEMENT_THEORY", Self::VT_MEAN_ELEMENT_THEORY, false)?
     .finish();
    Ok(())
  }
}
pub struct MPEArgs<'a> {
    pub ENTITY_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPOCH: f64,
    pub MEAN_MOTION: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RA_OF_ASC_NODE: f64,
    pub ARG_OF_PERICENTER: f64,
    pub MEAN_ANOMALY: f64,
    pub BSTAR: f64,
    pub MEAN_ELEMENT_THEORY: meanElementTheory,
}
impl<'a> Default for MPEArgs<'a> {
  #[inline]
  fn default() -> Self {
    MPEArgs {
      ENTITY_ID: None,
      EPOCH: 0.0,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      MEAN_ANOMALY: 0.0,
      BSTAR: 0.0,
      MEAN_ELEMENT_THEORY: meanElementTheory::SGP4,
    }
  }
}

pub struct MPEBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MPEBuilder<'a, 'b> {
  #[inline]
  pub fn add_ENTITY_ID(&mut self, ENTITY_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MPE::VT_ENTITY_ID, ENTITY_ID);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_EPOCH, EPOCH, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION(&mut self, MEAN_MOTION: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RA_OF_ASC_NODE(&mut self, RA_OF_ASC_NODE: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERICENTER(&mut self, ARG_OF_PERICENTER: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_ARG_OF_PERICENTER, ARG_OF_PERICENTER, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ANOMALY(&mut self, MEAN_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_BSTAR(&mut self, BSTAR: f64) {
    self.fbb_.push_slot::<f64>(MPE::VT_BSTAR, BSTAR, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ELEMENT_THEORY(&mut self, MEAN_ELEMENT_THEORY: meanElementTheory) {
    self.fbb_.push_slot::<meanElementTheory>(MPE::VT_MEAN_ELEMENT_THEORY, MEAN_ELEMENT_THEORY, meanElementTheory::SGP4);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MPEBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MPEBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MPE<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MPE<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MPE");
      ds.field("ENTITY_ID", &self.ENTITY_ID());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("MEAN_MOTION", &self.MEAN_MOTION());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RA_OF_ASC_NODE", &self.RA_OF_ASC_NODE());
      ds.field("ARG_OF_PERICENTER", &self.ARG_OF_PERICENTER());
      ds.field("MEAN_ANOMALY", &self.MEAN_ANOMALY());
      ds.field("BSTAR", &self.BSTAR());
      ds.field("MEAN_ELEMENT_THEORY", &self.MEAN_ELEMENT_THEORY());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MPET {
  pub ENTITY_ID: Option<String>,
  pub EPOCH: f64,
  pub MEAN_MOTION: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RA_OF_ASC_NODE: f64,
  pub ARG_OF_PERICENTER: f64,
  pub MEAN_ANOMALY: f64,
  pub BSTAR: f64,
  pub MEAN_ELEMENT_THEORY: meanElementTheory,
}
impl Default for MPET {
  fn default() -> Self {
    Self {
      ENTITY_ID: None,
      EPOCH: 0.0,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      MEAN_ANOMALY: 0.0,
      BSTAR: 0.0,
      MEAN_ELEMENT_THEORY: meanElementTheory::SGP4,
    }
  }
}
impl MPET {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MPE<'b>> {
    let ENTITY_ID = self.ENTITY_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPOCH = self.EPOCH;
    let MEAN_MOTION = self.MEAN_MOTION;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE;
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER;
    let MEAN_ANOMALY = self.MEAN_ANOMALY;
    let BSTAR = self.BSTAR;
    let MEAN_ELEMENT_THEORY = self.MEAN_ELEMENT_THEORY;
    MPE::create(_fbb, &MPEArgs{
      ENTITY_ID,
      EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      MEAN_ANOMALY,
      BSTAR,
      MEAN_ELEMENT_THEORY,
    })
  }
}
pub enum MPECOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MPECOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MPECOLLECTION<'a> {
  type Inner = MPECOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MPECOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MPECOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MPECOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<MPECOLLECTION<'bldr>> {
    let mut builder = MPECOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MPECOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MPECOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MPE<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MPE>>>>(MPECOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for MPECOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MPE>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MPECOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MPE<'a>>>>>,
}
impl<'a> Default for MPECOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    MPECOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct MPECOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MPECOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MPE<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MPECOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MPECOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MPECOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MPECOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MPECOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MPECOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MPECOLLECTIONT {
  pub RECORDS: Option<Vec<MPET>>,
}
impl Default for MPECOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl MPECOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MPECOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MPECOLLECTION::create(_fbb, &MPECOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MPE`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MPE_unchecked`.
pub fn root_as_MPE(buf: &[u8]) -> Result<MPE, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MPE>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MPE` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_MPE_unchecked`.
pub fn size_prefixed_root_as_MPE(buf: &[u8]) -> Result<MPE, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MPE>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MPE` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MPE_unchecked`.
pub fn root_as_MPE_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MPE<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MPE<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MPE` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MPE_unchecked`.
pub fn size_prefixed_root_as_MPE_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MPE<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MPE<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MPE and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MPE`.
pub unsafe fn root_as_MPE_unchecked(buf: &[u8]) -> MPE {
  flatbuffers::root_unchecked::<MPE>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MPE and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MPE`.
pub unsafe fn size_prefixed_root_as_MPE_unchecked(buf: &[u8]) -> MPE {
  flatbuffers::size_prefixed_root_unchecked::<MPE>(buf)
}
pub const MPE_IDENTIFIER: &str = "$MPE";

#[inline]
pub fn MPE_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MPE_IDENTIFIER, false)
}

#[inline]
pub fn MPE_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MPE_IDENTIFIER, true)
}

#[inline]
pub fn finish_MPE_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<MPE<'a>>) {
  fbb.finish(root, Some(MPE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_MPE_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<MPE<'a>>) {
  fbb.finish_size_prefixed(root, Some(MPE_IDENTIFIER));
}
