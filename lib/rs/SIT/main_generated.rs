// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SITE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SITE_TYPE: i8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SITE_TYPE: [SiteType; 18] = [
  SiteType::LAUNCH_SITE,
  SiteType::OBSERVATION_STATION,
  SiteType::HOBBYIST_OBSERVER,
  SiteType::RESEARCH_FACILITY,
  SiteType::SATELLITE_GROUND_STATION,
  SiteType::SPACEPORT,
  SiteType::MILITARY_BASE,
  SiteType::WEATHER_STATION,
  SiteType::ASTRONOMICAL_OBSERVATORY,
  SiteType::EDUCATIONAL_INSTITUTE,
  SiteType::COMMUNICATION_HUB,
  SiteType::POWER_PLANT,
  SiteType::INDUSTRIAL_COMPLEX,
  SiteType::TRANSPORTATION_HUB,
  SiteType::URBAN_AREA,
  SiteType::NATIONAL_PARK,
  SiteType::HISTORICAL_SITE,
  SiteType::OTHER,
];

/// Enum for the type of site
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SiteType(pub i8);
#[allow(non_upper_case_globals)]
impl SiteType {
  pub const LAUNCH_SITE: Self = Self(0);
  pub const OBSERVATION_STATION: Self = Self(1);
  pub const HOBBYIST_OBSERVER: Self = Self(2);
  pub const RESEARCH_FACILITY: Self = Self(3);
  pub const SATELLITE_GROUND_STATION: Self = Self(4);
  pub const SPACEPORT: Self = Self(5);
  pub const MILITARY_BASE: Self = Self(6);
  pub const WEATHER_STATION: Self = Self(7);
  pub const ASTRONOMICAL_OBSERVATORY: Self = Self(8);
  pub const EDUCATIONAL_INSTITUTE: Self = Self(9);
  pub const COMMUNICATION_HUB: Self = Self(10);
  pub const POWER_PLANT: Self = Self(11);
  pub const INDUSTRIAL_COMPLEX: Self = Self(12);
  pub const TRANSPORTATION_HUB: Self = Self(13);
  pub const URBAN_AREA: Self = Self(14);
  pub const NATIONAL_PARK: Self = Self(15);
  pub const HISTORICAL_SITE: Self = Self(16);
  pub const OTHER: Self = Self(17);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LAUNCH_SITE,
    Self::OBSERVATION_STATION,
    Self::HOBBYIST_OBSERVER,
    Self::RESEARCH_FACILITY,
    Self::SATELLITE_GROUND_STATION,
    Self::SPACEPORT,
    Self::MILITARY_BASE,
    Self::WEATHER_STATION,
    Self::ASTRONOMICAL_OBSERVATORY,
    Self::EDUCATIONAL_INSTITUTE,
    Self::COMMUNICATION_HUB,
    Self::POWER_PLANT,
    Self::INDUSTRIAL_COMPLEX,
    Self::TRANSPORTATION_HUB,
    Self::URBAN_AREA,
    Self::NATIONAL_PARK,
    Self::HISTORICAL_SITE,
    Self::OTHER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LAUNCH_SITE => Some("LAUNCH_SITE"),
      Self::OBSERVATION_STATION => Some("OBSERVATION_STATION"),
      Self::HOBBYIST_OBSERVER => Some("HOBBYIST_OBSERVER"),
      Self::RESEARCH_FACILITY => Some("RESEARCH_FACILITY"),
      Self::SATELLITE_GROUND_STATION => Some("SATELLITE_GROUND_STATION"),
      Self::SPACEPORT => Some("SPACEPORT"),
      Self::MILITARY_BASE => Some("MILITARY_BASE"),
      Self::WEATHER_STATION => Some("WEATHER_STATION"),
      Self::ASTRONOMICAL_OBSERVATORY => Some("ASTRONOMICAL_OBSERVATORY"),
      Self::EDUCATIONAL_INSTITUTE => Some("EDUCATIONAL_INSTITUTE"),
      Self::COMMUNICATION_HUB => Some("COMMUNICATION_HUB"),
      Self::POWER_PLANT => Some("POWER_PLANT"),
      Self::INDUSTRIAL_COMPLEX => Some("INDUSTRIAL_COMPLEX"),
      Self::TRANSPORTATION_HUB => Some("TRANSPORTATION_HUB"),
      Self::URBAN_AREA => Some("URBAN_AREA"),
      Self::NATIONAL_PARK => Some("NATIONAL_PARK"),
      Self::HISTORICAL_SITE => Some("HISTORICAL_SITE"),
      Self::OTHER => Some("OTHER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SiteType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SiteType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SiteType {
    type Output = SiteType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SiteType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SiteType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SiteType {}
pub enum GeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Geometry table with information about geometric properties
pub struct Geometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Geometry<'a> {
  type Inner = Geometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Geometry<'a> {
  pub const VT_GEOMETRY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COORDINATES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Geometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<Geometry<'bldr>> {
    let mut builder = GeometryBuilder::new(_fbb);
    if let Some(x) = args.COORDINATES { builder.add_COORDINATES(x); }
    if let Some(x) = args.GEOMETRY_TYPE { builder.add_GEOMETRY_TYPE(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GeometryT {
    let GEOMETRY_TYPE = self.GEOMETRY_TYPE().map(|x| {
      x.to_string()
    });
    let COORDINATES = self.COORDINATES().map(|x| {
      x.into_iter().collect()
    });
    GeometryT {
      GEOMETRY_TYPE,
      COORDINATES,
    }
  }

  /// Type of geometry
  #[inline]
  pub fn GEOMETRY_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Geometry::VT_GEOMETRY_TYPE, None)}
  }
  /// Coordinates of the geometry
  #[inline]
  pub fn COORDINATES(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(Geometry::VT_COORDINATES, None)}
  }
}

impl flatbuffers::Verifiable for Geometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GEOMETRY_TYPE", Self::VT_GEOMETRY_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("COORDINATES", Self::VT_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct GeometryArgs<'a> {
    pub GEOMETRY_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COORDINATES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for GeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GeometryArgs {
      GEOMETRY_TYPE: None,
      COORDINATES: None,
    }
  }
}

pub struct GeometryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GeometryBuilder<'a, 'b> {
  #[inline]
  pub fn add_GEOMETRY_TYPE(&mut self, GEOMETRY_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_GEOMETRY_TYPE, GEOMETRY_TYPE);
  }
  #[inline]
  pub fn add_COORDINATES(&mut self, COORDINATES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Geometry::VT_COORDINATES, COORDINATES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GeometryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Geometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Geometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Geometry");
      ds.field("GEOMETRY_TYPE", &self.GEOMETRY_TYPE());
      ds.field("COORDINATES", &self.COORDINATES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GeometryT {
  pub GEOMETRY_TYPE: Option<String>,
  pub COORDINATES: Option<Vec<f32>>,
}
impl Default for GeometryT {
  fn default() -> Self {
    Self {
      GEOMETRY_TYPE: None,
      COORDINATES: None,
    }
  }
}
impl GeometryT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Geometry<'b>> {
    let GEOMETRY_TYPE = self.GEOMETRY_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COORDINATES = self.COORDINATES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Geometry::create(_fbb, &GeometryArgs{
      GEOMETRY_TYPE,
      COORDINATES,
    })
  }
}
pub enum SITOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Site Information Message
pub struct SIT<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SIT<'a> {
  type Inner = SIT<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SIT<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ABBREVIATION: flatbuffers::VOffsetT = 8;
  pub const VT_SITE_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_CATCODE: flatbuffers::VOffsetT = 12;
  pub const VT_NETWORK: flatbuffers::VOffsetT = 14;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 16;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 18;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 20;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 22;
  pub const VT_CENTER_POINT_GEOMETRY: flatbuffers::VOffsetT = 24;
  pub const VT_CLASSIFICATION: flatbuffers::VOffsetT = 26;
  pub const VT_CTR_ID: flatbuffers::VOffsetT = 28;
  pub const VT_CREATED_BY: flatbuffers::VOffsetT = 30;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 32;
  pub const VT_MODEL_URL: flatbuffers::VOffsetT = 34;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 36;
  pub const VT_TASKABLE: flatbuffers::VOffsetT = 38;
  pub const VT_OPERATIONAL_STATUS: flatbuffers::VOffsetT = 40;
  pub const VT_ESTABLISHMENT_DATE: flatbuffers::VOffsetT = 42;
  pub const VT_CONTACT_INFO: flatbuffers::VOffsetT = 44;
  pub const VT_ENVIRONMENTAL_IMPACT: flatbuffers::VOffsetT = 46;
  pub const VT_ACCESSIBILITY_INFRA: flatbuffers::VOffsetT = 48;
  pub const VT_INTEGRATED_DEVICES: flatbuffers::VOffsetT = 50;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SIT { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SITArgs<'args>
  ) -> flatbuffers::WIPOffset<SIT<'bldr>> {
    let mut builder = SITBuilder::new(_fbb);
    if let Some(x) = args.INTEGRATED_DEVICES { builder.add_INTEGRATED_DEVICES(x); }
    if let Some(x) = args.ACCESSIBILITY_INFRA { builder.add_ACCESSIBILITY_INFRA(x); }
    if let Some(x) = args.ENVIRONMENTAL_IMPACT { builder.add_ENVIRONMENTAL_IMPACT(x); }
    if let Some(x) = args.CONTACT_INFO { builder.add_CONTACT_INFO(x); }
    if let Some(x) = args.ESTABLISHMENT_DATE { builder.add_ESTABLISHMENT_DATE(x); }
    if let Some(x) = args.OPERATIONAL_STATUS { builder.add_OPERATIONAL_STATUS(x); }
    if let Some(x) = args.SOURCE { builder.add_SOURCE(x); }
    if let Some(x) = args.MODEL_URL { builder.add_MODEL_URL(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.CREATED_BY { builder.add_CREATED_BY(x); }
    if let Some(x) = args.CTR_ID { builder.add_CTR_ID(x); }
    if let Some(x) = args.CLASSIFICATION { builder.add_CLASSIFICATION(x); }
    if let Some(x) = args.CENTER_POINT_GEOMETRY { builder.add_CENTER_POINT_GEOMETRY(x); }
    if let Some(x) = args.GEOMETRY { builder.add_GEOMETRY(x); }
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    if let Some(x) = args.NETWORK { builder.add_NETWORK(x); }
    if let Some(x) = args.CATCODE { builder.add_CATCODE(x); }
    if let Some(x) = args.ABBREVIATION { builder.add_ABBREVIATION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_TASKABLE(args.TASKABLE);
    builder.add_SITE_TYPE(args.SITE_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> SITT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ABBREVIATION = self.ABBREVIATION().map(|x| {
      x.to_string()
    });
    let SITE_TYPE = self.SITE_TYPE();
    let CATCODE = self.CATCODE().map(|x| {
      x.to_string()
    });
    let NETWORK = self.NETWORK().map(|x| {
      x.to_string()
    });
    let LATITUDE = self.LATITUDE();
    let LONGITUDE = self.LONGITUDE();
    let ALTITUDE = self.ALTITUDE();
    let GEOMETRY = self.GEOMETRY().map(|x| {
      Box::new(x.unpack())
    });
    let CENTER_POINT_GEOMETRY = self.CENTER_POINT_GEOMETRY().map(|x| {
      x.into_iter().collect()
    });
    let CLASSIFICATION = self.CLASSIFICATION().map(|x| {
      x.to_string()
    });
    let CTR_ID = self.CTR_ID().map(|x| {
      x.to_string()
    });
    let CREATED_BY = self.CREATED_BY().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MODEL_URL = self.MODEL_URL().map(|x| {
      x.to_string()
    });
    let SOURCE = self.SOURCE().map(|x| {
      x.to_string()
    });
    let TASKABLE = self.TASKABLE();
    let OPERATIONAL_STATUS = self.OPERATIONAL_STATUS().map(|x| {
      x.to_string()
    });
    let ESTABLISHMENT_DATE = self.ESTABLISHMENT_DATE().map(|x| {
      x.to_string()
    });
    let CONTACT_INFO = self.CONTACT_INFO().map(|x| {
      x.to_string()
    });
    let ENVIRONMENTAL_IMPACT = self.ENVIRONMENTAL_IMPACT().map(|x| {
      x.to_string()
    });
    let ACCESSIBILITY_INFRA = self.ACCESSIBILITY_INFRA().map(|x| {
      x.to_string()
    });
    let INTEGRATED_DEVICES = self.INTEGRATED_DEVICES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    SITT {
      ID,
      NAME,
      ABBREVIATION,
      SITE_TYPE,
      CATCODE,
      NETWORK,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      GEOMETRY,
      CENTER_POINT_GEOMETRY,
      CLASSIFICATION,
      CTR_ID,
      CREATED_BY,
      DESCRIPTION,
      MODEL_URL,
      SOURCE,
      TASKABLE,
      OPERATIONAL_STATUS,
      ESTABLISHMENT_DATE,
      CONTACT_INFO,
      ENVIRONMENTAL_IMPACT,
      ACCESSIBILITY_INFRA,
      INTEGRATED_DEVICES,
    }
  }

  /// Unique identifier for the site, BE_NUMBER
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_ID, None)}
  }
  /// Name of the site
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_NAME, None)}
  }
  /// Abbreviation
  #[inline]
  pub fn ABBREVIATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_ABBREVIATION, None)}
  }
  /// Site type as defined in SiteType enum
  #[inline]
  pub fn SITE_TYPE(&self) -> SiteType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SiteType>(SIT::VT_SITE_TYPE, Some(SiteType::LAUNCH_SITE)).unwrap()}
  }
  /// Site type CATCODE
  #[inline]
  pub fn CATCODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_CATCODE, None)}
  }
  /// Network identifier
  #[inline]
  pub fn NETWORK(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_NETWORK, None)}
  }
  /// Latitude of the site
  #[inline]
  pub fn LATITUDE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SIT::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Longitude of the site
  #[inline]
  pub fn LONGITUDE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SIT::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude of the site
  #[inline]
  pub fn ALTITUDE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SIT::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Geometry of the site
  #[inline]
  pub fn GEOMETRY(&self) -> Option<Geometry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Geometry>>(SIT::VT_GEOMETRY, None)}
  }
  /// Center point geometry coordinates
  #[inline]
  pub fn CENTER_POINT_GEOMETRY(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(SIT::VT_CENTER_POINT_GEOMETRY, None)}
  }
  /// Classification marking of the site
  #[inline]
  pub fn CLASSIFICATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_CLASSIFICATION, None)}
  }
  /// CTR ISO 3166 Numeric code as string
  #[inline]
  pub fn CTR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_CTR_ID, None)}
  }
  /// Identifier of the user who created the site data
  #[inline]
  pub fn CREATED_BY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_CREATED_BY, None)}
  }
  /// Description of the site
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_DESCRIPTION, None)}
  }
  /// URL for the 3D model of the site
  #[inline]
  pub fn MODEL_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_MODEL_URL, None)}
  }
  /// Source of the site data
  #[inline]
  pub fn SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_SOURCE, None)}
  }
  /// Indicates if the site is taskable
  #[inline]
  pub fn TASKABLE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SIT::VT_TASKABLE, Some(false)).unwrap()}
  }
  /// Operational status of the site (e.g., active, inactive, under construction)
  #[inline]
  pub fn OPERATIONAL_STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_OPERATIONAL_STATUS, None)}
  }
  /// Date of establishment
  #[inline]
  pub fn ESTABLISHMENT_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_ESTABLISHMENT_DATE, None)}
  }
  /// Contact information for the site
  #[inline]
  pub fn CONTACT_INFO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_CONTACT_INFO, None)}
  }
  /// Environmental impact or considerations
  #[inline]
  pub fn ENVIRONMENTAL_IMPACT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_ENVIRONMENTAL_IMPACT, None)}
  }
  /// Accessibility and infrastructure details
  #[inline]
  pub fn ACCESSIBILITY_INFRA(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SIT::VT_ACCESSIBILITY_INFRA, None)}
  }
  /// Vector of Integrated Devices (IDM)
  #[inline]
  pub fn INTEGRATED_DEVICES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IDM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IDM>>>>(SIT::VT_INTEGRATED_DEVICES, None)}
  }
}

impl flatbuffers::Verifiable for SIT<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ABBREVIATION", Self::VT_ABBREVIATION, false)?
     .visit_field::<SiteType>("SITE_TYPE", Self::VT_SITE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CATCODE", Self::VT_CATCODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NETWORK", Self::VT_NETWORK, false)?
     .visit_field::<f32>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f32>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f32>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Geometry>>("GEOMETRY", Self::VT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("CENTER_POINT_GEOMETRY", Self::VT_CENTER_POINT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION", Self::VT_CLASSIFICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CTR_ID", Self::VT_CTR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATED_BY", Self::VT_CREATED_BY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MODEL_URL", Self::VT_MODEL_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE", Self::VT_SOURCE, false)?
     .visit_field::<bool>("TASKABLE", Self::VT_TASKABLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPERATIONAL_STATUS", Self::VT_OPERATIONAL_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ESTABLISHMENT_DATE", Self::VT_ESTABLISHMENT_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTACT_INFO", Self::VT_CONTACT_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENVIRONMENTAL_IMPACT", Self::VT_ENVIRONMENTAL_IMPACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ACCESSIBILITY_INFRA", Self::VT_ACCESSIBILITY_INFRA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IDM>>>>("INTEGRATED_DEVICES", Self::VT_INTEGRATED_DEVICES, false)?
     .finish();
    Ok(())
  }
}
pub struct SITArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ABBREVIATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SITE_TYPE: SiteType,
    pub CATCODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NETWORK: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LATITUDE: f32,
    pub LONGITUDE: f32,
    pub ALTITUDE: f32,
    pub GEOMETRY: Option<flatbuffers::WIPOffset<Geometry<'a>>>,
    pub CENTER_POINT_GEOMETRY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub CLASSIFICATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CTR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CREATED_BY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MODEL_URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TASKABLE: bool,
    pub OPERATIONAL_STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ESTABLISHMENT_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTACT_INFO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENVIRONMENTAL_IMPACT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ACCESSIBILITY_INFRA: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTEGRATED_DEVICES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IDM<'a>>>>>,
}
impl<'a> Default for SITArgs<'a> {
  #[inline]
  fn default() -> Self {
    SITArgs {
      ID: None,
      NAME: None,
      ABBREVIATION: None,
      SITE_TYPE: SiteType::LAUNCH_SITE,
      CATCODE: None,
      NETWORK: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      GEOMETRY: None,
      CENTER_POINT_GEOMETRY: None,
      CLASSIFICATION: None,
      CTR_ID: None,
      CREATED_BY: None,
      DESCRIPTION: None,
      MODEL_URL: None,
      SOURCE: None,
      TASKABLE: false,
      OPERATIONAL_STATUS: None,
      ESTABLISHMENT_DATE: None,
      CONTACT_INFO: None,
      ENVIRONMENTAL_IMPACT: None,
      ACCESSIBILITY_INFRA: None,
      INTEGRATED_DEVICES: None,
    }
  }
}

pub struct SITBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SITBuilder<'a, 'b> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_ID, ID);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ABBREVIATION(&mut self, ABBREVIATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_ABBREVIATION, ABBREVIATION);
  }
  #[inline]
  pub fn add_SITE_TYPE(&mut self, SITE_TYPE: SiteType) {
    self.fbb_.push_slot::<SiteType>(SIT::VT_SITE_TYPE, SITE_TYPE, SiteType::LAUNCH_SITE);
  }
  #[inline]
  pub fn add_CATCODE(&mut self, CATCODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CATCODE, CATCODE);
  }
  #[inline]
  pub fn add_NETWORK(&mut self, NETWORK: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_NETWORK, NETWORK);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f32) {
    self.fbb_.push_slot::<f32>(SIT::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f32) {
    self.fbb_.push_slot::<f32>(SIT::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f32) {
    self.fbb_.push_slot::<f32>(SIT::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_GEOMETRY(&mut self, GEOMETRY: flatbuffers::WIPOffset<Geometry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Geometry>>(SIT::VT_GEOMETRY, GEOMETRY);
  }
  #[inline]
  pub fn add_CENTER_POINT_GEOMETRY(&mut self, CENTER_POINT_GEOMETRY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CENTER_POINT_GEOMETRY, CENTER_POINT_GEOMETRY);
  }
  #[inline]
  pub fn add_CLASSIFICATION(&mut self, CLASSIFICATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CLASSIFICATION, CLASSIFICATION);
  }
  #[inline]
  pub fn add_CTR_ID(&mut self, CTR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CTR_ID, CTR_ID);
  }
  #[inline]
  pub fn add_CREATED_BY(&mut self, CREATED_BY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CREATED_BY, CREATED_BY);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_MODEL_URL(&mut self, MODEL_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_MODEL_URL, MODEL_URL);
  }
  #[inline]
  pub fn add_SOURCE(&mut self, SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_SOURCE, SOURCE);
  }
  #[inline]
  pub fn add_TASKABLE(&mut self, TASKABLE: bool) {
    self.fbb_.push_slot::<bool>(SIT::VT_TASKABLE, TASKABLE, false);
  }
  #[inline]
  pub fn add_OPERATIONAL_STATUS(&mut self, OPERATIONAL_STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_OPERATIONAL_STATUS, OPERATIONAL_STATUS);
  }
  #[inline]
  pub fn add_ESTABLISHMENT_DATE(&mut self, ESTABLISHMENT_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_ESTABLISHMENT_DATE, ESTABLISHMENT_DATE);
  }
  #[inline]
  pub fn add_CONTACT_INFO(&mut self, CONTACT_INFO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_CONTACT_INFO, CONTACT_INFO);
  }
  #[inline]
  pub fn add_ENVIRONMENTAL_IMPACT(&mut self, ENVIRONMENTAL_IMPACT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_ENVIRONMENTAL_IMPACT, ENVIRONMENTAL_IMPACT);
  }
  #[inline]
  pub fn add_ACCESSIBILITY_INFRA(&mut self, ACCESSIBILITY_INFRA: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_ACCESSIBILITY_INFRA, ACCESSIBILITY_INFRA);
  }
  #[inline]
  pub fn add_INTEGRATED_DEVICES(&mut self, INTEGRATED_DEVICES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IDM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SIT::VT_INTEGRATED_DEVICES, INTEGRATED_DEVICES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SITBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SITBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SIT<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SIT<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SIT");
      ds.field("ID", &self.ID());
      ds.field("NAME", &self.NAME());
      ds.field("ABBREVIATION", &self.ABBREVIATION());
      ds.field("SITE_TYPE", &self.SITE_TYPE());
      ds.field("CATCODE", &self.CATCODE());
      ds.field("NETWORK", &self.NETWORK());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("GEOMETRY", &self.GEOMETRY());
      ds.field("CENTER_POINT_GEOMETRY", &self.CENTER_POINT_GEOMETRY());
      ds.field("CLASSIFICATION", &self.CLASSIFICATION());
      ds.field("CTR_ID", &self.CTR_ID());
      ds.field("CREATED_BY", &self.CREATED_BY());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("MODEL_URL", &self.MODEL_URL());
      ds.field("SOURCE", &self.SOURCE());
      ds.field("TASKABLE", &self.TASKABLE());
      ds.field("OPERATIONAL_STATUS", &self.OPERATIONAL_STATUS());
      ds.field("ESTABLISHMENT_DATE", &self.ESTABLISHMENT_DATE());
      ds.field("CONTACT_INFO", &self.CONTACT_INFO());
      ds.field("ENVIRONMENTAL_IMPACT", &self.ENVIRONMENTAL_IMPACT());
      ds.field("ACCESSIBILITY_INFRA", &self.ACCESSIBILITY_INFRA());
      ds.field("INTEGRATED_DEVICES", &self.INTEGRATED_DEVICES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SITT {
  pub ID: Option<String>,
  pub NAME: Option<String>,
  pub ABBREVIATION: Option<String>,
  pub SITE_TYPE: SiteType,
  pub CATCODE: Option<String>,
  pub NETWORK: Option<String>,
  pub LATITUDE: f32,
  pub LONGITUDE: f32,
  pub ALTITUDE: f32,
  pub GEOMETRY: Option<Box<GeometryT>>,
  pub CENTER_POINT_GEOMETRY: Option<Vec<f32>>,
  pub CLASSIFICATION: Option<String>,
  pub CTR_ID: Option<String>,
  pub CREATED_BY: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub MODEL_URL: Option<String>,
  pub SOURCE: Option<String>,
  pub TASKABLE: bool,
  pub OPERATIONAL_STATUS: Option<String>,
  pub ESTABLISHMENT_DATE: Option<String>,
  pub CONTACT_INFO: Option<String>,
  pub ENVIRONMENTAL_IMPACT: Option<String>,
  pub ACCESSIBILITY_INFRA: Option<String>,
  pub INTEGRATED_DEVICES: Option<Vec<IDMT>>,
}
impl Default for SITT {
  fn default() -> Self {
    Self {
      ID: None,
      NAME: None,
      ABBREVIATION: None,
      SITE_TYPE: SiteType::LAUNCH_SITE,
      CATCODE: None,
      NETWORK: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      GEOMETRY: None,
      CENTER_POINT_GEOMETRY: None,
      CLASSIFICATION: None,
      CTR_ID: None,
      CREATED_BY: None,
      DESCRIPTION: None,
      MODEL_URL: None,
      SOURCE: None,
      TASKABLE: false,
      OPERATIONAL_STATUS: None,
      ESTABLISHMENT_DATE: None,
      CONTACT_INFO: None,
      ENVIRONMENTAL_IMPACT: None,
      ACCESSIBILITY_INFRA: None,
      INTEGRATED_DEVICES: None,
    }
  }
}
impl SITT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SIT<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ABBREVIATION = self.ABBREVIATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SITE_TYPE = self.SITE_TYPE;
    let CATCODE = self.CATCODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NETWORK = self.NETWORK.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LATITUDE = self.LATITUDE;
    let LONGITUDE = self.LONGITUDE;
    let ALTITUDE = self.ALTITUDE;
    let GEOMETRY = self.GEOMETRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CENTER_POINT_GEOMETRY = self.CENTER_POINT_GEOMETRY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CLASSIFICATION = self.CLASSIFICATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CTR_ID = self.CTR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CREATED_BY = self.CREATED_BY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MODEL_URL = self.MODEL_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE = self.SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TASKABLE = self.TASKABLE;
    let OPERATIONAL_STATUS = self.OPERATIONAL_STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ESTABLISHMENT_DATE = self.ESTABLISHMENT_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTACT_INFO = self.CONTACT_INFO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENVIRONMENTAL_IMPACT = self.ENVIRONMENTAL_IMPACT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ACCESSIBILITY_INFRA = self.ACCESSIBILITY_INFRA.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTEGRATED_DEVICES = self.INTEGRATED_DEVICES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    SIT::create(_fbb, &SITArgs{
      ID,
      NAME,
      ABBREVIATION,
      SITE_TYPE,
      CATCODE,
      NETWORK,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      GEOMETRY,
      CENTER_POINT_GEOMETRY,
      CLASSIFICATION,
      CTR_ID,
      CREATED_BY,
      DESCRIPTION,
      MODEL_URL,
      SOURCE,
      TASKABLE,
      OPERATIONAL_STATUS,
      ESTABLISHMENT_DATE,
      CONTACT_INFO,
      ENVIRONMENTAL_IMPACT,
      ACCESSIBILITY_INFRA,
      INTEGRATED_DEVICES,
    })
  }
}
pub enum SITCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of SIT records
pub struct SITCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SITCOLLECTION<'a> {
  type Inner = SITCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SITCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SITCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SITCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<SITCOLLECTION<'bldr>> {
    let mut builder = SITCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SITCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    SITCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SIT<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SIT>>>>(SITCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for SITCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SIT>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SITCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SIT<'a>>>>>,
}
impl<'a> Default for SITCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    SITCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct SITCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SITCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SIT<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SITCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SITCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SITCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SITCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SITCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SITCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SITCOLLECTIONT {
  pub RECORDS: Option<Vec<SITT>>,
}
impl Default for SITCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl SITCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SITCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    SITCOLLECTION::create(_fbb, &SITCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SITCOLLECTION`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SITCOLLECTION_unchecked`.
pub fn root_as_SITCOLLECTION(buf: &[u8]) -> Result<SITCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SITCOLLECTION>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SITCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SITCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_SITCOLLECTION(buf: &[u8]) -> Result<SITCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SITCOLLECTION>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SITCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SITCOLLECTION_unchecked`.
pub fn root_as_SITCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SITCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SITCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SITCOLLECTION` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SITCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_SITCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SITCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SITCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SITCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SITCOLLECTION`.
pub unsafe fn root_as_SITCOLLECTION_unchecked(buf: &[u8]) -> SITCOLLECTION {
  flatbuffers::root_unchecked::<SITCOLLECTION>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SITCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SITCOLLECTION`.
pub unsafe fn size_prefixed_root_as_SITCOLLECTION_unchecked(buf: &[u8]) -> SITCOLLECTION {
  flatbuffers::size_prefixed_root_unchecked::<SITCOLLECTION>(buf)
}
pub const SITCOLLECTION_IDENTIFIER: &str = "$SIT";

#[inline]
pub fn SITCOLLECTION_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SITCOLLECTION_IDENTIFIER, false)
}

#[inline]
pub fn SITCOLLECTION_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SITCOLLECTION_IDENTIFIER, true)
}

#[inline]
pub fn finish_SITCOLLECTION_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<SITCOLLECTION<'a>>) {
  fbb.finish(root, Some(SITCOLLECTION_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SITCOLLECTION_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<SITCOLLECTION<'a>>) {
  fbb.finish_size_prefixed(root, Some(SITCOLLECTION_IDENTIFIER));
}
