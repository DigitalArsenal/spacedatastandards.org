// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum RDOOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Radar Observation
pub struct RDO<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RDO<'a> {
  type Inner = RDO<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RDO<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OB_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 8;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 10;
  pub const VT_TASK_ID: flatbuffers::VOffsetT = 12;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 14;
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 16;
  pub const VT_OB_POSITION: flatbuffers::VOffsetT = 18;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 20;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 22;
  pub const VT_UCT: flatbuffers::VOffsetT = 24;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 26;
  pub const VT_AZIMUTH_UNC: flatbuffers::VOffsetT = 28;
  pub const VT_AZIMUTH_BIAS: flatbuffers::VOffsetT = 30;
  pub const VT_AZIMUTH_RATE: flatbuffers::VOffsetT = 32;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 34;
  pub const VT_ELEVATION_UNC: flatbuffers::VOffsetT = 36;
  pub const VT_ELEVATION_BIAS: flatbuffers::VOffsetT = 38;
  pub const VT_ELEVATION_RATE: flatbuffers::VOffsetT = 40;
  pub const VT_RANGE: flatbuffers::VOffsetT = 42;
  pub const VT_RANGE_ACCEL: flatbuffers::VOffsetT = 44;
  pub const VT_RANGE_ACCEL_UNC: flatbuffers::VOffsetT = 46;
  pub const VT_RANGE_UNC: flatbuffers::VOffsetT = 48;
  pub const VT_RANGE_BIAS: flatbuffers::VOffsetT = 50;
  pub const VT_RANGE_RATE: flatbuffers::VOffsetT = 52;
  pub const VT_RANGE_RATE_UNC: flatbuffers::VOffsetT = 54;
  pub const VT_DOPPLER: flatbuffers::VOffsetT = 56;
  pub const VT_DOPPLER_UNC: flatbuffers::VOffsetT = 58;
  pub const VT_RA: flatbuffers::VOffsetT = 60;
  pub const VT_DECLINATION: flatbuffers::VOffsetT = 62;
  pub const VT_X: flatbuffers::VOffsetT = 64;
  pub const VT_Y: flatbuffers::VOffsetT = 66;
  pub const VT_Z: flatbuffers::VOffsetT = 68;
  pub const VT_XVEL: flatbuffers::VOffsetT = 70;
  pub const VT_YVEL: flatbuffers::VOffsetT = 72;
  pub const VT_ZVEL: flatbuffers::VOffsetT = 74;
  pub const VT_SENX: flatbuffers::VOffsetT = 76;
  pub const VT_SENY: flatbuffers::VOffsetT = 78;
  pub const VT_SENZ: flatbuffers::VOffsetT = 80;
  pub const VT_RCS: flatbuffers::VOffsetT = 82;
  pub const VT_RCS_UNC: flatbuffers::VOffsetT = 84;
  pub const VT_ORTHOGONAL_RCS: flatbuffers::VOffsetT = 86;
  pub const VT_ORTHOGONAL_RCS_UNC: flatbuffers::VOffsetT = 88;
  pub const VT_SNR: flatbuffers::VOffsetT = 90;
  pub const VT_BEAM: flatbuffers::VOffsetT = 92;
  pub const VT_TIMING_BIAS: flatbuffers::VOffsetT = 94;
  pub const VT_RAW_FILE_URI: flatbuffers::VOffsetT = 96;
  pub const VT_TAGS: flatbuffers::VOffsetT = 98;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 100;
  pub const VT_SEN_REFERENCE_FRAME: flatbuffers::VOffsetT = 102;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 104;
  pub const VT_TYPE: flatbuffers::VOffsetT = 106;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RDO { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RDOArgs<'args>
  ) -> flatbuffers::WIPOffset<RDO<'bldr>> {
    let mut builder = RDOBuilder::new(_fbb);
    builder.add_TIMING_BIAS(args.TIMING_BIAS);
    builder.add_BEAM(args.BEAM);
    builder.add_SNR(args.SNR);
    builder.add_ORTHOGONAL_RCS_UNC(args.ORTHOGONAL_RCS_UNC);
    builder.add_ORTHOGONAL_RCS(args.ORTHOGONAL_RCS);
    builder.add_RCS_UNC(args.RCS_UNC);
    builder.add_RCS(args.RCS);
    builder.add_SENZ(args.SENZ);
    builder.add_SENY(args.SENY);
    builder.add_SENX(args.SENX);
    builder.add_ZVEL(args.ZVEL);
    builder.add_YVEL(args.YVEL);
    builder.add_XVEL(args.XVEL);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    builder.add_DECLINATION(args.DECLINATION);
    builder.add_RA(args.RA);
    builder.add_DOPPLER_UNC(args.DOPPLER_UNC);
    builder.add_DOPPLER(args.DOPPLER);
    builder.add_RANGE_RATE_UNC(args.RANGE_RATE_UNC);
    builder.add_RANGE_RATE(args.RANGE_RATE);
    builder.add_RANGE_BIAS(args.RANGE_BIAS);
    builder.add_RANGE_UNC(args.RANGE_UNC);
    builder.add_RANGE_ACCEL_UNC(args.RANGE_ACCEL_UNC);
    builder.add_RANGE_ACCEL(args.RANGE_ACCEL);
    builder.add_RANGE(args.RANGE);
    builder.add_ELEVATION_RATE(args.ELEVATION_RATE);
    builder.add_ELEVATION_BIAS(args.ELEVATION_BIAS);
    builder.add_ELEVATION_UNC(args.ELEVATION_UNC);
    builder.add_ELEVATION(args.ELEVATION);
    builder.add_AZIMUTH_RATE(args.AZIMUTH_RATE);
    builder.add_AZIMUTH_BIAS(args.AZIMUTH_BIAS);
    builder.add_AZIMUTH_UNC(args.AZIMUTH_UNC);
    builder.add_AZIMUTH(args.AZIMUTH);
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    if let Some(x) = args.SEN_REFERENCE_FRAME { builder.add_SEN_REFERENCE_FRAME(x); }
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.RAW_FILE_URI { builder.add_RAW_FILE_URI(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    if let Some(x) = args.OB_POSITION { builder.add_OB_POSITION(x); }
    if let Some(x) = args.TRACK_ID { builder.add_TRACK_ID(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.TASK_ID { builder.add_TASK_ID(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.OB_TIME { builder.add_OB_TIME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_UCT(args.UCT);
    builder.finish()
  }

  pub fn unpack(&self) -> RDOT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let OB_TIME = self.OB_TIME().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let TASK_ID = self.TASK_ID().map(|x| {
      x.to_string()
    });
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let TRACK_ID = self.TRACK_ID().map(|x| {
      x.to_string()
    });
    let OB_POSITION = self.OB_POSITION().map(|x| {
      x.to_string()
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let UCT = self.UCT();
    let AZIMUTH = self.AZIMUTH();
    let AZIMUTH_UNC = self.AZIMUTH_UNC();
    let AZIMUTH_BIAS = self.AZIMUTH_BIAS();
    let AZIMUTH_RATE = self.AZIMUTH_RATE();
    let ELEVATION = self.ELEVATION();
    let ELEVATION_UNC = self.ELEVATION_UNC();
    let ELEVATION_BIAS = self.ELEVATION_BIAS();
    let ELEVATION_RATE = self.ELEVATION_RATE();
    let RANGE = self.RANGE();
    let RANGE_ACCEL = self.RANGE_ACCEL();
    let RANGE_ACCEL_UNC = self.RANGE_ACCEL_UNC();
    let RANGE_UNC = self.RANGE_UNC();
    let RANGE_BIAS = self.RANGE_BIAS();
    let RANGE_RATE = self.RANGE_RATE();
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC();
    let DOPPLER = self.DOPPLER();
    let DOPPLER_UNC = self.DOPPLER_UNC();
    let RA = self.RA();
    let DECLINATION = self.DECLINATION();
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let XVEL = self.XVEL();
    let YVEL = self.YVEL();
    let ZVEL = self.ZVEL();
    let SENX = self.SENX();
    let SENY = self.SENY();
    let SENZ = self.SENZ();
    let RCS = self.RCS();
    let RCS_UNC = self.RCS_UNC();
    let ORTHOGONAL_RCS = self.ORTHOGONAL_RCS();
    let ORTHOGONAL_RCS_UNC = self.ORTHOGONAL_RCS_UNC();
    let SNR = self.SNR();
    let BEAM = self.BEAM();
    let TIMING_BIAS = self.TIMING_BIAS();
    let RAW_FILE_URI = self.RAW_FILE_URI().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    RDOT {
      ID,
      OB_TIME,
      ID_SENSOR,
      SAT_NO,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      OB_POSITION,
      ORIG_OBJECT_ID,
      ORIG_SENSOR_ID,
      UCT,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_BIAS,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_BIAS,
      ELEVATION_RATE,
      RANGE,
      RANGE_ACCEL,
      RANGE_ACCEL_UNC,
      RANGE_UNC,
      RANGE_BIAS,
      RANGE_RATE,
      RANGE_RATE_UNC,
      DOPPLER,
      DOPPLER_UNC,
      RA,
      DECLINATION,
      X,
      Y,
      Z,
      XVEL,
      YVEL,
      ZVEL,
      SENX,
      SENY,
      SENZ,
      RCS,
      RCS_UNC,
      ORTHOGONAL_RCS,
      ORTHOGONAL_RCS_UNC,
      SNR,
      BEAM,
      TIMING_BIAS,
      RAW_FILE_URI,
      TAGS,
      ON_ORBIT,
      SEN_REFERENCE_FRAME,
      DESCRIPTOR,
      TYPE,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_ID, None)}
  }
  #[inline]
  pub fn OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_OB_TIME, None)}
  }
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_ID_SENSOR, None)}
  }
  #[inline]
  pub fn SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RDO::VT_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TASK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_TASK_ID, None)}
  }
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn TRACK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_TRACK_ID, None)}
  }
  #[inline]
  pub fn OB_POSITION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_OB_POSITION, None)}
  }
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_ORIG_OBJECT_ID, None)}
  }
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_ORIG_SENSOR_ID, None)}
  }
  #[inline]
  pub fn UCT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RDO::VT_UCT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_AZIMUTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AZIMUTH_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_AZIMUTH_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AZIMUTH_BIAS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_AZIMUTH_BIAS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AZIMUTH_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_AZIMUTH_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ELEVATION_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION_BIAS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ELEVATION_BIAS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ELEVATION_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_ACCEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_ACCEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_ACCEL_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_ACCEL_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_BIAS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_BIAS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RANGE_RATE_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RANGE_RATE_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DOPPLER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_DOPPLER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DOPPLER_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_DOPPLER_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DECLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_DECLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn XVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_XVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn YVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_YVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ZVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ZVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_SENX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_SENY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_SENZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RCS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RCS_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_RCS_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ORTHOGONAL_RCS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ORTHOGONAL_RCS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ORTHOGONAL_RCS_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_ORTHOGONAL_RCS_UNC, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SNR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_SNR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BEAM(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_BEAM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TIMING_BIAS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RDO::VT_TIMING_BIAS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RAW_FILE_URI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_RAW_FILE_URI, None)}
  }
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RDO::VT_TAGS, None)}
  }
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_ON_ORBIT, None)}
  }
  #[inline]
  pub fn SEN_REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_SEN_REFERENCE_FRAME, None)}
  }
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_DESCRIPTOR, None)}
  }
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RDO::VT_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for RDO<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_TIME", Self::VT_OB_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<i32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TASK_ID", Self::VT_TASK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_ID", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_POSITION", Self::VT_OB_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<bool>("UCT", Self::VT_UCT, false)?
     .visit_field::<f64>("AZIMUTH", Self::VT_AZIMUTH, false)?
     .visit_field::<f64>("AZIMUTH_UNC", Self::VT_AZIMUTH_UNC, false)?
     .visit_field::<f64>("AZIMUTH_BIAS", Self::VT_AZIMUTH_BIAS, false)?
     .visit_field::<f64>("AZIMUTH_RATE", Self::VT_AZIMUTH_RATE, false)?
     .visit_field::<f64>("ELEVATION", Self::VT_ELEVATION, false)?
     .visit_field::<f64>("ELEVATION_UNC", Self::VT_ELEVATION_UNC, false)?
     .visit_field::<f64>("ELEVATION_BIAS", Self::VT_ELEVATION_BIAS, false)?
     .visit_field::<f64>("ELEVATION_RATE", Self::VT_ELEVATION_RATE, false)?
     .visit_field::<f64>("RANGE", Self::VT_RANGE, false)?
     .visit_field::<f64>("RANGE_ACCEL", Self::VT_RANGE_ACCEL, false)?
     .visit_field::<f64>("RANGE_ACCEL_UNC", Self::VT_RANGE_ACCEL_UNC, false)?
     .visit_field::<f64>("RANGE_UNC", Self::VT_RANGE_UNC, false)?
     .visit_field::<f64>("RANGE_BIAS", Self::VT_RANGE_BIAS, false)?
     .visit_field::<f64>("RANGE_RATE", Self::VT_RANGE_RATE, false)?
     .visit_field::<f64>("RANGE_RATE_UNC", Self::VT_RANGE_RATE_UNC, false)?
     .visit_field::<f64>("DOPPLER", Self::VT_DOPPLER, false)?
     .visit_field::<f64>("DOPPLER_UNC", Self::VT_DOPPLER_UNC, false)?
     .visit_field::<f64>("RA", Self::VT_RA, false)?
     .visit_field::<f64>("DECLINATION", Self::VT_DECLINATION, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("XVEL", Self::VT_XVEL, false)?
     .visit_field::<f64>("YVEL", Self::VT_YVEL, false)?
     .visit_field::<f64>("ZVEL", Self::VT_ZVEL, false)?
     .visit_field::<f64>("SENX", Self::VT_SENX, false)?
     .visit_field::<f64>("SENY", Self::VT_SENY, false)?
     .visit_field::<f64>("SENZ", Self::VT_SENZ, false)?
     .visit_field::<f64>("RCS", Self::VT_RCS, false)?
     .visit_field::<f64>("RCS_UNC", Self::VT_RCS_UNC, false)?
     .visit_field::<f64>("ORTHOGONAL_RCS", Self::VT_ORTHOGONAL_RCS, false)?
     .visit_field::<f64>("ORTHOGONAL_RCS_UNC", Self::VT_ORTHOGONAL_RCS_UNC, false)?
     .visit_field::<f64>("SNR", Self::VT_SNR, false)?
     .visit_field::<f64>("BEAM", Self::VT_BEAM, false)?
     .visit_field::<f64>("TIMING_BIAS", Self::VT_TIMING_BIAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RAW_FILE_URI", Self::VT_RAW_FILE_URI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_REFERENCE_FRAME", Self::VT_SEN_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct RDOArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: i32,
    pub TASK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_POSITION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UCT: bool,
    pub AZIMUTH: f64,
    pub AZIMUTH_UNC: f64,
    pub AZIMUTH_BIAS: f64,
    pub AZIMUTH_RATE: f64,
    pub ELEVATION: f64,
    pub ELEVATION_UNC: f64,
    pub ELEVATION_BIAS: f64,
    pub ELEVATION_RATE: f64,
    pub RANGE: f64,
    pub RANGE_ACCEL: f64,
    pub RANGE_ACCEL_UNC: f64,
    pub RANGE_UNC: f64,
    pub RANGE_BIAS: f64,
    pub RANGE_RATE: f64,
    pub RANGE_RATE_UNC: f64,
    pub DOPPLER: f64,
    pub DOPPLER_UNC: f64,
    pub RA: f64,
    pub DECLINATION: f64,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub XVEL: f64,
    pub YVEL: f64,
    pub ZVEL: f64,
    pub SENX: f64,
    pub SENY: f64,
    pub SENZ: f64,
    pub RCS: f64,
    pub RCS_UNC: f64,
    pub ORTHOGONAL_RCS: f64,
    pub ORTHOGONAL_RCS_UNC: f64,
    pub SNR: f64,
    pub BEAM: f64,
    pub TIMING_BIAS: f64,
    pub RAW_FILE_URI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEN_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RDOArgs<'a> {
  #[inline]
  fn default() -> Self {
    RDOArgs {
      ID: None,
      OB_TIME: None,
      ID_SENSOR: None,
      SAT_NO: 0,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      OB_POSITION: None,
      ORIG_OBJECT_ID: None,
      ORIG_SENSOR_ID: None,
      UCT: false,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_BIAS: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_BIAS: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_ACCEL: 0.0,
      RANGE_ACCEL_UNC: 0.0,
      RANGE_UNC: 0.0,
      RANGE_BIAS: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      DOPPLER: 0.0,
      DOPPLER_UNC: 0.0,
      RA: 0.0,
      DECLINATION: 0.0,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      XVEL: 0.0,
      YVEL: 0.0,
      ZVEL: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      RCS: 0.0,
      RCS_UNC: 0.0,
      ORTHOGONAL_RCS: 0.0,
      ORTHOGONAL_RCS_UNC: 0.0,
      SNR: 0.0,
      BEAM: 0.0,
      TIMING_BIAS: 0.0,
      RAW_FILE_URI: None,
      TAGS: None,
      ON_ORBIT: None,
      SEN_REFERENCE_FRAME: None,
      DESCRIPTOR: None,
      TYPE: None,
    }
  }
}

pub struct RDOBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RDOBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_ID, ID);
  }
  #[inline]
  pub fn add_OB_TIME(&mut self, OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_OB_TIME, OB_TIME);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(RDO::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_TASK_ID(&mut self, TASK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_TASK_ID, TASK_ID);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_TRACK_ID(&mut self, TRACK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_TRACK_ID, TRACK_ID);
  }
  #[inline]
  pub fn add_OB_POSITION(&mut self, OB_POSITION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_OB_POSITION, OB_POSITION);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_UCT(&mut self, UCT: bool) {
    self.fbb_.push_slot::<bool>(RDO::VT_UCT, UCT, false);
  }
  #[inline]
  pub fn add_AZIMUTH(&mut self, AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_AZIMUTH, AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_UNC(&mut self, AZIMUTH_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_AZIMUTH_UNC, AZIMUTH_UNC, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_BIAS(&mut self, AZIMUTH_BIAS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_AZIMUTH_BIAS, AZIMUTH_BIAS, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_RATE(&mut self, AZIMUTH_RATE: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_AZIMUTH_RATE, AZIMUTH_RATE, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION(&mut self, ELEVATION: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ELEVATION, ELEVATION, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_UNC(&mut self, ELEVATION_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ELEVATION_UNC, ELEVATION_UNC, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_BIAS(&mut self, ELEVATION_BIAS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ELEVATION_BIAS, ELEVATION_BIAS, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_RATE(&mut self, ELEVATION_RATE: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ELEVATION_RATE, ELEVATION_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE(&mut self, RANGE: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE, RANGE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_ACCEL(&mut self, RANGE_ACCEL: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_ACCEL, RANGE_ACCEL, 0.0);
  }
  #[inline]
  pub fn add_RANGE_ACCEL_UNC(&mut self, RANGE_ACCEL_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_ACCEL_UNC, RANGE_ACCEL_UNC, 0.0);
  }
  #[inline]
  pub fn add_RANGE_UNC(&mut self, RANGE_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_UNC, RANGE_UNC, 0.0);
  }
  #[inline]
  pub fn add_RANGE_BIAS(&mut self, RANGE_BIAS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_BIAS, RANGE_BIAS, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE(&mut self, RANGE_RATE: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_RATE, RANGE_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE_UNC(&mut self, RANGE_RATE_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RANGE_RATE_UNC, RANGE_RATE_UNC, 0.0);
  }
  #[inline]
  pub fn add_DOPPLER(&mut self, DOPPLER: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_DOPPLER, DOPPLER, 0.0);
  }
  #[inline]
  pub fn add_DOPPLER_UNC(&mut self, DOPPLER_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_DOPPLER_UNC, DOPPLER_UNC, 0.0);
  }
  #[inline]
  pub fn add_RA(&mut self, RA: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RA, RA, 0.0);
  }
  #[inline]
  pub fn add_DECLINATION(&mut self, DECLINATION: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_DECLINATION, DECLINATION, 0.0);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_XVEL(&mut self, XVEL: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_XVEL, XVEL, 0.0);
  }
  #[inline]
  pub fn add_YVEL(&mut self, YVEL: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_YVEL, YVEL, 0.0);
  }
  #[inline]
  pub fn add_ZVEL(&mut self, ZVEL: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ZVEL, ZVEL, 0.0);
  }
  #[inline]
  pub fn add_SENX(&mut self, SENX: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_SENX, SENX, 0.0);
  }
  #[inline]
  pub fn add_SENY(&mut self, SENY: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_SENY, SENY, 0.0);
  }
  #[inline]
  pub fn add_SENZ(&mut self, SENZ: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_SENZ, SENZ, 0.0);
  }
  #[inline]
  pub fn add_RCS(&mut self, RCS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RCS, RCS, 0.0);
  }
  #[inline]
  pub fn add_RCS_UNC(&mut self, RCS_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_RCS_UNC, RCS_UNC, 0.0);
  }
  #[inline]
  pub fn add_ORTHOGONAL_RCS(&mut self, ORTHOGONAL_RCS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ORTHOGONAL_RCS, ORTHOGONAL_RCS, 0.0);
  }
  #[inline]
  pub fn add_ORTHOGONAL_RCS_UNC(&mut self, ORTHOGONAL_RCS_UNC: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_ORTHOGONAL_RCS_UNC, ORTHOGONAL_RCS_UNC, 0.0);
  }
  #[inline]
  pub fn add_SNR(&mut self, SNR: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_SNR, SNR, 0.0);
  }
  #[inline]
  pub fn add_BEAM(&mut self, BEAM: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_BEAM, BEAM, 0.0);
  }
  #[inline]
  pub fn add_TIMING_BIAS(&mut self, TIMING_BIAS: f64) {
    self.fbb_.push_slot::<f64>(RDO::VT_TIMING_BIAS, TIMING_BIAS, 0.0);
  }
  #[inline]
  pub fn add_RAW_FILE_URI(&mut self, RAW_FILE_URI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_RAW_FILE_URI, RAW_FILE_URI);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn add_SEN_REFERENCE_FRAME(&mut self, SEN_REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_SEN_REFERENCE_FRAME, SEN_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RDO::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RDOBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RDOBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RDO<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RDO<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RDO");
      ds.field("ID", &self.ID());
      ds.field("OB_TIME", &self.OB_TIME());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("TASK_ID", &self.TASK_ID());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("TRACK_ID", &self.TRACK_ID());
      ds.field("OB_POSITION", &self.OB_POSITION());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("UCT", &self.UCT());
      ds.field("AZIMUTH", &self.AZIMUTH());
      ds.field("AZIMUTH_UNC", &self.AZIMUTH_UNC());
      ds.field("AZIMUTH_BIAS", &self.AZIMUTH_BIAS());
      ds.field("AZIMUTH_RATE", &self.AZIMUTH_RATE());
      ds.field("ELEVATION", &self.ELEVATION());
      ds.field("ELEVATION_UNC", &self.ELEVATION_UNC());
      ds.field("ELEVATION_BIAS", &self.ELEVATION_BIAS());
      ds.field("ELEVATION_RATE", &self.ELEVATION_RATE());
      ds.field("RANGE", &self.RANGE());
      ds.field("RANGE_ACCEL", &self.RANGE_ACCEL());
      ds.field("RANGE_ACCEL_UNC", &self.RANGE_ACCEL_UNC());
      ds.field("RANGE_UNC", &self.RANGE_UNC());
      ds.field("RANGE_BIAS", &self.RANGE_BIAS());
      ds.field("RANGE_RATE", &self.RANGE_RATE());
      ds.field("RANGE_RATE_UNC", &self.RANGE_RATE_UNC());
      ds.field("DOPPLER", &self.DOPPLER());
      ds.field("DOPPLER_UNC", &self.DOPPLER_UNC());
      ds.field("RA", &self.RA());
      ds.field("DECLINATION", &self.DECLINATION());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("XVEL", &self.XVEL());
      ds.field("YVEL", &self.YVEL());
      ds.field("ZVEL", &self.ZVEL());
      ds.field("SENX", &self.SENX());
      ds.field("SENY", &self.SENY());
      ds.field("SENZ", &self.SENZ());
      ds.field("RCS", &self.RCS());
      ds.field("RCS_UNC", &self.RCS_UNC());
      ds.field("ORTHOGONAL_RCS", &self.ORTHOGONAL_RCS());
      ds.field("ORTHOGONAL_RCS_UNC", &self.ORTHOGONAL_RCS_UNC());
      ds.field("SNR", &self.SNR());
      ds.field("BEAM", &self.BEAM());
      ds.field("TIMING_BIAS", &self.TIMING_BIAS());
      ds.field("RAW_FILE_URI", &self.RAW_FILE_URI());
      ds.field("TAGS", &self.TAGS());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.field("SEN_REFERENCE_FRAME", &self.SEN_REFERENCE_FRAME());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("TYPE", &self.TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RDOT {
  pub ID: Option<String>,
  pub OB_TIME: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub SAT_NO: i32,
  pub TASK_ID: Option<String>,
  pub TRANSACTION_ID: Option<String>,
  pub TRACK_ID: Option<String>,
  pub OB_POSITION: Option<String>,
  pub ORIG_OBJECT_ID: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub UCT: bool,
  pub AZIMUTH: f64,
  pub AZIMUTH_UNC: f64,
  pub AZIMUTH_BIAS: f64,
  pub AZIMUTH_RATE: f64,
  pub ELEVATION: f64,
  pub ELEVATION_UNC: f64,
  pub ELEVATION_BIAS: f64,
  pub ELEVATION_RATE: f64,
  pub RANGE: f64,
  pub RANGE_ACCEL: f64,
  pub RANGE_ACCEL_UNC: f64,
  pub RANGE_UNC: f64,
  pub RANGE_BIAS: f64,
  pub RANGE_RATE: f64,
  pub RANGE_RATE_UNC: f64,
  pub DOPPLER: f64,
  pub DOPPLER_UNC: f64,
  pub RA: f64,
  pub DECLINATION: f64,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub XVEL: f64,
  pub YVEL: f64,
  pub ZVEL: f64,
  pub SENX: f64,
  pub SENY: f64,
  pub SENZ: f64,
  pub RCS: f64,
  pub RCS_UNC: f64,
  pub ORTHOGONAL_RCS: f64,
  pub ORTHOGONAL_RCS_UNC: f64,
  pub SNR: f64,
  pub BEAM: f64,
  pub TIMING_BIAS: f64,
  pub RAW_FILE_URI: Option<String>,
  pub TAGS: Option<Vec<String>>,
  pub ON_ORBIT: Option<String>,
  pub SEN_REFERENCE_FRAME: Option<String>,
  pub DESCRIPTOR: Option<String>,
  pub TYPE: Option<String>,
}
impl Default for RDOT {
  fn default() -> Self {
    Self {
      ID: None,
      OB_TIME: None,
      ID_SENSOR: None,
      SAT_NO: 0,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      OB_POSITION: None,
      ORIG_OBJECT_ID: None,
      ORIG_SENSOR_ID: None,
      UCT: false,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_BIAS: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_BIAS: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_ACCEL: 0.0,
      RANGE_ACCEL_UNC: 0.0,
      RANGE_UNC: 0.0,
      RANGE_BIAS: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      DOPPLER: 0.0,
      DOPPLER_UNC: 0.0,
      RA: 0.0,
      DECLINATION: 0.0,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      XVEL: 0.0,
      YVEL: 0.0,
      ZVEL: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      RCS: 0.0,
      RCS_UNC: 0.0,
      ORTHOGONAL_RCS: 0.0,
      ORTHOGONAL_RCS_UNC: 0.0,
      SNR: 0.0,
      BEAM: 0.0,
      TIMING_BIAS: 0.0,
      RAW_FILE_URI: None,
      TAGS: None,
      ON_ORBIT: None,
      SEN_REFERENCE_FRAME: None,
      DESCRIPTOR: None,
      TYPE: None,
    }
  }
}
impl RDOT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RDO<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_TIME = self.OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let TASK_ID = self.TASK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACK_ID = self.TRACK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_POSITION = self.OB_POSITION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UCT = self.UCT;
    let AZIMUTH = self.AZIMUTH;
    let AZIMUTH_UNC = self.AZIMUTH_UNC;
    let AZIMUTH_BIAS = self.AZIMUTH_BIAS;
    let AZIMUTH_RATE = self.AZIMUTH_RATE;
    let ELEVATION = self.ELEVATION;
    let ELEVATION_UNC = self.ELEVATION_UNC;
    let ELEVATION_BIAS = self.ELEVATION_BIAS;
    let ELEVATION_RATE = self.ELEVATION_RATE;
    let RANGE = self.RANGE;
    let RANGE_ACCEL = self.RANGE_ACCEL;
    let RANGE_ACCEL_UNC = self.RANGE_ACCEL_UNC;
    let RANGE_UNC = self.RANGE_UNC;
    let RANGE_BIAS = self.RANGE_BIAS;
    let RANGE_RATE = self.RANGE_RATE;
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC;
    let DOPPLER = self.DOPPLER;
    let DOPPLER_UNC = self.DOPPLER_UNC;
    let RA = self.RA;
    let DECLINATION = self.DECLINATION;
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let XVEL = self.XVEL;
    let YVEL = self.YVEL;
    let ZVEL = self.ZVEL;
    let SENX = self.SENX;
    let SENY = self.SENY;
    let SENZ = self.SENZ;
    let RCS = self.RCS;
    let RCS_UNC = self.RCS_UNC;
    let ORTHOGONAL_RCS = self.ORTHOGONAL_RCS;
    let ORTHOGONAL_RCS_UNC = self.ORTHOGONAL_RCS_UNC;
    let SNR = self.SNR;
    let BEAM = self.BEAM;
    let TIMING_BIAS = self.TIMING_BIAS;
    let RAW_FILE_URI = self.RAW_FILE_URI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    RDO::create(_fbb, &RDOArgs{
      ID,
      OB_TIME,
      ID_SENSOR,
      SAT_NO,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      OB_POSITION,
      ORIG_OBJECT_ID,
      ORIG_SENSOR_ID,
      UCT,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_BIAS,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_BIAS,
      ELEVATION_RATE,
      RANGE,
      RANGE_ACCEL,
      RANGE_ACCEL_UNC,
      RANGE_UNC,
      RANGE_BIAS,
      RANGE_RATE,
      RANGE_RATE_UNC,
      DOPPLER,
      DOPPLER_UNC,
      RA,
      DECLINATION,
      X,
      Y,
      Z,
      XVEL,
      YVEL,
      ZVEL,
      SENX,
      SENY,
      SENZ,
      RCS,
      RCS_UNC,
      ORTHOGONAL_RCS,
      ORTHOGONAL_RCS_UNC,
      SNR,
      BEAM,
      TIMING_BIAS,
      RAW_FILE_URI,
      TAGS,
      ON_ORBIT,
      SEN_REFERENCE_FRAME,
      DESCRIPTOR,
      TYPE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RDO`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RDO_unchecked`.
pub fn root_as_RDO(buf: &[u8]) -> Result<RDO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RDO>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RDO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_RDO_unchecked`.
pub fn size_prefixed_root_as_RDO(buf: &[u8]) -> Result<RDO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RDO>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RDO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RDO_unchecked`.
pub fn root_as_RDO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RDO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RDO<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RDO` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RDO_unchecked`.
pub fn size_prefixed_root_as_RDO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RDO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RDO<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RDO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RDO`.
pub unsafe fn root_as_RDO_unchecked(buf: &[u8]) -> RDO {
  flatbuffers::root_unchecked::<RDO>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RDO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RDO`.
pub unsafe fn size_prefixed_root_as_RDO_unchecked(buf: &[u8]) -> RDO {
  flatbuffers::size_prefixed_root_unchecked::<RDO>(buf)
}
pub const RDO_IDENTIFIER: &str = "$RDO";

#[inline]
pub fn RDO_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RDO_IDENTIFIER, false)
}

#[inline]
pub fn RDO_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RDO_IDENTIFIER, true)
}

#[inline]
pub fn finish_RDO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RDO<'a>>) {
  fbb.finish(root, Some(RDO_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_RDO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RDO<'a>>) {
  fbb.finish_size_prefixed(root, Some(RDO_IDENTIFIER));
}
