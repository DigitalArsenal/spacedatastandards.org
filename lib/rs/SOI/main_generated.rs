// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum SOIOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Space Object Identification Observation Set
pub struct SOI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SOI<'a> {
  type Inner = SOI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SOI<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MSG_CREATE_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 8;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 10;
  pub const VT_SENSOR_AS_ID: flatbuffers::VOffsetT = 12;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 14;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 16;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 18;
  pub const VT_SENLON: flatbuffers::VOffsetT = 20;
  pub const VT_SENALT: flatbuffers::VOffsetT = 22;
  pub const VT_SENX: flatbuffers::VOffsetT = 24;
  pub const VT_SENY: flatbuffers::VOffsetT = 26;
  pub const VT_SENZ: flatbuffers::VOffsetT = 28;
  pub const VT_SENVELX: flatbuffers::VOffsetT = 30;
  pub const VT_SENVELY: flatbuffers::VOffsetT = 32;
  pub const VT_SENVELZ: flatbuffers::VOffsetT = 34;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 36;
  pub const VT_END_TIME: flatbuffers::VOffsetT = 38;
  pub const VT_NUM_OBS: flatbuffers::VOffsetT = 40;
  pub const VT_TYPE: flatbuffers::VOffsetT = 42;
  pub const VT_POLAR_ANGLE_START: flatbuffers::VOffsetT = 44;
  pub const VT_POLAR_ANGLE_END: flatbuffers::VOffsetT = 46;
  pub const VT_REFERENCE_FRAME: flatbuffers::VOffsetT = 48;
  pub const VT_SEN_REFERENCE_FRAME: flatbuffers::VOffsetT = 50;
  pub const VT_LOS_DECLINATION_START: flatbuffers::VOffsetT = 52;
  pub const VT_LOS_DECLINATION_END: flatbuffers::VOffsetT = 54;
  pub const VT_POINTING_ANGLE_AZ_START: flatbuffers::VOffsetT = 56;
  pub const VT_POINTING_ANGLE_AZ_END: flatbuffers::VOffsetT = 58;
  pub const VT_POINTING_ANGLE_EL_START: flatbuffers::VOffsetT = 60;
  pub const VT_POINTING_ANGLE_EL_END: flatbuffers::VOffsetT = 62;
  pub const VT_PIXEL_ARRAY_WIDTH: flatbuffers::VOffsetT = 64;
  pub const VT_PIXEL_ARRAY_HEIGHT: flatbuffers::VOffsetT = 66;
  pub const VT_NUM_SPECTRAL_FILTERS: flatbuffers::VOffsetT = 68;
  pub const VT_SPECTRAL_FILTERS: flatbuffers::VOffsetT = 70;
  pub const VT_COLLECTION_MODE: flatbuffers::VOffsetT = 72;
  pub const VT_GAIN: flatbuffers::VOffsetT = 74;
  pub const VT_BINNING_HORIZ: flatbuffers::VOffsetT = 76;
  pub const VT_BINNING_VERT: flatbuffers::VOffsetT = 78;
  pub const VT_SOLAR_MAG: flatbuffers::VOffsetT = 80;
  pub const VT_PIXEL_MIN: flatbuffers::VOffsetT = 82;
  pub const VT_PIXEL_MAX: flatbuffers::VOffsetT = 84;
  pub const VT_SOFTWARE_VERSION: flatbuffers::VOffsetT = 86;
  pub const VT_SATELLITE_NAME: flatbuffers::VOffsetT = 88;
  pub const VT_STAR_CAT_NAME: flatbuffers::VOffsetT = 90;
  pub const VT_CORR_QUALITY: flatbuffers::VOffsetT = 92;
  pub const VT_UCT: flatbuffers::VOffsetT = 94;
  pub const VT_VALID_CALIBRATIONS: flatbuffers::VOffsetT = 96;
  pub const VT_CALIBRATION_TYPE: flatbuffers::VOffsetT = 98;
  pub const VT_PERCENT_SAT_THRESHOLD: flatbuffers::VOffsetT = 100;
  pub const VT_CHANGE_DETECTED: flatbuffers::VOffsetT = 102;
  pub const VT_PERIODICITY_CHANGE_DETECTED: flatbuffers::VOffsetT = 104;
  pub const VT_BRIGHTNESS_VARIANCE_CHANGE_DETECTED: flatbuffers::VOffsetT = 106;
  pub const VT_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: flatbuffers::VOffsetT = 108;
  pub const VT_CHANGE_CONF: flatbuffers::VOffsetT = 110;
  pub const VT_COLLECTION_DENSITY_CONF: flatbuffers::VOffsetT = 112;
  pub const VT_PERIODICITY_SAMPLING_CONF: flatbuffers::VOffsetT = 114;
  pub const VT_PERIODICITY_DETECTION_CONF: flatbuffers::VOffsetT = 116;
  pub const VT_COLLECTION_ID: flatbuffers::VOffsetT = 118;
  pub const VT_CALIBRATIONS: flatbuffers::VOffsetT = 120;
  pub const VT_TAGS: flatbuffers::VOffsetT = 122;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 124;
  pub const VT_OPTICAL_SOIOBSERVATION_LIST: flatbuffers::VOffsetT = 126;
  pub const VT_RADAR_SOIOBSERVATION_LIST: flatbuffers::VOffsetT = 128;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SOI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SOIArgs<'args>
  ) -> flatbuffers::WIPOffset<SOI<'bldr>> {
    let mut builder = SOIBuilder::new(_fbb);
    builder.add_PERCENT_SAT_THRESHOLD(args.PERCENT_SAT_THRESHOLD);
    builder.add_CORR_QUALITY(args.CORR_QUALITY);
    builder.add_SOLAR_MAG(args.SOLAR_MAG);
    builder.add_GAIN(args.GAIN);
    builder.add_POINTING_ANGLE_EL_END(args.POINTING_ANGLE_EL_END);
    builder.add_POINTING_ANGLE_EL_START(args.POINTING_ANGLE_EL_START);
    builder.add_POINTING_ANGLE_AZ_END(args.POINTING_ANGLE_AZ_END);
    builder.add_POINTING_ANGLE_AZ_START(args.POINTING_ANGLE_AZ_START);
    builder.add_LOS_DECLINATION_END(args.LOS_DECLINATION_END);
    builder.add_LOS_DECLINATION_START(args.LOS_DECLINATION_START);
    builder.add_POLAR_ANGLE_END(args.POLAR_ANGLE_END);
    builder.add_POLAR_ANGLE_START(args.POLAR_ANGLE_START);
    builder.add_SENVELZ(args.SENVELZ);
    builder.add_SENVELY(args.SENVELY);
    builder.add_SENVELX(args.SENVELX);
    builder.add_SENZ(args.SENZ);
    builder.add_SENY(args.SENY);
    builder.add_SENX(args.SENX);
    builder.add_SENALT(args.SENALT);
    builder.add_SENLON(args.SENLON);
    builder.add_SENLAT(args.SENLAT);
    if let Some(x) = args.RADAR_SOIOBSERVATION_LIST { builder.add_RADAR_SOIOBSERVATION_LIST(x); }
    if let Some(x) = args.OPTICAL_SOIOBSERVATION_LIST { builder.add_OPTICAL_SOIOBSERVATION_LIST(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.CALIBRATIONS { builder.add_CALIBRATIONS(x); }
    if let Some(x) = args.COLLECTION_ID { builder.add_COLLECTION_ID(x); }
    if let Some(x) = args.PERIODICITY_DETECTION_CONF { builder.add_PERIODICITY_DETECTION_CONF(x); }
    if let Some(x) = args.PERIODICITY_SAMPLING_CONF { builder.add_PERIODICITY_SAMPLING_CONF(x); }
    if let Some(x) = args.COLLECTION_DENSITY_CONF { builder.add_COLLECTION_DENSITY_CONF(x); }
    if let Some(x) = args.CHANGE_CONF { builder.add_CHANGE_CONF(x); }
    if let Some(x) = args.CALIBRATION_TYPE { builder.add_CALIBRATION_TYPE(x); }
    if let Some(x) = args.VALID_CALIBRATIONS { builder.add_VALID_CALIBRATIONS(x); }
    if let Some(x) = args.STAR_CAT_NAME { builder.add_STAR_CAT_NAME(x); }
    if let Some(x) = args.SATELLITE_NAME { builder.add_SATELLITE_NAME(x); }
    if let Some(x) = args.SOFTWARE_VERSION { builder.add_SOFTWARE_VERSION(x); }
    builder.add_PIXEL_MAX(args.PIXEL_MAX);
    builder.add_PIXEL_MIN(args.PIXEL_MIN);
    builder.add_BINNING_VERT(args.BINNING_VERT);
    builder.add_BINNING_HORIZ(args.BINNING_HORIZ);
    if let Some(x) = args.COLLECTION_MODE { builder.add_COLLECTION_MODE(x); }
    if let Some(x) = args.SPECTRAL_FILTERS { builder.add_SPECTRAL_FILTERS(x); }
    builder.add_NUM_SPECTRAL_FILTERS(args.NUM_SPECTRAL_FILTERS);
    builder.add_PIXEL_ARRAY_HEIGHT(args.PIXEL_ARRAY_HEIGHT);
    builder.add_PIXEL_ARRAY_WIDTH(args.PIXEL_ARRAY_WIDTH);
    if let Some(x) = args.SEN_REFERENCE_FRAME { builder.add_SEN_REFERENCE_FRAME(x); }
    if let Some(x) = args.REFERENCE_FRAME { builder.add_REFERENCE_FRAME(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    builder.add_NUM_OBS(args.NUM_OBS);
    if let Some(x) = args.END_TIME { builder.add_END_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.SENSOR_AS_ID { builder.add_SENSOR_AS_ID(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.MSG_CREATE_DATE { builder.add_MSG_CREATE_DATE(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED(args.SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED);
    builder.add_BRIGHTNESS_VARIANCE_CHANGE_DETECTED(args.BRIGHTNESS_VARIANCE_CHANGE_DETECTED);
    builder.add_PERIODICITY_CHANGE_DETECTED(args.PERIODICITY_CHANGE_DETECTED);
    builder.add_CHANGE_DETECTED(args.CHANGE_DETECTED);
    builder.add_UCT(args.UCT);
    builder.finish()
  }

  pub fn unpack(&self) -> SOIT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let MSG_CREATE_DATE = self.MSG_CREATE_DATE().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let SENSOR_AS_ID = self.SENSOR_AS_ID().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let SENLAT = self.SENLAT();
    let SENLON = self.SENLON();
    let SENALT = self.SENALT();
    let SENX = self.SENX();
    let SENY = self.SENY();
    let SENZ = self.SENZ();
    let SENVELX = self.SENVELX();
    let SENVELY = self.SENVELY();
    let SENVELZ = self.SENVELZ();
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let END_TIME = self.END_TIME().map(|x| {
      x.to_string()
    });
    let NUM_OBS = self.NUM_OBS();
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let POLAR_ANGLE_START = self.POLAR_ANGLE_START();
    let POLAR_ANGLE_END = self.POLAR_ANGLE_END();
    let REFERENCE_FRAME = self.REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let LOS_DECLINATION_START = self.LOS_DECLINATION_START();
    let LOS_DECLINATION_END = self.LOS_DECLINATION_END();
    let POINTING_ANGLE_AZ_START = self.POINTING_ANGLE_AZ_START();
    let POINTING_ANGLE_AZ_END = self.POINTING_ANGLE_AZ_END();
    let POINTING_ANGLE_EL_START = self.POINTING_ANGLE_EL_START();
    let POINTING_ANGLE_EL_END = self.POINTING_ANGLE_EL_END();
    let PIXEL_ARRAY_WIDTH = self.PIXEL_ARRAY_WIDTH();
    let PIXEL_ARRAY_HEIGHT = self.PIXEL_ARRAY_HEIGHT();
    let NUM_SPECTRAL_FILTERS = self.NUM_SPECTRAL_FILTERS();
    let SPECTRAL_FILTERS = self.SPECTRAL_FILTERS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let COLLECTION_MODE = self.COLLECTION_MODE().map(|x| {
      x.to_string()
    });
    let GAIN = self.GAIN();
    let BINNING_HORIZ = self.BINNING_HORIZ();
    let BINNING_VERT = self.BINNING_VERT();
    let SOLAR_MAG = self.SOLAR_MAG();
    let PIXEL_MIN = self.PIXEL_MIN();
    let PIXEL_MAX = self.PIXEL_MAX();
    let SOFTWARE_VERSION = self.SOFTWARE_VERSION().map(|x| {
      x.to_string()
    });
    let SATELLITE_NAME = self.SATELLITE_NAME().map(|x| {
      x.to_string()
    });
    let STAR_CAT_NAME = self.STAR_CAT_NAME().map(|x| {
      x.to_string()
    });
    let CORR_QUALITY = self.CORR_QUALITY();
    let UCT = self.UCT();
    let VALID_CALIBRATIONS = self.VALID_CALIBRATIONS().map(|x| {
      x.to_string()
    });
    let CALIBRATION_TYPE = self.CALIBRATION_TYPE().map(|x| {
      x.to_string()
    });
    let PERCENT_SAT_THRESHOLD = self.PERCENT_SAT_THRESHOLD();
    let CHANGE_DETECTED = self.CHANGE_DETECTED();
    let PERIODICITY_CHANGE_DETECTED = self.PERIODICITY_CHANGE_DETECTED();
    let BRIGHTNESS_VARIANCE_CHANGE_DETECTED = self.BRIGHTNESS_VARIANCE_CHANGE_DETECTED();
    let SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED = self.SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED();
    let CHANGE_CONF = self.CHANGE_CONF().map(|x| {
      x.to_string()
    });
    let COLLECTION_DENSITY_CONF = self.COLLECTION_DENSITY_CONF().map(|x| {
      x.to_string()
    });
    let PERIODICITY_SAMPLING_CONF = self.PERIODICITY_SAMPLING_CONF().map(|x| {
      x.to_string()
    });
    let PERIODICITY_DETECTION_CONF = self.PERIODICITY_DETECTION_CONF().map(|x| {
      x.to_string()
    });
    let COLLECTION_ID = self.COLLECTION_ID().map(|x| {
      x.to_string()
    });
    let CALIBRATIONS = self.CALIBRATIONS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let OPTICAL_SOIOBSERVATION_LIST = self.OPTICAL_SOIOBSERVATION_LIST().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let RADAR_SOIOBSERVATION_LIST = self.RADAR_SOIOBSERVATION_LIST().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    SOIT {
      ID,
      MSG_CREATE_DATE,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      SENSOR_AS_ID,
      SAT_NO,
      ORIG_OBJECT_ID,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      SENVELX,
      SENVELY,
      SENVELZ,
      START_TIME,
      END_TIME,
      NUM_OBS,
      TYPE,
      POLAR_ANGLE_START,
      POLAR_ANGLE_END,
      REFERENCE_FRAME,
      SEN_REFERENCE_FRAME,
      LOS_DECLINATION_START,
      LOS_DECLINATION_END,
      POINTING_ANGLE_AZ_START,
      POINTING_ANGLE_AZ_END,
      POINTING_ANGLE_EL_START,
      POINTING_ANGLE_EL_END,
      PIXEL_ARRAY_WIDTH,
      PIXEL_ARRAY_HEIGHT,
      NUM_SPECTRAL_FILTERS,
      SPECTRAL_FILTERS,
      COLLECTION_MODE,
      GAIN,
      BINNING_HORIZ,
      BINNING_VERT,
      SOLAR_MAG,
      PIXEL_MIN,
      PIXEL_MAX,
      SOFTWARE_VERSION,
      SATELLITE_NAME,
      STAR_CAT_NAME,
      CORR_QUALITY,
      UCT,
      VALID_CALIBRATIONS,
      CALIBRATION_TYPE,
      PERCENT_SAT_THRESHOLD,
      CHANGE_DETECTED,
      PERIODICITY_CHANGE_DETECTED,
      BRIGHTNESS_VARIANCE_CHANGE_DETECTED,
      SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED,
      CHANGE_CONF,
      COLLECTION_DENSITY_CONF,
      PERIODICITY_SAMPLING_CONF,
      PERIODICITY_DETECTION_CONF,
      COLLECTION_ID,
      CALIBRATIONS,
      TAGS,
      TRANSACTION_ID,
      OPTICAL_SOIOBSERVATION_LIST,
      RADAR_SOIOBSERVATION_LIST,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_ID, None)}
  }
  #[inline]
  pub fn MSG_CREATE_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_MSG_CREATE_DATE, None)}
  }
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_ID_SENSOR, None)}
  }
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_ORIG_SENSOR_ID, None)}
  }
  #[inline]
  pub fn SENSOR_AS_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_SENSOR_AS_ID, None)}
  }
  #[inline]
  pub fn SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_ORIG_OBJECT_ID, None)}
  }
  #[inline]
  pub fn SENLAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENLAT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENLON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENLON, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENALT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENVELX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENVELX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENVELY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENVELY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SENVELZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SENVELZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_START_TIME, None)}
  }
  #[inline]
  pub fn END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_END_TIME, None)}
  }
  #[inline]
  pub fn NUM_OBS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_NUM_OBS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_TYPE, None)}
  }
  #[inline]
  pub fn POLAR_ANGLE_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POLAR_ANGLE_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POLAR_ANGLE_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POLAR_ANGLE_END, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_REFERENCE_FRAME, None)}
  }
  #[inline]
  pub fn SEN_REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_SEN_REFERENCE_FRAME, None)}
  }
  #[inline]
  pub fn LOS_DECLINATION_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_LOS_DECLINATION_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LOS_DECLINATION_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_LOS_DECLINATION_END, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POINTING_ANGLE_AZ_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POINTING_ANGLE_AZ_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POINTING_ANGLE_AZ_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POINTING_ANGLE_AZ_END, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POINTING_ANGLE_EL_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POINTING_ANGLE_EL_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POINTING_ANGLE_EL_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_POINTING_ANGLE_EL_END, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PIXEL_ARRAY_WIDTH(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_PIXEL_ARRAY_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PIXEL_ARRAY_HEIGHT(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_PIXEL_ARRAY_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NUM_SPECTRAL_FILTERS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_NUM_SPECTRAL_FILTERS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SPECTRAL_FILTERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOI::VT_SPECTRAL_FILTERS, None)}
  }
  #[inline]
  pub fn COLLECTION_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_COLLECTION_MODE, None)}
  }
  #[inline]
  pub fn GAIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_GAIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BINNING_HORIZ(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_BINNING_HORIZ, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BINNING_VERT(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_BINNING_VERT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_MAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_SOLAR_MAG, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PIXEL_MIN(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_PIXEL_MIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PIXEL_MAX(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SOI::VT_PIXEL_MAX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SOFTWARE_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_SOFTWARE_VERSION, None)}
  }
  #[inline]
  pub fn SATELLITE_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_SATELLITE_NAME, None)}
  }
  #[inline]
  pub fn STAR_CAT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_STAR_CAT_NAME, None)}
  }
  #[inline]
  pub fn CORR_QUALITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_CORR_QUALITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn UCT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOI::VT_UCT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn VALID_CALIBRATIONS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_VALID_CALIBRATIONS, None)}
  }
  #[inline]
  pub fn CALIBRATION_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_CALIBRATION_TYPE, None)}
  }
  #[inline]
  pub fn PERCENT_SAT_THRESHOLD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SOI::VT_PERCENT_SAT_THRESHOLD, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CHANGE_DETECTED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOI::VT_CHANGE_DETECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn PERIODICITY_CHANGE_DETECTED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOI::VT_PERIODICITY_CHANGE_DETECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BRIGHTNESS_VARIANCE_CHANGE_DETECTED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOI::VT_BRIGHTNESS_VARIANCE_CHANGE_DETECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SOI::VT_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CHANGE_CONF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_CHANGE_CONF, None)}
  }
  #[inline]
  pub fn COLLECTION_DENSITY_CONF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_COLLECTION_DENSITY_CONF, None)}
  }
  #[inline]
  pub fn PERIODICITY_SAMPLING_CONF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_PERIODICITY_SAMPLING_CONF, None)}
  }
  #[inline]
  pub fn PERIODICITY_DETECTION_CONF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_PERIODICITY_DETECTION_CONF, None)}
  }
  #[inline]
  pub fn COLLECTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_COLLECTION_ID, None)}
  }
  #[inline]
  pub fn CALIBRATIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOI::VT_CALIBRATIONS, None)}
  }
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOI::VT_TAGS, None)}
  }
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SOI::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn OPTICAL_SOIOBSERVATION_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOI::VT_OPTICAL_SOIOBSERVATION_LIST, None)}
  }
  #[inline]
  pub fn RADAR_SOIOBSERVATION_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SOI::VT_RADAR_SOIOBSERVATION_LIST, None)}
  }
}

impl flatbuffers::Verifiable for SOI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MSG_CREATE_DATE", Self::VT_MSG_CREATE_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SENSOR_AS_ID", Self::VT_SENSOR_AS_ID, false)?
     .visit_field::<i32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<f64>("SENLAT", Self::VT_SENLAT, false)?
     .visit_field::<f64>("SENLON", Self::VT_SENLON, false)?
     .visit_field::<f64>("SENALT", Self::VT_SENALT, false)?
     .visit_field::<f64>("SENX", Self::VT_SENX, false)?
     .visit_field::<f64>("SENY", Self::VT_SENY, false)?
     .visit_field::<f64>("SENZ", Self::VT_SENZ, false)?
     .visit_field::<f64>("SENVELX", Self::VT_SENVELX, false)?
     .visit_field::<f64>("SENVELY", Self::VT_SENVELY, false)?
     .visit_field::<f64>("SENVELZ", Self::VT_SENVELZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END_TIME", Self::VT_END_TIME, false)?
     .visit_field::<i32>("NUM_OBS", Self::VT_NUM_OBS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<f64>("POLAR_ANGLE_START", Self::VT_POLAR_ANGLE_START, false)?
     .visit_field::<f64>("POLAR_ANGLE_END", Self::VT_POLAR_ANGLE_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REFERENCE_FRAME", Self::VT_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEN_REFERENCE_FRAME", Self::VT_SEN_REFERENCE_FRAME, false)?
     .visit_field::<f64>("LOS_DECLINATION_START", Self::VT_LOS_DECLINATION_START, false)?
     .visit_field::<f64>("LOS_DECLINATION_END", Self::VT_LOS_DECLINATION_END, false)?
     .visit_field::<f64>("POINTING_ANGLE_AZ_START", Self::VT_POINTING_ANGLE_AZ_START, false)?
     .visit_field::<f64>("POINTING_ANGLE_AZ_END", Self::VT_POINTING_ANGLE_AZ_END, false)?
     .visit_field::<f64>("POINTING_ANGLE_EL_START", Self::VT_POINTING_ANGLE_EL_START, false)?
     .visit_field::<f64>("POINTING_ANGLE_EL_END", Self::VT_POINTING_ANGLE_EL_END, false)?
     .visit_field::<i32>("PIXEL_ARRAY_WIDTH", Self::VT_PIXEL_ARRAY_WIDTH, false)?
     .visit_field::<i32>("PIXEL_ARRAY_HEIGHT", Self::VT_PIXEL_ARRAY_HEIGHT, false)?
     .visit_field::<i32>("NUM_SPECTRAL_FILTERS", Self::VT_NUM_SPECTRAL_FILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SPECTRAL_FILTERS", Self::VT_SPECTRAL_FILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_MODE", Self::VT_COLLECTION_MODE, false)?
     .visit_field::<f64>("GAIN", Self::VT_GAIN, false)?
     .visit_field::<i32>("BINNING_HORIZ", Self::VT_BINNING_HORIZ, false)?
     .visit_field::<i32>("BINNING_VERT", Self::VT_BINNING_VERT, false)?
     .visit_field::<f64>("SOLAR_MAG", Self::VT_SOLAR_MAG, false)?
     .visit_field::<i32>("PIXEL_MIN", Self::VT_PIXEL_MIN, false)?
     .visit_field::<i32>("PIXEL_MAX", Self::VT_PIXEL_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOFTWARE_VERSION", Self::VT_SOFTWARE_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SATELLITE_NAME", Self::VT_SATELLITE_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STAR_CAT_NAME", Self::VT_STAR_CAT_NAME, false)?
     .visit_field::<f64>("CORR_QUALITY", Self::VT_CORR_QUALITY, false)?
     .visit_field::<bool>("UCT", Self::VT_UCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALID_CALIBRATIONS", Self::VT_VALID_CALIBRATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CALIBRATION_TYPE", Self::VT_CALIBRATION_TYPE, false)?
     .visit_field::<f64>("PERCENT_SAT_THRESHOLD", Self::VT_PERCENT_SAT_THRESHOLD, false)?
     .visit_field::<bool>("CHANGE_DETECTED", Self::VT_CHANGE_DETECTED, false)?
     .visit_field::<bool>("PERIODICITY_CHANGE_DETECTED", Self::VT_PERIODICITY_CHANGE_DETECTED, false)?
     .visit_field::<bool>("BRIGHTNESS_VARIANCE_CHANGE_DETECTED", Self::VT_BRIGHTNESS_VARIANCE_CHANGE_DETECTED, false)?
     .visit_field::<bool>("SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED", Self::VT_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CHANGE_CONF", Self::VT_CHANGE_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_DENSITY_CONF", Self::VT_COLLECTION_DENSITY_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PERIODICITY_SAMPLING_CONF", Self::VT_PERIODICITY_SAMPLING_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PERIODICITY_DETECTION_CONF", Self::VT_PERIODICITY_DETECTION_CONF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_ID", Self::VT_COLLECTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("CALIBRATIONS", Self::VT_CALIBRATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("OPTICAL_SOIOBSERVATION_LIST", Self::VT_OPTICAL_SOIOBSERVATION_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("RADAR_SOIOBSERVATION_LIST", Self::VT_RADAR_SOIOBSERVATION_LIST, false)?
     .finish();
    Ok(())
  }
}
pub struct SOIArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MSG_CREATE_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENSOR_AS_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: i32,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENLAT: f64,
    pub SENLON: f64,
    pub SENALT: f64,
    pub SENX: f64,
    pub SENY: f64,
    pub SENZ: f64,
    pub SENVELX: f64,
    pub SENVELY: f64,
    pub SENVELZ: f64,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NUM_OBS: i32,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POLAR_ANGLE_START: f64,
    pub POLAR_ANGLE_END: f64,
    pub REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SEN_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOS_DECLINATION_START: f64,
    pub LOS_DECLINATION_END: f64,
    pub POINTING_ANGLE_AZ_START: f64,
    pub POINTING_ANGLE_AZ_END: f64,
    pub POINTING_ANGLE_EL_START: f64,
    pub POINTING_ANGLE_EL_END: f64,
    pub PIXEL_ARRAY_WIDTH: i32,
    pub PIXEL_ARRAY_HEIGHT: i32,
    pub NUM_SPECTRAL_FILTERS: i32,
    pub SPECTRAL_FILTERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub COLLECTION_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GAIN: f64,
    pub BINNING_HORIZ: i32,
    pub BINNING_VERT: i32,
    pub SOLAR_MAG: f64,
    pub PIXEL_MIN: i32,
    pub PIXEL_MAX: i32,
    pub SOFTWARE_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SATELLITE_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STAR_CAT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CORR_QUALITY: f64,
    pub UCT: bool,
    pub VALID_CALIBRATIONS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CALIBRATION_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PERCENT_SAT_THRESHOLD: f64,
    pub CHANGE_DETECTED: bool,
    pub PERIODICITY_CHANGE_DETECTED: bool,
    pub BRIGHTNESS_VARIANCE_CHANGE_DETECTED: bool,
    pub SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: bool,
    pub CHANGE_CONF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_DENSITY_CONF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PERIODICITY_SAMPLING_CONF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PERIODICITY_DETECTION_CONF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CALIBRATIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPTICAL_SOIOBSERVATION_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub RADAR_SOIOBSERVATION_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SOIArgs<'a> {
  #[inline]
  fn default() -> Self {
    SOIArgs {
      ID: None,
      MSG_CREATE_DATE: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      SENSOR_AS_ID: None,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      SENVELX: 0.0,
      SENVELY: 0.0,
      SENVELZ: 0.0,
      START_TIME: None,
      END_TIME: None,
      NUM_OBS: 0,
      TYPE: None,
      POLAR_ANGLE_START: 0.0,
      POLAR_ANGLE_END: 0.0,
      REFERENCE_FRAME: None,
      SEN_REFERENCE_FRAME: None,
      LOS_DECLINATION_START: 0.0,
      LOS_DECLINATION_END: 0.0,
      POINTING_ANGLE_AZ_START: 0.0,
      POINTING_ANGLE_AZ_END: 0.0,
      POINTING_ANGLE_EL_START: 0.0,
      POINTING_ANGLE_EL_END: 0.0,
      PIXEL_ARRAY_WIDTH: 0,
      PIXEL_ARRAY_HEIGHT: 0,
      NUM_SPECTRAL_FILTERS: 0,
      SPECTRAL_FILTERS: None,
      COLLECTION_MODE: None,
      GAIN: 0.0,
      BINNING_HORIZ: 0,
      BINNING_VERT: 0,
      SOLAR_MAG: 0.0,
      PIXEL_MIN: 0,
      PIXEL_MAX: 0,
      SOFTWARE_VERSION: None,
      SATELLITE_NAME: None,
      STAR_CAT_NAME: None,
      CORR_QUALITY: 0.0,
      UCT: false,
      VALID_CALIBRATIONS: None,
      CALIBRATION_TYPE: None,
      PERCENT_SAT_THRESHOLD: 0.0,
      CHANGE_DETECTED: false,
      PERIODICITY_CHANGE_DETECTED: false,
      BRIGHTNESS_VARIANCE_CHANGE_DETECTED: false,
      SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: false,
      CHANGE_CONF: None,
      COLLECTION_DENSITY_CONF: None,
      PERIODICITY_SAMPLING_CONF: None,
      PERIODICITY_DETECTION_CONF: None,
      COLLECTION_ID: None,
      CALIBRATIONS: None,
      TAGS: None,
      TRANSACTION_ID: None,
      OPTICAL_SOIOBSERVATION_LIST: None,
      RADAR_SOIOBSERVATION_LIST: None,
    }
  }
}

pub struct SOIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SOIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_ID, ID);
  }
  #[inline]
  pub fn add_MSG_CREATE_DATE(&mut self, MSG_CREATE_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_MSG_CREATE_DATE, MSG_CREATE_DATE);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_SENSOR_AS_ID(&mut self, SENSOR_AS_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_SENSOR_AS_ID, SENSOR_AS_ID);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_SENLAT(&mut self, SENLAT: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENLAT, SENLAT, 0.0);
  }
  #[inline]
  pub fn add_SENLON(&mut self, SENLON: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENLON, SENLON, 0.0);
  }
  #[inline]
  pub fn add_SENALT(&mut self, SENALT: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENALT, SENALT, 0.0);
  }
  #[inline]
  pub fn add_SENX(&mut self, SENX: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENX, SENX, 0.0);
  }
  #[inline]
  pub fn add_SENY(&mut self, SENY: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENY, SENY, 0.0);
  }
  #[inline]
  pub fn add_SENZ(&mut self, SENZ: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENZ, SENZ, 0.0);
  }
  #[inline]
  pub fn add_SENVELX(&mut self, SENVELX: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENVELX, SENVELX, 0.0);
  }
  #[inline]
  pub fn add_SENVELY(&mut self, SENVELY: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENVELY, SENVELY, 0.0);
  }
  #[inline]
  pub fn add_SENVELZ(&mut self, SENVELZ: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SENVELZ, SENVELZ, 0.0);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_END_TIME(&mut self, END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_END_TIME, END_TIME);
  }
  #[inline]
  pub fn add_NUM_OBS(&mut self, NUM_OBS: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_NUM_OBS, NUM_OBS, 0);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_POLAR_ANGLE_START(&mut self, POLAR_ANGLE_START: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POLAR_ANGLE_START, POLAR_ANGLE_START, 0.0);
  }
  #[inline]
  pub fn add_POLAR_ANGLE_END(&mut self, POLAR_ANGLE_END: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POLAR_ANGLE_END, POLAR_ANGLE_END, 0.0);
  }
  #[inline]
  pub fn add_REFERENCE_FRAME(&mut self, REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_REFERENCE_FRAME, REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_SEN_REFERENCE_FRAME(&mut self, SEN_REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_SEN_REFERENCE_FRAME, SEN_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_LOS_DECLINATION_START(&mut self, LOS_DECLINATION_START: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_LOS_DECLINATION_START, LOS_DECLINATION_START, 0.0);
  }
  #[inline]
  pub fn add_LOS_DECLINATION_END(&mut self, LOS_DECLINATION_END: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_LOS_DECLINATION_END, LOS_DECLINATION_END, 0.0);
  }
  #[inline]
  pub fn add_POINTING_ANGLE_AZ_START(&mut self, POINTING_ANGLE_AZ_START: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POINTING_ANGLE_AZ_START, POINTING_ANGLE_AZ_START, 0.0);
  }
  #[inline]
  pub fn add_POINTING_ANGLE_AZ_END(&mut self, POINTING_ANGLE_AZ_END: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POINTING_ANGLE_AZ_END, POINTING_ANGLE_AZ_END, 0.0);
  }
  #[inline]
  pub fn add_POINTING_ANGLE_EL_START(&mut self, POINTING_ANGLE_EL_START: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POINTING_ANGLE_EL_START, POINTING_ANGLE_EL_START, 0.0);
  }
  #[inline]
  pub fn add_POINTING_ANGLE_EL_END(&mut self, POINTING_ANGLE_EL_END: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_POINTING_ANGLE_EL_END, POINTING_ANGLE_EL_END, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_ARRAY_WIDTH(&mut self, PIXEL_ARRAY_WIDTH: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_PIXEL_ARRAY_WIDTH, PIXEL_ARRAY_WIDTH, 0);
  }
  #[inline]
  pub fn add_PIXEL_ARRAY_HEIGHT(&mut self, PIXEL_ARRAY_HEIGHT: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_PIXEL_ARRAY_HEIGHT, PIXEL_ARRAY_HEIGHT, 0);
  }
  #[inline]
  pub fn add_NUM_SPECTRAL_FILTERS(&mut self, NUM_SPECTRAL_FILTERS: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_NUM_SPECTRAL_FILTERS, NUM_SPECTRAL_FILTERS, 0);
  }
  #[inline]
  pub fn add_SPECTRAL_FILTERS(&mut self, SPECTRAL_FILTERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_SPECTRAL_FILTERS, SPECTRAL_FILTERS);
  }
  #[inline]
  pub fn add_COLLECTION_MODE(&mut self, COLLECTION_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_COLLECTION_MODE, COLLECTION_MODE);
  }
  #[inline]
  pub fn add_GAIN(&mut self, GAIN: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_GAIN, GAIN, 0.0);
  }
  #[inline]
  pub fn add_BINNING_HORIZ(&mut self, BINNING_HORIZ: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_BINNING_HORIZ, BINNING_HORIZ, 0);
  }
  #[inline]
  pub fn add_BINNING_VERT(&mut self, BINNING_VERT: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_BINNING_VERT, BINNING_VERT, 0);
  }
  #[inline]
  pub fn add_SOLAR_MAG(&mut self, SOLAR_MAG: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_SOLAR_MAG, SOLAR_MAG, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_MIN(&mut self, PIXEL_MIN: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_PIXEL_MIN, PIXEL_MIN, 0);
  }
  #[inline]
  pub fn add_PIXEL_MAX(&mut self, PIXEL_MAX: i32) {
    self.fbb_.push_slot::<i32>(SOI::VT_PIXEL_MAX, PIXEL_MAX, 0);
  }
  #[inline]
  pub fn add_SOFTWARE_VERSION(&mut self, SOFTWARE_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_SOFTWARE_VERSION, SOFTWARE_VERSION);
  }
  #[inline]
  pub fn add_SATELLITE_NAME(&mut self, SATELLITE_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_SATELLITE_NAME, SATELLITE_NAME);
  }
  #[inline]
  pub fn add_STAR_CAT_NAME(&mut self, STAR_CAT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_STAR_CAT_NAME, STAR_CAT_NAME);
  }
  #[inline]
  pub fn add_CORR_QUALITY(&mut self, CORR_QUALITY: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_CORR_QUALITY, CORR_QUALITY, 0.0);
  }
  #[inline]
  pub fn add_UCT(&mut self, UCT: bool) {
    self.fbb_.push_slot::<bool>(SOI::VT_UCT, UCT, false);
  }
  #[inline]
  pub fn add_VALID_CALIBRATIONS(&mut self, VALID_CALIBRATIONS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_VALID_CALIBRATIONS, VALID_CALIBRATIONS);
  }
  #[inline]
  pub fn add_CALIBRATION_TYPE(&mut self, CALIBRATION_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_CALIBRATION_TYPE, CALIBRATION_TYPE);
  }
  #[inline]
  pub fn add_PERCENT_SAT_THRESHOLD(&mut self, PERCENT_SAT_THRESHOLD: f64) {
    self.fbb_.push_slot::<f64>(SOI::VT_PERCENT_SAT_THRESHOLD, PERCENT_SAT_THRESHOLD, 0.0);
  }
  #[inline]
  pub fn add_CHANGE_DETECTED(&mut self, CHANGE_DETECTED: bool) {
    self.fbb_.push_slot::<bool>(SOI::VT_CHANGE_DETECTED, CHANGE_DETECTED, false);
  }
  #[inline]
  pub fn add_PERIODICITY_CHANGE_DETECTED(&mut self, PERIODICITY_CHANGE_DETECTED: bool) {
    self.fbb_.push_slot::<bool>(SOI::VT_PERIODICITY_CHANGE_DETECTED, PERIODICITY_CHANGE_DETECTED, false);
  }
  #[inline]
  pub fn add_BRIGHTNESS_VARIANCE_CHANGE_DETECTED(&mut self, BRIGHTNESS_VARIANCE_CHANGE_DETECTED: bool) {
    self.fbb_.push_slot::<bool>(SOI::VT_BRIGHTNESS_VARIANCE_CHANGE_DETECTED, BRIGHTNESS_VARIANCE_CHANGE_DETECTED, false);
  }
  #[inline]
  pub fn add_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED(&mut self, SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: bool) {
    self.fbb_.push_slot::<bool>(SOI::VT_SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED, SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED, false);
  }
  #[inline]
  pub fn add_CHANGE_CONF(&mut self, CHANGE_CONF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_CHANGE_CONF, CHANGE_CONF);
  }
  #[inline]
  pub fn add_COLLECTION_DENSITY_CONF(&mut self, COLLECTION_DENSITY_CONF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_COLLECTION_DENSITY_CONF, COLLECTION_DENSITY_CONF);
  }
  #[inline]
  pub fn add_PERIODICITY_SAMPLING_CONF(&mut self, PERIODICITY_SAMPLING_CONF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_PERIODICITY_SAMPLING_CONF, PERIODICITY_SAMPLING_CONF);
  }
  #[inline]
  pub fn add_PERIODICITY_DETECTION_CONF(&mut self, PERIODICITY_DETECTION_CONF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_PERIODICITY_DETECTION_CONF, PERIODICITY_DETECTION_CONF);
  }
  #[inline]
  pub fn add_COLLECTION_ID(&mut self, COLLECTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_COLLECTION_ID, COLLECTION_ID);
  }
  #[inline]
  pub fn add_CALIBRATIONS(&mut self, CALIBRATIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_CALIBRATIONS, CALIBRATIONS);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_OPTICAL_SOIOBSERVATION_LIST(&mut self, OPTICAL_SOIOBSERVATION_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_OPTICAL_SOIOBSERVATION_LIST, OPTICAL_SOIOBSERVATION_LIST);
  }
  #[inline]
  pub fn add_RADAR_SOIOBSERVATION_LIST(&mut self, RADAR_SOIOBSERVATION_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SOI::VT_RADAR_SOIOBSERVATION_LIST, RADAR_SOIOBSERVATION_LIST);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SOIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SOIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SOI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SOI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SOI");
      ds.field("ID", &self.ID());
      ds.field("MSG_CREATE_DATE", &self.MSG_CREATE_DATE());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("SENSOR_AS_ID", &self.SENSOR_AS_ID());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("SENLAT", &self.SENLAT());
      ds.field("SENLON", &self.SENLON());
      ds.field("SENALT", &self.SENALT());
      ds.field("SENX", &self.SENX());
      ds.field("SENY", &self.SENY());
      ds.field("SENZ", &self.SENZ());
      ds.field("SENVELX", &self.SENVELX());
      ds.field("SENVELY", &self.SENVELY());
      ds.field("SENVELZ", &self.SENVELZ());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("END_TIME", &self.END_TIME());
      ds.field("NUM_OBS", &self.NUM_OBS());
      ds.field("TYPE", &self.TYPE());
      ds.field("POLAR_ANGLE_START", &self.POLAR_ANGLE_START());
      ds.field("POLAR_ANGLE_END", &self.POLAR_ANGLE_END());
      ds.field("REFERENCE_FRAME", &self.REFERENCE_FRAME());
      ds.field("SEN_REFERENCE_FRAME", &self.SEN_REFERENCE_FRAME());
      ds.field("LOS_DECLINATION_START", &self.LOS_DECLINATION_START());
      ds.field("LOS_DECLINATION_END", &self.LOS_DECLINATION_END());
      ds.field("POINTING_ANGLE_AZ_START", &self.POINTING_ANGLE_AZ_START());
      ds.field("POINTING_ANGLE_AZ_END", &self.POINTING_ANGLE_AZ_END());
      ds.field("POINTING_ANGLE_EL_START", &self.POINTING_ANGLE_EL_START());
      ds.field("POINTING_ANGLE_EL_END", &self.POINTING_ANGLE_EL_END());
      ds.field("PIXEL_ARRAY_WIDTH", &self.PIXEL_ARRAY_WIDTH());
      ds.field("PIXEL_ARRAY_HEIGHT", &self.PIXEL_ARRAY_HEIGHT());
      ds.field("NUM_SPECTRAL_FILTERS", &self.NUM_SPECTRAL_FILTERS());
      ds.field("SPECTRAL_FILTERS", &self.SPECTRAL_FILTERS());
      ds.field("COLLECTION_MODE", &self.COLLECTION_MODE());
      ds.field("GAIN", &self.GAIN());
      ds.field("BINNING_HORIZ", &self.BINNING_HORIZ());
      ds.field("BINNING_VERT", &self.BINNING_VERT());
      ds.field("SOLAR_MAG", &self.SOLAR_MAG());
      ds.field("PIXEL_MIN", &self.PIXEL_MIN());
      ds.field("PIXEL_MAX", &self.PIXEL_MAX());
      ds.field("SOFTWARE_VERSION", &self.SOFTWARE_VERSION());
      ds.field("SATELLITE_NAME", &self.SATELLITE_NAME());
      ds.field("STAR_CAT_NAME", &self.STAR_CAT_NAME());
      ds.field("CORR_QUALITY", &self.CORR_QUALITY());
      ds.field("UCT", &self.UCT());
      ds.field("VALID_CALIBRATIONS", &self.VALID_CALIBRATIONS());
      ds.field("CALIBRATION_TYPE", &self.CALIBRATION_TYPE());
      ds.field("PERCENT_SAT_THRESHOLD", &self.PERCENT_SAT_THRESHOLD());
      ds.field("CHANGE_DETECTED", &self.CHANGE_DETECTED());
      ds.field("PERIODICITY_CHANGE_DETECTED", &self.PERIODICITY_CHANGE_DETECTED());
      ds.field("BRIGHTNESS_VARIANCE_CHANGE_DETECTED", &self.BRIGHTNESS_VARIANCE_CHANGE_DETECTED());
      ds.field("SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED", &self.SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED());
      ds.field("CHANGE_CONF", &self.CHANGE_CONF());
      ds.field("COLLECTION_DENSITY_CONF", &self.COLLECTION_DENSITY_CONF());
      ds.field("PERIODICITY_SAMPLING_CONF", &self.PERIODICITY_SAMPLING_CONF());
      ds.field("PERIODICITY_DETECTION_CONF", &self.PERIODICITY_DETECTION_CONF());
      ds.field("COLLECTION_ID", &self.COLLECTION_ID());
      ds.field("CALIBRATIONS", &self.CALIBRATIONS());
      ds.field("TAGS", &self.TAGS());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("OPTICAL_SOIOBSERVATION_LIST", &self.OPTICAL_SOIOBSERVATION_LIST());
      ds.field("RADAR_SOIOBSERVATION_LIST", &self.RADAR_SOIOBSERVATION_LIST());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SOIT {
  pub ID: Option<String>,
  pub MSG_CREATE_DATE: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub SENSOR_AS_ID: Option<String>,
  pub SAT_NO: i32,
  pub ORIG_OBJECT_ID: Option<String>,
  pub SENLAT: f64,
  pub SENLON: f64,
  pub SENALT: f64,
  pub SENX: f64,
  pub SENY: f64,
  pub SENZ: f64,
  pub SENVELX: f64,
  pub SENVELY: f64,
  pub SENVELZ: f64,
  pub START_TIME: Option<String>,
  pub END_TIME: Option<String>,
  pub NUM_OBS: i32,
  pub TYPE: Option<String>,
  pub POLAR_ANGLE_START: f64,
  pub POLAR_ANGLE_END: f64,
  pub REFERENCE_FRAME: Option<String>,
  pub SEN_REFERENCE_FRAME: Option<String>,
  pub LOS_DECLINATION_START: f64,
  pub LOS_DECLINATION_END: f64,
  pub POINTING_ANGLE_AZ_START: f64,
  pub POINTING_ANGLE_AZ_END: f64,
  pub POINTING_ANGLE_EL_START: f64,
  pub POINTING_ANGLE_EL_END: f64,
  pub PIXEL_ARRAY_WIDTH: i32,
  pub PIXEL_ARRAY_HEIGHT: i32,
  pub NUM_SPECTRAL_FILTERS: i32,
  pub SPECTRAL_FILTERS: Option<Vec<String>>,
  pub COLLECTION_MODE: Option<String>,
  pub GAIN: f64,
  pub BINNING_HORIZ: i32,
  pub BINNING_VERT: i32,
  pub SOLAR_MAG: f64,
  pub PIXEL_MIN: i32,
  pub PIXEL_MAX: i32,
  pub SOFTWARE_VERSION: Option<String>,
  pub SATELLITE_NAME: Option<String>,
  pub STAR_CAT_NAME: Option<String>,
  pub CORR_QUALITY: f64,
  pub UCT: bool,
  pub VALID_CALIBRATIONS: Option<String>,
  pub CALIBRATION_TYPE: Option<String>,
  pub PERCENT_SAT_THRESHOLD: f64,
  pub CHANGE_DETECTED: bool,
  pub PERIODICITY_CHANGE_DETECTED: bool,
  pub BRIGHTNESS_VARIANCE_CHANGE_DETECTED: bool,
  pub SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: bool,
  pub CHANGE_CONF: Option<String>,
  pub COLLECTION_DENSITY_CONF: Option<String>,
  pub PERIODICITY_SAMPLING_CONF: Option<String>,
  pub PERIODICITY_DETECTION_CONF: Option<String>,
  pub COLLECTION_ID: Option<String>,
  pub CALIBRATIONS: Option<Vec<String>>,
  pub TAGS: Option<Vec<String>>,
  pub TRANSACTION_ID: Option<String>,
  pub OPTICAL_SOIOBSERVATION_LIST: Option<Vec<String>>,
  pub RADAR_SOIOBSERVATION_LIST: Option<Vec<String>>,
}
impl Default for SOIT {
  fn default() -> Self {
    Self {
      ID: None,
      MSG_CREATE_DATE: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      SENSOR_AS_ID: None,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      SENVELX: 0.0,
      SENVELY: 0.0,
      SENVELZ: 0.0,
      START_TIME: None,
      END_TIME: None,
      NUM_OBS: 0,
      TYPE: None,
      POLAR_ANGLE_START: 0.0,
      POLAR_ANGLE_END: 0.0,
      REFERENCE_FRAME: None,
      SEN_REFERENCE_FRAME: None,
      LOS_DECLINATION_START: 0.0,
      LOS_DECLINATION_END: 0.0,
      POINTING_ANGLE_AZ_START: 0.0,
      POINTING_ANGLE_AZ_END: 0.0,
      POINTING_ANGLE_EL_START: 0.0,
      POINTING_ANGLE_EL_END: 0.0,
      PIXEL_ARRAY_WIDTH: 0,
      PIXEL_ARRAY_HEIGHT: 0,
      NUM_SPECTRAL_FILTERS: 0,
      SPECTRAL_FILTERS: None,
      COLLECTION_MODE: None,
      GAIN: 0.0,
      BINNING_HORIZ: 0,
      BINNING_VERT: 0,
      SOLAR_MAG: 0.0,
      PIXEL_MIN: 0,
      PIXEL_MAX: 0,
      SOFTWARE_VERSION: None,
      SATELLITE_NAME: None,
      STAR_CAT_NAME: None,
      CORR_QUALITY: 0.0,
      UCT: false,
      VALID_CALIBRATIONS: None,
      CALIBRATION_TYPE: None,
      PERCENT_SAT_THRESHOLD: 0.0,
      CHANGE_DETECTED: false,
      PERIODICITY_CHANGE_DETECTED: false,
      BRIGHTNESS_VARIANCE_CHANGE_DETECTED: false,
      SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED: false,
      CHANGE_CONF: None,
      COLLECTION_DENSITY_CONF: None,
      PERIODICITY_SAMPLING_CONF: None,
      PERIODICITY_DETECTION_CONF: None,
      COLLECTION_ID: None,
      CALIBRATIONS: None,
      TAGS: None,
      TRANSACTION_ID: None,
      OPTICAL_SOIOBSERVATION_LIST: None,
      RADAR_SOIOBSERVATION_LIST: None,
    }
  }
}
impl SOIT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SOI<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MSG_CREATE_DATE = self.MSG_CREATE_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENSOR_AS_ID = self.SENSOR_AS_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENLAT = self.SENLAT;
    let SENLON = self.SENLON;
    let SENALT = self.SENALT;
    let SENX = self.SENX;
    let SENY = self.SENY;
    let SENZ = self.SENZ;
    let SENVELX = self.SENVELX;
    let SENVELY = self.SENVELY;
    let SENVELZ = self.SENVELZ;
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END_TIME = self.END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NUM_OBS = self.NUM_OBS;
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POLAR_ANGLE_START = self.POLAR_ANGLE_START;
    let POLAR_ANGLE_END = self.POLAR_ANGLE_END;
    let REFERENCE_FRAME = self.REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SEN_REFERENCE_FRAME = self.SEN_REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOS_DECLINATION_START = self.LOS_DECLINATION_START;
    let LOS_DECLINATION_END = self.LOS_DECLINATION_END;
    let POINTING_ANGLE_AZ_START = self.POINTING_ANGLE_AZ_START;
    let POINTING_ANGLE_AZ_END = self.POINTING_ANGLE_AZ_END;
    let POINTING_ANGLE_EL_START = self.POINTING_ANGLE_EL_START;
    let POINTING_ANGLE_EL_END = self.POINTING_ANGLE_EL_END;
    let PIXEL_ARRAY_WIDTH = self.PIXEL_ARRAY_WIDTH;
    let PIXEL_ARRAY_HEIGHT = self.PIXEL_ARRAY_HEIGHT;
    let NUM_SPECTRAL_FILTERS = self.NUM_SPECTRAL_FILTERS;
    let SPECTRAL_FILTERS = self.SPECTRAL_FILTERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let COLLECTION_MODE = self.COLLECTION_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GAIN = self.GAIN;
    let BINNING_HORIZ = self.BINNING_HORIZ;
    let BINNING_VERT = self.BINNING_VERT;
    let SOLAR_MAG = self.SOLAR_MAG;
    let PIXEL_MIN = self.PIXEL_MIN;
    let PIXEL_MAX = self.PIXEL_MAX;
    let SOFTWARE_VERSION = self.SOFTWARE_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SATELLITE_NAME = self.SATELLITE_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STAR_CAT_NAME = self.STAR_CAT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CORR_QUALITY = self.CORR_QUALITY;
    let UCT = self.UCT;
    let VALID_CALIBRATIONS = self.VALID_CALIBRATIONS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CALIBRATION_TYPE = self.CALIBRATION_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PERCENT_SAT_THRESHOLD = self.PERCENT_SAT_THRESHOLD;
    let CHANGE_DETECTED = self.CHANGE_DETECTED;
    let PERIODICITY_CHANGE_DETECTED = self.PERIODICITY_CHANGE_DETECTED;
    let BRIGHTNESS_VARIANCE_CHANGE_DETECTED = self.BRIGHTNESS_VARIANCE_CHANGE_DETECTED;
    let SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED = self.SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED;
    let CHANGE_CONF = self.CHANGE_CONF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_DENSITY_CONF = self.COLLECTION_DENSITY_CONF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PERIODICITY_SAMPLING_CONF = self.PERIODICITY_SAMPLING_CONF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PERIODICITY_DETECTION_CONF = self.PERIODICITY_DETECTION_CONF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_ID = self.COLLECTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CALIBRATIONS = self.CALIBRATIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPTICAL_SOIOBSERVATION_LIST = self.OPTICAL_SOIOBSERVATION_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let RADAR_SOIOBSERVATION_LIST = self.RADAR_SOIOBSERVATION_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    SOI::create(_fbb, &SOIArgs{
      ID,
      MSG_CREATE_DATE,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      SENSOR_AS_ID,
      SAT_NO,
      ORIG_OBJECT_ID,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      SENVELX,
      SENVELY,
      SENVELZ,
      START_TIME,
      END_TIME,
      NUM_OBS,
      TYPE,
      POLAR_ANGLE_START,
      POLAR_ANGLE_END,
      REFERENCE_FRAME,
      SEN_REFERENCE_FRAME,
      LOS_DECLINATION_START,
      LOS_DECLINATION_END,
      POINTING_ANGLE_AZ_START,
      POINTING_ANGLE_AZ_END,
      POINTING_ANGLE_EL_START,
      POINTING_ANGLE_EL_END,
      PIXEL_ARRAY_WIDTH,
      PIXEL_ARRAY_HEIGHT,
      NUM_SPECTRAL_FILTERS,
      SPECTRAL_FILTERS,
      COLLECTION_MODE,
      GAIN,
      BINNING_HORIZ,
      BINNING_VERT,
      SOLAR_MAG,
      PIXEL_MIN,
      PIXEL_MAX,
      SOFTWARE_VERSION,
      SATELLITE_NAME,
      STAR_CAT_NAME,
      CORR_QUALITY,
      UCT,
      VALID_CALIBRATIONS,
      CALIBRATION_TYPE,
      PERCENT_SAT_THRESHOLD,
      CHANGE_DETECTED,
      PERIODICITY_CHANGE_DETECTED,
      BRIGHTNESS_VARIANCE_CHANGE_DETECTED,
      SOLAR_PHASE_ANGLE_BRIGHTNESS_CHANGE_DETECTED,
      CHANGE_CONF,
      COLLECTION_DENSITY_CONF,
      PERIODICITY_SAMPLING_CONF,
      PERIODICITY_DETECTION_CONF,
      COLLECTION_ID,
      CALIBRATIONS,
      TAGS,
      TRANSACTION_ID,
      OPTICAL_SOIOBSERVATION_LIST,
      RADAR_SOIOBSERVATION_LIST,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SOI`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SOI_unchecked`.
pub fn root_as_SOI(buf: &[u8]) -> Result<SOI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SOI>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SOI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SOI_unchecked`.
pub fn size_prefixed_root_as_SOI(buf: &[u8]) -> Result<SOI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SOI>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SOI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SOI_unchecked`.
pub fn root_as_SOI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SOI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SOI<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SOI` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SOI_unchecked`.
pub fn size_prefixed_root_as_SOI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SOI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SOI<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SOI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SOI`.
pub unsafe fn root_as_SOI_unchecked(buf: &[u8]) -> SOI {
  flatbuffers::root_unchecked::<SOI>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SOI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SOI`.
pub unsafe fn size_prefixed_root_as_SOI_unchecked(buf: &[u8]) -> SOI {
  flatbuffers::size_prefixed_root_unchecked::<SOI>(buf)
}
pub const SOI_IDENTIFIER: &str = "$SOI";

#[inline]
pub fn SOI_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SOI_IDENTIFIER, false)
}

#[inline]
pub fn SOI_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SOI_IDENTIFIER, true)
}

#[inline]
pub fn finish_SOI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SOI<'a>>) {
  fbb.finish(root, Some(SOI_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SOI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SOI<'a>>) {
  fbb.finish_size_prefixed(root, Some(SOI_IDENTIFIER));
}
