// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROPAGATOR_METHOD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROPAGATOR_METHOD: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROPAGATOR_METHOD: [PropagatorMethod; 11] = [
  PropagatorMethod::KEPLER,
  PropagatorMethod::SGP4,
  PropagatorMethod::SDP4,
  PropagatorMethod::HPOP,
  PropagatorMethod::COWELL,
  PropagatorMethod::ENCKE,
  PropagatorMethod::GAUSS_JACKSON,
  PropagatorMethod::RK78,
  PropagatorMethod::BROUWER,
  PropagatorMethod::KOZAI,
  PropagatorMethod::DSST,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PropagatorMethod(pub i8);
#[allow(non_upper_case_globals)]
impl PropagatorMethod {
  pub const KEPLER: Self = Self(0);
  pub const SGP4: Self = Self(1);
  pub const SDP4: Self = Self(2);
  pub const HPOP: Self = Self(3);
  pub const COWELL: Self = Self(4);
  pub const ENCKE: Self = Self(5);
  pub const GAUSS_JACKSON: Self = Self(6);
  pub const RK78: Self = Self(7);
  pub const BROUWER: Self = Self(8);
  pub const KOZAI: Self = Self(9);
  pub const DSST: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::KEPLER,
    Self::SGP4,
    Self::SDP4,
    Self::HPOP,
    Self::COWELL,
    Self::ENCKE,
    Self::GAUSS_JACKSON,
    Self::RK78,
    Self::BROUWER,
    Self::KOZAI,
    Self::DSST,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::KEPLER => Some("KEPLER"),
      Self::SGP4 => Some("SGP4"),
      Self::SDP4 => Some("SDP4"),
      Self::HPOP => Some("HPOP"),
      Self::COWELL => Some("COWELL"),
      Self::ENCKE => Some("ENCKE"),
      Self::GAUSS_JACKSON => Some("GAUSS_JACKSON"),
      Self::RK78 => Some("RK78"),
      Self::BROUWER => Some("BROUWER"),
      Self::KOZAI => Some("KOZAI"),
      Self::DSST => Some("DSST"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PropagatorMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PropagatorMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PropagatorMethod {
    type Output = PropagatorMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PropagatorMethod {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PropagatorMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PropagatorMethod {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FORCE_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FORCE_MODEL: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FORCE_MODEL: [ForceModel; 12] = [
  ForceModel::POINT_MASS,
  ForceModel::J2,
  ForceModel::J2_J4,
  ForceModel::SPHERICAL_HARMONICS,
  ForceModel::THIRD_BODY_SUN,
  ForceModel::THIRD_BODY_MOON,
  ForceModel::ATMOSPHERIC_DRAG,
  ForceModel::SOLAR_RADIATION_PRESSURE,
  ForceModel::RELATIVISTIC,
  ForceModel::SOLID_TIDES,
  ForceModel::OCEAN_TIDES,
  ForceModel::MANEUVER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ForceModel(pub i8);
#[allow(non_upper_case_globals)]
impl ForceModel {
  pub const POINT_MASS: Self = Self(0);
  pub const J2: Self = Self(1);
  pub const J2_J4: Self = Self(2);
  pub const SPHERICAL_HARMONICS: Self = Self(3);
  pub const THIRD_BODY_SUN: Self = Self(4);
  pub const THIRD_BODY_MOON: Self = Self(5);
  pub const ATMOSPHERIC_DRAG: Self = Self(6);
  pub const SOLAR_RADIATION_PRESSURE: Self = Self(7);
  pub const RELATIVISTIC: Self = Self(8);
  pub const SOLID_TIDES: Self = Self(9);
  pub const OCEAN_TIDES: Self = Self(10);
  pub const MANEUVER: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT_MASS,
    Self::J2,
    Self::J2_J4,
    Self::SPHERICAL_HARMONICS,
    Self::THIRD_BODY_SUN,
    Self::THIRD_BODY_MOON,
    Self::ATMOSPHERIC_DRAG,
    Self::SOLAR_RADIATION_PRESSURE,
    Self::RELATIVISTIC,
    Self::SOLID_TIDES,
    Self::OCEAN_TIDES,
    Self::MANEUVER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT_MASS => Some("POINT_MASS"),
      Self::J2 => Some("J2"),
      Self::J2_J4 => Some("J2_J4"),
      Self::SPHERICAL_HARMONICS => Some("SPHERICAL_HARMONICS"),
      Self::THIRD_BODY_SUN => Some("THIRD_BODY_SUN"),
      Self::THIRD_BODY_MOON => Some("THIRD_BODY_MOON"),
      Self::ATMOSPHERIC_DRAG => Some("ATMOSPHERIC_DRAG"),
      Self::SOLAR_RADIATION_PRESSURE => Some("SOLAR_RADIATION_PRESSURE"),
      Self::RELATIVISTIC => Some("RELATIVISTIC"),
      Self::SOLID_TIDES => Some("SOLID_TIDES"),
      Self::OCEAN_TIDES => Some("OCEAN_TIDES"),
      Self::MANEUVER => Some("MANEUVER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ForceModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ForceModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ForceModel {
    type Output = ForceModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ForceModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ForceModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ForceModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ORBITAL_REGIME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ORBITAL_REGIME: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ORBITAL_REGIME: [OrbitalRegime; 11] = [
  OrbitalRegime::LEO,
  OrbitalRegime::MEO,
  OrbitalRegime::GEO,
  OrbitalRegime::HEO,
  OrbitalRegime::SSO,
  OrbitalRegime::MOLNIYA,
  OrbitalRegime::TUNDRA,
  OrbitalRegime::POLAR,
  OrbitalRegime::EQUATORIAL,
  OrbitalRegime::HYPERBOLIC,
  OrbitalRegime::PARABOLIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OrbitalRegime(pub i8);
#[allow(non_upper_case_globals)]
impl OrbitalRegime {
  pub const LEO: Self = Self(0);
  pub const MEO: Self = Self(1);
  pub const GEO: Self = Self(2);
  pub const HEO: Self = Self(3);
  pub const SSO: Self = Self(4);
  pub const MOLNIYA: Self = Self(5);
  pub const TUNDRA: Self = Self(6);
  pub const POLAR: Self = Self(7);
  pub const EQUATORIAL: Self = Self(8);
  pub const HYPERBOLIC: Self = Self(9);
  pub const PARABOLIC: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEO,
    Self::MEO,
    Self::GEO,
    Self::HEO,
    Self::SSO,
    Self::MOLNIYA,
    Self::TUNDRA,
    Self::POLAR,
    Self::EQUATORIAL,
    Self::HYPERBOLIC,
    Self::PARABOLIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEO => Some("LEO"),
      Self::MEO => Some("MEO"),
      Self::GEO => Some("GEO"),
      Self::HEO => Some("HEO"),
      Self::SSO => Some("SSO"),
      Self::MOLNIYA => Some("MOLNIYA"),
      Self::TUNDRA => Some("TUNDRA"),
      Self::POLAR => Some("POLAR"),
      Self::EQUATORIAL => Some("EQUATORIAL"),
      Self::HYPERBOLIC => Some("HYPERBOLIC"),
      Self::PARABOLIC => Some("PARABOLIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OrbitalRegime {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OrbitalRegime {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OrbitalRegime {
    type Output = OrbitalRegime;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OrbitalRegime {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OrbitalRegime {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OrbitalRegime {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TIME_REFERENCE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TIME_REFERENCE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TIME_REFERENCE: [TimeReference; 7] = [
  TimeReference::UTC,
  TimeReference::TAI,
  TimeReference::TT,
  TimeReference::TDB,
  TimeReference::GPS_TIME,
  TimeReference::JULIAN_DATE,
  TimeReference::MODIFIED_JULIAN_DATE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TimeReference(pub i8);
#[allow(non_upper_case_globals)]
impl TimeReference {
  pub const UTC: Self = Self(0);
  pub const TAI: Self = Self(1);
  pub const TT: Self = Self(2);
  pub const TDB: Self = Self(3);
  pub const GPS_TIME: Self = Self(4);
  pub const JULIAN_DATE: Self = Self(5);
  pub const MODIFIED_JULIAN_DATE: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UTC,
    Self::TAI,
    Self::TT,
    Self::TDB,
    Self::GPS_TIME,
    Self::JULIAN_DATE,
    Self::MODIFIED_JULIAN_DATE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UTC => Some("UTC"),
      Self::TAI => Some("TAI"),
      Self::TT => Some("TT"),
      Self::TDB => Some("TDB"),
      Self::GPS_TIME => Some("GPS_TIME"),
      Self::JULIAN_DATE => Some("JULIAN_DATE"),
      Self::MODIFIED_JULIAN_DATE => Some("MODIFIED_JULIAN_DATE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TimeReference {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TimeReference {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TimeReference {
    type Output = TimeReference;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TimeReference {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TimeReference {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TimeReference {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REFERENCE_FRAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REFERENCE_FRAME: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REFERENCE_FRAME: [ReferenceFrame; 10] = [
  ReferenceFrame::ECI_J2000,
  ReferenceFrame::ECEF,
  ReferenceFrame::TEME,
  ReferenceFrame::GCRF,
  ReferenceFrame::ITRF,
  ReferenceFrame::RIC,
  ReferenceFrame::VNC,
  ReferenceFrame::NTW,
  ReferenceFrame::SEZ,
  ReferenceFrame::LVLH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReferenceFrame(pub i8);
#[allow(non_upper_case_globals)]
impl ReferenceFrame {
  pub const ECI_J2000: Self = Self(0);
  pub const ECEF: Self = Self(1);
  pub const TEME: Self = Self(2);
  pub const GCRF: Self = Self(3);
  pub const ITRF: Self = Self(4);
  pub const RIC: Self = Self(5);
  pub const VNC: Self = Self(6);
  pub const NTW: Self = Self(7);
  pub const SEZ: Self = Self(8);
  pub const LVLH: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ECI_J2000,
    Self::ECEF,
    Self::TEME,
    Self::GCRF,
    Self::ITRF,
    Self::RIC,
    Self::VNC,
    Self::NTW,
    Self::SEZ,
    Self::LVLH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ECI_J2000 => Some("ECI_J2000"),
      Self::ECEF => Some("ECEF"),
      Self::TEME => Some("TEME"),
      Self::GCRF => Some("GCRF"),
      Self::ITRF => Some("ITRF"),
      Self::RIC => Some("RIC"),
      Self::VNC => Some("VNC"),
      Self::NTW => Some("NTW"),
      Self::SEZ => Some("SEZ"),
      Self::LVLH => Some("LVLH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReferenceFrame {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReferenceFrame {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReferenceFrame {
    type Output = ReferenceFrame;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReferenceFrame {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReferenceFrame {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReferenceFrame {}
pub enum ASTOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Astrodynamics
pub struct AST<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AST<'a> {
  type Inner = AST<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AST<'a> {
  pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
  pub const VT_PROPAGATION_REQUEST: flatbuffers::VOffsetT = 6;
  pub const VT_TLE: flatbuffers::VOffsetT = 8;
  pub const VT_INITIAL_ELEMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_INITIAL_STATE: flatbuffers::VOffsetT = 12;
  pub const VT_EPOCH_MS: flatbuffers::VOffsetT = 14;
  pub const VT_MANEUVER_PLAN: flatbuffers::VOffsetT = 16;
  pub const VT_CONJUNCTION_PRIMARY: flatbuffers::VOffsetT = 18;
  pub const VT_CONJUNCTION_SECONDARY: flatbuffers::VOffsetT = 20;
  pub const VT_OBSERVATIONS: flatbuffers::VOffsetT = 22;
  pub const VT_OD_CONFIG: flatbuffers::VOffsetT = 24;
  pub const VT_GROUND_STATION: flatbuffers::VOffsetT = 26;
  pub const VT_FORMATION_CONFIG: flatbuffers::VOffsetT = 28;
  pub const VT_TARGET_ELEMENTS: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AST { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ASTArgs<'args>
  ) -> flatbuffers::WIPOffset<AST<'bldr>> {
    let mut builder = ASTBuilder::new(_fbb);
    builder.add_EPOCH_MS(args.EPOCH_MS);
    if let Some(x) = args.TARGET_ELEMENTS { builder.add_TARGET_ELEMENTS(x); }
    if let Some(x) = args.FORMATION_CONFIG { builder.add_FORMATION_CONFIG(x); }
    if let Some(x) = args.GROUND_STATION { builder.add_GROUND_STATION(x); }
    if let Some(x) = args.OD_CONFIG { builder.add_OD_CONFIG(x); }
    if let Some(x) = args.OBSERVATIONS { builder.add_OBSERVATIONS(x); }
    if let Some(x) = args.CONJUNCTION_SECONDARY { builder.add_CONJUNCTION_SECONDARY(x); }
    if let Some(x) = args.CONJUNCTION_PRIMARY { builder.add_CONJUNCTION_PRIMARY(x); }
    if let Some(x) = args.MANEUVER_PLAN { builder.add_MANEUVER_PLAN(x); }
    if let Some(x) = args.INITIAL_STATE { builder.add_INITIAL_STATE(x); }
    if let Some(x) = args.INITIAL_ELEMENTS { builder.add_INITIAL_ELEMENTS(x); }
    if let Some(x) = args.TLE { builder.add_TLE(x); }
    if let Some(x) = args.PROPAGATION_REQUEST { builder.add_PROPAGATION_REQUEST(x); }
    if let Some(x) = args.COMMAND { builder.add_COMMAND(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ASTT {
    let COMMAND = self.COMMAND().map(|x| {
      x.to_string()
    });
    let PROPAGATION_REQUEST = self.PROPAGATION_REQUEST().map(|x| {
      x.to_string()
    });
    let TLE = self.TLE().map(|x| {
      x.to_string()
    });
    let INITIAL_ELEMENTS = self.INITIAL_ELEMENTS().map(|x| {
      x.to_string()
    });
    let INITIAL_STATE = self.INITIAL_STATE().map(|x| {
      x.to_string()
    });
    let EPOCH_MS = self.EPOCH_MS();
    let MANEUVER_PLAN = self.MANEUVER_PLAN().map(|x| {
      x.to_string()
    });
    let CONJUNCTION_PRIMARY = self.CONJUNCTION_PRIMARY().map(|x| {
      x.to_string()
    });
    let CONJUNCTION_SECONDARY = self.CONJUNCTION_SECONDARY().map(|x| {
      x.to_string()
    });
    let OBSERVATIONS = self.OBSERVATIONS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let OD_CONFIG = self.OD_CONFIG().map(|x| {
      x.to_string()
    });
    let GROUND_STATION = self.GROUND_STATION().map(|x| {
      x.to_string()
    });
    let FORMATION_CONFIG = self.FORMATION_CONFIG().map(|x| {
      x.to_string()
    });
    let TARGET_ELEMENTS = self.TARGET_ELEMENTS().map(|x| {
      x.to_string()
    });
    ASTT {
      COMMAND,
      PROPAGATION_REQUEST,
      TLE,
      INITIAL_ELEMENTS,
      INITIAL_STATE,
      EPOCH_MS,
      MANEUVER_PLAN,
      CONJUNCTION_PRIMARY,
      CONJUNCTION_SECONDARY,
      OBSERVATIONS,
      OD_CONFIG,
      GROUND_STATION,
      FORMATION_CONFIG,
      TARGET_ELEMENTS,
    }
  }

  #[inline]
  pub fn COMMAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_COMMAND, None)}
  }
  #[inline]
  pub fn PROPAGATION_REQUEST(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_PROPAGATION_REQUEST, None)}
  }
  #[inline]
  pub fn TLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_TLE, None)}
  }
  #[inline]
  pub fn INITIAL_ELEMENTS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_INITIAL_ELEMENTS, None)}
  }
  #[inline]
  pub fn INITIAL_STATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_INITIAL_STATE, None)}
  }
  #[inline]
  pub fn EPOCH_MS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(AST::VT_EPOCH_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MANEUVER_PLAN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_MANEUVER_PLAN, None)}
  }
  #[inline]
  pub fn CONJUNCTION_PRIMARY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_CONJUNCTION_PRIMARY, None)}
  }
  #[inline]
  pub fn CONJUNCTION_SECONDARY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_CONJUNCTION_SECONDARY, None)}
  }
  #[inline]
  pub fn OBSERVATIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AST::VT_OBSERVATIONS, None)}
  }
  #[inline]
  pub fn OD_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_OD_CONFIG, None)}
  }
  #[inline]
  pub fn GROUND_STATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_GROUND_STATION, None)}
  }
  #[inline]
  pub fn FORMATION_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_FORMATION_CONFIG, None)}
  }
  #[inline]
  pub fn TARGET_ELEMENTS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AST::VT_TARGET_ELEMENTS, None)}
  }
}

impl flatbuffers::Verifiable for AST<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMAND", Self::VT_COMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROPAGATION_REQUEST", Self::VT_PROPAGATION_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TLE", Self::VT_TLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_ELEMENTS", Self::VT_INITIAL_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_STATE", Self::VT_INITIAL_STATE, false)?
     .visit_field::<i64>("EPOCH_MS", Self::VT_EPOCH_MS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MANEUVER_PLAN", Self::VT_MANEUVER_PLAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONJUNCTION_PRIMARY", Self::VT_CONJUNCTION_PRIMARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONJUNCTION_SECONDARY", Self::VT_CONJUNCTION_SECONDARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("OBSERVATIONS", Self::VT_OBSERVATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OD_CONFIG", Self::VT_OD_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GROUND_STATION", Self::VT_GROUND_STATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FORMATION_CONFIG", Self::VT_FORMATION_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TARGET_ELEMENTS", Self::VT_TARGET_ELEMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct ASTArgs<'a> {
    pub COMMAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROPAGATION_REQUEST: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_ELEMENTS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_STATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPOCH_MS: i64,
    pub MANEUVER_PLAN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONJUNCTION_PRIMARY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONJUNCTION_SECONDARY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBSERVATIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub OD_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GROUND_STATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FORMATION_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TARGET_ELEMENTS: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ASTArgs<'a> {
  #[inline]
  fn default() -> Self {
    ASTArgs {
      COMMAND: None,
      PROPAGATION_REQUEST: None,
      TLE: None,
      INITIAL_ELEMENTS: None,
      INITIAL_STATE: None,
      EPOCH_MS: 0,
      MANEUVER_PLAN: None,
      CONJUNCTION_PRIMARY: None,
      CONJUNCTION_SECONDARY: None,
      OBSERVATIONS: None,
      OD_CONFIG: None,
      GROUND_STATION: None,
      FORMATION_CONFIG: None,
      TARGET_ELEMENTS: None,
    }
  }
}

pub struct ASTBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ASTBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMAND(&mut self, COMMAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_COMMAND, COMMAND);
  }
  #[inline]
  pub fn add_PROPAGATION_REQUEST(&mut self, PROPAGATION_REQUEST: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_PROPAGATION_REQUEST, PROPAGATION_REQUEST);
  }
  #[inline]
  pub fn add_TLE(&mut self, TLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_TLE, TLE);
  }
  #[inline]
  pub fn add_INITIAL_ELEMENTS(&mut self, INITIAL_ELEMENTS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_INITIAL_ELEMENTS, INITIAL_ELEMENTS);
  }
  #[inline]
  pub fn add_INITIAL_STATE(&mut self, INITIAL_STATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_INITIAL_STATE, INITIAL_STATE);
  }
  #[inline]
  pub fn add_EPOCH_MS(&mut self, EPOCH_MS: i64) {
    self.fbb_.push_slot::<i64>(AST::VT_EPOCH_MS, EPOCH_MS, 0);
  }
  #[inline]
  pub fn add_MANEUVER_PLAN(&mut self, MANEUVER_PLAN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_MANEUVER_PLAN, MANEUVER_PLAN);
  }
  #[inline]
  pub fn add_CONJUNCTION_PRIMARY(&mut self, CONJUNCTION_PRIMARY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_CONJUNCTION_PRIMARY, CONJUNCTION_PRIMARY);
  }
  #[inline]
  pub fn add_CONJUNCTION_SECONDARY(&mut self, CONJUNCTION_SECONDARY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_CONJUNCTION_SECONDARY, CONJUNCTION_SECONDARY);
  }
  #[inline]
  pub fn add_OBSERVATIONS(&mut self, OBSERVATIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_OBSERVATIONS, OBSERVATIONS);
  }
  #[inline]
  pub fn add_OD_CONFIG(&mut self, OD_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_OD_CONFIG, OD_CONFIG);
  }
  #[inline]
  pub fn add_GROUND_STATION(&mut self, GROUND_STATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_GROUND_STATION, GROUND_STATION);
  }
  #[inline]
  pub fn add_FORMATION_CONFIG(&mut self, FORMATION_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_FORMATION_CONFIG, FORMATION_CONFIG);
  }
  #[inline]
  pub fn add_TARGET_ELEMENTS(&mut self, TARGET_ELEMENTS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AST::VT_TARGET_ELEMENTS, TARGET_ELEMENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ASTBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ASTBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AST<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AST<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AST");
      ds.field("COMMAND", &self.COMMAND());
      ds.field("PROPAGATION_REQUEST", &self.PROPAGATION_REQUEST());
      ds.field("TLE", &self.TLE());
      ds.field("INITIAL_ELEMENTS", &self.INITIAL_ELEMENTS());
      ds.field("INITIAL_STATE", &self.INITIAL_STATE());
      ds.field("EPOCH_MS", &self.EPOCH_MS());
      ds.field("MANEUVER_PLAN", &self.MANEUVER_PLAN());
      ds.field("CONJUNCTION_PRIMARY", &self.CONJUNCTION_PRIMARY());
      ds.field("CONJUNCTION_SECONDARY", &self.CONJUNCTION_SECONDARY());
      ds.field("OBSERVATIONS", &self.OBSERVATIONS());
      ds.field("OD_CONFIG", &self.OD_CONFIG());
      ds.field("GROUND_STATION", &self.GROUND_STATION());
      ds.field("FORMATION_CONFIG", &self.FORMATION_CONFIG());
      ds.field("TARGET_ELEMENTS", &self.TARGET_ELEMENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ASTT {
  pub COMMAND: Option<String>,
  pub PROPAGATION_REQUEST: Option<String>,
  pub TLE: Option<String>,
  pub INITIAL_ELEMENTS: Option<String>,
  pub INITIAL_STATE: Option<String>,
  pub EPOCH_MS: i64,
  pub MANEUVER_PLAN: Option<String>,
  pub CONJUNCTION_PRIMARY: Option<String>,
  pub CONJUNCTION_SECONDARY: Option<String>,
  pub OBSERVATIONS: Option<Vec<String>>,
  pub OD_CONFIG: Option<String>,
  pub GROUND_STATION: Option<String>,
  pub FORMATION_CONFIG: Option<String>,
  pub TARGET_ELEMENTS: Option<String>,
}
impl Default for ASTT {
  fn default() -> Self {
    Self {
      COMMAND: None,
      PROPAGATION_REQUEST: None,
      TLE: None,
      INITIAL_ELEMENTS: None,
      INITIAL_STATE: None,
      EPOCH_MS: 0,
      MANEUVER_PLAN: None,
      CONJUNCTION_PRIMARY: None,
      CONJUNCTION_SECONDARY: None,
      OBSERVATIONS: None,
      OD_CONFIG: None,
      GROUND_STATION: None,
      FORMATION_CONFIG: None,
      TARGET_ELEMENTS: None,
    }
  }
}
impl ASTT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AST<'b>> {
    let COMMAND = self.COMMAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROPAGATION_REQUEST = self.PROPAGATION_REQUEST.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TLE = self.TLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_ELEMENTS = self.INITIAL_ELEMENTS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_STATE = self.INITIAL_STATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPOCH_MS = self.EPOCH_MS;
    let MANEUVER_PLAN = self.MANEUVER_PLAN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONJUNCTION_PRIMARY = self.CONJUNCTION_PRIMARY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONJUNCTION_SECONDARY = self.CONJUNCTION_SECONDARY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBSERVATIONS = self.OBSERVATIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let OD_CONFIG = self.OD_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GROUND_STATION = self.GROUND_STATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FORMATION_CONFIG = self.FORMATION_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TARGET_ELEMENTS = self.TARGET_ELEMENTS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AST::create(_fbb, &ASTArgs{
      COMMAND,
      PROPAGATION_REQUEST,
      TLE,
      INITIAL_ELEMENTS,
      INITIAL_STATE,
      EPOCH_MS,
      MANEUVER_PLAN,
      CONJUNCTION_PRIMARY,
      CONJUNCTION_SECONDARY,
      OBSERVATIONS,
      OD_CONFIG,
      GROUND_STATION,
      FORMATION_CONFIG,
      TARGET_ELEMENTS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `AST`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_AST_unchecked`.
pub fn root_as_AST(buf: &[u8]) -> Result<AST, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<AST>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `AST` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_AST_unchecked`.
pub fn size_prefixed_root_as_AST(buf: &[u8]) -> Result<AST, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<AST>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `AST` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_AST_unchecked`.
pub fn root_as_AST_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AST<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<AST<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `AST` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_AST_unchecked`.
pub fn size_prefixed_root_as_AST_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<AST<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<AST<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a AST and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `AST`.
pub unsafe fn root_as_AST_unchecked(buf: &[u8]) -> AST {
  flatbuffers::root_unchecked::<AST>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed AST and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `AST`.
pub unsafe fn size_prefixed_root_as_AST_unchecked(buf: &[u8]) -> AST {
  flatbuffers::size_prefixed_root_unchecked::<AST>(buf)
}
pub const AST_IDENTIFIER: &str = "$AST";

#[inline]
pub fn AST_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AST_IDENTIFIER, false)
}

#[inline]
pub fn AST_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, AST_IDENTIFIER, true)
}

#[inline]
pub fn finish_AST_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<AST<'a>>) {
  fbb.finish(root, Some(AST_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_AST_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<AST<'a>>) {
  fbb.finish_size_prefixed(root, Some(AST_IDENTIFIER));
}
