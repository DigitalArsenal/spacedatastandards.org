// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ARMOR_MATERIAL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ARMOR_MATERIAL: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ARMOR_MATERIAL: [ArmorMaterial; 15] = [
  ArmorMaterial::RHA,
  ArmorMaterial::CHA,
  ArmorMaterial::FHA,
  ArmorMaterial::HHA,
  ArmorMaterial::ALUMINUM,
  ArmorMaterial::COMPOSITE,
  ArmorMaterial::CERAMIC,
  ArmorMaterial::ERA,
  ArmorMaterial::NERA,
  ArmorMaterial::SPACED,
  ArmorMaterial::RUBBER,
  ArmorMaterial::STRUCTURAL,
  ArmorMaterial::TITANIUM,
  ArmorMaterial::KEVLAR,
  ArmorMaterial::GLASS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ArmorMaterial(pub i8);
#[allow(non_upper_case_globals)]
impl ArmorMaterial {
  pub const RHA: Self = Self(0);
  pub const CHA: Self = Self(1);
  pub const FHA: Self = Self(2);
  pub const HHA: Self = Self(3);
  pub const ALUMINUM: Self = Self(4);
  pub const COMPOSITE: Self = Self(5);
  pub const CERAMIC: Self = Self(6);
  pub const ERA: Self = Self(7);
  pub const NERA: Self = Self(8);
  pub const SPACED: Self = Self(9);
  pub const RUBBER: Self = Self(10);
  pub const STRUCTURAL: Self = Self(11);
  pub const TITANIUM: Self = Self(12);
  pub const KEVLAR: Self = Self(13);
  pub const GLASS: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RHA,
    Self::CHA,
    Self::FHA,
    Self::HHA,
    Self::ALUMINUM,
    Self::COMPOSITE,
    Self::CERAMIC,
    Self::ERA,
    Self::NERA,
    Self::SPACED,
    Self::RUBBER,
    Self::STRUCTURAL,
    Self::TITANIUM,
    Self::KEVLAR,
    Self::GLASS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RHA => Some("RHA"),
      Self::CHA => Some("CHA"),
      Self::FHA => Some("FHA"),
      Self::HHA => Some("HHA"),
      Self::ALUMINUM => Some("ALUMINUM"),
      Self::COMPOSITE => Some("COMPOSITE"),
      Self::CERAMIC => Some("CERAMIC"),
      Self::ERA => Some("ERA"),
      Self::NERA => Some("NERA"),
      Self::SPACED => Some("SPACED"),
      Self::RUBBER => Some("RUBBER"),
      Self::STRUCTURAL => Some("STRUCTURAL"),
      Self::TITANIUM => Some("TITANIUM"),
      Self::KEVLAR => Some("KEVLAR"),
      Self::GLASS => Some("GLASS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ArmorMaterial {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ArmorMaterial {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ArmorMaterial {
    type Output = ArmorMaterial;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ArmorMaterial {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ArmorMaterial {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ArmorMaterial {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AMMO_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AMMO_TYPE: i8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AMMO_TYPE: [AmmoType; 18] = [
  AmmoType::AP,
  AmmoType::APC,
  AmmoType::APCBC,
  AmmoType::APCR,
  AmmoType::APDS,
  AmmoType::APFSDS,
  AmmoType::HEAT,
  AmmoType::HEAT_FS,
  AmmoType::HESH,
  AmmoType::HE,
  AmmoType::HE_FRAG,
  AmmoType::HEDP,
  AmmoType::APHE,
  AmmoType::SAP,
  AmmoType::ATGM,
  AmmoType::TANDEM_HEAT,
  AmmoType::TOP_ATTACK,
  AmmoType::EFP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AmmoType(pub i8);
#[allow(non_upper_case_globals)]
impl AmmoType {
  pub const AP: Self = Self(0);
  pub const APC: Self = Self(1);
  pub const APCBC: Self = Self(2);
  pub const APCR: Self = Self(3);
  pub const APDS: Self = Self(4);
  pub const APFSDS: Self = Self(5);
  pub const HEAT: Self = Self(6);
  pub const HEAT_FS: Self = Self(7);
  pub const HESH: Self = Self(8);
  pub const HE: Self = Self(9);
  pub const HE_FRAG: Self = Self(10);
  pub const HEDP: Self = Self(11);
  pub const APHE: Self = Self(12);
  pub const SAP: Self = Self(13);
  pub const ATGM: Self = Self(14);
  pub const TANDEM_HEAT: Self = Self(15);
  pub const TOP_ATTACK: Self = Self(16);
  pub const EFP: Self = Self(17);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AP,
    Self::APC,
    Self::APCBC,
    Self::APCR,
    Self::APDS,
    Self::APFSDS,
    Self::HEAT,
    Self::HEAT_FS,
    Self::HESH,
    Self::HE,
    Self::HE_FRAG,
    Self::HEDP,
    Self::APHE,
    Self::SAP,
    Self::ATGM,
    Self::TANDEM_HEAT,
    Self::TOP_ATTACK,
    Self::EFP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AP => Some("AP"),
      Self::APC => Some("APC"),
      Self::APCBC => Some("APCBC"),
      Self::APCR => Some("APCR"),
      Self::APDS => Some("APDS"),
      Self::APFSDS => Some("APFSDS"),
      Self::HEAT => Some("HEAT"),
      Self::HEAT_FS => Some("HEAT_FS"),
      Self::HESH => Some("HESH"),
      Self::HE => Some("HE"),
      Self::HE_FRAG => Some("HE_FRAG"),
      Self::HEDP => Some("HEDP"),
      Self::APHE => Some("APHE"),
      Self::SAP => Some("SAP"),
      Self::ATGM => Some("ATGM"),
      Self::TANDEM_HEAT => Some("TANDEM_HEAT"),
      Self::TOP_ATTACK => Some("TOP_ATTACK"),
      Self::EFP => Some("EFP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AmmoType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AmmoType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AmmoType {
    type Output = AmmoType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AmmoType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AmmoType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AmmoType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PEN_RESULT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PEN_RESULT: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PEN_RESULT: [PenResult; 6] = [
  PenResult::NO_PENETRATION,
  PenResult::PARTIAL_PEN,
  PenResult::FULL_PEN,
  PenResult::RICOCHET,
  PenResult::SHATTERED,
  PenResult::OVER_MATCH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PenResult(pub i8);
#[allow(non_upper_case_globals)]
impl PenResult {
  pub const NO_PENETRATION: Self = Self(0);
  pub const PARTIAL_PEN: Self = Self(1);
  pub const FULL_PEN: Self = Self(2);
  pub const RICOCHET: Self = Self(3);
  pub const SHATTERED: Self = Self(4);
  pub const OVER_MATCH: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NO_PENETRATION,
    Self::PARTIAL_PEN,
    Self::FULL_PEN,
    Self::RICOCHET,
    Self::SHATTERED,
    Self::OVER_MATCH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NO_PENETRATION => Some("NO_PENETRATION"),
      Self::PARTIAL_PEN => Some("PARTIAL_PEN"),
      Self::FULL_PEN => Some("FULL_PEN"),
      Self::RICOCHET => Some("RICOCHET"),
      Self::SHATTERED => Some("SHATTERED"),
      Self::OVER_MATCH => Some("OVER_MATCH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PenResult {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PenResult {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PenResult {
    type Output = PenResult;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PenResult {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PenResult {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PenResult {}
pub enum ARMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Armor and Protection
pub struct ARM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ARM<'a> {
  type Inner = ARM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ARM<'a> {
  pub const VT_THICKNESS: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_MATERIAL: flatbuffers::VOffsetT = 8;
  pub const VT_HARDNESS: flatbuffers::VOffsetT = 10;
  pub const VT_QUALITY: flatbuffers::VOffsetT = 12;
  pub const VT_ERA_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_ERA_EFFECTIVENESS: flatbuffers::VOffsetT = 16;
  pub const VT_ERA_VS_KE: flatbuffers::VOffsetT = 18;
  pub const VT_RHA_EQUIVALENT: flatbuffers::VOffsetT = 20;
  pub const VT_NORMAL_X: flatbuffers::VOffsetT = 22;
  pub const VT_NORMAL_Y: flatbuffers::VOffsetT = 24;
  pub const VT_NORMAL_Z: flatbuffers::VOffsetT = 26;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ARM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ARMArgs<'args>
  ) -> flatbuffers::WIPOffset<ARM<'bldr>> {
    let mut builder = ARMBuilder::new(_fbb);
    builder.add_NORMAL_Z(args.NORMAL_Z);
    builder.add_NORMAL_Y(args.NORMAL_Y);
    builder.add_NORMAL_X(args.NORMAL_X);
    builder.add_ANGLE(args.ANGLE);
    builder.add_THICKNESS(args.THICKNESS);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_RHA_EQUIVALENT(args.RHA_EQUIVALENT);
    builder.add_ERA_VS_KE(args.ERA_VS_KE);
    builder.add_ERA_EFFECTIVENESS(args.ERA_EFFECTIVENESS);
    builder.add_ERA_TYPE(args.ERA_TYPE);
    builder.add_QUALITY(args.QUALITY);
    builder.add_HARDNESS(args.HARDNESS);
    builder.add_MATERIAL(args.MATERIAL);
    builder.finish()
  }

  pub fn unpack(&self) -> ARMT {
    let THICKNESS = self.THICKNESS();
    let ANGLE = self.ANGLE();
    let MATERIAL = self.MATERIAL();
    let HARDNESS = self.HARDNESS();
    let QUALITY = self.QUALITY();
    let ERA_TYPE = self.ERA_TYPE();
    let ERA_EFFECTIVENESS = self.ERA_EFFECTIVENESS();
    let ERA_VS_KE = self.ERA_VS_KE();
    let RHA_EQUIVALENT = self.RHA_EQUIVALENT();
    let NORMAL_X = self.NORMAL_X();
    let NORMAL_Y = self.NORMAL_Y();
    let NORMAL_Z = self.NORMAL_Z();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    ARMT {
      THICKNESS,
      ANGLE,
      MATERIAL,
      HARDNESS,
      QUALITY,
      ERA_TYPE,
      ERA_EFFECTIVENESS,
      ERA_VS_KE,
      RHA_EQUIVALENT,
      NORMAL_X,
      NORMAL_Y,
      NORMAL_Z,
      RESERVED,
    }
  }

  #[inline]
  pub fn THICKNESS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ARM::VT_THICKNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ARM::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MATERIAL(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ARM::VT_MATERIAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HARDNESS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ARM::VT_HARDNESS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn QUALITY(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ARM::VT_QUALITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ERA_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ARM::VT_ERA_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ERA_EFFECTIVENESS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ARM::VT_ERA_EFFECTIVENESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ERA_VS_KE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ARM::VT_ERA_VS_KE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RHA_EQUIVALENT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ARM::VT_RHA_EQUIVALENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NORMAL_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ARM::VT_NORMAL_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NORMAL_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ARM::VT_NORMAL_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NORMAL_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ARM::VT_NORMAL_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ARM::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for ARM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("THICKNESS", Self::VT_THICKNESS, false)?
     .visit_field::<f64>("ANGLE", Self::VT_ANGLE, false)?
     .visit_field::<u8>("MATERIAL", Self::VT_MATERIAL, false)?
     .visit_field::<u8>("HARDNESS", Self::VT_HARDNESS, false)?
     .visit_field::<u8>("QUALITY", Self::VT_QUALITY, false)?
     .visit_field::<u8>("ERA_TYPE", Self::VT_ERA_TYPE, false)?
     .visit_field::<f32>("ERA_EFFECTIVENESS", Self::VT_ERA_EFFECTIVENESS, false)?
     .visit_field::<f32>("ERA_VS_KE", Self::VT_ERA_VS_KE, false)?
     .visit_field::<f32>("RHA_EQUIVALENT", Self::VT_RHA_EQUIVALENT, false)?
     .visit_field::<f64>("NORMAL_X", Self::VT_NORMAL_X, false)?
     .visit_field::<f64>("NORMAL_Y", Self::VT_NORMAL_Y, false)?
     .visit_field::<f64>("NORMAL_Z", Self::VT_NORMAL_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct ARMArgs<'a> {
    pub THICKNESS: f64,
    pub ANGLE: f64,
    pub MATERIAL: u8,
    pub HARDNESS: u8,
    pub QUALITY: u8,
    pub ERA_TYPE: u8,
    pub ERA_EFFECTIVENESS: f32,
    pub ERA_VS_KE: f32,
    pub RHA_EQUIVALENT: f32,
    pub NORMAL_X: f64,
    pub NORMAL_Y: f64,
    pub NORMAL_Z: f64,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ARMArgs<'a> {
  #[inline]
  fn default() -> Self {
    ARMArgs {
      THICKNESS: 0.0,
      ANGLE: 0.0,
      MATERIAL: 0,
      HARDNESS: 0,
      QUALITY: 0,
      ERA_TYPE: 0,
      ERA_EFFECTIVENESS: 0.0,
      ERA_VS_KE: 0.0,
      RHA_EQUIVALENT: 0.0,
      NORMAL_X: 0.0,
      NORMAL_Y: 0.0,
      NORMAL_Z: 0.0,
      RESERVED: None,
    }
  }
}

pub struct ARMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ARMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_THICKNESS(&mut self, THICKNESS: f64) {
    self.fbb_.push_slot::<f64>(ARM::VT_THICKNESS, THICKNESS, 0.0);
  }
  #[inline]
  pub fn add_ANGLE(&mut self, ANGLE: f64) {
    self.fbb_.push_slot::<f64>(ARM::VT_ANGLE, ANGLE, 0.0);
  }
  #[inline]
  pub fn add_MATERIAL(&mut self, MATERIAL: u8) {
    self.fbb_.push_slot::<u8>(ARM::VT_MATERIAL, MATERIAL, 0);
  }
  #[inline]
  pub fn add_HARDNESS(&mut self, HARDNESS: u8) {
    self.fbb_.push_slot::<u8>(ARM::VT_HARDNESS, HARDNESS, 0);
  }
  #[inline]
  pub fn add_QUALITY(&mut self, QUALITY: u8) {
    self.fbb_.push_slot::<u8>(ARM::VT_QUALITY, QUALITY, 0);
  }
  #[inline]
  pub fn add_ERA_TYPE(&mut self, ERA_TYPE: u8) {
    self.fbb_.push_slot::<u8>(ARM::VT_ERA_TYPE, ERA_TYPE, 0);
  }
  #[inline]
  pub fn add_ERA_EFFECTIVENESS(&mut self, ERA_EFFECTIVENESS: f32) {
    self.fbb_.push_slot::<f32>(ARM::VT_ERA_EFFECTIVENESS, ERA_EFFECTIVENESS, 0.0);
  }
  #[inline]
  pub fn add_ERA_VS_KE(&mut self, ERA_VS_KE: f32) {
    self.fbb_.push_slot::<f32>(ARM::VT_ERA_VS_KE, ERA_VS_KE, 0.0);
  }
  #[inline]
  pub fn add_RHA_EQUIVALENT(&mut self, RHA_EQUIVALENT: f32) {
    self.fbb_.push_slot::<f32>(ARM::VT_RHA_EQUIVALENT, RHA_EQUIVALENT, 0.0);
  }
  #[inline]
  pub fn add_NORMAL_X(&mut self, NORMAL_X: f64) {
    self.fbb_.push_slot::<f64>(ARM::VT_NORMAL_X, NORMAL_X, 0.0);
  }
  #[inline]
  pub fn add_NORMAL_Y(&mut self, NORMAL_Y: f64) {
    self.fbb_.push_slot::<f64>(ARM::VT_NORMAL_Y, NORMAL_Y, 0.0);
  }
  #[inline]
  pub fn add_NORMAL_Z(&mut self, NORMAL_Z: f64) {
    self.fbb_.push_slot::<f64>(ARM::VT_NORMAL_Z, NORMAL_Z, 0.0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ARM::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ARMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ARMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ARM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ARM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ARM");
      ds.field("THICKNESS", &self.THICKNESS());
      ds.field("ANGLE", &self.ANGLE());
      ds.field("MATERIAL", &self.MATERIAL());
      ds.field("HARDNESS", &self.HARDNESS());
      ds.field("QUALITY", &self.QUALITY());
      ds.field("ERA_TYPE", &self.ERA_TYPE());
      ds.field("ERA_EFFECTIVENESS", &self.ERA_EFFECTIVENESS());
      ds.field("ERA_VS_KE", &self.ERA_VS_KE());
      ds.field("RHA_EQUIVALENT", &self.RHA_EQUIVALENT());
      ds.field("NORMAL_X", &self.NORMAL_X());
      ds.field("NORMAL_Y", &self.NORMAL_Y());
      ds.field("NORMAL_Z", &self.NORMAL_Z());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ARMT {
  pub THICKNESS: f64,
  pub ANGLE: f64,
  pub MATERIAL: u8,
  pub HARDNESS: u8,
  pub QUALITY: u8,
  pub ERA_TYPE: u8,
  pub ERA_EFFECTIVENESS: f32,
  pub ERA_VS_KE: f32,
  pub RHA_EQUIVALENT: f32,
  pub NORMAL_X: f64,
  pub NORMAL_Y: f64,
  pub NORMAL_Z: f64,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for ARMT {
  fn default() -> Self {
    Self {
      THICKNESS: 0.0,
      ANGLE: 0.0,
      MATERIAL: 0,
      HARDNESS: 0,
      QUALITY: 0,
      ERA_TYPE: 0,
      ERA_EFFECTIVENESS: 0.0,
      ERA_VS_KE: 0.0,
      RHA_EQUIVALENT: 0.0,
      NORMAL_X: 0.0,
      NORMAL_Y: 0.0,
      NORMAL_Z: 0.0,
      RESERVED: None,
    }
  }
}
impl ARMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ARM<'b>> {
    let THICKNESS = self.THICKNESS;
    let ANGLE = self.ANGLE;
    let MATERIAL = self.MATERIAL;
    let HARDNESS = self.HARDNESS;
    let QUALITY = self.QUALITY;
    let ERA_TYPE = self.ERA_TYPE;
    let ERA_EFFECTIVENESS = self.ERA_EFFECTIVENESS;
    let ERA_VS_KE = self.ERA_VS_KE;
    let RHA_EQUIVALENT = self.RHA_EQUIVALENT;
    let NORMAL_X = self.NORMAL_X;
    let NORMAL_Y = self.NORMAL_Y;
    let NORMAL_Z = self.NORMAL_Z;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ARM::create(_fbb, &ARMArgs{
      THICKNESS,
      ANGLE,
      MATERIAL,
      HARDNESS,
      QUALITY,
      ERA_TYPE,
      ERA_EFFECTIVENESS,
      ERA_VS_KE,
      RHA_EQUIVALENT,
      NORMAL_X,
      NORMAL_Y,
      NORMAL_Z,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ARM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ARM_unchecked`.
pub fn root_as_ARM(buf: &[u8]) -> Result<ARM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ARM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ARM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ARM_unchecked`.
pub fn size_prefixed_root_as_ARM(buf: &[u8]) -> Result<ARM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ARM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ARM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ARM_unchecked`.
pub fn root_as_ARM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ARM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ARM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ARM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ARM_unchecked`.
pub fn size_prefixed_root_as_ARM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ARM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ARM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ARM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ARM`.
pub unsafe fn root_as_ARM_unchecked(buf: &[u8]) -> ARM {
  flatbuffers::root_unchecked::<ARM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ARM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ARM`.
pub unsafe fn size_prefixed_root_as_ARM_unchecked(buf: &[u8]) -> ARM {
  flatbuffers::size_prefixed_root_unchecked::<ARM>(buf)
}
pub const ARM_IDENTIFIER: &str = "$ARM";

#[inline]
pub fn ARM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ARM_IDENTIFIER, false)
}

#[inline]
pub fn ARM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ARM_IDENTIFIER, true)
}

#[inline]
pub fn finish_ARM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ARM<'a>>) {
  fbb.finish(root, Some(ARM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ARM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ARM<'a>>) {
  fbb.finish_size_prefixed(root, Some(ARM_IDENTIFIER));
}
