// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FILTER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FILTER_TYPE: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FILTER_TYPE: [FilterType; 11] = [
  FilterType::ALPHA_BETA,
  FilterType::ALPHA_BETA_GAMMA,
  FilterType::KALMAN,
  FilterType::EXTENDED_KALMAN,
  FilterType::UNSCENTED_KALMAN,
  FilterType::PARTICLE,
  FilterType::IMM,
  FilterType::JPDA,
  FilterType::MHT,
  FilterType::GNN,
  FilterType::NNKF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FilterType(pub i8);
#[allow(non_upper_case_globals)]
impl FilterType {
  pub const ALPHA_BETA: Self = Self(0);
  pub const ALPHA_BETA_GAMMA: Self = Self(1);
  pub const KALMAN: Self = Self(2);
  pub const EXTENDED_KALMAN: Self = Self(3);
  pub const UNSCENTED_KALMAN: Self = Self(4);
  pub const PARTICLE: Self = Self(5);
  pub const IMM: Self = Self(6);
  pub const JPDA: Self = Self(7);
  pub const MHT: Self = Self(8);
  pub const GNN: Self = Self(9);
  pub const NNKF: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALPHA_BETA,
    Self::ALPHA_BETA_GAMMA,
    Self::KALMAN,
    Self::EXTENDED_KALMAN,
    Self::UNSCENTED_KALMAN,
    Self::PARTICLE,
    Self::IMM,
    Self::JPDA,
    Self::MHT,
    Self::GNN,
    Self::NNKF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ALPHA_BETA => Some("ALPHA_BETA"),
      Self::ALPHA_BETA_GAMMA => Some("ALPHA_BETA_GAMMA"),
      Self::KALMAN => Some("KALMAN"),
      Self::EXTENDED_KALMAN => Some("EXTENDED_KALMAN"),
      Self::UNSCENTED_KALMAN => Some("UNSCENTED_KALMAN"),
      Self::PARTICLE => Some("PARTICLE"),
      Self::IMM => Some("IMM"),
      Self::JPDA => Some("JPDA"),
      Self::MHT => Some("MHT"),
      Self::GNN => Some("GNN"),
      Self::NNKF => Some("NNKF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FilterType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FilterType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FilterType {
    type Output = FilterType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FilterType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FilterType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FilterType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MOTION_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MOTION_MODEL: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MOTION_MODEL: [MotionModel; 9] = [
  MotionModel::CONSTANT_VELOCITY,
  MotionModel::CONSTANT_ACCELERATION,
  MotionModel::COORDINATED_TURN,
  MotionModel::SINGER_ACCELERATION,
  MotionModel::JUMP_MARKOV,
  MotionModel::BALLISTIC,
  MotionModel::ORBITAL,
  MotionModel::SURFACE_VEHICLE,
  MotionModel::CURVILINEAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MotionModel(pub i8);
#[allow(non_upper_case_globals)]
impl MotionModel {
  pub const CONSTANT_VELOCITY: Self = Self(0);
  pub const CONSTANT_ACCELERATION: Self = Self(1);
  pub const COORDINATED_TURN: Self = Self(2);
  pub const SINGER_ACCELERATION: Self = Self(3);
  pub const JUMP_MARKOV: Self = Self(4);
  pub const BALLISTIC: Self = Self(5);
  pub const ORBITAL: Self = Self(6);
  pub const SURFACE_VEHICLE: Self = Self(7);
  pub const CURVILINEAR: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CONSTANT_VELOCITY,
    Self::CONSTANT_ACCELERATION,
    Self::COORDINATED_TURN,
    Self::SINGER_ACCELERATION,
    Self::JUMP_MARKOV,
    Self::BALLISTIC,
    Self::ORBITAL,
    Self::SURFACE_VEHICLE,
    Self::CURVILINEAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CONSTANT_VELOCITY => Some("CONSTANT_VELOCITY"),
      Self::CONSTANT_ACCELERATION => Some("CONSTANT_ACCELERATION"),
      Self::COORDINATED_TURN => Some("COORDINATED_TURN"),
      Self::SINGER_ACCELERATION => Some("SINGER_ACCELERATION"),
      Self::JUMP_MARKOV => Some("JUMP_MARKOV"),
      Self::BALLISTIC => Some("BALLISTIC"),
      Self::ORBITAL => Some("ORBITAL"),
      Self::SURFACE_VEHICLE => Some("SURFACE_VEHICLE"),
      Self::CURVILINEAR => Some("CURVILINEAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MotionModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MotionModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MotionModel {
    type Output = MotionModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MotionModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MotionModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MotionModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MEASUREMENT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MEASUREMENT_TYPE: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEASUREMENT_TYPE: [MeasurementType; 13] = [
  MeasurementType::POSITION_3D,
  MeasurementType::POSITION_2D,
  MeasurementType::RANGE_BEARING,
  MeasurementType::RANGE_BEARING_ELEVATION,
  MeasurementType::RANGE_ONLY,
  MeasurementType::BEARING_ONLY,
  MeasurementType::RANGE_RATE,
  MeasurementType::ANGLES_ONLY,
  MeasurementType::TLE,
  MeasurementType::GPS,
  MeasurementType::RADAR,
  MeasurementType::ADSB,
  MeasurementType::SONAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MeasurementType(pub i8);
#[allow(non_upper_case_globals)]
impl MeasurementType {
  pub const POSITION_3D: Self = Self(0);
  pub const POSITION_2D: Self = Self(1);
  pub const RANGE_BEARING: Self = Self(2);
  pub const RANGE_BEARING_ELEVATION: Self = Self(3);
  pub const RANGE_ONLY: Self = Self(4);
  pub const BEARING_ONLY: Self = Self(5);
  pub const RANGE_RATE: Self = Self(6);
  pub const ANGLES_ONLY: Self = Self(7);
  pub const TLE: Self = Self(8);
  pub const GPS: Self = Self(9);
  pub const RADAR: Self = Self(10);
  pub const ADSB: Self = Self(11);
  pub const SONAR: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POSITION_3D,
    Self::POSITION_2D,
    Self::RANGE_BEARING,
    Self::RANGE_BEARING_ELEVATION,
    Self::RANGE_ONLY,
    Self::BEARING_ONLY,
    Self::RANGE_RATE,
    Self::ANGLES_ONLY,
    Self::TLE,
    Self::GPS,
    Self::RADAR,
    Self::ADSB,
    Self::SONAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POSITION_3D => Some("POSITION_3D"),
      Self::POSITION_2D => Some("POSITION_2D"),
      Self::RANGE_BEARING => Some("RANGE_BEARING"),
      Self::RANGE_BEARING_ELEVATION => Some("RANGE_BEARING_ELEVATION"),
      Self::RANGE_ONLY => Some("RANGE_ONLY"),
      Self::BEARING_ONLY => Some("BEARING_ONLY"),
      Self::RANGE_RATE => Some("RANGE_RATE"),
      Self::ANGLES_ONLY => Some("ANGLES_ONLY"),
      Self::TLE => Some("TLE"),
      Self::GPS => Some("GPS"),
      Self::RADAR => Some("RADAR"),
      Self::ADSB => Some("ADSB"),
      Self::SONAR => Some("SONAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MeasurementType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MeasurementType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MeasurementType {
    type Output = MeasurementType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MeasurementType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MeasurementType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MeasurementType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRACK_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRACK_STATUS: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRACK_STATUS: [TrackStatus; 5] = [
  TrackStatus::TENTATIVE,
  TrackStatus::CONFIRMED,
  TrackStatus::COASTING,
  TrackStatus::LOST,
  TrackStatus::DELETED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TrackStatus(pub i8);
#[allow(non_upper_case_globals)]
impl TrackStatus {
  pub const TENTATIVE: Self = Self(0);
  pub const CONFIRMED: Self = Self(1);
  pub const COASTING: Self = Self(2);
  pub const LOST: Self = Self(3);
  pub const DELETED: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TENTATIVE,
    Self::CONFIRMED,
    Self::COASTING,
    Self::LOST,
    Self::DELETED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TENTATIVE => Some("TENTATIVE"),
      Self::CONFIRMED => Some("CONFIRMED"),
      Self::COASTING => Some("COASTING"),
      Self::LOST => Some("LOST"),
      Self::DELETED => Some("DELETED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TrackStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TrackStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TrackStatus {
    type Output = TrackStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TrackStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TrackStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TrackStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ASSOCIATION_METHOD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ASSOCIATION_METHOD: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ASSOCIATION_METHOD: [AssociationMethod; 7] = [
  AssociationMethod::NEAREST_NEIGHBOR,
  AssociationMethod::GLOBAL_NEAREST_NEIGHBOR,
  AssociationMethod::PROBABILISTIC_DATA,
  AssociationMethod::JOINT_PROBABILISTIC,
  AssociationMethod::AUCTION,
  AssociationMethod::HUNGARIAN,
  AssociationMethod::MUNKRES,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AssociationMethod(pub i8);
#[allow(non_upper_case_globals)]
impl AssociationMethod {
  pub const NEAREST_NEIGHBOR: Self = Self(0);
  pub const GLOBAL_NEAREST_NEIGHBOR: Self = Self(1);
  pub const PROBABILISTIC_DATA: Self = Self(2);
  pub const JOINT_PROBABILISTIC: Self = Self(3);
  pub const AUCTION: Self = Self(4);
  pub const HUNGARIAN: Self = Self(5);
  pub const MUNKRES: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NEAREST_NEIGHBOR,
    Self::GLOBAL_NEAREST_NEIGHBOR,
    Self::PROBABILISTIC_DATA,
    Self::JOINT_PROBABILISTIC,
    Self::AUCTION,
    Self::HUNGARIAN,
    Self::MUNKRES,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NEAREST_NEIGHBOR => Some("NEAREST_NEIGHBOR"),
      Self::GLOBAL_NEAREST_NEIGHBOR => Some("GLOBAL_NEAREST_NEIGHBOR"),
      Self::PROBABILISTIC_DATA => Some("PROBABILISTIC_DATA"),
      Self::JOINT_PROBABILISTIC => Some("JOINT_PROBABILISTIC"),
      Self::AUCTION => Some("AUCTION"),
      Self::HUNGARIAN => Some("HUNGARIAN"),
      Self::MUNKRES => Some("MUNKRES"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AssociationMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AssociationMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AssociationMethod {
    type Output = AssociationMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AssociationMethod {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AssociationMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AssociationMethod {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FUSION_METHOD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FUSION_METHOD: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FUSION_METHOD: [FusionMethod; 6] = [
  FusionMethod::SIMPLE_AVERAGE,
  FusionMethod::WEIGHTED_AVERAGE,
  FusionMethod::COVARIANCE_INTERSECTION,
  FusionMethod::BAR_SHALOM_CAMPO,
  FusionMethod::FEDERATED,
  FusionMethod::SEQUENTIAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FusionMethod(pub i8);
#[allow(non_upper_case_globals)]
impl FusionMethod {
  pub const SIMPLE_AVERAGE: Self = Self(0);
  pub const WEIGHTED_AVERAGE: Self = Self(1);
  pub const COVARIANCE_INTERSECTION: Self = Self(2);
  pub const BAR_SHALOM_CAMPO: Self = Self(3);
  pub const FEDERATED: Self = Self(4);
  pub const SEQUENTIAL: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SIMPLE_AVERAGE,
    Self::WEIGHTED_AVERAGE,
    Self::COVARIANCE_INTERSECTION,
    Self::BAR_SHALOM_CAMPO,
    Self::FEDERATED,
    Self::SEQUENTIAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SIMPLE_AVERAGE => Some("SIMPLE_AVERAGE"),
      Self::WEIGHTED_AVERAGE => Some("WEIGHTED_AVERAGE"),
      Self::COVARIANCE_INTERSECTION => Some("COVARIANCE_INTERSECTION"),
      Self::BAR_SHALOM_CAMPO => Some("BAR_SHALOM_CAMPO"),
      Self::FEDERATED => Some("FEDERATED"),
      Self::SEQUENTIAL => Some("SEQUENTIAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FusionMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FusionMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FusionMethod {
    type Output = FusionMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FusionMethod {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FusionMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FusionMethod {}
pub enum TKGOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Tracking and Data Fusion
pub struct TKG<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TKG<'a> {
  type Inner = TKG<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TKG<'a> {
  pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
  pub const VT_FILTER_CONFIG: flatbuffers::VOffsetT = 6;
  pub const VT_IMM_CONFIG: flatbuffers::VOffsetT = 8;
  pub const VT_MHT_CONFIG: flatbuffers::VOffsetT = 10;
  pub const VT_JPDA_CONFIG: flatbuffers::VOffsetT = 12;
  pub const VT_FUSION_CONFIG: flatbuffers::VOffsetT = 14;
  pub const VT_MEASUREMENTS: flatbuffers::VOffsetT = 16;
  pub const VT_INITIAL_STATE: flatbuffers::VOffsetT = 18;
  pub const VT_TRACK_TO_UPDATE: flatbuffers::VOffsetT = 20;
  pub const VT_TRACKS_TO_CORRELATE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TKG { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TKGArgs<'args>
  ) -> flatbuffers::WIPOffset<TKG<'bldr>> {
    let mut builder = TKGBuilder::new(_fbb);
    if let Some(x) = args.TRACKS_TO_CORRELATE { builder.add_TRACKS_TO_CORRELATE(x); }
    if let Some(x) = args.TRACK_TO_UPDATE { builder.add_TRACK_TO_UPDATE(x); }
    if let Some(x) = args.INITIAL_STATE { builder.add_INITIAL_STATE(x); }
    if let Some(x) = args.MEASUREMENTS { builder.add_MEASUREMENTS(x); }
    if let Some(x) = args.FUSION_CONFIG { builder.add_FUSION_CONFIG(x); }
    if let Some(x) = args.JPDA_CONFIG { builder.add_JPDA_CONFIG(x); }
    if let Some(x) = args.MHT_CONFIG { builder.add_MHT_CONFIG(x); }
    if let Some(x) = args.IMM_CONFIG { builder.add_IMM_CONFIG(x); }
    if let Some(x) = args.FILTER_CONFIG { builder.add_FILTER_CONFIG(x); }
    if let Some(x) = args.COMMAND { builder.add_COMMAND(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TKGT {
    let COMMAND = self.COMMAND().map(|x| {
      x.to_string()
    });
    let FILTER_CONFIG = self.FILTER_CONFIG().map(|x| {
      x.to_string()
    });
    let IMM_CONFIG = self.IMM_CONFIG().map(|x| {
      x.to_string()
    });
    let MHT_CONFIG = self.MHT_CONFIG().map(|x| {
      x.to_string()
    });
    let JPDA_CONFIG = self.JPDA_CONFIG().map(|x| {
      x.to_string()
    });
    let FUSION_CONFIG = self.FUSION_CONFIG().map(|x| {
      x.to_string()
    });
    let MEASUREMENTS = self.MEASUREMENTS().map(|x| {
      x.to_string()
    });
    let INITIAL_STATE = self.INITIAL_STATE().map(|x| {
      x.to_string()
    });
    let TRACK_TO_UPDATE = self.TRACK_TO_UPDATE().map(|x| {
      x.to_string()
    });
    let TRACKS_TO_CORRELATE = self.TRACKS_TO_CORRELATE().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    TKGT {
      COMMAND,
      FILTER_CONFIG,
      IMM_CONFIG,
      MHT_CONFIG,
      JPDA_CONFIG,
      FUSION_CONFIG,
      MEASUREMENTS,
      INITIAL_STATE,
      TRACK_TO_UPDATE,
      TRACKS_TO_CORRELATE,
    }
  }

  #[inline]
  pub fn COMMAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_COMMAND, None)}
  }
  #[inline]
  pub fn FILTER_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_FILTER_CONFIG, None)}
  }
  #[inline]
  pub fn IMM_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_IMM_CONFIG, None)}
  }
  #[inline]
  pub fn MHT_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_MHT_CONFIG, None)}
  }
  #[inline]
  pub fn JPDA_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_JPDA_CONFIG, None)}
  }
  #[inline]
  pub fn FUSION_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_FUSION_CONFIG, None)}
  }
  #[inline]
  pub fn MEASUREMENTS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_MEASUREMENTS, None)}
  }
  #[inline]
  pub fn INITIAL_STATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_INITIAL_STATE, None)}
  }
  #[inline]
  pub fn TRACK_TO_UPDATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TKG::VT_TRACK_TO_UPDATE, None)}
  }
  #[inline]
  pub fn TRACKS_TO_CORRELATE(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TKG::VT_TRACKS_TO_CORRELATE, None)}
  }
}

impl flatbuffers::Verifiable for TKG<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMAND", Self::VT_COMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FILTER_CONFIG", Self::VT_FILTER_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMM_CONFIG", Self::VT_IMM_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MHT_CONFIG", Self::VT_MHT_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JPDA_CONFIG", Self::VT_JPDA_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FUSION_CONFIG", Self::VT_FUSION_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MEASUREMENTS", Self::VT_MEASUREMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_STATE", Self::VT_INITIAL_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_TO_UPDATE", Self::VT_TRACK_TO_UPDATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TRACKS_TO_CORRELATE", Self::VT_TRACKS_TO_CORRELATE, false)?
     .finish();
    Ok(())
  }
}
pub struct TKGArgs<'a> {
    pub COMMAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FILTER_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMM_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MHT_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub JPDA_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FUSION_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEASUREMENTS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_STATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACK_TO_UPDATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACKS_TO_CORRELATE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for TKGArgs<'a> {
  #[inline]
  fn default() -> Self {
    TKGArgs {
      COMMAND: None,
      FILTER_CONFIG: None,
      IMM_CONFIG: None,
      MHT_CONFIG: None,
      JPDA_CONFIG: None,
      FUSION_CONFIG: None,
      MEASUREMENTS: None,
      INITIAL_STATE: None,
      TRACK_TO_UPDATE: None,
      TRACKS_TO_CORRELATE: None,
    }
  }
}

pub struct TKGBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TKGBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMAND(&mut self, COMMAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_COMMAND, COMMAND);
  }
  #[inline]
  pub fn add_FILTER_CONFIG(&mut self, FILTER_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_FILTER_CONFIG, FILTER_CONFIG);
  }
  #[inline]
  pub fn add_IMM_CONFIG(&mut self, IMM_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_IMM_CONFIG, IMM_CONFIG);
  }
  #[inline]
  pub fn add_MHT_CONFIG(&mut self, MHT_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_MHT_CONFIG, MHT_CONFIG);
  }
  #[inline]
  pub fn add_JPDA_CONFIG(&mut self, JPDA_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_JPDA_CONFIG, JPDA_CONFIG);
  }
  #[inline]
  pub fn add_FUSION_CONFIG(&mut self, FUSION_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_FUSION_CONFIG, FUSION_CONFIG);
  }
  #[inline]
  pub fn add_MEASUREMENTS(&mut self, MEASUREMENTS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_MEASUREMENTS, MEASUREMENTS);
  }
  #[inline]
  pub fn add_INITIAL_STATE(&mut self, INITIAL_STATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_INITIAL_STATE, INITIAL_STATE);
  }
  #[inline]
  pub fn add_TRACK_TO_UPDATE(&mut self, TRACK_TO_UPDATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_TRACK_TO_UPDATE, TRACK_TO_UPDATE);
  }
  #[inline]
  pub fn add_TRACKS_TO_CORRELATE(&mut self, TRACKS_TO_CORRELATE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TKG::VT_TRACKS_TO_CORRELATE, TRACKS_TO_CORRELATE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TKGBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TKGBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TKG<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TKG<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TKG");
      ds.field("COMMAND", &self.COMMAND());
      ds.field("FILTER_CONFIG", &self.FILTER_CONFIG());
      ds.field("IMM_CONFIG", &self.IMM_CONFIG());
      ds.field("MHT_CONFIG", &self.MHT_CONFIG());
      ds.field("JPDA_CONFIG", &self.JPDA_CONFIG());
      ds.field("FUSION_CONFIG", &self.FUSION_CONFIG());
      ds.field("MEASUREMENTS", &self.MEASUREMENTS());
      ds.field("INITIAL_STATE", &self.INITIAL_STATE());
      ds.field("TRACK_TO_UPDATE", &self.TRACK_TO_UPDATE());
      ds.field("TRACKS_TO_CORRELATE", &self.TRACKS_TO_CORRELATE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TKGT {
  pub COMMAND: Option<String>,
  pub FILTER_CONFIG: Option<String>,
  pub IMM_CONFIG: Option<String>,
  pub MHT_CONFIG: Option<String>,
  pub JPDA_CONFIG: Option<String>,
  pub FUSION_CONFIG: Option<String>,
  pub MEASUREMENTS: Option<String>,
  pub INITIAL_STATE: Option<String>,
  pub TRACK_TO_UPDATE: Option<String>,
  pub TRACKS_TO_CORRELATE: Option<Vec<String>>,
}
impl Default for TKGT {
  fn default() -> Self {
    Self {
      COMMAND: None,
      FILTER_CONFIG: None,
      IMM_CONFIG: None,
      MHT_CONFIG: None,
      JPDA_CONFIG: None,
      FUSION_CONFIG: None,
      MEASUREMENTS: None,
      INITIAL_STATE: None,
      TRACK_TO_UPDATE: None,
      TRACKS_TO_CORRELATE: None,
    }
  }
}
impl TKGT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TKG<'b>> {
    let COMMAND = self.COMMAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FILTER_CONFIG = self.FILTER_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMM_CONFIG = self.IMM_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MHT_CONFIG = self.MHT_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let JPDA_CONFIG = self.JPDA_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FUSION_CONFIG = self.FUSION_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEASUREMENTS = self.MEASUREMENTS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_STATE = self.INITIAL_STATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACK_TO_UPDATE = self.TRACK_TO_UPDATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACKS_TO_CORRELATE = self.TRACKS_TO_CORRELATE.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    TKG::create(_fbb, &TKGArgs{
      COMMAND,
      FILTER_CONFIG,
      IMM_CONFIG,
      MHT_CONFIG,
      JPDA_CONFIG,
      FUSION_CONFIG,
      MEASUREMENTS,
      INITIAL_STATE,
      TRACK_TO_UPDATE,
      TRACKS_TO_CORRELATE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `TKG`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TKG_unchecked`.
pub fn root_as_TKG(buf: &[u8]) -> Result<TKG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<TKG>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `TKG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_TKG_unchecked`.
pub fn size_prefixed_root_as_TKG(buf: &[u8]) -> Result<TKG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<TKG>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `TKG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TKG_unchecked`.
pub fn root_as_TKG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TKG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<TKG<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `TKG` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_TKG_unchecked`.
pub fn size_prefixed_root_as_TKG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<TKG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<TKG<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a TKG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `TKG`.
pub unsafe fn root_as_TKG_unchecked(buf: &[u8]) -> TKG {
  flatbuffers::root_unchecked::<TKG>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed TKG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `TKG`.
pub unsafe fn size_prefixed_root_as_TKG_unchecked(buf: &[u8]) -> TKG {
  flatbuffers::size_prefixed_root_unchecked::<TKG>(buf)
}
pub const TKG_IDENTIFIER: &str = "$TKG";

#[inline]
pub fn TKG_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TKG_IDENTIFIER, false)
}

#[inline]
pub fn TKG_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, TKG_IDENTIFIER, true)
}

#[inline]
pub fn finish_TKG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<TKG<'a>>) {
  fbb.finish(root, Some(TKG_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_TKG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<TKG<'a>>) {
  fbb.finish_size_prefixed(root, Some(TKG_IDENTIFIER));
}
