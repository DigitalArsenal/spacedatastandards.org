// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum EMEOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Encrypted Message Envelope
pub struct EME<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EME<'a> {
  type Inner = EME<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EME<'a> {
  pub const VT_ENCRYPTED_BLOB: flatbuffers::VOffsetT = 4;
  pub const VT_EPHEMERAL_PUBLIC_KEY: flatbuffers::VOffsetT = 6;
  pub const VT_MAC: flatbuffers::VOffsetT = 8;
  pub const VT_NONCE: flatbuffers::VOffsetT = 10;
  pub const VT_TAG: flatbuffers::VOffsetT = 12;
  pub const VT_IV: flatbuffers::VOffsetT = 14;
  pub const VT_PUBLIC_KEY_IDENTIFIER: flatbuffers::VOffsetT = 16;
  pub const VT_CIPHER_SUITE: flatbuffers::VOffsetT = 18;
  pub const VT_KDF_PARAMETERS: flatbuffers::VOffsetT = 20;
  pub const VT_ENCRYPTION_ALGORITHM_PARAMETERS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EME { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EMEArgs<'args>
  ) -> flatbuffers::WIPOffset<EME<'bldr>> {
    let mut builder = EMEBuilder::new(_fbb);
    if let Some(x) = args.ENCRYPTION_ALGORITHM_PARAMETERS { builder.add_ENCRYPTION_ALGORITHM_PARAMETERS(x); }
    if let Some(x) = args.KDF_PARAMETERS { builder.add_KDF_PARAMETERS(x); }
    if let Some(x) = args.CIPHER_SUITE { builder.add_CIPHER_SUITE(x); }
    if let Some(x) = args.PUBLIC_KEY_IDENTIFIER { builder.add_PUBLIC_KEY_IDENTIFIER(x); }
    if let Some(x) = args.IV { builder.add_IV(x); }
    if let Some(x) = args.TAG { builder.add_TAG(x); }
    if let Some(x) = args.NONCE { builder.add_NONCE(x); }
    if let Some(x) = args.MAC { builder.add_MAC(x); }
    if let Some(x) = args.EPHEMERAL_PUBLIC_KEY { builder.add_EPHEMERAL_PUBLIC_KEY(x); }
    if let Some(x) = args.ENCRYPTED_BLOB { builder.add_ENCRYPTED_BLOB(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EMET {
    let ENCRYPTED_BLOB = self.ENCRYPTED_BLOB().map(|x| {
      x.into_iter().collect()
    });
    let EPHEMERAL_PUBLIC_KEY = self.EPHEMERAL_PUBLIC_KEY().map(|x| {
      x.to_string()
    });
    let MAC = self.MAC().map(|x| {
      x.to_string()
    });
    let NONCE = self.NONCE().map(|x| {
      x.to_string()
    });
    let TAG = self.TAG().map(|x| {
      x.to_string()
    });
    let IV = self.IV().map(|x| {
      x.to_string()
    });
    let PUBLIC_KEY_IDENTIFIER = self.PUBLIC_KEY_IDENTIFIER().map(|x| {
      x.to_string()
    });
    let CIPHER_SUITE = self.CIPHER_SUITE().map(|x| {
      x.to_string()
    });
    let KDF_PARAMETERS = self.KDF_PARAMETERS().map(|x| {
      x.to_string()
    });
    let ENCRYPTION_ALGORITHM_PARAMETERS = self.ENCRYPTION_ALGORITHM_PARAMETERS().map(|x| {
      x.to_string()
    });
    EMET {
      ENCRYPTED_BLOB,
      EPHEMERAL_PUBLIC_KEY,
      MAC,
      NONCE,
      TAG,
      IV,
      PUBLIC_KEY_IDENTIFIER,
      CIPHER_SUITE,
      KDF_PARAMETERS,
      ENCRYPTION_ALGORITHM_PARAMETERS,
    }
  }

  /// Encrypted data blob, containing the ciphertext of the original plaintext message.
  #[inline]
  pub fn ENCRYPTED_BLOB(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EME::VT_ENCRYPTED_BLOB, None)}
  }
  /// Temporary public key used for the encryption session, contributing to the derivation of the shared secret.
  #[inline]
  pub fn EPHEMERAL_PUBLIC_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_EPHEMERAL_PUBLIC_KEY, None)}
  }
  /// Message Authentication Code to verify the integrity and authenticity of the encrypted message.
  #[inline]
  pub fn MAC(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_MAC, None)}
  }
  /// Unique value used to ensure that the same plaintext produces a different ciphertext for each encryption.
  #[inline]
  pub fn NONCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_NONCE, None)}
  }
  /// Additional authentication tag used in some encryption schemes for integrity and authenticity verification.
  #[inline]
  pub fn TAG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_TAG, None)}
  }
  /// Initialization vector used to introduce randomness in the encryption process, enhancing security.
  #[inline]
  pub fn IV(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_IV, None)}
  }
  /// Identifier for the public key used, aiding in recipient key management and message decryption.
  #[inline]
  pub fn PUBLIC_KEY_IDENTIFIER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_PUBLIC_KEY_IDENTIFIER, None)}
  }
  /// Specifies the set of cryptographic algorithms used in the encryption process.
  #[inline]
  pub fn CIPHER_SUITE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_CIPHER_SUITE, None)}
  }
  /// Parameters for the Key Derivation Function, guiding the process of deriving keys from the shared secret.
  #[inline]
  pub fn KDF_PARAMETERS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_KDF_PARAMETERS, None)}
  }
  /// Parameters defining specific settings for the encryption algorithm, such as block size or operation mode.
  #[inline]
  pub fn ENCRYPTION_ALGORITHM_PARAMETERS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EME::VT_ENCRYPTION_ALGORITHM_PARAMETERS, None)}
  }
}

impl flatbuffers::Verifiable for EME<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("ENCRYPTED_BLOB", Self::VT_ENCRYPTED_BLOB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPHEMERAL_PUBLIC_KEY", Self::VT_EPHEMERAL_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MAC", Self::VT_MAC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NONCE", Self::VT_NONCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TAG", Self::VT_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IV", Self::VT_IV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PUBLIC_KEY_IDENTIFIER", Self::VT_PUBLIC_KEY_IDENTIFIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CIPHER_SUITE", Self::VT_CIPHER_SUITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KDF_PARAMETERS", Self::VT_KDF_PARAMETERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENCRYPTION_ALGORITHM_PARAMETERS", Self::VT_ENCRYPTION_ALGORITHM_PARAMETERS, false)?
     .finish();
    Ok(())
  }
}
pub struct EMEArgs<'a> {
    pub ENCRYPTED_BLOB: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub EPHEMERAL_PUBLIC_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MAC: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NONCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PUBLIC_KEY_IDENTIFIER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CIPHER_SUITE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KDF_PARAMETERS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENCRYPTION_ALGORITHM_PARAMETERS: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EMEArgs<'a> {
  #[inline]
  fn default() -> Self {
    EMEArgs {
      ENCRYPTED_BLOB: None,
      EPHEMERAL_PUBLIC_KEY: None,
      MAC: None,
      NONCE: None,
      TAG: None,
      IV: None,
      PUBLIC_KEY_IDENTIFIER: None,
      CIPHER_SUITE: None,
      KDF_PARAMETERS: None,
      ENCRYPTION_ALGORITHM_PARAMETERS: None,
    }
  }
}

pub struct EMEBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EMEBuilder<'a, 'b> {
  #[inline]
  pub fn add_ENCRYPTED_BLOB(&mut self, ENCRYPTED_BLOB: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_ENCRYPTED_BLOB, ENCRYPTED_BLOB);
  }
  #[inline]
  pub fn add_EPHEMERAL_PUBLIC_KEY(&mut self, EPHEMERAL_PUBLIC_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_EPHEMERAL_PUBLIC_KEY, EPHEMERAL_PUBLIC_KEY);
  }
  #[inline]
  pub fn add_MAC(&mut self, MAC: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_MAC, MAC);
  }
  #[inline]
  pub fn add_NONCE(&mut self, NONCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_NONCE, NONCE);
  }
  #[inline]
  pub fn add_TAG(&mut self, TAG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_TAG, TAG);
  }
  #[inline]
  pub fn add_IV(&mut self, IV: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_IV, IV);
  }
  #[inline]
  pub fn add_PUBLIC_KEY_IDENTIFIER(&mut self, PUBLIC_KEY_IDENTIFIER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_PUBLIC_KEY_IDENTIFIER, PUBLIC_KEY_IDENTIFIER);
  }
  #[inline]
  pub fn add_CIPHER_SUITE(&mut self, CIPHER_SUITE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_CIPHER_SUITE, CIPHER_SUITE);
  }
  #[inline]
  pub fn add_KDF_PARAMETERS(&mut self, KDF_PARAMETERS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_KDF_PARAMETERS, KDF_PARAMETERS);
  }
  #[inline]
  pub fn add_ENCRYPTION_ALGORITHM_PARAMETERS(&mut self, ENCRYPTION_ALGORITHM_PARAMETERS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EME::VT_ENCRYPTION_ALGORITHM_PARAMETERS, ENCRYPTION_ALGORITHM_PARAMETERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EMEBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EMEBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EME<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EME<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EME");
      ds.field("ENCRYPTED_BLOB", &self.ENCRYPTED_BLOB());
      ds.field("EPHEMERAL_PUBLIC_KEY", &self.EPHEMERAL_PUBLIC_KEY());
      ds.field("MAC", &self.MAC());
      ds.field("NONCE", &self.NONCE());
      ds.field("TAG", &self.TAG());
      ds.field("IV", &self.IV());
      ds.field("PUBLIC_KEY_IDENTIFIER", &self.PUBLIC_KEY_IDENTIFIER());
      ds.field("CIPHER_SUITE", &self.CIPHER_SUITE());
      ds.field("KDF_PARAMETERS", &self.KDF_PARAMETERS());
      ds.field("ENCRYPTION_ALGORITHM_PARAMETERS", &self.ENCRYPTION_ALGORITHM_PARAMETERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EMET {
  pub ENCRYPTED_BLOB: Option<Vec<u8>>,
  pub EPHEMERAL_PUBLIC_KEY: Option<String>,
  pub MAC: Option<String>,
  pub NONCE: Option<String>,
  pub TAG: Option<String>,
  pub IV: Option<String>,
  pub PUBLIC_KEY_IDENTIFIER: Option<String>,
  pub CIPHER_SUITE: Option<String>,
  pub KDF_PARAMETERS: Option<String>,
  pub ENCRYPTION_ALGORITHM_PARAMETERS: Option<String>,
}
impl Default for EMET {
  fn default() -> Self {
    Self {
      ENCRYPTED_BLOB: None,
      EPHEMERAL_PUBLIC_KEY: None,
      MAC: None,
      NONCE: None,
      TAG: None,
      IV: None,
      PUBLIC_KEY_IDENTIFIER: None,
      CIPHER_SUITE: None,
      KDF_PARAMETERS: None,
      ENCRYPTION_ALGORITHM_PARAMETERS: None,
    }
  }
}
impl EMET {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EME<'b>> {
    let ENCRYPTED_BLOB = self.ENCRYPTED_BLOB.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let EPHEMERAL_PUBLIC_KEY = self.EPHEMERAL_PUBLIC_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MAC = self.MAC.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NONCE = self.NONCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAG = self.TAG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IV = self.IV.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PUBLIC_KEY_IDENTIFIER = self.PUBLIC_KEY_IDENTIFIER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CIPHER_SUITE = self.CIPHER_SUITE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KDF_PARAMETERS = self.KDF_PARAMETERS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENCRYPTION_ALGORITHM_PARAMETERS = self.ENCRYPTION_ALGORITHM_PARAMETERS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EME::create(_fbb, &EMEArgs{
      ENCRYPTED_BLOB,
      EPHEMERAL_PUBLIC_KEY,
      MAC,
      NONCE,
      TAG,
      IV,
      PUBLIC_KEY_IDENTIFIER,
      CIPHER_SUITE,
      KDF_PARAMETERS,
      ENCRYPTION_ALGORITHM_PARAMETERS,
    })
  }
}
pub enum EMECOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EMECOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EMECOLLECTION<'a> {
  type Inner = EMECOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EMECOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EMECOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EMECOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<EMECOLLECTION<'bldr>> {
    let mut builder = EMECOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EMECOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    EMECOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EME<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EME>>>>(EMECOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for EMECOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EME>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct EMECOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EME<'a>>>>>,
}
impl<'a> Default for EMECOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    EMECOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct EMECOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EMECOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EME<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EMECOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EMECOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EMECOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EMECOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EMECOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EMECOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EMECOLLECTIONT {
  pub RECORDS: Option<Vec<EMET>>,
}
impl Default for EMECOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl EMECOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EMECOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    EMECOLLECTION::create(_fbb, &EMECOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EME`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EME_unchecked`.
pub fn root_as_EME(buf: &[u8]) -> Result<EME, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EME>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EME` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EME_unchecked`.
pub fn size_prefixed_root_as_EME(buf: &[u8]) -> Result<EME, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EME>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EME` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EME_unchecked`.
pub fn root_as_EME_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EME<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EME<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EME` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EME_unchecked`.
pub fn size_prefixed_root_as_EME_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EME<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EME<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EME and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EME`.
pub unsafe fn root_as_EME_unchecked(buf: &[u8]) -> EME {
  flatbuffers::root_unchecked::<EME>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EME and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EME`.
pub unsafe fn size_prefixed_root_as_EME_unchecked(buf: &[u8]) -> EME {
  flatbuffers::size_prefixed_root_unchecked::<EME>(buf)
}
pub const EME_IDENTIFIER: &str = "$EME";

#[inline]
pub fn EME_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EME_IDENTIFIER, false)
}

#[inline]
pub fn EME_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EME_IDENTIFIER, true)
}

#[inline]
pub fn finish_EME_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<EME<'a>>) {
  fbb.finish(root, Some(EME_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EME_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<EME<'a>>) {
  fbb.finish_size_prefixed(root, Some(EME_IDENTIFIER));
}
