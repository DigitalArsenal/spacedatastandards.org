// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REFERENCE_FRAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REFERENCE_FRAME: i8 = 22;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REFERENCE_FRAME: [referenceFrame; 23] = [
  referenceFrame::ECEF,
  referenceFrame::ICRF,
  referenceFrame::TEME,
  referenceFrame::ENU,
  referenceFrame::NED,
  referenceFrame::NEU,
  referenceFrame::RIC,
  referenceFrame::J2000,
  referenceFrame::GCRF,
  referenceFrame::GRC,
  referenceFrame::ITRF2000,
  referenceFrame::ITRF93,
  referenceFrame::ITRF97,
  referenceFrame::TDR,
  referenceFrame::TOD,
  referenceFrame::RTN,
  referenceFrame::TVN,
  referenceFrame::VVLH,
  referenceFrame::VLVH,
  referenceFrame::LTP,
  referenceFrame::LVLH,
  referenceFrame::PNE,
  referenceFrame::BRF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct referenceFrame(pub i8);
#[allow(non_upper_case_globals)]
impl referenceFrame {
  /// Earth-Centered-Earth-Fixed (ECEF) frame: Rotates with Earth. Origin at Earth's center. X-axis towards prime meridian, Y-axis eastward, Z-axis towards North Pole. Ideal for terrestrial points.
  pub const ECEF: Self = Self(0);
  /// International Celestial Reference Frame (ICRF): An inertial frame fixed relative to distant stars. Based on quasars. Used for precision astronomy and unaffected by Earth's rotation.
  pub const ICRF: Self = Self(1);
  /// True Equator Mean Equinox (TEME): Used in SGP4 model for satellite tracking. Accounts for Earth's precession and nutation. Dynamic frame useful for orbit prediction.
  pub const TEME: Self = Self(2);
  /// East-North-Up (ENU): Local tangent plane system for surface points. "East" eastward, "North" northward, "Up" perpendicular to Earth's surface. Suited for stationary or slow-moving objects at low altitudes.
  pub const ENU: Self = Self(3);
  /// North-East-Down (NED): Common in aviation and navigation. "North" northward, "East" eastward, "Down" towards Earth's center. Aligns with gravity, intuitive for aircraft and vehicles.
  pub const NED: Self = Self(4);
  /// North-East-Up (NEU): Similar to NED but "Up" axis is opposite to gravity. Suited for applications preferring a conventional "Up" direction.
  pub const NEU: Self = Self(5);
  /// Radial-Intrack-Cross-track (RIC): Aligned with spacecraft's UVW system. "Radial" axis towards spacecraft, "In-track" perpendicular to radial and cross-track, "Cross-track" normal to orbit plane. Used for spacecraft orientation and tracking.
  pub const RIC: Self = Self(6);
  /// Earth Mean Equator and Equinox of J2000 (J2000): An Earth-Centered Inertial (ECI) frame defined by Earth's mean equator and equinox at the start of the year 2000. Fixed relative to distant stars, used for celestial mechanics and space navigation.
  pub const J2000: Self = Self(7);
  /// Geocentric Celestial Reference Frame
  pub const GCRF: Self = Self(8);
  /// Greenwich Rotating Coordinates
  pub const GRC: Self = Self(9);
  /// International Terrestrial Reference Frame 2000
  pub const ITRF2000: Self = Self(10);
  /// International Terrestrial Reference Frame 1993
  pub const ITRF93: Self = Self(11);
  /// International Terrestrial Reference Frame 1997
  pub const ITRF97: Self = Self(12);
  /// True of Date, Rotating
  pub const TDR: Self = Self(13);
  /// True of Date
  pub const TOD: Self = Self(14);
  /// Radial, Transverse, Normal
  pub const RTN: Self = Self(15);
  /// Transverse, Velocity, Normal
  pub const TVN: Self = Self(16);
  /// Vehicle-Body-Local-Horizontal (VVLH): An orbit reference frame with X-axis pointing from the center of the central body to the vehicle, Z-axis oppoOBSERVER to the orbital angular momentum vector, and Y-axis completing the right-handed system.
  pub const VVLH: Self = Self(17);
  /// Vehicle-Local-Vertical-Local-Horizontal (VLVH): An orbit reference frame similar to VVLH, often used in close proximity operations or surface-oriented missions.
  pub const VLVH: Self = Self(18);
  /// Local Tangent Plane (LTP): A local, surface-fixed reference frame often used for terrestrial applications, aligned with the local horizon.
  pub const LTP: Self = Self(19);
  /// Local Vertical-Local Horizontal (LVLH): An orbit reference frame with the Z-axis pointing towards the center of the central body (oppoOBSERVER to local vertical), the X-axis in the velocity direction (local horizontal), and the Y-axis completing the right-hand system.
  pub const LVLH: Self = Self(20);
  /// Polar-North-East (PNE): A variation of local coordinate systems typically used in polar regions, with axes aligned toward the geographic North Pole, Eastward, and perpendicular to the Earth's surface.
  pub const PNE: Self = Self(21);
  /// Body-Fixed Reference Frame (BRF): A reference frame fixed to the body of a spacecraft or celestial object, oriented according to the body's principal axes.
  pub const BRF: Self = Self(22);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 22;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ECEF,
    Self::ICRF,
    Self::TEME,
    Self::ENU,
    Self::NED,
    Self::NEU,
    Self::RIC,
    Self::J2000,
    Self::GCRF,
    Self::GRC,
    Self::ITRF2000,
    Self::ITRF93,
    Self::ITRF97,
    Self::TDR,
    Self::TOD,
    Self::RTN,
    Self::TVN,
    Self::VVLH,
    Self::VLVH,
    Self::LTP,
    Self::LVLH,
    Self::PNE,
    Self::BRF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ECEF => Some("ECEF"),
      Self::ICRF => Some("ICRF"),
      Self::TEME => Some("TEME"),
      Self::ENU => Some("ENU"),
      Self::NED => Some("NED"),
      Self::NEU => Some("NEU"),
      Self::RIC => Some("RIC"),
      Self::J2000 => Some("J2000"),
      Self::GCRF => Some("GCRF"),
      Self::GRC => Some("GRC"),
      Self::ITRF2000 => Some("ITRF2000"),
      Self::ITRF93 => Some("ITRF93"),
      Self::ITRF97 => Some("ITRF97"),
      Self::TDR => Some("TDR"),
      Self::TOD => Some("TOD"),
      Self::RTN => Some("RTN"),
      Self::TVN => Some("TVN"),
      Self::VVLH => Some("VVLH"),
      Self::VLVH => Some("VLVH"),
      Self::LTP => Some("LTP"),
      Self::LVLH => Some("LVLH"),
      Self::PNE => Some("PNE"),
      Self::BRF => Some("BRF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for referenceFrame {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for referenceFrame {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for referenceFrame {
    type Output = referenceFrame;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for referenceFrame {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for referenceFrame {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for referenceFrame {}
pub enum RFMOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RFM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RFM<'a> {
  type Inner = RFM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RFM<'a> {
  pub const VT_REFERENCE_FRAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RFM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RFMArgs
  ) -> flatbuffers::WIPOffset<RFM<'bldr>> {
    let mut builder = RFMBuilder::new(_fbb);
    builder.add_REFERENCE_FRAME(args.REFERENCE_FRAME);
    builder.finish()
  }

  pub fn unpack(&self) -> RFMT {
    let REFERENCE_FRAME = self.REFERENCE_FRAME();
    RFMT {
      REFERENCE_FRAME,
    }
  }

  #[inline]
  pub fn REFERENCE_FRAME(&self) -> referenceFrame {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<referenceFrame>(RFM::VT_REFERENCE_FRAME, Some(referenceFrame::ECEF)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RFM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<referenceFrame>("REFERENCE_FRAME", Self::VT_REFERENCE_FRAME, false)?
     .finish();
    Ok(())
  }
}
pub struct RFMArgs {
    pub REFERENCE_FRAME: referenceFrame,
}
impl<'a> Default for RFMArgs {
  #[inline]
  fn default() -> Self {
    RFMArgs {
      REFERENCE_FRAME: referenceFrame::ECEF,
    }
  }
}

pub struct RFMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RFMBuilder<'a, 'b> {
  #[inline]
  pub fn add_REFERENCE_FRAME(&mut self, REFERENCE_FRAME: referenceFrame) {
    self.fbb_.push_slot::<referenceFrame>(RFM::VT_REFERENCE_FRAME, REFERENCE_FRAME, referenceFrame::ECEF);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RFMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RFMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RFM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RFM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RFM");
      ds.field("REFERENCE_FRAME", &self.REFERENCE_FRAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RFMT {
  pub REFERENCE_FRAME: referenceFrame,
}
impl Default for RFMT {
  fn default() -> Self {
    Self {
      REFERENCE_FRAME: referenceFrame::ECEF,
    }
  }
}
impl RFMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<RFM<'b>> {
    let REFERENCE_FRAME = self.REFERENCE_FRAME;
    RFM::create(_fbb, &RFMArgs{
      REFERENCE_FRAME,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RFM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFM_unchecked`.
pub fn root_as_RFM(buf: &[u8]) -> Result<RFM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RFM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RFM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_RFM_unchecked`.
pub fn size_prefixed_root_as_RFM(buf: &[u8]) -> Result<RFM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RFM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RFM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFM_unchecked`.
pub fn root_as_RFM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RFM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RFM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFM_unchecked`.
pub fn size_prefixed_root_as_RFM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RFM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RFM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RFM`.
pub unsafe fn root_as_RFM_unchecked(buf: &[u8]) -> RFM {
  flatbuffers::root_unchecked::<RFM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RFM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RFM`.
pub unsafe fn size_prefixed_root_as_RFM_unchecked(buf: &[u8]) -> RFM {
  flatbuffers::size_prefixed_root_unchecked::<RFM>(buf)
}
pub const RFM_IDENTIFIER: &str = "$RFM";

#[inline]
pub fn RFM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFM_IDENTIFIER, false)
}

#[inline]
pub fn RFM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFM_IDENTIFIER, true)
}

#[inline]
pub fn finish_RFM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<RFM<'a>>) {
  fbb.finish(root, Some(RFM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_RFM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<RFM<'a>>) {
  fbb.finish_size_prefixed(root, Some(RFM_IDENTIFIER));
}
