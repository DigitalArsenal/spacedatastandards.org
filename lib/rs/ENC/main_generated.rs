// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KEY_EXCHANGE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KEY_EXCHANGE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KEY_EXCHANGE: [KeyExchange; 3] = [
  KeyExchange::X25519,
  KeyExchange::Secp256k1,
  KeyExchange::P256,
];

/// Encryption Header for FlatBuffers field-level encryption
/// Key exchange algorithm used to derive the shared secret
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KeyExchange(pub i8);
#[allow(non_upper_case_globals)]
impl KeyExchange {
  pub const X25519: Self = Self(0);
  pub const Secp256k1: Self = Self(1);
  pub const P256: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::X25519,
    Self::Secp256k1,
    Self::P256,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::X25519 => Some("X25519"),
      Self::Secp256k1 => Some("Secp256k1"),
      Self::P256 => Some("P256"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KeyExchange {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KeyExchange {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KeyExchange {
    type Output = KeyExchange;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KeyExchange {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KeyExchange {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KeyExchange {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SYMMETRIC_ALGO: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SYMMETRIC_ALGO: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SYMMETRIC_ALGO: [SymmetricAlgo; 1] = [
  SymmetricAlgo::AES_256_CTR,
];

/// Symmetric encryption algorithm
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SymmetricAlgo(pub i8);
#[allow(non_upper_case_globals)]
impl SymmetricAlgo {
  pub const AES_256_CTR: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AES_256_CTR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AES_256_CTR => Some("AES_256_CTR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SymmetricAlgo {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SymmetricAlgo {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SymmetricAlgo {
    type Output = SymmetricAlgo;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SymmetricAlgo {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SymmetricAlgo {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SymmetricAlgo {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KDF: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KDF: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KDF: [KDF; 1] = [
  KDF::HKDF_SHA256,
];

/// Key derivation function
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KDF(pub i8);
#[allow(non_upper_case_globals)]
impl KDF {
  pub const HKDF_SHA256: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HKDF_SHA256,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HKDF_SHA256 => Some("HKDF_SHA256"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KDF {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KDF {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KDF {
    type Output = KDF;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KDF {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KDF {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KDF {}
pub enum ENCOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Encryption Header containing all parameters needed for decryption
pub struct ENC<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ENC<'a> {
  type Inner = ENC<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ENC<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_KEY_EXCHANGE: flatbuffers::VOffsetT = 6;
  pub const VT_SYMMETRIC: flatbuffers::VOffsetT = 8;
  pub const VT_KEY_DERIVATION: flatbuffers::VOffsetT = 10;
  pub const VT_EPHEMERAL_PUBLIC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_NONCE_START: flatbuffers::VOffsetT = 14;
  pub const VT_RECIPIENT_KEY_ID: flatbuffers::VOffsetT = 16;
  pub const VT_CONTEXT: flatbuffers::VOffsetT = 18;
  pub const VT_SCHEMA_HASH: flatbuffers::VOffsetT = 20;
  pub const VT_ROOT_TYPE: flatbuffers::VOffsetT = 22;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ENC { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ENCArgs<'args>
  ) -> flatbuffers::WIPOffset<ENC<'bldr>> {
    let mut builder = ENCBuilder::new(_fbb);
    builder.add_TIMESTAMP(args.TIMESTAMP);
    if let Some(x) = args.ROOT_TYPE { builder.add_ROOT_TYPE(x); }
    if let Some(x) = args.SCHEMA_HASH { builder.add_SCHEMA_HASH(x); }
    if let Some(x) = args.CONTEXT { builder.add_CONTEXT(x); }
    if let Some(x) = args.RECIPIENT_KEY_ID { builder.add_RECIPIENT_KEY_ID(x); }
    if let Some(x) = args.NONCE_START { builder.add_NONCE_START(x); }
    if let Some(x) = args.EPHEMERAL_PUBLIC_KEY { builder.add_EPHEMERAL_PUBLIC_KEY(x); }
    builder.add_KEY_DERIVATION(args.KEY_DERIVATION);
    builder.add_SYMMETRIC(args.SYMMETRIC);
    builder.add_KEY_EXCHANGE(args.KEY_EXCHANGE);
    builder.add_VERSION(args.VERSION);
    builder.finish()
  }

  pub fn unpack(&self) -> ENCT {
    let VERSION = self.VERSION();
    let KEY_EXCHANGE = self.KEY_EXCHANGE();
    let SYMMETRIC = self.SYMMETRIC();
    let KEY_DERIVATION = self.KEY_DERIVATION();
    let EPHEMERAL_PUBLIC_KEY = {
      let x = self.EPHEMERAL_PUBLIC_KEY();
      x.into_iter().collect()
    };
    let NONCE_START = {
      let x = self.NONCE_START();
      x.into_iter().collect()
    };
    let RECIPIENT_KEY_ID = self.RECIPIENT_KEY_ID().map(|x| {
      x.into_iter().collect()
    });
    let CONTEXT = self.CONTEXT().map(|x| {
      x.to_string()
    });
    let SCHEMA_HASH = self.SCHEMA_HASH().map(|x| {
      x.into_iter().collect()
    });
    let ROOT_TYPE = self.ROOT_TYPE().map(|x| {
      x.to_string()
    });
    let TIMESTAMP = self.TIMESTAMP();
    ENCT {
      VERSION,
      KEY_EXCHANGE,
      SYMMETRIC,
      KEY_DERIVATION,
      EPHEMERAL_PUBLIC_KEY,
      NONCE_START,
      RECIPIENT_KEY_ID,
      CONTEXT,
      SCHEMA_HASH,
      ROOT_TYPE,
      TIMESTAMP,
    }
  }

  /// Schema version for forward compatibility
  #[inline]
  pub fn VERSION(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ENC::VT_VERSION, Some(1)).unwrap()}
  }
  /// Key exchange algorithm used
  #[inline]
  pub fn KEY_EXCHANGE(&self) -> KeyExchange {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KeyExchange>(ENC::VT_KEY_EXCHANGE, Some(KeyExchange::X25519)).unwrap()}
  }
  /// Symmetric encryption algorithm used
  #[inline]
  pub fn SYMMETRIC(&self) -> SymmetricAlgo {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SymmetricAlgo>(ENC::VT_SYMMETRIC, Some(SymmetricAlgo::AES_256_CTR)).unwrap()}
  }
  /// Key derivation function used
  #[inline]
  pub fn KEY_DERIVATION(&self) -> KDF {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KDF>(ENC::VT_KEY_DERIVATION, Some(KDF::HKDF_SHA256)).unwrap()}
  }
  /// Ephemeral public key for ECDH key agreement (32-65 bytes depending on algorithm)
  #[inline]
  pub fn EPHEMERAL_PUBLIC_KEY(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ENC::VT_EPHEMERAL_PUBLIC_KEY, None).unwrap()}
  }
  /// Random 12-byte nonce starting value. Incremented for each record in the stream to ensure unique nonces.
  #[inline]
  pub fn NONCE_START(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ENC::VT_NONCE_START, None).unwrap()}
  }
  /// Optional identifier for the recipient's public key (up to 32 bytes)
  #[inline]
  pub fn RECIPIENT_KEY_ID(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ENC::VT_RECIPIENT_KEY_ID, None)}
  }
  /// Optional domain separation context string
  #[inline]
  pub fn CONTEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ENC::VT_CONTEXT, None)}
  }
  /// Optional SHA-256 hash of the FlatBuffers schema (32 bytes)
  #[inline]
  pub fn SCHEMA_HASH(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ENC::VT_SCHEMA_HASH, None)}
  }
  /// Optional root type name from the schema
  #[inline]
  pub fn ROOT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ENC::VT_ROOT_TYPE, None)}
  }
  /// Optional Unix timestamp (milliseconds) when encryption was performed
  #[inline]
  pub fn TIMESTAMP(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ENC::VT_TIMESTAMP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ENC<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<KeyExchange>("KEY_EXCHANGE", Self::VT_KEY_EXCHANGE, false)?
     .visit_field::<SymmetricAlgo>("SYMMETRIC", Self::VT_SYMMETRIC, false)?
     .visit_field::<KDF>("KEY_DERIVATION", Self::VT_KEY_DERIVATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("EPHEMERAL_PUBLIC_KEY", Self::VT_EPHEMERAL_PUBLIC_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("NONCE_START", Self::VT_NONCE_START, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RECIPIENT_KEY_ID", Self::VT_RECIPIENT_KEY_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTEXT", Self::VT_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("SCHEMA_HASH", Self::VT_SCHEMA_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ROOT_TYPE", Self::VT_ROOT_TYPE, false)?
     .visit_field::<u64>("TIMESTAMP", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct ENCArgs<'a> {
    pub VERSION: u8,
    pub KEY_EXCHANGE: KeyExchange,
    pub SYMMETRIC: SymmetricAlgo,
    pub KEY_DERIVATION: KDF,
    pub EPHEMERAL_PUBLIC_KEY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub NONCE_START: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub RECIPIENT_KEY_ID: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub CONTEXT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCHEMA_HASH: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ROOT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIMESTAMP: u64,
}
impl<'a> Default for ENCArgs<'a> {
  #[inline]
  fn default() -> Self {
    ENCArgs {
      VERSION: 1,
      KEY_EXCHANGE: KeyExchange::X25519,
      SYMMETRIC: SymmetricAlgo::AES_256_CTR,
      KEY_DERIVATION: KDF::HKDF_SHA256,
      EPHEMERAL_PUBLIC_KEY: None, // required field
      NONCE_START: None, // required field
      RECIPIENT_KEY_ID: None,
      CONTEXT: None,
      SCHEMA_HASH: None,
      ROOT_TYPE: None,
      TIMESTAMP: 0,
    }
  }
}

pub struct ENCBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ENCBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: u8) {
    self.fbb_.push_slot::<u8>(ENC::VT_VERSION, VERSION, 1);
  }
  #[inline]
  pub fn add_KEY_EXCHANGE(&mut self, KEY_EXCHANGE: KeyExchange) {
    self.fbb_.push_slot::<KeyExchange>(ENC::VT_KEY_EXCHANGE, KEY_EXCHANGE, KeyExchange::X25519);
  }
  #[inline]
  pub fn add_SYMMETRIC(&mut self, SYMMETRIC: SymmetricAlgo) {
    self.fbb_.push_slot::<SymmetricAlgo>(ENC::VT_SYMMETRIC, SYMMETRIC, SymmetricAlgo::AES_256_CTR);
  }
  #[inline]
  pub fn add_KEY_DERIVATION(&mut self, KEY_DERIVATION: KDF) {
    self.fbb_.push_slot::<KDF>(ENC::VT_KEY_DERIVATION, KEY_DERIVATION, KDF::HKDF_SHA256);
  }
  #[inline]
  pub fn add_EPHEMERAL_PUBLIC_KEY(&mut self, EPHEMERAL_PUBLIC_KEY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_EPHEMERAL_PUBLIC_KEY, EPHEMERAL_PUBLIC_KEY);
  }
  #[inline]
  pub fn add_NONCE_START(&mut self, NONCE_START: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_NONCE_START, NONCE_START);
  }
  #[inline]
  pub fn add_RECIPIENT_KEY_ID(&mut self, RECIPIENT_KEY_ID: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_RECIPIENT_KEY_ID, RECIPIENT_KEY_ID);
  }
  #[inline]
  pub fn add_CONTEXT(&mut self, CONTEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_CONTEXT, CONTEXT);
  }
  #[inline]
  pub fn add_SCHEMA_HASH(&mut self, SCHEMA_HASH: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_SCHEMA_HASH, SCHEMA_HASH);
  }
  #[inline]
  pub fn add_ROOT_TYPE(&mut self, ROOT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENC::VT_ROOT_TYPE, ROOT_TYPE);
  }
  #[inline]
  pub fn add_TIMESTAMP(&mut self, TIMESTAMP: u64) {
    self.fbb_.push_slot::<u64>(ENC::VT_TIMESTAMP, TIMESTAMP, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ENCBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ENCBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ENC<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ENC::VT_EPHEMERAL_PUBLIC_KEY,"EPHEMERAL_PUBLIC_KEY");
    self.fbb_.required(o, ENC::VT_NONCE_START,"NONCE_START");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ENC<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ENC");
      ds.field("VERSION", &self.VERSION());
      ds.field("KEY_EXCHANGE", &self.KEY_EXCHANGE());
      ds.field("SYMMETRIC", &self.SYMMETRIC());
      ds.field("KEY_DERIVATION", &self.KEY_DERIVATION());
      ds.field("EPHEMERAL_PUBLIC_KEY", &self.EPHEMERAL_PUBLIC_KEY());
      ds.field("NONCE_START", &self.NONCE_START());
      ds.field("RECIPIENT_KEY_ID", &self.RECIPIENT_KEY_ID());
      ds.field("CONTEXT", &self.CONTEXT());
      ds.field("SCHEMA_HASH", &self.SCHEMA_HASH());
      ds.field("ROOT_TYPE", &self.ROOT_TYPE());
      ds.field("TIMESTAMP", &self.TIMESTAMP());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ENCT {
  pub VERSION: u8,
  pub KEY_EXCHANGE: KeyExchange,
  pub SYMMETRIC: SymmetricAlgo,
  pub KEY_DERIVATION: KDF,
  pub EPHEMERAL_PUBLIC_KEY: Vec<u8>,
  pub NONCE_START: Vec<u8>,
  pub RECIPIENT_KEY_ID: Option<Vec<u8>>,
  pub CONTEXT: Option<String>,
  pub SCHEMA_HASH: Option<Vec<u8>>,
  pub ROOT_TYPE: Option<String>,
  pub TIMESTAMP: u64,
}
impl Default for ENCT {
  fn default() -> Self {
    Self {
      VERSION: 1,
      KEY_EXCHANGE: KeyExchange::X25519,
      SYMMETRIC: SymmetricAlgo::AES_256_CTR,
      KEY_DERIVATION: KDF::HKDF_SHA256,
      EPHEMERAL_PUBLIC_KEY: Default::default(),
      NONCE_START: Default::default(),
      RECIPIENT_KEY_ID: None,
      CONTEXT: None,
      SCHEMA_HASH: None,
      ROOT_TYPE: None,
      TIMESTAMP: 0,
    }
  }
}
impl ENCT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ENC<'b>> {
    let VERSION = self.VERSION;
    let KEY_EXCHANGE = self.KEY_EXCHANGE;
    let SYMMETRIC = self.SYMMETRIC;
    let KEY_DERIVATION = self.KEY_DERIVATION;
    let EPHEMERAL_PUBLIC_KEY = Some({
      let x = &self.EPHEMERAL_PUBLIC_KEY;
      _fbb.create_vector(x)
    });
    let NONCE_START = Some({
      let x = &self.NONCE_START;
      _fbb.create_vector(x)
    });
    let RECIPIENT_KEY_ID = self.RECIPIENT_KEY_ID.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let CONTEXT = self.CONTEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCHEMA_HASH = self.SCHEMA_HASH.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ROOT_TYPE = self.ROOT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIMESTAMP = self.TIMESTAMP;
    ENC::create(_fbb, &ENCArgs{
      VERSION,
      KEY_EXCHANGE,
      SYMMETRIC,
      KEY_DERIVATION,
      EPHEMERAL_PUBLIC_KEY,
      NONCE_START,
      RECIPIENT_KEY_ID,
      CONTEXT,
      SCHEMA_HASH,
      ROOT_TYPE,
      TIMESTAMP,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ENC`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ENC_unchecked`.
pub fn root_as_ENC(buf: &[u8]) -> Result<ENC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ENC>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ENC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ENC_unchecked`.
pub fn size_prefixed_root_as_ENC(buf: &[u8]) -> Result<ENC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ENC>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ENC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ENC_unchecked`.
pub fn root_as_ENC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ENC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ENC<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ENC` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ENC_unchecked`.
pub fn size_prefixed_root_as_ENC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ENC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ENC<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ENC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ENC`.
pub unsafe fn root_as_ENC_unchecked(buf: &[u8]) -> ENC {
  flatbuffers::root_unchecked::<ENC>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ENC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ENC`.
pub unsafe fn size_prefixed_root_as_ENC_unchecked(buf: &[u8]) -> ENC {
  flatbuffers::size_prefixed_root_unchecked::<ENC>(buf)
}
pub const ENC_IDENTIFIER: &str = "$ENC";

#[inline]
pub fn ENC_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ENC_IDENTIFIER, false)
}

#[inline]
pub fn ENC_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ENC_IDENTIFIER, true)
}

#[inline]
pub fn finish_ENC_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ENC<'a>>) {
  fbb.finish(root, Some(ENC_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ENC_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ENC<'a>>) {
  fbb.finish_size_prefixed(root, Some(ENC_IDENTIFIER));
}
