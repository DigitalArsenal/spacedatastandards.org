// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SCREENING_VOLUME_SHAPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SCREENING_VOLUME_SHAPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCREENING_VOLUME_SHAPE: [screeningVolumeShape; 2] = [
  screeningVolumeShape::ELLIPSOID,
  screeningVolumeShape::BOX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct screeningVolumeShape(pub i8);
#[allow(non_upper_case_globals)]
impl screeningVolumeShape {
  pub const ELLIPSOID: Self = Self(0);
  pub const BOX: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ELLIPSOID,
    Self::BOX,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ELLIPSOID => Some("ELLIPSOID"),
      Self::BOX => Some("BOX"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for screeningVolumeShape {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for screeningVolumeShape {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for screeningVolumeShape {
    type Output = screeningVolumeShape;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for screeningVolumeShape {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for screeningVolumeShape {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for screeningVolumeShape {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COVARIANCE_METHOD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COVARIANCE_METHOD: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COVARIANCE_METHOD: [covarianceMethod; 2] = [
  covarianceMethod::CALCULATED,
  covarianceMethod::DEFAULT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct covarianceMethod(pub i8);
#[allow(non_upper_case_globals)]
impl covarianceMethod {
  pub const CALCULATED: Self = Self(0);
  pub const DEFAULT: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CALCULATED,
    Self::DEFAULT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CALCULATED => Some("CALCULATED"),
      Self::DEFAULT => Some("DEFAULT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for covarianceMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for covarianceMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for covarianceMethod {
    type Output = covarianceMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for covarianceMethod {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for covarianceMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for covarianceMethod {}
pub enum CDMObjectOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CDMObject<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CDMObject<'a> {
  type Inner = CDMObject<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CDMObject<'a> {
  pub const VT_COMMENT: flatbuffers::VOffsetT = 4;
  pub const VT_OBJECT: flatbuffers::VOffsetT = 6;
  pub const VT_POC: flatbuffers::VOffsetT = 8;
  pub const VT_OPERATOR_CONTACT_POSITION: flatbuffers::VOffsetT = 10;
  pub const VT_OPERATOR_ORGANIZATION: flatbuffers::VOffsetT = 12;
  pub const VT_EPHEMERIS_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_COVARIANCE_METHOD: flatbuffers::VOffsetT = 16;
  pub const VT_REFERENCE_FRAME: flatbuffers::VOffsetT = 18;
  pub const VT_GRAVITY_MODEL: flatbuffers::VOffsetT = 20;
  pub const VT_ATMOSPHERIC_MODEL: flatbuffers::VOffsetT = 22;
  pub const VT_N_BODY_PERTURBATIONS: flatbuffers::VOffsetT = 24;
  pub const VT_SOLAR_RAD_PRESSURE: flatbuffers::VOffsetT = 26;
  pub const VT_EARTH_TIDES: flatbuffers::VOffsetT = 28;
  pub const VT_INTRACK_THRUST: flatbuffers::VOffsetT = 30;
  pub const VT_TIME_LASTOB_START: flatbuffers::VOffsetT = 32;
  pub const VT_TIME_LASTOB_END: flatbuffers::VOffsetT = 34;
  pub const VT_RECOMMENDED_OD_SPAN: flatbuffers::VOffsetT = 36;
  pub const VT_ACTUAL_OD_SPAN: flatbuffers::VOffsetT = 38;
  pub const VT_OBS_AVAILABLE: flatbuffers::VOffsetT = 40;
  pub const VT_OBS_USED: flatbuffers::VOffsetT = 42;
  pub const VT_TRACKS_AVAILABLE: flatbuffers::VOffsetT = 44;
  pub const VT_TRACKS_USED: flatbuffers::VOffsetT = 46;
  pub const VT_RESIDUALS_ACCEPTED: flatbuffers::VOffsetT = 48;
  pub const VT_WEIGHTED_RMS: flatbuffers::VOffsetT = 50;
  pub const VT_AREA_PC: flatbuffers::VOffsetT = 52;
  pub const VT_AREA_DRG: flatbuffers::VOffsetT = 54;
  pub const VT_AREA_SRP: flatbuffers::VOffsetT = 56;
  pub const VT_CR_AREA_OVER_MASS: flatbuffers::VOffsetT = 58;
  pub const VT_THRUST_ACCELERATION: flatbuffers::VOffsetT = 60;
  pub const VT_SEDR: flatbuffers::VOffsetT = 62;
  pub const VT_X: flatbuffers::VOffsetT = 64;
  pub const VT_Y: flatbuffers::VOffsetT = 66;
  pub const VT_Z: flatbuffers::VOffsetT = 68;
  pub const VT_X_DOT: flatbuffers::VOffsetT = 70;
  pub const VT_Y_DOT: flatbuffers::VOffsetT = 72;
  pub const VT_Z_DOT: flatbuffers::VOffsetT = 74;
  pub const VT_COVARIANCE: flatbuffers::VOffsetT = 76;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CDMObject { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CDMObjectArgs<'args>
  ) -> flatbuffers::WIPOffset<CDMObject<'bldr>> {
    let mut builder = CDMObjectBuilder::new(_fbb);
    builder.add_Z_DOT(args.Z_DOT);
    builder.add_Y_DOT(args.Y_DOT);
    builder.add_X_DOT(args.X_DOT);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    builder.add_SEDR(args.SEDR);
    builder.add_THRUST_ACCELERATION(args.THRUST_ACCELERATION);
    builder.add_CR_AREA_OVER_MASS(args.CR_AREA_OVER_MASS);
    builder.add_AREA_SRP(args.AREA_SRP);
    builder.add_AREA_DRG(args.AREA_DRG);
    builder.add_AREA_PC(args.AREA_PC);
    builder.add_WEIGHTED_RMS(args.WEIGHTED_RMS);
    builder.add_RESIDUALS_ACCEPTED(args.RESIDUALS_ACCEPTED);
    builder.add_ACTUAL_OD_SPAN(args.ACTUAL_OD_SPAN);
    builder.add_RECOMMENDED_OD_SPAN(args.RECOMMENDED_OD_SPAN);
    if let Some(x) = args.COVARIANCE { builder.add_COVARIANCE(x); }
    builder.add_TRACKS_USED(args.TRACKS_USED);
    builder.add_TRACKS_AVAILABLE(args.TRACKS_AVAILABLE);
    builder.add_OBS_USED(args.OBS_USED);
    builder.add_OBS_AVAILABLE(args.OBS_AVAILABLE);
    if let Some(x) = args.TIME_LASTOB_END { builder.add_TIME_LASTOB_END(x); }
    if let Some(x) = args.TIME_LASTOB_START { builder.add_TIME_LASTOB_START(x); }
    if let Some(x) = args.N_BODY_PERTURBATIONS { builder.add_N_BODY_PERTURBATIONS(x); }
    if let Some(x) = args.ATMOSPHERIC_MODEL { builder.add_ATMOSPHERIC_MODEL(x); }
    if let Some(x) = args.GRAVITY_MODEL { builder.add_GRAVITY_MODEL(x); }
    if let Some(x) = args.REFERENCE_FRAME { builder.add_REFERENCE_FRAME(x); }
    if let Some(x) = args.EPHEMERIS_NAME { builder.add_EPHEMERIS_NAME(x); }
    if let Some(x) = args.OPERATOR_ORGANIZATION { builder.add_OPERATOR_ORGANIZATION(x); }
    if let Some(x) = args.OPERATOR_CONTACT_POSITION { builder.add_OPERATOR_CONTACT_POSITION(x); }
    if let Some(x) = args.POC { builder.add_POC(x); }
    if let Some(x) = args.OBJECT { builder.add_OBJECT(x); }
    if let Some(x) = args.COMMENT { builder.add_COMMENT(x); }
    builder.add_INTRACK_THRUST(args.INTRACK_THRUST);
    builder.add_EARTH_TIDES(args.EARTH_TIDES);
    builder.add_SOLAR_RAD_PRESSURE(args.SOLAR_RAD_PRESSURE);
    builder.add_COVARIANCE_METHOD(args.COVARIANCE_METHOD);
    builder.finish()
  }

  pub fn unpack(&self) -> CDMObjectT {
    let COMMENT = self.COMMENT().map(|x| {
      x.to_string()
    });
    let OBJECT = self.OBJECT().map(|x| {
      Box::new(x.unpack())
    });
    let POC = self.POC().map(|x| {
      Box::new(x.unpack())
    });
    let OPERATOR_CONTACT_POSITION = self.OPERATOR_CONTACT_POSITION().map(|x| {
      x.to_string()
    });
    let OPERATOR_ORGANIZATION = self.OPERATOR_ORGANIZATION().map(|x| {
      x.to_string()
    });
    let EPHEMERIS_NAME = self.EPHEMERIS_NAME().map(|x| {
      x.to_string()
    });
    let COVARIANCE_METHOD = self.COVARIANCE_METHOD();
    let REFERENCE_FRAME = self.REFERENCE_FRAME().map(|x| {
      Box::new(x.unpack())
    });
    let GRAVITY_MODEL = self.GRAVITY_MODEL().map(|x| {
      x.to_string()
    });
    let ATMOSPHERIC_MODEL = self.ATMOSPHERIC_MODEL().map(|x| {
      x.to_string()
    });
    let N_BODY_PERTURBATIONS = self.N_BODY_PERTURBATIONS().map(|x| {
      x.to_string()
    });
    let SOLAR_RAD_PRESSURE = self.SOLAR_RAD_PRESSURE();
    let EARTH_TIDES = self.EARTH_TIDES();
    let INTRACK_THRUST = self.INTRACK_THRUST();
    let TIME_LASTOB_START = self.TIME_LASTOB_START().map(|x| {
      x.to_string()
    });
    let TIME_LASTOB_END = self.TIME_LASTOB_END().map(|x| {
      x.to_string()
    });
    let RECOMMENDED_OD_SPAN = self.RECOMMENDED_OD_SPAN();
    let ACTUAL_OD_SPAN = self.ACTUAL_OD_SPAN();
    let OBS_AVAILABLE = self.OBS_AVAILABLE();
    let OBS_USED = self.OBS_USED();
    let TRACKS_AVAILABLE = self.TRACKS_AVAILABLE();
    let TRACKS_USED = self.TRACKS_USED();
    let RESIDUALS_ACCEPTED = self.RESIDUALS_ACCEPTED();
    let WEIGHTED_RMS = self.WEIGHTED_RMS();
    let AREA_PC = self.AREA_PC();
    let AREA_DRG = self.AREA_DRG();
    let AREA_SRP = self.AREA_SRP();
    let CR_AREA_OVER_MASS = self.CR_AREA_OVER_MASS();
    let THRUST_ACCELERATION = self.THRUST_ACCELERATION();
    let SEDR = self.SEDR();
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let X_DOT = self.X_DOT();
    let Y_DOT = self.Y_DOT();
    let Z_DOT = self.Z_DOT();
    let COVARIANCE = self.COVARIANCE().map(|x| {
      x.into_iter().collect()
    });
    CDMObjectT {
      COMMENT,
      OBJECT,
      POC,
      OPERATOR_CONTACT_POSITION,
      OPERATOR_ORGANIZATION,
      EPHEMERIS_NAME,
      COVARIANCE_METHOD,
      REFERENCE_FRAME,
      GRAVITY_MODEL,
      ATMOSPHERIC_MODEL,
      N_BODY_PERTURBATIONS,
      SOLAR_RAD_PRESSURE,
      EARTH_TIDES,
      INTRACK_THRUST,
      TIME_LASTOB_START,
      TIME_LASTOB_END,
      RECOMMENDED_OD_SPAN,
      ACTUAL_OD_SPAN,
      OBS_AVAILABLE,
      OBS_USED,
      TRACKS_AVAILABLE,
      TRACKS_USED,
      RESIDUALS_ACCEPTED,
      WEIGHTED_RMS,
      AREA_PC,
      AREA_DRG,
      AREA_SRP,
      CR_AREA_OVER_MASS,
      THRUST_ACCELERATION,
      SEDR,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      COVARIANCE,
    }
  }

  /// A comment
  #[inline]
  pub fn COMMENT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_COMMENT, None)}
  }
  #[inline]
  pub fn OBJECT(&self) -> Option<CAT<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CAT>>(CDMObject::VT_OBJECT, None)}
  }
  /// Point of Contact
  #[inline]
  pub fn POC(&self) -> Option<EPM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EPM>>(CDMObject::VT_POC, None)}
  }
  /// Operator contact position
  #[inline]
  pub fn OPERATOR_CONTACT_POSITION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_OPERATOR_CONTACT_POSITION, None)}
  }
  /// Operator organization
  #[inline]
  pub fn OPERATOR_ORGANIZATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_OPERATOR_ORGANIZATION, None)}
  }
  /// Ephemeris name
  #[inline]
  pub fn EPHEMERIS_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_EPHEMERIS_NAME, None)}
  }
  /// Covariance method
  #[inline]
  pub fn COVARIANCE_METHOD(&self) -> covarianceMethod {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<covarianceMethod>(CDMObject::VT_COVARIANCE_METHOD, Some(covarianceMethod::CALCULATED)).unwrap()}
  }
  /// Reference Frame in which the object position is defined
  #[inline]
  pub fn REFERENCE_FRAME(&self) -> Option<RFM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RFM>>(CDMObject::VT_REFERENCE_FRAME, None)}
  }
  /// Gravity model
  #[inline]
  pub fn GRAVITY_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_GRAVITY_MODEL, None)}
  }
  /// Atmospheric model
  #[inline]
  pub fn ATMOSPHERIC_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_ATMOSPHERIC_MODEL, None)}
  }
  /// N-body perturbations
  #[inline]
  pub fn N_BODY_PERTURBATIONS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_N_BODY_PERTURBATIONS, None)}
  }
  /// Solar radiation pressure
  #[inline]
  pub fn SOLAR_RAD_PRESSURE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CDMObject::VT_SOLAR_RAD_PRESSURE, Some(false)).unwrap()}
  }
  /// Earth tides
  #[inline]
  pub fn EARTH_TIDES(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CDMObject::VT_EARTH_TIDES, Some(false)).unwrap()}
  }
  /// Intrack thrust
  #[inline]
  pub fn INTRACK_THRUST(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CDMObject::VT_INTRACK_THRUST, Some(false)).unwrap()}
  }
  /// Time of last observation start
  #[inline]
  pub fn TIME_LASTOB_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_TIME_LASTOB_START, None)}
  }
  /// Time of last observation end
  #[inline]
  pub fn TIME_LASTOB_END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDMObject::VT_TIME_LASTOB_END, None)}
  }
  /// Recommended observation data span
  #[inline]
  pub fn RECOMMENDED_OD_SPAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_RECOMMENDED_OD_SPAN, Some(0.0)).unwrap()}
  }
  /// Actual observation data span
  #[inline]
  pub fn ACTUAL_OD_SPAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_ACTUAL_OD_SPAN, Some(0.0)).unwrap()}
  }
  /// Number of observations available
  #[inline]
  pub fn OBS_AVAILABLE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CDMObject::VT_OBS_AVAILABLE, Some(0)).unwrap()}
  }
  /// Number of observations used
  #[inline]
  pub fn OBS_USED(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CDMObject::VT_OBS_USED, Some(0)).unwrap()}
  }
  /// Number of tracks available
  #[inline]
  pub fn TRACKS_AVAILABLE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CDMObject::VT_TRACKS_AVAILABLE, Some(0)).unwrap()}
  }
  /// Number of tracks used
  #[inline]
  pub fn TRACKS_USED(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(CDMObject::VT_TRACKS_USED, Some(0)).unwrap()}
  }
  /// Residuals accepted
  #[inline]
  pub fn RESIDUALS_ACCEPTED(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_RESIDUALS_ACCEPTED, Some(0.0)).unwrap()}
  }
  /// Weighted root mean square
  #[inline]
  pub fn WEIGHTED_RMS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_WEIGHTED_RMS, Some(0.0)).unwrap()}
  }
  /// Area of the object
  #[inline]
  pub fn AREA_PC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_AREA_PC, Some(0.0)).unwrap()}
  }
  /// Area of the object drag
  #[inline]
  pub fn AREA_DRG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_AREA_DRG, Some(0.0)).unwrap()}
  }
  /// Area of the object solar radiation pressure
  #[inline]
  pub fn AREA_SRP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_AREA_SRP, Some(0.0)).unwrap()}
  }
  /// Object's area-to-mass ratio
  #[inline]
  pub fn CR_AREA_OVER_MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_CR_AREA_OVER_MASS, Some(0.0)).unwrap()}
  }
  /// Object's thrust acceleration
  #[inline]
  pub fn THRUST_ACCELERATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_THRUST_ACCELERATION, Some(0.0)).unwrap()}
  }
  /// Object's solar flux
  #[inline]
  pub fn SEDR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_SEDR, Some(0.0)).unwrap()}
  }
  /// X-coordinate of the object's position in RTN coordinates
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_X, Some(0.0)).unwrap()}
  }
  /// Y-coordinate of the object's position in RTN
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_Y, Some(0.0)).unwrap()}
  }
  /// Z-coordinate of the object's position in RTN
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_Z, Some(0.0)).unwrap()}
  }
  /// X-coordinate of the object's position in RTN coordinates
  #[inline]
  pub fn X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_X_DOT, Some(0.0)).unwrap()}
  }
  /// Y-coordinate of the object's position in RTN
  #[inline]
  pub fn Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_Y_DOT, Some(0.0)).unwrap()}
  }
  /// Z-coordinate of the object's position in RTN
  #[inline]
  pub fn Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDMObject::VT_Z_DOT, Some(0.0)).unwrap()}
  }
  /// Covariance matrix as flat array (9x9 lower triangular = 45 elements).
  /// Order: [CR_R, CT_R, CT_T, CN_R, CN_T, CN_N, CRDOT_R, CRDOT_T, CRDOT_N, CRDOT_RDOT,
  ///         CTDOT_R, CTDOT_T, CTDOT_N, CTDOT_RDOT, CTDOT_TDOT,
  ///         CNDOT_R, CNDOT_T, CNDOT_N, CNDOT_RDOT, CNDOT_TDOT, CNDOT_NDOT,
  ///         CDRG_R, CDRG_T, CDRG_N, CDRG_RDOT, CDRG_TDOT, CDRG_NDOT, CDRG_DRG,
  ///         CSRP_R, CSRP_T, CSRP_N, CSRP_RDOT, CSRP_TDOT, CSRP_NDOT, CSRP_DRG, CSRP_SRP,
  ///         CTHR_R, CTHR_T, CTHR_N, CTHR_RDOT, CTHR_TDOT, CTHR_NDOT, CTHR_DRG, CTHR_SRP, CTHR_THR]
  #[inline]
  pub fn COVARIANCE(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(CDMObject::VT_COVARIANCE, None)}
  }
}

impl flatbuffers::Verifiable for CDMObject<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMENT", Self::VT_COMMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CAT>>("OBJECT", Self::VT_OBJECT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EPM>>("POC", Self::VT_POC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPERATOR_CONTACT_POSITION", Self::VT_OPERATOR_CONTACT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPERATOR_ORGANIZATION", Self::VT_OPERATOR_ORGANIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPHEMERIS_NAME", Self::VT_EPHEMERIS_NAME, false)?
     .visit_field::<covarianceMethod>("COVARIANCE_METHOD", Self::VT_COVARIANCE_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RFM>>("REFERENCE_FRAME", Self::VT_REFERENCE_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GRAVITY_MODEL", Self::VT_GRAVITY_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ATMOSPHERIC_MODEL", Self::VT_ATMOSPHERIC_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("N_BODY_PERTURBATIONS", Self::VT_N_BODY_PERTURBATIONS, false)?
     .visit_field::<bool>("SOLAR_RAD_PRESSURE", Self::VT_SOLAR_RAD_PRESSURE, false)?
     .visit_field::<bool>("EARTH_TIDES", Self::VT_EARTH_TIDES, false)?
     .visit_field::<bool>("INTRACK_THRUST", Self::VT_INTRACK_THRUST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME_LASTOB_START", Self::VT_TIME_LASTOB_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME_LASTOB_END", Self::VT_TIME_LASTOB_END, false)?
     .visit_field::<f64>("RECOMMENDED_OD_SPAN", Self::VT_RECOMMENDED_OD_SPAN, false)?
     .visit_field::<f64>("ACTUAL_OD_SPAN", Self::VT_ACTUAL_OD_SPAN, false)?
     .visit_field::<u32>("OBS_AVAILABLE", Self::VT_OBS_AVAILABLE, false)?
     .visit_field::<u32>("OBS_USED", Self::VT_OBS_USED, false)?
     .visit_field::<u32>("TRACKS_AVAILABLE", Self::VT_TRACKS_AVAILABLE, false)?
     .visit_field::<u32>("TRACKS_USED", Self::VT_TRACKS_USED, false)?
     .visit_field::<f64>("RESIDUALS_ACCEPTED", Self::VT_RESIDUALS_ACCEPTED, false)?
     .visit_field::<f64>("WEIGHTED_RMS", Self::VT_WEIGHTED_RMS, false)?
     .visit_field::<f64>("AREA_PC", Self::VT_AREA_PC, false)?
     .visit_field::<f64>("AREA_DRG", Self::VT_AREA_DRG, false)?
     .visit_field::<f64>("AREA_SRP", Self::VT_AREA_SRP, false)?
     .visit_field::<f64>("CR_AREA_OVER_MASS", Self::VT_CR_AREA_OVER_MASS, false)?
     .visit_field::<f64>("THRUST_ACCELERATION", Self::VT_THRUST_ACCELERATION, false)?
     .visit_field::<f64>("SEDR", Self::VT_SEDR, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("X_DOT", Self::VT_X_DOT, false)?
     .visit_field::<f64>("Y_DOT", Self::VT_Y_DOT, false)?
     .visit_field::<f64>("Z_DOT", Self::VT_Z_DOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("COVARIANCE", Self::VT_COVARIANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CDMObjectArgs<'a> {
    pub COMMENT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT: Option<flatbuffers::WIPOffset<CAT<'a>>>,
    pub POC: Option<flatbuffers::WIPOffset<EPM<'a>>>,
    pub OPERATOR_CONTACT_POSITION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPERATOR_ORGANIZATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPHEMERIS_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COVARIANCE_METHOD: covarianceMethod,
    pub REFERENCE_FRAME: Option<flatbuffers::WIPOffset<RFM<'a>>>,
    pub GRAVITY_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ATMOSPHERIC_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub N_BODY_PERTURBATIONS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOLAR_RAD_PRESSURE: bool,
    pub EARTH_TIDES: bool,
    pub INTRACK_THRUST: bool,
    pub TIME_LASTOB_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_LASTOB_END: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RECOMMENDED_OD_SPAN: f64,
    pub ACTUAL_OD_SPAN: f64,
    pub OBS_AVAILABLE: u32,
    pub OBS_USED: u32,
    pub TRACKS_AVAILABLE: u32,
    pub TRACKS_USED: u32,
    pub RESIDUALS_ACCEPTED: f64,
    pub WEIGHTED_RMS: f64,
    pub AREA_PC: f64,
    pub AREA_DRG: f64,
    pub AREA_SRP: f64,
    pub CR_AREA_OVER_MASS: f64,
    pub THRUST_ACCELERATION: f64,
    pub SEDR: f64,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub X_DOT: f64,
    pub Y_DOT: f64,
    pub Z_DOT: f64,
    pub COVARIANCE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for CDMObjectArgs<'a> {
  #[inline]
  fn default() -> Self {
    CDMObjectArgs {
      COMMENT: None,
      OBJECT: None,
      POC: None,
      OPERATOR_CONTACT_POSITION: None,
      OPERATOR_ORGANIZATION: None,
      EPHEMERIS_NAME: None,
      COVARIANCE_METHOD: covarianceMethod::CALCULATED,
      REFERENCE_FRAME: None,
      GRAVITY_MODEL: None,
      ATMOSPHERIC_MODEL: None,
      N_BODY_PERTURBATIONS: None,
      SOLAR_RAD_PRESSURE: false,
      EARTH_TIDES: false,
      INTRACK_THRUST: false,
      TIME_LASTOB_START: None,
      TIME_LASTOB_END: None,
      RECOMMENDED_OD_SPAN: 0.0,
      ACTUAL_OD_SPAN: 0.0,
      OBS_AVAILABLE: 0,
      OBS_USED: 0,
      TRACKS_AVAILABLE: 0,
      TRACKS_USED: 0,
      RESIDUALS_ACCEPTED: 0.0,
      WEIGHTED_RMS: 0.0,
      AREA_PC: 0.0,
      AREA_DRG: 0.0,
      AREA_SRP: 0.0,
      CR_AREA_OVER_MASS: 0.0,
      THRUST_ACCELERATION: 0.0,
      SEDR: 0.0,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      COVARIANCE: None,
    }
  }
}

pub struct CDMObjectBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CDMObjectBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMENT(&mut self, COMMENT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_COMMENT, COMMENT);
  }
  #[inline]
  pub fn add_OBJECT(&mut self, OBJECT: flatbuffers::WIPOffset<CAT<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CAT>>(CDMObject::VT_OBJECT, OBJECT);
  }
  #[inline]
  pub fn add_POC(&mut self, POC: flatbuffers::WIPOffset<EPM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EPM>>(CDMObject::VT_POC, POC);
  }
  #[inline]
  pub fn add_OPERATOR_CONTACT_POSITION(&mut self, OPERATOR_CONTACT_POSITION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_OPERATOR_CONTACT_POSITION, OPERATOR_CONTACT_POSITION);
  }
  #[inline]
  pub fn add_OPERATOR_ORGANIZATION(&mut self, OPERATOR_ORGANIZATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_OPERATOR_ORGANIZATION, OPERATOR_ORGANIZATION);
  }
  #[inline]
  pub fn add_EPHEMERIS_NAME(&mut self, EPHEMERIS_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_EPHEMERIS_NAME, EPHEMERIS_NAME);
  }
  #[inline]
  pub fn add_COVARIANCE_METHOD(&mut self, COVARIANCE_METHOD: covarianceMethod) {
    self.fbb_.push_slot::<covarianceMethod>(CDMObject::VT_COVARIANCE_METHOD, COVARIANCE_METHOD, covarianceMethod::CALCULATED);
  }
  #[inline]
  pub fn add_REFERENCE_FRAME(&mut self, REFERENCE_FRAME: flatbuffers::WIPOffset<RFM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RFM>>(CDMObject::VT_REFERENCE_FRAME, REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_GRAVITY_MODEL(&mut self, GRAVITY_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_GRAVITY_MODEL, GRAVITY_MODEL);
  }
  #[inline]
  pub fn add_ATMOSPHERIC_MODEL(&mut self, ATMOSPHERIC_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_ATMOSPHERIC_MODEL, ATMOSPHERIC_MODEL);
  }
  #[inline]
  pub fn add_N_BODY_PERTURBATIONS(&mut self, N_BODY_PERTURBATIONS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_N_BODY_PERTURBATIONS, N_BODY_PERTURBATIONS);
  }
  #[inline]
  pub fn add_SOLAR_RAD_PRESSURE(&mut self, SOLAR_RAD_PRESSURE: bool) {
    self.fbb_.push_slot::<bool>(CDMObject::VT_SOLAR_RAD_PRESSURE, SOLAR_RAD_PRESSURE, false);
  }
  #[inline]
  pub fn add_EARTH_TIDES(&mut self, EARTH_TIDES: bool) {
    self.fbb_.push_slot::<bool>(CDMObject::VT_EARTH_TIDES, EARTH_TIDES, false);
  }
  #[inline]
  pub fn add_INTRACK_THRUST(&mut self, INTRACK_THRUST: bool) {
    self.fbb_.push_slot::<bool>(CDMObject::VT_INTRACK_THRUST, INTRACK_THRUST, false);
  }
  #[inline]
  pub fn add_TIME_LASTOB_START(&mut self, TIME_LASTOB_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_TIME_LASTOB_START, TIME_LASTOB_START);
  }
  #[inline]
  pub fn add_TIME_LASTOB_END(&mut self, TIME_LASTOB_END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_TIME_LASTOB_END, TIME_LASTOB_END);
  }
  #[inline]
  pub fn add_RECOMMENDED_OD_SPAN(&mut self, RECOMMENDED_OD_SPAN: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_RECOMMENDED_OD_SPAN, RECOMMENDED_OD_SPAN, 0.0);
  }
  #[inline]
  pub fn add_ACTUAL_OD_SPAN(&mut self, ACTUAL_OD_SPAN: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_ACTUAL_OD_SPAN, ACTUAL_OD_SPAN, 0.0);
  }
  #[inline]
  pub fn add_OBS_AVAILABLE(&mut self, OBS_AVAILABLE: u32) {
    self.fbb_.push_slot::<u32>(CDMObject::VT_OBS_AVAILABLE, OBS_AVAILABLE, 0);
  }
  #[inline]
  pub fn add_OBS_USED(&mut self, OBS_USED: u32) {
    self.fbb_.push_slot::<u32>(CDMObject::VT_OBS_USED, OBS_USED, 0);
  }
  #[inline]
  pub fn add_TRACKS_AVAILABLE(&mut self, TRACKS_AVAILABLE: u32) {
    self.fbb_.push_slot::<u32>(CDMObject::VT_TRACKS_AVAILABLE, TRACKS_AVAILABLE, 0);
  }
  #[inline]
  pub fn add_TRACKS_USED(&mut self, TRACKS_USED: u32) {
    self.fbb_.push_slot::<u32>(CDMObject::VT_TRACKS_USED, TRACKS_USED, 0);
  }
  #[inline]
  pub fn add_RESIDUALS_ACCEPTED(&mut self, RESIDUALS_ACCEPTED: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_RESIDUALS_ACCEPTED, RESIDUALS_ACCEPTED, 0.0);
  }
  #[inline]
  pub fn add_WEIGHTED_RMS(&mut self, WEIGHTED_RMS: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_WEIGHTED_RMS, WEIGHTED_RMS, 0.0);
  }
  #[inline]
  pub fn add_AREA_PC(&mut self, AREA_PC: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_AREA_PC, AREA_PC, 0.0);
  }
  #[inline]
  pub fn add_AREA_DRG(&mut self, AREA_DRG: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_AREA_DRG, AREA_DRG, 0.0);
  }
  #[inline]
  pub fn add_AREA_SRP(&mut self, AREA_SRP: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_AREA_SRP, AREA_SRP, 0.0);
  }
  #[inline]
  pub fn add_CR_AREA_OVER_MASS(&mut self, CR_AREA_OVER_MASS: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_CR_AREA_OVER_MASS, CR_AREA_OVER_MASS, 0.0);
  }
  #[inline]
  pub fn add_THRUST_ACCELERATION(&mut self, THRUST_ACCELERATION: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_THRUST_ACCELERATION, THRUST_ACCELERATION, 0.0);
  }
  #[inline]
  pub fn add_SEDR(&mut self, SEDR: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_SEDR, SEDR, 0.0);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_X_DOT(&mut self, X_DOT: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_X_DOT, X_DOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DOT(&mut self, Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_Y_DOT, Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DOT(&mut self, Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(CDMObject::VT_Z_DOT, Z_DOT, 0.0);
  }
  #[inline]
  pub fn add_COVARIANCE(&mut self, COVARIANCE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDMObject::VT_COVARIANCE, COVARIANCE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CDMObjectBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CDMObjectBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CDMObject<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CDMObject<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CDMObject");
      ds.field("COMMENT", &self.COMMENT());
      ds.field("OBJECT", &self.OBJECT());
      ds.field("POC", &self.POC());
      ds.field("OPERATOR_CONTACT_POSITION", &self.OPERATOR_CONTACT_POSITION());
      ds.field("OPERATOR_ORGANIZATION", &self.OPERATOR_ORGANIZATION());
      ds.field("EPHEMERIS_NAME", &self.EPHEMERIS_NAME());
      ds.field("COVARIANCE_METHOD", &self.COVARIANCE_METHOD());
      ds.field("REFERENCE_FRAME", &self.REFERENCE_FRAME());
      ds.field("GRAVITY_MODEL", &self.GRAVITY_MODEL());
      ds.field("ATMOSPHERIC_MODEL", &self.ATMOSPHERIC_MODEL());
      ds.field("N_BODY_PERTURBATIONS", &self.N_BODY_PERTURBATIONS());
      ds.field("SOLAR_RAD_PRESSURE", &self.SOLAR_RAD_PRESSURE());
      ds.field("EARTH_TIDES", &self.EARTH_TIDES());
      ds.field("INTRACK_THRUST", &self.INTRACK_THRUST());
      ds.field("TIME_LASTOB_START", &self.TIME_LASTOB_START());
      ds.field("TIME_LASTOB_END", &self.TIME_LASTOB_END());
      ds.field("RECOMMENDED_OD_SPAN", &self.RECOMMENDED_OD_SPAN());
      ds.field("ACTUAL_OD_SPAN", &self.ACTUAL_OD_SPAN());
      ds.field("OBS_AVAILABLE", &self.OBS_AVAILABLE());
      ds.field("OBS_USED", &self.OBS_USED());
      ds.field("TRACKS_AVAILABLE", &self.TRACKS_AVAILABLE());
      ds.field("TRACKS_USED", &self.TRACKS_USED());
      ds.field("RESIDUALS_ACCEPTED", &self.RESIDUALS_ACCEPTED());
      ds.field("WEIGHTED_RMS", &self.WEIGHTED_RMS());
      ds.field("AREA_PC", &self.AREA_PC());
      ds.field("AREA_DRG", &self.AREA_DRG());
      ds.field("AREA_SRP", &self.AREA_SRP());
      ds.field("CR_AREA_OVER_MASS", &self.CR_AREA_OVER_MASS());
      ds.field("THRUST_ACCELERATION", &self.THRUST_ACCELERATION());
      ds.field("SEDR", &self.SEDR());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("X_DOT", &self.X_DOT());
      ds.field("Y_DOT", &self.Y_DOT());
      ds.field("Z_DOT", &self.Z_DOT());
      ds.field("COVARIANCE", &self.COVARIANCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CDMObjectT {
  pub COMMENT: Option<String>,
  pub OBJECT: Option<Box<CATT>>,
  pub POC: Option<Box<EPMT>>,
  pub OPERATOR_CONTACT_POSITION: Option<String>,
  pub OPERATOR_ORGANIZATION: Option<String>,
  pub EPHEMERIS_NAME: Option<String>,
  pub COVARIANCE_METHOD: covarianceMethod,
  pub REFERENCE_FRAME: Option<Box<RFMT>>,
  pub GRAVITY_MODEL: Option<String>,
  pub ATMOSPHERIC_MODEL: Option<String>,
  pub N_BODY_PERTURBATIONS: Option<String>,
  pub SOLAR_RAD_PRESSURE: bool,
  pub EARTH_TIDES: bool,
  pub INTRACK_THRUST: bool,
  pub TIME_LASTOB_START: Option<String>,
  pub TIME_LASTOB_END: Option<String>,
  pub RECOMMENDED_OD_SPAN: f64,
  pub ACTUAL_OD_SPAN: f64,
  pub OBS_AVAILABLE: u32,
  pub OBS_USED: u32,
  pub TRACKS_AVAILABLE: u32,
  pub TRACKS_USED: u32,
  pub RESIDUALS_ACCEPTED: f64,
  pub WEIGHTED_RMS: f64,
  pub AREA_PC: f64,
  pub AREA_DRG: f64,
  pub AREA_SRP: f64,
  pub CR_AREA_OVER_MASS: f64,
  pub THRUST_ACCELERATION: f64,
  pub SEDR: f64,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub X_DOT: f64,
  pub Y_DOT: f64,
  pub Z_DOT: f64,
  pub COVARIANCE: Option<Vec<f64>>,
}
impl Default for CDMObjectT {
  fn default() -> Self {
    Self {
      COMMENT: None,
      OBJECT: None,
      POC: None,
      OPERATOR_CONTACT_POSITION: None,
      OPERATOR_ORGANIZATION: None,
      EPHEMERIS_NAME: None,
      COVARIANCE_METHOD: covarianceMethod::CALCULATED,
      REFERENCE_FRAME: None,
      GRAVITY_MODEL: None,
      ATMOSPHERIC_MODEL: None,
      N_BODY_PERTURBATIONS: None,
      SOLAR_RAD_PRESSURE: false,
      EARTH_TIDES: false,
      INTRACK_THRUST: false,
      TIME_LASTOB_START: None,
      TIME_LASTOB_END: None,
      RECOMMENDED_OD_SPAN: 0.0,
      ACTUAL_OD_SPAN: 0.0,
      OBS_AVAILABLE: 0,
      OBS_USED: 0,
      TRACKS_AVAILABLE: 0,
      TRACKS_USED: 0,
      RESIDUALS_ACCEPTED: 0.0,
      WEIGHTED_RMS: 0.0,
      AREA_PC: 0.0,
      AREA_DRG: 0.0,
      AREA_SRP: 0.0,
      CR_AREA_OVER_MASS: 0.0,
      THRUST_ACCELERATION: 0.0,
      SEDR: 0.0,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      COVARIANCE: None,
    }
  }
}
impl CDMObjectT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CDMObject<'b>> {
    let COMMENT = self.COMMENT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT = self.OBJECT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POC = self.POC.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OPERATOR_CONTACT_POSITION = self.OPERATOR_CONTACT_POSITION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPERATOR_ORGANIZATION = self.OPERATOR_ORGANIZATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPHEMERIS_NAME = self.EPHEMERIS_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COVARIANCE_METHOD = self.COVARIANCE_METHOD;
    let REFERENCE_FRAME = self.REFERENCE_FRAME.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let GRAVITY_MODEL = self.GRAVITY_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ATMOSPHERIC_MODEL = self.ATMOSPHERIC_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let N_BODY_PERTURBATIONS = self.N_BODY_PERTURBATIONS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOLAR_RAD_PRESSURE = self.SOLAR_RAD_PRESSURE;
    let EARTH_TIDES = self.EARTH_TIDES;
    let INTRACK_THRUST = self.INTRACK_THRUST;
    let TIME_LASTOB_START = self.TIME_LASTOB_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_LASTOB_END = self.TIME_LASTOB_END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RECOMMENDED_OD_SPAN = self.RECOMMENDED_OD_SPAN;
    let ACTUAL_OD_SPAN = self.ACTUAL_OD_SPAN;
    let OBS_AVAILABLE = self.OBS_AVAILABLE;
    let OBS_USED = self.OBS_USED;
    let TRACKS_AVAILABLE = self.TRACKS_AVAILABLE;
    let TRACKS_USED = self.TRACKS_USED;
    let RESIDUALS_ACCEPTED = self.RESIDUALS_ACCEPTED;
    let WEIGHTED_RMS = self.WEIGHTED_RMS;
    let AREA_PC = self.AREA_PC;
    let AREA_DRG = self.AREA_DRG;
    let AREA_SRP = self.AREA_SRP;
    let CR_AREA_OVER_MASS = self.CR_AREA_OVER_MASS;
    let THRUST_ACCELERATION = self.THRUST_ACCELERATION;
    let SEDR = self.SEDR;
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let X_DOT = self.X_DOT;
    let Y_DOT = self.Y_DOT;
    let Z_DOT = self.Z_DOT;
    let COVARIANCE = self.COVARIANCE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    CDMObject::create(_fbb, &CDMObjectArgs{
      COMMENT,
      OBJECT,
      POC,
      OPERATOR_CONTACT_POSITION,
      OPERATOR_ORGANIZATION,
      EPHEMERIS_NAME,
      COVARIANCE_METHOD,
      REFERENCE_FRAME,
      GRAVITY_MODEL,
      ATMOSPHERIC_MODEL,
      N_BODY_PERTURBATIONS,
      SOLAR_RAD_PRESSURE,
      EARTH_TIDES,
      INTRACK_THRUST,
      TIME_LASTOB_START,
      TIME_LASTOB_END,
      RECOMMENDED_OD_SPAN,
      ACTUAL_OD_SPAN,
      OBS_AVAILABLE,
      OBS_USED,
      TRACKS_AVAILABLE,
      TRACKS_USED,
      RESIDUALS_ACCEPTED,
      WEIGHTED_RMS,
      AREA_PC,
      AREA_DRG,
      AREA_SRP,
      CR_AREA_OVER_MASS,
      THRUST_ACCELERATION,
      SEDR,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      COVARIANCE,
    })
  }
}
pub enum CDMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Conjunction Data Message
pub struct CDM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CDM<'a> {
  type Inner = CDM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CDM<'a> {
  pub const VT_CCSDS_CDM_VERS: flatbuffers::VOffsetT = 4;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 8;
  pub const VT_MESSAGE_FOR: flatbuffers::VOffsetT = 10;
  pub const VT_MESSAGE_ID: flatbuffers::VOffsetT = 12;
  pub const VT_TCA: flatbuffers::VOffsetT = 14;
  pub const VT_MISS_DISTANCE: flatbuffers::VOffsetT = 16;
  pub const VT_RELATIVE_SPEED: flatbuffers::VOffsetT = 18;
  pub const VT_RELATIVE_POSITION_R: flatbuffers::VOffsetT = 20;
  pub const VT_RELATIVE_POSITION_T: flatbuffers::VOffsetT = 22;
  pub const VT_RELATIVE_POSITION_N: flatbuffers::VOffsetT = 24;
  pub const VT_RELATIVE_VELOCITY_R: flatbuffers::VOffsetT = 26;
  pub const VT_RELATIVE_VELOCITY_T: flatbuffers::VOffsetT = 28;
  pub const VT_RELATIVE_VELOCITY_N: flatbuffers::VOffsetT = 30;
  pub const VT_START_SCREEN_PERIOD: flatbuffers::VOffsetT = 32;
  pub const VT_STOP_SCREEN_PERIOD: flatbuffers::VOffsetT = 34;
  pub const VT_SCREEN_VOLUME_FRAME: flatbuffers::VOffsetT = 36;
  pub const VT_SCREEN_VOLUME_SHAPE: flatbuffers::VOffsetT = 38;
  pub const VT_SCREEN_VOLUME_X: flatbuffers::VOffsetT = 40;
  pub const VT_SCREEN_VOLUME_Y: flatbuffers::VOffsetT = 42;
  pub const VT_SCREEN_VOLUME_Z: flatbuffers::VOffsetT = 44;
  pub const VT_SCREEN_ENTRY_TIME: flatbuffers::VOffsetT = 46;
  pub const VT_SCREEN_EXIT_TIME: flatbuffers::VOffsetT = 48;
  pub const VT_COLLISION_PROBABILITY: flatbuffers::VOffsetT = 50;
  pub const VT_COLLISION_PROBABILITY_METHOD: flatbuffers::VOffsetT = 52;
  pub const VT_OBJECT1: flatbuffers::VOffsetT = 54;
  pub const VT_OBJECT2: flatbuffers::VOffsetT = 56;
  pub const VT_OBJECT1_DATASOURCE: flatbuffers::VOffsetT = 58;
  pub const VT_OBJECT2_DATASOURCE: flatbuffers::VOffsetT = 60;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CDM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CDMArgs<'args>
  ) -> flatbuffers::WIPOffset<CDM<'bldr>> {
    let mut builder = CDMBuilder::new(_fbb);
    builder.add_COLLISION_PROBABILITY(args.COLLISION_PROBABILITY);
    builder.add_SCREEN_VOLUME_Z(args.SCREEN_VOLUME_Z);
    builder.add_SCREEN_VOLUME_Y(args.SCREEN_VOLUME_Y);
    builder.add_SCREEN_VOLUME_X(args.SCREEN_VOLUME_X);
    builder.add_RELATIVE_VELOCITY_N(args.RELATIVE_VELOCITY_N);
    builder.add_RELATIVE_VELOCITY_T(args.RELATIVE_VELOCITY_T);
    builder.add_RELATIVE_VELOCITY_R(args.RELATIVE_VELOCITY_R);
    builder.add_RELATIVE_POSITION_N(args.RELATIVE_POSITION_N);
    builder.add_RELATIVE_POSITION_T(args.RELATIVE_POSITION_T);
    builder.add_RELATIVE_POSITION_R(args.RELATIVE_POSITION_R);
    builder.add_RELATIVE_SPEED(args.RELATIVE_SPEED);
    builder.add_MISS_DISTANCE(args.MISS_DISTANCE);
    builder.add_CCSDS_CDM_VERS(args.CCSDS_CDM_VERS);
    if let Some(x) = args.OBJECT2_DATASOURCE { builder.add_OBJECT2_DATASOURCE(x); }
    if let Some(x) = args.OBJECT1_DATASOURCE { builder.add_OBJECT1_DATASOURCE(x); }
    if let Some(x) = args.OBJECT2 { builder.add_OBJECT2(x); }
    if let Some(x) = args.OBJECT1 { builder.add_OBJECT1(x); }
    if let Some(x) = args.COLLISION_PROBABILITY_METHOD { builder.add_COLLISION_PROBABILITY_METHOD(x); }
    if let Some(x) = args.SCREEN_EXIT_TIME { builder.add_SCREEN_EXIT_TIME(x); }
    if let Some(x) = args.SCREEN_ENTRY_TIME { builder.add_SCREEN_ENTRY_TIME(x); }
    if let Some(x) = args.SCREEN_VOLUME_FRAME { builder.add_SCREEN_VOLUME_FRAME(x); }
    if let Some(x) = args.STOP_SCREEN_PERIOD { builder.add_STOP_SCREEN_PERIOD(x); }
    if let Some(x) = args.START_SCREEN_PERIOD { builder.add_START_SCREEN_PERIOD(x); }
    if let Some(x) = args.TCA { builder.add_TCA(x); }
    if let Some(x) = args.MESSAGE_ID { builder.add_MESSAGE_ID(x); }
    if let Some(x) = args.MESSAGE_FOR { builder.add_MESSAGE_FOR(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    builder.add_SCREEN_VOLUME_SHAPE(args.SCREEN_VOLUME_SHAPE);
    builder.finish()
  }

  pub fn unpack(&self) -> CDMT {
    let CCSDS_CDM_VERS = self.CCSDS_CDM_VERS();
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let MESSAGE_FOR = self.MESSAGE_FOR().map(|x| {
      x.to_string()
    });
    let MESSAGE_ID = self.MESSAGE_ID().map(|x| {
      x.to_string()
    });
    let TCA = self.TCA().map(|x| {
      x.to_string()
    });
    let MISS_DISTANCE = self.MISS_DISTANCE();
    let RELATIVE_SPEED = self.RELATIVE_SPEED();
    let RELATIVE_POSITION_R = self.RELATIVE_POSITION_R();
    let RELATIVE_POSITION_T = self.RELATIVE_POSITION_T();
    let RELATIVE_POSITION_N = self.RELATIVE_POSITION_N();
    let RELATIVE_VELOCITY_R = self.RELATIVE_VELOCITY_R();
    let RELATIVE_VELOCITY_T = self.RELATIVE_VELOCITY_T();
    let RELATIVE_VELOCITY_N = self.RELATIVE_VELOCITY_N();
    let START_SCREEN_PERIOD = self.START_SCREEN_PERIOD().map(|x| {
      x.to_string()
    });
    let STOP_SCREEN_PERIOD = self.STOP_SCREEN_PERIOD().map(|x| {
      x.to_string()
    });
    let SCREEN_VOLUME_FRAME = self.SCREEN_VOLUME_FRAME().map(|x| {
      Box::new(x.unpack())
    });
    let SCREEN_VOLUME_SHAPE = self.SCREEN_VOLUME_SHAPE();
    let SCREEN_VOLUME_X = self.SCREEN_VOLUME_X();
    let SCREEN_VOLUME_Y = self.SCREEN_VOLUME_Y();
    let SCREEN_VOLUME_Z = self.SCREEN_VOLUME_Z();
    let SCREEN_ENTRY_TIME = self.SCREEN_ENTRY_TIME().map(|x| {
      x.to_string()
    });
    let SCREEN_EXIT_TIME = self.SCREEN_EXIT_TIME().map(|x| {
      x.to_string()
    });
    let COLLISION_PROBABILITY = self.COLLISION_PROBABILITY();
    let COLLISION_PROBABILITY_METHOD = self.COLLISION_PROBABILITY_METHOD().map(|x| {
      x.to_string()
    });
    let OBJECT1 = self.OBJECT1().map(|x| {
      Box::new(x.unpack())
    });
    let OBJECT2 = self.OBJECT2().map(|x| {
      Box::new(x.unpack())
    });
    let OBJECT1_DATASOURCE = self.OBJECT1_DATASOURCE().map(|x| {
      Box::new(x.unpack())
    });
    let OBJECT2_DATASOURCE = self.OBJECT2_DATASOURCE().map(|x| {
      Box::new(x.unpack())
    });
    CDMT {
      CCSDS_CDM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      MESSAGE_FOR,
      MESSAGE_ID,
      TCA,
      MISS_DISTANCE,
      RELATIVE_SPEED,
      RELATIVE_POSITION_R,
      RELATIVE_POSITION_T,
      RELATIVE_POSITION_N,
      RELATIVE_VELOCITY_R,
      RELATIVE_VELOCITY_T,
      RELATIVE_VELOCITY_N,
      START_SCREEN_PERIOD,
      STOP_SCREEN_PERIOD,
      SCREEN_VOLUME_FRAME,
      SCREEN_VOLUME_SHAPE,
      SCREEN_VOLUME_X,
      SCREEN_VOLUME_Y,
      SCREEN_VOLUME_Z,
      SCREEN_ENTRY_TIME,
      SCREEN_EXIT_TIME,
      COLLISION_PROBABILITY,
      COLLISION_PROBABILITY_METHOD,
      OBJECT1,
      OBJECT2,
      OBJECT1_DATASOURCE,
      OBJECT2_DATASOURCE,
    }
  }

  /// The version of the CCSDS CDM standard used
  #[inline]
  pub fn CCSDS_CDM_VERS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_CCSDS_CDM_VERS, Some(0.0)).unwrap()}
  }
  /// The date the CDM message was created
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_CREATION_DATE, None)}
  }
  /// The originator of the CDM message
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_ORIGINATOR, None)}
  }
  /// The intended recipient of the CDM message
  #[inline]
  pub fn MESSAGE_FOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_MESSAGE_FOR, None)}
  }
  /// A unique identifier for the CDM message
  #[inline]
  pub fn MESSAGE_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_MESSAGE_ID, None)}
  }
  /// Time of closest approach
  #[inline]
  pub fn TCA(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_TCA, None)}
  }
  /// The miss distance between the two objects
  #[inline]
  pub fn MISS_DISTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_MISS_DISTANCE, Some(0.0)).unwrap()}
  }
  /// The relative speed between the two objects
  #[inline]
  pub fn RELATIVE_SPEED(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_SPEED, Some(0.0)).unwrap()}
  }
  /// The relative position R component
  #[inline]
  pub fn RELATIVE_POSITION_R(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_POSITION_R, Some(0.0)).unwrap()}
  }
  /// The relative position T component
  #[inline]
  pub fn RELATIVE_POSITION_T(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_POSITION_T, Some(0.0)).unwrap()}
  }
  /// The relative position N component
  #[inline]
  pub fn RELATIVE_POSITION_N(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_POSITION_N, Some(0.0)).unwrap()}
  }
  /// The relative velocity R component
  #[inline]
  pub fn RELATIVE_VELOCITY_R(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_VELOCITY_R, Some(0.0)).unwrap()}
  }
  /// The relative velocity T component
  #[inline]
  pub fn RELATIVE_VELOCITY_T(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_VELOCITY_T, Some(0.0)).unwrap()}
  }
  /// The relative velocity N component
  #[inline]
  pub fn RELATIVE_VELOCITY_N(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_RELATIVE_VELOCITY_N, Some(0.0)).unwrap()}
  }
  /// The start time of the screening period
  #[inline]
  pub fn START_SCREEN_PERIOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_START_SCREEN_PERIOD, None)}
  }
  /// The end time of the screening period
  #[inline]
  pub fn STOP_SCREEN_PERIOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_STOP_SCREEN_PERIOD, None)}
  }
  /// The reference frame for the screening volume
  #[inline]
  pub fn SCREEN_VOLUME_FRAME(&self) -> Option<RFM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RFM>>(CDM::VT_SCREEN_VOLUME_FRAME, None)}
  }
  /// The shape of the screening volume
  #[inline]
  pub fn SCREEN_VOLUME_SHAPE(&self) -> screeningVolumeShape {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<screeningVolumeShape>(CDM::VT_SCREEN_VOLUME_SHAPE, Some(screeningVolumeShape::ELLIPSOID)).unwrap()}
  }
  /// The X dimension of the screening volume
  #[inline]
  pub fn SCREEN_VOLUME_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_SCREEN_VOLUME_X, Some(0.0)).unwrap()}
  }
  /// The Y dimension of the screening volume
  #[inline]
  pub fn SCREEN_VOLUME_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_SCREEN_VOLUME_Y, Some(0.0)).unwrap()}
  }
  /// The Z dimension of the screening volume
  #[inline]
  pub fn SCREEN_VOLUME_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_SCREEN_VOLUME_Z, Some(0.0)).unwrap()}
  }
  /// The time the objects entered the screening volume
  #[inline]
  pub fn SCREEN_ENTRY_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_SCREEN_ENTRY_TIME, None)}
  }
  /// The time the objects exited the screening volume
  #[inline]
  pub fn SCREEN_EXIT_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_SCREEN_EXIT_TIME, None)}
  }
  /// The probability of collision between the two objects
  #[inline]
  pub fn COLLISION_PROBABILITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CDM::VT_COLLISION_PROBABILITY, Some(0.0)).unwrap()}
  }
  /// The method used to calculate the collision probability
  #[inline]
  pub fn COLLISION_PROBABILITY_METHOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CDM::VT_COLLISION_PROBABILITY_METHOD, None)}
  }
  /// The first object in the CDM message
  #[inline]
  pub fn OBJECT1(&self) -> Option<CDMObject<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CDMObject>>(CDM::VT_OBJECT1, None)}
  }
  /// The second object in the CDM message
  #[inline]
  pub fn OBJECT2(&self) -> Option<CDMObject<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CDMObject>>(CDM::VT_OBJECT2, None)}
  }
  /// Data Source for the positional information for Object 1
  #[inline]
  pub fn OBJECT1_DATASOURCE(&self) -> Option<PNM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PNM>>(CDM::VT_OBJECT1_DATASOURCE, None)}
  }
  /// Data Source for the positional information for Object 2
  #[inline]
  pub fn OBJECT2_DATASOURCE(&self) -> Option<PNM<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PNM>>(CDM::VT_OBJECT2_DATASOURCE, None)}
  }
}

impl flatbuffers::Verifiable for CDM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("CCSDS_CDM_VERS", Self::VT_CCSDS_CDM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MESSAGE_FOR", Self::VT_MESSAGE_FOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MESSAGE_ID", Self::VT_MESSAGE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TCA", Self::VT_TCA, false)?
     .visit_field::<f64>("MISS_DISTANCE", Self::VT_MISS_DISTANCE, false)?
     .visit_field::<f64>("RELATIVE_SPEED", Self::VT_RELATIVE_SPEED, false)?
     .visit_field::<f64>("RELATIVE_POSITION_R", Self::VT_RELATIVE_POSITION_R, false)?
     .visit_field::<f64>("RELATIVE_POSITION_T", Self::VT_RELATIVE_POSITION_T, false)?
     .visit_field::<f64>("RELATIVE_POSITION_N", Self::VT_RELATIVE_POSITION_N, false)?
     .visit_field::<f64>("RELATIVE_VELOCITY_R", Self::VT_RELATIVE_VELOCITY_R, false)?
     .visit_field::<f64>("RELATIVE_VELOCITY_T", Self::VT_RELATIVE_VELOCITY_T, false)?
     .visit_field::<f64>("RELATIVE_VELOCITY_N", Self::VT_RELATIVE_VELOCITY_N, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_SCREEN_PERIOD", Self::VT_START_SCREEN_PERIOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STOP_SCREEN_PERIOD", Self::VT_STOP_SCREEN_PERIOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RFM>>("SCREEN_VOLUME_FRAME", Self::VT_SCREEN_VOLUME_FRAME, false)?
     .visit_field::<screeningVolumeShape>("SCREEN_VOLUME_SHAPE", Self::VT_SCREEN_VOLUME_SHAPE, false)?
     .visit_field::<f64>("SCREEN_VOLUME_X", Self::VT_SCREEN_VOLUME_X, false)?
     .visit_field::<f64>("SCREEN_VOLUME_Y", Self::VT_SCREEN_VOLUME_Y, false)?
     .visit_field::<f64>("SCREEN_VOLUME_Z", Self::VT_SCREEN_VOLUME_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SCREEN_ENTRY_TIME", Self::VT_SCREEN_ENTRY_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SCREEN_EXIT_TIME", Self::VT_SCREEN_EXIT_TIME, false)?
     .visit_field::<f64>("COLLISION_PROBABILITY", Self::VT_COLLISION_PROBABILITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLISION_PROBABILITY_METHOD", Self::VT_COLLISION_PROBABILITY_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CDMObject>>("OBJECT1", Self::VT_OBJECT1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CDMObject>>("OBJECT2", Self::VT_OBJECT2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PNM>>("OBJECT1_DATASOURCE", Self::VT_OBJECT1_DATASOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PNM>>("OBJECT2_DATASOURCE", Self::VT_OBJECT2_DATASOURCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CDMArgs<'a> {
    pub CCSDS_CDM_VERS: f64,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MESSAGE_FOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MESSAGE_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TCA: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MISS_DISTANCE: f64,
    pub RELATIVE_SPEED: f64,
    pub RELATIVE_POSITION_R: f64,
    pub RELATIVE_POSITION_T: f64,
    pub RELATIVE_POSITION_N: f64,
    pub RELATIVE_VELOCITY_R: f64,
    pub RELATIVE_VELOCITY_T: f64,
    pub RELATIVE_VELOCITY_N: f64,
    pub START_SCREEN_PERIOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STOP_SCREEN_PERIOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCREEN_VOLUME_FRAME: Option<flatbuffers::WIPOffset<RFM<'a>>>,
    pub SCREEN_VOLUME_SHAPE: screeningVolumeShape,
    pub SCREEN_VOLUME_X: f64,
    pub SCREEN_VOLUME_Y: f64,
    pub SCREEN_VOLUME_Z: f64,
    pub SCREEN_ENTRY_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCREEN_EXIT_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLISION_PROBABILITY: f64,
    pub COLLISION_PROBABILITY_METHOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT1: Option<flatbuffers::WIPOffset<CDMObject<'a>>>,
    pub OBJECT2: Option<flatbuffers::WIPOffset<CDMObject<'a>>>,
    pub OBJECT1_DATASOURCE: Option<flatbuffers::WIPOffset<PNM<'a>>>,
    pub OBJECT2_DATASOURCE: Option<flatbuffers::WIPOffset<PNM<'a>>>,
}
impl<'a> Default for CDMArgs<'a> {
  #[inline]
  fn default() -> Self {
    CDMArgs {
      CCSDS_CDM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      MESSAGE_FOR: None,
      MESSAGE_ID: None,
      TCA: None,
      MISS_DISTANCE: 0.0,
      RELATIVE_SPEED: 0.0,
      RELATIVE_POSITION_R: 0.0,
      RELATIVE_POSITION_T: 0.0,
      RELATIVE_POSITION_N: 0.0,
      RELATIVE_VELOCITY_R: 0.0,
      RELATIVE_VELOCITY_T: 0.0,
      RELATIVE_VELOCITY_N: 0.0,
      START_SCREEN_PERIOD: None,
      STOP_SCREEN_PERIOD: None,
      SCREEN_VOLUME_FRAME: None,
      SCREEN_VOLUME_SHAPE: screeningVolumeShape::ELLIPSOID,
      SCREEN_VOLUME_X: 0.0,
      SCREEN_VOLUME_Y: 0.0,
      SCREEN_VOLUME_Z: 0.0,
      SCREEN_ENTRY_TIME: None,
      SCREEN_EXIT_TIME: None,
      COLLISION_PROBABILITY: 0.0,
      COLLISION_PROBABILITY_METHOD: None,
      OBJECT1: None,
      OBJECT2: None,
      OBJECT1_DATASOURCE: None,
      OBJECT2_DATASOURCE: None,
    }
  }
}

pub struct CDMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CDMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CCSDS_CDM_VERS(&mut self, CCSDS_CDM_VERS: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_CCSDS_CDM_VERS, CCSDS_CDM_VERS, 0.0);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_MESSAGE_FOR(&mut self, MESSAGE_FOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_MESSAGE_FOR, MESSAGE_FOR);
  }
  #[inline]
  pub fn add_MESSAGE_ID(&mut self, MESSAGE_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_MESSAGE_ID, MESSAGE_ID);
  }
  #[inline]
  pub fn add_TCA(&mut self, TCA: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_TCA, TCA);
  }
  #[inline]
  pub fn add_MISS_DISTANCE(&mut self, MISS_DISTANCE: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_MISS_DISTANCE, MISS_DISTANCE, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_SPEED(&mut self, RELATIVE_SPEED: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_SPEED, RELATIVE_SPEED, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_POSITION_R(&mut self, RELATIVE_POSITION_R: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_POSITION_R, RELATIVE_POSITION_R, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_POSITION_T(&mut self, RELATIVE_POSITION_T: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_POSITION_T, RELATIVE_POSITION_T, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_POSITION_N(&mut self, RELATIVE_POSITION_N: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_POSITION_N, RELATIVE_POSITION_N, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_VELOCITY_R(&mut self, RELATIVE_VELOCITY_R: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_VELOCITY_R, RELATIVE_VELOCITY_R, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_VELOCITY_T(&mut self, RELATIVE_VELOCITY_T: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_VELOCITY_T, RELATIVE_VELOCITY_T, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_VELOCITY_N(&mut self, RELATIVE_VELOCITY_N: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_RELATIVE_VELOCITY_N, RELATIVE_VELOCITY_N, 0.0);
  }
  #[inline]
  pub fn add_START_SCREEN_PERIOD(&mut self, START_SCREEN_PERIOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_START_SCREEN_PERIOD, START_SCREEN_PERIOD);
  }
  #[inline]
  pub fn add_STOP_SCREEN_PERIOD(&mut self, STOP_SCREEN_PERIOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_STOP_SCREEN_PERIOD, STOP_SCREEN_PERIOD);
  }
  #[inline]
  pub fn add_SCREEN_VOLUME_FRAME(&mut self, SCREEN_VOLUME_FRAME: flatbuffers::WIPOffset<RFM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RFM>>(CDM::VT_SCREEN_VOLUME_FRAME, SCREEN_VOLUME_FRAME);
  }
  #[inline]
  pub fn add_SCREEN_VOLUME_SHAPE(&mut self, SCREEN_VOLUME_SHAPE: screeningVolumeShape) {
    self.fbb_.push_slot::<screeningVolumeShape>(CDM::VT_SCREEN_VOLUME_SHAPE, SCREEN_VOLUME_SHAPE, screeningVolumeShape::ELLIPSOID);
  }
  #[inline]
  pub fn add_SCREEN_VOLUME_X(&mut self, SCREEN_VOLUME_X: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_SCREEN_VOLUME_X, SCREEN_VOLUME_X, 0.0);
  }
  #[inline]
  pub fn add_SCREEN_VOLUME_Y(&mut self, SCREEN_VOLUME_Y: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_SCREEN_VOLUME_Y, SCREEN_VOLUME_Y, 0.0);
  }
  #[inline]
  pub fn add_SCREEN_VOLUME_Z(&mut self, SCREEN_VOLUME_Z: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_SCREEN_VOLUME_Z, SCREEN_VOLUME_Z, 0.0);
  }
  #[inline]
  pub fn add_SCREEN_ENTRY_TIME(&mut self, SCREEN_ENTRY_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_SCREEN_ENTRY_TIME, SCREEN_ENTRY_TIME);
  }
  #[inline]
  pub fn add_SCREEN_EXIT_TIME(&mut self, SCREEN_EXIT_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_SCREEN_EXIT_TIME, SCREEN_EXIT_TIME);
  }
  #[inline]
  pub fn add_COLLISION_PROBABILITY(&mut self, COLLISION_PROBABILITY: f64) {
    self.fbb_.push_slot::<f64>(CDM::VT_COLLISION_PROBABILITY, COLLISION_PROBABILITY, 0.0);
  }
  #[inline]
  pub fn add_COLLISION_PROBABILITY_METHOD(&mut self, COLLISION_PROBABILITY_METHOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CDM::VT_COLLISION_PROBABILITY_METHOD, COLLISION_PROBABILITY_METHOD);
  }
  #[inline]
  pub fn add_OBJECT1(&mut self, OBJECT1: flatbuffers::WIPOffset<CDMObject<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CDMObject>>(CDM::VT_OBJECT1, OBJECT1);
  }
  #[inline]
  pub fn add_OBJECT2(&mut self, OBJECT2: flatbuffers::WIPOffset<CDMObject<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CDMObject>>(CDM::VT_OBJECT2, OBJECT2);
  }
  #[inline]
  pub fn add_OBJECT1_DATASOURCE(&mut self, OBJECT1_DATASOURCE: flatbuffers::WIPOffset<PNM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PNM>>(CDM::VT_OBJECT1_DATASOURCE, OBJECT1_DATASOURCE);
  }
  #[inline]
  pub fn add_OBJECT2_DATASOURCE(&mut self, OBJECT2_DATASOURCE: flatbuffers::WIPOffset<PNM<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PNM>>(CDM::VT_OBJECT2_DATASOURCE, OBJECT2_DATASOURCE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CDMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CDMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CDM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CDM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CDM");
      ds.field("CCSDS_CDM_VERS", &self.CCSDS_CDM_VERS());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("MESSAGE_FOR", &self.MESSAGE_FOR());
      ds.field("MESSAGE_ID", &self.MESSAGE_ID());
      ds.field("TCA", &self.TCA());
      ds.field("MISS_DISTANCE", &self.MISS_DISTANCE());
      ds.field("RELATIVE_SPEED", &self.RELATIVE_SPEED());
      ds.field("RELATIVE_POSITION_R", &self.RELATIVE_POSITION_R());
      ds.field("RELATIVE_POSITION_T", &self.RELATIVE_POSITION_T());
      ds.field("RELATIVE_POSITION_N", &self.RELATIVE_POSITION_N());
      ds.field("RELATIVE_VELOCITY_R", &self.RELATIVE_VELOCITY_R());
      ds.field("RELATIVE_VELOCITY_T", &self.RELATIVE_VELOCITY_T());
      ds.field("RELATIVE_VELOCITY_N", &self.RELATIVE_VELOCITY_N());
      ds.field("START_SCREEN_PERIOD", &self.START_SCREEN_PERIOD());
      ds.field("STOP_SCREEN_PERIOD", &self.STOP_SCREEN_PERIOD());
      ds.field("SCREEN_VOLUME_FRAME", &self.SCREEN_VOLUME_FRAME());
      ds.field("SCREEN_VOLUME_SHAPE", &self.SCREEN_VOLUME_SHAPE());
      ds.field("SCREEN_VOLUME_X", &self.SCREEN_VOLUME_X());
      ds.field("SCREEN_VOLUME_Y", &self.SCREEN_VOLUME_Y());
      ds.field("SCREEN_VOLUME_Z", &self.SCREEN_VOLUME_Z());
      ds.field("SCREEN_ENTRY_TIME", &self.SCREEN_ENTRY_TIME());
      ds.field("SCREEN_EXIT_TIME", &self.SCREEN_EXIT_TIME());
      ds.field("COLLISION_PROBABILITY", &self.COLLISION_PROBABILITY());
      ds.field("COLLISION_PROBABILITY_METHOD", &self.COLLISION_PROBABILITY_METHOD());
      ds.field("OBJECT1", &self.OBJECT1());
      ds.field("OBJECT2", &self.OBJECT2());
      ds.field("OBJECT1_DATASOURCE", &self.OBJECT1_DATASOURCE());
      ds.field("OBJECT2_DATASOURCE", &self.OBJECT2_DATASOURCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CDMT {
  pub CCSDS_CDM_VERS: f64,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub MESSAGE_FOR: Option<String>,
  pub MESSAGE_ID: Option<String>,
  pub TCA: Option<String>,
  pub MISS_DISTANCE: f64,
  pub RELATIVE_SPEED: f64,
  pub RELATIVE_POSITION_R: f64,
  pub RELATIVE_POSITION_T: f64,
  pub RELATIVE_POSITION_N: f64,
  pub RELATIVE_VELOCITY_R: f64,
  pub RELATIVE_VELOCITY_T: f64,
  pub RELATIVE_VELOCITY_N: f64,
  pub START_SCREEN_PERIOD: Option<String>,
  pub STOP_SCREEN_PERIOD: Option<String>,
  pub SCREEN_VOLUME_FRAME: Option<Box<RFMT>>,
  pub SCREEN_VOLUME_SHAPE: screeningVolumeShape,
  pub SCREEN_VOLUME_X: f64,
  pub SCREEN_VOLUME_Y: f64,
  pub SCREEN_VOLUME_Z: f64,
  pub SCREEN_ENTRY_TIME: Option<String>,
  pub SCREEN_EXIT_TIME: Option<String>,
  pub COLLISION_PROBABILITY: f64,
  pub COLLISION_PROBABILITY_METHOD: Option<String>,
  pub OBJECT1: Option<Box<CDMObjectT>>,
  pub OBJECT2: Option<Box<CDMObjectT>>,
  pub OBJECT1_DATASOURCE: Option<Box<PNMT>>,
  pub OBJECT2_DATASOURCE: Option<Box<PNMT>>,
}
impl Default for CDMT {
  fn default() -> Self {
    Self {
      CCSDS_CDM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      MESSAGE_FOR: None,
      MESSAGE_ID: None,
      TCA: None,
      MISS_DISTANCE: 0.0,
      RELATIVE_SPEED: 0.0,
      RELATIVE_POSITION_R: 0.0,
      RELATIVE_POSITION_T: 0.0,
      RELATIVE_POSITION_N: 0.0,
      RELATIVE_VELOCITY_R: 0.0,
      RELATIVE_VELOCITY_T: 0.0,
      RELATIVE_VELOCITY_N: 0.0,
      START_SCREEN_PERIOD: None,
      STOP_SCREEN_PERIOD: None,
      SCREEN_VOLUME_FRAME: None,
      SCREEN_VOLUME_SHAPE: screeningVolumeShape::ELLIPSOID,
      SCREEN_VOLUME_X: 0.0,
      SCREEN_VOLUME_Y: 0.0,
      SCREEN_VOLUME_Z: 0.0,
      SCREEN_ENTRY_TIME: None,
      SCREEN_EXIT_TIME: None,
      COLLISION_PROBABILITY: 0.0,
      COLLISION_PROBABILITY_METHOD: None,
      OBJECT1: None,
      OBJECT2: None,
      OBJECT1_DATASOURCE: None,
      OBJECT2_DATASOURCE: None,
    }
  }
}
impl CDMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CDM<'b>> {
    let CCSDS_CDM_VERS = self.CCSDS_CDM_VERS;
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MESSAGE_FOR = self.MESSAGE_FOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MESSAGE_ID = self.MESSAGE_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TCA = self.TCA.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MISS_DISTANCE = self.MISS_DISTANCE;
    let RELATIVE_SPEED = self.RELATIVE_SPEED;
    let RELATIVE_POSITION_R = self.RELATIVE_POSITION_R;
    let RELATIVE_POSITION_T = self.RELATIVE_POSITION_T;
    let RELATIVE_POSITION_N = self.RELATIVE_POSITION_N;
    let RELATIVE_VELOCITY_R = self.RELATIVE_VELOCITY_R;
    let RELATIVE_VELOCITY_T = self.RELATIVE_VELOCITY_T;
    let RELATIVE_VELOCITY_N = self.RELATIVE_VELOCITY_N;
    let START_SCREEN_PERIOD = self.START_SCREEN_PERIOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STOP_SCREEN_PERIOD = self.STOP_SCREEN_PERIOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCREEN_VOLUME_FRAME = self.SCREEN_VOLUME_FRAME.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SCREEN_VOLUME_SHAPE = self.SCREEN_VOLUME_SHAPE;
    let SCREEN_VOLUME_X = self.SCREEN_VOLUME_X;
    let SCREEN_VOLUME_Y = self.SCREEN_VOLUME_Y;
    let SCREEN_VOLUME_Z = self.SCREEN_VOLUME_Z;
    let SCREEN_ENTRY_TIME = self.SCREEN_ENTRY_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCREEN_EXIT_TIME = self.SCREEN_EXIT_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLISION_PROBABILITY = self.COLLISION_PROBABILITY;
    let COLLISION_PROBABILITY_METHOD = self.COLLISION_PROBABILITY_METHOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT1 = self.OBJECT1.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OBJECT2 = self.OBJECT2.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OBJECT1_DATASOURCE = self.OBJECT1_DATASOURCE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let OBJECT2_DATASOURCE = self.OBJECT2_DATASOURCE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CDM::create(_fbb, &CDMArgs{
      CCSDS_CDM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      MESSAGE_FOR,
      MESSAGE_ID,
      TCA,
      MISS_DISTANCE,
      RELATIVE_SPEED,
      RELATIVE_POSITION_R,
      RELATIVE_POSITION_T,
      RELATIVE_POSITION_N,
      RELATIVE_VELOCITY_R,
      RELATIVE_VELOCITY_T,
      RELATIVE_VELOCITY_N,
      START_SCREEN_PERIOD,
      STOP_SCREEN_PERIOD,
      SCREEN_VOLUME_FRAME,
      SCREEN_VOLUME_SHAPE,
      SCREEN_VOLUME_X,
      SCREEN_VOLUME_Y,
      SCREEN_VOLUME_Z,
      SCREEN_ENTRY_TIME,
      SCREEN_EXIT_TIME,
      COLLISION_PROBABILITY,
      COLLISION_PROBABILITY_METHOD,
      OBJECT1,
      OBJECT2,
      OBJECT1_DATASOURCE,
      OBJECT2_DATASOURCE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `CDM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CDM_unchecked`.
pub fn root_as_CDM(buf: &[u8]) -> Result<CDM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<CDM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `CDM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_CDM_unchecked`.
pub fn size_prefixed_root_as_CDM(buf: &[u8]) -> Result<CDM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<CDM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `CDM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CDM_unchecked`.
pub fn root_as_CDM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CDM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<CDM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `CDM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_CDM_unchecked`.
pub fn size_prefixed_root_as_CDM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<CDM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<CDM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a CDM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `CDM`.
pub unsafe fn root_as_CDM_unchecked(buf: &[u8]) -> CDM {
  flatbuffers::root_unchecked::<CDM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed CDM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `CDM`.
pub unsafe fn size_prefixed_root_as_CDM_unchecked(buf: &[u8]) -> CDM {
  flatbuffers::size_prefixed_root_unchecked::<CDM>(buf)
}
pub const CDM_IDENTIFIER: &str = "$CDM";

#[inline]
pub fn CDM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CDM_IDENTIFIER, false)
}

#[inline]
pub fn CDM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, CDM_IDENTIFIER, true)
}

#[inline]
pub fn finish_CDM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<CDM<'a>>) {
  fbb.finish(root, Some(CDM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_CDM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<CDM<'a>>) {
  fbb.finish_size_prefixed(root, Some(CDM_IDENTIFIER));
}
