// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTEGRATION_METHOD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTEGRATION_METHOD: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTEGRATION_METHOD: [IntegrationMethod; 10] = [
  IntegrationMethod::EULER,
  IntegrationMethod::EULER_IMPROVED,
  IntegrationMethod::RK2,
  IntegrationMethod::RK4,
  IntegrationMethod::RK45,
  IntegrationMethod::RK78,
  IntegrationMethod::VERLET,
  IntegrationMethod::LEAPFROG,
  IntegrationMethod::ADAMS_BASHFORTH,
  IntegrationMethod::GAUSS_JACKSON,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IntegrationMethod(pub i8);
#[allow(non_upper_case_globals)]
impl IntegrationMethod {
  pub const EULER: Self = Self(0);
  pub const EULER_IMPROVED: Self = Self(1);
  pub const RK2: Self = Self(2);
  pub const RK4: Self = Self(3);
  pub const RK45: Self = Self(4);
  pub const RK78: Self = Self(5);
  pub const VERLET: Self = Self(6);
  pub const LEAPFROG: Self = Self(7);
  pub const ADAMS_BASHFORTH: Self = Self(8);
  pub const GAUSS_JACKSON: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EULER,
    Self::EULER_IMPROVED,
    Self::RK2,
    Self::RK4,
    Self::RK45,
    Self::RK78,
    Self::VERLET,
    Self::LEAPFROG,
    Self::ADAMS_BASHFORTH,
    Self::GAUSS_JACKSON,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EULER => Some("EULER"),
      Self::EULER_IMPROVED => Some("EULER_IMPROVED"),
      Self::RK2 => Some("RK2"),
      Self::RK4 => Some("RK4"),
      Self::RK45 => Some("RK45"),
      Self::RK78 => Some("RK78"),
      Self::VERLET => Some("VERLET"),
      Self::LEAPFROG => Some("LEAPFROG"),
      Self::ADAMS_BASHFORTH => Some("ADAMS_BASHFORTH"),
      Self::GAUSS_JACKSON => Some("GAUSS_JACKSON"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IntegrationMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IntegrationMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IntegrationMethod {
    type Output = IntegrationMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IntegrationMethod {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IntegrationMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IntegrationMethod {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLLISION_SHAPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLLISION_SHAPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLLISION_SHAPE: [CollisionShape; 8] = [
  CollisionShape::SPHERE,
  CollisionShape::BOX,
  CollisionShape::CYLINDER,
  CollisionShape::CAPSULE,
  CollisionShape::CONE,
  CollisionShape::CONVEX_HULL,
  CollisionShape::MESH,
  CollisionShape::COMPOUND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CollisionShape(pub i8);
#[allow(non_upper_case_globals)]
impl CollisionShape {
  pub const SPHERE: Self = Self(0);
  pub const BOX: Self = Self(1);
  pub const CYLINDER: Self = Self(2);
  pub const CAPSULE: Self = Self(3);
  pub const CONE: Self = Self(4);
  pub const CONVEX_HULL: Self = Self(5);
  pub const MESH: Self = Self(6);
  pub const COMPOUND: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPHERE,
    Self::BOX,
    Self::CYLINDER,
    Self::CAPSULE,
    Self::CONE,
    Self::CONVEX_HULL,
    Self::MESH,
    Self::COMPOUND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPHERE => Some("SPHERE"),
      Self::BOX => Some("BOX"),
      Self::CYLINDER => Some("CYLINDER"),
      Self::CAPSULE => Some("CAPSULE"),
      Self::CONE => Some("CONE"),
      Self::CONVEX_HULL => Some("CONVEX_HULL"),
      Self::MESH => Some("MESH"),
      Self::COMPOUND => Some("COMPOUND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CollisionShape {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CollisionShape {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CollisionShape {
    type Output = CollisionShape;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CollisionShape {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CollisionShape {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CollisionShape {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MATERIAL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MATERIAL_TYPE: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATERIAL_TYPE: [MaterialType; 11] = [
  MaterialType::STEEL,
  MaterialType::ALUMINUM,
  MaterialType::TITANIUM,
  MaterialType::CERAMIC,
  MaterialType::COMPOSITE,
  MaterialType::CONCRETE,
  MaterialType::WOOD,
  MaterialType::RUBBER,
  MaterialType::WATER,
  MaterialType::AIR,
  MaterialType::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MaterialType(pub i8);
#[allow(non_upper_case_globals)]
impl MaterialType {
  pub const STEEL: Self = Self(0);
  pub const ALUMINUM: Self = Self(1);
  pub const TITANIUM: Self = Self(2);
  pub const CERAMIC: Self = Self(3);
  pub const COMPOSITE: Self = Self(4);
  pub const CONCRETE: Self = Self(5);
  pub const WOOD: Self = Self(6);
  pub const RUBBER: Self = Self(7);
  pub const WATER: Self = Self(8);
  pub const AIR: Self = Self(9);
  pub const CUSTOM: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STEEL,
    Self::ALUMINUM,
    Self::TITANIUM,
    Self::CERAMIC,
    Self::COMPOSITE,
    Self::CONCRETE,
    Self::WOOD,
    Self::RUBBER,
    Self::WATER,
    Self::AIR,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STEEL => Some("STEEL"),
      Self::ALUMINUM => Some("ALUMINUM"),
      Self::TITANIUM => Some("TITANIUM"),
      Self::CERAMIC => Some("CERAMIC"),
      Self::COMPOSITE => Some("COMPOSITE"),
      Self::CONCRETE => Some("CONCRETE"),
      Self::WOOD => Some("WOOD"),
      Self::RUBBER => Some("RUBBER"),
      Self::WATER => Some("WATER"),
      Self::AIR => Some("AIR"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MaterialType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MaterialType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MaterialType {
    type Output = MaterialType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MaterialType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MaterialType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MaterialType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FORCE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FORCE_TYPE: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FORCE_TYPE: [ForceType; 11] = [
  ForceType::GRAVITY,
  ForceType::THRUST,
  ForceType::DRAG,
  ForceType::LIFT,
  ForceType::FRICTION,
  ForceType::SPRING,
  ForceType::DAMPER,
  ForceType::CONTACT,
  ForceType::MAGNETIC,
  ForceType::ELECTRIC,
  ForceType::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ForceType(pub i8);
#[allow(non_upper_case_globals)]
impl ForceType {
  pub const GRAVITY: Self = Self(0);
  pub const THRUST: Self = Self(1);
  pub const DRAG: Self = Self(2);
  pub const LIFT: Self = Self(3);
  pub const FRICTION: Self = Self(4);
  pub const SPRING: Self = Self(5);
  pub const DAMPER: Self = Self(6);
  pub const CONTACT: Self = Self(7);
  pub const MAGNETIC: Self = Self(8);
  pub const ELECTRIC: Self = Self(9);
  pub const CUSTOM: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GRAVITY,
    Self::THRUST,
    Self::DRAG,
    Self::LIFT,
    Self::FRICTION,
    Self::SPRING,
    Self::DAMPER,
    Self::CONTACT,
    Self::MAGNETIC,
    Self::ELECTRIC,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GRAVITY => Some("GRAVITY"),
      Self::THRUST => Some("THRUST"),
      Self::DRAG => Some("DRAG"),
      Self::LIFT => Some("LIFT"),
      Self::FRICTION => Some("FRICTION"),
      Self::SPRING => Some("SPRING"),
      Self::DAMPER => Some("DAMPER"),
      Self::CONTACT => Some("CONTACT"),
      Self::MAGNETIC => Some("MAGNETIC"),
      Self::ELECTRIC => Some("ELECTRIC"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ForceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ForceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ForceType {
    type Output = ForceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ForceType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ForceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ForceType {}
pub enum PHYOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Physics and Rigid Body Dynamics
pub struct PHY<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PHY<'a> {
  type Inner = PHY<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PHY<'a> {
  pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
  pub const VT_SIMULATION_STEP: flatbuffers::VOffsetT = 6;
  pub const VT_RIGID_BODY: flatbuffers::VOffsetT = 8;
  pub const VT_INTEGRATION_CONFIG: flatbuffers::VOffsetT = 10;
  pub const VT_COLLISION_QUERY_A: flatbuffers::VOffsetT = 12;
  pub const VT_COLLISION_QUERY_B: flatbuffers::VOffsetT = 14;
  pub const VT_TRANSFORM_A: flatbuffers::VOffsetT = 16;
  pub const VT_TRANSFORM_B: flatbuffers::VOffsetT = 18;
  pub const VT_POSITION_A: flatbuffers::VOffsetT = 20;
  pub const VT_POSITION_B: flatbuffers::VOffsetT = 22;
  pub const VT_FLUID: flatbuffers::VOffsetT = 24;
  pub const VT_AERO_QUERY: flatbuffers::VOffsetT = 26;
  pub const VT_DRAG_MODEL: flatbuffers::VOffsetT = 28;
  pub const VT_THERMAL_STATE: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PHY { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PHYArgs<'args>
  ) -> flatbuffers::WIPOffset<PHY<'bldr>> {
    let mut builder = PHYBuilder::new(_fbb);
    if let Some(x) = args.THERMAL_STATE { builder.add_THERMAL_STATE(x); }
    if let Some(x) = args.DRAG_MODEL { builder.add_DRAG_MODEL(x); }
    if let Some(x) = args.AERO_QUERY { builder.add_AERO_QUERY(x); }
    if let Some(x) = args.FLUID { builder.add_FLUID(x); }
    if let Some(x) = args.POSITION_B { builder.add_POSITION_B(x); }
    if let Some(x) = args.POSITION_A { builder.add_POSITION_A(x); }
    if let Some(x) = args.TRANSFORM_B { builder.add_TRANSFORM_B(x); }
    if let Some(x) = args.TRANSFORM_A { builder.add_TRANSFORM_A(x); }
    if let Some(x) = args.COLLISION_QUERY_B { builder.add_COLLISION_QUERY_B(x); }
    if let Some(x) = args.COLLISION_QUERY_A { builder.add_COLLISION_QUERY_A(x); }
    if let Some(x) = args.INTEGRATION_CONFIG { builder.add_INTEGRATION_CONFIG(x); }
    if let Some(x) = args.RIGID_BODY { builder.add_RIGID_BODY(x); }
    if let Some(x) = args.SIMULATION_STEP { builder.add_SIMULATION_STEP(x); }
    if let Some(x) = args.COMMAND { builder.add_COMMAND(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PHYT {
    let COMMAND = self.COMMAND().map(|x| {
      x.to_string()
    });
    let SIMULATION_STEP = self.SIMULATION_STEP().map(|x| {
      x.to_string()
    });
    let RIGID_BODY = self.RIGID_BODY().map(|x| {
      x.to_string()
    });
    let INTEGRATION_CONFIG = self.INTEGRATION_CONFIG().map(|x| {
      x.to_string()
    });
    let COLLISION_QUERY_A = self.COLLISION_QUERY_A().map(|x| {
      x.to_string()
    });
    let COLLISION_QUERY_B = self.COLLISION_QUERY_B().map(|x| {
      x.to_string()
    });
    let TRANSFORM_A = self.TRANSFORM_A().map(|x| {
      x.to_string()
    });
    let TRANSFORM_B = self.TRANSFORM_B().map(|x| {
      x.to_string()
    });
    let POSITION_A = self.POSITION_A().map(|x| {
      x.to_string()
    });
    let POSITION_B = self.POSITION_B().map(|x| {
      x.to_string()
    });
    let FLUID = self.FLUID().map(|x| {
      x.to_string()
    });
    let AERO_QUERY = self.AERO_QUERY().map(|x| {
      x.to_string()
    });
    let DRAG_MODEL = self.DRAG_MODEL().map(|x| {
      x.to_string()
    });
    let THERMAL_STATE = self.THERMAL_STATE().map(|x| {
      x.to_string()
    });
    PHYT {
      COMMAND,
      SIMULATION_STEP,
      RIGID_BODY,
      INTEGRATION_CONFIG,
      COLLISION_QUERY_A,
      COLLISION_QUERY_B,
      TRANSFORM_A,
      TRANSFORM_B,
      POSITION_A,
      POSITION_B,
      FLUID,
      AERO_QUERY,
      DRAG_MODEL,
      THERMAL_STATE,
    }
  }

  #[inline]
  pub fn COMMAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_COMMAND, None)}
  }
  #[inline]
  pub fn SIMULATION_STEP(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_SIMULATION_STEP, None)}
  }
  #[inline]
  pub fn RIGID_BODY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_RIGID_BODY, None)}
  }
  #[inline]
  pub fn INTEGRATION_CONFIG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_INTEGRATION_CONFIG, None)}
  }
  #[inline]
  pub fn COLLISION_QUERY_A(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_COLLISION_QUERY_A, None)}
  }
  #[inline]
  pub fn COLLISION_QUERY_B(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_COLLISION_QUERY_B, None)}
  }
  #[inline]
  pub fn TRANSFORM_A(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_TRANSFORM_A, None)}
  }
  #[inline]
  pub fn TRANSFORM_B(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_TRANSFORM_B, None)}
  }
  #[inline]
  pub fn POSITION_A(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_POSITION_A, None)}
  }
  #[inline]
  pub fn POSITION_B(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_POSITION_B, None)}
  }
  #[inline]
  pub fn FLUID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_FLUID, None)}
  }
  #[inline]
  pub fn AERO_QUERY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_AERO_QUERY, None)}
  }
  #[inline]
  pub fn DRAG_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_DRAG_MODEL, None)}
  }
  #[inline]
  pub fn THERMAL_STATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PHY::VT_THERMAL_STATE, None)}
  }
}

impl flatbuffers::Verifiable for PHY<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMAND", Self::VT_COMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SIMULATION_STEP", Self::VT_SIMULATION_STEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RIGID_BODY", Self::VT_RIGID_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INTEGRATION_CONFIG", Self::VT_INTEGRATION_CONFIG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLISION_QUERY_A", Self::VT_COLLISION_QUERY_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLISION_QUERY_B", Self::VT_COLLISION_QUERY_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSFORM_A", Self::VT_TRANSFORM_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSFORM_B", Self::VT_TRANSFORM_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSITION_A", Self::VT_POSITION_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSITION_B", Self::VT_POSITION_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FLUID", Self::VT_FLUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AERO_QUERY", Self::VT_AERO_QUERY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DRAG_MODEL", Self::VT_DRAG_MODEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("THERMAL_STATE", Self::VT_THERMAL_STATE, false)?
     .finish();
    Ok(())
  }
}
pub struct PHYArgs<'a> {
    pub COMMAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIMULATION_STEP: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RIGID_BODY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INTEGRATION_CONFIG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLISION_QUERY_A: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLISION_QUERY_B: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSFORM_A: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSFORM_B: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSITION_A: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSITION_B: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FLUID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AERO_QUERY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DRAG_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub THERMAL_STATE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PHYArgs<'a> {
  #[inline]
  fn default() -> Self {
    PHYArgs {
      COMMAND: None,
      SIMULATION_STEP: None,
      RIGID_BODY: None,
      INTEGRATION_CONFIG: None,
      COLLISION_QUERY_A: None,
      COLLISION_QUERY_B: None,
      TRANSFORM_A: None,
      TRANSFORM_B: None,
      POSITION_A: None,
      POSITION_B: None,
      FLUID: None,
      AERO_QUERY: None,
      DRAG_MODEL: None,
      THERMAL_STATE: None,
    }
  }
}

pub struct PHYBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PHYBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMAND(&mut self, COMMAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_COMMAND, COMMAND);
  }
  #[inline]
  pub fn add_SIMULATION_STEP(&mut self, SIMULATION_STEP: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_SIMULATION_STEP, SIMULATION_STEP);
  }
  #[inline]
  pub fn add_RIGID_BODY(&mut self, RIGID_BODY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_RIGID_BODY, RIGID_BODY);
  }
  #[inline]
  pub fn add_INTEGRATION_CONFIG(&mut self, INTEGRATION_CONFIG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_INTEGRATION_CONFIG, INTEGRATION_CONFIG);
  }
  #[inline]
  pub fn add_COLLISION_QUERY_A(&mut self, COLLISION_QUERY_A: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_COLLISION_QUERY_A, COLLISION_QUERY_A);
  }
  #[inline]
  pub fn add_COLLISION_QUERY_B(&mut self, COLLISION_QUERY_B: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_COLLISION_QUERY_B, COLLISION_QUERY_B);
  }
  #[inline]
  pub fn add_TRANSFORM_A(&mut self, TRANSFORM_A: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_TRANSFORM_A, TRANSFORM_A);
  }
  #[inline]
  pub fn add_TRANSFORM_B(&mut self, TRANSFORM_B: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_TRANSFORM_B, TRANSFORM_B);
  }
  #[inline]
  pub fn add_POSITION_A(&mut self, POSITION_A: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_POSITION_A, POSITION_A);
  }
  #[inline]
  pub fn add_POSITION_B(&mut self, POSITION_B: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_POSITION_B, POSITION_B);
  }
  #[inline]
  pub fn add_FLUID(&mut self, FLUID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_FLUID, FLUID);
  }
  #[inline]
  pub fn add_AERO_QUERY(&mut self, AERO_QUERY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_AERO_QUERY, AERO_QUERY);
  }
  #[inline]
  pub fn add_DRAG_MODEL(&mut self, DRAG_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_DRAG_MODEL, DRAG_MODEL);
  }
  #[inline]
  pub fn add_THERMAL_STATE(&mut self, THERMAL_STATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PHY::VT_THERMAL_STATE, THERMAL_STATE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PHYBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PHYBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PHY<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PHY<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PHY");
      ds.field("COMMAND", &self.COMMAND());
      ds.field("SIMULATION_STEP", &self.SIMULATION_STEP());
      ds.field("RIGID_BODY", &self.RIGID_BODY());
      ds.field("INTEGRATION_CONFIG", &self.INTEGRATION_CONFIG());
      ds.field("COLLISION_QUERY_A", &self.COLLISION_QUERY_A());
      ds.field("COLLISION_QUERY_B", &self.COLLISION_QUERY_B());
      ds.field("TRANSFORM_A", &self.TRANSFORM_A());
      ds.field("TRANSFORM_B", &self.TRANSFORM_B());
      ds.field("POSITION_A", &self.POSITION_A());
      ds.field("POSITION_B", &self.POSITION_B());
      ds.field("FLUID", &self.FLUID());
      ds.field("AERO_QUERY", &self.AERO_QUERY());
      ds.field("DRAG_MODEL", &self.DRAG_MODEL());
      ds.field("THERMAL_STATE", &self.THERMAL_STATE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PHYT {
  pub COMMAND: Option<String>,
  pub SIMULATION_STEP: Option<String>,
  pub RIGID_BODY: Option<String>,
  pub INTEGRATION_CONFIG: Option<String>,
  pub COLLISION_QUERY_A: Option<String>,
  pub COLLISION_QUERY_B: Option<String>,
  pub TRANSFORM_A: Option<String>,
  pub TRANSFORM_B: Option<String>,
  pub POSITION_A: Option<String>,
  pub POSITION_B: Option<String>,
  pub FLUID: Option<String>,
  pub AERO_QUERY: Option<String>,
  pub DRAG_MODEL: Option<String>,
  pub THERMAL_STATE: Option<String>,
}
impl Default for PHYT {
  fn default() -> Self {
    Self {
      COMMAND: None,
      SIMULATION_STEP: None,
      RIGID_BODY: None,
      INTEGRATION_CONFIG: None,
      COLLISION_QUERY_A: None,
      COLLISION_QUERY_B: None,
      TRANSFORM_A: None,
      TRANSFORM_B: None,
      POSITION_A: None,
      POSITION_B: None,
      FLUID: None,
      AERO_QUERY: None,
      DRAG_MODEL: None,
      THERMAL_STATE: None,
    }
  }
}
impl PHYT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PHY<'b>> {
    let COMMAND = self.COMMAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIMULATION_STEP = self.SIMULATION_STEP.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RIGID_BODY = self.RIGID_BODY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INTEGRATION_CONFIG = self.INTEGRATION_CONFIG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLISION_QUERY_A = self.COLLISION_QUERY_A.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLISION_QUERY_B = self.COLLISION_QUERY_B.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSFORM_A = self.TRANSFORM_A.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSFORM_B = self.TRANSFORM_B.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSITION_A = self.POSITION_A.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSITION_B = self.POSITION_B.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FLUID = self.FLUID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AERO_QUERY = self.AERO_QUERY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DRAG_MODEL = self.DRAG_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let THERMAL_STATE = self.THERMAL_STATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    PHY::create(_fbb, &PHYArgs{
      COMMAND,
      SIMULATION_STEP,
      RIGID_BODY,
      INTEGRATION_CONFIG,
      COLLISION_QUERY_A,
      COLLISION_QUERY_B,
      TRANSFORM_A,
      TRANSFORM_B,
      POSITION_A,
      POSITION_B,
      FLUID,
      AERO_QUERY,
      DRAG_MODEL,
      THERMAL_STATE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PHY`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PHY_unchecked`.
pub fn root_as_PHY(buf: &[u8]) -> Result<PHY, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PHY>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PHY` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_PHY_unchecked`.
pub fn size_prefixed_root_as_PHY(buf: &[u8]) -> Result<PHY, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PHY>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PHY` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PHY_unchecked`.
pub fn root_as_PHY_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PHY<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PHY<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PHY` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PHY_unchecked`.
pub fn size_prefixed_root_as_PHY_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PHY<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PHY<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PHY and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PHY`.
pub unsafe fn root_as_PHY_unchecked(buf: &[u8]) -> PHY {
  flatbuffers::root_unchecked::<PHY>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PHY and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PHY`.
pub unsafe fn size_prefixed_root_as_PHY_unchecked(buf: &[u8]) -> PHY {
  flatbuffers::size_prefixed_root_unchecked::<PHY>(buf)
}
pub const PHY_IDENTIFIER: &str = "$PHY";

#[inline]
pub fn PHY_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PHY_IDENTIFIER, false)
}

#[inline]
pub fn PHY_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PHY_IDENTIFIER, true)
}

#[inline]
pub fn finish_PHY_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PHY<'a>>) {
  fbb.finish(root, Some(PHY_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_PHY_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<PHY<'a>>) {
  fbb.finish_size_prefixed(root, Some(PHY_IDENTIFIER));
}
