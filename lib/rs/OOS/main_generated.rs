// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OOSOffset {}
#[derive(Copy, Clone, PartialEq)]

/// On-Orbit Solar Array
pub struct OOS<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OOS<'a> {
  type Inner = OOS<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OOS<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ID_ON_ORBIT: flatbuffers::VOffsetT = 6;
  pub const VT_ID_SOLAR_ARRAY: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_CELL_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_QUANTITY: flatbuffers::VOffsetT = 14;
  pub const VT_AREA: flatbuffers::VOffsetT = 16;
  pub const VT_POWER_BOL: flatbuffers::VOffsetT = 18;
  pub const VT_POWER_EOL: flatbuffers::VOffsetT = 20;
  pub const VT_EFFICIENCY: flatbuffers::VOffsetT = 22;
  pub const VT_DEGRADATION_RATE: flatbuffers::VOffsetT = 24;
  pub const VT_NUM_PANELS: flatbuffers::VOffsetT = 26;
  pub const VT_DEPLOYABLE: flatbuffers::VOffsetT = 28;
  pub const VT_TRACKING: flatbuffers::VOffsetT = 30;
  pub const VT_MASS: flatbuffers::VOffsetT = 32;
  pub const VT_NOTES: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OOS { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OOSArgs<'args>
  ) -> flatbuffers::WIPOffset<OOS<'bldr>> {
    let mut builder = OOSBuilder::new(_fbb);
    builder.add_MASS(args.MASS);
    builder.add_DEGRADATION_RATE(args.DEGRADATION_RATE);
    builder.add_EFFICIENCY(args.EFFICIENCY);
    builder.add_POWER_EOL(args.POWER_EOL);
    builder.add_POWER_BOL(args.POWER_BOL);
    builder.add_AREA(args.AREA);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    builder.add_NUM_PANELS(args.NUM_PANELS);
    builder.add_QUANTITY(args.QUANTITY);
    if let Some(x) = args.CELL_TYPE { builder.add_CELL_TYPE(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID_SOLAR_ARRAY { builder.add_ID_SOLAR_ARRAY(x); }
    if let Some(x) = args.ID_ON_ORBIT { builder.add_ID_ON_ORBIT(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_TRACKING(args.TRACKING);
    builder.add_DEPLOYABLE(args.DEPLOYABLE);
    builder.finish()
  }

  pub fn unpack(&self) -> OOST {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT().map(|x| {
      x.to_string()
    });
    let ID_SOLAR_ARRAY = self.ID_SOLAR_ARRAY().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CELL_TYPE = self.CELL_TYPE().map(|x| {
      x.to_string()
    });
    let QUANTITY = self.QUANTITY();
    let AREA = self.AREA();
    let POWER_BOL = self.POWER_BOL();
    let POWER_EOL = self.POWER_EOL();
    let EFFICIENCY = self.EFFICIENCY();
    let DEGRADATION_RATE = self.DEGRADATION_RATE();
    let NUM_PANELS = self.NUM_PANELS();
    let DEPLOYABLE = self.DEPLOYABLE();
    let TRACKING = self.TRACKING();
    let MASS = self.MASS();
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    OOST {
      ID,
      ID_ON_ORBIT,
      ID_SOLAR_ARRAY,
      NAME,
      CELL_TYPE,
      QUANTITY,
      AREA,
      POWER_BOL,
      POWER_EOL,
      EFFICIENCY,
      DEGRADATION_RATE,
      NUM_PANELS,
      DEPLOYABLE,
      TRACKING,
      MASS,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_ID, None)}
  }
  /// Reference to parent on-orbit object
  #[inline]
  pub fn ID_ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_ID_ON_ORBIT, None)}
  }
  /// Reference to solar array specification
  #[inline]
  pub fn ID_SOLAR_ARRAY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_ID_SOLAR_ARRAY, None)}
  }
  /// Solar array name or designation
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_NAME, None)}
  }
  /// Solar cell type (e.g., SILICON, GAAS, MULTI_JUNCTION, THIN_FILM, PEROVSKITE)
  #[inline]
  pub fn CELL_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_CELL_TYPE, None)}
  }
  /// Number of solar arrays of this type
  #[inline]
  pub fn QUANTITY(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OOS::VT_QUANTITY, Some(0)).unwrap()}
  }
  /// Total array area in square meters
  #[inline]
  pub fn AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_AREA, Some(0.0)).unwrap()}
  }
  /// Beginning of life power output in Watts
  #[inline]
  pub fn POWER_BOL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_POWER_BOL, Some(0.0)).unwrap()}
  }
  /// End of life power output in Watts
  #[inline]
  pub fn POWER_EOL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_POWER_EOL, Some(0.0)).unwrap()}
  }
  /// Conversion efficiency as fraction (0.0-1.0)
  #[inline]
  pub fn EFFICIENCY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_EFFICIENCY, Some(0.0)).unwrap()}
  }
  /// Degradation rate per year as fraction
  #[inline]
  pub fn DEGRADATION_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_DEGRADATION_RATE, Some(0.0)).unwrap()}
  }
  /// Number of panels per array
  #[inline]
  pub fn NUM_PANELS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OOS::VT_NUM_PANELS, Some(0)).unwrap()}
  }
  /// Whether the array is deployable
  #[inline]
  pub fn DEPLOYABLE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OOS::VT_DEPLOYABLE, Some(false)).unwrap()}
  }
  /// Whether the array is articulable/tracking
  #[inline]
  pub fn TRACKING(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OOS::VT_TRACKING, Some(false)).unwrap()}
  }
  /// Array mass in kg
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOS::VT_MASS, Some(0.0)).unwrap()}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOS::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for OOS<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_ON_ORBIT", Self::VT_ID_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SOLAR_ARRAY", Self::VT_ID_SOLAR_ARRAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CELL_TYPE", Self::VT_CELL_TYPE, false)?
     .visit_field::<u32>("QUANTITY", Self::VT_QUANTITY, false)?
     .visit_field::<f64>("AREA", Self::VT_AREA, false)?
     .visit_field::<f64>("POWER_BOL", Self::VT_POWER_BOL, false)?
     .visit_field::<f64>("POWER_EOL", Self::VT_POWER_EOL, false)?
     .visit_field::<f64>("EFFICIENCY", Self::VT_EFFICIENCY, false)?
     .visit_field::<f64>("DEGRADATION_RATE", Self::VT_DEGRADATION_RATE, false)?
     .visit_field::<u32>("NUM_PANELS", Self::VT_NUM_PANELS, false)?
     .visit_field::<bool>("DEPLOYABLE", Self::VT_DEPLOYABLE, false)?
     .visit_field::<bool>("TRACKING", Self::VT_TRACKING, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct OOSArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SOLAR_ARRAY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CELL_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub QUANTITY: u32,
    pub AREA: f64,
    pub POWER_BOL: f64,
    pub POWER_EOL: f64,
    pub EFFICIENCY: f64,
    pub DEGRADATION_RATE: f64,
    pub NUM_PANELS: u32,
    pub DEPLOYABLE: bool,
    pub TRACKING: bool,
    pub MASS: f64,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OOSArgs<'a> {
  #[inline]
  fn default() -> Self {
    OOSArgs {
      ID: None,
      ID_ON_ORBIT: None,
      ID_SOLAR_ARRAY: None,
      NAME: None,
      CELL_TYPE: None,
      QUANTITY: 0,
      AREA: 0.0,
      POWER_BOL: 0.0,
      POWER_EOL: 0.0,
      EFFICIENCY: 0.0,
      DEGRADATION_RATE: 0.0,
      NUM_PANELS: 0,
      DEPLOYABLE: false,
      TRACKING: false,
      MASS: 0.0,
      NOTES: None,
    }
  }
}

pub struct OOSBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OOSBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_ID, ID);
  }
  #[inline]
  pub fn add_ID_ON_ORBIT(&mut self, ID_ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_ID_ON_ORBIT, ID_ON_ORBIT);
  }
  #[inline]
  pub fn add_ID_SOLAR_ARRAY(&mut self, ID_SOLAR_ARRAY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_ID_SOLAR_ARRAY, ID_SOLAR_ARRAY);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CELL_TYPE(&mut self, CELL_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_CELL_TYPE, CELL_TYPE);
  }
  #[inline]
  pub fn add_QUANTITY(&mut self, QUANTITY: u32) {
    self.fbb_.push_slot::<u32>(OOS::VT_QUANTITY, QUANTITY, 0);
  }
  #[inline]
  pub fn add_AREA(&mut self, AREA: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_AREA, AREA, 0.0);
  }
  #[inline]
  pub fn add_POWER_BOL(&mut self, POWER_BOL: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_POWER_BOL, POWER_BOL, 0.0);
  }
  #[inline]
  pub fn add_POWER_EOL(&mut self, POWER_EOL: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_POWER_EOL, POWER_EOL, 0.0);
  }
  #[inline]
  pub fn add_EFFICIENCY(&mut self, EFFICIENCY: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_EFFICIENCY, EFFICIENCY, 0.0);
  }
  #[inline]
  pub fn add_DEGRADATION_RATE(&mut self, DEGRADATION_RATE: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_DEGRADATION_RATE, DEGRADATION_RATE, 0.0);
  }
  #[inline]
  pub fn add_NUM_PANELS(&mut self, NUM_PANELS: u32) {
    self.fbb_.push_slot::<u32>(OOS::VT_NUM_PANELS, NUM_PANELS, 0);
  }
  #[inline]
  pub fn add_DEPLOYABLE(&mut self, DEPLOYABLE: bool) {
    self.fbb_.push_slot::<bool>(OOS::VT_DEPLOYABLE, DEPLOYABLE, false);
  }
  #[inline]
  pub fn add_TRACKING(&mut self, TRACKING: bool) {
    self.fbb_.push_slot::<bool>(OOS::VT_TRACKING, TRACKING, false);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(OOS::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOS::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OOSBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OOSBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OOS<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OOS<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OOS");
      ds.field("ID", &self.ID());
      ds.field("ID_ON_ORBIT", &self.ID_ON_ORBIT());
      ds.field("ID_SOLAR_ARRAY", &self.ID_SOLAR_ARRAY());
      ds.field("NAME", &self.NAME());
      ds.field("CELL_TYPE", &self.CELL_TYPE());
      ds.field("QUANTITY", &self.QUANTITY());
      ds.field("AREA", &self.AREA());
      ds.field("POWER_BOL", &self.POWER_BOL());
      ds.field("POWER_EOL", &self.POWER_EOL());
      ds.field("EFFICIENCY", &self.EFFICIENCY());
      ds.field("DEGRADATION_RATE", &self.DEGRADATION_RATE());
      ds.field("NUM_PANELS", &self.NUM_PANELS());
      ds.field("DEPLOYABLE", &self.DEPLOYABLE());
      ds.field("TRACKING", &self.TRACKING());
      ds.field("MASS", &self.MASS());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OOST {
  pub ID: Option<String>,
  pub ID_ON_ORBIT: Option<String>,
  pub ID_SOLAR_ARRAY: Option<String>,
  pub NAME: Option<String>,
  pub CELL_TYPE: Option<String>,
  pub QUANTITY: u32,
  pub AREA: f64,
  pub POWER_BOL: f64,
  pub POWER_EOL: f64,
  pub EFFICIENCY: f64,
  pub DEGRADATION_RATE: f64,
  pub NUM_PANELS: u32,
  pub DEPLOYABLE: bool,
  pub TRACKING: bool,
  pub MASS: f64,
  pub NOTES: Option<String>,
}
impl Default for OOST {
  fn default() -> Self {
    Self {
      ID: None,
      ID_ON_ORBIT: None,
      ID_SOLAR_ARRAY: None,
      NAME: None,
      CELL_TYPE: None,
      QUANTITY: 0,
      AREA: 0.0,
      POWER_BOL: 0.0,
      POWER_EOL: 0.0,
      EFFICIENCY: 0.0,
      DEGRADATION_RATE: 0.0,
      NUM_PANELS: 0,
      DEPLOYABLE: false,
      TRACKING: false,
      MASS: 0.0,
      NOTES: None,
    }
  }
}
impl OOST {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OOS<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_ON_ORBIT = self.ID_ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SOLAR_ARRAY = self.ID_SOLAR_ARRAY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CELL_TYPE = self.CELL_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let QUANTITY = self.QUANTITY;
    let AREA = self.AREA;
    let POWER_BOL = self.POWER_BOL;
    let POWER_EOL = self.POWER_EOL;
    let EFFICIENCY = self.EFFICIENCY;
    let DEGRADATION_RATE = self.DEGRADATION_RATE;
    let NUM_PANELS = self.NUM_PANELS;
    let DEPLOYABLE = self.DEPLOYABLE;
    let TRACKING = self.TRACKING;
    let MASS = self.MASS;
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OOS::create(_fbb, &OOSArgs{
      ID,
      ID_ON_ORBIT,
      ID_SOLAR_ARRAY,
      NAME,
      CELL_TYPE,
      QUANTITY,
      AREA,
      POWER_BOL,
      POWER_EOL,
      EFFICIENCY,
      DEGRADATION_RATE,
      NUM_PANELS,
      DEPLOYABLE,
      TRACKING,
      MASS,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OOS`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOS_unchecked`.
pub fn root_as_OOS(buf: &[u8]) -> Result<OOS, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OOS>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OOS` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OOS_unchecked`.
pub fn size_prefixed_root_as_OOS(buf: &[u8]) -> Result<OOS, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OOS>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OOS` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOS_unchecked`.
pub fn root_as_OOS_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOS<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OOS<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OOS` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOS_unchecked`.
pub fn size_prefixed_root_as_OOS_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOS<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OOS<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OOS and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OOS`.
pub unsafe fn root_as_OOS_unchecked(buf: &[u8]) -> OOS {
  flatbuffers::root_unchecked::<OOS>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OOS and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OOS`.
pub unsafe fn size_prefixed_root_as_OOS_unchecked(buf: &[u8]) -> OOS {
  flatbuffers::size_prefixed_root_unchecked::<OOS>(buf)
}
pub const OOS_IDENTIFIER: &str = "$OOS";

#[inline]
pub fn OOS_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOS_IDENTIFIER, false)
}

#[inline]
pub fn OOS_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOS_IDENTIFIER, true)
}

#[inline]
pub fn finish_OOS_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OOS<'a>>) {
  fbb.finish(root, Some(OOS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OOS_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OOS<'a>>) {
  fbb.finish_size_prefixed(root, Some(OOS_IDENTIFIER));
}
