// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum LDMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Launch Data Message
pub struct LDM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LDM<'a> {
  type Inner = LDM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LDM<'a> {
  pub const VT_SITE: flatbuffers::VOffsetT = 4;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 6;
  pub const VT_REFERENCES: flatbuffers::VOffsetT = 8;
  pub const VT_AGENCY_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_POINTS_OF_CONTACT: flatbuffers::VOffsetT = 12;
  pub const VT_OPERATIONS_POINTS_OF_CONTACT: flatbuffers::VOffsetT = 14;
  pub const VT_NET: flatbuffers::VOffsetT = 16;
  pub const VT_ROCKET_CONFIGURATION: flatbuffers::VOffsetT = 18;
  pub const VT_MISSION_NAME: flatbuffers::VOffsetT = 20;
  pub const VT_MISSION_DESCRIPTION: flatbuffers::VOffsetT = 22;
  pub const VT_MISSION_TYPE: flatbuffers::VOffsetT = 24;
  pub const VT_ORBIT_TYPE: flatbuffers::VOffsetT = 26;
  pub const VT_WEATHER_CONDITIONS: flatbuffers::VOffsetT = 28;
  pub const VT_LAUNCH_STATUS: flatbuffers::VOffsetT = 30;
  pub const VT_WEBCAST_URL: flatbuffers::VOffsetT = 32;
  pub const VT_MEDIA_LINKS: flatbuffers::VOffsetT = 34;
  pub const VT_EARLIEST_LAUNCH_TIMES: flatbuffers::VOffsetT = 36;
  pub const VT_LATEST_LAUNCH_TIMES: flatbuffers::VOffsetT = 38;
  pub const VT_LCOLA_WINDOW_CLOSURES: flatbuffers::VOffsetT = 40;
  pub const VT_OBJECTS: flatbuffers::VOffsetT = 42;
  pub const VT_TRACKING_REQUIREMENTS: flatbuffers::VOffsetT = 44;
  pub const VT_COLA_SCREEN_DURATION: flatbuffers::VOffsetT = 46;
  pub const VT_PROBABILITY_OF_COLLISION_THRESHOLD: flatbuffers::VOffsetT = 48;
  pub const VT_COLA_RUNS_REQUIRED: flatbuffers::VOffsetT = 50;
  pub const VT_COLA_POINTS_OF_CONTACT: flatbuffers::VOffsetT = 52;
  pub const VT_ORBITAL_PARAMETERS: flatbuffers::VOffsetT = 54;
  pub const VT_BURN_OUT_VECTORS: flatbuffers::VOffsetT = 56;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LDM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LDMArgs<'args>
  ) -> flatbuffers::WIPOffset<LDM<'bldr>> {
    let mut builder = LDMBuilder::new(_fbb);
    if let Some(x) = args.BURN_OUT_VECTORS { builder.add_BURN_OUT_VECTORS(x); }
    if let Some(x) = args.ORBITAL_PARAMETERS { builder.add_ORBITAL_PARAMETERS(x); }
    if let Some(x) = args.COLA_POINTS_OF_CONTACT { builder.add_COLA_POINTS_OF_CONTACT(x); }
    if let Some(x) = args.COLA_RUNS_REQUIRED { builder.add_COLA_RUNS_REQUIRED(x); }
    if let Some(x) = args.PROBABILITY_OF_COLLISION_THRESHOLD { builder.add_PROBABILITY_OF_COLLISION_THRESHOLD(x); }
    if let Some(x) = args.COLA_SCREEN_DURATION { builder.add_COLA_SCREEN_DURATION(x); }
    if let Some(x) = args.TRACKING_REQUIREMENTS { builder.add_TRACKING_REQUIREMENTS(x); }
    if let Some(x) = args.OBJECTS { builder.add_OBJECTS(x); }
    if let Some(x) = args.LCOLA_WINDOW_CLOSURES { builder.add_LCOLA_WINDOW_CLOSURES(x); }
    if let Some(x) = args.LATEST_LAUNCH_TIMES { builder.add_LATEST_LAUNCH_TIMES(x); }
    if let Some(x) = args.EARLIEST_LAUNCH_TIMES { builder.add_EARLIEST_LAUNCH_TIMES(x); }
    if let Some(x) = args.MEDIA_LINKS { builder.add_MEDIA_LINKS(x); }
    if let Some(x) = args.WEBCAST_URL { builder.add_WEBCAST_URL(x); }
    if let Some(x) = args.LAUNCH_STATUS { builder.add_LAUNCH_STATUS(x); }
    if let Some(x) = args.WEATHER_CONDITIONS { builder.add_WEATHER_CONDITIONS(x); }
    if let Some(x) = args.ORBIT_TYPE { builder.add_ORBIT_TYPE(x); }
    if let Some(x) = args.MISSION_TYPE { builder.add_MISSION_TYPE(x); }
    if let Some(x) = args.MISSION_DESCRIPTION { builder.add_MISSION_DESCRIPTION(x); }
    if let Some(x) = args.MISSION_NAME { builder.add_MISSION_NAME(x); }
    if let Some(x) = args.ROCKET_CONFIGURATION { builder.add_ROCKET_CONFIGURATION(x); }
    if let Some(x) = args.NET { builder.add_NET(x); }
    if let Some(x) = args.OPERATIONS_POINTS_OF_CONTACT { builder.add_OPERATIONS_POINTS_OF_CONTACT(x); }
    if let Some(x) = args.POINTS_OF_CONTACT { builder.add_POINTS_OF_CONTACT(x); }
    if let Some(x) = args.AGENCY_NAME { builder.add_AGENCY_NAME(x); }
    if let Some(x) = args.REFERENCES { builder.add_REFERENCES(x); }
    builder.add_AZIMUTH(args.AZIMUTH);
    if let Some(x) = args.SITE { builder.add_SITE(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LDMT {
    let SITE = self.SITE().map(|x| {
      Box::new(x.unpack())
    });
    let AZIMUTH = self.AZIMUTH();
    let REFERENCES = self.REFERENCES().map(|x| {
      x.to_string()
    });
    let AGENCY_NAME = self.AGENCY_NAME().map(|x| {
      x.to_string()
    });
    let POINTS_OF_CONTACT = self.POINTS_OF_CONTACT().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let OPERATIONS_POINTS_OF_CONTACT = self.OPERATIONS_POINTS_OF_CONTACT().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NET = self.NET().map(|x| {
      x.to_string()
    });
    let ROCKET_CONFIGURATION = self.ROCKET_CONFIGURATION().map(|x| {
      Box::new(x.unpack())
    });
    let MISSION_NAME = self.MISSION_NAME().map(|x| {
      x.to_string()
    });
    let MISSION_DESCRIPTION = self.MISSION_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MISSION_TYPE = self.MISSION_TYPE().map(|x| {
      x.to_string()
    });
    let ORBIT_TYPE = self.ORBIT_TYPE().map(|x| {
      x.to_string()
    });
    let WEATHER_CONDITIONS = self.WEATHER_CONDITIONS().map(|x| {
      x.to_string()
    });
    let LAUNCH_STATUS = self.LAUNCH_STATUS().map(|x| {
      x.to_string()
    });
    let WEBCAST_URL = self.WEBCAST_URL().map(|x| {
      x.to_string()
    });
    let MEDIA_LINKS = self.MEDIA_LINKS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let EARLIEST_LAUNCH_TIMES = self.EARLIEST_LAUNCH_TIMES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let LATEST_LAUNCH_TIMES = self.LATEST_LAUNCH_TIMES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let LCOLA_WINDOW_CLOSURES = self.LCOLA_WINDOW_CLOSURES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let OBJECTS = self.OBJECTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let TRACKING_REQUIREMENTS = self.TRACKING_REQUIREMENTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let COLA_SCREEN_DURATION = self.COLA_SCREEN_DURATION().map(|x| {
      x.to_string()
    });
    let PROBABILITY_OF_COLLISION_THRESHOLD = self.PROBABILITY_OF_COLLISION_THRESHOLD().map(|x| {
      x.to_string()
    });
    let COLA_RUNS_REQUIRED = self.COLA_RUNS_REQUIRED().map(|x| {
      x.to_string()
    });
    let COLA_POINTS_OF_CONTACT = self.COLA_POINTS_OF_CONTACT().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ORBITAL_PARAMETERS = self.ORBITAL_PARAMETERS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let BURN_OUT_VECTORS = self.BURN_OUT_VECTORS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    LDMT {
      SITE,
      AZIMUTH,
      REFERENCES,
      AGENCY_NAME,
      POINTS_OF_CONTACT,
      OPERATIONS_POINTS_OF_CONTACT,
      NET,
      ROCKET_CONFIGURATION,
      MISSION_NAME,
      MISSION_DESCRIPTION,
      MISSION_TYPE,
      ORBIT_TYPE,
      WEATHER_CONDITIONS,
      LAUNCH_STATUS,
      WEBCAST_URL,
      MEDIA_LINKS,
      EARLIEST_LAUNCH_TIMES,
      LATEST_LAUNCH_TIMES,
      LCOLA_WINDOW_CLOSURES,
      OBJECTS,
      TRACKING_REQUIREMENTS,
      COLA_SCREEN_DURATION,
      PROBABILITY_OF_COLLISION_THRESHOLD,
      COLA_RUNS_REQUIRED,
      COLA_POINTS_OF_CONTACT,
      ORBITAL_PARAMETERS,
      BURN_OUT_VECTORS,
    }
  }

  /// Launch Site Information
  #[inline]
  pub fn SITE(&self) -> Option<SIT<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SIT>>(LDM::VT_SITE, None)}
  }
  /// Azimuth at Launch (in Degrees)
  #[inline]
  pub fn AZIMUTH(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(LDM::VT_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// References for Launch Data
  #[inline]
  pub fn REFERENCES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_REFERENCES, None)}
  }
  /// Launching Agency Name
  #[inline]
  pub fn AGENCY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_AGENCY_NAME, None)}
  }
  /// Points of Contact for Launch
  #[inline]
  pub fn POINTS_OF_CONTACT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM>>>>(LDM::VT_POINTS_OF_CONTACT, None)}
  }
  /// Operations Points of Contact for Launch
  #[inline]
  pub fn OPERATIONS_POINTS_OF_CONTACT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM>>>>(LDM::VT_OPERATIONS_POINTS_OF_CONTACT, None)}
  }
  /// Net Launch Time (UTC Format)
  #[inline]
  pub fn NET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_NET, None)}
  }
  /// Rocket Configuration Details
  #[inline]
  pub fn ROCKET_CONFIGURATION(&self) -> Option<ROC<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ROC>>(LDM::VT_ROCKET_CONFIGURATION, None)}
  }
  /// Mission Name
  #[inline]
  pub fn MISSION_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_MISSION_NAME, None)}
  }
  /// Description of the Mission
  #[inline]
  pub fn MISSION_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_MISSION_DESCRIPTION, None)}
  }
  /// Type of the Mission (e.g., Test Flight, Satellite Deployment)
  #[inline]
  pub fn MISSION_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_MISSION_TYPE, None)}
  }
  /// Target Orbit Type (e.g., LEO, GEO)
  #[inline]
  pub fn ORBIT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_ORBIT_TYPE, None)}
  }
  /// Weather and Environmental Conditions at Launch
  #[inline]
  pub fn WEATHER_CONDITIONS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_WEATHER_CONDITIONS, None)}
  }
  /// Launch Outcome and Status (e.g., Successful, Failed)
  #[inline]
  pub fn LAUNCH_STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_LAUNCH_STATUS, None)}
  }
  /// Webcast URL for the Launch
  #[inline]
  pub fn WEBCAST_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_WEBCAST_URL, None)}
  }
  /// Media Links Related to the Launch
  #[inline]
  pub fn MEDIA_LINKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_MEDIA_LINKS, None)}
  }
  /// Earliest Possible Launch Times
  #[inline]
  pub fn EARLIEST_LAUNCH_TIMES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_EARLIEST_LAUNCH_TIMES, None)}
  }
  /// Latest Possible Launch Times
  #[inline]
  pub fn LATEST_LAUNCH_TIMES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_LATEST_LAUNCH_TIMES, None)}
  }
  /// Launch Collision Avoidance Information
  #[inline]
  pub fn LCOLA_WINDOW_CLOSURES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_LCOLA_WINDOW_CLOSURES, None)}
  }
  /// Payload Information (Catalog Entities)
  #[inline]
  pub fn OBJECTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CAT<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CAT>>>>(LDM::VT_OBJECTS, None)}
  }
  /// Tracking and Collision Avoidance Requirements
  #[inline]
  pub fn TRACKING_REQUIREMENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_TRACKING_REQUIREMENTS, None)}
  }
  /// Duration of Collision Avoidance Screen (in Seconds)
  #[inline]
  pub fn COLA_SCREEN_DURATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_COLA_SCREEN_DURATION, None)}
  }
  /// Probability of Collision Threshold (Percentage)
  #[inline]
  pub fn PROBABILITY_OF_COLLISION_THRESHOLD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_PROBABILITY_OF_COLLISION_THRESHOLD, None)}
  }
  /// Number of Required Collision Avoidance Runs
  #[inline]
  pub fn COLA_RUNS_REQUIRED(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LDM::VT_COLA_RUNS_REQUIRED, None)}
  }
  /// Points of Contact for Collision Avoidance
  #[inline]
  pub fn COLA_POINTS_OF_CONTACT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM>>>>(LDM::VT_COLA_POINTS_OF_CONTACT, None)}
  }
  /// Orbital Parameters of the Launch
  #[inline]
  pub fn ORBITAL_PARAMETERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LDM::VT_ORBITAL_PARAMETERS, None)}
  }
  /// Burn Out Vectors for the Launch
  #[inline]
  pub fn BURN_OUT_VECTORS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BOV<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BOV>>>>(LDM::VT_BURN_OUT_VECTORS, None)}
  }
}

impl flatbuffers::Verifiable for LDM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<SIT>>("SITE", Self::VT_SITE, false)?
     .visit_field::<f32>("AZIMUTH", Self::VT_AZIMUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REFERENCES", Self::VT_REFERENCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AGENCY_NAME", Self::VT_AGENCY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UPM>>>>("POINTS_OF_CONTACT", Self::VT_POINTS_OF_CONTACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UPM>>>>("OPERATIONS_POINTS_OF_CONTACT", Self::VT_OPERATIONS_POINTS_OF_CONTACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NET", Self::VT_NET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ROC>>("ROCKET_CONFIGURATION", Self::VT_ROCKET_CONFIGURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MISSION_NAME", Self::VT_MISSION_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MISSION_DESCRIPTION", Self::VT_MISSION_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MISSION_TYPE", Self::VT_MISSION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORBIT_TYPE", Self::VT_ORBIT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WEATHER_CONDITIONS", Self::VT_WEATHER_CONDITIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAUNCH_STATUS", Self::VT_LAUNCH_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WEBCAST_URL", Self::VT_WEBCAST_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MEDIA_LINKS", Self::VT_MEDIA_LINKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("EARLIEST_LAUNCH_TIMES", Self::VT_EARLIEST_LAUNCH_TIMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LATEST_LAUNCH_TIMES", Self::VT_LATEST_LAUNCH_TIMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LCOLA_WINDOW_CLOSURES", Self::VT_LCOLA_WINDOW_CLOSURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CAT>>>>("OBJECTS", Self::VT_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TRACKING_REQUIREMENTS", Self::VT_TRACKING_REQUIREMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLA_SCREEN_DURATION", Self::VT_COLA_SCREEN_DURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROBABILITY_OF_COLLISION_THRESHOLD", Self::VT_PROBABILITY_OF_COLLISION_THRESHOLD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLA_RUNS_REQUIRED", Self::VT_COLA_RUNS_REQUIRED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<UPM>>>>("COLA_POINTS_OF_CONTACT", Self::VT_COLA_POINTS_OF_CONTACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ORBITAL_PARAMETERS", Self::VT_ORBITAL_PARAMETERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BOV>>>>("BURN_OUT_VECTORS", Self::VT_BURN_OUT_VECTORS, false)?
     .finish();
    Ok(())
  }
}
pub struct LDMArgs<'a> {
    pub SITE: Option<flatbuffers::WIPOffset<SIT<'a>>>,
    pub AZIMUTH: f32,
    pub REFERENCES: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AGENCY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POINTS_OF_CONTACT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>>>,
    pub OPERATIONS_POINTS_OF_CONTACT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>>>,
    pub NET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ROCKET_CONFIGURATION: Option<flatbuffers::WIPOffset<ROC<'a>>>,
    pub MISSION_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MISSION_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MISSION_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORBIT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WEATHER_CONDITIONS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAUNCH_STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WEBCAST_URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEDIA_LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EARLIEST_LAUNCH_TIMES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub LATEST_LAUNCH_TIMES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub LCOLA_WINDOW_CLOSURES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub OBJECTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CAT<'a>>>>>,
    pub TRACKING_REQUIREMENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub COLA_SCREEN_DURATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROBABILITY_OF_COLLISION_THRESHOLD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLA_RUNS_REQUIRED: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLA_POINTS_OF_CONTACT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UPM<'a>>>>>,
    pub ORBITAL_PARAMETERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub BURN_OUT_VECTORS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BOV<'a>>>>>,
}
impl<'a> Default for LDMArgs<'a> {
  #[inline]
  fn default() -> Self {
    LDMArgs {
      SITE: None,
      AZIMUTH: 0.0,
      REFERENCES: None,
      AGENCY_NAME: None,
      POINTS_OF_CONTACT: None,
      OPERATIONS_POINTS_OF_CONTACT: None,
      NET: None,
      ROCKET_CONFIGURATION: None,
      MISSION_NAME: None,
      MISSION_DESCRIPTION: None,
      MISSION_TYPE: None,
      ORBIT_TYPE: None,
      WEATHER_CONDITIONS: None,
      LAUNCH_STATUS: None,
      WEBCAST_URL: None,
      MEDIA_LINKS: None,
      EARLIEST_LAUNCH_TIMES: None,
      LATEST_LAUNCH_TIMES: None,
      LCOLA_WINDOW_CLOSURES: None,
      OBJECTS: None,
      TRACKING_REQUIREMENTS: None,
      COLA_SCREEN_DURATION: None,
      PROBABILITY_OF_COLLISION_THRESHOLD: None,
      COLA_RUNS_REQUIRED: None,
      COLA_POINTS_OF_CONTACT: None,
      ORBITAL_PARAMETERS: None,
      BURN_OUT_VECTORS: None,
    }
  }
}

pub struct LDMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LDMBuilder<'a, 'b> {
  #[inline]
  pub fn add_SITE(&mut self, SITE: flatbuffers::WIPOffset<SIT<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SIT>>(LDM::VT_SITE, SITE);
  }
  #[inline]
  pub fn add_AZIMUTH(&mut self, AZIMUTH: f32) {
    self.fbb_.push_slot::<f32>(LDM::VT_AZIMUTH, AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_REFERENCES(&mut self, REFERENCES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_REFERENCES, REFERENCES);
  }
  #[inline]
  pub fn add_AGENCY_NAME(&mut self, AGENCY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_AGENCY_NAME, AGENCY_NAME);
  }
  #[inline]
  pub fn add_POINTS_OF_CONTACT(&mut self, POINTS_OF_CONTACT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_POINTS_OF_CONTACT, POINTS_OF_CONTACT);
  }
  #[inline]
  pub fn add_OPERATIONS_POINTS_OF_CONTACT(&mut self, OPERATIONS_POINTS_OF_CONTACT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_OPERATIONS_POINTS_OF_CONTACT, OPERATIONS_POINTS_OF_CONTACT);
  }
  #[inline]
  pub fn add_NET(&mut self, NET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_NET, NET);
  }
  #[inline]
  pub fn add_ROCKET_CONFIGURATION(&mut self, ROCKET_CONFIGURATION: flatbuffers::WIPOffset<ROC<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ROC>>(LDM::VT_ROCKET_CONFIGURATION, ROCKET_CONFIGURATION);
  }
  #[inline]
  pub fn add_MISSION_NAME(&mut self, MISSION_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_MISSION_NAME, MISSION_NAME);
  }
  #[inline]
  pub fn add_MISSION_DESCRIPTION(&mut self, MISSION_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_MISSION_DESCRIPTION, MISSION_DESCRIPTION);
  }
  #[inline]
  pub fn add_MISSION_TYPE(&mut self, MISSION_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_MISSION_TYPE, MISSION_TYPE);
  }
  #[inline]
  pub fn add_ORBIT_TYPE(&mut self, ORBIT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_ORBIT_TYPE, ORBIT_TYPE);
  }
  #[inline]
  pub fn add_WEATHER_CONDITIONS(&mut self, WEATHER_CONDITIONS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_WEATHER_CONDITIONS, WEATHER_CONDITIONS);
  }
  #[inline]
  pub fn add_LAUNCH_STATUS(&mut self, LAUNCH_STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_LAUNCH_STATUS, LAUNCH_STATUS);
  }
  #[inline]
  pub fn add_WEBCAST_URL(&mut self, WEBCAST_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_WEBCAST_URL, WEBCAST_URL);
  }
  #[inline]
  pub fn add_MEDIA_LINKS(&mut self, MEDIA_LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_MEDIA_LINKS, MEDIA_LINKS);
  }
  #[inline]
  pub fn add_EARLIEST_LAUNCH_TIMES(&mut self, EARLIEST_LAUNCH_TIMES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_EARLIEST_LAUNCH_TIMES, EARLIEST_LAUNCH_TIMES);
  }
  #[inline]
  pub fn add_LATEST_LAUNCH_TIMES(&mut self, LATEST_LAUNCH_TIMES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_LATEST_LAUNCH_TIMES, LATEST_LAUNCH_TIMES);
  }
  #[inline]
  pub fn add_LCOLA_WINDOW_CLOSURES(&mut self, LCOLA_WINDOW_CLOSURES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_LCOLA_WINDOW_CLOSURES, LCOLA_WINDOW_CLOSURES);
  }
  #[inline]
  pub fn add_OBJECTS(&mut self, OBJECTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CAT<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_OBJECTS, OBJECTS);
  }
  #[inline]
  pub fn add_TRACKING_REQUIREMENTS(&mut self, TRACKING_REQUIREMENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_TRACKING_REQUIREMENTS, TRACKING_REQUIREMENTS);
  }
  #[inline]
  pub fn add_COLA_SCREEN_DURATION(&mut self, COLA_SCREEN_DURATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_COLA_SCREEN_DURATION, COLA_SCREEN_DURATION);
  }
  #[inline]
  pub fn add_PROBABILITY_OF_COLLISION_THRESHOLD(&mut self, PROBABILITY_OF_COLLISION_THRESHOLD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_PROBABILITY_OF_COLLISION_THRESHOLD, PROBABILITY_OF_COLLISION_THRESHOLD);
  }
  #[inline]
  pub fn add_COLA_RUNS_REQUIRED(&mut self, COLA_RUNS_REQUIRED: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_COLA_RUNS_REQUIRED, COLA_RUNS_REQUIRED);
  }
  #[inline]
  pub fn add_COLA_POINTS_OF_CONTACT(&mut self, COLA_POINTS_OF_CONTACT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<UPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_COLA_POINTS_OF_CONTACT, COLA_POINTS_OF_CONTACT);
  }
  #[inline]
  pub fn add_ORBITAL_PARAMETERS(&mut self, ORBITAL_PARAMETERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_ORBITAL_PARAMETERS, ORBITAL_PARAMETERS);
  }
  #[inline]
  pub fn add_BURN_OUT_VECTORS(&mut self, BURN_OUT_VECTORS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BOV<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDM::VT_BURN_OUT_VECTORS, BURN_OUT_VECTORS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LDMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LDMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LDM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LDM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LDM");
      ds.field("SITE", &self.SITE());
      ds.field("AZIMUTH", &self.AZIMUTH());
      ds.field("REFERENCES", &self.REFERENCES());
      ds.field("AGENCY_NAME", &self.AGENCY_NAME());
      ds.field("POINTS_OF_CONTACT", &self.POINTS_OF_CONTACT());
      ds.field("OPERATIONS_POINTS_OF_CONTACT", &self.OPERATIONS_POINTS_OF_CONTACT());
      ds.field("NET", &self.NET());
      ds.field("ROCKET_CONFIGURATION", &self.ROCKET_CONFIGURATION());
      ds.field("MISSION_NAME", &self.MISSION_NAME());
      ds.field("MISSION_DESCRIPTION", &self.MISSION_DESCRIPTION());
      ds.field("MISSION_TYPE", &self.MISSION_TYPE());
      ds.field("ORBIT_TYPE", &self.ORBIT_TYPE());
      ds.field("WEATHER_CONDITIONS", &self.WEATHER_CONDITIONS());
      ds.field("LAUNCH_STATUS", &self.LAUNCH_STATUS());
      ds.field("WEBCAST_URL", &self.WEBCAST_URL());
      ds.field("MEDIA_LINKS", &self.MEDIA_LINKS());
      ds.field("EARLIEST_LAUNCH_TIMES", &self.EARLIEST_LAUNCH_TIMES());
      ds.field("LATEST_LAUNCH_TIMES", &self.LATEST_LAUNCH_TIMES());
      ds.field("LCOLA_WINDOW_CLOSURES", &self.LCOLA_WINDOW_CLOSURES());
      ds.field("OBJECTS", &self.OBJECTS());
      ds.field("TRACKING_REQUIREMENTS", &self.TRACKING_REQUIREMENTS());
      ds.field("COLA_SCREEN_DURATION", &self.COLA_SCREEN_DURATION());
      ds.field("PROBABILITY_OF_COLLISION_THRESHOLD", &self.PROBABILITY_OF_COLLISION_THRESHOLD());
      ds.field("COLA_RUNS_REQUIRED", &self.COLA_RUNS_REQUIRED());
      ds.field("COLA_POINTS_OF_CONTACT", &self.COLA_POINTS_OF_CONTACT());
      ds.field("ORBITAL_PARAMETERS", &self.ORBITAL_PARAMETERS());
      ds.field("BURN_OUT_VECTORS", &self.BURN_OUT_VECTORS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LDMT {
  pub SITE: Option<Box<SITT>>,
  pub AZIMUTH: f32,
  pub REFERENCES: Option<String>,
  pub AGENCY_NAME: Option<String>,
  pub POINTS_OF_CONTACT: Option<Vec<UPMT>>,
  pub OPERATIONS_POINTS_OF_CONTACT: Option<Vec<UPMT>>,
  pub NET: Option<String>,
  pub ROCKET_CONFIGURATION: Option<Box<ROCT>>,
  pub MISSION_NAME: Option<String>,
  pub MISSION_DESCRIPTION: Option<String>,
  pub MISSION_TYPE: Option<String>,
  pub ORBIT_TYPE: Option<String>,
  pub WEATHER_CONDITIONS: Option<String>,
  pub LAUNCH_STATUS: Option<String>,
  pub WEBCAST_URL: Option<String>,
  pub MEDIA_LINKS: Option<Vec<String>>,
  pub EARLIEST_LAUNCH_TIMES: Option<Vec<String>>,
  pub LATEST_LAUNCH_TIMES: Option<Vec<String>>,
  pub LCOLA_WINDOW_CLOSURES: Option<Vec<String>>,
  pub OBJECTS: Option<Vec<CATT>>,
  pub TRACKING_REQUIREMENTS: Option<Vec<String>>,
  pub COLA_SCREEN_DURATION: Option<String>,
  pub PROBABILITY_OF_COLLISION_THRESHOLD: Option<String>,
  pub COLA_RUNS_REQUIRED: Option<String>,
  pub COLA_POINTS_OF_CONTACT: Option<Vec<UPMT>>,
  pub ORBITAL_PARAMETERS: Option<Vec<String>>,
  pub BURN_OUT_VECTORS: Option<Vec<BOVT>>,
}
impl Default for LDMT {
  fn default() -> Self {
    Self {
      SITE: None,
      AZIMUTH: 0.0,
      REFERENCES: None,
      AGENCY_NAME: None,
      POINTS_OF_CONTACT: None,
      OPERATIONS_POINTS_OF_CONTACT: None,
      NET: None,
      ROCKET_CONFIGURATION: None,
      MISSION_NAME: None,
      MISSION_DESCRIPTION: None,
      MISSION_TYPE: None,
      ORBIT_TYPE: None,
      WEATHER_CONDITIONS: None,
      LAUNCH_STATUS: None,
      WEBCAST_URL: None,
      MEDIA_LINKS: None,
      EARLIEST_LAUNCH_TIMES: None,
      LATEST_LAUNCH_TIMES: None,
      LCOLA_WINDOW_CLOSURES: None,
      OBJECTS: None,
      TRACKING_REQUIREMENTS: None,
      COLA_SCREEN_DURATION: None,
      PROBABILITY_OF_COLLISION_THRESHOLD: None,
      COLA_RUNS_REQUIRED: None,
      COLA_POINTS_OF_CONTACT: None,
      ORBITAL_PARAMETERS: None,
      BURN_OUT_VECTORS: None,
    }
  }
}
impl LDMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LDM<'b>> {
    let SITE = self.SITE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let AZIMUTH = self.AZIMUTH;
    let REFERENCES = self.REFERENCES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AGENCY_NAME = self.AGENCY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POINTS_OF_CONTACT = self.POINTS_OF_CONTACT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let OPERATIONS_POINTS_OF_CONTACT = self.OPERATIONS_POINTS_OF_CONTACT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NET = self.NET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ROCKET_CONFIGURATION = self.ROCKET_CONFIGURATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let MISSION_NAME = self.MISSION_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MISSION_DESCRIPTION = self.MISSION_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MISSION_TYPE = self.MISSION_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORBIT_TYPE = self.ORBIT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WEATHER_CONDITIONS = self.WEATHER_CONDITIONS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAUNCH_STATUS = self.LAUNCH_STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WEBCAST_URL = self.WEBCAST_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEDIA_LINKS = self.MEDIA_LINKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EARLIEST_LAUNCH_TIMES = self.EARLIEST_LAUNCH_TIMES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let LATEST_LAUNCH_TIMES = self.LATEST_LAUNCH_TIMES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let LCOLA_WINDOW_CLOSURES = self.LCOLA_WINDOW_CLOSURES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let OBJECTS = self.OBJECTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let TRACKING_REQUIREMENTS = self.TRACKING_REQUIREMENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let COLA_SCREEN_DURATION = self.COLA_SCREEN_DURATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROBABILITY_OF_COLLISION_THRESHOLD = self.PROBABILITY_OF_COLLISION_THRESHOLD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLA_RUNS_REQUIRED = self.COLA_RUNS_REQUIRED.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLA_POINTS_OF_CONTACT = self.COLA_POINTS_OF_CONTACT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ORBITAL_PARAMETERS = self.ORBITAL_PARAMETERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let BURN_OUT_VECTORS = self.BURN_OUT_VECTORS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    LDM::create(_fbb, &LDMArgs{
      SITE,
      AZIMUTH,
      REFERENCES,
      AGENCY_NAME,
      POINTS_OF_CONTACT,
      OPERATIONS_POINTS_OF_CONTACT,
      NET,
      ROCKET_CONFIGURATION,
      MISSION_NAME,
      MISSION_DESCRIPTION,
      MISSION_TYPE,
      ORBIT_TYPE,
      WEATHER_CONDITIONS,
      LAUNCH_STATUS,
      WEBCAST_URL,
      MEDIA_LINKS,
      EARLIEST_LAUNCH_TIMES,
      LATEST_LAUNCH_TIMES,
      LCOLA_WINDOW_CLOSURES,
      OBJECTS,
      TRACKING_REQUIREMENTS,
      COLA_SCREEN_DURATION,
      PROBABILITY_OF_COLLISION_THRESHOLD,
      COLA_RUNS_REQUIRED,
      COLA_POINTS_OF_CONTACT,
      ORBITAL_PARAMETERS,
      BURN_OUT_VECTORS,
    })
  }
}
pub enum LDMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LDMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LDMCOLLECTION<'a> {
  type Inner = LDMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LDMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LDMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LDMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<LDMCOLLECTION<'bldr>> {
    let mut builder = LDMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LDMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    LDMCOLLECTIONT {
      RECORDS,
    }
  }

  /// Collection of LDM Records
  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LDM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LDM>>>>(LDMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for LDMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LDM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct LDMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LDM<'a>>>>>,
}
impl<'a> Default for LDMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    LDMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct LDMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LDMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LDM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LDMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LDMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LDMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LDMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LDMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LDMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LDMCOLLECTIONT {
  pub RECORDS: Option<Vec<LDMT>>,
}
impl Default for LDMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl LDMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LDMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    LDMCOLLECTION::create(_fbb, &LDMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LDM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LDM_unchecked`.
pub fn root_as_LDM(buf: &[u8]) -> Result<LDM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LDM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LDM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_LDM_unchecked`.
pub fn size_prefixed_root_as_LDM(buf: &[u8]) -> Result<LDM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LDM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LDM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LDM_unchecked`.
pub fn root_as_LDM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LDM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LDM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LDM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LDM_unchecked`.
pub fn size_prefixed_root_as_LDM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LDM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LDM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LDM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LDM`.
pub unsafe fn root_as_LDM_unchecked(buf: &[u8]) -> LDM {
  flatbuffers::root_unchecked::<LDM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LDM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LDM`.
pub unsafe fn size_prefixed_root_as_LDM_unchecked(buf: &[u8]) -> LDM {
  flatbuffers::size_prefixed_root_unchecked::<LDM>(buf)
}
pub const LDM_IDENTIFIER: &str = "$LDM";

#[inline]
pub fn LDM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LDM_IDENTIFIER, false)
}

#[inline]
pub fn LDM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LDM_IDENTIFIER, true)
}

#[inline]
pub fn finish_LDM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<LDM<'a>>) {
  fbb.finish(root, Some(LDM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_LDM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<LDM<'a>>) {
  fbb.finish_size_prefixed(root, Some(LDM_IDENTIFIER));
}
