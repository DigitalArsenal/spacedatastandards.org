// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SENSOR_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SENSOR_STATUS: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SENSOR_STATUS: [sensorStatus; 7] = [
  sensorStatus::OPERATIONAL,
  sensorStatus::DEGRADED,
  sensorStatus::MAINTENANCE,
  sensorStatus::OFFLINE,
  sensorStatus::CALIBRATING,
  sensorStatus::TESTING,
  sensorStatus::DECOMMISSIONED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct sensorStatus(pub i8);
#[allow(non_upper_case_globals)]
impl sensorStatus {
  pub const OPERATIONAL: Self = Self(0);
  pub const DEGRADED: Self = Self(1);
  pub const MAINTENANCE: Self = Self(2);
  pub const OFFLINE: Self = Self(3);
  pub const CALIBRATING: Self = Self(4);
  pub const TESTING: Self = Self(5);
  pub const DECOMMISSIONED: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPERATIONAL,
    Self::DEGRADED,
    Self::MAINTENANCE,
    Self::OFFLINE,
    Self::CALIBRATING,
    Self::TESTING,
    Self::DECOMMISSIONED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPERATIONAL => Some("OPERATIONAL"),
      Self::DEGRADED => Some("DEGRADED"),
      Self::MAINTENANCE => Some("MAINTENANCE"),
      Self::OFFLINE => Some("OFFLINE"),
      Self::CALIBRATING => Some("CALIBRATING"),
      Self::TESTING => Some("TESTING"),
      Self::DECOMMISSIONED => Some("DECOMMISSIONED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for sensorStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for sensorStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for sensorStatus {
    type Output = sensorStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for sensorStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for sensorStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for sensorStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MAINTENANCE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MAINTENANCE_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MAINTENANCE_TYPE: [maintenanceType; 7] = [
  maintenanceType::SCHEDULED,
  maintenanceType::UNSCHEDULED,
  maintenanceType::CORRECTIVE,
  maintenanceType::PREVENTIVE,
  maintenanceType::CALIBRATION,
  maintenanceType::UPGRADE,
  maintenanceType::INSPECTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct maintenanceType(pub i8);
#[allow(non_upper_case_globals)]
impl maintenanceType {
  pub const SCHEDULED: Self = Self(0);
  pub const UNSCHEDULED: Self = Self(1);
  pub const CORRECTIVE: Self = Self(2);
  pub const PREVENTIVE: Self = Self(3);
  pub const CALIBRATION: Self = Self(4);
  pub const UPGRADE: Self = Self(5);
  pub const INSPECTION: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCHEDULED,
    Self::UNSCHEDULED,
    Self::CORRECTIVE,
    Self::PREVENTIVE,
    Self::CALIBRATION,
    Self::UPGRADE,
    Self::INSPECTION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SCHEDULED => Some("SCHEDULED"),
      Self::UNSCHEDULED => Some("UNSCHEDULED"),
      Self::CORRECTIVE => Some("CORRECTIVE"),
      Self::PREVENTIVE => Some("PREVENTIVE"),
      Self::CALIBRATION => Some("CALIBRATION"),
      Self::UPGRADE => Some("UPGRADE"),
      Self::INSPECTION => Some("INSPECTION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for maintenanceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for maintenanceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for maintenanceType {
    type Output = maintenanceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for maintenanceType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for maintenanceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for maintenanceType {}
pub enum sensorMaintenanceEventOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sensor Maintenance Event
pub struct sensorMaintenanceEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for sensorMaintenanceEvent<'a> {
  type Inner = sensorMaintenanceEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> sensorMaintenanceEvent<'a> {
  pub const VT_START_TIME: flatbuffers::VOffsetT = 4;
  pub const VT_END_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_COMPONENTS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    sensorMaintenanceEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args sensorMaintenanceEventArgs<'args>
  ) -> flatbuffers::WIPOffset<sensorMaintenanceEvent<'bldr>> {
    let mut builder = sensorMaintenanceEventBuilder::new(_fbb);
    if let Some(x) = args.COMPONENTS { builder.add_COMPONENTS(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.END_TIME { builder.add_END_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> sensorMaintenanceEventT {
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let END_TIME = self.END_TIME().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE();
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let COMPONENTS = self.COMPONENTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    sensorMaintenanceEventT {
      START_TIME,
      END_TIME,
      TYPE,
      DESCRIPTION,
      COMPONENTS,
    }
  }

  /// Maintenance start time (ISO 8601)
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorMaintenanceEvent::VT_START_TIME, None)}
  }
  /// Maintenance end time (ISO 8601)
  #[inline]
  pub fn END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorMaintenanceEvent::VT_END_TIME, None)}
  }
  /// Type of maintenance
  #[inline]
  pub fn TYPE(&self) -> maintenanceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<maintenanceType>(sensorMaintenanceEvent::VT_TYPE, Some(maintenanceType::SCHEDULED)).unwrap()}
  }
  /// Description of maintenance performed
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorMaintenanceEvent::VT_DESCRIPTION, None)}
  }
  /// Components affected
  #[inline]
  pub fn COMPONENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(sensorMaintenanceEvent::VT_COMPONENTS, None)}
  }
}

impl flatbuffers::Verifiable for sensorMaintenanceEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END_TIME", Self::VT_END_TIME, false)?
     .visit_field::<maintenanceType>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("COMPONENTS", Self::VT_COMPONENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct sensorMaintenanceEventArgs<'a> {
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: maintenanceType,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COMPONENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for sensorMaintenanceEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    sensorMaintenanceEventArgs {
      START_TIME: None,
      END_TIME: None,
      TYPE: maintenanceType::SCHEDULED,
      DESCRIPTION: None,
      COMPONENTS: None,
    }
  }
}

pub struct sensorMaintenanceEventBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> sensorMaintenanceEventBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorMaintenanceEvent::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_END_TIME(&mut self, END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorMaintenanceEvent::VT_END_TIME, END_TIME);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: maintenanceType) {
    self.fbb_.push_slot::<maintenanceType>(sensorMaintenanceEvent::VT_TYPE, TYPE, maintenanceType::SCHEDULED);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorMaintenanceEvent::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_COMPONENTS(&mut self, COMPONENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorMaintenanceEvent::VT_COMPONENTS, COMPONENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> sensorMaintenanceEventBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    sensorMaintenanceEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<sensorMaintenanceEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for sensorMaintenanceEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("sensorMaintenanceEvent");
      ds.field("START_TIME", &self.START_TIME());
      ds.field("END_TIME", &self.END_TIME());
      ds.field("TYPE", &self.TYPE());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("COMPONENTS", &self.COMPONENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct sensorMaintenanceEventT {
  pub START_TIME: Option<String>,
  pub END_TIME: Option<String>,
  pub TYPE: maintenanceType,
  pub DESCRIPTION: Option<String>,
  pub COMPONENTS: Option<Vec<String>>,
}
impl Default for sensorMaintenanceEventT {
  fn default() -> Self {
    Self {
      START_TIME: None,
      END_TIME: None,
      TYPE: maintenanceType::SCHEDULED,
      DESCRIPTION: None,
      COMPONENTS: None,
    }
  }
}
impl sensorMaintenanceEventT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<sensorMaintenanceEvent<'b>> {
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END_TIME = self.END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE;
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COMPONENTS = self.COMPONENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    sensorMaintenanceEvent::create(_fbb, &sensorMaintenanceEventArgs{
      START_TIME,
      END_TIME,
      TYPE,
      DESCRIPTION,
      COMPONENTS,
    })
  }
}
pub enum sensorPlanOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sensor Tasking Plan
pub struct sensorPlan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for sensorPlan<'a> {
  type Inner = sensorPlan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> sensorPlan<'a> {
  pub const VT_START_TIME: flatbuffers::VOffsetT = 4;
  pub const VT_END_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_TARGET_ID: flatbuffers::VOffsetT = 8;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 10;
  pub const VT_MODE: flatbuffers::VOffsetT = 12;
  pub const VT_MIN_ELEVATION: flatbuffers::VOffsetT = 14;
  pub const VT_MAX_RANGE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    sensorPlan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args sensorPlanArgs<'args>
  ) -> flatbuffers::WIPOffset<sensorPlan<'bldr>> {
    let mut builder = sensorPlanBuilder::new(_fbb);
    builder.add_MAX_RANGE(args.MAX_RANGE);
    builder.add_MIN_ELEVATION(args.MIN_ELEVATION);
    if let Some(x) = args.MODE { builder.add_MODE(x); }
    if let Some(x) = args.TARGET_ID { builder.add_TARGET_ID(x); }
    if let Some(x) = args.END_TIME { builder.add_END_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    builder.add_PRIORITY(args.PRIORITY);
    builder.finish()
  }

  pub fn unpack(&self) -> sensorPlanT {
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let END_TIME = self.END_TIME().map(|x| {
      x.to_string()
    });
    let TARGET_ID = self.TARGET_ID().map(|x| {
      x.to_string()
    });
    let PRIORITY = self.PRIORITY();
    let MODE = self.MODE().map(|x| {
      x.to_string()
    });
    let MIN_ELEVATION = self.MIN_ELEVATION();
    let MAX_RANGE = self.MAX_RANGE();
    sensorPlanT {
      START_TIME,
      END_TIME,
      TARGET_ID,
      PRIORITY,
      MODE,
      MIN_ELEVATION,
      MAX_RANGE,
    }
  }

  /// Plan start time (ISO 8601)
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorPlan::VT_START_TIME, None)}
  }
  /// Plan end time (ISO 8601)
  #[inline]
  pub fn END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorPlan::VT_END_TIME, None)}
  }
  /// Target satellite number or designator
  #[inline]
  pub fn TARGET_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorPlan::VT_TARGET_ID, None)}
  }
  /// Priority level (1=highest)
  #[inline]
  pub fn PRIORITY(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(sensorPlan::VT_PRIORITY, Some(0)).unwrap()}
  }
  /// Requested observation mode
  #[inline]
  pub fn MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorPlan::VT_MODE, None)}
  }
  /// Minimum elevation in degrees
  #[inline]
  pub fn MIN_ELEVATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(sensorPlan::VT_MIN_ELEVATION, Some(0.0)).unwrap()}
  }
  /// Maximum range in km
  #[inline]
  pub fn MAX_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(sensorPlan::VT_MAX_RANGE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for sensorPlan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END_TIME", Self::VT_END_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TARGET_ID", Self::VT_TARGET_ID, false)?
     .visit_field::<u8>("PRIORITY", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MODE", Self::VT_MODE, false)?
     .visit_field::<f64>("MIN_ELEVATION", Self::VT_MIN_ELEVATION, false)?
     .visit_field::<f64>("MAX_RANGE", Self::VT_MAX_RANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct sensorPlanArgs<'a> {
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TARGET_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIORITY: u8,
    pub MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MIN_ELEVATION: f64,
    pub MAX_RANGE: f64,
}
impl<'a> Default for sensorPlanArgs<'a> {
  #[inline]
  fn default() -> Self {
    sensorPlanArgs {
      START_TIME: None,
      END_TIME: None,
      TARGET_ID: None,
      PRIORITY: 0,
      MODE: None,
      MIN_ELEVATION: 0.0,
      MAX_RANGE: 0.0,
    }
  }
}

pub struct sensorPlanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> sensorPlanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorPlan::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_END_TIME(&mut self, END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorPlan::VT_END_TIME, END_TIME);
  }
  #[inline]
  pub fn add_TARGET_ID(&mut self, TARGET_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorPlan::VT_TARGET_ID, TARGET_ID);
  }
  #[inline]
  pub fn add_PRIORITY(&mut self, PRIORITY: u8) {
    self.fbb_.push_slot::<u8>(sensorPlan::VT_PRIORITY, PRIORITY, 0);
  }
  #[inline]
  pub fn add_MODE(&mut self, MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorPlan::VT_MODE, MODE);
  }
  #[inline]
  pub fn add_MIN_ELEVATION(&mut self, MIN_ELEVATION: f64) {
    self.fbb_.push_slot::<f64>(sensorPlan::VT_MIN_ELEVATION, MIN_ELEVATION, 0.0);
  }
  #[inline]
  pub fn add_MAX_RANGE(&mut self, MAX_RANGE: f64) {
    self.fbb_.push_slot::<f64>(sensorPlan::VT_MAX_RANGE, MAX_RANGE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> sensorPlanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    sensorPlanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<sensorPlan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for sensorPlan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("sensorPlan");
      ds.field("START_TIME", &self.START_TIME());
      ds.field("END_TIME", &self.END_TIME());
      ds.field("TARGET_ID", &self.TARGET_ID());
      ds.field("PRIORITY", &self.PRIORITY());
      ds.field("MODE", &self.MODE());
      ds.field("MIN_ELEVATION", &self.MIN_ELEVATION());
      ds.field("MAX_RANGE", &self.MAX_RANGE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct sensorPlanT {
  pub START_TIME: Option<String>,
  pub END_TIME: Option<String>,
  pub TARGET_ID: Option<String>,
  pub PRIORITY: u8,
  pub MODE: Option<String>,
  pub MIN_ELEVATION: f64,
  pub MAX_RANGE: f64,
}
impl Default for sensorPlanT {
  fn default() -> Self {
    Self {
      START_TIME: None,
      END_TIME: None,
      TARGET_ID: None,
      PRIORITY: 0,
      MODE: None,
      MIN_ELEVATION: 0.0,
      MAX_RANGE: 0.0,
    }
  }
}
impl sensorPlanT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<sensorPlan<'b>> {
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END_TIME = self.END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TARGET_ID = self.TARGET_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIORITY = self.PRIORITY;
    let MODE = self.MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MIN_ELEVATION = self.MIN_ELEVATION;
    let MAX_RANGE = self.MAX_RANGE;
    sensorPlan::create(_fbb, &sensorPlanArgs{
      START_TIME,
      END_TIME,
      TARGET_ID,
      PRIORITY,
      MODE,
      MIN_ELEVATION,
      MAX_RANGE,
    })
  }
}
pub enum sensorStatsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sensor Operational Statistics
pub struct sensorStats<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for sensorStats<'a> {
  type Inner = sensorStats<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> sensorStats<'a> {
  pub const VT_PERIOD_START: flatbuffers::VOffsetT = 4;
  pub const VT_PERIOD_END: flatbuffers::VOffsetT = 6;
  pub const VT_OBS_ATTEMPTED: flatbuffers::VOffsetT = 8;
  pub const VT_OBS_SUCCESSFUL: flatbuffers::VOffsetT = 10;
  pub const VT_OBS_FAILED: flatbuffers::VOffsetT = 12;
  pub const VT_UPTIME: flatbuffers::VOffsetT = 14;
  pub const VT_AVG_ACCURACY: flatbuffers::VOffsetT = 16;
  pub const VT_DETECTIONS: flatbuffers::VOffsetT = 18;
  pub const VT_UCT_COUNT: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    sensorStats { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args sensorStatsArgs<'args>
  ) -> flatbuffers::WIPOffset<sensorStats<'bldr>> {
    let mut builder = sensorStatsBuilder::new(_fbb);
    builder.add_AVG_ACCURACY(args.AVG_ACCURACY);
    builder.add_UPTIME(args.UPTIME);
    builder.add_UCT_COUNT(args.UCT_COUNT);
    builder.add_DETECTIONS(args.DETECTIONS);
    builder.add_OBS_FAILED(args.OBS_FAILED);
    builder.add_OBS_SUCCESSFUL(args.OBS_SUCCESSFUL);
    builder.add_OBS_ATTEMPTED(args.OBS_ATTEMPTED);
    if let Some(x) = args.PERIOD_END { builder.add_PERIOD_END(x); }
    if let Some(x) = args.PERIOD_START { builder.add_PERIOD_START(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> sensorStatsT {
    let PERIOD_START = self.PERIOD_START().map(|x| {
      x.to_string()
    });
    let PERIOD_END = self.PERIOD_END().map(|x| {
      x.to_string()
    });
    let OBS_ATTEMPTED = self.OBS_ATTEMPTED();
    let OBS_SUCCESSFUL = self.OBS_SUCCESSFUL();
    let OBS_FAILED = self.OBS_FAILED();
    let UPTIME = self.UPTIME();
    let AVG_ACCURACY = self.AVG_ACCURACY();
    let DETECTIONS = self.DETECTIONS();
    let UCT_COUNT = self.UCT_COUNT();
    sensorStatsT {
      PERIOD_START,
      PERIOD_END,
      OBS_ATTEMPTED,
      OBS_SUCCESSFUL,
      OBS_FAILED,
      UPTIME,
      AVG_ACCURACY,
      DETECTIONS,
      UCT_COUNT,
    }
  }

  /// Statistics period start (ISO 8601)
  #[inline]
  pub fn PERIOD_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorStats::VT_PERIOD_START, None)}
  }
  /// Statistics period end (ISO 8601)
  #[inline]
  pub fn PERIOD_END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(sensorStats::VT_PERIOD_END, None)}
  }
  /// Total observation attempts
  #[inline]
  pub fn OBS_ATTEMPTED(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(sensorStats::VT_OBS_ATTEMPTED, Some(0)).unwrap()}
  }
  /// Successful observations
  #[inline]
  pub fn OBS_SUCCESSFUL(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(sensorStats::VT_OBS_SUCCESSFUL, Some(0)).unwrap()}
  }
  /// Failed observations
  #[inline]
  pub fn OBS_FAILED(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(sensorStats::VT_OBS_FAILED, Some(0)).unwrap()}
  }
  /// Uptime fraction (0.0-1.0)
  #[inline]
  pub fn UPTIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(sensorStats::VT_UPTIME, Some(0.0)).unwrap()}
  }
  /// Average tracking accuracy in arcseconds
  #[inline]
  pub fn AVG_ACCURACY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(sensorStats::VT_AVG_ACCURACY, Some(0.0)).unwrap()}
  }
  /// Detected objects count
  #[inline]
  pub fn DETECTIONS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(sensorStats::VT_DETECTIONS, Some(0)).unwrap()}
  }
  /// Uncorrelated tracks count
  #[inline]
  pub fn UCT_COUNT(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(sensorStats::VT_UCT_COUNT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for sensorStats<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PERIOD_START", Self::VT_PERIOD_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PERIOD_END", Self::VT_PERIOD_END, false)?
     .visit_field::<u32>("OBS_ATTEMPTED", Self::VT_OBS_ATTEMPTED, false)?
     .visit_field::<u32>("OBS_SUCCESSFUL", Self::VT_OBS_SUCCESSFUL, false)?
     .visit_field::<u32>("OBS_FAILED", Self::VT_OBS_FAILED, false)?
     .visit_field::<f64>("UPTIME", Self::VT_UPTIME, false)?
     .visit_field::<f64>("AVG_ACCURACY", Self::VT_AVG_ACCURACY, false)?
     .visit_field::<u32>("DETECTIONS", Self::VT_DETECTIONS, false)?
     .visit_field::<u32>("UCT_COUNT", Self::VT_UCT_COUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct sensorStatsArgs<'a> {
    pub PERIOD_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PERIOD_END: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBS_ATTEMPTED: u32,
    pub OBS_SUCCESSFUL: u32,
    pub OBS_FAILED: u32,
    pub UPTIME: f64,
    pub AVG_ACCURACY: f64,
    pub DETECTIONS: u32,
    pub UCT_COUNT: u32,
}
impl<'a> Default for sensorStatsArgs<'a> {
  #[inline]
  fn default() -> Self {
    sensorStatsArgs {
      PERIOD_START: None,
      PERIOD_END: None,
      OBS_ATTEMPTED: 0,
      OBS_SUCCESSFUL: 0,
      OBS_FAILED: 0,
      UPTIME: 0.0,
      AVG_ACCURACY: 0.0,
      DETECTIONS: 0,
      UCT_COUNT: 0,
    }
  }
}

pub struct sensorStatsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> sensorStatsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PERIOD_START(&mut self, PERIOD_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorStats::VT_PERIOD_START, PERIOD_START);
  }
  #[inline]
  pub fn add_PERIOD_END(&mut self, PERIOD_END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(sensorStats::VT_PERIOD_END, PERIOD_END);
  }
  #[inline]
  pub fn add_OBS_ATTEMPTED(&mut self, OBS_ATTEMPTED: u32) {
    self.fbb_.push_slot::<u32>(sensorStats::VT_OBS_ATTEMPTED, OBS_ATTEMPTED, 0);
  }
  #[inline]
  pub fn add_OBS_SUCCESSFUL(&mut self, OBS_SUCCESSFUL: u32) {
    self.fbb_.push_slot::<u32>(sensorStats::VT_OBS_SUCCESSFUL, OBS_SUCCESSFUL, 0);
  }
  #[inline]
  pub fn add_OBS_FAILED(&mut self, OBS_FAILED: u32) {
    self.fbb_.push_slot::<u32>(sensorStats::VT_OBS_FAILED, OBS_FAILED, 0);
  }
  #[inline]
  pub fn add_UPTIME(&mut self, UPTIME: f64) {
    self.fbb_.push_slot::<f64>(sensorStats::VT_UPTIME, UPTIME, 0.0);
  }
  #[inline]
  pub fn add_AVG_ACCURACY(&mut self, AVG_ACCURACY: f64) {
    self.fbb_.push_slot::<f64>(sensorStats::VT_AVG_ACCURACY, AVG_ACCURACY, 0.0);
  }
  #[inline]
  pub fn add_DETECTIONS(&mut self, DETECTIONS: u32) {
    self.fbb_.push_slot::<u32>(sensorStats::VT_DETECTIONS, DETECTIONS, 0);
  }
  #[inline]
  pub fn add_UCT_COUNT(&mut self, UCT_COUNT: u32) {
    self.fbb_.push_slot::<u32>(sensorStats::VT_UCT_COUNT, UCT_COUNT, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> sensorStatsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    sensorStatsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<sensorStats<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for sensorStats<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("sensorStats");
      ds.field("PERIOD_START", &self.PERIOD_START());
      ds.field("PERIOD_END", &self.PERIOD_END());
      ds.field("OBS_ATTEMPTED", &self.OBS_ATTEMPTED());
      ds.field("OBS_SUCCESSFUL", &self.OBS_SUCCESSFUL());
      ds.field("OBS_FAILED", &self.OBS_FAILED());
      ds.field("UPTIME", &self.UPTIME());
      ds.field("AVG_ACCURACY", &self.AVG_ACCURACY());
      ds.field("DETECTIONS", &self.DETECTIONS());
      ds.field("UCT_COUNT", &self.UCT_COUNT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct sensorStatsT {
  pub PERIOD_START: Option<String>,
  pub PERIOD_END: Option<String>,
  pub OBS_ATTEMPTED: u32,
  pub OBS_SUCCESSFUL: u32,
  pub OBS_FAILED: u32,
  pub UPTIME: f64,
  pub AVG_ACCURACY: f64,
  pub DETECTIONS: u32,
  pub UCT_COUNT: u32,
}
impl Default for sensorStatsT {
  fn default() -> Self {
    Self {
      PERIOD_START: None,
      PERIOD_END: None,
      OBS_ATTEMPTED: 0,
      OBS_SUCCESSFUL: 0,
      OBS_FAILED: 0,
      UPTIME: 0.0,
      AVG_ACCURACY: 0.0,
      DETECTIONS: 0,
      UCT_COUNT: 0,
    }
  }
}
impl sensorStatsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<sensorStats<'b>> {
    let PERIOD_START = self.PERIOD_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PERIOD_END = self.PERIOD_END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBS_ATTEMPTED = self.OBS_ATTEMPTED;
    let OBS_SUCCESSFUL = self.OBS_SUCCESSFUL;
    let OBS_FAILED = self.OBS_FAILED;
    let UPTIME = self.UPTIME;
    let AVG_ACCURACY = self.AVG_ACCURACY;
    let DETECTIONS = self.DETECTIONS;
    let UCT_COUNT = self.UCT_COUNT;
    sensorStats::create(_fbb, &sensorStatsArgs{
      PERIOD_START,
      PERIOD_END,
      OBS_ATTEMPTED,
      OBS_SUCCESSFUL,
      OBS_FAILED,
      UPTIME,
      AVG_ACCURACY,
      DETECTIONS,
      UCT_COUNT,
    })
  }
}
pub enum SENOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sensor Management
pub struct SEN<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SEN<'a> {
  type Inner = SEN<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SEN<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_STATUS: flatbuffers::VOffsetT = 10;
  pub const VT_SITE_ID: flatbuffers::VOffsetT = 12;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 16;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 18;
  pub const VT_STATUS_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_MAINTENANCE: flatbuffers::VOffsetT = 22;
  pub const VT_PLANS: flatbuffers::VOffsetT = 24;
  pub const VT_STATISTICS: flatbuffers::VOffsetT = 26;
  pub const VT_NOTES: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SEN { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SENArgs<'args>
  ) -> flatbuffers::WIPOffset<SEN<'bldr>> {
    let mut builder = SENBuilder::new(_fbb);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.STATISTICS { builder.add_STATISTICS(x); }
    if let Some(x) = args.PLANS { builder.add_PLANS(x); }
    if let Some(x) = args.MAINTENANCE { builder.add_MAINTENANCE(x); }
    if let Some(x) = args.STATUS_TIME { builder.add_STATUS_TIME(x); }
    if let Some(x) = args.SITE_ID { builder.add_SITE_ID(x); }
    if let Some(x) = args.TYPE { builder.add_TYPE(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_STATUS(args.STATUS);
    builder.finish()
  }

  pub fn unpack(&self) -> SENT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE().map(|x| {
      x.to_string()
    });
    let STATUS = self.STATUS();
    let SITE_ID = self.SITE_ID().map(|x| {
      x.to_string()
    });
    let LATITUDE = self.LATITUDE();
    let LONGITUDE = self.LONGITUDE();
    let ALTITUDE = self.ALTITUDE();
    let STATUS_TIME = self.STATUS_TIME().map(|x| {
      x.to_string()
    });
    let MAINTENANCE = self.MAINTENANCE().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let PLANS = self.PLANS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let STATISTICS = self.STATISTICS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    SENT {
      ID,
      NAME,
      TYPE,
      STATUS,
      SITE_ID,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      STATUS_TIME,
      MAINTENANCE,
      PLANS,
      STATISTICS,
      NOTES,
    }
  }

  /// Unique sensor identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_ID, None)}
  }
  /// Sensor name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_NAME, None)}
  }
  /// Sensor type
  #[inline]
  pub fn TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_TYPE, None)}
  }
  /// Current operational status
  #[inline]
  pub fn STATUS(&self) -> sensorStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<sensorStatus>(SEN::VT_STATUS, Some(sensorStatus::OPERATIONAL)).unwrap()}
  }
  /// Site identifier
  #[inline]
  pub fn SITE_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_SITE_ID, None)}
  }
  /// Geodetic latitude in degrees
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEN::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Geodetic longitude in degrees
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEN::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude in meters above WGS-84
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SEN::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Last status update (ISO 8601)
  #[inline]
  pub fn STATUS_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_STATUS_TIME, None)}
  }
  /// Maintenance history
  #[inline]
  pub fn MAINTENANCE(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorMaintenanceEvent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorMaintenanceEvent>>>>(SEN::VT_MAINTENANCE, None)}
  }
  /// Observation plans/taskings
  #[inline]
  pub fn PLANS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorPlan<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorPlan>>>>(SEN::VT_PLANS, None)}
  }
  /// Operational statistics
  #[inline]
  pub fn STATISTICS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorStats<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorStats>>>>(SEN::VT_STATISTICS, None)}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SEN::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for SEN<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<sensorStatus>("STATUS", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SITE_ID", Self::VT_SITE_ID, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STATUS_TIME", Self::VT_STATUS_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<sensorMaintenanceEvent>>>>("MAINTENANCE", Self::VT_MAINTENANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<sensorPlan>>>>("PLANS", Self::VT_PLANS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<sensorStats>>>>("STATISTICS", Self::VT_STATISTICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct SENArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STATUS: sensorStatus,
    pub SITE_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LATITUDE: f64,
    pub LONGITUDE: f64,
    pub ALTITUDE: f64,
    pub STATUS_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MAINTENANCE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorMaintenanceEvent<'a>>>>>,
    pub PLANS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorPlan<'a>>>>>,
    pub STATISTICS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<sensorStats<'a>>>>>,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SENArgs<'a> {
  #[inline]
  fn default() -> Self {
    SENArgs {
      ID: None,
      NAME: None,
      TYPE: None,
      STATUS: sensorStatus::OPERATIONAL,
      SITE_ID: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      STATUS_TIME: None,
      MAINTENANCE: None,
      PLANS: None,
      STATISTICS: None,
      NOTES: None,
    }
  }
}

pub struct SENBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SENBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_ID, ID);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_TYPE, TYPE);
  }
  #[inline]
  pub fn add_STATUS(&mut self, STATUS: sensorStatus) {
    self.fbb_.push_slot::<sensorStatus>(SEN::VT_STATUS, STATUS, sensorStatus::OPERATIONAL);
  }
  #[inline]
  pub fn add_SITE_ID(&mut self, SITE_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_SITE_ID, SITE_ID);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(SEN::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(SEN::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(SEN::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_STATUS_TIME(&mut self, STATUS_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_STATUS_TIME, STATUS_TIME);
  }
  #[inline]
  pub fn add_MAINTENANCE(&mut self, MAINTENANCE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<sensorMaintenanceEvent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_MAINTENANCE, MAINTENANCE);
  }
  #[inline]
  pub fn add_PLANS(&mut self, PLANS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<sensorPlan<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_PLANS, PLANS);
  }
  #[inline]
  pub fn add_STATISTICS(&mut self, STATISTICS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<sensorStats<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_STATISTICS, STATISTICS);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SEN::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SENBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SENBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SEN<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SEN<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SEN");
      ds.field("ID", &self.ID());
      ds.field("NAME", &self.NAME());
      ds.field("TYPE", &self.TYPE());
      ds.field("STATUS", &self.STATUS());
      ds.field("SITE_ID", &self.SITE_ID());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("STATUS_TIME", &self.STATUS_TIME());
      ds.field("MAINTENANCE", &self.MAINTENANCE());
      ds.field("PLANS", &self.PLANS());
      ds.field("STATISTICS", &self.STATISTICS());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SENT {
  pub ID: Option<String>,
  pub NAME: Option<String>,
  pub TYPE: Option<String>,
  pub STATUS: sensorStatus,
  pub SITE_ID: Option<String>,
  pub LATITUDE: f64,
  pub LONGITUDE: f64,
  pub ALTITUDE: f64,
  pub STATUS_TIME: Option<String>,
  pub MAINTENANCE: Option<Vec<sensorMaintenanceEventT>>,
  pub PLANS: Option<Vec<sensorPlanT>>,
  pub STATISTICS: Option<Vec<sensorStatsT>>,
  pub NOTES: Option<String>,
}
impl Default for SENT {
  fn default() -> Self {
    Self {
      ID: None,
      NAME: None,
      TYPE: None,
      STATUS: sensorStatus::OPERATIONAL,
      SITE_ID: None,
      LATITUDE: 0.0,
      LONGITUDE: 0.0,
      ALTITUDE: 0.0,
      STATUS_TIME: None,
      MAINTENANCE: None,
      PLANS: None,
      STATISTICS: None,
      NOTES: None,
    }
  }
}
impl SENT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SEN<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STATUS = self.STATUS;
    let SITE_ID = self.SITE_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LATITUDE = self.LATITUDE;
    let LONGITUDE = self.LONGITUDE;
    let ALTITUDE = self.ALTITUDE;
    let STATUS_TIME = self.STATUS_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MAINTENANCE = self.MAINTENANCE.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let PLANS = self.PLANS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let STATISTICS = self.STATISTICS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SEN::create(_fbb, &SENArgs{
      ID,
      NAME,
      TYPE,
      STATUS,
      SITE_ID,
      LATITUDE,
      LONGITUDE,
      ALTITUDE,
      STATUS_TIME,
      MAINTENANCE,
      PLANS,
      STATISTICS,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SEN`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEN_unchecked`.
pub fn root_as_SEN(buf: &[u8]) -> Result<SEN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SEN>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SEN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SEN_unchecked`.
pub fn size_prefixed_root_as_SEN(buf: &[u8]) -> Result<SEN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SEN>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SEN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEN_unchecked`.
pub fn root_as_SEN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SEN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SEN<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SEN` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SEN_unchecked`.
pub fn size_prefixed_root_as_SEN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SEN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SEN<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SEN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SEN`.
pub unsafe fn root_as_SEN_unchecked(buf: &[u8]) -> SEN {
  flatbuffers::root_unchecked::<SEN>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SEN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SEN`.
pub unsafe fn size_prefixed_root_as_SEN_unchecked(buf: &[u8]) -> SEN {
  flatbuffers::size_prefixed_root_unchecked::<SEN>(buf)
}
pub const SEN_IDENTIFIER: &str = "$SEN";

#[inline]
pub fn SEN_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SEN_IDENTIFIER, false)
}

#[inline]
pub fn SEN_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SEN_IDENTIFIER, true)
}

#[inline]
pub fn finish_SEN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SEN<'a>>) {
  fbb.finish(root, Some(SEN_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SEN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SEN<'a>>) {
  fbb.finish_size_prefixed(root, Some(SEN_IDENTIFIER));
}
