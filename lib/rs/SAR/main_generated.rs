// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SAR_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SAR_MODE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SAR_MODE: [sarMode; 8] = [
  sarMode::STRIPMAP,
  sarMode::SPOTLIGHT,
  sarMode::SCANSAR,
  sarMode::TOPSAR,
  sarMode::ISAR,
  sarMode::GMTI,
  sarMode::MARITIME,
  sarMode::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct sarMode(pub i8);
#[allow(non_upper_case_globals)]
impl sarMode {
  pub const STRIPMAP: Self = Self(0);
  pub const SPOTLIGHT: Self = Self(1);
  pub const SCANSAR: Self = Self(2);
  pub const TOPSAR: Self = Self(3);
  pub const ISAR: Self = Self(4);
  pub const GMTI: Self = Self(5);
  pub const MARITIME: Self = Self(6);
  pub const UNKNOWN: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STRIPMAP,
    Self::SPOTLIGHT,
    Self::SCANSAR,
    Self::TOPSAR,
    Self::ISAR,
    Self::GMTI,
    Self::MARITIME,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STRIPMAP => Some("STRIPMAP"),
      Self::SPOTLIGHT => Some("SPOTLIGHT"),
      Self::SCANSAR => Some("SCANSAR"),
      Self::TOPSAR => Some("TOPSAR"),
      Self::ISAR => Some("ISAR"),
      Self::GMTI => Some("GMTI"),
      Self::MARITIME => Some("MARITIME"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for sarMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for sarMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for sarMode {
    type Output = sarMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for sarMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for sarMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for sarMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SAR_POLARIZATION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SAR_POLARIZATION: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SAR_POLARIZATION: [sarPolarization; 9] = [
  sarPolarization::HH,
  sarPolarization::VV,
  sarPolarization::HV,
  sarPolarization::VH,
  sarPolarization::DUAL_HH_VV,
  sarPolarization::DUAL_HH_HV,
  sarPolarization::DUAL_VV_VH,
  sarPolarization::QUAD,
  sarPolarization::COMPACT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct sarPolarization(pub i8);
#[allow(non_upper_case_globals)]
impl sarPolarization {
  pub const HH: Self = Self(0);
  pub const VV: Self = Self(1);
  pub const HV: Self = Self(2);
  pub const VH: Self = Self(3);
  pub const DUAL_HH_VV: Self = Self(4);
  pub const DUAL_HH_HV: Self = Self(5);
  pub const DUAL_VV_VH: Self = Self(6);
  pub const QUAD: Self = Self(7);
  pub const COMPACT: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HH,
    Self::VV,
    Self::HV,
    Self::VH,
    Self::DUAL_HH_VV,
    Self::DUAL_HH_HV,
    Self::DUAL_VV_VH,
    Self::QUAD,
    Self::COMPACT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HH => Some("HH"),
      Self::VV => Some("VV"),
      Self::HV => Some("HV"),
      Self::VH => Some("VH"),
      Self::DUAL_HH_VV => Some("DUAL_HH_VV"),
      Self::DUAL_HH_HV => Some("DUAL_HH_HV"),
      Self::DUAL_VV_VH => Some("DUAL_VV_VH"),
      Self::QUAD => Some("QUAD"),
      Self::COMPACT => Some("COMPACT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for sarPolarization {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for sarPolarization {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for sarPolarization {
    type Output = sarPolarization;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for sarPolarization {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for sarPolarization {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for sarPolarization {}
pub enum SAROffset {}
#[derive(Copy, Clone, PartialEq)]

/// SAR Observation
pub struct SAR<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SAR<'a> {
  type Inner = SAR<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SAR<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 6;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 10;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 12;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 14;
  pub const VT_EXTERNAL_ID: flatbuffers::VOffsetT = 16;
  pub const VT_COLLECTION_ID: flatbuffers::VOffsetT = 18;
  pub const VT_DETECTION_ID: flatbuffers::VOffsetT = 20;
  pub const VT_COLLECTION_START: flatbuffers::VOffsetT = 22;
  pub const VT_COLLECTION_END: flatbuffers::VOffsetT = 24;
  pub const VT_CENTER_TIME: flatbuffers::VOffsetT = 26;
  pub const VT_DETECTION_START: flatbuffers::VOffsetT = 28;
  pub const VT_DETECTION_END: flatbuffers::VOffsetT = 30;
  pub const VT_DWELL_TIME: flatbuffers::VOffsetT = 32;
  pub const VT_ORBIT_STATE: flatbuffers::VOffsetT = 34;
  pub const VT_SAR_MODE: flatbuffers::VOffsetT = 36;
  pub const VT_OPERATING_BAND: flatbuffers::VOffsetT = 38;
  pub const VT_OPERATING_FREQ: flatbuffers::VOffsetT = 40;
  pub const VT_SNR: flatbuffers::VOffsetT = 42;
  pub const VT_TX_POLARIZATION: flatbuffers::VOffsetT = 44;
  pub const VT_RX_POLARIZATION: flatbuffers::VOffsetT = 46;
  pub const VT_GRAZE_ANGLE: flatbuffers::VOffsetT = 48;
  pub const VT_INCIDENCE_ANGLE: flatbuffers::VOffsetT = 50;
  pub const VT_SQUINT_ANGLE: flatbuffers::VOffsetT = 52;
  pub const VT_PULSE_BANDWIDTH: flatbuffers::VOffsetT = 54;
  pub const VT_PULSE_DURATION: flatbuffers::VOffsetT = 56;
  pub const VT_CONTINUOUS_SPOT_ANGLE: flatbuffers::VOffsetT = 58;
  pub const VT_SLANT_RANGE: flatbuffers::VOffsetT = 60;
  pub const VT_NEAR_RANGE: flatbuffers::VOffsetT = 62;
  pub const VT_FAR_RANGE: flatbuffers::VOffsetT = 64;
  pub const VT_SWATH_LENGTH: flatbuffers::VOffsetT = 66;
  pub const VT_AGJSON: flatbuffers::VOffsetT = 68;
  pub const VT_ATEXT: flatbuffers::VOffsetT = 70;
  pub const VT_ATYPE: flatbuffers::VOffsetT = 72;
  pub const VT_COORD_SYS: flatbuffers::VOffsetT = 74;
  pub const VT_SPACING_RANGE: flatbuffers::VOffsetT = 76;
  pub const VT_SPACING_AZIMUTH: flatbuffers::VOffsetT = 78;
  pub const VT_LOOKS_AZIMUTH: flatbuffers::VOffsetT = 80;
  pub const VT_LOOKS_RANGE: flatbuffers::VOffsetT = 82;
  pub const VT_RESOLUTION_RANGE: flatbuffers::VOffsetT = 84;
  pub const VT_RESOLUTION_AZIMUTH: flatbuffers::VOffsetT = 86;
  pub const VT_OB_DIRECTION: flatbuffers::VOffsetT = 88;
  pub const VT_TARGETPOSX: flatbuffers::VOffsetT = 90;
  pub const VT_TARGETPOSY: flatbuffers::VOffsetT = 92;
  pub const VT_TARGETPOSZ: flatbuffers::VOffsetT = 94;
  pub const VT_SENALT: flatbuffers::VOffsetT = 96;
  pub const VT_SENVELX: flatbuffers::VOffsetT = 98;
  pub const VT_SENVELY: flatbuffers::VOffsetT = 100;
  pub const VT_SENVELZ: flatbuffers::VOffsetT = 102;
  pub const VT_SENLAT_START: flatbuffers::VOffsetT = 104;
  pub const VT_SENLON_START: flatbuffers::VOffsetT = 106;
  pub const VT_SENLAT_END: flatbuffers::VOffsetT = 108;
  pub const VT_SENLON_END: flatbuffers::VOffsetT = 110;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 112;
  pub const VT_TAGS: flatbuffers::VOffsetT = 114;
  pub const VT_SRC_TYPS: flatbuffers::VOffsetT = 116;
  pub const VT_SRC_IDS: flatbuffers::VOffsetT = 118;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SAR { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SARArgs<'args>
  ) -> flatbuffers::WIPOffset<SAR<'bldr>> {
    let mut builder = SARBuilder::new(_fbb);
    builder.add_SENLON_END(args.SENLON_END);
    builder.add_SENLAT_END(args.SENLAT_END);
    builder.add_SENLON_START(args.SENLON_START);
    builder.add_SENLAT_START(args.SENLAT_START);
    builder.add_SENVELZ(args.SENVELZ);
    builder.add_SENVELY(args.SENVELY);
    builder.add_SENVELX(args.SENVELX);
    builder.add_SENALT(args.SENALT);
    builder.add_TARGETPOSZ(args.TARGETPOSZ);
    builder.add_TARGETPOSY(args.TARGETPOSY);
    builder.add_TARGETPOSX(args.TARGETPOSX);
    builder.add_RESOLUTION_AZIMUTH(args.RESOLUTION_AZIMUTH);
    builder.add_RESOLUTION_RANGE(args.RESOLUTION_RANGE);
    builder.add_SPACING_AZIMUTH(args.SPACING_AZIMUTH);
    builder.add_SPACING_RANGE(args.SPACING_RANGE);
    builder.add_SWATH_LENGTH(args.SWATH_LENGTH);
    builder.add_FAR_RANGE(args.FAR_RANGE);
    builder.add_NEAR_RANGE(args.NEAR_RANGE);
    builder.add_SLANT_RANGE(args.SLANT_RANGE);
    builder.add_CONTINUOUS_SPOT_ANGLE(args.CONTINUOUS_SPOT_ANGLE);
    builder.add_PULSE_DURATION(args.PULSE_DURATION);
    builder.add_PULSE_BANDWIDTH(args.PULSE_BANDWIDTH);
    builder.add_SQUINT_ANGLE(args.SQUINT_ANGLE);
    builder.add_INCIDENCE_ANGLE(args.INCIDENCE_ANGLE);
    builder.add_GRAZE_ANGLE(args.GRAZE_ANGLE);
    builder.add_SNR(args.SNR);
    builder.add_OPERATING_FREQ(args.OPERATING_FREQ);
    builder.add_DWELL_TIME(args.DWELL_TIME);
    if let Some(x) = args.SRC_IDS { builder.add_SRC_IDS(x); }
    if let Some(x) = args.SRC_TYPS { builder.add_SRC_TYPS(x); }
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.OB_DIRECTION { builder.add_OB_DIRECTION(x); }
    if let Some(x) = args.COORD_SYS { builder.add_COORD_SYS(x); }
    if let Some(x) = args.ATYPE { builder.add_ATYPE(x); }
    if let Some(x) = args.ATEXT { builder.add_ATEXT(x); }
    if let Some(x) = args.AGJSON { builder.add_AGJSON(x); }
    if let Some(x) = args.OPERATING_BAND { builder.add_OPERATING_BAND(x); }
    if let Some(x) = args.ORBIT_STATE { builder.add_ORBIT_STATE(x); }
    if let Some(x) = args.DETECTION_END { builder.add_DETECTION_END(x); }
    if let Some(x) = args.DETECTION_START { builder.add_DETECTION_START(x); }
    if let Some(x) = args.CENTER_TIME { builder.add_CENTER_TIME(x); }
    if let Some(x) = args.COLLECTION_END { builder.add_COLLECTION_END(x); }
    if let Some(x) = args.COLLECTION_START { builder.add_COLLECTION_START(x); }
    if let Some(x) = args.DETECTION_ID { builder.add_DETECTION_ID(x); }
    if let Some(x) = args.COLLECTION_ID { builder.add_COLLECTION_ID(x); }
    if let Some(x) = args.EXTERNAL_ID { builder.add_EXTERNAL_ID(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_LOOKS_RANGE(args.LOOKS_RANGE);
    builder.add_LOOKS_AZIMUTH(args.LOOKS_AZIMUTH);
    builder.add_RX_POLARIZATION(args.RX_POLARIZATION);
    builder.add_TX_POLARIZATION(args.TX_POLARIZATION);
    builder.add_SAR_MODE(args.SAR_MODE);
    builder.finish()
  }

  pub fn unpack(&self) -> SART {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let EXTERNAL_ID = self.EXTERNAL_ID().map(|x| {
      x.to_string()
    });
    let COLLECTION_ID = self.COLLECTION_ID().map(|x| {
      x.to_string()
    });
    let DETECTION_ID = self.DETECTION_ID().map(|x| {
      x.to_string()
    });
    let COLLECTION_START = self.COLLECTION_START().map(|x| {
      x.to_string()
    });
    let COLLECTION_END = self.COLLECTION_END().map(|x| {
      x.to_string()
    });
    let CENTER_TIME = self.CENTER_TIME().map(|x| {
      x.to_string()
    });
    let DETECTION_START = self.DETECTION_START().map(|x| {
      x.to_string()
    });
    let DETECTION_END = self.DETECTION_END().map(|x| {
      x.to_string()
    });
    let DWELL_TIME = self.DWELL_TIME();
    let ORBIT_STATE = self.ORBIT_STATE().map(|x| {
      x.to_string()
    });
    let SAR_MODE = self.SAR_MODE();
    let OPERATING_BAND = self.OPERATING_BAND().map(|x| {
      x.to_string()
    });
    let OPERATING_FREQ = self.OPERATING_FREQ();
    let SNR = self.SNR();
    let TX_POLARIZATION = self.TX_POLARIZATION();
    let RX_POLARIZATION = self.RX_POLARIZATION();
    let GRAZE_ANGLE = self.GRAZE_ANGLE();
    let INCIDENCE_ANGLE = self.INCIDENCE_ANGLE();
    let SQUINT_ANGLE = self.SQUINT_ANGLE();
    let PULSE_BANDWIDTH = self.PULSE_BANDWIDTH();
    let PULSE_DURATION = self.PULSE_DURATION();
    let CONTINUOUS_SPOT_ANGLE = self.CONTINUOUS_SPOT_ANGLE();
    let SLANT_RANGE = self.SLANT_RANGE();
    let NEAR_RANGE = self.NEAR_RANGE();
    let FAR_RANGE = self.FAR_RANGE();
    let SWATH_LENGTH = self.SWATH_LENGTH();
    let AGJSON = self.AGJSON().map(|x| {
      x.to_string()
    });
    let ATEXT = self.ATEXT().map(|x| {
      x.to_string()
    });
    let ATYPE = self.ATYPE().map(|x| {
      x.to_string()
    });
    let COORD_SYS = self.COORD_SYS().map(|x| {
      x.to_string()
    });
    let SPACING_RANGE = self.SPACING_RANGE();
    let SPACING_AZIMUTH = self.SPACING_AZIMUTH();
    let LOOKS_AZIMUTH = self.LOOKS_AZIMUTH();
    let LOOKS_RANGE = self.LOOKS_RANGE();
    let RESOLUTION_RANGE = self.RESOLUTION_RANGE();
    let RESOLUTION_AZIMUTH = self.RESOLUTION_AZIMUTH();
    let OB_DIRECTION = self.OB_DIRECTION().map(|x| {
      x.to_string()
    });
    let TARGETPOSX = self.TARGETPOSX();
    let TARGETPOSY = self.TARGETPOSY();
    let TARGETPOSZ = self.TARGETPOSZ();
    let SENALT = self.SENALT();
    let SENVELX = self.SENVELX();
    let SENVELY = self.SENVELY();
    let SENVELZ = self.SENVELZ();
    let SENLAT_START = self.SENLAT_START();
    let SENLON_START = self.SENLON_START();
    let SENLAT_END = self.SENLAT_END();
    let SENLON_END = self.SENLON_END();
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SRC_TYPS = self.SRC_TYPS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SRC_IDS = self.SRC_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    SART {
      ID,
      SAT_NO,
      ORIG_OBJECT_ID,
      ON_ORBIT,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      EXTERNAL_ID,
      COLLECTION_ID,
      DETECTION_ID,
      COLLECTION_START,
      COLLECTION_END,
      CENTER_TIME,
      DETECTION_START,
      DETECTION_END,
      DWELL_TIME,
      ORBIT_STATE,
      SAR_MODE,
      OPERATING_BAND,
      OPERATING_FREQ,
      SNR,
      TX_POLARIZATION,
      RX_POLARIZATION,
      GRAZE_ANGLE,
      INCIDENCE_ANGLE,
      SQUINT_ANGLE,
      PULSE_BANDWIDTH,
      PULSE_DURATION,
      CONTINUOUS_SPOT_ANGLE,
      SLANT_RANGE,
      NEAR_RANGE,
      FAR_RANGE,
      SWATH_LENGTH,
      AGJSON,
      ATEXT,
      ATYPE,
      COORD_SYS,
      SPACING_RANGE,
      SPACING_AZIMUTH,
      LOOKS_AZIMUTH,
      LOOKS_RANGE,
      RESOLUTION_RANGE,
      RESOLUTION_AZIMUTH,
      OB_DIRECTION,
      TARGETPOSX,
      TARGETPOSY,
      TARGETPOSZ,
      SENALT,
      SENVELX,
      SENVELY,
      SENVELZ,
      SENLAT_START,
      SENLON_START,
      SENLAT_END,
      SENLON_END,
      TRANSACTION_ID,
      TAGS,
      SRC_TYPS,
      SRC_IDS,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ID, None)}
  }
  /// Satellite catalog number (of SAR platform)
  #[inline]
  pub fn SAT_NO(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SAR::VT_SAT_NO, Some(0)).unwrap()}
  }
  /// International designator
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ORIG_OBJECT_ID, None)}
  }
  /// On-orbit reference
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ON_ORBIT, None)}
  }
  /// Sensor identifier
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ID_SENSOR, None)}
  }
  /// Original sensor identifier
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ORIG_SENSOR_ID, None)}
  }
  /// External reference identifier
  #[inline]
  pub fn EXTERNAL_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_EXTERNAL_ID, None)}
  }
  /// Collection identifier
  #[inline]
  pub fn COLLECTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_COLLECTION_ID, None)}
  }
  /// Detection identifier
  #[inline]
  pub fn DETECTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_DETECTION_ID, None)}
  }
  /// Collection start time (ISO 8601)
  #[inline]
  pub fn COLLECTION_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_COLLECTION_START, None)}
  }
  /// Collection end time (ISO 8601)
  #[inline]
  pub fn COLLECTION_END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_COLLECTION_END, None)}
  }
  /// Center time of observation (ISO 8601)
  #[inline]
  pub fn CENTER_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_CENTER_TIME, None)}
  }
  /// Detection start time (ISO 8601)
  #[inline]
  pub fn DETECTION_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_DETECTION_START, None)}
  }
  /// Detection end time (ISO 8601)
  #[inline]
  pub fn DETECTION_END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_DETECTION_END, None)}
  }
  /// Integration/dwell time (seconds)
  #[inline]
  pub fn DWELL_TIME(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_DWELL_TIME, Some(0.0)).unwrap()}
  }
  /// Orbit state description
  #[inline]
  pub fn ORBIT_STATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ORBIT_STATE, None)}
  }
  /// SAR imaging mode
  #[inline]
  pub fn SAR_MODE(&self) -> sarMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<sarMode>(SAR::VT_SAR_MODE, Some(sarMode::STRIPMAP)).unwrap()}
  }
  /// Operating RF band (e.g., X, C, L, S, P)
  #[inline]
  pub fn OPERATING_BAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_OPERATING_BAND, None)}
  }
  /// Operating frequency (GHz)
  #[inline]
  pub fn OPERATING_FREQ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_OPERATING_FREQ, Some(0.0)).unwrap()}
  }
  /// Signal-to-noise ratio (dB)
  #[inline]
  pub fn SNR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SNR, Some(0.0)).unwrap()}
  }
  /// Transmit polarization
  #[inline]
  pub fn TX_POLARIZATION(&self) -> sarPolarization {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<sarPolarization>(SAR::VT_TX_POLARIZATION, Some(sarPolarization::HH)).unwrap()}
  }
  /// Receive polarization
  #[inline]
  pub fn RX_POLARIZATION(&self) -> sarPolarization {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<sarPolarization>(SAR::VT_RX_POLARIZATION, Some(sarPolarization::HH)).unwrap()}
  }
  /// Grazing angle (degrees)
  #[inline]
  pub fn GRAZE_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_GRAZE_ANGLE, Some(0.0)).unwrap()}
  }
  /// Incidence angle (degrees)
  #[inline]
  pub fn INCIDENCE_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_INCIDENCE_ANGLE, Some(0.0)).unwrap()}
  }
  /// Squint angle (degrees)
  #[inline]
  pub fn SQUINT_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SQUINT_ANGLE, Some(0.0)).unwrap()}
  }
  /// Pulse bandwidth (MHz)
  #[inline]
  pub fn PULSE_BANDWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_PULSE_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Pulse duration (microseconds)
  #[inline]
  pub fn PULSE_DURATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_PULSE_DURATION, Some(0.0)).unwrap()}
  }
  /// Continuous spot angle (degrees)
  #[inline]
  pub fn CONTINUOUS_SPOT_ANGLE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_CONTINUOUS_SPOT_ANGLE, Some(0.0)).unwrap()}
  }
  /// Slant range to target (km)
  #[inline]
  pub fn SLANT_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SLANT_RANGE, Some(0.0)).unwrap()}
  }
  /// Near range (km)
  #[inline]
  pub fn NEAR_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_NEAR_RANGE, Some(0.0)).unwrap()}
  }
  /// Far range (km)
  #[inline]
  pub fn FAR_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_FAR_RANGE, Some(0.0)).unwrap()}
  }
  /// Swath length (km)
  #[inline]
  pub fn SWATH_LENGTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SWATH_LENGTH, Some(0.0)).unwrap()}
  }
  /// Image area GeoJSON
  #[inline]
  pub fn AGJSON(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_AGJSON, None)}
  }
  /// Image area text description
  #[inline]
  pub fn ATEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ATEXT, None)}
  }
  /// Area type
  #[inline]
  pub fn ATYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_ATYPE, None)}
  }
  /// Coordinate system
  #[inline]
  pub fn COORD_SYS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_COORD_SYS, None)}
  }
  /// Range pixel spacing (meters)
  #[inline]
  pub fn SPACING_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SPACING_RANGE, Some(0.0)).unwrap()}
  }
  /// Azimuth pixel spacing (meters)
  #[inline]
  pub fn SPACING_AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SPACING_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// Number of azimuth looks
  #[inline]
  pub fn LOOKS_AZIMUTH(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SAR::VT_LOOKS_AZIMUTH, Some(0)).unwrap()}
  }
  /// Number of range looks
  #[inline]
  pub fn LOOKS_RANGE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SAR::VT_LOOKS_RANGE, Some(0)).unwrap()}
  }
  /// Range resolution (meters)
  #[inline]
  pub fn RESOLUTION_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_RESOLUTION_RANGE, Some(0.0)).unwrap()}
  }
  /// Azimuth resolution (meters)
  #[inline]
  pub fn RESOLUTION_AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_RESOLUTION_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// Observation direction (ASCENDING/DESCENDING)
  #[inline]
  pub fn OB_DIRECTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_OB_DIRECTION, None)}
  }
  /// Target position X (km)
  #[inline]
  pub fn TARGETPOSX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_TARGETPOSX, Some(0.0)).unwrap()}
  }
  /// Target position Y (km)
  #[inline]
  pub fn TARGETPOSY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_TARGETPOSY, Some(0.0)).unwrap()}
  }
  /// Target position Z (km)
  #[inline]
  pub fn TARGETPOSZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_TARGETPOSZ, Some(0.0)).unwrap()}
  }
  /// Sensor altitude (km)
  #[inline]
  pub fn SENALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// Sensor velocity X (km/s)
  #[inline]
  pub fn SENVELX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENVELX, Some(0.0)).unwrap()}
  }
  /// Sensor velocity Y (km/s)
  #[inline]
  pub fn SENVELY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENVELY, Some(0.0)).unwrap()}
  }
  /// Sensor velocity Z (km/s)
  #[inline]
  pub fn SENVELZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENVELZ, Some(0.0)).unwrap()}
  }
  /// Sensor latitude at start (degrees)
  #[inline]
  pub fn SENLAT_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENLAT_START, Some(0.0)).unwrap()}
  }
  /// Sensor longitude at start (degrees)
  #[inline]
  pub fn SENLON_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENLON_START, Some(0.0)).unwrap()}
  }
  /// Sensor latitude at end (degrees)
  #[inline]
  pub fn SENLAT_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENLAT_END, Some(0.0)).unwrap()}
  }
  /// Sensor longitude at end (degrees)
  #[inline]
  pub fn SENLON_END(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SAR::VT_SENLON_END, Some(0.0)).unwrap()}
  }
  /// Transaction identifier
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SAR::VT_TRANSACTION_ID, None)}
  }
  /// Associated tags
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SAR::VT_TAGS, None)}
  }
  /// Source types
  #[inline]
  pub fn SRC_TYPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SAR::VT_SRC_TYPS, None)}
  }
  /// Source identifiers
  #[inline]
  pub fn SRC_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SAR::VT_SRC_IDS, None)}
  }
}

impl flatbuffers::Verifiable for SAR<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<u32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXTERNAL_ID", Self::VT_EXTERNAL_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_ID", Self::VT_COLLECTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DETECTION_ID", Self::VT_DETECTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_START", Self::VT_COLLECTION_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_END", Self::VT_COLLECTION_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CENTER_TIME", Self::VT_CENTER_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DETECTION_START", Self::VT_DETECTION_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DETECTION_END", Self::VT_DETECTION_END, false)?
     .visit_field::<f64>("DWELL_TIME", Self::VT_DWELL_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORBIT_STATE", Self::VT_ORBIT_STATE, false)?
     .visit_field::<sarMode>("SAR_MODE", Self::VT_SAR_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPERATING_BAND", Self::VT_OPERATING_BAND, false)?
     .visit_field::<f64>("OPERATING_FREQ", Self::VT_OPERATING_FREQ, false)?
     .visit_field::<f64>("SNR", Self::VT_SNR, false)?
     .visit_field::<sarPolarization>("TX_POLARIZATION", Self::VT_TX_POLARIZATION, false)?
     .visit_field::<sarPolarization>("RX_POLARIZATION", Self::VT_RX_POLARIZATION, false)?
     .visit_field::<f64>("GRAZE_ANGLE", Self::VT_GRAZE_ANGLE, false)?
     .visit_field::<f64>("INCIDENCE_ANGLE", Self::VT_INCIDENCE_ANGLE, false)?
     .visit_field::<f64>("SQUINT_ANGLE", Self::VT_SQUINT_ANGLE, false)?
     .visit_field::<f64>("PULSE_BANDWIDTH", Self::VT_PULSE_BANDWIDTH, false)?
     .visit_field::<f64>("PULSE_DURATION", Self::VT_PULSE_DURATION, false)?
     .visit_field::<f64>("CONTINUOUS_SPOT_ANGLE", Self::VT_CONTINUOUS_SPOT_ANGLE, false)?
     .visit_field::<f64>("SLANT_RANGE", Self::VT_SLANT_RANGE, false)?
     .visit_field::<f64>("NEAR_RANGE", Self::VT_NEAR_RANGE, false)?
     .visit_field::<f64>("FAR_RANGE", Self::VT_FAR_RANGE, false)?
     .visit_field::<f64>("SWATH_LENGTH", Self::VT_SWATH_LENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AGJSON", Self::VT_AGJSON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ATEXT", Self::VT_ATEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ATYPE", Self::VT_ATYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COORD_SYS", Self::VT_COORD_SYS, false)?
     .visit_field::<f64>("SPACING_RANGE", Self::VT_SPACING_RANGE, false)?
     .visit_field::<f64>("SPACING_AZIMUTH", Self::VT_SPACING_AZIMUTH, false)?
     .visit_field::<u8>("LOOKS_AZIMUTH", Self::VT_LOOKS_AZIMUTH, false)?
     .visit_field::<u8>("LOOKS_RANGE", Self::VT_LOOKS_RANGE, false)?
     .visit_field::<f64>("RESOLUTION_RANGE", Self::VT_RESOLUTION_RANGE, false)?
     .visit_field::<f64>("RESOLUTION_AZIMUTH", Self::VT_RESOLUTION_AZIMUTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_DIRECTION", Self::VT_OB_DIRECTION, false)?
     .visit_field::<f64>("TARGETPOSX", Self::VT_TARGETPOSX, false)?
     .visit_field::<f64>("TARGETPOSY", Self::VT_TARGETPOSY, false)?
     .visit_field::<f64>("TARGETPOSZ", Self::VT_TARGETPOSZ, false)?
     .visit_field::<f64>("SENALT", Self::VT_SENALT, false)?
     .visit_field::<f64>("SENVELX", Self::VT_SENVELX, false)?
     .visit_field::<f64>("SENVELY", Self::VT_SENVELY, false)?
     .visit_field::<f64>("SENVELZ", Self::VT_SENVELZ, false)?
     .visit_field::<f64>("SENLAT_START", Self::VT_SENLAT_START, false)?
     .visit_field::<f64>("SENLON_START", Self::VT_SENLON_START, false)?
     .visit_field::<f64>("SENLAT_END", Self::VT_SENLAT_END, false)?
     .visit_field::<f64>("SENLON_END", Self::VT_SENLON_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_TYPS", Self::VT_SRC_TYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SRC_IDS", Self::VT_SRC_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SARArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: u32,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EXTERNAL_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DETECTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_END: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CENTER_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DETECTION_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DETECTION_END: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DWELL_TIME: f64,
    pub ORBIT_STATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAR_MODE: sarMode,
    pub OPERATING_BAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPERATING_FREQ: f64,
    pub SNR: f64,
    pub TX_POLARIZATION: sarPolarization,
    pub RX_POLARIZATION: sarPolarization,
    pub GRAZE_ANGLE: f64,
    pub INCIDENCE_ANGLE: f64,
    pub SQUINT_ANGLE: f64,
    pub PULSE_BANDWIDTH: f64,
    pub PULSE_DURATION: f64,
    pub CONTINUOUS_SPOT_ANGLE: f64,
    pub SLANT_RANGE: f64,
    pub NEAR_RANGE: f64,
    pub FAR_RANGE: f64,
    pub SWATH_LENGTH: f64,
    pub AGJSON: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ATEXT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ATYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COORD_SYS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SPACING_RANGE: f64,
    pub SPACING_AZIMUTH: f64,
    pub LOOKS_AZIMUTH: u8,
    pub LOOKS_RANGE: u8,
    pub RESOLUTION_RANGE: f64,
    pub RESOLUTION_AZIMUTH: f64,
    pub OB_DIRECTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TARGETPOSX: f64,
    pub TARGETPOSY: f64,
    pub TARGETPOSZ: f64,
    pub SENALT: f64,
    pub SENVELX: f64,
    pub SENVELY: f64,
    pub SENVELZ: f64,
    pub SENLAT_START: f64,
    pub SENLON_START: f64,
    pub SENLAT_END: f64,
    pub SENLON_END: f64,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SRC_TYPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SRC_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SARArgs<'a> {
  #[inline]
  fn default() -> Self {
    SARArgs {
      ID: None,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ON_ORBIT: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      EXTERNAL_ID: None,
      COLLECTION_ID: None,
      DETECTION_ID: None,
      COLLECTION_START: None,
      COLLECTION_END: None,
      CENTER_TIME: None,
      DETECTION_START: None,
      DETECTION_END: None,
      DWELL_TIME: 0.0,
      ORBIT_STATE: None,
      SAR_MODE: sarMode::STRIPMAP,
      OPERATING_BAND: None,
      OPERATING_FREQ: 0.0,
      SNR: 0.0,
      TX_POLARIZATION: sarPolarization::HH,
      RX_POLARIZATION: sarPolarization::HH,
      GRAZE_ANGLE: 0.0,
      INCIDENCE_ANGLE: 0.0,
      SQUINT_ANGLE: 0.0,
      PULSE_BANDWIDTH: 0.0,
      PULSE_DURATION: 0.0,
      CONTINUOUS_SPOT_ANGLE: 0.0,
      SLANT_RANGE: 0.0,
      NEAR_RANGE: 0.0,
      FAR_RANGE: 0.0,
      SWATH_LENGTH: 0.0,
      AGJSON: None,
      ATEXT: None,
      ATYPE: None,
      COORD_SYS: None,
      SPACING_RANGE: 0.0,
      SPACING_AZIMUTH: 0.0,
      LOOKS_AZIMUTH: 0,
      LOOKS_RANGE: 0,
      RESOLUTION_RANGE: 0.0,
      RESOLUTION_AZIMUTH: 0.0,
      OB_DIRECTION: None,
      TARGETPOSX: 0.0,
      TARGETPOSY: 0.0,
      TARGETPOSZ: 0.0,
      SENALT: 0.0,
      SENVELX: 0.0,
      SENVELY: 0.0,
      SENVELZ: 0.0,
      SENLAT_START: 0.0,
      SENLON_START: 0.0,
      SENLAT_END: 0.0,
      SENLON_END: 0.0,
      TRANSACTION_ID: None,
      TAGS: None,
      SRC_TYPS: None,
      SRC_IDS: None,
    }
  }
}

pub struct SARBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SARBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ID, ID);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: u32) {
    self.fbb_.push_slot::<u32>(SAR::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_EXTERNAL_ID(&mut self, EXTERNAL_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_EXTERNAL_ID, EXTERNAL_ID);
  }
  #[inline]
  pub fn add_COLLECTION_ID(&mut self, COLLECTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_COLLECTION_ID, COLLECTION_ID);
  }
  #[inline]
  pub fn add_DETECTION_ID(&mut self, DETECTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_DETECTION_ID, DETECTION_ID);
  }
  #[inline]
  pub fn add_COLLECTION_START(&mut self, COLLECTION_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_COLLECTION_START, COLLECTION_START);
  }
  #[inline]
  pub fn add_COLLECTION_END(&mut self, COLLECTION_END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_COLLECTION_END, COLLECTION_END);
  }
  #[inline]
  pub fn add_CENTER_TIME(&mut self, CENTER_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_CENTER_TIME, CENTER_TIME);
  }
  #[inline]
  pub fn add_DETECTION_START(&mut self, DETECTION_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_DETECTION_START, DETECTION_START);
  }
  #[inline]
  pub fn add_DETECTION_END(&mut self, DETECTION_END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_DETECTION_END, DETECTION_END);
  }
  #[inline]
  pub fn add_DWELL_TIME(&mut self, DWELL_TIME: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_DWELL_TIME, DWELL_TIME, 0.0);
  }
  #[inline]
  pub fn add_ORBIT_STATE(&mut self, ORBIT_STATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ORBIT_STATE, ORBIT_STATE);
  }
  #[inline]
  pub fn add_SAR_MODE(&mut self, SAR_MODE: sarMode) {
    self.fbb_.push_slot::<sarMode>(SAR::VT_SAR_MODE, SAR_MODE, sarMode::STRIPMAP);
  }
  #[inline]
  pub fn add_OPERATING_BAND(&mut self, OPERATING_BAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_OPERATING_BAND, OPERATING_BAND);
  }
  #[inline]
  pub fn add_OPERATING_FREQ(&mut self, OPERATING_FREQ: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_OPERATING_FREQ, OPERATING_FREQ, 0.0);
  }
  #[inline]
  pub fn add_SNR(&mut self, SNR: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SNR, SNR, 0.0);
  }
  #[inline]
  pub fn add_TX_POLARIZATION(&mut self, TX_POLARIZATION: sarPolarization) {
    self.fbb_.push_slot::<sarPolarization>(SAR::VT_TX_POLARIZATION, TX_POLARIZATION, sarPolarization::HH);
  }
  #[inline]
  pub fn add_RX_POLARIZATION(&mut self, RX_POLARIZATION: sarPolarization) {
    self.fbb_.push_slot::<sarPolarization>(SAR::VT_RX_POLARIZATION, RX_POLARIZATION, sarPolarization::HH);
  }
  #[inline]
  pub fn add_GRAZE_ANGLE(&mut self, GRAZE_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_GRAZE_ANGLE, GRAZE_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_INCIDENCE_ANGLE(&mut self, INCIDENCE_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_INCIDENCE_ANGLE, INCIDENCE_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_SQUINT_ANGLE(&mut self, SQUINT_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SQUINT_ANGLE, SQUINT_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_PULSE_BANDWIDTH(&mut self, PULSE_BANDWIDTH: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_PULSE_BANDWIDTH, PULSE_BANDWIDTH, 0.0);
  }
  #[inline]
  pub fn add_PULSE_DURATION(&mut self, PULSE_DURATION: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_PULSE_DURATION, PULSE_DURATION, 0.0);
  }
  #[inline]
  pub fn add_CONTINUOUS_SPOT_ANGLE(&mut self, CONTINUOUS_SPOT_ANGLE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_CONTINUOUS_SPOT_ANGLE, CONTINUOUS_SPOT_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_SLANT_RANGE(&mut self, SLANT_RANGE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SLANT_RANGE, SLANT_RANGE, 0.0);
  }
  #[inline]
  pub fn add_NEAR_RANGE(&mut self, NEAR_RANGE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_NEAR_RANGE, NEAR_RANGE, 0.0);
  }
  #[inline]
  pub fn add_FAR_RANGE(&mut self, FAR_RANGE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_FAR_RANGE, FAR_RANGE, 0.0);
  }
  #[inline]
  pub fn add_SWATH_LENGTH(&mut self, SWATH_LENGTH: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SWATH_LENGTH, SWATH_LENGTH, 0.0);
  }
  #[inline]
  pub fn add_AGJSON(&mut self, AGJSON: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_AGJSON, AGJSON);
  }
  #[inline]
  pub fn add_ATEXT(&mut self, ATEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ATEXT, ATEXT);
  }
  #[inline]
  pub fn add_ATYPE(&mut self, ATYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_ATYPE, ATYPE);
  }
  #[inline]
  pub fn add_COORD_SYS(&mut self, COORD_SYS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_COORD_SYS, COORD_SYS);
  }
  #[inline]
  pub fn add_SPACING_RANGE(&mut self, SPACING_RANGE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SPACING_RANGE, SPACING_RANGE, 0.0);
  }
  #[inline]
  pub fn add_SPACING_AZIMUTH(&mut self, SPACING_AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SPACING_AZIMUTH, SPACING_AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_LOOKS_AZIMUTH(&mut self, LOOKS_AZIMUTH: u8) {
    self.fbb_.push_slot::<u8>(SAR::VT_LOOKS_AZIMUTH, LOOKS_AZIMUTH, 0);
  }
  #[inline]
  pub fn add_LOOKS_RANGE(&mut self, LOOKS_RANGE: u8) {
    self.fbb_.push_slot::<u8>(SAR::VT_LOOKS_RANGE, LOOKS_RANGE, 0);
  }
  #[inline]
  pub fn add_RESOLUTION_RANGE(&mut self, RESOLUTION_RANGE: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_RESOLUTION_RANGE, RESOLUTION_RANGE, 0.0);
  }
  #[inline]
  pub fn add_RESOLUTION_AZIMUTH(&mut self, RESOLUTION_AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_RESOLUTION_AZIMUTH, RESOLUTION_AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_OB_DIRECTION(&mut self, OB_DIRECTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_OB_DIRECTION, OB_DIRECTION);
  }
  #[inline]
  pub fn add_TARGETPOSX(&mut self, TARGETPOSX: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_TARGETPOSX, TARGETPOSX, 0.0);
  }
  #[inline]
  pub fn add_TARGETPOSY(&mut self, TARGETPOSY: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_TARGETPOSY, TARGETPOSY, 0.0);
  }
  #[inline]
  pub fn add_TARGETPOSZ(&mut self, TARGETPOSZ: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_TARGETPOSZ, TARGETPOSZ, 0.0);
  }
  #[inline]
  pub fn add_SENALT(&mut self, SENALT: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENALT, SENALT, 0.0);
  }
  #[inline]
  pub fn add_SENVELX(&mut self, SENVELX: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENVELX, SENVELX, 0.0);
  }
  #[inline]
  pub fn add_SENVELY(&mut self, SENVELY: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENVELY, SENVELY, 0.0);
  }
  #[inline]
  pub fn add_SENVELZ(&mut self, SENVELZ: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENVELZ, SENVELZ, 0.0);
  }
  #[inline]
  pub fn add_SENLAT_START(&mut self, SENLAT_START: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENLAT_START, SENLAT_START, 0.0);
  }
  #[inline]
  pub fn add_SENLON_START(&mut self, SENLON_START: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENLON_START, SENLON_START, 0.0);
  }
  #[inline]
  pub fn add_SENLAT_END(&mut self, SENLAT_END: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENLAT_END, SENLAT_END, 0.0);
  }
  #[inline]
  pub fn add_SENLON_END(&mut self, SENLON_END: f64) {
    self.fbb_.push_slot::<f64>(SAR::VT_SENLON_END, SENLON_END, 0.0);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn add_SRC_TYPS(&mut self, SRC_TYPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_SRC_TYPS, SRC_TYPS);
  }
  #[inline]
  pub fn add_SRC_IDS(&mut self, SRC_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SAR::VT_SRC_IDS, SRC_IDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SARBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SARBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SAR<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SAR<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SAR");
      ds.field("ID", &self.ID());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("EXTERNAL_ID", &self.EXTERNAL_ID());
      ds.field("COLLECTION_ID", &self.COLLECTION_ID());
      ds.field("DETECTION_ID", &self.DETECTION_ID());
      ds.field("COLLECTION_START", &self.COLLECTION_START());
      ds.field("COLLECTION_END", &self.COLLECTION_END());
      ds.field("CENTER_TIME", &self.CENTER_TIME());
      ds.field("DETECTION_START", &self.DETECTION_START());
      ds.field("DETECTION_END", &self.DETECTION_END());
      ds.field("DWELL_TIME", &self.DWELL_TIME());
      ds.field("ORBIT_STATE", &self.ORBIT_STATE());
      ds.field("SAR_MODE", &self.SAR_MODE());
      ds.field("OPERATING_BAND", &self.OPERATING_BAND());
      ds.field("OPERATING_FREQ", &self.OPERATING_FREQ());
      ds.field("SNR", &self.SNR());
      ds.field("TX_POLARIZATION", &self.TX_POLARIZATION());
      ds.field("RX_POLARIZATION", &self.RX_POLARIZATION());
      ds.field("GRAZE_ANGLE", &self.GRAZE_ANGLE());
      ds.field("INCIDENCE_ANGLE", &self.INCIDENCE_ANGLE());
      ds.field("SQUINT_ANGLE", &self.SQUINT_ANGLE());
      ds.field("PULSE_BANDWIDTH", &self.PULSE_BANDWIDTH());
      ds.field("PULSE_DURATION", &self.PULSE_DURATION());
      ds.field("CONTINUOUS_SPOT_ANGLE", &self.CONTINUOUS_SPOT_ANGLE());
      ds.field("SLANT_RANGE", &self.SLANT_RANGE());
      ds.field("NEAR_RANGE", &self.NEAR_RANGE());
      ds.field("FAR_RANGE", &self.FAR_RANGE());
      ds.field("SWATH_LENGTH", &self.SWATH_LENGTH());
      ds.field("AGJSON", &self.AGJSON());
      ds.field("ATEXT", &self.ATEXT());
      ds.field("ATYPE", &self.ATYPE());
      ds.field("COORD_SYS", &self.COORD_SYS());
      ds.field("SPACING_RANGE", &self.SPACING_RANGE());
      ds.field("SPACING_AZIMUTH", &self.SPACING_AZIMUTH());
      ds.field("LOOKS_AZIMUTH", &self.LOOKS_AZIMUTH());
      ds.field("LOOKS_RANGE", &self.LOOKS_RANGE());
      ds.field("RESOLUTION_RANGE", &self.RESOLUTION_RANGE());
      ds.field("RESOLUTION_AZIMUTH", &self.RESOLUTION_AZIMUTH());
      ds.field("OB_DIRECTION", &self.OB_DIRECTION());
      ds.field("TARGETPOSX", &self.TARGETPOSX());
      ds.field("TARGETPOSY", &self.TARGETPOSY());
      ds.field("TARGETPOSZ", &self.TARGETPOSZ());
      ds.field("SENALT", &self.SENALT());
      ds.field("SENVELX", &self.SENVELX());
      ds.field("SENVELY", &self.SENVELY());
      ds.field("SENVELZ", &self.SENVELZ());
      ds.field("SENLAT_START", &self.SENLAT_START());
      ds.field("SENLON_START", &self.SENLON_START());
      ds.field("SENLAT_END", &self.SENLAT_END());
      ds.field("SENLON_END", &self.SENLON_END());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("TAGS", &self.TAGS());
      ds.field("SRC_TYPS", &self.SRC_TYPS());
      ds.field("SRC_IDS", &self.SRC_IDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SART {
  pub ID: Option<String>,
  pub SAT_NO: u32,
  pub ORIG_OBJECT_ID: Option<String>,
  pub ON_ORBIT: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub EXTERNAL_ID: Option<String>,
  pub COLLECTION_ID: Option<String>,
  pub DETECTION_ID: Option<String>,
  pub COLLECTION_START: Option<String>,
  pub COLLECTION_END: Option<String>,
  pub CENTER_TIME: Option<String>,
  pub DETECTION_START: Option<String>,
  pub DETECTION_END: Option<String>,
  pub DWELL_TIME: f64,
  pub ORBIT_STATE: Option<String>,
  pub SAR_MODE: sarMode,
  pub OPERATING_BAND: Option<String>,
  pub OPERATING_FREQ: f64,
  pub SNR: f64,
  pub TX_POLARIZATION: sarPolarization,
  pub RX_POLARIZATION: sarPolarization,
  pub GRAZE_ANGLE: f64,
  pub INCIDENCE_ANGLE: f64,
  pub SQUINT_ANGLE: f64,
  pub PULSE_BANDWIDTH: f64,
  pub PULSE_DURATION: f64,
  pub CONTINUOUS_SPOT_ANGLE: f64,
  pub SLANT_RANGE: f64,
  pub NEAR_RANGE: f64,
  pub FAR_RANGE: f64,
  pub SWATH_LENGTH: f64,
  pub AGJSON: Option<String>,
  pub ATEXT: Option<String>,
  pub ATYPE: Option<String>,
  pub COORD_SYS: Option<String>,
  pub SPACING_RANGE: f64,
  pub SPACING_AZIMUTH: f64,
  pub LOOKS_AZIMUTH: u8,
  pub LOOKS_RANGE: u8,
  pub RESOLUTION_RANGE: f64,
  pub RESOLUTION_AZIMUTH: f64,
  pub OB_DIRECTION: Option<String>,
  pub TARGETPOSX: f64,
  pub TARGETPOSY: f64,
  pub TARGETPOSZ: f64,
  pub SENALT: f64,
  pub SENVELX: f64,
  pub SENVELY: f64,
  pub SENVELZ: f64,
  pub SENLAT_START: f64,
  pub SENLON_START: f64,
  pub SENLAT_END: f64,
  pub SENLON_END: f64,
  pub TRANSACTION_ID: Option<String>,
  pub TAGS: Option<Vec<String>>,
  pub SRC_TYPS: Option<Vec<String>>,
  pub SRC_IDS: Option<Vec<String>>,
}
impl Default for SART {
  fn default() -> Self {
    Self {
      ID: None,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ON_ORBIT: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      EXTERNAL_ID: None,
      COLLECTION_ID: None,
      DETECTION_ID: None,
      COLLECTION_START: None,
      COLLECTION_END: None,
      CENTER_TIME: None,
      DETECTION_START: None,
      DETECTION_END: None,
      DWELL_TIME: 0.0,
      ORBIT_STATE: None,
      SAR_MODE: sarMode::STRIPMAP,
      OPERATING_BAND: None,
      OPERATING_FREQ: 0.0,
      SNR: 0.0,
      TX_POLARIZATION: sarPolarization::HH,
      RX_POLARIZATION: sarPolarization::HH,
      GRAZE_ANGLE: 0.0,
      INCIDENCE_ANGLE: 0.0,
      SQUINT_ANGLE: 0.0,
      PULSE_BANDWIDTH: 0.0,
      PULSE_DURATION: 0.0,
      CONTINUOUS_SPOT_ANGLE: 0.0,
      SLANT_RANGE: 0.0,
      NEAR_RANGE: 0.0,
      FAR_RANGE: 0.0,
      SWATH_LENGTH: 0.0,
      AGJSON: None,
      ATEXT: None,
      ATYPE: None,
      COORD_SYS: None,
      SPACING_RANGE: 0.0,
      SPACING_AZIMUTH: 0.0,
      LOOKS_AZIMUTH: 0,
      LOOKS_RANGE: 0,
      RESOLUTION_RANGE: 0.0,
      RESOLUTION_AZIMUTH: 0.0,
      OB_DIRECTION: None,
      TARGETPOSX: 0.0,
      TARGETPOSY: 0.0,
      TARGETPOSZ: 0.0,
      SENALT: 0.0,
      SENVELX: 0.0,
      SENVELY: 0.0,
      SENVELZ: 0.0,
      SENLAT_START: 0.0,
      SENLON_START: 0.0,
      SENLAT_END: 0.0,
      SENLON_END: 0.0,
      TRANSACTION_ID: None,
      TAGS: None,
      SRC_TYPS: None,
      SRC_IDS: None,
    }
  }
}
impl SART {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SAR<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EXTERNAL_ID = self.EXTERNAL_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_ID = self.COLLECTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DETECTION_ID = self.DETECTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_START = self.COLLECTION_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_END = self.COLLECTION_END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CENTER_TIME = self.CENTER_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DETECTION_START = self.DETECTION_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DETECTION_END = self.DETECTION_END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DWELL_TIME = self.DWELL_TIME;
    let ORBIT_STATE = self.ORBIT_STATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAR_MODE = self.SAR_MODE;
    let OPERATING_BAND = self.OPERATING_BAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPERATING_FREQ = self.OPERATING_FREQ;
    let SNR = self.SNR;
    let TX_POLARIZATION = self.TX_POLARIZATION;
    let RX_POLARIZATION = self.RX_POLARIZATION;
    let GRAZE_ANGLE = self.GRAZE_ANGLE;
    let INCIDENCE_ANGLE = self.INCIDENCE_ANGLE;
    let SQUINT_ANGLE = self.SQUINT_ANGLE;
    let PULSE_BANDWIDTH = self.PULSE_BANDWIDTH;
    let PULSE_DURATION = self.PULSE_DURATION;
    let CONTINUOUS_SPOT_ANGLE = self.CONTINUOUS_SPOT_ANGLE;
    let SLANT_RANGE = self.SLANT_RANGE;
    let NEAR_RANGE = self.NEAR_RANGE;
    let FAR_RANGE = self.FAR_RANGE;
    let SWATH_LENGTH = self.SWATH_LENGTH;
    let AGJSON = self.AGJSON.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ATEXT = self.ATEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ATYPE = self.ATYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COORD_SYS = self.COORD_SYS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SPACING_RANGE = self.SPACING_RANGE;
    let SPACING_AZIMUTH = self.SPACING_AZIMUTH;
    let LOOKS_AZIMUTH = self.LOOKS_AZIMUTH;
    let LOOKS_RANGE = self.LOOKS_RANGE;
    let RESOLUTION_RANGE = self.RESOLUTION_RANGE;
    let RESOLUTION_AZIMUTH = self.RESOLUTION_AZIMUTH;
    let OB_DIRECTION = self.OB_DIRECTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TARGETPOSX = self.TARGETPOSX;
    let TARGETPOSY = self.TARGETPOSY;
    let TARGETPOSZ = self.TARGETPOSZ;
    let SENALT = self.SENALT;
    let SENVELX = self.SENVELX;
    let SENVELY = self.SENVELY;
    let SENVELZ = self.SENVELZ;
    let SENLAT_START = self.SENLAT_START;
    let SENLON_START = self.SENLON_START;
    let SENLAT_END = self.SENLAT_END;
    let SENLON_END = self.SENLON_END;
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SRC_TYPS = self.SRC_TYPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SRC_IDS = self.SRC_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    SAR::create(_fbb, &SARArgs{
      ID,
      SAT_NO,
      ORIG_OBJECT_ID,
      ON_ORBIT,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      EXTERNAL_ID,
      COLLECTION_ID,
      DETECTION_ID,
      COLLECTION_START,
      COLLECTION_END,
      CENTER_TIME,
      DETECTION_START,
      DETECTION_END,
      DWELL_TIME,
      ORBIT_STATE,
      SAR_MODE,
      OPERATING_BAND,
      OPERATING_FREQ,
      SNR,
      TX_POLARIZATION,
      RX_POLARIZATION,
      GRAZE_ANGLE,
      INCIDENCE_ANGLE,
      SQUINT_ANGLE,
      PULSE_BANDWIDTH,
      PULSE_DURATION,
      CONTINUOUS_SPOT_ANGLE,
      SLANT_RANGE,
      NEAR_RANGE,
      FAR_RANGE,
      SWATH_LENGTH,
      AGJSON,
      ATEXT,
      ATYPE,
      COORD_SYS,
      SPACING_RANGE,
      SPACING_AZIMUTH,
      LOOKS_AZIMUTH,
      LOOKS_RANGE,
      RESOLUTION_RANGE,
      RESOLUTION_AZIMUTH,
      OB_DIRECTION,
      TARGETPOSX,
      TARGETPOSY,
      TARGETPOSZ,
      SENALT,
      SENVELX,
      SENVELY,
      SENVELZ,
      SENLAT_START,
      SENLON_START,
      SENLAT_END,
      SENLON_END,
      TRANSACTION_ID,
      TAGS,
      SRC_TYPS,
      SRC_IDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SAR`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SAR_unchecked`.
pub fn root_as_SAR(buf: &[u8]) -> Result<SAR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SAR>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SAR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SAR_unchecked`.
pub fn size_prefixed_root_as_SAR(buf: &[u8]) -> Result<SAR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SAR>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SAR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SAR_unchecked`.
pub fn root_as_SAR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SAR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SAR<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SAR` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SAR_unchecked`.
pub fn size_prefixed_root_as_SAR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SAR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SAR<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SAR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SAR`.
pub unsafe fn root_as_SAR_unchecked(buf: &[u8]) -> SAR {
  flatbuffers::root_unchecked::<SAR>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SAR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SAR`.
pub unsafe fn size_prefixed_root_as_SAR_unchecked(buf: &[u8]) -> SAR {
  flatbuffers::size_prefixed_root_unchecked::<SAR>(buf)
}
pub const SAR_IDENTIFIER: &str = "$SAR";

#[inline]
pub fn SAR_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SAR_IDENTIFIER, false)
}

#[inline]
pub fn SAR_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SAR_IDENTIFIER, true)
}

#[inline]
pub fn finish_SAR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SAR<'a>>) {
  fbb.finish(root, Some(SAR_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SAR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SAR<'a>>) {
  fbb.finish_size_prefixed(root, Some(SAR_IDENTIFIER));
}
