// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSILE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSILE_TYPE: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSILE_TYPE: [MissileType; 15] = [
  MissileType::AAM_IR,
  MissileType::AAM_SARH,
  MissileType::AAM_ARH,
  MissileType::SAM_IR,
  MissileType::SAM_SARH,
  MissileType::SAM_COMMAND,
  MissileType::ASM_AR,
  MissileType::ASM_TV,
  MissileType::ASM_LASER,
  MissileType::ATGM_SACLOS,
  MissileType::ATGM_BEAM,
  MissileType::ATGM_TOP,
  MissileType::CRUISE,
  MissileType::BALLISTIC,
  MissileType::TORPEDO,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissileType(pub i8);
#[allow(non_upper_case_globals)]
impl MissileType {
  pub const AAM_IR: Self = Self(0);
  pub const AAM_SARH: Self = Self(1);
  pub const AAM_ARH: Self = Self(2);
  pub const SAM_IR: Self = Self(3);
  pub const SAM_SARH: Self = Self(4);
  pub const SAM_COMMAND: Self = Self(5);
  pub const ASM_AR: Self = Self(6);
  pub const ASM_TV: Self = Self(7);
  pub const ASM_LASER: Self = Self(8);
  pub const ATGM_SACLOS: Self = Self(9);
  pub const ATGM_BEAM: Self = Self(10);
  pub const ATGM_TOP: Self = Self(11);
  pub const CRUISE: Self = Self(12);
  pub const BALLISTIC: Self = Self(13);
  pub const TORPEDO: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AAM_IR,
    Self::AAM_SARH,
    Self::AAM_ARH,
    Self::SAM_IR,
    Self::SAM_SARH,
    Self::SAM_COMMAND,
    Self::ASM_AR,
    Self::ASM_TV,
    Self::ASM_LASER,
    Self::ATGM_SACLOS,
    Self::ATGM_BEAM,
    Self::ATGM_TOP,
    Self::CRUISE,
    Self::BALLISTIC,
    Self::TORPEDO,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AAM_IR => Some("AAM_IR"),
      Self::AAM_SARH => Some("AAM_SARH"),
      Self::AAM_ARH => Some("AAM_ARH"),
      Self::SAM_IR => Some("SAM_IR"),
      Self::SAM_SARH => Some("SAM_SARH"),
      Self::SAM_COMMAND => Some("SAM_COMMAND"),
      Self::ASM_AR => Some("ASM_AR"),
      Self::ASM_TV => Some("ASM_TV"),
      Self::ASM_LASER => Some("ASM_LASER"),
      Self::ATGM_SACLOS => Some("ATGM_SACLOS"),
      Self::ATGM_BEAM => Some("ATGM_BEAM"),
      Self::ATGM_TOP => Some("ATGM_TOP"),
      Self::CRUISE => Some("CRUISE"),
      Self::BALLISTIC => Some("BALLISTIC"),
      Self::TORPEDO => Some("TORPEDO"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissileType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissileType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissileType {
    type Output = MissileType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissileType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissileType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissileType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEEKER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEEKER_TYPE: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEEKER_TYPE: [SeekerType; 13] = [
  SeekerType::NONE,
  SeekerType::IR_UNCOOLED,
  SeekerType::IR_COOLED,
  SeekerType::IR_IMAGING,
  SeekerType::IR_2COLOR,
  SeekerType::RADAR_SARH,
  SeekerType::RADAR_ARH,
  SeekerType::RADAR_PASSIVE,
  SeekerType::TV_OPTICAL,
  SeekerType::LASER_SH,
  SeekerType::GPS_INS,
  SeekerType::ACOUSTIC,
  SeekerType::WIRE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SeekerType(pub i8);
#[allow(non_upper_case_globals)]
impl SeekerType {
  pub const NONE: Self = Self(0);
  pub const IR_UNCOOLED: Self = Self(1);
  pub const IR_COOLED: Self = Self(2);
  pub const IR_IMAGING: Self = Self(3);
  pub const IR_2COLOR: Self = Self(4);
  pub const RADAR_SARH: Self = Self(5);
  pub const RADAR_ARH: Self = Self(6);
  pub const RADAR_PASSIVE: Self = Self(7);
  pub const TV_OPTICAL: Self = Self(8);
  pub const LASER_SH: Self = Self(9);
  pub const GPS_INS: Self = Self(10);
  pub const ACOUSTIC: Self = Self(11);
  pub const WIRE: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::IR_UNCOOLED,
    Self::IR_COOLED,
    Self::IR_IMAGING,
    Self::IR_2COLOR,
    Self::RADAR_SARH,
    Self::RADAR_ARH,
    Self::RADAR_PASSIVE,
    Self::TV_OPTICAL,
    Self::LASER_SH,
    Self::GPS_INS,
    Self::ACOUSTIC,
    Self::WIRE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::IR_UNCOOLED => Some("IR_UNCOOLED"),
      Self::IR_COOLED => Some("IR_COOLED"),
      Self::IR_IMAGING => Some("IR_IMAGING"),
      Self::IR_2COLOR => Some("IR_2COLOR"),
      Self::RADAR_SARH => Some("RADAR_SARH"),
      Self::RADAR_ARH => Some("RADAR_ARH"),
      Self::RADAR_PASSIVE => Some("RADAR_PASSIVE"),
      Self::TV_OPTICAL => Some("TV_OPTICAL"),
      Self::LASER_SH => Some("LASER_SH"),
      Self::GPS_INS => Some("GPS_INS"),
      Self::ACOUSTIC => Some("ACOUSTIC"),
      Self::WIRE => Some("WIRE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SeekerType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SeekerType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SeekerType {
    type Output = SeekerType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SeekerType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SeekerType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SeekerType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GUIDANCE_LAW: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GUIDANCE_LAW: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GUIDANCE_LAW: [GuidanceLaw; 11] = [
  GuidanceLaw::NONE,
  GuidanceLaw::PURE_PURSUIT,
  GuidanceLaw::LEAD_PURSUIT,
  GuidanceLaw::PROPORTIONAL_NAV,
  GuidanceLaw::AUGMENTED_PN,
  GuidanceLaw::OPTIMAL_GUIDANCE,
  GuidanceLaw::COMMAND_LOS,
  GuidanceLaw::BEAM_RIDING,
  GuidanceLaw::TVM,
  GuidanceLaw::LOFT,
  GuidanceLaw::TERRAIN_FOLLOW,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GuidanceLaw(pub i8);
#[allow(non_upper_case_globals)]
impl GuidanceLaw {
  pub const NONE: Self = Self(0);
  pub const PURE_PURSUIT: Self = Self(1);
  pub const LEAD_PURSUIT: Self = Self(2);
  pub const PROPORTIONAL_NAV: Self = Self(3);
  pub const AUGMENTED_PN: Self = Self(4);
  pub const OPTIMAL_GUIDANCE: Self = Self(5);
  pub const COMMAND_LOS: Self = Self(6);
  pub const BEAM_RIDING: Self = Self(7);
  pub const TVM: Self = Self(8);
  pub const LOFT: Self = Self(9);
  pub const TERRAIN_FOLLOW: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PURE_PURSUIT,
    Self::LEAD_PURSUIT,
    Self::PROPORTIONAL_NAV,
    Self::AUGMENTED_PN,
    Self::OPTIMAL_GUIDANCE,
    Self::COMMAND_LOS,
    Self::BEAM_RIDING,
    Self::TVM,
    Self::LOFT,
    Self::TERRAIN_FOLLOW,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PURE_PURSUIT => Some("PURE_PURSUIT"),
      Self::LEAD_PURSUIT => Some("LEAD_PURSUIT"),
      Self::PROPORTIONAL_NAV => Some("PROPORTIONAL_NAV"),
      Self::AUGMENTED_PN => Some("AUGMENTED_PN"),
      Self::OPTIMAL_GUIDANCE => Some("OPTIMAL_GUIDANCE"),
      Self::COMMAND_LOS => Some("COMMAND_LOS"),
      Self::BEAM_RIDING => Some("BEAM_RIDING"),
      Self::TVM => Some("TVM"),
      Self::LOFT => Some("LOFT"),
      Self::TERRAIN_FOLLOW => Some("TERRAIN_FOLLOW"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GuidanceLaw {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GuidanceLaw {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GuidanceLaw {
    type Output = GuidanceLaw;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GuidanceLaw {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GuidanceLaw {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GuidanceLaw {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MISSILE_PHASE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MISSILE_PHASE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MISSILE_PHASE: [MissilePhase; 9] = [
  MissilePhase::CAPTIVE,
  MissilePhase::LAUNCH,
  MissilePhase::BOOST,
  MissilePhase::SUSTAIN,
  MissilePhase::COAST,
  MissilePhase::TERMINAL,
  MissilePhase::INTERCEPT,
  MissilePhase::MISS,
  MissilePhase::SELF_DESTRUCT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MissilePhase(pub i8);
#[allow(non_upper_case_globals)]
impl MissilePhase {
  pub const CAPTIVE: Self = Self(0);
  pub const LAUNCH: Self = Self(1);
  pub const BOOST: Self = Self(2);
  pub const SUSTAIN: Self = Self(3);
  pub const COAST: Self = Self(4);
  pub const TERMINAL: Self = Self(5);
  pub const INTERCEPT: Self = Self(6);
  pub const MISS: Self = Self(7);
  pub const SELF_DESTRUCT: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CAPTIVE,
    Self::LAUNCH,
    Self::BOOST,
    Self::SUSTAIN,
    Self::COAST,
    Self::TERMINAL,
    Self::INTERCEPT,
    Self::MISS,
    Self::SELF_DESTRUCT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CAPTIVE => Some("CAPTIVE"),
      Self::LAUNCH => Some("LAUNCH"),
      Self::BOOST => Some("BOOST"),
      Self::SUSTAIN => Some("SUSTAIN"),
      Self::COAST => Some("COAST"),
      Self::TERMINAL => Some("TERMINAL"),
      Self::INTERCEPT => Some("INTERCEPT"),
      Self::MISS => Some("MISS"),
      Self::SELF_DESTRUCT => Some("SELF_DESTRUCT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MissilePhase {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MissilePhase {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MissilePhase {
    type Output = MissilePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MissilePhase {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MissilePhase {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MissilePhase {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SEEKER_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SEEKER_STATUS: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SEEKER_STATUS: [SeekerStatus; 7] = [
  SeekerStatus::OFF,
  SeekerStatus::CAGED,
  SeekerStatus::UNCAGED,
  SeekerStatus::ACQUIRING,
  SeekerStatus::TRACKING,
  SeekerStatus::MEMORY,
  SeekerStatus::JAMMED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SeekerStatus(pub i8);
#[allow(non_upper_case_globals)]
impl SeekerStatus {
  pub const OFF: Self = Self(0);
  pub const CAGED: Self = Self(1);
  pub const UNCAGED: Self = Self(2);
  pub const ACQUIRING: Self = Self(3);
  pub const TRACKING: Self = Self(4);
  pub const MEMORY: Self = Self(5);
  pub const JAMMED: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OFF,
    Self::CAGED,
    Self::UNCAGED,
    Self::ACQUIRING,
    Self::TRACKING,
    Self::MEMORY,
    Self::JAMMED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OFF => Some("OFF"),
      Self::CAGED => Some("CAGED"),
      Self::UNCAGED => Some("UNCAGED"),
      Self::ACQUIRING => Some("ACQUIRING"),
      Self::TRACKING => Some("TRACKING"),
      Self::MEMORY => Some("MEMORY"),
      Self::JAMMED => Some("JAMMED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SeekerStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SeekerStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SeekerStatus {
    type Output = SeekerStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SeekerStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SeekerStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SeekerStatus {}
pub enum MSLOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Guided Missiles
pub struct MSL<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MSL<'a> {
  type Inner = MSL<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MSL<'a> {
  pub const VT_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_ATTITUDE_X: flatbuffers::VOffsetT = 16;
  pub const VT_ATTITUDE_Y: flatbuffers::VOffsetT = 18;
  pub const VT_ATTITUDE_Z: flatbuffers::VOffsetT = 20;
  pub const VT_ATTITUDE_W: flatbuffers::VOffsetT = 22;
  pub const VT_OMEGA_X: flatbuffers::VOffsetT = 24;
  pub const VT_OMEGA_Y: flatbuffers::VOffsetT = 26;
  pub const VT_OMEGA_Z: flatbuffers::VOffsetT = 28;
  pub const VT_MASS: flatbuffers::VOffsetT = 30;
  pub const VT_MASS_INITIAL: flatbuffers::VOffsetT = 32;
  pub const VT_TARGET_POSITION_X: flatbuffers::VOffsetT = 34;
  pub const VT_TARGET_POSITION_Y: flatbuffers::VOffsetT = 36;
  pub const VT_TARGET_POSITION_Z: flatbuffers::VOffsetT = 38;
  pub const VT_TARGET_VELOCITY_X: flatbuffers::VOffsetT = 40;
  pub const VT_TARGET_VELOCITY_Y: flatbuffers::VOffsetT = 42;
  pub const VT_TARGET_VELOCITY_Z: flatbuffers::VOffsetT = 44;
  pub const VT_MISS_DISTANCE: flatbuffers::VOffsetT = 46;
  pub const VT_SEEKER: flatbuffers::VOffsetT = 48;
  pub const VT_MOTOR: flatbuffers::VOffsetT = 50;
  pub const VT_GUIDANCE_CMD: flatbuffers::VOffsetT = 52;
  pub const VT_PHASE: flatbuffers::VOffsetT = 54;
  pub const VT_GUIDANCE_LAW: flatbuffers::VOffsetT = 56;
  pub const VT_TYPE: flatbuffers::VOffsetT = 58;
  pub const VT_ARMED: flatbuffers::VOffsetT = 60;
  pub const VT_TIME_OF_FLIGHT: flatbuffers::VOffsetT = 62;
  pub const VT_MAX_G: flatbuffers::VOffsetT = 64;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 66;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MSL { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MSLArgs<'args>
  ) -> flatbuffers::WIPOffset<MSL<'bldr>> {
    let mut builder = MSLBuilder::new(_fbb);
    builder.add_MISS_DISTANCE(args.MISS_DISTANCE);
    builder.add_TARGET_VELOCITY_Z(args.TARGET_VELOCITY_Z);
    builder.add_TARGET_VELOCITY_Y(args.TARGET_VELOCITY_Y);
    builder.add_TARGET_VELOCITY_X(args.TARGET_VELOCITY_X);
    builder.add_TARGET_POSITION_Z(args.TARGET_POSITION_Z);
    builder.add_TARGET_POSITION_Y(args.TARGET_POSITION_Y);
    builder.add_TARGET_POSITION_X(args.TARGET_POSITION_X);
    builder.add_MASS_INITIAL(args.MASS_INITIAL);
    builder.add_MASS(args.MASS);
    builder.add_OMEGA_Z(args.OMEGA_Z);
    builder.add_OMEGA_Y(args.OMEGA_Y);
    builder.add_OMEGA_X(args.OMEGA_X);
    builder.add_ATTITUDE_W(args.ATTITUDE_W);
    builder.add_ATTITUDE_Z(args.ATTITUDE_Z);
    builder.add_ATTITUDE_Y(args.ATTITUDE_Y);
    builder.add_ATTITUDE_X(args.ATTITUDE_X);
    builder.add_VELOCITY_Z(args.VELOCITY_Z);
    builder.add_VELOCITY_Y(args.VELOCITY_Y);
    builder.add_VELOCITY_X(args.VELOCITY_X);
    builder.add_POSITION_Z(args.POSITION_Z);
    builder.add_POSITION_Y(args.POSITION_Y);
    builder.add_POSITION_X(args.POSITION_X);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_MAX_G(args.MAX_G);
    builder.add_TIME_OF_FLIGHT(args.TIME_OF_FLIGHT);
    if let Some(x) = args.GUIDANCE_CMD { builder.add_GUIDANCE_CMD(x); }
    if let Some(x) = args.MOTOR { builder.add_MOTOR(x); }
    if let Some(x) = args.SEEKER { builder.add_SEEKER(x); }
    builder.add_ARMED(args.ARMED);
    builder.add_TYPE(args.TYPE);
    builder.add_GUIDANCE_LAW(args.GUIDANCE_LAW);
    builder.add_PHASE(args.PHASE);
    builder.finish()
  }

  pub fn unpack(&self) -> MSLT {
    let POSITION_X = self.POSITION_X();
    let POSITION_Y = self.POSITION_Y();
    let POSITION_Z = self.POSITION_Z();
    let VELOCITY_X = self.VELOCITY_X();
    let VELOCITY_Y = self.VELOCITY_Y();
    let VELOCITY_Z = self.VELOCITY_Z();
    let ATTITUDE_X = self.ATTITUDE_X();
    let ATTITUDE_Y = self.ATTITUDE_Y();
    let ATTITUDE_Z = self.ATTITUDE_Z();
    let ATTITUDE_W = self.ATTITUDE_W();
    let OMEGA_X = self.OMEGA_X();
    let OMEGA_Y = self.OMEGA_Y();
    let OMEGA_Z = self.OMEGA_Z();
    let MASS = self.MASS();
    let MASS_INITIAL = self.MASS_INITIAL();
    let TARGET_POSITION_X = self.TARGET_POSITION_X();
    let TARGET_POSITION_Y = self.TARGET_POSITION_Y();
    let TARGET_POSITION_Z = self.TARGET_POSITION_Z();
    let TARGET_VELOCITY_X = self.TARGET_VELOCITY_X();
    let TARGET_VELOCITY_Y = self.TARGET_VELOCITY_Y();
    let TARGET_VELOCITY_Z = self.TARGET_VELOCITY_Z();
    let MISS_DISTANCE = self.MISS_DISTANCE();
    let SEEKER = self.SEEKER().map(|x| {
      x.to_string()
    });
    let MOTOR = self.MOTOR().map(|x| {
      x.to_string()
    });
    let GUIDANCE_CMD = self.GUIDANCE_CMD().map(|x| {
      x.to_string()
    });
    let PHASE = self.PHASE();
    let GUIDANCE_LAW = self.GUIDANCE_LAW();
    let TYPE = self.TYPE();
    let ARMED = self.ARMED();
    let TIME_OF_FLIGHT = self.TIME_OF_FLIGHT();
    let MAX_G = self.MAX_G();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    MSLT {
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      MASS_INITIAL,
      TARGET_POSITION_X,
      TARGET_POSITION_Y,
      TARGET_POSITION_Z,
      TARGET_VELOCITY_X,
      TARGET_VELOCITY_Y,
      TARGET_VELOCITY_Z,
      MISS_DISTANCE,
      SEEKER,
      MOTOR,
      GUIDANCE_CMD,
      PHASE,
      GUIDANCE_LAW,
      TYPE,
      ARMED,
      TIME_OF_FLIGHT,
      MAX_G,
      RESERVED,
    }
  }

  #[inline]
  pub fn POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_ATTITUDE_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_ATTITUDE_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_ATTITUDE_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_W(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_ATTITUDE_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_OMEGA_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_OMEGA_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_OMEGA_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MASS_INITIAL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_MASS_INITIAL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TARGET_VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_TARGET_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MISS_DISTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MSL::VT_MISS_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEEKER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MSL::VT_SEEKER, None)}
  }
  #[inline]
  pub fn MOTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MSL::VT_MOTOR, None)}
  }
  #[inline]
  pub fn GUIDANCE_CMD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MSL::VT_GUIDANCE_CMD, None)}
  }
  #[inline]
  pub fn PHASE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MSL::VT_PHASE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GUIDANCE_LAW(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MSL::VT_GUIDANCE_LAW, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MSL::VT_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ARMED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(MSL::VT_ARMED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TIME_OF_FLIGHT(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MSL::VT_TIME_OF_FLIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAX_G(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MSL::VT_MAX_G, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(MSL::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for MSL<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("POSITION_X", Self::VT_POSITION_X, false)?
     .visit_field::<f64>("POSITION_Y", Self::VT_POSITION_Y, false)?
     .visit_field::<f64>("POSITION_Z", Self::VT_POSITION_Z, false)?
     .visit_field::<f64>("VELOCITY_X", Self::VT_VELOCITY_X, false)?
     .visit_field::<f64>("VELOCITY_Y", Self::VT_VELOCITY_Y, false)?
     .visit_field::<f64>("VELOCITY_Z", Self::VT_VELOCITY_Z, false)?
     .visit_field::<f64>("ATTITUDE_X", Self::VT_ATTITUDE_X, false)?
     .visit_field::<f64>("ATTITUDE_Y", Self::VT_ATTITUDE_Y, false)?
     .visit_field::<f64>("ATTITUDE_Z", Self::VT_ATTITUDE_Z, false)?
     .visit_field::<f64>("ATTITUDE_W", Self::VT_ATTITUDE_W, false)?
     .visit_field::<f64>("OMEGA_X", Self::VT_OMEGA_X, false)?
     .visit_field::<f64>("OMEGA_Y", Self::VT_OMEGA_Y, false)?
     .visit_field::<f64>("OMEGA_Z", Self::VT_OMEGA_Z, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<f64>("MASS_INITIAL", Self::VT_MASS_INITIAL, false)?
     .visit_field::<f64>("TARGET_POSITION_X", Self::VT_TARGET_POSITION_X, false)?
     .visit_field::<f64>("TARGET_POSITION_Y", Self::VT_TARGET_POSITION_Y, false)?
     .visit_field::<f64>("TARGET_POSITION_Z", Self::VT_TARGET_POSITION_Z, false)?
     .visit_field::<f64>("TARGET_VELOCITY_X", Self::VT_TARGET_VELOCITY_X, false)?
     .visit_field::<f64>("TARGET_VELOCITY_Y", Self::VT_TARGET_VELOCITY_Y, false)?
     .visit_field::<f64>("TARGET_VELOCITY_Z", Self::VT_TARGET_VELOCITY_Z, false)?
     .visit_field::<f64>("MISS_DISTANCE", Self::VT_MISS_DISTANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SEEKER", Self::VT_SEEKER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MOTOR", Self::VT_MOTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GUIDANCE_CMD", Self::VT_GUIDANCE_CMD, false)?
     .visit_field::<u8>("PHASE", Self::VT_PHASE, false)?
     .visit_field::<u8>("GUIDANCE_LAW", Self::VT_GUIDANCE_LAW, false)?
     .visit_field::<u8>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<u8>("ARMED", Self::VT_ARMED, false)?
     .visit_field::<f32>("TIME_OF_FLIGHT", Self::VT_TIME_OF_FLIGHT, false)?
     .visit_field::<f32>("MAX_G", Self::VT_MAX_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct MSLArgs<'a> {
    pub POSITION_X: f64,
    pub POSITION_Y: f64,
    pub POSITION_Z: f64,
    pub VELOCITY_X: f64,
    pub VELOCITY_Y: f64,
    pub VELOCITY_Z: f64,
    pub ATTITUDE_X: f64,
    pub ATTITUDE_Y: f64,
    pub ATTITUDE_Z: f64,
    pub ATTITUDE_W: f64,
    pub OMEGA_X: f64,
    pub OMEGA_Y: f64,
    pub OMEGA_Z: f64,
    pub MASS: f64,
    pub MASS_INITIAL: f64,
    pub TARGET_POSITION_X: f64,
    pub TARGET_POSITION_Y: f64,
    pub TARGET_POSITION_Z: f64,
    pub TARGET_VELOCITY_X: f64,
    pub TARGET_VELOCITY_Y: f64,
    pub TARGET_VELOCITY_Z: f64,
    pub MISS_DISTANCE: f64,
    pub SEEKER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MOTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GUIDANCE_CMD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PHASE: u8,
    pub GUIDANCE_LAW: u8,
    pub TYPE: u8,
    pub ARMED: u8,
    pub TIME_OF_FLIGHT: f32,
    pub MAX_G: f32,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MSLArgs<'a> {
  #[inline]
  fn default() -> Self {
    MSLArgs {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      MASS: 0.0,
      MASS_INITIAL: 0.0,
      TARGET_POSITION_X: 0.0,
      TARGET_POSITION_Y: 0.0,
      TARGET_POSITION_Z: 0.0,
      TARGET_VELOCITY_X: 0.0,
      TARGET_VELOCITY_Y: 0.0,
      TARGET_VELOCITY_Z: 0.0,
      MISS_DISTANCE: 0.0,
      SEEKER: None,
      MOTOR: None,
      GUIDANCE_CMD: None,
      PHASE: 0,
      GUIDANCE_LAW: 0,
      TYPE: 0,
      ARMED: 0,
      TIME_OF_FLIGHT: 0.0,
      MAX_G: 0.0,
      RESERVED: None,
    }
  }
}

pub struct MSLBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MSLBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITION_X(&mut self, POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_POSITION_X, POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Y(&mut self, POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Z(&mut self, POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_X(&mut self, VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Y(&mut self, VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Z(&mut self, VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_X(&mut self, ATTITUDE_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Y(&mut self, ATTITUDE_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Z(&mut self, ATTITUDE_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_W(&mut self, ATTITUDE_W: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_X(&mut self, OMEGA_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Y(&mut self, OMEGA_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Z(&mut self, OMEGA_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_MASS_INITIAL(&mut self, MASS_INITIAL: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_MASS_INITIAL, MASS_INITIAL, 0.0);
  }
  #[inline]
  pub fn add_TARGET_POSITION_X(&mut self, TARGET_POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_POSITION_X, TARGET_POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_TARGET_POSITION_Y(&mut self, TARGET_POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_POSITION_Y, TARGET_POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_TARGET_POSITION_Z(&mut self, TARGET_POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_POSITION_Z, TARGET_POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_TARGET_VELOCITY_X(&mut self, TARGET_VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_VELOCITY_X, TARGET_VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_TARGET_VELOCITY_Y(&mut self, TARGET_VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_VELOCITY_Y, TARGET_VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_TARGET_VELOCITY_Z(&mut self, TARGET_VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_TARGET_VELOCITY_Z, TARGET_VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_MISS_DISTANCE(&mut self, MISS_DISTANCE: f64) {
    self.fbb_.push_slot::<f64>(MSL::VT_MISS_DISTANCE, MISS_DISTANCE, 0.0);
  }
  #[inline]
  pub fn add_SEEKER(&mut self, SEEKER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MSL::VT_SEEKER, SEEKER);
  }
  #[inline]
  pub fn add_MOTOR(&mut self, MOTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MSL::VT_MOTOR, MOTOR);
  }
  #[inline]
  pub fn add_GUIDANCE_CMD(&mut self, GUIDANCE_CMD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MSL::VT_GUIDANCE_CMD, GUIDANCE_CMD);
  }
  #[inline]
  pub fn add_PHASE(&mut self, PHASE: u8) {
    self.fbb_.push_slot::<u8>(MSL::VT_PHASE, PHASE, 0);
  }
  #[inline]
  pub fn add_GUIDANCE_LAW(&mut self, GUIDANCE_LAW: u8) {
    self.fbb_.push_slot::<u8>(MSL::VT_GUIDANCE_LAW, GUIDANCE_LAW, 0);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: u8) {
    self.fbb_.push_slot::<u8>(MSL::VT_TYPE, TYPE, 0);
  }
  #[inline]
  pub fn add_ARMED(&mut self, ARMED: u8) {
    self.fbb_.push_slot::<u8>(MSL::VT_ARMED, ARMED, 0);
  }
  #[inline]
  pub fn add_TIME_OF_FLIGHT(&mut self, TIME_OF_FLIGHT: f32) {
    self.fbb_.push_slot::<f32>(MSL::VT_TIME_OF_FLIGHT, TIME_OF_FLIGHT, 0.0);
  }
  #[inline]
  pub fn add_MAX_G(&mut self, MAX_G: f32) {
    self.fbb_.push_slot::<f32>(MSL::VT_MAX_G, MAX_G, 0.0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MSL::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MSLBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MSLBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MSL<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MSL<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MSL");
      ds.field("POSITION_X", &self.POSITION_X());
      ds.field("POSITION_Y", &self.POSITION_Y());
      ds.field("POSITION_Z", &self.POSITION_Z());
      ds.field("VELOCITY_X", &self.VELOCITY_X());
      ds.field("VELOCITY_Y", &self.VELOCITY_Y());
      ds.field("VELOCITY_Z", &self.VELOCITY_Z());
      ds.field("ATTITUDE_X", &self.ATTITUDE_X());
      ds.field("ATTITUDE_Y", &self.ATTITUDE_Y());
      ds.field("ATTITUDE_Z", &self.ATTITUDE_Z());
      ds.field("ATTITUDE_W", &self.ATTITUDE_W());
      ds.field("OMEGA_X", &self.OMEGA_X());
      ds.field("OMEGA_Y", &self.OMEGA_Y());
      ds.field("OMEGA_Z", &self.OMEGA_Z());
      ds.field("MASS", &self.MASS());
      ds.field("MASS_INITIAL", &self.MASS_INITIAL());
      ds.field("TARGET_POSITION_X", &self.TARGET_POSITION_X());
      ds.field("TARGET_POSITION_Y", &self.TARGET_POSITION_Y());
      ds.field("TARGET_POSITION_Z", &self.TARGET_POSITION_Z());
      ds.field("TARGET_VELOCITY_X", &self.TARGET_VELOCITY_X());
      ds.field("TARGET_VELOCITY_Y", &self.TARGET_VELOCITY_Y());
      ds.field("TARGET_VELOCITY_Z", &self.TARGET_VELOCITY_Z());
      ds.field("MISS_DISTANCE", &self.MISS_DISTANCE());
      ds.field("SEEKER", &self.SEEKER());
      ds.field("MOTOR", &self.MOTOR());
      ds.field("GUIDANCE_CMD", &self.GUIDANCE_CMD());
      ds.field("PHASE", &self.PHASE());
      ds.field("GUIDANCE_LAW", &self.GUIDANCE_LAW());
      ds.field("TYPE", &self.TYPE());
      ds.field("ARMED", &self.ARMED());
      ds.field("TIME_OF_FLIGHT", &self.TIME_OF_FLIGHT());
      ds.field("MAX_G", &self.MAX_G());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MSLT {
  pub POSITION_X: f64,
  pub POSITION_Y: f64,
  pub POSITION_Z: f64,
  pub VELOCITY_X: f64,
  pub VELOCITY_Y: f64,
  pub VELOCITY_Z: f64,
  pub ATTITUDE_X: f64,
  pub ATTITUDE_Y: f64,
  pub ATTITUDE_Z: f64,
  pub ATTITUDE_W: f64,
  pub OMEGA_X: f64,
  pub OMEGA_Y: f64,
  pub OMEGA_Z: f64,
  pub MASS: f64,
  pub MASS_INITIAL: f64,
  pub TARGET_POSITION_X: f64,
  pub TARGET_POSITION_Y: f64,
  pub TARGET_POSITION_Z: f64,
  pub TARGET_VELOCITY_X: f64,
  pub TARGET_VELOCITY_Y: f64,
  pub TARGET_VELOCITY_Z: f64,
  pub MISS_DISTANCE: f64,
  pub SEEKER: Option<String>,
  pub MOTOR: Option<String>,
  pub GUIDANCE_CMD: Option<String>,
  pub PHASE: u8,
  pub GUIDANCE_LAW: u8,
  pub TYPE: u8,
  pub ARMED: u8,
  pub TIME_OF_FLIGHT: f32,
  pub MAX_G: f32,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for MSLT {
  fn default() -> Self {
    Self {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      MASS: 0.0,
      MASS_INITIAL: 0.0,
      TARGET_POSITION_X: 0.0,
      TARGET_POSITION_Y: 0.0,
      TARGET_POSITION_Z: 0.0,
      TARGET_VELOCITY_X: 0.0,
      TARGET_VELOCITY_Y: 0.0,
      TARGET_VELOCITY_Z: 0.0,
      MISS_DISTANCE: 0.0,
      SEEKER: None,
      MOTOR: None,
      GUIDANCE_CMD: None,
      PHASE: 0,
      GUIDANCE_LAW: 0,
      TYPE: 0,
      ARMED: 0,
      TIME_OF_FLIGHT: 0.0,
      MAX_G: 0.0,
      RESERVED: None,
    }
  }
}
impl MSLT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MSL<'b>> {
    let POSITION_X = self.POSITION_X;
    let POSITION_Y = self.POSITION_Y;
    let POSITION_Z = self.POSITION_Z;
    let VELOCITY_X = self.VELOCITY_X;
    let VELOCITY_Y = self.VELOCITY_Y;
    let VELOCITY_Z = self.VELOCITY_Z;
    let ATTITUDE_X = self.ATTITUDE_X;
    let ATTITUDE_Y = self.ATTITUDE_Y;
    let ATTITUDE_Z = self.ATTITUDE_Z;
    let ATTITUDE_W = self.ATTITUDE_W;
    let OMEGA_X = self.OMEGA_X;
    let OMEGA_Y = self.OMEGA_Y;
    let OMEGA_Z = self.OMEGA_Z;
    let MASS = self.MASS;
    let MASS_INITIAL = self.MASS_INITIAL;
    let TARGET_POSITION_X = self.TARGET_POSITION_X;
    let TARGET_POSITION_Y = self.TARGET_POSITION_Y;
    let TARGET_POSITION_Z = self.TARGET_POSITION_Z;
    let TARGET_VELOCITY_X = self.TARGET_VELOCITY_X;
    let TARGET_VELOCITY_Y = self.TARGET_VELOCITY_Y;
    let TARGET_VELOCITY_Z = self.TARGET_VELOCITY_Z;
    let MISS_DISTANCE = self.MISS_DISTANCE;
    let SEEKER = self.SEEKER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MOTOR = self.MOTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GUIDANCE_CMD = self.GUIDANCE_CMD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PHASE = self.PHASE;
    let GUIDANCE_LAW = self.GUIDANCE_LAW;
    let TYPE = self.TYPE;
    let ARMED = self.ARMED;
    let TIME_OF_FLIGHT = self.TIME_OF_FLIGHT;
    let MAX_G = self.MAX_G;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    MSL::create(_fbb, &MSLArgs{
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      MASS_INITIAL,
      TARGET_POSITION_X,
      TARGET_POSITION_Y,
      TARGET_POSITION_Z,
      TARGET_VELOCITY_X,
      TARGET_VELOCITY_Y,
      TARGET_VELOCITY_Z,
      MISS_DISTANCE,
      SEEKER,
      MOTOR,
      GUIDANCE_CMD,
      PHASE,
      GUIDANCE_LAW,
      TYPE,
      ARMED,
      TIME_OF_FLIGHT,
      MAX_G,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MSL`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MSL_unchecked`.
pub fn root_as_MSL(buf: &[u8]) -> Result<MSL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MSL>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MSL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_MSL_unchecked`.
pub fn size_prefixed_root_as_MSL(buf: &[u8]) -> Result<MSL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MSL>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MSL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MSL_unchecked`.
pub fn root_as_MSL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MSL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MSL<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MSL` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MSL_unchecked`.
pub fn size_prefixed_root_as_MSL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MSL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MSL<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MSL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MSL`.
pub unsafe fn root_as_MSL_unchecked(buf: &[u8]) -> MSL {
  flatbuffers::root_unchecked::<MSL>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MSL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MSL`.
pub unsafe fn size_prefixed_root_as_MSL_unchecked(buf: &[u8]) -> MSL {
  flatbuffers::size_prefixed_root_unchecked::<MSL>(buf)
}
pub const MSL_IDENTIFIER: &str = "$MSL";

#[inline]
pub fn MSL_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MSL_IDENTIFIER, false)
}

#[inline]
pub fn MSL_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MSL_IDENTIFIER, true)
}

#[inline]
pub fn finish_MSL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MSL<'a>>) {
  fbb.finish(root, Some(MSL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_MSL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MSL<'a>>) {
  fbb.finish_size_prefixed(root, Some(MSL_IDENTIFIER));
}
