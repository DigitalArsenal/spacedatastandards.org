// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ROTOR_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ROTOR_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ROTOR_TYPE: [RotorType; 6] = [
  RotorType::MAIN,
  RotorType::TAIL,
  RotorType::TANDEM_FRONT,
  RotorType::TANDEM_REAR,
  RotorType::COAXIAL_UPPER,
  RotorType::COAXIAL_LOWER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RotorType(pub i8);
#[allow(non_upper_case_globals)]
impl RotorType {
  pub const MAIN: Self = Self(0);
  pub const TAIL: Self = Self(1);
  pub const TANDEM_FRONT: Self = Self(2);
  pub const TANDEM_REAR: Self = Self(3);
  pub const COAXIAL_UPPER: Self = Self(4);
  pub const COAXIAL_LOWER: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MAIN,
    Self::TAIL,
    Self::TANDEM_FRONT,
    Self::TANDEM_REAR,
    Self::COAXIAL_UPPER,
    Self::COAXIAL_LOWER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MAIN => Some("MAIN"),
      Self::TAIL => Some("TAIL"),
      Self::TANDEM_FRONT => Some("TANDEM_FRONT"),
      Self::TANDEM_REAR => Some("TANDEM_REAR"),
      Self::COAXIAL_UPPER => Some("COAXIAL_UPPER"),
      Self::COAXIAL_LOWER => Some("COAXIAL_LOWER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RotorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RotorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RotorType {
    type Output = RotorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RotorType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RotorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RotorType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ROTOR_FLAGS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ROTOR_FLAGS: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ROTOR_FLAGS: [RotorFlags; 7] = [
  RotorFlags::NORMAL,
  RotorFlags::VRS_WARNING,
  RotorFlags::VRS_ACTIVE,
  RotorFlags::RBS_WARNING,
  RotorFlags::RBS_ACTIVE,
  RotorFlags::OVERSPEED,
  RotorFlags::UNDERSPEED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RotorFlags(pub i8);
#[allow(non_upper_case_globals)]
impl RotorFlags {
  pub const NORMAL: Self = Self(0);
  pub const VRS_WARNING: Self = Self(1);
  pub const VRS_ACTIVE: Self = Self(2);
  pub const RBS_WARNING: Self = Self(3);
  pub const RBS_ACTIVE: Self = Self(4);
  pub const OVERSPEED: Self = Self(5);
  pub const UNDERSPEED: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::VRS_WARNING,
    Self::VRS_ACTIVE,
    Self::RBS_WARNING,
    Self::RBS_ACTIVE,
    Self::OVERSPEED,
    Self::UNDERSPEED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::VRS_WARNING => Some("VRS_WARNING"),
      Self::VRS_ACTIVE => Some("VRS_ACTIVE"),
      Self::RBS_WARNING => Some("RBS_WARNING"),
      Self::RBS_ACTIVE => Some("RBS_ACTIVE"),
      Self::OVERSPEED => Some("OVERSPEED"),
      Self::UNDERSPEED => Some("UNDERSPEED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RotorFlags {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RotorFlags {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RotorFlags {
    type Output = RotorFlags;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RotorFlags {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RotorFlags {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RotorFlags {}
pub enum HELOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Helicopter Dynamics
pub struct HEL<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HEL<'a> {
  type Inner = HEL<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HEL<'a> {
  pub const VT_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_QUAT_W: flatbuffers::VOffsetT = 16;
  pub const VT_QUAT_X: flatbuffers::VOffsetT = 18;
  pub const VT_QUAT_Y: flatbuffers::VOffsetT = 20;
  pub const VT_QUAT_Z: flatbuffers::VOffsetT = 22;
  pub const VT_OMEGA_BODY_X: flatbuffers::VOffsetT = 24;
  pub const VT_OMEGA_BODY_Y: flatbuffers::VOffsetT = 26;
  pub const VT_OMEGA_BODY_Z: flatbuffers::VOffsetT = 28;
  pub const VT_MAIN_ROTOR: flatbuffers::VOffsetT = 30;
  pub const VT_TAIL_ROTOR: flatbuffers::VOffsetT = 32;
  pub const VT_ENGINE_N1: flatbuffers::VOffsetT = 34;
  pub const VT_ENGINE_TORQUE: flatbuffers::VOffsetT = 36;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 38;
  pub const VT_FUEL_REMAINING: flatbuffers::VOffsetT = 40;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HEL { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HELArgs<'args>
  ) -> flatbuffers::WIPOffset<HEL<'bldr>> {
    let mut builder = HELBuilder::new(_fbb);
    builder.add_ENGINE_TORQUE(args.ENGINE_TORQUE);
    builder.add_ENGINE_N1(args.ENGINE_N1);
    builder.add_OMEGA_BODY_Z(args.OMEGA_BODY_Z);
    builder.add_OMEGA_BODY_Y(args.OMEGA_BODY_Y);
    builder.add_OMEGA_BODY_X(args.OMEGA_BODY_X);
    builder.add_QUAT_Z(args.QUAT_Z);
    builder.add_QUAT_Y(args.QUAT_Y);
    builder.add_QUAT_X(args.QUAT_X);
    builder.add_QUAT_W(args.QUAT_W);
    builder.add_VELOCITY_Z(args.VELOCITY_Z);
    builder.add_VELOCITY_Y(args.VELOCITY_Y);
    builder.add_VELOCITY_X(args.VELOCITY_X);
    builder.add_POSITION_Z(args.POSITION_Z);
    builder.add_POSITION_Y(args.POSITION_Y);
    builder.add_POSITION_X(args.POSITION_X);
    builder.add_FUEL_REMAINING(args.FUEL_REMAINING);
    builder.add_FLAGS(args.FLAGS);
    if let Some(x) = args.TAIL_ROTOR { builder.add_TAIL_ROTOR(x); }
    if let Some(x) = args.MAIN_ROTOR { builder.add_MAIN_ROTOR(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HELT {
    let POSITION_X = self.POSITION_X();
    let POSITION_Y = self.POSITION_Y();
    let POSITION_Z = self.POSITION_Z();
    let VELOCITY_X = self.VELOCITY_X();
    let VELOCITY_Y = self.VELOCITY_Y();
    let VELOCITY_Z = self.VELOCITY_Z();
    let QUAT_W = self.QUAT_W();
    let QUAT_X = self.QUAT_X();
    let QUAT_Y = self.QUAT_Y();
    let QUAT_Z = self.QUAT_Z();
    let OMEGA_BODY_X = self.OMEGA_BODY_X();
    let OMEGA_BODY_Y = self.OMEGA_BODY_Y();
    let OMEGA_BODY_Z = self.OMEGA_BODY_Z();
    let MAIN_ROTOR = self.MAIN_ROTOR().map(|x| {
      x.to_string()
    });
    let TAIL_ROTOR = self.TAIL_ROTOR().map(|x| {
      x.to_string()
    });
    let ENGINE_N1 = self.ENGINE_N1();
    let ENGINE_TORQUE = self.ENGINE_TORQUE();
    let FLAGS = self.FLAGS();
    let FUEL_REMAINING = self.FUEL_REMAINING();
    HELT {
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      QUAT_W,
      QUAT_X,
      QUAT_Y,
      QUAT_Z,
      OMEGA_BODY_X,
      OMEGA_BODY_Y,
      OMEGA_BODY_Z,
      MAIN_ROTOR,
      TAIL_ROTOR,
      ENGINE_N1,
      ENGINE_TORQUE,
      FLAGS,
      FUEL_REMAINING,
    }
  }

  #[inline]
  pub fn POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn QUAT_W(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_QUAT_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn QUAT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_QUAT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn QUAT_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_QUAT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn QUAT_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_QUAT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_BODY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_OMEGA_BODY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_BODY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_OMEGA_BODY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_BODY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_OMEGA_BODY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MAIN_ROTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HEL::VT_MAIN_ROTOR, None)}
  }
  #[inline]
  pub fn TAIL_ROTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HEL::VT_TAIL_ROTOR, None)}
  }
  #[inline]
  pub fn ENGINE_N1(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_ENGINE_N1, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ENGINE_TORQUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HEL::VT_ENGINE_TORQUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn FLAGS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(HEL::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FUEL_REMAINING(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(HEL::VT_FUEL_REMAINING, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for HEL<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("POSITION_X", Self::VT_POSITION_X, false)?
     .visit_field::<f64>("POSITION_Y", Self::VT_POSITION_Y, false)?
     .visit_field::<f64>("POSITION_Z", Self::VT_POSITION_Z, false)?
     .visit_field::<f64>("VELOCITY_X", Self::VT_VELOCITY_X, false)?
     .visit_field::<f64>("VELOCITY_Y", Self::VT_VELOCITY_Y, false)?
     .visit_field::<f64>("VELOCITY_Z", Self::VT_VELOCITY_Z, false)?
     .visit_field::<f64>("QUAT_W", Self::VT_QUAT_W, false)?
     .visit_field::<f64>("QUAT_X", Self::VT_QUAT_X, false)?
     .visit_field::<f64>("QUAT_Y", Self::VT_QUAT_Y, false)?
     .visit_field::<f64>("QUAT_Z", Self::VT_QUAT_Z, false)?
     .visit_field::<f64>("OMEGA_BODY_X", Self::VT_OMEGA_BODY_X, false)?
     .visit_field::<f64>("OMEGA_BODY_Y", Self::VT_OMEGA_BODY_Y, false)?
     .visit_field::<f64>("OMEGA_BODY_Z", Self::VT_OMEGA_BODY_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MAIN_ROTOR", Self::VT_MAIN_ROTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TAIL_ROTOR", Self::VT_TAIL_ROTOR, false)?
     .visit_field::<f64>("ENGINE_N1", Self::VT_ENGINE_N1, false)?
     .visit_field::<f64>("ENGINE_TORQUE", Self::VT_ENGINE_TORQUE, false)?
     .visit_field::<u32>("FLAGS", Self::VT_FLAGS, false)?
     .visit_field::<f32>("FUEL_REMAINING", Self::VT_FUEL_REMAINING, false)?
     .finish();
    Ok(())
  }
}
pub struct HELArgs<'a> {
    pub POSITION_X: f64,
    pub POSITION_Y: f64,
    pub POSITION_Z: f64,
    pub VELOCITY_X: f64,
    pub VELOCITY_Y: f64,
    pub VELOCITY_Z: f64,
    pub QUAT_W: f64,
    pub QUAT_X: f64,
    pub QUAT_Y: f64,
    pub QUAT_Z: f64,
    pub OMEGA_BODY_X: f64,
    pub OMEGA_BODY_Y: f64,
    pub OMEGA_BODY_Z: f64,
    pub MAIN_ROTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAIL_ROTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENGINE_N1: f64,
    pub ENGINE_TORQUE: f64,
    pub FLAGS: u32,
    pub FUEL_REMAINING: f32,
}
impl<'a> Default for HELArgs<'a> {
  #[inline]
  fn default() -> Self {
    HELArgs {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      QUAT_W: 0.0,
      QUAT_X: 0.0,
      QUAT_Y: 0.0,
      QUAT_Z: 0.0,
      OMEGA_BODY_X: 0.0,
      OMEGA_BODY_Y: 0.0,
      OMEGA_BODY_Z: 0.0,
      MAIN_ROTOR: None,
      TAIL_ROTOR: None,
      ENGINE_N1: 0.0,
      ENGINE_TORQUE: 0.0,
      FLAGS: 0,
      FUEL_REMAINING: 0.0,
    }
  }
}

pub struct HELBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HELBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITION_X(&mut self, POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_POSITION_X, POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Y(&mut self, POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Z(&mut self, POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_X(&mut self, VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Y(&mut self, VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Z(&mut self, VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_QUAT_W(&mut self, QUAT_W: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_QUAT_W, QUAT_W, 0.0);
  }
  #[inline]
  pub fn add_QUAT_X(&mut self, QUAT_X: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_QUAT_X, QUAT_X, 0.0);
  }
  #[inline]
  pub fn add_QUAT_Y(&mut self, QUAT_Y: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_QUAT_Y, QUAT_Y, 0.0);
  }
  #[inline]
  pub fn add_QUAT_Z(&mut self, QUAT_Z: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_QUAT_Z, QUAT_Z, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_BODY_X(&mut self, OMEGA_BODY_X: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_OMEGA_BODY_X, OMEGA_BODY_X, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_BODY_Y(&mut self, OMEGA_BODY_Y: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_OMEGA_BODY_Y, OMEGA_BODY_Y, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_BODY_Z(&mut self, OMEGA_BODY_Z: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_OMEGA_BODY_Z, OMEGA_BODY_Z, 0.0);
  }
  #[inline]
  pub fn add_MAIN_ROTOR(&mut self, MAIN_ROTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HEL::VT_MAIN_ROTOR, MAIN_ROTOR);
  }
  #[inline]
  pub fn add_TAIL_ROTOR(&mut self, TAIL_ROTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HEL::VT_TAIL_ROTOR, TAIL_ROTOR);
  }
  #[inline]
  pub fn add_ENGINE_N1(&mut self, ENGINE_N1: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_ENGINE_N1, ENGINE_N1, 0.0);
  }
  #[inline]
  pub fn add_ENGINE_TORQUE(&mut self, ENGINE_TORQUE: f64) {
    self.fbb_.push_slot::<f64>(HEL::VT_ENGINE_TORQUE, ENGINE_TORQUE, 0.0);
  }
  #[inline]
  pub fn add_FLAGS(&mut self, FLAGS: u32) {
    self.fbb_.push_slot::<u32>(HEL::VT_FLAGS, FLAGS, 0);
  }
  #[inline]
  pub fn add_FUEL_REMAINING(&mut self, FUEL_REMAINING: f32) {
    self.fbb_.push_slot::<f32>(HEL::VT_FUEL_REMAINING, FUEL_REMAINING, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HELBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HELBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HEL<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HEL<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HEL");
      ds.field("POSITION_X", &self.POSITION_X());
      ds.field("POSITION_Y", &self.POSITION_Y());
      ds.field("POSITION_Z", &self.POSITION_Z());
      ds.field("VELOCITY_X", &self.VELOCITY_X());
      ds.field("VELOCITY_Y", &self.VELOCITY_Y());
      ds.field("VELOCITY_Z", &self.VELOCITY_Z());
      ds.field("QUAT_W", &self.QUAT_W());
      ds.field("QUAT_X", &self.QUAT_X());
      ds.field("QUAT_Y", &self.QUAT_Y());
      ds.field("QUAT_Z", &self.QUAT_Z());
      ds.field("OMEGA_BODY_X", &self.OMEGA_BODY_X());
      ds.field("OMEGA_BODY_Y", &self.OMEGA_BODY_Y());
      ds.field("OMEGA_BODY_Z", &self.OMEGA_BODY_Z());
      ds.field("MAIN_ROTOR", &self.MAIN_ROTOR());
      ds.field("TAIL_ROTOR", &self.TAIL_ROTOR());
      ds.field("ENGINE_N1", &self.ENGINE_N1());
      ds.field("ENGINE_TORQUE", &self.ENGINE_TORQUE());
      ds.field("FLAGS", &self.FLAGS());
      ds.field("FUEL_REMAINING", &self.FUEL_REMAINING());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HELT {
  pub POSITION_X: f64,
  pub POSITION_Y: f64,
  pub POSITION_Z: f64,
  pub VELOCITY_X: f64,
  pub VELOCITY_Y: f64,
  pub VELOCITY_Z: f64,
  pub QUAT_W: f64,
  pub QUAT_X: f64,
  pub QUAT_Y: f64,
  pub QUAT_Z: f64,
  pub OMEGA_BODY_X: f64,
  pub OMEGA_BODY_Y: f64,
  pub OMEGA_BODY_Z: f64,
  pub MAIN_ROTOR: Option<String>,
  pub TAIL_ROTOR: Option<String>,
  pub ENGINE_N1: f64,
  pub ENGINE_TORQUE: f64,
  pub FLAGS: u32,
  pub FUEL_REMAINING: f32,
}
impl Default for HELT {
  fn default() -> Self {
    Self {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      QUAT_W: 0.0,
      QUAT_X: 0.0,
      QUAT_Y: 0.0,
      QUAT_Z: 0.0,
      OMEGA_BODY_X: 0.0,
      OMEGA_BODY_Y: 0.0,
      OMEGA_BODY_Z: 0.0,
      MAIN_ROTOR: None,
      TAIL_ROTOR: None,
      ENGINE_N1: 0.0,
      ENGINE_TORQUE: 0.0,
      FLAGS: 0,
      FUEL_REMAINING: 0.0,
    }
  }
}
impl HELT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<HEL<'b>> {
    let POSITION_X = self.POSITION_X;
    let POSITION_Y = self.POSITION_Y;
    let POSITION_Z = self.POSITION_Z;
    let VELOCITY_X = self.VELOCITY_X;
    let VELOCITY_Y = self.VELOCITY_Y;
    let VELOCITY_Z = self.VELOCITY_Z;
    let QUAT_W = self.QUAT_W;
    let QUAT_X = self.QUAT_X;
    let QUAT_Y = self.QUAT_Y;
    let QUAT_Z = self.QUAT_Z;
    let OMEGA_BODY_X = self.OMEGA_BODY_X;
    let OMEGA_BODY_Y = self.OMEGA_BODY_Y;
    let OMEGA_BODY_Z = self.OMEGA_BODY_Z;
    let MAIN_ROTOR = self.MAIN_ROTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAIL_ROTOR = self.TAIL_ROTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENGINE_N1 = self.ENGINE_N1;
    let ENGINE_TORQUE = self.ENGINE_TORQUE;
    let FLAGS = self.FLAGS;
    let FUEL_REMAINING = self.FUEL_REMAINING;
    HEL::create(_fbb, &HELArgs{
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      QUAT_W,
      QUAT_X,
      QUAT_Y,
      QUAT_Z,
      OMEGA_BODY_X,
      OMEGA_BODY_Y,
      OMEGA_BODY_Z,
      MAIN_ROTOR,
      TAIL_ROTOR,
      ENGINE_N1,
      ENGINE_TORQUE,
      FLAGS,
      FUEL_REMAINING,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `HEL`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HEL_unchecked`.
pub fn root_as_HEL(buf: &[u8]) -> Result<HEL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<HEL>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `HEL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_HEL_unchecked`.
pub fn size_prefixed_root_as_HEL(buf: &[u8]) -> Result<HEL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<HEL>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `HEL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HEL_unchecked`.
pub fn root_as_HEL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HEL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<HEL<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `HEL` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HEL_unchecked`.
pub fn size_prefixed_root_as_HEL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HEL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<HEL<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a HEL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `HEL`.
pub unsafe fn root_as_HEL_unchecked(buf: &[u8]) -> HEL {
  flatbuffers::root_unchecked::<HEL>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed HEL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `HEL`.
pub unsafe fn size_prefixed_root_as_HEL_unchecked(buf: &[u8]) -> HEL {
  flatbuffers::size_prefixed_root_unchecked::<HEL>(buf)
}
pub const HEL_IDENTIFIER: &str = "$HEL";

#[inline]
pub fn HEL_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HEL_IDENTIFIER, false)
}

#[inline]
pub fn HEL_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HEL_IDENTIFIER, true)
}

#[inline]
pub fn finish_HEL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<HEL<'a>>) {
  fbb.finish(root, Some(HEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_HEL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<HEL<'a>>) {
  fbb.finish_size_prefixed(root, Some(HEL_IDENTIFIER));
}
