// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MTI_STANDARD: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MTI_STANDARD: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MTI_STANDARD: [mtiStandard; 4] = [
  mtiStandard::STANAG_4607,
  mtiStandard::STANAG_4545,
  mtiStandard::CUSTOM,
  mtiStandard::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct mtiStandard(pub i8);
#[allow(non_upper_case_globals)]
impl mtiStandard {
  pub const STANAG_4607: Self = Self(0);
  pub const STANAG_4545: Self = Self(1);
  pub const CUSTOM: Self = Self(2);
  pub const UNKNOWN: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STANAG_4607,
    Self::STANAG_4545,
    Self::CUSTOM,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STANAG_4607 => Some("STANAG_4607"),
      Self::STANAG_4545 => Some("STANAG_4545"),
      Self::CUSTOM => Some("CUSTOM"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for mtiStandard {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for mtiStandard {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for mtiStandard {
    type Output = mtiStandard;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for mtiStandard {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for mtiStandard {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for mtiStandard {}
pub enum MTIOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Moving Target Indicator
pub struct MTI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MTI<'a> {
  type Inner = MTI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MTI<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STANDARD: flatbuffers::VOffsetT = 6;
  pub const VT_P3: flatbuffers::VOffsetT = 8;
  pub const VT_P6: flatbuffers::VOffsetT = 10;
  pub const VT_P7: flatbuffers::VOffsetT = 12;
  pub const VT_P8: flatbuffers::VOffsetT = 14;
  pub const VT_P9: flatbuffers::VOffsetT = 16;
  pub const VT_P10: flatbuffers::VOffsetT = 18;
  pub const VT_MISSIONS: flatbuffers::VOffsetT = 20;
  pub const VT_DWELLS: flatbuffers::VOffsetT = 22;
  pub const VT_HRRS: flatbuffers::VOffsetT = 24;
  pub const VT_JOB_DEFS: flatbuffers::VOffsetT = 26;
  pub const VT_FREE_TEXTS: flatbuffers::VOffsetT = 28;
  pub const VT_PLATFORM_LOCS: flatbuffers::VOffsetT = 30;
  pub const VT_JOB_REQUESTS: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MTI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MTIArgs<'args>
  ) -> flatbuffers::WIPOffset<MTI<'bldr>> {
    let mut builder = MTIBuilder::new(_fbb);
    if let Some(x) = args.JOB_REQUESTS { builder.add_JOB_REQUESTS(x); }
    if let Some(x) = args.PLATFORM_LOCS { builder.add_PLATFORM_LOCS(x); }
    if let Some(x) = args.FREE_TEXTS { builder.add_FREE_TEXTS(x); }
    if let Some(x) = args.JOB_DEFS { builder.add_JOB_DEFS(x); }
    if let Some(x) = args.HRRS { builder.add_HRRS(x); }
    if let Some(x) = args.DWELLS { builder.add_DWELLS(x); }
    if let Some(x) = args.MISSIONS { builder.add_MISSIONS(x); }
    builder.add_P9(args.P9);
    if let Some(x) = args.P8 { builder.add_P8(x); }
    if let Some(x) = args.P7 { builder.add_P7(x); }
    if let Some(x) = args.P6 { builder.add_P6(x); }
    if let Some(x) = args.P3 { builder.add_P3(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_P10(args.P10);
    builder.add_STANDARD(args.STANDARD);
    builder.finish()
  }

  pub fn unpack(&self) -> MTIT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let STANDARD = self.STANDARD();
    let P3 = self.P3().map(|x| {
      x.to_string()
    });
    let P6 = self.P6().map(|x| {
      x.to_string()
    });
    let P7 = self.P7().map(|x| {
      x.to_string()
    });
    let P8 = self.P8().map(|x| {
      x.to_string()
    });
    let P9 = self.P9();
    let P10 = self.P10();
    let MISSIONS = self.MISSIONS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DWELLS = self.DWELLS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let HRRS = self.HRRS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let JOB_DEFS = self.JOB_DEFS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let FREE_TEXTS = self.FREE_TEXTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let PLATFORM_LOCS = self.PLATFORM_LOCS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let JOB_REQUESTS = self.JOB_REQUESTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    MTIT {
      ID,
      STANDARD,
      P3,
      P6,
      P7,
      P8,
      P9,
      P10,
      MISSIONS,
      DWELLS,
      HRRS,
      JOB_DEFS,
      FREE_TEXTS,
      PLATFORM_LOCS,
      JOB_REQUESTS,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MTI::VT_ID, None)}
  }
  /// MTI standard (e.g., STANAG 4607)
  #[inline]
  pub fn STANDARD(&self) -> mtiStandard {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<mtiStandard>(MTI::VT_STANDARD, Some(mtiStandard::STANAG_4607)).unwrap()}
  }
  /// Platform type (P3 field)
  #[inline]
  pub fn P3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MTI::VT_P3, None)}
  }
  /// Platform activity (P6 field)
  #[inline]
  pub fn P6(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MTI::VT_P6, None)}
  }
  /// Sensor type (P7 field)
  #[inline]
  pub fn P7(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MTI::VT_P7, None)}
  }
  /// Sensor model (P8 field)
  #[inline]
  pub fn P8(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MTI::VT_P8, None)}
  }
  /// Reference time code (P9)
  #[inline]
  pub fn P9(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(MTI::VT_P9, Some(0)).unwrap()}
  }
  /// Security classification (P10)
  #[inline]
  pub fn P10(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(MTI::VT_P10, Some(0)).unwrap()}
  }
  /// Mission segment identifiers
  #[inline]
  pub fn MISSIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_MISSIONS, None)}
  }
  /// Dwell segment data references
  #[inline]
  pub fn DWELLS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_DWELLS, None)}
  }
  /// High range resolution profile references
  #[inline]
  pub fn HRRS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_HRRS, None)}
  }
  /// Job definition references
  #[inline]
  pub fn JOB_DEFS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_JOB_DEFS, None)}
  }
  /// Free text entries
  #[inline]
  pub fn FREE_TEXTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_FREE_TEXTS, None)}
  }
  /// Platform location data references
  #[inline]
  pub fn PLATFORM_LOCS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_PLATFORM_LOCS, None)}
  }
  /// Job request references
  #[inline]
  pub fn JOB_REQUESTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(MTI::VT_JOB_REQUESTS, None)}
  }
}

impl flatbuffers::Verifiable for MTI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<mtiStandard>("STANDARD", Self::VT_STANDARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("P3", Self::VT_P3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("P6", Self::VT_P6, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("P7", Self::VT_P7, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("P8", Self::VT_P8, false)?
     .visit_field::<u32>("P9", Self::VT_P9, false)?
     .visit_field::<u16>("P10", Self::VT_P10, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MISSIONS", Self::VT_MISSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DWELLS", Self::VT_DWELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("HRRS", Self::VT_HRRS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("JOB_DEFS", Self::VT_JOB_DEFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("FREE_TEXTS", Self::VT_FREE_TEXTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("PLATFORM_LOCS", Self::VT_PLATFORM_LOCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("JOB_REQUESTS", Self::VT_JOB_REQUESTS, false)?
     .finish();
    Ok(())
  }
}
pub struct MTIArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STANDARD: mtiStandard,
    pub P3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub P6: Option<flatbuffers::WIPOffset<&'a str>>,
    pub P7: Option<flatbuffers::WIPOffset<&'a str>>,
    pub P8: Option<flatbuffers::WIPOffset<&'a str>>,
    pub P9: u32,
    pub P10: u16,
    pub MISSIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DWELLS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub HRRS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub JOB_DEFS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub FREE_TEXTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub PLATFORM_LOCS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub JOB_REQUESTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for MTIArgs<'a> {
  #[inline]
  fn default() -> Self {
    MTIArgs {
      ID: None,
      STANDARD: mtiStandard::STANAG_4607,
      P3: None,
      P6: None,
      P7: None,
      P8: None,
      P9: 0,
      P10: 0,
      MISSIONS: None,
      DWELLS: None,
      HRRS: None,
      JOB_DEFS: None,
      FREE_TEXTS: None,
      PLATFORM_LOCS: None,
      JOB_REQUESTS: None,
    }
  }
}

pub struct MTIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MTIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_ID, ID);
  }
  #[inline]
  pub fn add_STANDARD(&mut self, STANDARD: mtiStandard) {
    self.fbb_.push_slot::<mtiStandard>(MTI::VT_STANDARD, STANDARD, mtiStandard::STANAG_4607);
  }
  #[inline]
  pub fn add_P3(&mut self, P3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_P3, P3);
  }
  #[inline]
  pub fn add_P6(&mut self, P6: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_P6, P6);
  }
  #[inline]
  pub fn add_P7(&mut self, P7: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_P7, P7);
  }
  #[inline]
  pub fn add_P8(&mut self, P8: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_P8, P8);
  }
  #[inline]
  pub fn add_P9(&mut self, P9: u32) {
    self.fbb_.push_slot::<u32>(MTI::VT_P9, P9, 0);
  }
  #[inline]
  pub fn add_P10(&mut self, P10: u16) {
    self.fbb_.push_slot::<u16>(MTI::VT_P10, P10, 0);
  }
  #[inline]
  pub fn add_MISSIONS(&mut self, MISSIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_MISSIONS, MISSIONS);
  }
  #[inline]
  pub fn add_DWELLS(&mut self, DWELLS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_DWELLS, DWELLS);
  }
  #[inline]
  pub fn add_HRRS(&mut self, HRRS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_HRRS, HRRS);
  }
  #[inline]
  pub fn add_JOB_DEFS(&mut self, JOB_DEFS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_JOB_DEFS, JOB_DEFS);
  }
  #[inline]
  pub fn add_FREE_TEXTS(&mut self, FREE_TEXTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_FREE_TEXTS, FREE_TEXTS);
  }
  #[inline]
  pub fn add_PLATFORM_LOCS(&mut self, PLATFORM_LOCS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_PLATFORM_LOCS, PLATFORM_LOCS);
  }
  #[inline]
  pub fn add_JOB_REQUESTS(&mut self, JOB_REQUESTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MTI::VT_JOB_REQUESTS, JOB_REQUESTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MTIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MTIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MTI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MTI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MTI");
      ds.field("ID", &self.ID());
      ds.field("STANDARD", &self.STANDARD());
      ds.field("P3", &self.P3());
      ds.field("P6", &self.P6());
      ds.field("P7", &self.P7());
      ds.field("P8", &self.P8());
      ds.field("P9", &self.P9());
      ds.field("P10", &self.P10());
      ds.field("MISSIONS", &self.MISSIONS());
      ds.field("DWELLS", &self.DWELLS());
      ds.field("HRRS", &self.HRRS());
      ds.field("JOB_DEFS", &self.JOB_DEFS());
      ds.field("FREE_TEXTS", &self.FREE_TEXTS());
      ds.field("PLATFORM_LOCS", &self.PLATFORM_LOCS());
      ds.field("JOB_REQUESTS", &self.JOB_REQUESTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MTIT {
  pub ID: Option<String>,
  pub STANDARD: mtiStandard,
  pub P3: Option<String>,
  pub P6: Option<String>,
  pub P7: Option<String>,
  pub P8: Option<String>,
  pub P9: u32,
  pub P10: u16,
  pub MISSIONS: Option<Vec<String>>,
  pub DWELLS: Option<Vec<String>>,
  pub HRRS: Option<Vec<String>>,
  pub JOB_DEFS: Option<Vec<String>>,
  pub FREE_TEXTS: Option<Vec<String>>,
  pub PLATFORM_LOCS: Option<Vec<String>>,
  pub JOB_REQUESTS: Option<Vec<String>>,
}
impl Default for MTIT {
  fn default() -> Self {
    Self {
      ID: None,
      STANDARD: mtiStandard::STANAG_4607,
      P3: None,
      P6: None,
      P7: None,
      P8: None,
      P9: 0,
      P10: 0,
      MISSIONS: None,
      DWELLS: None,
      HRRS: None,
      JOB_DEFS: None,
      FREE_TEXTS: None,
      PLATFORM_LOCS: None,
      JOB_REQUESTS: None,
    }
  }
}
impl MTIT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MTI<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STANDARD = self.STANDARD;
    let P3 = self.P3.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let P6 = self.P6.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let P7 = self.P7.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let P8 = self.P8.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let P9 = self.P9;
    let P10 = self.P10;
    let MISSIONS = self.MISSIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DWELLS = self.DWELLS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let HRRS = self.HRRS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let JOB_DEFS = self.JOB_DEFS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let FREE_TEXTS = self.FREE_TEXTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let PLATFORM_LOCS = self.PLATFORM_LOCS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let JOB_REQUESTS = self.JOB_REQUESTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    MTI::create(_fbb, &MTIArgs{
      ID,
      STANDARD,
      P3,
      P6,
      P7,
      P8,
      P9,
      P10,
      MISSIONS,
      DWELLS,
      HRRS,
      JOB_DEFS,
      FREE_TEXTS,
      PLATFORM_LOCS,
      JOB_REQUESTS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MTI`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MTI_unchecked`.
pub fn root_as_MTI(buf: &[u8]) -> Result<MTI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MTI>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MTI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_MTI_unchecked`.
pub fn size_prefixed_root_as_MTI(buf: &[u8]) -> Result<MTI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MTI>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MTI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MTI_unchecked`.
pub fn root_as_MTI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MTI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MTI<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MTI` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MTI_unchecked`.
pub fn size_prefixed_root_as_MTI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MTI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MTI<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MTI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MTI`.
pub unsafe fn root_as_MTI_unchecked(buf: &[u8]) -> MTI {
  flatbuffers::root_unchecked::<MTI>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MTI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MTI`.
pub unsafe fn size_prefixed_root_as_MTI_unchecked(buf: &[u8]) -> MTI {
  flatbuffers::size_prefixed_root_unchecked::<MTI>(buf)
}
pub const MTI_IDENTIFIER: &str = "$MTI";

#[inline]
pub fn MTI_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_IDENTIFIER, false)
}

#[inline]
pub fn MTI_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MTI_IDENTIFIER, true)
}

#[inline]
pub fn finish_MTI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MTI<'a>>) {
  fbb.finish(root, Some(MTI_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_MTI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MTI<'a>>) {
  fbb.finish_size_prefixed(root, Some(MTI_IDENTIFIER));
}
