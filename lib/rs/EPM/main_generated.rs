// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LDIFATTRIBUTE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LDIFATTRIBUTE_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LDIFATTRIBUTE_TYPE: [LDIFAttributeType; 6] = [
  LDIFAttributeType::CN,
  LDIFAttributeType::OU,
  LDIFAttributeType::O,
  LDIFAttributeType::DC,
  LDIFAttributeType::C,
  LDIFAttributeType::SN,
];

/// Enumeration for LDAP attribute types relevant to Distinguished Names
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LDIFAttributeType(pub i8);
#[allow(non_upper_case_globals)]
impl LDIFAttributeType {
  /// Common Name
  pub const CN: Self = Self(0);
  /// Organizational Unit Name
  pub const OU: Self = Self(1);
  /// Organization Name
  pub const O: Self = Self(2);
  /// Domain Component
  pub const DC: Self = Self(3);
  /// Country Name
  pub const C: Self = Self(4);
  /// Surname
  pub const SN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CN,
    Self::OU,
    Self::O,
    Self::DC,
    Self::C,
    Self::SN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CN => Some("CN"),
      Self::OU => Some("OU"),
      Self::O => Some("O"),
      Self::DC => Some("DC"),
      Self::C => Some("C"),
      Self::SN => Some("SN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LDIFAttributeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LDIFAttributeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LDIFAttributeType {
    type Output = LDIFAttributeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LDIFAttributeType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LDIFAttributeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LDIFAttributeType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SPECIFIC_ATTRIBUTES: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SPECIFIC_ATTRIBUTES: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPECIFIC_ATTRIBUTES: [SpecificAttributes; 3] = [
  SpecificAttributes::NONE,
  SpecificAttributes::PersonAttributes,
  SpecificAttributes::OrganizationAttributes,
];

/// Union for specific attributes, distinguishing between Person and Organization
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SpecificAttributes(pub u8);
#[allow(non_upper_case_globals)]
impl SpecificAttributes {
  pub const NONE: Self = Self(0);
  pub const PersonAttributes: Self = Self(1);
  pub const OrganizationAttributes: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PersonAttributes,
    Self::OrganizationAttributes,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PersonAttributes => Some("PersonAttributes"),
      Self::OrganizationAttributes => Some("OrganizationAttributes"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SpecificAttributes {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SpecificAttributes {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SpecificAttributes {
    type Output = SpecificAttributes;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SpecificAttributes {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SpecificAttributes {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SpecificAttributes {}
pub struct SpecificAttributesUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum SpecificAttributesT {
  NONE,
  PersonAttributes(Box<PersonAttributesT>),
  OrganizationAttributes(Box<OrganizationAttributesT>),
}
impl Default for SpecificAttributesT {
  fn default() -> Self {
    Self::NONE
  }
}
impl SpecificAttributesT {
  pub fn specific_attributes_type(&self) -> SpecificAttributes {
    match self {
      Self::NONE => SpecificAttributes::NONE,
      Self::PersonAttributes(_) => SpecificAttributes::PersonAttributes,
      Self::OrganizationAttributes(_) => SpecificAttributes::OrganizationAttributes,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::PersonAttributes(v) => Some(v.pack(fbb).as_union_value()),
      Self::OrganizationAttributes(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned PersonAttributesT, setting the union to NONE.
  pub fn take_person_attributes(&mut self) -> Option<Box<PersonAttributesT>> {
    if let Self::PersonAttributes(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PersonAttributes(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PersonAttributesT.
  pub fn as_person_attributes(&self) -> Option<&PersonAttributesT> {
    if let Self::PersonAttributes(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PersonAttributesT.
  pub fn as_person_attributes_mut(&mut self) -> Option<&mut PersonAttributesT> {
    if let Self::PersonAttributes(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned OrganizationAttributesT, setting the union to NONE.
  pub fn take_organization_attributes(&mut self) -> Option<Box<OrganizationAttributesT>> {
    if let Self::OrganizationAttributes(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::OrganizationAttributes(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the OrganizationAttributesT.
  pub fn as_organization_attributes(&self) -> Option<&OrganizationAttributesT> {
    if let Self::OrganizationAttributes(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the OrganizationAttributesT.
  pub fn as_organization_attributes_mut(&mut self) -> Option<&mut OrganizationAttributesT> {
    if let Self::OrganizationAttributes(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum DNComponentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents a component of a Distinguished Name (DN) in LDAP
pub struct DNComponent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DNComponent<'a> {
  type Inner = DNComponent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DNComponent<'a> {
  pub const VT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DNComponent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DNComponentArgs<'args>
  ) -> flatbuffers::WIPOffset<DNComponent<'bldr>> {
    let mut builder = DNComponentBuilder::new(_fbb);
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> DNComponentT {
    let TYPE = self.TYPE();
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    DNComponentT {
      TYPE,
      VALUE,
    }
  }

  /// The type of the DN component
  #[inline]
  pub fn TYPE(&self) -> LDIFAttributeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LDIFAttributeType>(DNComponent::VT_TYPE, Some(LDIFAttributeType::CN)).unwrap()}
  }
  /// The value of the DN component
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DNComponent::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DNComponent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LDIFAttributeType>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DNComponentArgs<'a> {
    pub TYPE: LDIFAttributeType,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DNComponentArgs<'a> {
  #[inline]
  fn default() -> Self {
    DNComponentArgs {
      TYPE: LDIFAttributeType::CN,
      VALUE: None,
    }
  }
}

pub struct DNComponentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DNComponentBuilder<'a, 'b> {
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: LDIFAttributeType) {
    self.fbb_.push_slot::<LDIFAttributeType>(DNComponent::VT_TYPE, TYPE, LDIFAttributeType::CN);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DNComponent::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DNComponentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DNComponentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DNComponent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DNComponent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DNComponent");
      ds.field("TYPE", &self.TYPE());
      ds.field("VALUE", &self.VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DNComponentT {
  pub TYPE: LDIFAttributeType,
  pub VALUE: Option<String>,
}
impl Default for DNComponentT {
  fn default() -> Self {
    Self {
      TYPE: LDIFAttributeType::CN,
      VALUE: None,
    }
  }
}
impl DNComponentT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DNComponent<'b>> {
    let TYPE = self.TYPE;
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    DNComponent::create(_fbb, &DNComponentArgs{
      TYPE,
      VALUE,
    })
  }
}
pub enum DistinguishedNameOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents a Distinguished Name composed of DNComponents
pub struct DistinguishedName<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DistinguishedName<'a> {
  type Inner = DistinguishedName<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DistinguishedName<'a> {
  pub const VT_COMPONENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DistinguishedName { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DistinguishedNameArgs<'args>
  ) -> flatbuffers::WIPOffset<DistinguishedName<'bldr>> {
    let mut builder = DistinguishedNameBuilder::new(_fbb);
    if let Some(x) = args.COMPONENTS { builder.add_COMPONENTS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> DistinguishedNameT {
    let COMPONENTS = self.COMPONENTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    DistinguishedNameT {
      COMPONENTS,
    }
  }

  /// The sequence of components making up the DN
  #[inline]
  pub fn COMPONENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNComponent<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNComponent>>>>(DistinguishedName::VT_COMPONENTS, None)}
  }
}

impl flatbuffers::Verifiable for DistinguishedName<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DNComponent>>>>("COMPONENTS", Self::VT_COMPONENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct DistinguishedNameArgs<'a> {
    pub COMPONENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DNComponent<'a>>>>>,
}
impl<'a> Default for DistinguishedNameArgs<'a> {
  #[inline]
  fn default() -> Self {
    DistinguishedNameArgs {
      COMPONENTS: None,
    }
  }
}

pub struct DistinguishedNameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DistinguishedNameBuilder<'a, 'b> {
  #[inline]
  pub fn add_COMPONENTS(&mut self, COMPONENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DNComponent<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DistinguishedName::VT_COMPONENTS, COMPONENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DistinguishedNameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DistinguishedNameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DistinguishedName<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DistinguishedName<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DistinguishedName");
      ds.field("COMPONENTS", &self.COMPONENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DistinguishedNameT {
  pub COMPONENTS: Option<Vec<DNComponentT>>,
}
impl Default for DistinguishedNameT {
  fn default() -> Self {
    Self {
      COMPONENTS: None,
    }
  }
}
impl DistinguishedNameT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DistinguishedName<'b>> {
    let COMPONENTS = self.COMPONENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    DistinguishedName::create(_fbb, &DistinguishedNameArgs{
      COMPONENTS,
    })
  }
}
pub enum CryptoKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents cryptographic key information
pub struct CryptoKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CryptoKey<'a> {
  type Inner = CryptoKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CryptoKey<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_XPUB: flatbuffers::VOffsetT = 6;
  pub const VT_PRIVATE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_XPRIV: flatbuffers::VOffsetT = 10;
  pub const VT_KEY_ADDRESS: flatbuffers::VOffsetT = 12;
  pub const VT_ADDRESS_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CryptoKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CryptoKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<CryptoKey<'bldr>> {
    let mut builder = CryptoKeyBuilder::new(_fbb);
    if let Some(x) = args.ADDRESS_TYPE { builder.add_ADDRESS_TYPE(x); }
    if let Some(x) = args.KEY_ADDRESS { builder.add_KEY_ADDRESS(x); }
    if let Some(x) = args.XPRIV { builder.add_XPRIV(x); }
    if let Some(x) = args.PRIVATE_KEY { builder.add_PRIVATE_KEY(x); }
    if let Some(x) = args.XPUB { builder.add_XPUB(x); }
    if let Some(x) = args.PUBLIC_KEY { builder.add_PUBLIC_KEY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CryptoKeyT {
    let PUBLIC_KEY = self.PUBLIC_KEY().map(|x| {
      x.to_string()
    });
    let XPUB = self.XPUB().map(|x| {
      x.to_string()
    });
    let PRIVATE_KEY = self.PRIVATE_KEY().map(|x| {
      x.to_string()
    });
    let XPRIV = self.XPRIV().map(|x| {
      x.to_string()
    });
    let KEY_ADDRESS = self.KEY_ADDRESS().map(|x| {
      x.to_string()
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE().map(|x| {
      x.to_string()
    });
    CryptoKeyT {
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    }
  }

  /// Public part of the cryptographic key
  #[inline]
  pub fn PUBLIC_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PUBLIC_KEY, None)}
  }
  /// Extended public key
  #[inline]
  pub fn XPUB(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPUB, None)}
  }
  /// Private part of the cryptographic key, should be kept secret
  #[inline]
  pub fn PRIVATE_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PRIVATE_KEY, None)}
  }
  /// Extended private key
  #[inline]
  pub fn XPRIV(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPRIV, None)}
  }
  /// Address generated from the cryptographic key
  #[inline]
  pub fn KEY_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_KEY_ADDRESS, None)}
  }
  /// Type of the address generated from the cryptographic key
  #[inline]
  pub fn ADDRESS_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_ADDRESS_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for CryptoKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PUBLIC_KEY", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPUB", Self::VT_XPUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PRIVATE_KEY", Self::VT_PRIVATE_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPRIV", Self::VT_XPRIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEY_ADDRESS", Self::VT_KEY_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_TYPE", Self::VT_ADDRESS_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CryptoKeyArgs<'a> {
    pub PUBLIC_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPUB: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIVATE_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPRIV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CryptoKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CryptoKeyArgs {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
    }
  }
}

pub struct CryptoKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CryptoKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_PUBLIC_KEY(&mut self, PUBLIC_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  #[inline]
  pub fn add_XPUB(&mut self, XPUB: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPUB, XPUB);
  }
  #[inline]
  pub fn add_PRIVATE_KEY(&mut self, PRIVATE_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  #[inline]
  pub fn add_XPRIV(&mut self, XPRIV: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPRIV, XPRIV);
  }
  #[inline]
  pub fn add_KEY_ADDRESS(&mut self, KEY_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  #[inline]
  pub fn add_ADDRESS_TYPE(&mut self, ADDRESS_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CryptoKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CryptoKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CryptoKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CryptoKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CryptoKey");
      ds.field("PUBLIC_KEY", &self.PUBLIC_KEY());
      ds.field("XPUB", &self.XPUB());
      ds.field("PRIVATE_KEY", &self.PRIVATE_KEY());
      ds.field("XPRIV", &self.XPRIV());
      ds.field("KEY_ADDRESS", &self.KEY_ADDRESS());
      ds.field("ADDRESS_TYPE", &self.ADDRESS_TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CryptoKeyT {
  pub PUBLIC_KEY: Option<String>,
  pub XPUB: Option<String>,
  pub PRIVATE_KEY: Option<String>,
  pub XPRIV: Option<String>,
  pub KEY_ADDRESS: Option<String>,
  pub ADDRESS_TYPE: Option<String>,
}
impl Default for CryptoKeyT {
  fn default() -> Self {
    Self {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
    }
  }
}
impl CryptoKeyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CryptoKey<'b>> {
    let PUBLIC_KEY = self.PUBLIC_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPUB = self.XPUB.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIVATE_KEY = self.PRIVATE_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPRIV = self.XPRIV.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY_ADDRESS = self.KEY_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CryptoKey::create(_fbb, &CryptoKeyArgs{
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    })
  }
}
pub enum AddressOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents a geographic address
pub struct Address<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Address<'a> {
  type Inner = Address<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Address<'a> {
  pub const VT_COUNTRY: flatbuffers::VOffsetT = 4;
  pub const VT_REGION: flatbuffers::VOffsetT = 6;
  pub const VT_LOCALITY: flatbuffers::VOffsetT = 8;
  pub const VT_POSTAL_CODE: flatbuffers::VOffsetT = 10;
  pub const VT_STREET: flatbuffers::VOffsetT = 12;
  pub const VT_POST_OFFICE_BOX_NUMBER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Address { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddressArgs<'args>
  ) -> flatbuffers::WIPOffset<Address<'bldr>> {
    let mut builder = AddressBuilder::new(_fbb);
    if let Some(x) = args.POST_OFFICE_BOX_NUMBER { builder.add_POST_OFFICE_BOX_NUMBER(x); }
    if let Some(x) = args.STREET { builder.add_STREET(x); }
    if let Some(x) = args.POSTAL_CODE { builder.add_POSTAL_CODE(x); }
    if let Some(x) = args.LOCALITY { builder.add_LOCALITY(x); }
    if let Some(x) = args.REGION { builder.add_REGION(x); }
    if let Some(x) = args.COUNTRY { builder.add_COUNTRY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AddressT {
    let COUNTRY = self.COUNTRY().map(|x| {
      x.to_string()
    });
    let REGION = self.REGION().map(|x| {
      x.to_string()
    });
    let LOCALITY = self.LOCALITY().map(|x| {
      x.to_string()
    });
    let POSTAL_CODE = self.POSTAL_CODE().map(|x| {
      x.to_string()
    });
    let STREET = self.STREET().map(|x| {
      x.to_string()
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER().map(|x| {
      x.to_string()
    });
    AddressT {
      COUNTRY,
      REGION,
      LOCALITY,
      POSTAL_CODE,
      STREET,
      POST_OFFICE_BOX_NUMBER,
    }
  }

  /// Country of the address
  #[inline]
  pub fn COUNTRY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_COUNTRY, None)}
  }
  /// Region of the address (e.g., state or province)
  #[inline]
  pub fn REGION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_REGION, None)}
  }
  /// Locality of the address (e.g., city or town)
  #[inline]
  pub fn LOCALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_LOCALITY, None)}
  }
  /// Postal code of the address
  #[inline]
  pub fn POSTAL_CODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_POSTAL_CODE, None)}
  }
  /// Street address
  #[inline]
  pub fn STREET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_STREET, None)}
  }
  /// Post office box number
  #[inline]
  pub fn POST_OFFICE_BOX_NUMBER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_POST_OFFICE_BOX_NUMBER, None)}
  }
}

impl flatbuffers::Verifiable for Address<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COUNTRY", Self::VT_COUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REGION", Self::VT_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LOCALITY", Self::VT_LOCALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSTAL_CODE", Self::VT_POSTAL_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STREET", Self::VT_STREET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POST_OFFICE_BOX_NUMBER", Self::VT_POST_OFFICE_BOX_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct AddressArgs<'a> {
    pub COUNTRY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REGION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSTAL_CODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STREET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POST_OFFICE_BOX_NUMBER: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AddressArgs<'a> {
  #[inline]
  fn default() -> Self {
    AddressArgs {
      COUNTRY: None,
      REGION: None,
      LOCALITY: None,
      POSTAL_CODE: None,
      STREET: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}

pub struct AddressBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddressBuilder<'a, 'b> {
  #[inline]
  pub fn add_COUNTRY(&mut self, COUNTRY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_COUNTRY, COUNTRY);
  }
  #[inline]
  pub fn add_REGION(&mut self, REGION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_REGION, REGION);
  }
  #[inline]
  pub fn add_LOCALITY(&mut self, LOCALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_LOCALITY, LOCALITY);
  }
  #[inline]
  pub fn add_POSTAL_CODE(&mut self, POSTAL_CODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_POSTAL_CODE, POSTAL_CODE);
  }
  #[inline]
  pub fn add_STREET(&mut self, STREET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_STREET, STREET);
  }
  #[inline]
  pub fn add_POST_OFFICE_BOX_NUMBER(&mut self, POST_OFFICE_BOX_NUMBER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddressBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddressBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Address<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Address<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Address");
      ds.field("COUNTRY", &self.COUNTRY());
      ds.field("REGION", &self.REGION());
      ds.field("LOCALITY", &self.LOCALITY());
      ds.field("POSTAL_CODE", &self.POSTAL_CODE());
      ds.field("STREET", &self.STREET());
      ds.field("POST_OFFICE_BOX_NUMBER", &self.POST_OFFICE_BOX_NUMBER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AddressT {
  pub COUNTRY: Option<String>,
  pub REGION: Option<String>,
  pub LOCALITY: Option<String>,
  pub POSTAL_CODE: Option<String>,
  pub STREET: Option<String>,
  pub POST_OFFICE_BOX_NUMBER: Option<String>,
}
impl Default for AddressT {
  fn default() -> Self {
    Self {
      COUNTRY: None,
      REGION: None,
      LOCALITY: None,
      POSTAL_CODE: None,
      STREET: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}
impl AddressT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Address<'b>> {
    let COUNTRY = self.COUNTRY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REGION = self.REGION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCALITY = self.LOCALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSTAL_CODE = self.POSTAL_CODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STREET = self.STREET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Address::create(_fbb, &AddressArgs{
      COUNTRY,
      REGION,
      LOCALITY,
      POSTAL_CODE,
      STREET,
      POST_OFFICE_BOX_NUMBER,
    })
  }
}
pub enum PersonAttributesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Specific attributes for a Person
pub struct PersonAttributes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PersonAttributes<'a> {
  type Inner = PersonAttributes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PersonAttributes<'a> {
  pub const VT_FAMILY_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_GIVEN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ADDITIONAL_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_HONORIFIC_PREFIX: flatbuffers::VOffsetT = 10;
  pub const VT_HONORIFIC_SUFFIX: flatbuffers::VOffsetT = 12;
  pub const VT_JOB_TITLE: flatbuffers::VOffsetT = 14;
  pub const VT_OCCUPATION: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PersonAttributes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PersonAttributesArgs<'args>
  ) -> flatbuffers::WIPOffset<PersonAttributes<'bldr>> {
    let mut builder = PersonAttributesBuilder::new(_fbb);
    if let Some(x) = args.OCCUPATION { builder.add_OCCUPATION(x); }
    if let Some(x) = args.JOB_TITLE { builder.add_JOB_TITLE(x); }
    if let Some(x) = args.HONORIFIC_SUFFIX { builder.add_HONORIFIC_SUFFIX(x); }
    if let Some(x) = args.HONORIFIC_PREFIX { builder.add_HONORIFIC_PREFIX(x); }
    if let Some(x) = args.ADDITIONAL_NAME { builder.add_ADDITIONAL_NAME(x); }
    if let Some(x) = args.GIVEN_NAME { builder.add_GIVEN_NAME(x); }
    if let Some(x) = args.FAMILY_NAME { builder.add_FAMILY_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PersonAttributesT {
    let FAMILY_NAME = self.FAMILY_NAME().map(|x| {
      x.to_string()
    });
    let GIVEN_NAME = self.GIVEN_NAME().map(|x| {
      x.to_string()
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME().map(|x| {
      x.to_string()
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX().map(|x| {
      x.to_string()
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX().map(|x| {
      x.to_string()
    });
    let JOB_TITLE = self.JOB_TITLE().map(|x| {
      x.to_string()
    });
    let OCCUPATION = self.OCCUPATION().map(|x| {
      x.to_string()
    });
    PersonAttributesT {
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
      JOB_TITLE,
      OCCUPATION,
    }
  }

  /// Family name or surname of the person
  #[inline]
  pub fn FAMILY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_FAMILY_NAME, None)}
  }
  /// Given name or first name of the person
  #[inline]
  pub fn GIVEN_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_GIVEN_NAME, None)}
  }
  /// Additional name or middle name of the person
  #[inline]
  pub fn ADDITIONAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_ADDITIONAL_NAME, None)}
  }
  /// Honorific prefix preceding the person's name (e.g., Mr., Dr.)
  #[inline]
  pub fn HONORIFIC_PREFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_HONORIFIC_PREFIX, None)}
  }
  /// Honorific suffix following the person's name (e.g., Jr., Sr.)
  #[inline]
  pub fn HONORIFIC_SUFFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_HONORIFIC_SUFFIX, None)}
  }
  /// Job title of the person
  #[inline]
  pub fn JOB_TITLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_JOB_TITLE, None)}
  }
  /// Occupation of the person
  #[inline]
  pub fn OCCUPATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PersonAttributes::VT_OCCUPATION, None)}
  }
}

impl flatbuffers::Verifiable for PersonAttributes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FAMILY_NAME", Self::VT_FAMILY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GIVEN_NAME", Self::VT_GIVEN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDITIONAL_NAME", Self::VT_ADDITIONAL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_PREFIX", Self::VT_HONORIFIC_PREFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_SUFFIX", Self::VT_HONORIFIC_SUFFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JOB_TITLE", Self::VT_JOB_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OCCUPATION", Self::VT_OCCUPATION, false)?
     .finish();
    Ok(())
  }
}
pub struct PersonAttributesArgs<'a> {
    pub FAMILY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GIVEN_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDITIONAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_PREFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_SUFFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub JOB_TITLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OCCUPATION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PersonAttributesArgs<'a> {
  #[inline]
  fn default() -> Self {
    PersonAttributesArgs {
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
      JOB_TITLE: None,
      OCCUPATION: None,
    }
  }
}

pub struct PersonAttributesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PersonAttributesBuilder<'a, 'b> {
  #[inline]
  pub fn add_FAMILY_NAME(&mut self, FAMILY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_FAMILY_NAME, FAMILY_NAME);
  }
  #[inline]
  pub fn add_GIVEN_NAME(&mut self, GIVEN_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_GIVEN_NAME, GIVEN_NAME);
  }
  #[inline]
  pub fn add_ADDITIONAL_NAME(&mut self, ADDITIONAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  #[inline]
  pub fn add_HONORIFIC_PREFIX(&mut self, HONORIFIC_PREFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  #[inline]
  pub fn add_HONORIFIC_SUFFIX(&mut self, HONORIFIC_SUFFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  #[inline]
  pub fn add_JOB_TITLE(&mut self, JOB_TITLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_JOB_TITLE, JOB_TITLE);
  }
  #[inline]
  pub fn add_OCCUPATION(&mut self, OCCUPATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PersonAttributes::VT_OCCUPATION, OCCUPATION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PersonAttributesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PersonAttributesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PersonAttributes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PersonAttributes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PersonAttributes");
      ds.field("FAMILY_NAME", &self.FAMILY_NAME());
      ds.field("GIVEN_NAME", &self.GIVEN_NAME());
      ds.field("ADDITIONAL_NAME", &self.ADDITIONAL_NAME());
      ds.field("HONORIFIC_PREFIX", &self.HONORIFIC_PREFIX());
      ds.field("HONORIFIC_SUFFIX", &self.HONORIFIC_SUFFIX());
      ds.field("JOB_TITLE", &self.JOB_TITLE());
      ds.field("OCCUPATION", &self.OCCUPATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PersonAttributesT {
  pub FAMILY_NAME: Option<String>,
  pub GIVEN_NAME: Option<String>,
  pub ADDITIONAL_NAME: Option<String>,
  pub HONORIFIC_PREFIX: Option<String>,
  pub HONORIFIC_SUFFIX: Option<String>,
  pub JOB_TITLE: Option<String>,
  pub OCCUPATION: Option<String>,
}
impl Default for PersonAttributesT {
  fn default() -> Self {
    Self {
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
      JOB_TITLE: None,
      OCCUPATION: None,
    }
  }
}
impl PersonAttributesT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PersonAttributes<'b>> {
    let FAMILY_NAME = self.FAMILY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GIVEN_NAME = self.GIVEN_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let JOB_TITLE = self.JOB_TITLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OCCUPATION = self.OCCUPATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    PersonAttributes::create(_fbb, &PersonAttributesArgs{
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
      JOB_TITLE,
      OCCUPATION,
    })
  }
}
pub enum OrganizationAttributesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Specific attributes for an Organization
pub struct OrganizationAttributes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OrganizationAttributes<'a> {
  type Inner = OrganizationAttributes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OrganizationAttributes<'a> {
  pub const VT_LEGAL_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OrganizationAttributes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OrganizationAttributesArgs<'args>
  ) -> flatbuffers::WIPOffset<OrganizationAttributes<'bldr>> {
    let mut builder = OrganizationAttributesBuilder::new(_fbb);
    if let Some(x) = args.LEGAL_NAME { builder.add_LEGAL_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OrganizationAttributesT {
    let LEGAL_NAME = self.LEGAL_NAME().map(|x| {
      x.to_string()
    });
    OrganizationAttributesT {
      LEGAL_NAME,
    }
  }

  /// Legal name of the organization
  #[inline]
  pub fn LEGAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OrganizationAttributes::VT_LEGAL_NAME, None)}
  }
}

impl flatbuffers::Verifiable for OrganizationAttributes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LEGAL_NAME", Self::VT_LEGAL_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct OrganizationAttributesArgs<'a> {
    pub LEGAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OrganizationAttributesArgs<'a> {
  #[inline]
  fn default() -> Self {
    OrganizationAttributesArgs {
      LEGAL_NAME: None,
    }
  }
}

pub struct OrganizationAttributesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OrganizationAttributesBuilder<'a, 'b> {
  #[inline]
  pub fn add_LEGAL_NAME(&mut self, LEGAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OrganizationAttributes::VT_LEGAL_NAME, LEGAL_NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OrganizationAttributesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OrganizationAttributesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OrganizationAttributes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OrganizationAttributes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OrganizationAttributes");
      ds.field("LEGAL_NAME", &self.LEGAL_NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OrganizationAttributesT {
  pub LEGAL_NAME: Option<String>,
}
impl Default for OrganizationAttributesT {
  fn default() -> Self {
    Self {
      LEGAL_NAME: None,
    }
  }
}
impl OrganizationAttributesT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<OrganizationAttributes<'b>> {
    let LEGAL_NAME = self.LEGAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OrganizationAttributes::create(_fbb, &OrganizationAttributesArgs{
      LEGAL_NAME,
    })
  }
}
pub enum EPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Entity Profile Message
pub struct EPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EPM<'a> {
  type Inner = EPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EPM<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ALTERNATE_NAMES: flatbuffers::VOffsetT = 6;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 8;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 10;
  pub const VT_KEYS: flatbuffers::VOffsetT = 12;
  pub const VT_MULTIFORMAT_ADDRESS: flatbuffers::VOffsetT = 14;
  pub const VT_ATTRIBUTES_TYPE: flatbuffers::VOffsetT = 16;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EPMArgs<'args>
  ) -> flatbuffers::WIPOffset<EPM<'bldr>> {
    let mut builder = EPMBuilder::new(_fbb);
    if let Some(x) = args.ATTRIBUTES { builder.add_ATTRIBUTES(x); }
    if let Some(x) = args.MULTIFORMAT_ADDRESS { builder.add_MULTIFORMAT_ADDRESS(x); }
    if let Some(x) = args.KEYS { builder.add_KEYS(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.ALTERNATE_NAMES { builder.add_ALTERNATE_NAMES(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_ATTRIBUTES_type(args.ATTRIBUTES_type);
    builder.finish()
  }

  pub fn unpack(&self) -> EPMT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ALTERNATE_NAMES = self.ALTERNATE_NAMES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let KEYS = self.KEYS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let MULTIFORMAT_ADDRESS = self.MULTIFORMAT_ADDRESS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ATTRIBUTES = match self.attributes_type() {
      SpecificAttributes::NONE => SpecificAttributesT::NONE,
      SpecificAttributes::PersonAttributes => SpecificAttributesT::PersonAttributes(Box::new(
        self.ATTRIBUTES_as_person_attributes()
            .expect("Invalid union table, expected `SpecificAttributes::PersonAttributes`.")
            .unpack()
      )),
      SpecificAttributes::OrganizationAttributes => SpecificAttributesT::OrganizationAttributes(Box::new(
        self.ATTRIBUTES_as_organization_attributes()
            .expect("Invalid union table, expected `SpecificAttributes::OrganizationAttributes`.")
            .unpack()
      )),
      _ => SpecificAttributesT::NONE,
    };
    EPMT {
      NAME,
      ALTERNATE_NAMES,
      EMAIL,
      TELEPHONE,
      KEYS,
      MULTIFORMAT_ADDRESS,
      ATTRIBUTES,
    }
  }

  /// Common name of the entity (person or organization)
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_NAME, None)}
  }
  /// Alternate names for the entity
  #[inline]
  pub fn ALTERNATE_NAMES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EPM::VT_ALTERNATE_NAMES, None)}
  }
  /// Email address of the entity
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_EMAIL, None)}
  }
  /// Telephone number of the entity
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_TELEPHONE, None)}
  }
  /// Cryptographic keys associated with the entity
  #[inline]
  pub fn KEYS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey>>>>(EPM::VT_KEYS, None)}
  }
  /// Multiformat addresses associated with the entity
  #[inline]
  pub fn MULTIFORMAT_ADDRESS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EPM::VT_MULTIFORMAT_ADDRESS, None)}
  }
  #[inline]
  pub fn ATTRIBUTES_type(&self) -> SpecificAttributes {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SpecificAttributes>(EPM::VT_ATTRIBUTES_TYPE, Some(SpecificAttributes::NONE)).unwrap()}
  }
  /// Specific attributes for the entity, either Person or Organization
  #[inline]
  pub fn ATTRIBUTES(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EPM::VT_ATTRIBUTES, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn ATTRIBUTES_as_person_attributes(&self) -> Option<PersonAttributes<'a>> {
    if self.attributes_type() == SpecificAttributes::PersonAttributes {
      self.ATTRIBUTES().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PersonAttributes::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ATTRIBUTES_as_organization_attributes(&self) -> Option<OrganizationAttributes<'a>> {
    if self.attributes_type() == SpecificAttributes::OrganizationAttributes {
      self.ATTRIBUTES().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { OrganizationAttributes::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for EPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ALTERNATE_NAMES", Self::VT_ALTERNATE_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CryptoKey>>>>("KEYS", Self::VT_KEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MULTIFORMAT_ADDRESS", Self::VT_MULTIFORMAT_ADDRESS, false)?
     .visit_union::<SpecificAttributes, _>("attributes_type", Self::VT_ATTRIBUTES_TYPE, "ATTRIBUTES", Self::VT_ATTRIBUTES, false, |key, v, pos| {
        match key {
          SpecificAttributes::PersonAttributes => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PersonAttributes>>("SpecificAttributes::PersonAttributes", pos),
          SpecificAttributes::OrganizationAttributes => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OrganizationAttributes>>("SpecificAttributes::OrganizationAttributes", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct EPMArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALTERNATE_NAMES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEYS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>>>,
    pub MULTIFORMAT_ADDRESS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ATTRIBUTES_type: SpecificAttributes,
    pub ATTRIBUTES: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    EPMArgs {
      NAME: None,
      ALTERNATE_NAMES: None,
      EMAIL: None,
      TELEPHONE: None,
      KEYS: None,
      MULTIFORMAT_ADDRESS: None,
      ATTRIBUTES_type: SpecificAttributes::NONE,
      ATTRIBUTES: None,
    }
  }
}

pub struct EPMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EPMBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ALTERNATE_NAMES(&mut self, ALTERNATE_NAMES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ALTERNATE_NAMES, ALTERNATE_NAMES);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_KEYS(&mut self, KEYS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CryptoKey<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_KEYS, KEYS);
  }
  #[inline]
  pub fn add_MULTIFORMAT_ADDRESS(&mut self, MULTIFORMAT_ADDRESS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  #[inline]
  pub fn add_ATTRIBUTES_type(&mut self, ATTRIBUTES_type: SpecificAttributes) {
    self.fbb_.push_slot::<SpecificAttributes>(EPM::VT_ATTRIBUTES_TYPE, ATTRIBUTES_type, SpecificAttributes::NONE);
  }
  #[inline]
  pub fn add_ATTRIBUTES(&mut self, ATTRIBUTES: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ATTRIBUTES, ATTRIBUTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EPMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EPM");
      ds.field("NAME", &self.NAME());
      ds.field("ALTERNATE_NAMES", &self.ALTERNATE_NAMES());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("KEYS", &self.KEYS());
      ds.field("MULTIFORMAT_ADDRESS", &self.MULTIFORMAT_ADDRESS());
      ds.field("ATTRIBUTES_type", &self.ATTRIBUTES_type());
      match self.attributes_type() {
        SpecificAttributes::PersonAttributes => {
          if let Some(x) = self.ATTRIBUTES_as_person_attributes() {
            ds.field("ATTRIBUTES", &x)
          } else {
            ds.field("ATTRIBUTES", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        SpecificAttributes::OrganizationAttributes => {
          if let Some(x) = self.ATTRIBUTES_as_organization_attributes() {
            ds.field("ATTRIBUTES", &x)
          } else {
            ds.field("ATTRIBUTES", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("ATTRIBUTES", &x)
        },
      };
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EPMT {
  pub NAME: Option<String>,
  pub ALTERNATE_NAMES: Option<Vec<String>>,
  pub EMAIL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub KEYS: Option<Vec<CryptoKeyT>>,
  pub MULTIFORMAT_ADDRESS: Option<Vec<String>>,
  pub ATTRIBUTES: SpecificAttributesT,
}
impl Default for EPMT {
  fn default() -> Self {
    Self {
      NAME: None,
      ALTERNATE_NAMES: None,
      EMAIL: None,
      TELEPHONE: None,
      KEYS: None,
      MULTIFORMAT_ADDRESS: None,
      ATTRIBUTES: SpecificAttributesT::NONE,
    }
  }
}
impl EPMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EPM<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALTERNATE_NAMES = self.ALTERNATE_NAMES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEYS = self.KEYS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let MULTIFORMAT_ADDRESS = self.MULTIFORMAT_ADDRESS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let attributes_type = self.ATTRIBUTES.specific_attributes_type();
    let ATTRIBUTES = self.ATTRIBUTES.pack(_fbb);
    EPM::create(_fbb, &EPMArgs{
      NAME,
      ALTERNATE_NAMES,
      EMAIL,
      TELEPHONE,
      KEYS,
      MULTIFORMAT_ADDRESS,
      ATTRIBUTES_type,
      ATTRIBUTES,
    })
  }
}
pub enum EPMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of Entity Profile Messages
pub struct EPMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EPMCOLLECTION<'a> {
  type Inner = EPMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EPMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EPMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EPMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<EPMCOLLECTION<'bldr>> {
    let mut builder = EPMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EPMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    EPMCOLLECTIONT {
      RECORDS,
    }
  }

  /// Records of Entity Profile Messages
  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM>>>>(EPMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for EPMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EPM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct EPMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM<'a>>>>>,
}
impl<'a> Default for EPMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    EPMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct EPMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EPMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EPMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EPMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EPMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EPMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EPMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EPMCOLLECTIONT {
  pub RECORDS: Option<Vec<EPMT>>,
}
impl Default for EPMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl EPMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EPMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    EPMCOLLECTION::create(_fbb, &EPMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EPMCOLLECTION`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPMCOLLECTION_unchecked`.
pub fn root_as_EPMCOLLECTION(buf: &[u8]) -> Result<EPMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EPMCOLLECTION>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EPMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EPMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_EPMCOLLECTION(buf: &[u8]) -> Result<EPMCOLLECTION, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EPMCOLLECTION>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EPMCOLLECTION` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPMCOLLECTION_unchecked`.
pub fn root_as_EPMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EPMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EPMCOLLECTION` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPMCOLLECTION_unchecked`.
pub fn size_prefixed_root_as_EPMCOLLECTION_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPMCOLLECTION<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EPMCOLLECTION<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EPMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EPMCOLLECTION`.
pub unsafe fn root_as_EPMCOLLECTION_unchecked(buf: &[u8]) -> EPMCOLLECTION {
  flatbuffers::root_unchecked::<EPMCOLLECTION>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EPMCOLLECTION and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EPMCOLLECTION`.
pub unsafe fn size_prefixed_root_as_EPMCOLLECTION_unchecked(buf: &[u8]) -> EPMCOLLECTION {
  flatbuffers::size_prefixed_root_unchecked::<EPMCOLLECTION>(buf)
}
pub const EPMCOLLECTION_IDENTIFIER: &str = "$EPM";

#[inline]
pub fn EPMCOLLECTION_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPMCOLLECTION_IDENTIFIER, false)
}

#[inline]
pub fn EPMCOLLECTION_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPMCOLLECTION_IDENTIFIER, true)
}

#[inline]
pub fn finish_EPMCOLLECTION_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<EPMCOLLECTION<'a>>) {
  fbb.finish(root, Some(EPMCOLLECTION_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EPMCOLLECTION_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<EPMCOLLECTION<'a>>) {
  fbb.finish_size_prefixed(root, Some(EPMCOLLECTION_IDENTIFIER));
}
