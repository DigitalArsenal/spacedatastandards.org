// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTITY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTITY: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTITY: [Entity; 3] = [
  Entity::NONE,
  Entity::Person,
  Entity::Organization,
];

/// Union type for Entity, which can be either a Person or an Organization
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Entity(pub u8);
#[allow(non_upper_case_globals)]
impl Entity {
  pub const NONE: Self = Self(0);
  pub const Person: Self = Self(1);
  pub const Organization: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Person,
    Self::Organization,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Person => Some("Person"),
      Self::Organization => Some("Organization"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Entity {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Entity {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Entity {
    type Output = Entity;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Entity {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Entity {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Entity {}
pub struct EntityUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum EntityT {
  NONE,
  Person(Box<PersonT>),
  Organization(Box<OrganizationT>),
}
impl Default for EntityT {
  fn default() -> Self {
    Self::NONE
  }
}
impl EntityT {
  pub fn entity_type(&self) -> Entity {
    match self {
      Self::NONE => Entity::NONE,
      Self::Person(_) => Entity::Person,
      Self::Organization(_) => Entity::Organization,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Person(v) => Some(v.pack(fbb).as_union_value()),
      Self::Organization(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned PersonT, setting the union to NONE.
  pub fn take_person(&mut self) -> Option<Box<PersonT>> {
    if let Self::Person(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Person(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PersonT.
  pub fn as_person(&self) -> Option<&PersonT> {
    if let Self::Person(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PersonT.
  pub fn as_person_mut(&mut self) -> Option<&mut PersonT> {
    if let Self::Person(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned OrganizationT, setting the union to NONE.
  pub fn take_organization(&mut self) -> Option<Box<OrganizationT>> {
    if let Self::Organization(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Organization(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the OrganizationT.
  pub fn as_organization(&self) -> Option<&OrganizationT> {
    if let Self::Organization(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the OrganizationT.
  pub fn as_organization_mut(&mut self) -> Option<&mut OrganizationT> {
    if let Self::Organization(v) = self { Some(v.as_mut()) } else { None }
  }
}
pub enum CryptoKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Crypto Key Information
pub struct CryptoKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CryptoKey<'a> {
  type Inner = CryptoKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CryptoKey<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_XPUB: flatbuffers::VOffsetT = 6;
  pub const VT_PRIVATE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_XPRIV: flatbuffers::VOffsetT = 10;
  pub const VT_KEY_ADDRESS: flatbuffers::VOffsetT = 12;
  pub const VT_ADDRESS_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CryptoKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CryptoKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<CryptoKey<'bldr>> {
    let mut builder = CryptoKeyBuilder::new(_fbb);
    if let Some(x) = args.ADDRESS_TYPE { builder.add_ADDRESS_TYPE(x); }
    if let Some(x) = args.KEY_ADDRESS { builder.add_KEY_ADDRESS(x); }
    if let Some(x) = args.XPRIV { builder.add_XPRIV(x); }
    if let Some(x) = args.PRIVATE_KEY { builder.add_PRIVATE_KEY(x); }
    if let Some(x) = args.XPUB { builder.add_XPUB(x); }
    if let Some(x) = args.PUBLIC_KEY { builder.add_PUBLIC_KEY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CryptoKeyT {
    let PUBLIC_KEY = self.PUBLIC_KEY().map(|x| {
      x.to_string()
    });
    let XPUB = self.XPUB().map(|x| {
      x.to_string()
    });
    let PRIVATE_KEY = self.PRIVATE_KEY().map(|x| {
      x.to_string()
    });
    let XPRIV = self.XPRIV().map(|x| {
      x.to_string()
    });
    let KEY_ADDRESS = self.KEY_ADDRESS().map(|x| {
      x.to_string()
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE().map(|x| {
      x.to_string()
    });
    CryptoKeyT {
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    }
  }

  /// Public part of the cryptographic key
  #[inline]
  pub fn PUBLIC_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PUBLIC_KEY, None)}
  }
  /// Extended public key
  #[inline]
  pub fn XPUB(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPUB, None)}
  }
  /// Private part of the cryptographic key, should be kept secret
  #[inline]
  pub fn PRIVATE_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PRIVATE_KEY, None)}
  }
  /// Extended private key
  #[inline]
  pub fn XPRIV(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPRIV, None)}
  }
  /// Address generated from the cryptographic key
  #[inline]
  pub fn KEY_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_KEY_ADDRESS, None)}
  }
  /// Numerical type of the address generated from the cryptographic key
  #[inline]
  pub fn ADDRESS_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_ADDRESS_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for CryptoKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PUBLIC_KEY", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPUB", Self::VT_XPUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PRIVATE_KEY", Self::VT_PRIVATE_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPRIV", Self::VT_XPRIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEY_ADDRESS", Self::VT_KEY_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_TYPE", Self::VT_ADDRESS_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CryptoKeyArgs<'a> {
    pub PUBLIC_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPUB: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIVATE_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPRIV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CryptoKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CryptoKeyArgs {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
    }
  }
}

pub struct CryptoKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CryptoKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_PUBLIC_KEY(&mut self, PUBLIC_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  #[inline]
  pub fn add_XPUB(&mut self, XPUB: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPUB, XPUB);
  }
  #[inline]
  pub fn add_PRIVATE_KEY(&mut self, PRIVATE_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  #[inline]
  pub fn add_XPRIV(&mut self, XPRIV: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPRIV, XPRIV);
  }
  #[inline]
  pub fn add_KEY_ADDRESS(&mut self, KEY_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  #[inline]
  pub fn add_ADDRESS_TYPE(&mut self, ADDRESS_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CryptoKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CryptoKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CryptoKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CryptoKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CryptoKey");
      ds.field("PUBLIC_KEY", &self.PUBLIC_KEY());
      ds.field("XPUB", &self.XPUB());
      ds.field("PRIVATE_KEY", &self.PRIVATE_KEY());
      ds.field("XPRIV", &self.XPRIV());
      ds.field("KEY_ADDRESS", &self.KEY_ADDRESS());
      ds.field("ADDRESS_TYPE", &self.ADDRESS_TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CryptoKeyT {
  pub PUBLIC_KEY: Option<String>,
  pub XPUB: Option<String>,
  pub PRIVATE_KEY: Option<String>,
  pub XPRIV: Option<String>,
  pub KEY_ADDRESS: Option<String>,
  pub ADDRESS_TYPE: Option<String>,
}
impl Default for CryptoKeyT {
  fn default() -> Self {
    Self {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
    }
  }
}
impl CryptoKeyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CryptoKey<'b>> {
    let PUBLIC_KEY = self.PUBLIC_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPUB = self.XPUB.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIVATE_KEY = self.PRIVATE_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPRIV = self.XPRIV.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY_ADDRESS = self.KEY_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CryptoKey::create(_fbb, &CryptoKeyArgs{
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
    })
  }
}
pub enum ContactPointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Information about a contact point
pub struct ContactPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContactPoint<'a> {
  type Inner = ContactPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContactPoint<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_CONTACT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 8;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 10;
  pub const VT_CONTACT_OPTION: flatbuffers::VOffsetT = 12;
  pub const VT_AREA_SERVED: flatbuffers::VOffsetT = 14;
  pub const VT_AVAILABLE_LANGUAGE: flatbuffers::VOffsetT = 16;
  pub const VT_ADDRESS_COUNTRY: flatbuffers::VOffsetT = 18;
  pub const VT_ADDRESS_REGION: flatbuffers::VOffsetT = 20;
  pub const VT_ADDRESS_LOCALITY: flatbuffers::VOffsetT = 22;
  pub const VT_POSTAL_CODE: flatbuffers::VOffsetT = 24;
  pub const VT_STREET_ADDRESS: flatbuffers::VOffsetT = 26;
  pub const VT_POST_OFFICE_BOX_NUMBER: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContactPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContactPointArgs<'args>
  ) -> flatbuffers::WIPOffset<ContactPoint<'bldr>> {
    let mut builder = ContactPointBuilder::new(_fbb);
    if let Some(x) = args.POST_OFFICE_BOX_NUMBER { builder.add_POST_OFFICE_BOX_NUMBER(x); }
    if let Some(x) = args.STREET_ADDRESS { builder.add_STREET_ADDRESS(x); }
    if let Some(x) = args.POSTAL_CODE { builder.add_POSTAL_CODE(x); }
    if let Some(x) = args.ADDRESS_LOCALITY { builder.add_ADDRESS_LOCALITY(x); }
    if let Some(x) = args.ADDRESS_REGION { builder.add_ADDRESS_REGION(x); }
    if let Some(x) = args.ADDRESS_COUNTRY { builder.add_ADDRESS_COUNTRY(x); }
    if let Some(x) = args.AVAILABLE_LANGUAGE { builder.add_AVAILABLE_LANGUAGE(x); }
    if let Some(x) = args.AREA_SERVED { builder.add_AREA_SERVED(x); }
    if let Some(x) = args.CONTACT_OPTION { builder.add_CONTACT_OPTION(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.CONTACT_TYPE { builder.add_CONTACT_TYPE(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContactPointT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CONTACT_TYPE = self.CONTACT_TYPE().map(|x| {
      x.to_string()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let CONTACT_OPTION = self.CONTACT_OPTION().map(|x| {
      x.to_string()
    });
    let AREA_SERVED = self.AREA_SERVED().map(|x| {
      x.to_string()
    });
    let AVAILABLE_LANGUAGE = self.AVAILABLE_LANGUAGE().map(|x| {
      x.to_string()
    });
    let ADDRESS_COUNTRY = self.ADDRESS_COUNTRY().map(|x| {
      x.to_string()
    });
    let ADDRESS_REGION = self.ADDRESS_REGION().map(|x| {
      x.to_string()
    });
    let ADDRESS_LOCALITY = self.ADDRESS_LOCALITY().map(|x| {
      x.to_string()
    });
    let POSTAL_CODE = self.POSTAL_CODE().map(|x| {
      x.to_string()
    });
    let STREET_ADDRESS = self.STREET_ADDRESS().map(|x| {
      x.to_string()
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER().map(|x| {
      x.to_string()
    });
    ContactPointT {
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER,
    }
  }

  /// Name of the contact point or person
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_NAME, None)}
  }
  /// Type of contact (e.g., customer service, technical support)
  #[inline]
  pub fn CONTACT_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_CONTACT_TYPE, None)}
  }
  /// Email address
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_EMAIL, None)}
  }
  /// Telephone number
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_TELEPHONE, None)}
  }
  /// Available contact options (e.g., HearingImpairedSupported)
  #[inline]
  pub fn CONTACT_OPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_CONTACT_OPTION, None)}
  }
  /// Geographic area where the service is available
  #[inline]
  pub fn AREA_SERVED(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_AREA_SERVED, None)}
  }
  /// Language available for communication
  #[inline]
  pub fn AVAILABLE_LANGUAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_AVAILABLE_LANGUAGE, None)}
  }
  /// Country of the address
  #[inline]
  pub fn ADDRESS_COUNTRY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_COUNTRY, None)}
  }
  /// Region of the address (e.g., state or province)
  #[inline]
  pub fn ADDRESS_REGION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_REGION, None)}
  }
  /// Locality of the address (e.g., city or town)
  #[inline]
  pub fn ADDRESS_LOCALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_ADDRESS_LOCALITY, None)}
  }
  /// Postal code of the address
  #[inline]
  pub fn POSTAL_CODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_POSTAL_CODE, None)}
  }
  /// Street address
  #[inline]
  pub fn STREET_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_STREET_ADDRESS, None)}
  }
  /// Post office box number
  #[inline]
  pub fn POST_OFFICE_BOX_NUMBER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContactPoint::VT_POST_OFFICE_BOX_NUMBER, None)}
  }
}

impl flatbuffers::Verifiable for ContactPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTACT_TYPE", Self::VT_CONTACT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTACT_OPTION", Self::VT_CONTACT_OPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AREA_SERVED", Self::VT_AREA_SERVED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AVAILABLE_LANGUAGE", Self::VT_AVAILABLE_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_COUNTRY", Self::VT_ADDRESS_COUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_REGION", Self::VT_ADDRESS_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_LOCALITY", Self::VT_ADDRESS_LOCALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSTAL_CODE", Self::VT_POSTAL_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STREET_ADDRESS", Self::VT_STREET_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POST_OFFICE_BOX_NUMBER", Self::VT_POST_OFFICE_BOX_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct ContactPointArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTACT_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTACT_OPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AREA_SERVED: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AVAILABLE_LANGUAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_COUNTRY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_REGION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_LOCALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSTAL_CODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STREET_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POST_OFFICE_BOX_NUMBER: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContactPointArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactPointArgs {
      NAME: None,
      CONTACT_TYPE: None,
      EMAIL: None,
      TELEPHONE: None,
      CONTACT_OPTION: None,
      AREA_SERVED: None,
      AVAILABLE_LANGUAGE: None,
      ADDRESS_COUNTRY: None,
      ADDRESS_REGION: None,
      ADDRESS_LOCALITY: None,
      POSTAL_CODE: None,
      STREET_ADDRESS: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}

pub struct ContactPointBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContactPointBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CONTACT_TYPE(&mut self, CONTACT_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_CONTACT_TYPE, CONTACT_TYPE);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_CONTACT_OPTION(&mut self, CONTACT_OPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_CONTACT_OPTION, CONTACT_OPTION);
  }
  #[inline]
  pub fn add_AREA_SERVED(&mut self, AREA_SERVED: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_AREA_SERVED, AREA_SERVED);
  }
  #[inline]
  pub fn add_AVAILABLE_LANGUAGE(&mut self, AVAILABLE_LANGUAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_AVAILABLE_LANGUAGE, AVAILABLE_LANGUAGE);
  }
  #[inline]
  pub fn add_ADDRESS_COUNTRY(&mut self, ADDRESS_COUNTRY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_COUNTRY, ADDRESS_COUNTRY);
  }
  #[inline]
  pub fn add_ADDRESS_REGION(&mut self, ADDRESS_REGION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_REGION, ADDRESS_REGION);
  }
  #[inline]
  pub fn add_ADDRESS_LOCALITY(&mut self, ADDRESS_LOCALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_ADDRESS_LOCALITY, ADDRESS_LOCALITY);
  }
  #[inline]
  pub fn add_POSTAL_CODE(&mut self, POSTAL_CODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_POSTAL_CODE, POSTAL_CODE);
  }
  #[inline]
  pub fn add_STREET_ADDRESS(&mut self, STREET_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_STREET_ADDRESS, STREET_ADDRESS);
  }
  #[inline]
  pub fn add_POST_OFFICE_BOX_NUMBER(&mut self, POST_OFFICE_BOX_NUMBER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContactPoint::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContactPointBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContactPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContactPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContactPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContactPoint");
      ds.field("NAME", &self.NAME());
      ds.field("CONTACT_TYPE", &self.CONTACT_TYPE());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("CONTACT_OPTION", &self.CONTACT_OPTION());
      ds.field("AREA_SERVED", &self.AREA_SERVED());
      ds.field("AVAILABLE_LANGUAGE", &self.AVAILABLE_LANGUAGE());
      ds.field("ADDRESS_COUNTRY", &self.ADDRESS_COUNTRY());
      ds.field("ADDRESS_REGION", &self.ADDRESS_REGION());
      ds.field("ADDRESS_LOCALITY", &self.ADDRESS_LOCALITY());
      ds.field("POSTAL_CODE", &self.POSTAL_CODE());
      ds.field("STREET_ADDRESS", &self.STREET_ADDRESS());
      ds.field("POST_OFFICE_BOX_NUMBER", &self.POST_OFFICE_BOX_NUMBER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContactPointT {
  pub NAME: Option<String>,
  pub CONTACT_TYPE: Option<String>,
  pub EMAIL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub CONTACT_OPTION: Option<String>,
  pub AREA_SERVED: Option<String>,
  pub AVAILABLE_LANGUAGE: Option<String>,
  pub ADDRESS_COUNTRY: Option<String>,
  pub ADDRESS_REGION: Option<String>,
  pub ADDRESS_LOCALITY: Option<String>,
  pub POSTAL_CODE: Option<String>,
  pub STREET_ADDRESS: Option<String>,
  pub POST_OFFICE_BOX_NUMBER: Option<String>,
}
impl Default for ContactPointT {
  fn default() -> Self {
    Self {
      NAME: None,
      CONTACT_TYPE: None,
      EMAIL: None,
      TELEPHONE: None,
      CONTACT_OPTION: None,
      AREA_SERVED: None,
      AVAILABLE_LANGUAGE: None,
      ADDRESS_COUNTRY: None,
      ADDRESS_REGION: None,
      ADDRESS_LOCALITY: None,
      POSTAL_CODE: None,
      STREET_ADDRESS: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}
impl ContactPointT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ContactPoint<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTACT_TYPE = self.CONTACT_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTACT_OPTION = self.CONTACT_OPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AREA_SERVED = self.AREA_SERVED.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AVAILABLE_LANGUAGE = self.AVAILABLE_LANGUAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_COUNTRY = self.ADDRESS_COUNTRY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_REGION = self.ADDRESS_REGION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_LOCALITY = self.ADDRESS_LOCALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSTAL_CODE = self.POSTAL_CODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STREET_ADDRESS = self.STREET_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ContactPoint::create(_fbb, &ContactPointArgs{
      NAME,
      CONTACT_TYPE,
      EMAIL,
      TELEPHONE,
      CONTACT_OPTION,
      AREA_SERVED,
      AVAILABLE_LANGUAGE,
      ADDRESS_COUNTRY,
      ADDRESS_REGION,
      ADDRESS_LOCALITY,
      POSTAL_CODE,
      STREET_ADDRESS,
      POST_OFFICE_BOX_NUMBER,
    })
  }
}
pub enum OrganizationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Basic information about an organization
pub struct Organization<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Organization<'a> {
  type Inner = Organization<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Organization<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_LEGAL_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Organization { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OrganizationArgs<'args>
  ) -> flatbuffers::WIPOffset<Organization<'bldr>> {
    let mut builder = OrganizationBuilder::new(_fbb);
    if let Some(x) = args.LEGAL_NAME { builder.add_LEGAL_NAME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OrganizationT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let LEGAL_NAME = self.LEGAL_NAME().map(|x| {
      x.to_string()
    });
    OrganizationT {
      NAME,
      LEGAL_NAME,
    }
  }

  /// Common name of the organization
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Organization::VT_NAME, None)}
  }
  /// Legal name of the organization
  #[inline]
  pub fn LEGAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Organization::VT_LEGAL_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Organization<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LEGAL_NAME", Self::VT_LEGAL_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct OrganizationArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LEGAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OrganizationArgs<'a> {
  #[inline]
  fn default() -> Self {
    OrganizationArgs {
      NAME: None,
      LEGAL_NAME: None,
    }
  }
}

pub struct OrganizationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OrganizationBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Organization::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_LEGAL_NAME(&mut self, LEGAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Organization::VT_LEGAL_NAME, LEGAL_NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OrganizationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OrganizationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Organization<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Organization<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Organization");
      ds.field("NAME", &self.NAME());
      ds.field("LEGAL_NAME", &self.LEGAL_NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OrganizationT {
  pub NAME: Option<String>,
  pub LEGAL_NAME: Option<String>,
}
impl Default for OrganizationT {
  fn default() -> Self {
    Self {
      NAME: None,
      LEGAL_NAME: None,
    }
  }
}
impl OrganizationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Organization<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LEGAL_NAME = self.LEGAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Organization::create(_fbb, &OrganizationArgs{
      NAME,
      LEGAL_NAME,
    })
  }
}
pub enum OccupationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Information about a person's occupation
pub struct Occupation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Occupation<'a> {
  type Inner = Occupation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Occupation<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Occupation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OccupationArgs<'args>
  ) -> flatbuffers::WIPOffset<Occupation<'bldr>> {
    let mut builder = OccupationBuilder::new(_fbb);
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OccupationT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    OccupationT {
      NAME,
    }
  }

  /// Name of the occupation
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Occupation::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Occupation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct OccupationArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OccupationArgs<'a> {
  #[inline]
  fn default() -> Self {
    OccupationArgs {
      NAME: None,
    }
  }
}

pub struct OccupationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OccupationBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Occupation::VT_NAME, NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OccupationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OccupationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Occupation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Occupation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Occupation");
      ds.field("NAME", &self.NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OccupationT {
  pub NAME: Option<String>,
}
impl Default for OccupationT {
  fn default() -> Self {
    Self {
      NAME: None,
    }
  }
}
impl OccupationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Occupation<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Occupation::create(_fbb, &OccupationArgs{
      NAME,
    })
  }
}
pub enum PersonOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Information about a person
pub struct Person<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Person<'a> {
  type Inner = Person<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Person<'a> {
  pub const VT_FAMILY_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_GIVEN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_ADDITIONAL_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_HONORIFIC_PREFIX: flatbuffers::VOffsetT = 10;
  pub const VT_HONORIFIC_SUFFIX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Person { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PersonArgs<'args>
  ) -> flatbuffers::WIPOffset<Person<'bldr>> {
    let mut builder = PersonBuilder::new(_fbb);
    if let Some(x) = args.HONORIFIC_SUFFIX { builder.add_HONORIFIC_SUFFIX(x); }
    if let Some(x) = args.HONORIFIC_PREFIX { builder.add_HONORIFIC_PREFIX(x); }
    if let Some(x) = args.ADDITIONAL_NAME { builder.add_ADDITIONAL_NAME(x); }
    if let Some(x) = args.GIVEN_NAME { builder.add_GIVEN_NAME(x); }
    if let Some(x) = args.FAMILY_NAME { builder.add_FAMILY_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PersonT {
    let FAMILY_NAME = self.FAMILY_NAME().map(|x| {
      x.to_string()
    });
    let GIVEN_NAME = self.GIVEN_NAME().map(|x| {
      x.to_string()
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME().map(|x| {
      x.to_string()
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX().map(|x| {
      x.to_string()
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX().map(|x| {
      x.to_string()
    });
    PersonT {
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
    }
  }

  /// Family name or surname of the person
  #[inline]
  pub fn FAMILY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Person::VT_FAMILY_NAME, None)}
  }
  /// Given name or first name of the person
  #[inline]
  pub fn GIVEN_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Person::VT_GIVEN_NAME, None)}
  }
  /// Additional name or middle name of the person
  #[inline]
  pub fn ADDITIONAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Person::VT_ADDITIONAL_NAME, None)}
  }
  /// Honorific prefix preceding the person's name
  #[inline]
  pub fn HONORIFIC_PREFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Person::VT_HONORIFIC_PREFIX, None)}
  }
  /// Honorific suffix following the person's name
  #[inline]
  pub fn HONORIFIC_SUFFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Person::VT_HONORIFIC_SUFFIX, None)}
  }
}

impl flatbuffers::Verifiable for Person<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FAMILY_NAME", Self::VT_FAMILY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GIVEN_NAME", Self::VT_GIVEN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDITIONAL_NAME", Self::VT_ADDITIONAL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_PREFIX", Self::VT_HONORIFIC_PREFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_SUFFIX", Self::VT_HONORIFIC_SUFFIX, false)?
     .finish();
    Ok(())
  }
}
pub struct PersonArgs<'a> {
    pub FAMILY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GIVEN_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDITIONAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_PREFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_SUFFIX: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PersonArgs<'a> {
  #[inline]
  fn default() -> Self {
    PersonArgs {
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
    }
  }
}

pub struct PersonBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PersonBuilder<'a, 'b> {
  #[inline]
  pub fn add_FAMILY_NAME(&mut self, FAMILY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Person::VT_FAMILY_NAME, FAMILY_NAME);
  }
  #[inline]
  pub fn add_GIVEN_NAME(&mut self, GIVEN_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Person::VT_GIVEN_NAME, GIVEN_NAME);
  }
  #[inline]
  pub fn add_ADDITIONAL_NAME(&mut self, ADDITIONAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Person::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  #[inline]
  pub fn add_HONORIFIC_PREFIX(&mut self, HONORIFIC_PREFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Person::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  #[inline]
  pub fn add_HONORIFIC_SUFFIX(&mut self, HONORIFIC_SUFFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Person::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PersonBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PersonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Person<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Person<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Person");
      ds.field("FAMILY_NAME", &self.FAMILY_NAME());
      ds.field("GIVEN_NAME", &self.GIVEN_NAME());
      ds.field("ADDITIONAL_NAME", &self.ADDITIONAL_NAME());
      ds.field("HONORIFIC_PREFIX", &self.HONORIFIC_PREFIX());
      ds.field("HONORIFIC_SUFFIX", &self.HONORIFIC_SUFFIX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PersonT {
  pub FAMILY_NAME: Option<String>,
  pub GIVEN_NAME: Option<String>,
  pub ADDITIONAL_NAME: Option<String>,
  pub HONORIFIC_PREFIX: Option<String>,
  pub HONORIFIC_SUFFIX: Option<String>,
}
impl Default for PersonT {
  fn default() -> Self {
    Self {
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
    }
  }
}
impl PersonT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Person<'b>> {
    let FAMILY_NAME = self.FAMILY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GIVEN_NAME = self.GIVEN_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Person::create(_fbb, &PersonArgs{
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
    })
  }
}
pub enum EPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Entity Profile Message
pub struct EPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EPM<'a> {
  type Inner = EPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EPM<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ALTERNATE_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;
  pub const VT_SAME_AS: flatbuffers::VOffsetT = 12;
  pub const VT_URL: flatbuffers::VOffsetT = 14;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 16;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 18;
  pub const VT_KEY: flatbuffers::VOffsetT = 20;
  pub const VT_CONTACT_POINT: flatbuffers::VOffsetT = 22;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 24;
  pub const VT_JOB_TITLE: flatbuffers::VOffsetT = 26;
  pub const VT_ENTITY_TYPE: flatbuffers::VOffsetT = 28;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 30;
  pub const VT_HAS_OCCUPATION: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EPMArgs<'args>
  ) -> flatbuffers::WIPOffset<EPM<'bldr>> {
    let mut builder = EPMBuilder::new(_fbb);
    if let Some(x) = args.HAS_OCCUPATION { builder.add_HAS_OCCUPATION(x); }
    if let Some(x) = args.ENTITY { builder.add_ENTITY(x); }
    if let Some(x) = args.JOB_TITLE { builder.add_JOB_TITLE(x); }
    if let Some(x) = args.ADDRESS { builder.add_ADDRESS(x); }
    if let Some(x) = args.CONTACT_POINT { builder.add_CONTACT_POINT(x); }
    if let Some(x) = args.KEY { builder.add_KEY(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.URL { builder.add_URL(x); }
    if let Some(x) = args.SAME_AS { builder.add_SAME_AS(x); }
    if let Some(x) = args.IMAGE { builder.add_IMAGE(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.ALTERNATE_NAME { builder.add_ALTERNATE_NAME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_ENTITY_type(args.ENTITY_type);
    builder.finish()
  }

  pub fn unpack(&self) -> EPMT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ALTERNATE_NAME = self.ALTERNATE_NAME().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let IMAGE = self.IMAGE().map(|x| {
      x.to_string()
    });
    let SAME_AS = self.SAME_AS().map(|x| {
      x.to_string()
    });
    let URL = self.URL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let KEY = self.KEY().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let CONTACT_POINT = self.CONTACT_POINT().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ADDRESS = self.ADDRESS().map(|x| {
      Box::new(x.unpack())
    });
    let JOB_TITLE = self.JOB_TITLE().map(|x| {
      x.to_string()
    });
    let ENTITY = match self.entity_type() {
      Entity::NONE => EntityT::NONE,
      Entity::Person => EntityT::Person(Box::new(
        self.ENTITY_as_person()
            .expect("Invalid union table, expected `Entity::Person`.")
            .unpack()
      )),
      Entity::Organization => EntityT::Organization(Box::new(
        self.ENTITY_as_organization()
            .expect("Invalid union table, expected `Entity::Organization`.")
            .unpack()
      )),
      _ => EntityT::NONE,
    };
    let HAS_OCCUPATION = self.HAS_OCCUPATION().map(|x| {
      Box::new(x.unpack())
    });
    EPMT {
      NAME,
      ALTERNATE_NAME,
      DESCRIPTION,
      IMAGE,
      SAME_AS,
      URL,
      TELEPHONE,
      EMAIL,
      KEY,
      CONTACT_POINT,
      ADDRESS,
      JOB_TITLE,
      ENTITY,
      HAS_OCCUPATION,
    }
  }

  /// Common name of the entity (person or organization)
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_NAME, None)}
  }
  /// Alternate name for the entity
  #[inline]
  pub fn ALTERNATE_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_ALTERNATE_NAME, None)}
  }
  /// Description of the entity
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_DESCRIPTION, None)}
  }
  /// URL of an image representing the entity
  #[inline]
  pub fn IMAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_IMAGE, None)}
  }
  /// URL of a webpage that unambiguously indicates the entity's identity
  #[inline]
  pub fn SAME_AS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_SAME_AS, None)}
  }
  /// URL of the entity's website
  #[inline]
  pub fn URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_URL, None)}
  }
  /// Telephone number for the entity
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_TELEPHONE, None)}
  }
  /// Email address for the entity
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_EMAIL, None)}
  }
  /// Cryptographic key information associated with the entity
  #[inline]
  pub fn KEY(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey>>>>(EPM::VT_KEY, None)}
  }
  /// Contact points for the entity
  #[inline]
  pub fn CONTACT_POINT(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint>>>>(EPM::VT_CONTACT_POINT, None)}
  }
  /// Address of the entity, using the ContactPoint structure
  #[inline]
  pub fn ADDRESS(&self) -> Option<ContactPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContactPoint>>(EPM::VT_ADDRESS, None)}
  }
  /// Job title of the entity (applicable to persons)
  #[inline]
  pub fn JOB_TITLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_JOB_TITLE, None)}
  }
  #[inline]
  pub fn ENTITY_type(&self) -> Entity {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Entity>(EPM::VT_ENTITY_TYPE, Some(Entity::NONE)).unwrap()}
  }
  /// Union type to represent either a person or an organization
  #[inline]
  pub fn ENTITY(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EPM::VT_ENTITY, None)}
  }
  /// Occupation of the entity (applicable to persons)
  #[inline]
  pub fn HAS_OCCUPATION(&self) -> Option<Occupation<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Occupation>>(EPM::VT_HAS_OCCUPATION, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn ENTITY_as_person(&self) -> Option<Person<'a>> {
    if self.entity_type() == Entity::Person {
      self.ENTITY().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Person::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn ENTITY_as_organization(&self) -> Option<Organization<'a>> {
    if self.entity_type() == Entity::Organization {
      self.ENTITY().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Organization::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for EPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALTERNATE_NAME", Self::VT_ALTERNATE_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMAGE", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SAME_AS", Self::VT_SAME_AS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("URL", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CryptoKey>>>>("KEY", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContactPoint>>>>("CONTACT_POINT", Self::VT_CONTACT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContactPoint>>("ADDRESS", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JOB_TITLE", Self::VT_JOB_TITLE, false)?
     .visit_union::<Entity, _>("entity_type", Self::VT_ENTITY_TYPE, "ENTITY", Self::VT_ENTITY, false, |key, v, pos| {
        match key {
          Entity::Person => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Person>>("Entity::Person", pos),
          Entity::Organization => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Organization>>("Entity::Organization", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<Occupation>>("HAS_OCCUPATION", Self::VT_HAS_OCCUPATION, false)?
     .finish();
    Ok(())
  }
}
pub struct EPMArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALTERNATE_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAME_AS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>>>,
    pub CONTACT_POINT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContactPoint<'a>>>>>,
    pub ADDRESS: Option<flatbuffers::WIPOffset<ContactPoint<'a>>>,
    pub JOB_TITLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENTITY_type: Entity,
    pub ENTITY: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub HAS_OCCUPATION: Option<flatbuffers::WIPOffset<Occupation<'a>>>,
}
impl<'a> Default for EPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    EPMArgs {
      NAME: None,
      ALTERNATE_NAME: None,
      DESCRIPTION: None,
      IMAGE: None,
      SAME_AS: None,
      URL: None,
      TELEPHONE: None,
      EMAIL: None,
      KEY: None,
      CONTACT_POINT: None,
      ADDRESS: None,
      JOB_TITLE: None,
      ENTITY_type: Entity::NONE,
      ENTITY: None,
      HAS_OCCUPATION: None,
    }
  }
}

pub struct EPMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EPMBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ALTERNATE_NAME(&mut self, ALTERNATE_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ALTERNATE_NAME, ALTERNATE_NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_IMAGE(&mut self, IMAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_IMAGE, IMAGE);
  }
  #[inline]
  pub fn add_SAME_AS(&mut self, SAME_AS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_SAME_AS, SAME_AS);
  }
  #[inline]
  pub fn add_URL(&mut self, URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_URL, URL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_KEY(&mut self, KEY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CryptoKey<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_KEY, KEY);
  }
  #[inline]
  pub fn add_CONTACT_POINT(&mut self, CONTACT_POINT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContactPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_CONTACT_POINT, CONTACT_POINT);
  }
  #[inline]
  pub fn add_ADDRESS(&mut self, ADDRESS: flatbuffers::WIPOffset<ContactPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContactPoint>>(EPM::VT_ADDRESS, ADDRESS);
  }
  #[inline]
  pub fn add_JOB_TITLE(&mut self, JOB_TITLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_JOB_TITLE, JOB_TITLE);
  }
  #[inline]
  pub fn add_ENTITY_type(&mut self, ENTITY_type: Entity) {
    self.fbb_.push_slot::<Entity>(EPM::VT_ENTITY_TYPE, ENTITY_type, Entity::NONE);
  }
  #[inline]
  pub fn add_ENTITY(&mut self, ENTITY: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ENTITY, ENTITY);
  }
  #[inline]
  pub fn add_HAS_OCCUPATION(&mut self, HAS_OCCUPATION: flatbuffers::WIPOffset<Occupation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Occupation>>(EPM::VT_HAS_OCCUPATION, HAS_OCCUPATION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EPMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EPM");
      ds.field("NAME", &self.NAME());
      ds.field("ALTERNATE_NAME", &self.ALTERNATE_NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("IMAGE", &self.IMAGE());
      ds.field("SAME_AS", &self.SAME_AS());
      ds.field("URL", &self.URL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("KEY", &self.KEY());
      ds.field("CONTACT_POINT", &self.CONTACT_POINT());
      ds.field("ADDRESS", &self.ADDRESS());
      ds.field("JOB_TITLE", &self.JOB_TITLE());
      ds.field("ENTITY_type", &self.ENTITY_type());
      match self.entity_type() {
        Entity::Person => {
          if let Some(x) = self.ENTITY_as_person() {
            ds.field("ENTITY", &x)
          } else {
            ds.field("ENTITY", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Entity::Organization => {
          if let Some(x) = self.ENTITY_as_organization() {
            ds.field("ENTITY", &x)
          } else {
            ds.field("ENTITY", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("ENTITY", &x)
        },
      };
      ds.field("HAS_OCCUPATION", &self.HAS_OCCUPATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EPMT {
  pub NAME: Option<String>,
  pub ALTERNATE_NAME: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub IMAGE: Option<String>,
  pub SAME_AS: Option<String>,
  pub URL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub EMAIL: Option<String>,
  pub KEY: Option<Vec<CryptoKeyT>>,
  pub CONTACT_POINT: Option<Vec<ContactPointT>>,
  pub ADDRESS: Option<Box<ContactPointT>>,
  pub JOB_TITLE: Option<String>,
  pub ENTITY: EntityT,
  pub HAS_OCCUPATION: Option<Box<OccupationT>>,
}
impl Default for EPMT {
  fn default() -> Self {
    Self {
      NAME: None,
      ALTERNATE_NAME: None,
      DESCRIPTION: None,
      IMAGE: None,
      SAME_AS: None,
      URL: None,
      TELEPHONE: None,
      EMAIL: None,
      KEY: None,
      CONTACT_POINT: None,
      ADDRESS: None,
      JOB_TITLE: None,
      ENTITY: EntityT::NONE,
      HAS_OCCUPATION: None,
    }
  }
}
impl EPMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EPM<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALTERNATE_NAME = self.ALTERNATE_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMAGE = self.IMAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAME_AS = self.SAME_AS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let URL = self.URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY = self.KEY.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let CONTACT_POINT = self.CONTACT_POINT.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ADDRESS = self.ADDRESS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let JOB_TITLE = self.JOB_TITLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let entity_type = self.ENTITY.entity_type();
    let ENTITY = self.ENTITY.pack(_fbb);
    let HAS_OCCUPATION = self.HAS_OCCUPATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    EPM::create(_fbb, &EPMArgs{
      NAME,
      ALTERNATE_NAME,
      DESCRIPTION,
      IMAGE,
      SAME_AS,
      URL,
      TELEPHONE,
      EMAIL,
      KEY,
      CONTACT_POINT,
      ADDRESS,
      JOB_TITLE,
      ENTITY_type,
      ENTITY,
      HAS_OCCUPATION,
    })
  }
}
pub enum EPMCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EPMCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EPMCOLLECTION<'a> {
  type Inner = EPMCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EPMCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EPMCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EPMCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<EPMCOLLECTION<'bldr>> {
    let mut builder = EPMCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EPMCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    EPMCOLLECTIONT {
      RECORDS,
    }
  }

  /// Records of Entity Profile Messages
  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM>>>>(EPMCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for EPMCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EPM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct EPMCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EPM<'a>>>>>,
}
impl<'a> Default for EPMCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    EPMCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct EPMCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EPMCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPMCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EPMCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EPMCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EPMCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EPMCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EPMCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EPMCOLLECTIONT {
  pub RECORDS: Option<Vec<EPMT>>,
}
impl Default for EPMCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl EPMCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EPMCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    EPMCOLLECTION::create(_fbb, &EPMCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EPM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn root_as_EPM(buf: &[u8]) -> Result<EPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EPM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EPM_unchecked`.
pub fn size_prefixed_root_as_EPM(buf: &[u8]) -> Result<EPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EPM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn root_as_EPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EPM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EPM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn size_prefixed_root_as_EPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EPM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EPM`.
pub unsafe fn root_as_EPM_unchecked(buf: &[u8]) -> EPM {
  flatbuffers::root_unchecked::<EPM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EPM`.
pub unsafe fn size_prefixed_root_as_EPM_unchecked(buf: &[u8]) -> EPM {
  flatbuffers::size_prefixed_root_unchecked::<EPM>(buf)
}
pub const EPM_IDENTIFIER: &str = "$EPM";

#[inline]
pub fn EPM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPM_IDENTIFIER, false)
}

#[inline]
pub fn EPM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPM_IDENTIFIER, true)
}

#[inline]
pub fn finish_EPM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<EPM<'a>>) {
  fbb.finish(root, Some(EPM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EPM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<EPM<'a>>) {
  fbb.finish_size_prefixed(root, Some(EPM_IDENTIFIER));
}
