// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KEY_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KEY_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KEY_TYPE: [KeyType; 2] = [
  KeyType::signing,
  KeyType::encryption,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct KeyType(pub i8);
#[allow(non_upper_case_globals)]
impl KeyType {
  pub const signing: Self = Self(0);
  pub const encryption: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::signing,
    Self::encryption,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::signing => Some("signing"),
      Self::encryption => Some("encryption"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for KeyType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for KeyType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for KeyType {
    type Output = KeyType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for KeyType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for KeyType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for KeyType {}
pub enum CryptoKeyOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents cryptographic key information
pub struct CryptoKey<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CryptoKey<'a> {
  type Inner = CryptoKey<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CryptoKey<'a> {
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_XPUB: flatbuffers::VOffsetT = 6;
  pub const VT_PRIVATE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_XPRIV: flatbuffers::VOffsetT = 10;
  pub const VT_KEY_ADDRESS: flatbuffers::VOffsetT = 12;
  pub const VT_ADDRESS_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_KEY_TYPE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CryptoKey { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CryptoKeyArgs<'args>
  ) -> flatbuffers::WIPOffset<CryptoKey<'bldr>> {
    let mut builder = CryptoKeyBuilder::new(_fbb);
    if let Some(x) = args.ADDRESS_TYPE { builder.add_ADDRESS_TYPE(x); }
    if let Some(x) = args.KEY_ADDRESS { builder.add_KEY_ADDRESS(x); }
    if let Some(x) = args.XPRIV { builder.add_XPRIV(x); }
    if let Some(x) = args.PRIVATE_KEY { builder.add_PRIVATE_KEY(x); }
    if let Some(x) = args.XPUB { builder.add_XPUB(x); }
    if let Some(x) = args.PUBLIC_KEY { builder.add_PUBLIC_KEY(x); }
    builder.add_KEY_TYPE(args.KEY_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> CryptoKeyT {
    let PUBLIC_KEY = self.PUBLIC_KEY().map(|x| {
      x.to_string()
    });
    let XPUB = self.XPUB().map(|x| {
      x.to_string()
    });
    let PRIVATE_KEY = self.PRIVATE_KEY().map(|x| {
      x.to_string()
    });
    let XPRIV = self.XPRIV().map(|x| {
      x.to_string()
    });
    let KEY_ADDRESS = self.KEY_ADDRESS().map(|x| {
      x.to_string()
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE().map(|x| {
      x.to_string()
    });
    let KEY_TYPE = self.KEY_TYPE();
    CryptoKeyT {
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
      KEY_TYPE,
    }
  }

  /// Public part of the cryptographic key
  #[inline]
  pub fn PUBLIC_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PUBLIC_KEY, None)}
  }
  /// Extended public key
  #[inline]
  pub fn XPUB(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPUB, None)}
  }
  /// Private part of the cryptographic key, should be kept secret
  #[inline]
  pub fn PRIVATE_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_PRIVATE_KEY, None)}
  }
  /// Extended private key
  #[inline]
  pub fn XPRIV(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_XPRIV, None)}
  }
  /// Address generated from the cryptographic key
  #[inline]
  pub fn KEY_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_KEY_ADDRESS, None)}
  }
  /// Type of the address generated from the cryptographic key
  #[inline]
  pub fn ADDRESS_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CryptoKey::VT_ADDRESS_TYPE, None)}
  }
  /// Type of the cryptographic key (signing or encryption)
  #[inline]
  pub fn KEY_TYPE(&self) -> KeyType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<KeyType>(CryptoKey::VT_KEY_TYPE, Some(KeyType::signing)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CryptoKey<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PUBLIC_KEY", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPUB", Self::VT_XPUB, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PRIVATE_KEY", Self::VT_PRIVATE_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("XPRIV", Self::VT_XPRIV, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEY_ADDRESS", Self::VT_KEY_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDRESS_TYPE", Self::VT_ADDRESS_TYPE, false)?
     .visit_field::<KeyType>("KEY_TYPE", Self::VT_KEY_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CryptoKeyArgs<'a> {
    pub PUBLIC_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPUB: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIVATE_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub XPRIV: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEY_TYPE: KeyType,
}
impl<'a> Default for CryptoKeyArgs<'a> {
  #[inline]
  fn default() -> Self {
    CryptoKeyArgs {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
      KEY_TYPE: KeyType::signing,
    }
  }
}

pub struct CryptoKeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CryptoKeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_PUBLIC_KEY(&mut self, PUBLIC_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PUBLIC_KEY, PUBLIC_KEY);
  }
  #[inline]
  pub fn add_XPUB(&mut self, XPUB: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPUB, XPUB);
  }
  #[inline]
  pub fn add_PRIVATE_KEY(&mut self, PRIVATE_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_PRIVATE_KEY, PRIVATE_KEY);
  }
  #[inline]
  pub fn add_XPRIV(&mut self, XPRIV: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_XPRIV, XPRIV);
  }
  #[inline]
  pub fn add_KEY_ADDRESS(&mut self, KEY_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_KEY_ADDRESS, KEY_ADDRESS);
  }
  #[inline]
  pub fn add_ADDRESS_TYPE(&mut self, ADDRESS_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CryptoKey::VT_ADDRESS_TYPE, ADDRESS_TYPE);
  }
  #[inline]
  pub fn add_KEY_TYPE(&mut self, KEY_TYPE: KeyType) {
    self.fbb_.push_slot::<KeyType>(CryptoKey::VT_KEY_TYPE, KEY_TYPE, KeyType::signing);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CryptoKeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CryptoKeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CryptoKey<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CryptoKey<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CryptoKey");
      ds.field("PUBLIC_KEY", &self.PUBLIC_KEY());
      ds.field("XPUB", &self.XPUB());
      ds.field("PRIVATE_KEY", &self.PRIVATE_KEY());
      ds.field("XPRIV", &self.XPRIV());
      ds.field("KEY_ADDRESS", &self.KEY_ADDRESS());
      ds.field("ADDRESS_TYPE", &self.ADDRESS_TYPE());
      ds.field("KEY_TYPE", &self.KEY_TYPE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CryptoKeyT {
  pub PUBLIC_KEY: Option<String>,
  pub XPUB: Option<String>,
  pub PRIVATE_KEY: Option<String>,
  pub XPRIV: Option<String>,
  pub KEY_ADDRESS: Option<String>,
  pub ADDRESS_TYPE: Option<String>,
  pub KEY_TYPE: KeyType,
}
impl Default for CryptoKeyT {
  fn default() -> Self {
    Self {
      PUBLIC_KEY: None,
      XPUB: None,
      PRIVATE_KEY: None,
      XPRIV: None,
      KEY_ADDRESS: None,
      ADDRESS_TYPE: None,
      KEY_TYPE: KeyType::signing,
    }
  }
}
impl CryptoKeyT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CryptoKey<'b>> {
    let PUBLIC_KEY = self.PUBLIC_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPUB = self.XPUB.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIVATE_KEY = self.PRIVATE_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let XPRIV = self.XPRIV.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY_ADDRESS = self.KEY_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS_TYPE = self.ADDRESS_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEY_TYPE = self.KEY_TYPE;
    CryptoKey::create(_fbb, &CryptoKeyArgs{
      PUBLIC_KEY,
      XPUB,
      PRIVATE_KEY,
      XPRIV,
      KEY_ADDRESS,
      ADDRESS_TYPE,
      KEY_TYPE,
    })
  }
}
pub enum AddressOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Represents a geographic address
pub struct Address<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Address<'a> {
  type Inner = Address<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Address<'a> {
  pub const VT_COUNTRY: flatbuffers::VOffsetT = 4;
  pub const VT_REGION: flatbuffers::VOffsetT = 6;
  pub const VT_LOCALITY: flatbuffers::VOffsetT = 8;
  pub const VT_POSTAL_CODE: flatbuffers::VOffsetT = 10;
  pub const VT_STREET: flatbuffers::VOffsetT = 12;
  pub const VT_POST_OFFICE_BOX_NUMBER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Address { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddressArgs<'args>
  ) -> flatbuffers::WIPOffset<Address<'bldr>> {
    let mut builder = AddressBuilder::new(_fbb);
    if let Some(x) = args.POST_OFFICE_BOX_NUMBER { builder.add_POST_OFFICE_BOX_NUMBER(x); }
    if let Some(x) = args.STREET { builder.add_STREET(x); }
    if let Some(x) = args.POSTAL_CODE { builder.add_POSTAL_CODE(x); }
    if let Some(x) = args.LOCALITY { builder.add_LOCALITY(x); }
    if let Some(x) = args.REGION { builder.add_REGION(x); }
    if let Some(x) = args.COUNTRY { builder.add_COUNTRY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AddressT {
    let COUNTRY = self.COUNTRY().map(|x| {
      x.to_string()
    });
    let REGION = self.REGION().map(|x| {
      x.to_string()
    });
    let LOCALITY = self.LOCALITY().map(|x| {
      x.to_string()
    });
    let POSTAL_CODE = self.POSTAL_CODE().map(|x| {
      x.to_string()
    });
    let STREET = self.STREET().map(|x| {
      x.to_string()
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER().map(|x| {
      x.to_string()
    });
    AddressT {
      COUNTRY,
      REGION,
      LOCALITY,
      POSTAL_CODE,
      STREET,
      POST_OFFICE_BOX_NUMBER,
    }
  }

  /// Country of the address
  #[inline]
  pub fn COUNTRY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_COUNTRY, None)}
  }
  /// Region of the address (e.g., state or province)
  #[inline]
  pub fn REGION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_REGION, None)}
  }
  /// Locality of the address (e.g., city or town)
  #[inline]
  pub fn LOCALITY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_LOCALITY, None)}
  }
  /// Postal code of the address
  #[inline]
  pub fn POSTAL_CODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_POSTAL_CODE, None)}
  }
  /// Street address
  #[inline]
  pub fn STREET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_STREET, None)}
  }
  /// Post office box number
  #[inline]
  pub fn POST_OFFICE_BOX_NUMBER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Address::VT_POST_OFFICE_BOX_NUMBER, None)}
  }
}

impl flatbuffers::Verifiable for Address<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COUNTRY", Self::VT_COUNTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REGION", Self::VT_REGION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LOCALITY", Self::VT_LOCALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POSTAL_CODE", Self::VT_POSTAL_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STREET", Self::VT_STREET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POST_OFFICE_BOX_NUMBER", Self::VT_POST_OFFICE_BOX_NUMBER, false)?
     .finish();
    Ok(())
  }
}
pub struct AddressArgs<'a> {
    pub COUNTRY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REGION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCALITY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POSTAL_CODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STREET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POST_OFFICE_BOX_NUMBER: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AddressArgs<'a> {
  #[inline]
  fn default() -> Self {
    AddressArgs {
      COUNTRY: None,
      REGION: None,
      LOCALITY: None,
      POSTAL_CODE: None,
      STREET: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}

pub struct AddressBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddressBuilder<'a, 'b> {
  #[inline]
  pub fn add_COUNTRY(&mut self, COUNTRY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_COUNTRY, COUNTRY);
  }
  #[inline]
  pub fn add_REGION(&mut self, REGION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_REGION, REGION);
  }
  #[inline]
  pub fn add_LOCALITY(&mut self, LOCALITY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_LOCALITY, LOCALITY);
  }
  #[inline]
  pub fn add_POSTAL_CODE(&mut self, POSTAL_CODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_POSTAL_CODE, POSTAL_CODE);
  }
  #[inline]
  pub fn add_STREET(&mut self, STREET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_STREET, STREET);
  }
  #[inline]
  pub fn add_POST_OFFICE_BOX_NUMBER(&mut self, POST_OFFICE_BOX_NUMBER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Address::VT_POST_OFFICE_BOX_NUMBER, POST_OFFICE_BOX_NUMBER);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddressBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddressBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Address<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Address<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Address");
      ds.field("COUNTRY", &self.COUNTRY());
      ds.field("REGION", &self.REGION());
      ds.field("LOCALITY", &self.LOCALITY());
      ds.field("POSTAL_CODE", &self.POSTAL_CODE());
      ds.field("STREET", &self.STREET());
      ds.field("POST_OFFICE_BOX_NUMBER", &self.POST_OFFICE_BOX_NUMBER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AddressT {
  pub COUNTRY: Option<String>,
  pub REGION: Option<String>,
  pub LOCALITY: Option<String>,
  pub POSTAL_CODE: Option<String>,
  pub STREET: Option<String>,
  pub POST_OFFICE_BOX_NUMBER: Option<String>,
}
impl Default for AddressT {
  fn default() -> Self {
    Self {
      COUNTRY: None,
      REGION: None,
      LOCALITY: None,
      POSTAL_CODE: None,
      STREET: None,
      POST_OFFICE_BOX_NUMBER: None,
    }
  }
}
impl AddressT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Address<'b>> {
    let COUNTRY = self.COUNTRY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REGION = self.REGION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCALITY = self.LOCALITY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POSTAL_CODE = self.POSTAL_CODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STREET = self.STREET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POST_OFFICE_BOX_NUMBER = self.POST_OFFICE_BOX_NUMBER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Address::create(_fbb, &AddressArgs{
      COUNTRY,
      REGION,
      LOCALITY,
      POSTAL_CODE,
      STREET,
      POST_OFFICE_BOX_NUMBER,
    })
  }
}
pub enum EPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Entity Profile Message
pub struct EPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EPM<'a> {
  type Inner = EPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EPM<'a> {
  pub const VT_DN: flatbuffers::VOffsetT = 4;
  pub const VT_LEGAL_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_FAMILY_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_GIVEN_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_ADDITIONAL_NAME: flatbuffers::VOffsetT = 12;
  pub const VT_HONORIFIC_PREFIX: flatbuffers::VOffsetT = 14;
  pub const VT_HONORIFIC_SUFFIX: flatbuffers::VOffsetT = 16;
  pub const VT_JOB_TITLE: flatbuffers::VOffsetT = 18;
  pub const VT_OCCUPATION: flatbuffers::VOffsetT = 20;
  pub const VT_ADDRESS: flatbuffers::VOffsetT = 22;
  pub const VT_ALTERNATE_NAMES: flatbuffers::VOffsetT = 24;
  pub const VT_EMAIL: flatbuffers::VOffsetT = 26;
  pub const VT_TELEPHONE: flatbuffers::VOffsetT = 28;
  pub const VT_KEYS: flatbuffers::VOffsetT = 30;
  pub const VT_MULTIFORMAT_ADDRESS: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EPMArgs<'args>
  ) -> flatbuffers::WIPOffset<EPM<'bldr>> {
    let mut builder = EPMBuilder::new(_fbb);
    if let Some(x) = args.MULTIFORMAT_ADDRESS { builder.add_MULTIFORMAT_ADDRESS(x); }
    if let Some(x) = args.KEYS { builder.add_KEYS(x); }
    if let Some(x) = args.TELEPHONE { builder.add_TELEPHONE(x); }
    if let Some(x) = args.EMAIL { builder.add_EMAIL(x); }
    if let Some(x) = args.ALTERNATE_NAMES { builder.add_ALTERNATE_NAMES(x); }
    if let Some(x) = args.ADDRESS { builder.add_ADDRESS(x); }
    if let Some(x) = args.OCCUPATION { builder.add_OCCUPATION(x); }
    if let Some(x) = args.JOB_TITLE { builder.add_JOB_TITLE(x); }
    if let Some(x) = args.HONORIFIC_SUFFIX { builder.add_HONORIFIC_SUFFIX(x); }
    if let Some(x) = args.HONORIFIC_PREFIX { builder.add_HONORIFIC_PREFIX(x); }
    if let Some(x) = args.ADDITIONAL_NAME { builder.add_ADDITIONAL_NAME(x); }
    if let Some(x) = args.GIVEN_NAME { builder.add_GIVEN_NAME(x); }
    if let Some(x) = args.FAMILY_NAME { builder.add_FAMILY_NAME(x); }
    if let Some(x) = args.LEGAL_NAME { builder.add_LEGAL_NAME(x); }
    if let Some(x) = args.DN { builder.add_DN(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EPMT {
    let DN = self.DN().map(|x| {
      x.to_string()
    });
    let LEGAL_NAME = self.LEGAL_NAME().map(|x| {
      x.to_string()
    });
    let FAMILY_NAME = self.FAMILY_NAME().map(|x| {
      x.to_string()
    });
    let GIVEN_NAME = self.GIVEN_NAME().map(|x| {
      x.to_string()
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME().map(|x| {
      x.to_string()
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX().map(|x| {
      x.to_string()
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX().map(|x| {
      x.to_string()
    });
    let JOB_TITLE = self.JOB_TITLE().map(|x| {
      x.to_string()
    });
    let OCCUPATION = self.OCCUPATION().map(|x| {
      x.to_string()
    });
    let ADDRESS = self.ADDRESS().map(|x| {
      Box::new(x.unpack())
    });
    let ALTERNATE_NAMES = self.ALTERNATE_NAMES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let EMAIL = self.EMAIL().map(|x| {
      x.to_string()
    });
    let TELEPHONE = self.TELEPHONE().map(|x| {
      x.to_string()
    });
    let KEYS = self.KEYS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let MULTIFORMAT_ADDRESS = self.MULTIFORMAT_ADDRESS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    EPMT {
      DN,
      LEGAL_NAME,
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
      JOB_TITLE,
      OCCUPATION,
      ADDRESS,
      ALTERNATE_NAMES,
      EMAIL,
      TELEPHONE,
      KEYS,
      MULTIFORMAT_ADDRESS,
    }
  }

  /// Distinguished Name of the entity
  #[inline]
  pub fn DN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_DN, None)}
  }
  /// Common name of the entity (person or organization)
  #[inline]
  pub fn LEGAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_LEGAL_NAME, None)}
  }
  /// Family name or surname of the person
  #[inline]
  pub fn FAMILY_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_FAMILY_NAME, None)}
  }
  /// Given name or first name of the person
  #[inline]
  pub fn GIVEN_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_GIVEN_NAME, None)}
  }
  /// Additional name or middle name of the person
  #[inline]
  pub fn ADDITIONAL_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_ADDITIONAL_NAME, None)}
  }
  /// Honorific prefix preceding the person's name (e.g., Mr., Dr.)
  #[inline]
  pub fn HONORIFIC_PREFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_HONORIFIC_PREFIX, None)}
  }
  /// Honorific suffix following the person's name (e.g., Jr., Sr.)
  #[inline]
  pub fn HONORIFIC_SUFFIX(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_HONORIFIC_SUFFIX, None)}
  }
  /// Job title of the person
  #[inline]
  pub fn JOB_TITLE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_JOB_TITLE, None)}
  }
  /// Occupation of the person
  #[inline]
  pub fn OCCUPATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_OCCUPATION, None)}
  }
  /// Physical Address
  #[inline]
  pub fn ADDRESS(&self) -> Option<Address<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Address>>(EPM::VT_ADDRESS, None)}
  }
  /// Alternate names for the entity
  #[inline]
  pub fn ALTERNATE_NAMES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EPM::VT_ALTERNATE_NAMES, None)}
  }
  /// Email address of the entity
  #[inline]
  pub fn EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_EMAIL, None)}
  }
  /// Telephone number of the entity
  #[inline]
  pub fn TELEPHONE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EPM::VT_TELEPHONE, None)}
  }
  /// Cryptographic keys associated with the entity
  #[inline]
  pub fn KEYS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey>>>>(EPM::VT_KEYS, None)}
  }
  /// Multiformat addresses associated with the entity
  #[inline]
  pub fn MULTIFORMAT_ADDRESS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EPM::VT_MULTIFORMAT_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for EPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DN", Self::VT_DN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LEGAL_NAME", Self::VT_LEGAL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FAMILY_NAME", Self::VT_FAMILY_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("GIVEN_NAME", Self::VT_GIVEN_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ADDITIONAL_NAME", Self::VT_ADDITIONAL_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_PREFIX", Self::VT_HONORIFIC_PREFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HONORIFIC_SUFFIX", Self::VT_HONORIFIC_SUFFIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JOB_TITLE", Self::VT_JOB_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OCCUPATION", Self::VT_OCCUPATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Address>>("ADDRESS", Self::VT_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ALTERNATE_NAMES", Self::VT_ALTERNATE_NAMES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EMAIL", Self::VT_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TELEPHONE", Self::VT_TELEPHONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CryptoKey>>>>("KEYS", Self::VT_KEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MULTIFORMAT_ADDRESS", Self::VT_MULTIFORMAT_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct EPMArgs<'a> {
    pub DN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LEGAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FAMILY_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GIVEN_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDITIONAL_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_PREFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HONORIFIC_SUFFIX: Option<flatbuffers::WIPOffset<&'a str>>,
    pub JOB_TITLE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OCCUPATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ADDRESS: Option<flatbuffers::WIPOffset<Address<'a>>>,
    pub ALTERNATE_NAMES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TELEPHONE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub KEYS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CryptoKey<'a>>>>>,
    pub MULTIFORMAT_ADDRESS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for EPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    EPMArgs {
      DN: None,
      LEGAL_NAME: None,
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
      JOB_TITLE: None,
      OCCUPATION: None,
      ADDRESS: None,
      ALTERNATE_NAMES: None,
      EMAIL: None,
      TELEPHONE: None,
      KEYS: None,
      MULTIFORMAT_ADDRESS: None,
    }
  }
}

pub struct EPMBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EPMBuilder<'a, 'b> {
  #[inline]
  pub fn add_DN(&mut self, DN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_DN, DN);
  }
  #[inline]
  pub fn add_LEGAL_NAME(&mut self, LEGAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_LEGAL_NAME, LEGAL_NAME);
  }
  #[inline]
  pub fn add_FAMILY_NAME(&mut self, FAMILY_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_FAMILY_NAME, FAMILY_NAME);
  }
  #[inline]
  pub fn add_GIVEN_NAME(&mut self, GIVEN_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_GIVEN_NAME, GIVEN_NAME);
  }
  #[inline]
  pub fn add_ADDITIONAL_NAME(&mut self, ADDITIONAL_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ADDITIONAL_NAME, ADDITIONAL_NAME);
  }
  #[inline]
  pub fn add_HONORIFIC_PREFIX(&mut self, HONORIFIC_PREFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_HONORIFIC_PREFIX, HONORIFIC_PREFIX);
  }
  #[inline]
  pub fn add_HONORIFIC_SUFFIX(&mut self, HONORIFIC_SUFFIX: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_HONORIFIC_SUFFIX, HONORIFIC_SUFFIX);
  }
  #[inline]
  pub fn add_JOB_TITLE(&mut self, JOB_TITLE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_JOB_TITLE, JOB_TITLE);
  }
  #[inline]
  pub fn add_OCCUPATION(&mut self, OCCUPATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_OCCUPATION, OCCUPATION);
  }
  #[inline]
  pub fn add_ADDRESS(&mut self, ADDRESS: flatbuffers::WIPOffset<Address<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Address>>(EPM::VT_ADDRESS, ADDRESS);
  }
  #[inline]
  pub fn add_ALTERNATE_NAMES(&mut self, ALTERNATE_NAMES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_ALTERNATE_NAMES, ALTERNATE_NAMES);
  }
  #[inline]
  pub fn add_EMAIL(&mut self, EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_EMAIL, EMAIL);
  }
  #[inline]
  pub fn add_TELEPHONE(&mut self, TELEPHONE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_TELEPHONE, TELEPHONE);
  }
  #[inline]
  pub fn add_KEYS(&mut self, KEYS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CryptoKey<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_KEYS, KEYS);
  }
  #[inline]
  pub fn add_MULTIFORMAT_ADDRESS(&mut self, MULTIFORMAT_ADDRESS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EPM::VT_MULTIFORMAT_ADDRESS, MULTIFORMAT_ADDRESS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EPMBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EPM");
      ds.field("DN", &self.DN());
      ds.field("LEGAL_NAME", &self.LEGAL_NAME());
      ds.field("FAMILY_NAME", &self.FAMILY_NAME());
      ds.field("GIVEN_NAME", &self.GIVEN_NAME());
      ds.field("ADDITIONAL_NAME", &self.ADDITIONAL_NAME());
      ds.field("HONORIFIC_PREFIX", &self.HONORIFIC_PREFIX());
      ds.field("HONORIFIC_SUFFIX", &self.HONORIFIC_SUFFIX());
      ds.field("JOB_TITLE", &self.JOB_TITLE());
      ds.field("OCCUPATION", &self.OCCUPATION());
      ds.field("ADDRESS", &self.ADDRESS());
      ds.field("ALTERNATE_NAMES", &self.ALTERNATE_NAMES());
      ds.field("EMAIL", &self.EMAIL());
      ds.field("TELEPHONE", &self.TELEPHONE());
      ds.field("KEYS", &self.KEYS());
      ds.field("MULTIFORMAT_ADDRESS", &self.MULTIFORMAT_ADDRESS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EPMT {
  pub DN: Option<String>,
  pub LEGAL_NAME: Option<String>,
  pub FAMILY_NAME: Option<String>,
  pub GIVEN_NAME: Option<String>,
  pub ADDITIONAL_NAME: Option<String>,
  pub HONORIFIC_PREFIX: Option<String>,
  pub HONORIFIC_SUFFIX: Option<String>,
  pub JOB_TITLE: Option<String>,
  pub OCCUPATION: Option<String>,
  pub ADDRESS: Option<Box<AddressT>>,
  pub ALTERNATE_NAMES: Option<Vec<String>>,
  pub EMAIL: Option<String>,
  pub TELEPHONE: Option<String>,
  pub KEYS: Option<Vec<CryptoKeyT>>,
  pub MULTIFORMAT_ADDRESS: Option<Vec<String>>,
}
impl Default for EPMT {
  fn default() -> Self {
    Self {
      DN: None,
      LEGAL_NAME: None,
      FAMILY_NAME: None,
      GIVEN_NAME: None,
      ADDITIONAL_NAME: None,
      HONORIFIC_PREFIX: None,
      HONORIFIC_SUFFIX: None,
      JOB_TITLE: None,
      OCCUPATION: None,
      ADDRESS: None,
      ALTERNATE_NAMES: None,
      EMAIL: None,
      TELEPHONE: None,
      KEYS: None,
      MULTIFORMAT_ADDRESS: None,
    }
  }
}
impl EPMT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EPM<'b>> {
    let DN = self.DN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LEGAL_NAME = self.LEGAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FAMILY_NAME = self.FAMILY_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GIVEN_NAME = self.GIVEN_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDITIONAL_NAME = self.ADDITIONAL_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_PREFIX = self.HONORIFIC_PREFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HONORIFIC_SUFFIX = self.HONORIFIC_SUFFIX.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let JOB_TITLE = self.JOB_TITLE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OCCUPATION = self.OCCUPATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ADDRESS = self.ADDRESS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ALTERNATE_NAMES = self.ALTERNATE_NAMES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EMAIL = self.EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TELEPHONE = self.TELEPHONE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let KEYS = self.KEYS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let MULTIFORMAT_ADDRESS = self.MULTIFORMAT_ADDRESS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    EPM::create(_fbb, &EPMArgs{
      DN,
      LEGAL_NAME,
      FAMILY_NAME,
      GIVEN_NAME,
      ADDITIONAL_NAME,
      HONORIFIC_PREFIX,
      HONORIFIC_SUFFIX,
      JOB_TITLE,
      OCCUPATION,
      ADDRESS,
      ALTERNATE_NAMES,
      EMAIL,
      TELEPHONE,
      KEYS,
      MULTIFORMAT_ADDRESS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `EPM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn root_as_EPM(buf: &[u8]) -> Result<EPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EPM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_EPM_unchecked`.
pub fn size_prefixed_root_as_EPM(buf: &[u8]) -> Result<EPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EPM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn root_as_EPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EPM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EPM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_EPM_unchecked`.
pub fn size_prefixed_root_as_EPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EPM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EPM`.
pub unsafe fn root_as_EPM_unchecked(buf: &[u8]) -> EPM {
  flatbuffers::root_unchecked::<EPM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EPM`.
pub unsafe fn size_prefixed_root_as_EPM_unchecked(buf: &[u8]) -> EPM {
  flatbuffers::size_prefixed_root_unchecked::<EPM>(buf)
}
pub const EPM_IDENTIFIER: &str = "$EPM";

#[inline]
pub fn EPM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPM_IDENTIFIER, false)
}

#[inline]
pub fn EPM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EPM_IDENTIFIER, true)
}

#[inline]
pub fn finish_EPM_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<EPM<'a>>) {
  fbb.finish(root, Some(EPM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_EPM_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<EPM<'a>>) {
  fbb.finish_size_prefixed(root, Some(EPM_IDENTIFIER));
}
