// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MODULE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MODULE_TYPE: i8 = 33;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MODULE_TYPE: [ModuleType; 34] = [
  ModuleType::ENGINE,
  ModuleType::TRANSMISSION,
  ModuleType::FUEL_TANK,
  ModuleType::AMMO_RACK,
  ModuleType::AMMO_FIRST_STAGE,
  ModuleType::GUN_BREECH,
  ModuleType::GUN_BARREL,
  ModuleType::TURRET_RING,
  ModuleType::TURRET_DRIVE,
  ModuleType::TRACKS,
  ModuleType::WHEELS,
  ModuleType::SUSPENSION,
  ModuleType::DRIVER_PORT,
  ModuleType::OPTICS_GUNNER,
  ModuleType::OPTICS_COMMANDER,
  ModuleType::FCS,
  ModuleType::RADIO,
  ModuleType::HYDRAULICS,
  ModuleType::AUTOLOADER,
  ModuleType::ERA_BLOCK,
  ModuleType::RADAR,
  ModuleType::WING_LEFT,
  ModuleType::WING_RIGHT,
  ModuleType::TAIL,
  ModuleType::AILERON_LEFT,
  ModuleType::AILERON_RIGHT,
  ModuleType::ELEVATOR,
  ModuleType::RUDDER,
  ModuleType::LANDING_GEAR,
  ModuleType::MAIN_ROTOR,
  ModuleType::TAIL_ROTOR,
  ModuleType::PROPELLER,
  ModuleType::BRIDGE,
  ModuleType::MAGAZINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ModuleType(pub i8);
#[allow(non_upper_case_globals)]
impl ModuleType {
  pub const ENGINE: Self = Self(0);
  pub const TRANSMISSION: Self = Self(1);
  pub const FUEL_TANK: Self = Self(2);
  pub const AMMO_RACK: Self = Self(3);
  pub const AMMO_FIRST_STAGE: Self = Self(4);
  pub const GUN_BREECH: Self = Self(5);
  pub const GUN_BARREL: Self = Self(6);
  pub const TURRET_RING: Self = Self(7);
  pub const TURRET_DRIVE: Self = Self(8);
  pub const TRACKS: Self = Self(9);
  pub const WHEELS: Self = Self(10);
  pub const SUSPENSION: Self = Self(11);
  pub const DRIVER_PORT: Self = Self(12);
  pub const OPTICS_GUNNER: Self = Self(13);
  pub const OPTICS_COMMANDER: Self = Self(14);
  pub const FCS: Self = Self(15);
  pub const RADIO: Self = Self(16);
  pub const HYDRAULICS: Self = Self(17);
  pub const AUTOLOADER: Self = Self(18);
  pub const ERA_BLOCK: Self = Self(19);
  pub const RADAR: Self = Self(20);
  pub const WING_LEFT: Self = Self(21);
  pub const WING_RIGHT: Self = Self(22);
  pub const TAIL: Self = Self(23);
  pub const AILERON_LEFT: Self = Self(24);
  pub const AILERON_RIGHT: Self = Self(25);
  pub const ELEVATOR: Self = Self(26);
  pub const RUDDER: Self = Self(27);
  pub const LANDING_GEAR: Self = Self(28);
  pub const MAIN_ROTOR: Self = Self(29);
  pub const TAIL_ROTOR: Self = Self(30);
  pub const PROPELLER: Self = Self(31);
  pub const BRIDGE: Self = Self(32);
  pub const MAGAZINE: Self = Self(33);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 33;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ENGINE,
    Self::TRANSMISSION,
    Self::FUEL_TANK,
    Self::AMMO_RACK,
    Self::AMMO_FIRST_STAGE,
    Self::GUN_BREECH,
    Self::GUN_BARREL,
    Self::TURRET_RING,
    Self::TURRET_DRIVE,
    Self::TRACKS,
    Self::WHEELS,
    Self::SUSPENSION,
    Self::DRIVER_PORT,
    Self::OPTICS_GUNNER,
    Self::OPTICS_COMMANDER,
    Self::FCS,
    Self::RADIO,
    Self::HYDRAULICS,
    Self::AUTOLOADER,
    Self::ERA_BLOCK,
    Self::RADAR,
    Self::WING_LEFT,
    Self::WING_RIGHT,
    Self::TAIL,
    Self::AILERON_LEFT,
    Self::AILERON_RIGHT,
    Self::ELEVATOR,
    Self::RUDDER,
    Self::LANDING_GEAR,
    Self::MAIN_ROTOR,
    Self::TAIL_ROTOR,
    Self::PROPELLER,
    Self::BRIDGE,
    Self::MAGAZINE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ENGINE => Some("ENGINE"),
      Self::TRANSMISSION => Some("TRANSMISSION"),
      Self::FUEL_TANK => Some("FUEL_TANK"),
      Self::AMMO_RACK => Some("AMMO_RACK"),
      Self::AMMO_FIRST_STAGE => Some("AMMO_FIRST_STAGE"),
      Self::GUN_BREECH => Some("GUN_BREECH"),
      Self::GUN_BARREL => Some("GUN_BARREL"),
      Self::TURRET_RING => Some("TURRET_RING"),
      Self::TURRET_DRIVE => Some("TURRET_DRIVE"),
      Self::TRACKS => Some("TRACKS"),
      Self::WHEELS => Some("WHEELS"),
      Self::SUSPENSION => Some("SUSPENSION"),
      Self::DRIVER_PORT => Some("DRIVER_PORT"),
      Self::OPTICS_GUNNER => Some("OPTICS_GUNNER"),
      Self::OPTICS_COMMANDER => Some("OPTICS_COMMANDER"),
      Self::FCS => Some("FCS"),
      Self::RADIO => Some("RADIO"),
      Self::HYDRAULICS => Some("HYDRAULICS"),
      Self::AUTOLOADER => Some("AUTOLOADER"),
      Self::ERA_BLOCK => Some("ERA_BLOCK"),
      Self::RADAR => Some("RADAR"),
      Self::WING_LEFT => Some("WING_LEFT"),
      Self::WING_RIGHT => Some("WING_RIGHT"),
      Self::TAIL => Some("TAIL"),
      Self::AILERON_LEFT => Some("AILERON_LEFT"),
      Self::AILERON_RIGHT => Some("AILERON_RIGHT"),
      Self::ELEVATOR => Some("ELEVATOR"),
      Self::RUDDER => Some("RUDDER"),
      Self::LANDING_GEAR => Some("LANDING_GEAR"),
      Self::MAIN_ROTOR => Some("MAIN_ROTOR"),
      Self::TAIL_ROTOR => Some("TAIL_ROTOR"),
      Self::PROPELLER => Some("PROPELLER"),
      Self::BRIDGE => Some("BRIDGE"),
      Self::MAGAZINE => Some("MAGAZINE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ModuleType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ModuleType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ModuleType {
    type Output = ModuleType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ModuleType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ModuleType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ModuleType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MODULE_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MODULE_STATE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MODULE_STATE: [ModuleState; 5] = [
  ModuleState::OPERATIONAL,
  ModuleState::DAMAGED,
  ModuleState::CRITICAL,
  ModuleState::DESTROYED,
  ModuleState::REPAIRING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ModuleState(pub i8);
#[allow(non_upper_case_globals)]
impl ModuleState {
  pub const OPERATIONAL: Self = Self(0);
  pub const DAMAGED: Self = Self(1);
  pub const CRITICAL: Self = Self(2);
  pub const DESTROYED: Self = Self(3);
  pub const REPAIRING: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OPERATIONAL,
    Self::DAMAGED,
    Self::CRITICAL,
    Self::DESTROYED,
    Self::REPAIRING,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OPERATIONAL => Some("OPERATIONAL"),
      Self::DAMAGED => Some("DAMAGED"),
      Self::CRITICAL => Some("CRITICAL"),
      Self::DESTROYED => Some("DESTROYED"),
      Self::REPAIRING => Some("REPAIRING"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ModuleState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ModuleState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ModuleState {
    type Output = ModuleState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ModuleState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ModuleState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ModuleState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CREW_ROLE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CREW_ROLE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CREW_ROLE: [CrewRole; 9] = [
  CrewRole::COMMANDER,
  CrewRole::GUNNER,
  CrewRole::DRIVER,
  CrewRole::LOADER,
  CrewRole::RADIO_OP,
  CrewRole::PILOT,
  CrewRole::COPILOT,
  CrewRole::ENGINEER,
  CrewRole::HELMSMAN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CrewRole(pub i8);
#[allow(non_upper_case_globals)]
impl CrewRole {
  pub const COMMANDER: Self = Self(0);
  pub const GUNNER: Self = Self(1);
  pub const DRIVER: Self = Self(2);
  pub const LOADER: Self = Self(3);
  pub const RADIO_OP: Self = Self(4);
  pub const PILOT: Self = Self(5);
  pub const COPILOT: Self = Self(6);
  pub const ENGINEER: Self = Self(7);
  pub const HELMSMAN: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMMANDER,
    Self::GUNNER,
    Self::DRIVER,
    Self::LOADER,
    Self::RADIO_OP,
    Self::PILOT,
    Self::COPILOT,
    Self::ENGINEER,
    Self::HELMSMAN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::COMMANDER => Some("COMMANDER"),
      Self::GUNNER => Some("GUNNER"),
      Self::DRIVER => Some("DRIVER"),
      Self::LOADER => Some("LOADER"),
      Self::RADIO_OP => Some("RADIO_OP"),
      Self::PILOT => Some("PILOT"),
      Self::COPILOT => Some("COPILOT"),
      Self::ENGINEER => Some("ENGINEER"),
      Self::HELMSMAN => Some("HELMSMAN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CrewRole {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CrewRole {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CrewRole {
    type Output = CrewRole;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CrewRole {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CrewRole {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CrewRole {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CREW_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CREW_STATE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CREW_STATE: [CrewState; 5] = [
  CrewState::ALIVE,
  CrewState::WOUNDED,
  CrewState::UNCONSCIOUS,
  CrewState::DEAD,
  CrewState::BAILED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CrewState(pub i8);
#[allow(non_upper_case_globals)]
impl CrewState {
  pub const ALIVE: Self = Self(0);
  pub const WOUNDED: Self = Self(1);
  pub const UNCONSCIOUS: Self = Self(2);
  pub const DEAD: Self = Self(3);
  pub const BAILED: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALIVE,
    Self::WOUNDED,
    Self::UNCONSCIOUS,
    Self::DEAD,
    Self::BAILED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ALIVE => Some("ALIVE"),
      Self::WOUNDED => Some("WOUNDED"),
      Self::UNCONSCIOUS => Some("UNCONSCIOUS"),
      Self::DEAD => Some("DEAD"),
      Self::BAILED => Some("BAILED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CrewState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CrewState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CrewState {
    type Output = CrewState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CrewState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CrewState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CrewState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DESTRUCTION_CAUSE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DESTRUCTION_CAUSE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DESTRUCTION_CAUSE: [DestructionCause; 6] = [
  DestructionCause::NONE,
  DestructionCause::AMMO_DETONATION,
  DestructionCause::FUEL_FIRE,
  DestructionCause::CREW_LOST,
  DestructionCause::STRUCTURAL_FAILURE,
  DestructionCause::FLOODING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DestructionCause(pub i8);
#[allow(non_upper_case_globals)]
impl DestructionCause {
  pub const NONE: Self = Self(0);
  pub const AMMO_DETONATION: Self = Self(1);
  pub const FUEL_FIRE: Self = Self(2);
  pub const CREW_LOST: Self = Self(3);
  pub const STRUCTURAL_FAILURE: Self = Self(4);
  pub const FLOODING: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AMMO_DETONATION,
    Self::FUEL_FIRE,
    Self::CREW_LOST,
    Self::STRUCTURAL_FAILURE,
    Self::FLOODING,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::AMMO_DETONATION => Some("AMMO_DETONATION"),
      Self::FUEL_FIRE => Some("FUEL_FIRE"),
      Self::CREW_LOST => Some("CREW_LOST"),
      Self::STRUCTURAL_FAILURE => Some("STRUCTURAL_FAILURE"),
      Self::FLOODING => Some("FLOODING"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DestructionCause {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DestructionCause {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DestructionCause {
    type Output = DestructionCause;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DestructionCause {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DestructionCause {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DestructionCause {}
pub enum DMGOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Damage Models
pub struct DMG<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DMG<'a> {
  type Inner = DMG<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DMG<'a> {
  pub const VT_OVERALL_HEALTH: flatbuffers::VOffsetT = 4;
  pub const VT_MOBILITY: flatbuffers::VOffsetT = 6;
  pub const VT_FIREPOWER: flatbuffers::VOffsetT = 8;
  pub const VT_MODULE_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_CREW_COUNT: flatbuffers::VOffsetT = 12;
  pub const VT_FIRE_COUNT: flatbuffers::VOffsetT = 14;
  pub const VT_FLOOD_COUNT: flatbuffers::VOffsetT = 16;
  pub const VT_IS_DESTROYED: flatbuffers::VOffsetT = 18;
  pub const VT_DESTRUCTION_CAUSE: flatbuffers::VOffsetT = 20;
  pub const VT_EXTINGUISHERS: flatbuffers::VOffsetT = 22;
  pub const VT_REPAIR_ACTIVE: flatbuffers::VOffsetT = 24;
  pub const VT_RELOAD_MULTIPLIER: flatbuffers::VOffsetT = 26;
  pub const VT_ACCURACY_MULTIPLIER: flatbuffers::VOffsetT = 28;
  pub const VT_CREW_ALIVE: flatbuffers::VOffsetT = 30;
  pub const VT_CREW_WOUNDED: flatbuffers::VOffsetT = 32;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DMG { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DMGArgs<'args>
  ) -> flatbuffers::WIPOffset<DMG<'bldr>> {
    let mut builder = DMGBuilder::new(_fbb);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_ACCURACY_MULTIPLIER(args.ACCURACY_MULTIPLIER);
    builder.add_RELOAD_MULTIPLIER(args.RELOAD_MULTIPLIER);
    builder.add_FIREPOWER(args.FIREPOWER);
    builder.add_MOBILITY(args.MOBILITY);
    builder.add_OVERALL_HEALTH(args.OVERALL_HEALTH);
    builder.add_CREW_WOUNDED(args.CREW_WOUNDED);
    builder.add_CREW_ALIVE(args.CREW_ALIVE);
    builder.add_REPAIR_ACTIVE(args.REPAIR_ACTIVE);
    builder.add_EXTINGUISHERS(args.EXTINGUISHERS);
    builder.add_DESTRUCTION_CAUSE(args.DESTRUCTION_CAUSE);
    builder.add_IS_DESTROYED(args.IS_DESTROYED);
    builder.add_FLOOD_COUNT(args.FLOOD_COUNT);
    builder.add_FIRE_COUNT(args.FIRE_COUNT);
    builder.add_CREW_COUNT(args.CREW_COUNT);
    builder.add_MODULE_COUNT(args.MODULE_COUNT);
    builder.finish()
  }

  pub fn unpack(&self) -> DMGT {
    let OVERALL_HEALTH = self.OVERALL_HEALTH();
    let MOBILITY = self.MOBILITY();
    let FIREPOWER = self.FIREPOWER();
    let MODULE_COUNT = self.MODULE_COUNT();
    let CREW_COUNT = self.CREW_COUNT();
    let FIRE_COUNT = self.FIRE_COUNT();
    let FLOOD_COUNT = self.FLOOD_COUNT();
    let IS_DESTROYED = self.IS_DESTROYED();
    let DESTRUCTION_CAUSE = self.DESTRUCTION_CAUSE();
    let EXTINGUISHERS = self.EXTINGUISHERS();
    let REPAIR_ACTIVE = self.REPAIR_ACTIVE();
    let RELOAD_MULTIPLIER = self.RELOAD_MULTIPLIER();
    let ACCURACY_MULTIPLIER = self.ACCURACY_MULTIPLIER();
    let CREW_ALIVE = self.CREW_ALIVE();
    let CREW_WOUNDED = self.CREW_WOUNDED();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    DMGT {
      OVERALL_HEALTH,
      MOBILITY,
      FIREPOWER,
      MODULE_COUNT,
      CREW_COUNT,
      FIRE_COUNT,
      FLOOD_COUNT,
      IS_DESTROYED,
      DESTRUCTION_CAUSE,
      EXTINGUISHERS,
      REPAIR_ACTIVE,
      RELOAD_MULTIPLIER,
      ACCURACY_MULTIPLIER,
      CREW_ALIVE,
      CREW_WOUNDED,
      RESERVED,
    }
  }

  #[inline]
  pub fn OVERALL_HEALTH(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DMG::VT_OVERALL_HEALTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MOBILITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DMG::VT_MOBILITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn FIREPOWER(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DMG::VT_FIREPOWER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MODULE_COUNT(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_MODULE_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CREW_COUNT(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_CREW_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FIRE_COUNT(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_FIRE_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FLOOD_COUNT(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_FLOOD_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IS_DESTROYED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_IS_DESTROYED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DESTRUCTION_CAUSE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_DESTRUCTION_CAUSE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EXTINGUISHERS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_EXTINGUISHERS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn REPAIR_ACTIVE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_REPAIR_ACTIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RELOAD_MULTIPLIER(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DMG::VT_RELOAD_MULTIPLIER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ACCURACY_MULTIPLIER(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DMG::VT_ACCURACY_MULTIPLIER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CREW_ALIVE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_CREW_ALIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CREW_WOUNDED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DMG::VT_CREW_WOUNDED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DMG::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for DMG<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("OVERALL_HEALTH", Self::VT_OVERALL_HEALTH, false)?
     .visit_field::<f32>("MOBILITY", Self::VT_MOBILITY, false)?
     .visit_field::<f32>("FIREPOWER", Self::VT_FIREPOWER, false)?
     .visit_field::<u8>("MODULE_COUNT", Self::VT_MODULE_COUNT, false)?
     .visit_field::<u8>("CREW_COUNT", Self::VT_CREW_COUNT, false)?
     .visit_field::<u8>("FIRE_COUNT", Self::VT_FIRE_COUNT, false)?
     .visit_field::<u8>("FLOOD_COUNT", Self::VT_FLOOD_COUNT, false)?
     .visit_field::<u8>("IS_DESTROYED", Self::VT_IS_DESTROYED, false)?
     .visit_field::<u8>("DESTRUCTION_CAUSE", Self::VT_DESTRUCTION_CAUSE, false)?
     .visit_field::<u8>("EXTINGUISHERS", Self::VT_EXTINGUISHERS, false)?
     .visit_field::<u8>("REPAIR_ACTIVE", Self::VT_REPAIR_ACTIVE, false)?
     .visit_field::<f32>("RELOAD_MULTIPLIER", Self::VT_RELOAD_MULTIPLIER, false)?
     .visit_field::<f32>("ACCURACY_MULTIPLIER", Self::VT_ACCURACY_MULTIPLIER, false)?
     .visit_field::<u8>("CREW_ALIVE", Self::VT_CREW_ALIVE, false)?
     .visit_field::<u8>("CREW_WOUNDED", Self::VT_CREW_WOUNDED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct DMGArgs<'a> {
    pub OVERALL_HEALTH: f32,
    pub MOBILITY: f32,
    pub FIREPOWER: f32,
    pub MODULE_COUNT: u8,
    pub CREW_COUNT: u8,
    pub FIRE_COUNT: u8,
    pub FLOOD_COUNT: u8,
    pub IS_DESTROYED: u8,
    pub DESTRUCTION_CAUSE: u8,
    pub EXTINGUISHERS: u8,
    pub REPAIR_ACTIVE: u8,
    pub RELOAD_MULTIPLIER: f32,
    pub ACCURACY_MULTIPLIER: f32,
    pub CREW_ALIVE: u8,
    pub CREW_WOUNDED: u8,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DMGArgs<'a> {
  #[inline]
  fn default() -> Self {
    DMGArgs {
      OVERALL_HEALTH: 0.0,
      MOBILITY: 0.0,
      FIREPOWER: 0.0,
      MODULE_COUNT: 0,
      CREW_COUNT: 0,
      FIRE_COUNT: 0,
      FLOOD_COUNT: 0,
      IS_DESTROYED: 0,
      DESTRUCTION_CAUSE: 0,
      EXTINGUISHERS: 0,
      REPAIR_ACTIVE: 0,
      RELOAD_MULTIPLIER: 0.0,
      ACCURACY_MULTIPLIER: 0.0,
      CREW_ALIVE: 0,
      CREW_WOUNDED: 0,
      RESERVED: None,
    }
  }
}

pub struct DMGBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DMGBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_OVERALL_HEALTH(&mut self, OVERALL_HEALTH: f32) {
    self.fbb_.push_slot::<f32>(DMG::VT_OVERALL_HEALTH, OVERALL_HEALTH, 0.0);
  }
  #[inline]
  pub fn add_MOBILITY(&mut self, MOBILITY: f32) {
    self.fbb_.push_slot::<f32>(DMG::VT_MOBILITY, MOBILITY, 0.0);
  }
  #[inline]
  pub fn add_FIREPOWER(&mut self, FIREPOWER: f32) {
    self.fbb_.push_slot::<f32>(DMG::VT_FIREPOWER, FIREPOWER, 0.0);
  }
  #[inline]
  pub fn add_MODULE_COUNT(&mut self, MODULE_COUNT: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_MODULE_COUNT, MODULE_COUNT, 0);
  }
  #[inline]
  pub fn add_CREW_COUNT(&mut self, CREW_COUNT: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_CREW_COUNT, CREW_COUNT, 0);
  }
  #[inline]
  pub fn add_FIRE_COUNT(&mut self, FIRE_COUNT: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_FIRE_COUNT, FIRE_COUNT, 0);
  }
  #[inline]
  pub fn add_FLOOD_COUNT(&mut self, FLOOD_COUNT: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_FLOOD_COUNT, FLOOD_COUNT, 0);
  }
  #[inline]
  pub fn add_IS_DESTROYED(&mut self, IS_DESTROYED: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_IS_DESTROYED, IS_DESTROYED, 0);
  }
  #[inline]
  pub fn add_DESTRUCTION_CAUSE(&mut self, DESTRUCTION_CAUSE: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_DESTRUCTION_CAUSE, DESTRUCTION_CAUSE, 0);
  }
  #[inline]
  pub fn add_EXTINGUISHERS(&mut self, EXTINGUISHERS: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_EXTINGUISHERS, EXTINGUISHERS, 0);
  }
  #[inline]
  pub fn add_REPAIR_ACTIVE(&mut self, REPAIR_ACTIVE: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_REPAIR_ACTIVE, REPAIR_ACTIVE, 0);
  }
  #[inline]
  pub fn add_RELOAD_MULTIPLIER(&mut self, RELOAD_MULTIPLIER: f32) {
    self.fbb_.push_slot::<f32>(DMG::VT_RELOAD_MULTIPLIER, RELOAD_MULTIPLIER, 0.0);
  }
  #[inline]
  pub fn add_ACCURACY_MULTIPLIER(&mut self, ACCURACY_MULTIPLIER: f32) {
    self.fbb_.push_slot::<f32>(DMG::VT_ACCURACY_MULTIPLIER, ACCURACY_MULTIPLIER, 0.0);
  }
  #[inline]
  pub fn add_CREW_ALIVE(&mut self, CREW_ALIVE: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_CREW_ALIVE, CREW_ALIVE, 0);
  }
  #[inline]
  pub fn add_CREW_WOUNDED(&mut self, CREW_WOUNDED: u8) {
    self.fbb_.push_slot::<u8>(DMG::VT_CREW_WOUNDED, CREW_WOUNDED, 0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DMG::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DMGBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DMGBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DMG<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DMG<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DMG");
      ds.field("OVERALL_HEALTH", &self.OVERALL_HEALTH());
      ds.field("MOBILITY", &self.MOBILITY());
      ds.field("FIREPOWER", &self.FIREPOWER());
      ds.field("MODULE_COUNT", &self.MODULE_COUNT());
      ds.field("CREW_COUNT", &self.CREW_COUNT());
      ds.field("FIRE_COUNT", &self.FIRE_COUNT());
      ds.field("FLOOD_COUNT", &self.FLOOD_COUNT());
      ds.field("IS_DESTROYED", &self.IS_DESTROYED());
      ds.field("DESTRUCTION_CAUSE", &self.DESTRUCTION_CAUSE());
      ds.field("EXTINGUISHERS", &self.EXTINGUISHERS());
      ds.field("REPAIR_ACTIVE", &self.REPAIR_ACTIVE());
      ds.field("RELOAD_MULTIPLIER", &self.RELOAD_MULTIPLIER());
      ds.field("ACCURACY_MULTIPLIER", &self.ACCURACY_MULTIPLIER());
      ds.field("CREW_ALIVE", &self.CREW_ALIVE());
      ds.field("CREW_WOUNDED", &self.CREW_WOUNDED());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DMGT {
  pub OVERALL_HEALTH: f32,
  pub MOBILITY: f32,
  pub FIREPOWER: f32,
  pub MODULE_COUNT: u8,
  pub CREW_COUNT: u8,
  pub FIRE_COUNT: u8,
  pub FLOOD_COUNT: u8,
  pub IS_DESTROYED: u8,
  pub DESTRUCTION_CAUSE: u8,
  pub EXTINGUISHERS: u8,
  pub REPAIR_ACTIVE: u8,
  pub RELOAD_MULTIPLIER: f32,
  pub ACCURACY_MULTIPLIER: f32,
  pub CREW_ALIVE: u8,
  pub CREW_WOUNDED: u8,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for DMGT {
  fn default() -> Self {
    Self {
      OVERALL_HEALTH: 0.0,
      MOBILITY: 0.0,
      FIREPOWER: 0.0,
      MODULE_COUNT: 0,
      CREW_COUNT: 0,
      FIRE_COUNT: 0,
      FLOOD_COUNT: 0,
      IS_DESTROYED: 0,
      DESTRUCTION_CAUSE: 0,
      EXTINGUISHERS: 0,
      REPAIR_ACTIVE: 0,
      RELOAD_MULTIPLIER: 0.0,
      ACCURACY_MULTIPLIER: 0.0,
      CREW_ALIVE: 0,
      CREW_WOUNDED: 0,
      RESERVED: None,
    }
  }
}
impl DMGT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DMG<'b>> {
    let OVERALL_HEALTH = self.OVERALL_HEALTH;
    let MOBILITY = self.MOBILITY;
    let FIREPOWER = self.FIREPOWER;
    let MODULE_COUNT = self.MODULE_COUNT;
    let CREW_COUNT = self.CREW_COUNT;
    let FIRE_COUNT = self.FIRE_COUNT;
    let FLOOD_COUNT = self.FLOOD_COUNT;
    let IS_DESTROYED = self.IS_DESTROYED;
    let DESTRUCTION_CAUSE = self.DESTRUCTION_CAUSE;
    let EXTINGUISHERS = self.EXTINGUISHERS;
    let REPAIR_ACTIVE = self.REPAIR_ACTIVE;
    let RELOAD_MULTIPLIER = self.RELOAD_MULTIPLIER;
    let ACCURACY_MULTIPLIER = self.ACCURACY_MULTIPLIER;
    let CREW_ALIVE = self.CREW_ALIVE;
    let CREW_WOUNDED = self.CREW_WOUNDED;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    DMG::create(_fbb, &DMGArgs{
      OVERALL_HEALTH,
      MOBILITY,
      FIREPOWER,
      MODULE_COUNT,
      CREW_COUNT,
      FIRE_COUNT,
      FLOOD_COUNT,
      IS_DESTROYED,
      DESTRUCTION_CAUSE,
      EXTINGUISHERS,
      REPAIR_ACTIVE,
      RELOAD_MULTIPLIER,
      ACCURACY_MULTIPLIER,
      CREW_ALIVE,
      CREW_WOUNDED,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DMG`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_DMG_unchecked`.
pub fn root_as_DMG(buf: &[u8]) -> Result<DMG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<DMG>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DMG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_DMG_unchecked`.
pub fn size_prefixed_root_as_DMG(buf: &[u8]) -> Result<DMG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<DMG>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DMG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_DMG_unchecked`.
pub fn root_as_DMG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DMG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<DMG<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DMG` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_DMG_unchecked`.
pub fn size_prefixed_root_as_DMG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DMG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<DMG<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DMG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DMG`.
pub unsafe fn root_as_DMG_unchecked(buf: &[u8]) -> DMG {
  flatbuffers::root_unchecked::<DMG>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DMG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DMG`.
pub unsafe fn size_prefixed_root_as_DMG_unchecked(buf: &[u8]) -> DMG {
  flatbuffers::size_prefixed_root_unchecked::<DMG>(buf)
}
pub const DMG_IDENTIFIER: &str = "$DMG";

#[inline]
pub fn DMG_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DMG_IDENTIFIER, false)
}

#[inline]
pub fn DMG_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DMG_IDENTIFIER, true)
}

#[inline]
pub fn finish_DMG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<DMG<'a>>) {
  fbb.finish(root, Some(DMG_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_DMG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<DMG<'a>>) {
  fbb.finish_size_prefixed(root, Some(DMG_IDENTIFIER));
}
