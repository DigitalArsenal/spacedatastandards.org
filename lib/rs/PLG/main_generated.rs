// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLUGIN_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLUGIN_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLUGIN_TYPE: [pluginType; 8] = [
  pluginType::Sensor,
  pluginType::Propagator,
  pluginType::Renderer,
  pluginType::Analysis,
  pluginType::DataSource,
  pluginType::EW,
  pluginType::Comms,
  pluginType::Physics,
];

/// Plugin type category
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct pluginType(pub i8);
#[allow(non_upper_case_globals)]
impl pluginType {
  /// Sensor simulation and analysis
  pub const Sensor: Self = Self(0);
  /// Orbital propagation algorithms
  pub const Propagator: Self = Self(1);
  /// Custom rendering/visualization
  pub const Renderer: Self = Self(2);
  /// Data analysis and processing
  pub const Analysis: Self = Self(3);
  /// External data source integration
  pub const DataSource: Self = Self(4);
  /// Electronic warfare simulation
  pub const EW: Self = Self(5);
  /// Communications modeling
  pub const Comms: Self = Self(6);
  /// Physics simulation
  pub const Physics: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Sensor,
    Self::Propagator,
    Self::Renderer,
    Self::Analysis,
    Self::DataSource,
    Self::EW,
    Self::Comms,
    Self::Physics,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Sensor => Some("Sensor"),
      Self::Propagator => Some("Propagator"),
      Self::Renderer => Some("Renderer"),
      Self::Analysis => Some("Analysis"),
      Self::DataSource => Some("DataSource"),
      Self::EW => Some("EW"),
      Self::Comms => Some("Comms"),
      Self::Physics => Some("Physics"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for pluginType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for pluginType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for pluginType {
    type Output = pluginType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for pluginType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for pluginType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for pluginType {}
pub enum PluginCapabilityOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Plugin capability declaration
pub struct PluginCapability<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginCapability<'a> {
  type Inner = PluginCapability<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginCapability<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_REQUIRED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginCapability { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PluginCapabilityArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginCapability<'bldr>> {
    let mut builder = PluginCapabilityBuilder::new(_fbb);
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_REQUIRED(args.REQUIRED);
    builder.finish()
  }

  pub fn unpack(&self) -> PluginCapabilityT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let VERSION = self.VERSION().map(|x| {
      x.to_string()
    });
    let REQUIRED = self.REQUIRED();
    PluginCapabilityT {
      NAME,
      VERSION,
      REQUIRED,
    }
  }

  /// Capability name, e.g., "gpu_compute", "wasm_simd"
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginCapability::VT_NAME, None)}
  }
  /// Capability version
  #[inline]
  pub fn VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginCapability::VT_VERSION, None)}
  }
  /// Whether this capability is required
  #[inline]
  pub fn REQUIRED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PluginCapability::VT_REQUIRED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PluginCapability<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<bool>("REQUIRED", Self::VT_REQUIRED, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginCapabilityArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REQUIRED: bool,
}
impl<'a> Default for PluginCapabilityArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginCapabilityArgs {
      NAME: None,
      VERSION: None,
      REQUIRED: false,
    }
  }
}

pub struct PluginCapabilityBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PluginCapabilityBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginCapability::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginCapability::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_REQUIRED(&mut self, REQUIRED: bool) {
    self.fbb_.push_slot::<bool>(PluginCapability::VT_REQUIRED, REQUIRED, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PluginCapabilityBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PluginCapabilityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginCapability<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginCapability<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginCapability");
      ds.field("NAME", &self.NAME());
      ds.field("VERSION", &self.VERSION());
      ds.field("REQUIRED", &self.REQUIRED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PluginCapabilityT {
  pub NAME: Option<String>,
  pub VERSION: Option<String>,
  pub REQUIRED: bool,
}
impl Default for PluginCapabilityT {
  fn default() -> Self {
    Self {
      NAME: None,
      VERSION: None,
      REQUIRED: false,
    }
  }
}
impl PluginCapabilityT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PluginCapability<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VERSION = self.VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REQUIRED = self.REQUIRED;
    PluginCapability::create(_fbb, &PluginCapabilityArgs{
      NAME,
      VERSION,
      REQUIRED,
    })
  }
}
pub enum PluginDependencyOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Plugin dependency on another plugin
pub struct PluginDependency<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginDependency<'a> {
  type Inner = PluginDependency<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginDependency<'a> {
  pub const VT_PLUGIN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MIN_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_MAX_VERSION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginDependency { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PluginDependencyArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginDependency<'bldr>> {
    let mut builder = PluginDependencyBuilder::new(_fbb);
    if let Some(x) = args.MAX_VERSION { builder.add_MAX_VERSION(x); }
    if let Some(x) = args.MIN_VERSION { builder.add_MIN_VERSION(x); }
    if let Some(x) = args.PLUGIN_ID { builder.add_PLUGIN_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PluginDependencyT {
    let PLUGIN_ID = self.PLUGIN_ID().map(|x| {
      x.to_string()
    });
    let MIN_VERSION = self.MIN_VERSION().map(|x| {
      x.to_string()
    });
    let MAX_VERSION = self.MAX_VERSION().map(|x| {
      x.to_string()
    });
    PluginDependencyT {
      PLUGIN_ID,
      MIN_VERSION,
      MAX_VERSION,
    }
  }

  /// Plugin ID of the dependency
  #[inline]
  pub fn PLUGIN_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginDependency::VT_PLUGIN_ID, None)}
  }
  /// Minimum version required (semver)
  #[inline]
  pub fn MIN_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginDependency::VT_MIN_VERSION, None)}
  }
  /// Maximum version allowed (optional)
  #[inline]
  pub fn MAX_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginDependency::VT_MAX_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for PluginDependency<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PLUGIN_ID", Self::VT_PLUGIN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MIN_VERSION", Self::VT_MIN_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MAX_VERSION", Self::VT_MAX_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginDependencyArgs<'a> {
    pub PLUGIN_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MIN_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MAX_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PluginDependencyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginDependencyArgs {
      PLUGIN_ID: None,
      MIN_VERSION: None,
      MAX_VERSION: None,
    }
  }
}

pub struct PluginDependencyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PluginDependencyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PLUGIN_ID(&mut self, PLUGIN_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginDependency::VT_PLUGIN_ID, PLUGIN_ID);
  }
  #[inline]
  pub fn add_MIN_VERSION(&mut self, MIN_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginDependency::VT_MIN_VERSION, MIN_VERSION);
  }
  #[inline]
  pub fn add_MAX_VERSION(&mut self, MAX_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginDependency::VT_MAX_VERSION, MAX_VERSION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PluginDependencyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PluginDependencyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginDependency<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginDependency<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginDependency");
      ds.field("PLUGIN_ID", &self.PLUGIN_ID());
      ds.field("MIN_VERSION", &self.MIN_VERSION());
      ds.field("MAX_VERSION", &self.MAX_VERSION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PluginDependencyT {
  pub PLUGIN_ID: Option<String>,
  pub MIN_VERSION: Option<String>,
  pub MAX_VERSION: Option<String>,
}
impl Default for PluginDependencyT {
  fn default() -> Self {
    Self {
      PLUGIN_ID: None,
      MIN_VERSION: None,
      MAX_VERSION: None,
    }
  }
}
impl PluginDependencyT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PluginDependency<'b>> {
    let PLUGIN_ID = self.PLUGIN_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MIN_VERSION = self.MIN_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MAX_VERSION = self.MAX_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    PluginDependency::create(_fbb, &PluginDependencyArgs{
      PLUGIN_ID,
      MIN_VERSION,
      MAX_VERSION,
    })
  }
}
pub enum EntryFunctionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Plugin entry point function definition
pub struct EntryFunction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntryFunction<'a> {
  type Inner = EntryFunction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntryFunction<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_SCHEMAS: flatbuffers::VOffsetT = 8;
  pub const VT_OUTPUT_SCHEMA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntryFunction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EntryFunctionArgs<'args>
  ) -> flatbuffers::WIPOffset<EntryFunction<'bldr>> {
    let mut builder = EntryFunctionBuilder::new(_fbb);
    if let Some(x) = args.OUTPUT_SCHEMA { builder.add_OUTPUT_SCHEMA(x); }
    if let Some(x) = args.INPUT_SCHEMAS { builder.add_INPUT_SCHEMAS(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EntryFunctionT {
    let NAME = {
      let x = self.NAME();
      x.to_string()
    };
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let INPUT_SCHEMAS = self.INPUT_SCHEMAS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let OUTPUT_SCHEMA = self.OUTPUT_SCHEMA().map(|x| {
      x.to_string()
    });
    EntryFunctionT {
      NAME,
      DESCRIPTION,
      INPUT_SCHEMAS,
      OUTPUT_SCHEMA,
    }
  }

  /// Function name as exported from WASM
  #[inline]
  pub fn NAME(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryFunction::VT_NAME, None).unwrap()}
  }
  /// Human-readable description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryFunction::VT_DESCRIPTION, None)}
  }
  /// Input parameter types (FlatBuffer schema names)
  #[inline]
  pub fn INPUT_SCHEMAS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(EntryFunction::VT_INPUT_SCHEMAS, None)}
  }
  /// Output type (FlatBuffer schema name)
  #[inline]
  pub fn OUTPUT_SCHEMA(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntryFunction::VT_OUTPUT_SCHEMA, None)}
  }
}

impl flatbuffers::Verifiable for EntryFunction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("INPUT_SCHEMAS", Self::VT_INPUT_SCHEMAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OUTPUT_SCHEMA", Self::VT_OUTPUT_SCHEMA, false)?
     .finish();
    Ok(())
  }
}
pub struct EntryFunctionArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INPUT_SCHEMAS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub OUTPUT_SCHEMA: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EntryFunctionArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntryFunctionArgs {
      NAME: None, // required field
      DESCRIPTION: None,
      INPUT_SCHEMAS: None,
      OUTPUT_SCHEMA: None,
    }
  }
}

pub struct EntryFunctionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EntryFunctionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryFunction::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryFunction::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_INPUT_SCHEMAS(&mut self, INPUT_SCHEMAS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryFunction::VT_INPUT_SCHEMAS, INPUT_SCHEMAS);
  }
  #[inline]
  pub fn add_OUTPUT_SCHEMA(&mut self, OUTPUT_SCHEMA: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntryFunction::VT_OUTPUT_SCHEMA, OUTPUT_SCHEMA);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EntryFunctionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EntryFunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntryFunction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, EntryFunction::VT_NAME,"NAME");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntryFunction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntryFunction");
      ds.field("NAME", &self.NAME());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("INPUT_SCHEMAS", &self.INPUT_SCHEMAS());
      ds.field("OUTPUT_SCHEMA", &self.OUTPUT_SCHEMA());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EntryFunctionT {
  pub NAME: String,
  pub DESCRIPTION: Option<String>,
  pub INPUT_SCHEMAS: Option<Vec<String>>,
  pub OUTPUT_SCHEMA: Option<String>,
}
impl Default for EntryFunctionT {
  fn default() -> Self {
    Self {
      NAME: "".to_string(),
      DESCRIPTION: None,
      INPUT_SCHEMAS: None,
      OUTPUT_SCHEMA: None,
    }
  }
}
impl EntryFunctionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EntryFunction<'b>> {
    let NAME = Some({
      let x = &self.NAME;
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INPUT_SCHEMAS = self.INPUT_SCHEMAS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let OUTPUT_SCHEMA = self.OUTPUT_SCHEMA.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EntryFunction::create(_fbb, &EntryFunctionArgs{
      NAME,
      DESCRIPTION,
      INPUT_SCHEMAS,
      OUTPUT_SCHEMA,
    })
  }
}
pub enum PLGOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Plugin Manifest - WASM plugin distribution
pub struct PLG<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PLG<'a> {
  type Inner = PLG<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PLG<'a> {
  pub const VT_PLUGIN_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_VERSION: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_PLUGIN_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_ABI_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_WASM_HASH: flatbuffers::VOffsetT = 16;
  pub const VT_WASM_SIZE: flatbuffers::VOffsetT = 18;
  pub const VT_WASM_CID: flatbuffers::VOffsetT = 20;
  pub const VT_ENTRY_FUNCTIONS: flatbuffers::VOffsetT = 22;
  pub const VT_REQUIRED_SCHEMAS: flatbuffers::VOffsetT = 24;
  pub const VT_DEPENDENCIES: flatbuffers::VOffsetT = 26;
  pub const VT_CAPABILITIES: flatbuffers::VOffsetT = 28;
  pub const VT_PROVIDER_PEER_ID: flatbuffers::VOffsetT = 30;
  pub const VT_PROVIDER_EPM_CID: flatbuffers::VOffsetT = 32;
  pub const VT_ENCRYPTED: flatbuffers::VOffsetT = 34;
  pub const VT_MIN_PERMISSIONS: flatbuffers::VOffsetT = 36;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 38;
  pub const VT_UPDATED_AT: flatbuffers::VOffsetT = 40;
  pub const VT_DOCUMENTATION_URL: flatbuffers::VOffsetT = 42;
  pub const VT_ICON_URL: flatbuffers::VOffsetT = 44;
  pub const VT_LICENSE: flatbuffers::VOffsetT = 46;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PLG { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PLGArgs<'args>
  ) -> flatbuffers::WIPOffset<PLG<'bldr>> {
    let mut builder = PLGBuilder::new(_fbb);
    builder.add_UPDATED_AT(args.UPDATED_AT);
    builder.add_CREATED_AT(args.CREATED_AT);
    builder.add_WASM_SIZE(args.WASM_SIZE);
    if let Some(x) = args.SIGNATURE { builder.add_SIGNATURE(x); }
    if let Some(x) = args.LICENSE { builder.add_LICENSE(x); }
    if let Some(x) = args.ICON_URL { builder.add_ICON_URL(x); }
    if let Some(x) = args.DOCUMENTATION_URL { builder.add_DOCUMENTATION_URL(x); }
    if let Some(x) = args.MIN_PERMISSIONS { builder.add_MIN_PERMISSIONS(x); }
    if let Some(x) = args.PROVIDER_EPM_CID { builder.add_PROVIDER_EPM_CID(x); }
    if let Some(x) = args.PROVIDER_PEER_ID { builder.add_PROVIDER_PEER_ID(x); }
    if let Some(x) = args.CAPABILITIES { builder.add_CAPABILITIES(x); }
    if let Some(x) = args.DEPENDENCIES { builder.add_DEPENDENCIES(x); }
    if let Some(x) = args.REQUIRED_SCHEMAS { builder.add_REQUIRED_SCHEMAS(x); }
    if let Some(x) = args.ENTRY_FUNCTIONS { builder.add_ENTRY_FUNCTIONS(x); }
    if let Some(x) = args.WASM_CID { builder.add_WASM_CID(x); }
    if let Some(x) = args.WASM_HASH { builder.add_WASM_HASH(x); }
    builder.add_ABI_VERSION(args.ABI_VERSION);
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.PLUGIN_ID { builder.add_PLUGIN_ID(x); }
    builder.add_ENCRYPTED(args.ENCRYPTED);
    builder.add_PLUGIN_TYPE(args.PLUGIN_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> PLGT {
    let PLUGIN_ID = {
      let x = self.PLUGIN_ID();
      x.to_string()
    };
    let NAME = {
      let x = self.NAME();
      x.to_string()
    };
    let VERSION = {
      let x = self.VERSION();
      x.to_string()
    };
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let PLUGIN_TYPE = self.PLUGIN_TYPE();
    let ABI_VERSION = self.ABI_VERSION();
    let WASM_HASH = self.WASM_HASH().map(|x| {
      x.into_iter().collect()
    });
    let WASM_SIZE = self.WASM_SIZE();
    let WASM_CID = self.WASM_CID().map(|x| {
      x.to_string()
    });
    let ENTRY_FUNCTIONS = self.ENTRY_FUNCTIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let REQUIRED_SCHEMAS = self.REQUIRED_SCHEMAS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DEPENDENCIES = self.DEPENDENCIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let CAPABILITIES = self.CAPABILITIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let PROVIDER_PEER_ID = self.PROVIDER_PEER_ID().map(|x| {
      x.to_string()
    });
    let PROVIDER_EPM_CID = self.PROVIDER_EPM_CID().map(|x| {
      x.to_string()
    });
    let ENCRYPTED = self.ENCRYPTED();
    let MIN_PERMISSIONS = self.MIN_PERMISSIONS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let CREATED_AT = self.CREATED_AT();
    let UPDATED_AT = self.UPDATED_AT();
    let DOCUMENTATION_URL = self.DOCUMENTATION_URL().map(|x| {
      x.to_string()
    });
    let ICON_URL = self.ICON_URL().map(|x| {
      x.to_string()
    });
    let LICENSE = self.LICENSE().map(|x| {
      x.to_string()
    });
    let SIGNATURE = self.SIGNATURE().map(|x| {
      x.into_iter().collect()
    });
    PLGT {
      PLUGIN_ID,
      NAME,
      VERSION,
      DESCRIPTION,
      PLUGIN_TYPE,
      ABI_VERSION,
      WASM_HASH,
      WASM_SIZE,
      WASM_CID,
      ENTRY_FUNCTIONS,
      REQUIRED_SCHEMAS,
      DEPENDENCIES,
      CAPABILITIES,
      PROVIDER_PEER_ID,
      PROVIDER_EPM_CID,
      ENCRYPTED,
      MIN_PERMISSIONS,
      CREATED_AT,
      UPDATED_AT,
      DOCUMENTATION_URL,
      ICON_URL,
      LICENSE,
      SIGNATURE,
    }
  }

  /// Unique identifier for the plugin
  #[inline]
  pub fn PLUGIN_ID(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_PLUGIN_ID, None).unwrap()}
  }
  /// Human-readable plugin name
  #[inline]
  pub fn NAME(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_NAME, None).unwrap()}
  }
  /// Plugin version (semver format)
  #[inline]
  pub fn VERSION(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_VERSION, None).unwrap()}
  }
  /// Detailed description of plugin functionality
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_DESCRIPTION, None)}
  }
  /// Type/category of the plugin
  #[inline]
  pub fn PLUGIN_TYPE(&self) -> pluginType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<pluginType>(PLG::VT_PLUGIN_TYPE, Some(pluginType::Sensor)).unwrap()}
  }
  /// ABI version for compatibility checking
  #[inline]
  pub fn ABI_VERSION(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PLG::VT_ABI_VERSION, Some(1)).unwrap()}
  }
  /// SHA256 hash of the decrypted WASM binary
  #[inline]
  pub fn WASM_HASH(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PLG::VT_WASM_HASH, None)}
  }
  /// Size of WASM binary in bytes
  #[inline]
  pub fn WASM_SIZE(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLG::VT_WASM_SIZE, Some(0)).unwrap()}
  }
  /// IPFS CID of the encrypted WASM binary
  #[inline]
  pub fn WASM_CID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_WASM_CID, None)}
  }
  /// Entry point functions exported by the plugin
  #[inline]
  pub fn ENTRY_FUNCTIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryFunction<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryFunction>>>>(PLG::VT_ENTRY_FUNCTIONS, None)}
  }
  /// FlatBuffer schemas required by this plugin
  #[inline]
  pub fn REQUIRED_SCHEMAS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PLG::VT_REQUIRED_SCHEMAS, None)}
  }
  /// Other plugins this depends on
  #[inline]
  pub fn DEPENDENCIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginDependency<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginDependency>>>>(PLG::VT_DEPENDENCIES, None)}
  }
  /// Capabilities provided by this plugin
  #[inline]
  pub fn CAPABILITIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginCapability<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginCapability>>>>(PLG::VT_CAPABILITIES, None)}
  }
  /// Peer ID of the plugin provider
  #[inline]
  pub fn PROVIDER_PEER_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_PROVIDER_PEER_ID, None)}
  }
  /// IPFS CID of provider's EPM (Entity Profile Message)
  #[inline]
  pub fn PROVIDER_EPM_CID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_PROVIDER_EPM_CID, None)}
  }
  /// Whether the WASM binary is encrypted
  #[inline]
  pub fn ENCRYPTED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PLG::VT_ENCRYPTED, Some(true)).unwrap()}
  }
  /// Minimum permissions required to run
  #[inline]
  pub fn MIN_PERMISSIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PLG::VT_MIN_PERMISSIONS, None)}
  }
  /// Unix timestamp when plugin was created
  #[inline]
  pub fn CREATED_AT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLG::VT_CREATED_AT, Some(0)).unwrap()}
  }
  /// Unix timestamp when plugin was last updated
  #[inline]
  pub fn UPDATED_AT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLG::VT_UPDATED_AT, Some(0)).unwrap()}
  }
  /// URL to plugin documentation
  #[inline]
  pub fn DOCUMENTATION_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_DOCUMENTATION_URL, None)}
  }
  /// URL to plugin icon/logo
  #[inline]
  pub fn ICON_URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_ICON_URL, None)}
  }
  /// License identifier (SPDX format)
  #[inline]
  pub fn LICENSE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLG::VT_LICENSE, None)}
  }
  /// Ed25519 signature from provider over manifest
  #[inline]
  pub fn SIGNATURE(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PLG::VT_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for PLG<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PLUGIN_ID", Self::VT_PLUGIN_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<pluginType>("PLUGIN_TYPE", Self::VT_PLUGIN_TYPE, false)?
     .visit_field::<u32>("ABI_VERSION", Self::VT_ABI_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("WASM_HASH", Self::VT_WASM_HASH, false)?
     .visit_field::<u64>("WASM_SIZE", Self::VT_WASM_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("WASM_CID", Self::VT_WASM_CID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntryFunction>>>>("ENTRY_FUNCTIONS", Self::VT_ENTRY_FUNCTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("REQUIRED_SCHEMAS", Self::VT_REQUIRED_SCHEMAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PluginDependency>>>>("DEPENDENCIES", Self::VT_DEPENDENCIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PluginCapability>>>>("CAPABILITIES", Self::VT_CAPABILITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROVIDER_PEER_ID", Self::VT_PROVIDER_PEER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROVIDER_EPM_CID", Self::VT_PROVIDER_EPM_CID, false)?
     .visit_field::<bool>("ENCRYPTED", Self::VT_ENCRYPTED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MIN_PERMISSIONS", Self::VT_MIN_PERMISSIONS, false)?
     .visit_field::<u64>("CREATED_AT", Self::VT_CREATED_AT, false)?
     .visit_field::<u64>("UPDATED_AT", Self::VT_UPDATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DOCUMENTATION_URL", Self::VT_DOCUMENTATION_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ICON_URL", Self::VT_ICON_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LICENSE", Self::VT_LICENSE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("SIGNATURE", Self::VT_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct PLGArgs<'a> {
    pub PLUGIN_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PLUGIN_TYPE: pluginType,
    pub ABI_VERSION: u32,
    pub WASM_HASH: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub WASM_SIZE: u64,
    pub WASM_CID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENTRY_FUNCTIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntryFunction<'a>>>>>,
    pub REQUIRED_SCHEMAS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DEPENDENCIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginDependency<'a>>>>>,
    pub CAPABILITIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PluginCapability<'a>>>>>,
    pub PROVIDER_PEER_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROVIDER_EPM_CID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENCRYPTED: bool,
    pub MIN_PERMISSIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub CREATED_AT: u64,
    pub UPDATED_AT: u64,
    pub DOCUMENTATION_URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ICON_URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LICENSE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIGNATURE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for PLGArgs<'a> {
  #[inline]
  fn default() -> Self {
    PLGArgs {
      PLUGIN_ID: None, // required field
      NAME: None, // required field
      VERSION: None, // required field
      DESCRIPTION: None,
      PLUGIN_TYPE: pluginType::Sensor,
      ABI_VERSION: 1,
      WASM_HASH: None,
      WASM_SIZE: 0,
      WASM_CID: None,
      ENTRY_FUNCTIONS: None,
      REQUIRED_SCHEMAS: None,
      DEPENDENCIES: None,
      CAPABILITIES: None,
      PROVIDER_PEER_ID: None,
      PROVIDER_EPM_CID: None,
      ENCRYPTED: true,
      MIN_PERMISSIONS: None,
      CREATED_AT: 0,
      UPDATED_AT: 0,
      DOCUMENTATION_URL: None,
      ICON_URL: None,
      LICENSE: None,
      SIGNATURE: None,
    }
  }
}

pub struct PLGBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PLGBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PLUGIN_ID(&mut self, PLUGIN_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_PLUGIN_ID, PLUGIN_ID);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_PLUGIN_TYPE(&mut self, PLUGIN_TYPE: pluginType) {
    self.fbb_.push_slot::<pluginType>(PLG::VT_PLUGIN_TYPE, PLUGIN_TYPE, pluginType::Sensor);
  }
  #[inline]
  pub fn add_ABI_VERSION(&mut self, ABI_VERSION: u32) {
    self.fbb_.push_slot::<u32>(PLG::VT_ABI_VERSION, ABI_VERSION, 1);
  }
  #[inline]
  pub fn add_WASM_HASH(&mut self, WASM_HASH: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_WASM_HASH, WASM_HASH);
  }
  #[inline]
  pub fn add_WASM_SIZE(&mut self, WASM_SIZE: u64) {
    self.fbb_.push_slot::<u64>(PLG::VT_WASM_SIZE, WASM_SIZE, 0);
  }
  #[inline]
  pub fn add_WASM_CID(&mut self, WASM_CID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_WASM_CID, WASM_CID);
  }
  #[inline]
  pub fn add_ENTRY_FUNCTIONS(&mut self, ENTRY_FUNCTIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntryFunction<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_ENTRY_FUNCTIONS, ENTRY_FUNCTIONS);
  }
  #[inline]
  pub fn add_REQUIRED_SCHEMAS(&mut self, REQUIRED_SCHEMAS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_REQUIRED_SCHEMAS, REQUIRED_SCHEMAS);
  }
  #[inline]
  pub fn add_DEPENDENCIES(&mut self, DEPENDENCIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PluginDependency<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_DEPENDENCIES, DEPENDENCIES);
  }
  #[inline]
  pub fn add_CAPABILITIES(&mut self, CAPABILITIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PluginCapability<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_CAPABILITIES, CAPABILITIES);
  }
  #[inline]
  pub fn add_PROVIDER_PEER_ID(&mut self, PROVIDER_PEER_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_PROVIDER_PEER_ID, PROVIDER_PEER_ID);
  }
  #[inline]
  pub fn add_PROVIDER_EPM_CID(&mut self, PROVIDER_EPM_CID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_PROVIDER_EPM_CID, PROVIDER_EPM_CID);
  }
  #[inline]
  pub fn add_ENCRYPTED(&mut self, ENCRYPTED: bool) {
    self.fbb_.push_slot::<bool>(PLG::VT_ENCRYPTED, ENCRYPTED, true);
  }
  #[inline]
  pub fn add_MIN_PERMISSIONS(&mut self, MIN_PERMISSIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_MIN_PERMISSIONS, MIN_PERMISSIONS);
  }
  #[inline]
  pub fn add_CREATED_AT(&mut self, CREATED_AT: u64) {
    self.fbb_.push_slot::<u64>(PLG::VT_CREATED_AT, CREATED_AT, 0);
  }
  #[inline]
  pub fn add_UPDATED_AT(&mut self, UPDATED_AT: u64) {
    self.fbb_.push_slot::<u64>(PLG::VT_UPDATED_AT, UPDATED_AT, 0);
  }
  #[inline]
  pub fn add_DOCUMENTATION_URL(&mut self, DOCUMENTATION_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_DOCUMENTATION_URL, DOCUMENTATION_URL);
  }
  #[inline]
  pub fn add_ICON_URL(&mut self, ICON_URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_ICON_URL, ICON_URL);
  }
  #[inline]
  pub fn add_LICENSE(&mut self, LICENSE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_LICENSE, LICENSE);
  }
  #[inline]
  pub fn add_SIGNATURE(&mut self, SIGNATURE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLG::VT_SIGNATURE, SIGNATURE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PLGBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PLGBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PLG<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PLG::VT_PLUGIN_ID,"PLUGIN_ID");
    self.fbb_.required(o, PLG::VT_NAME,"NAME");
    self.fbb_.required(o, PLG::VT_VERSION,"VERSION");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PLG<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PLG");
      ds.field("PLUGIN_ID", &self.PLUGIN_ID());
      ds.field("NAME", &self.NAME());
      ds.field("VERSION", &self.VERSION());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("PLUGIN_TYPE", &self.PLUGIN_TYPE());
      ds.field("ABI_VERSION", &self.ABI_VERSION());
      ds.field("WASM_HASH", &self.WASM_HASH());
      ds.field("WASM_SIZE", &self.WASM_SIZE());
      ds.field("WASM_CID", &self.WASM_CID());
      ds.field("ENTRY_FUNCTIONS", &self.ENTRY_FUNCTIONS());
      ds.field("REQUIRED_SCHEMAS", &self.REQUIRED_SCHEMAS());
      ds.field("DEPENDENCIES", &self.DEPENDENCIES());
      ds.field("CAPABILITIES", &self.CAPABILITIES());
      ds.field("PROVIDER_PEER_ID", &self.PROVIDER_PEER_ID());
      ds.field("PROVIDER_EPM_CID", &self.PROVIDER_EPM_CID());
      ds.field("ENCRYPTED", &self.ENCRYPTED());
      ds.field("MIN_PERMISSIONS", &self.MIN_PERMISSIONS());
      ds.field("CREATED_AT", &self.CREATED_AT());
      ds.field("UPDATED_AT", &self.UPDATED_AT());
      ds.field("DOCUMENTATION_URL", &self.DOCUMENTATION_URL());
      ds.field("ICON_URL", &self.ICON_URL());
      ds.field("LICENSE", &self.LICENSE());
      ds.field("SIGNATURE", &self.SIGNATURE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PLGT {
  pub PLUGIN_ID: String,
  pub NAME: String,
  pub VERSION: String,
  pub DESCRIPTION: Option<String>,
  pub PLUGIN_TYPE: pluginType,
  pub ABI_VERSION: u32,
  pub WASM_HASH: Option<Vec<u8>>,
  pub WASM_SIZE: u64,
  pub WASM_CID: Option<String>,
  pub ENTRY_FUNCTIONS: Option<Vec<EntryFunctionT>>,
  pub REQUIRED_SCHEMAS: Option<Vec<String>>,
  pub DEPENDENCIES: Option<Vec<PluginDependencyT>>,
  pub CAPABILITIES: Option<Vec<PluginCapabilityT>>,
  pub PROVIDER_PEER_ID: Option<String>,
  pub PROVIDER_EPM_CID: Option<String>,
  pub ENCRYPTED: bool,
  pub MIN_PERMISSIONS: Option<Vec<String>>,
  pub CREATED_AT: u64,
  pub UPDATED_AT: u64,
  pub DOCUMENTATION_URL: Option<String>,
  pub ICON_URL: Option<String>,
  pub LICENSE: Option<String>,
  pub SIGNATURE: Option<Vec<u8>>,
}
impl Default for PLGT {
  fn default() -> Self {
    Self {
      PLUGIN_ID: "".to_string(),
      NAME: "".to_string(),
      VERSION: "".to_string(),
      DESCRIPTION: None,
      PLUGIN_TYPE: pluginType::Sensor,
      ABI_VERSION: 1,
      WASM_HASH: None,
      WASM_SIZE: 0,
      WASM_CID: None,
      ENTRY_FUNCTIONS: None,
      REQUIRED_SCHEMAS: None,
      DEPENDENCIES: None,
      CAPABILITIES: None,
      PROVIDER_PEER_ID: None,
      PROVIDER_EPM_CID: None,
      ENCRYPTED: true,
      MIN_PERMISSIONS: None,
      CREATED_AT: 0,
      UPDATED_AT: 0,
      DOCUMENTATION_URL: None,
      ICON_URL: None,
      LICENSE: None,
      SIGNATURE: None,
    }
  }
}
impl PLGT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PLG<'b>> {
    let PLUGIN_ID = Some({
      let x = &self.PLUGIN_ID;
      _fbb.create_string(x)
    });
    let NAME = Some({
      let x = &self.NAME;
      _fbb.create_string(x)
    });
    let VERSION = Some({
      let x = &self.VERSION;
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PLUGIN_TYPE = self.PLUGIN_TYPE;
    let ABI_VERSION = self.ABI_VERSION;
    let WASM_HASH = self.WASM_HASH.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let WASM_SIZE = self.WASM_SIZE;
    let WASM_CID = self.WASM_CID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENTRY_FUNCTIONS = self.ENTRY_FUNCTIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let REQUIRED_SCHEMAS = self.REQUIRED_SCHEMAS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DEPENDENCIES = self.DEPENDENCIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let CAPABILITIES = self.CAPABILITIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let PROVIDER_PEER_ID = self.PROVIDER_PEER_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROVIDER_EPM_CID = self.PROVIDER_EPM_CID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENCRYPTED = self.ENCRYPTED;
    let MIN_PERMISSIONS = self.MIN_PERMISSIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let CREATED_AT = self.CREATED_AT;
    let UPDATED_AT = self.UPDATED_AT;
    let DOCUMENTATION_URL = self.DOCUMENTATION_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ICON_URL = self.ICON_URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LICENSE = self.LICENSE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIGNATURE = self.SIGNATURE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    PLG::create(_fbb, &PLGArgs{
      PLUGIN_ID,
      NAME,
      VERSION,
      DESCRIPTION,
      PLUGIN_TYPE,
      ABI_VERSION,
      WASM_HASH,
      WASM_SIZE,
      WASM_CID,
      ENTRY_FUNCTIONS,
      REQUIRED_SCHEMAS,
      DEPENDENCIES,
      CAPABILITIES,
      PROVIDER_PEER_ID,
      PROVIDER_EPM_CID,
      ENCRYPTED,
      MIN_PERMISSIONS,
      CREATED_AT,
      UPDATED_AT,
      DOCUMENTATION_URL,
      ICON_URL,
      LICENSE,
      SIGNATURE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PLG`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLG_unchecked`.
pub fn root_as_PLG(buf: &[u8]) -> Result<PLG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PLG>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PLG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_PLG_unchecked`.
pub fn size_prefixed_root_as_PLG(buf: &[u8]) -> Result<PLG, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PLG>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PLG` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLG_unchecked`.
pub fn root_as_PLG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PLG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PLG<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PLG` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLG_unchecked`.
pub fn size_prefixed_root_as_PLG_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PLG<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PLG<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PLG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PLG`.
pub unsafe fn root_as_PLG_unchecked(buf: &[u8]) -> PLG {
  flatbuffers::root_unchecked::<PLG>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PLG and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PLG`.
pub unsafe fn size_prefixed_root_as_PLG_unchecked(buf: &[u8]) -> PLG {
  flatbuffers::size_prefixed_root_unchecked::<PLG>(buf)
}
pub const PLG_IDENTIFIER: &str = "$PLG";

#[inline]
pub fn PLG_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PLG_IDENTIFIER, false)
}

#[inline]
pub fn PLG_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PLG_IDENTIFIER, true)
}

#[inline]
pub fn finish_PLG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PLG<'a>>) {
  fbb.finish(root, Some(PLG_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_PLG_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<PLG<'a>>) {
  fbb.finish_size_prefixed(root, Some(PLG_IDENTIFIER));
}
