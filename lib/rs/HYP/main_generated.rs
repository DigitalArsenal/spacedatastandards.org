// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SCORE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SCORE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCORE_TYPE: [ScoreType; 1] = [
  ScoreType::OUTLIER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ScoreType(pub i8);
#[allow(non_upper_case_globals)]
impl ScoreType {
  pub const OUTLIER: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OUTLIER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OUTLIER => Some("OUTLIER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ScoreType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ScoreType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ScoreType {
    type Output = ScoreType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ScoreType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ScoreType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ScoreType {}
pub enum ScoreOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Score<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Score<'a> {
  type Inner = Score<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Score<'a> {
  pub const VT_NORAD_CAT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_TAG: flatbuffers::VOffsetT = 8;
  pub const VT_SCORE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Score { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ScoreArgs<'args>
  ) -> flatbuffers::WIPOffset<Score<'bldr>> {
    let mut builder = ScoreBuilder::new(_fbb);
    builder.add_SCORE(args.SCORE);
    if let Some(x) = args.TAG { builder.add_TAG(x); }
    if let Some(x) = args.NORAD_CAT_ID { builder.add_NORAD_CAT_ID(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> ScoreT {
    let NORAD_CAT_ID = self.NORAD_CAT_ID().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE();
    let TAG = self.TAG().map(|x| {
      x.to_string()
    });
    let SCORE = self.SCORE();
    ScoreT {
      NORAD_CAT_ID,
      TYPE,
      TAG,
      SCORE,
    }
  }

  #[inline]
  pub fn NORAD_CAT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Score::VT_NORAD_CAT_ID, None)}
  }
  #[inline]
  pub fn TYPE(&self) -> ScoreType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScoreType>(Score::VT_TYPE, Some(ScoreType::OUTLIER)).unwrap()}
  }
  #[inline]
  pub fn TAG(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Score::VT_TAG, None)}
  }
  #[inline]
  pub fn SCORE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Score::VT_SCORE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Score<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NORAD_CAT_ID", Self::VT_NORAD_CAT_ID, false)?
     .visit_field::<ScoreType>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TAG", Self::VT_TAG, false)?
     .visit_field::<f32>("SCORE", Self::VT_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct ScoreArgs<'a> {
    pub NORAD_CAT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: ScoreType,
    pub TAG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SCORE: f32,
}
impl<'a> Default for ScoreArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScoreArgs {
      NORAD_CAT_ID: None,
      TYPE: ScoreType::OUTLIER,
      TAG: None,
      SCORE: 0.0,
    }
  }
}

pub struct ScoreBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScoreBuilder<'a, 'b> {
  #[inline]
  pub fn add_NORAD_CAT_ID(&mut self, NORAD_CAT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Score::VT_NORAD_CAT_ID, NORAD_CAT_ID);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: ScoreType) {
    self.fbb_.push_slot::<ScoreType>(Score::VT_TYPE, TYPE, ScoreType::OUTLIER);
  }
  #[inline]
  pub fn add_TAG(&mut self, TAG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Score::VT_TAG, TAG);
  }
  #[inline]
  pub fn add_SCORE(&mut self, SCORE: f32) {
    self.fbb_.push_slot::<f32>(Score::VT_SCORE, SCORE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScoreBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScoreBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Score<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Score<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Score");
      ds.field("NORAD_CAT_ID", &self.NORAD_CAT_ID());
      ds.field("TYPE", &self.TYPE());
      ds.field("TAG", &self.TAG());
      ds.field("SCORE", &self.SCORE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ScoreT {
  pub NORAD_CAT_ID: Option<String>,
  pub TYPE: ScoreType,
  pub TAG: Option<String>,
  pub SCORE: f32,
}
impl Default for ScoreT {
  fn default() -> Self {
    Self {
      NORAD_CAT_ID: None,
      TYPE: ScoreType::OUTLIER,
      TAG: None,
      SCORE: 0.0,
    }
  }
}
impl ScoreT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Score<'b>> {
    let NORAD_CAT_ID = self.NORAD_CAT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE;
    let TAG = self.TAG.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SCORE = self.SCORE;
    Score::create(_fbb, &ScoreArgs{
      NORAD_CAT_ID,
      TYPE,
      TAG,
      SCORE,
    })
  }
}
pub enum HYPOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Hypothesis Message
pub struct HYP<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HYP<'a> {
  type Inner = HYP<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HYP<'a> {
  pub const VT_CAT_IDS: flatbuffers::VOffsetT = 4;
  pub const VT_SIT_IDS: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_CATEGORY: flatbuffers::VOffsetT = 10;
  pub const VT_ROW_INDICATORS: flatbuffers::VOffsetT = 12;
  pub const VT_COL_INDICATORS: flatbuffers::VOffsetT = 14;
  pub const VT_MATRIX: flatbuffers::VOffsetT = 16;
  pub const VT_SCORE: flatbuffers::VOffsetT = 18;
  pub const VT_ANALYSIS_METHOD: flatbuffers::VOffsetT = 20;
  pub const VT_EVENT_START_TIME: flatbuffers::VOffsetT = 22;
  pub const VT_EVENT_END_TIME: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HYP { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HYPArgs<'args>
  ) -> flatbuffers::WIPOffset<HYP<'bldr>> {
    let mut builder = HYPBuilder::new(_fbb);
    if let Some(x) = args.EVENT_END_TIME { builder.add_EVENT_END_TIME(x); }
    if let Some(x) = args.EVENT_START_TIME { builder.add_EVENT_START_TIME(x); }
    if let Some(x) = args.ANALYSIS_METHOD { builder.add_ANALYSIS_METHOD(x); }
    if let Some(x) = args.SCORE { builder.add_SCORE(x); }
    if let Some(x) = args.MATRIX { builder.add_MATRIX(x); }
    if let Some(x) = args.COL_INDICATORS { builder.add_COL_INDICATORS(x); }
    if let Some(x) = args.ROW_INDICATORS { builder.add_ROW_INDICATORS(x); }
    if let Some(x) = args.CATEGORY { builder.add_CATEGORY(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.SIT_IDS { builder.add_SIT_IDS(x); }
    if let Some(x) = args.CAT_IDS { builder.add_CAT_IDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> HYPT {
    let CAT_IDS = self.CAT_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SIT_IDS = self.SIT_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let CATEGORY = self.CATEGORY().map(|x| {
      x.to_string()
    });
    let ROW_INDICATORS = self.ROW_INDICATORS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let COL_INDICATORS = self.COL_INDICATORS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let MATRIX = self.MATRIX().map(|x| {
      x.into_iter().collect()
    });
    let SCORE = self.SCORE().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ANALYSIS_METHOD = self.ANALYSIS_METHOD().map(|x| {
      x.to_string()
    });
    let EVENT_START_TIME = self.EVENT_START_TIME().map(|x| {
      x.to_string()
    });
    let EVENT_END_TIME = self.EVENT_END_TIME().map(|x| {
      x.to_string()
    });
    HYPT {
      CAT_IDS,
      SIT_IDS,
      NAME,
      CATEGORY,
      ROW_INDICATORS,
      COL_INDICATORS,
      MATRIX,
      SCORE,
      ANALYSIS_METHOD,
      EVENT_START_TIME,
      EVENT_END_TIME,
    }
  }

  /// Space Objects Involved
  #[inline]
  pub fn CAT_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(HYP::VT_CAT_IDS, None)}
  }
  /// Space Objects Involved
  #[inline]
  pub fn SIT_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(HYP::VT_SIT_IDS, None)}
  }
  /// Name of the hypothesis
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HYP::VT_NAME, None)}
  }
  /// Category of the hypothesis
  #[inline]
  pub fn CATEGORY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HYP::VT_CATEGORY, None)}
  }
  /// Row indicators for the hypothesis matrix
  #[inline]
  pub fn ROW_INDICATORS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(HYP::VT_ROW_INDICATORS, None)}
  }
  /// Column indicators for the hypothesis matrix
  #[inline]
  pub fn COL_INDICATORS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(HYP::VT_COL_INDICATORS, None)}
  }
  /// Matrix data as a boolean array in row major format; if overflow, adds additional rows
  #[inline]
  pub fn MATRIX(&self) -> Option<flatbuffers::Vector<'a, bool>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(HYP::VT_MATRIX, None)}
  }
  /// Scores for objects
  #[inline]
  pub fn SCORE(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Score<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Score>>>>(HYP::VT_SCORE, None)}
  }
  /// Analysis methodology used to form the hypothesis
  #[inline]
  pub fn ANALYSIS_METHOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HYP::VT_ANALYSIS_METHOD, None)}
  }
  #[inline]
  pub fn EVENT_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HYP::VT_EVENT_START_TIME, None)}
  }
  #[inline]
  pub fn EVENT_END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HYP::VT_EVENT_END_TIME, None)}
  }
}

impl flatbuffers::Verifiable for HYP<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("CAT_IDS", Self::VT_CAT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SIT_IDS", Self::VT_SIT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CATEGORY", Self::VT_CATEGORY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ROW_INDICATORS", Self::VT_ROW_INDICATORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("COL_INDICATORS", Self::VT_COL_INDICATORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("MATRIX", Self::VT_MATRIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Score>>>>("SCORE", Self::VT_SCORE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ANALYSIS_METHOD", Self::VT_ANALYSIS_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EVENT_START_TIME", Self::VT_EVENT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EVENT_END_TIME", Self::VT_EVENT_END_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct HYPArgs<'a> {
    pub CAT_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SIT_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CATEGORY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ROW_INDICATORS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub COL_INDICATORS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub MATRIX: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub SCORE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Score<'a>>>>>,
    pub ANALYSIS_METHOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EVENT_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EVENT_END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HYPArgs<'a> {
  #[inline]
  fn default() -> Self {
    HYPArgs {
      CAT_IDS: None,
      SIT_IDS: None,
      NAME: None,
      CATEGORY: None,
      ROW_INDICATORS: None,
      COL_INDICATORS: None,
      MATRIX: None,
      SCORE: None,
      ANALYSIS_METHOD: None,
      EVENT_START_TIME: None,
      EVENT_END_TIME: None,
    }
  }
}

pub struct HYPBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HYPBuilder<'a, 'b> {
  #[inline]
  pub fn add_CAT_IDS(&mut self, CAT_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_CAT_IDS, CAT_IDS);
  }
  #[inline]
  pub fn add_SIT_IDS(&mut self, SIT_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_SIT_IDS, SIT_IDS);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_CATEGORY(&mut self, CATEGORY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_CATEGORY, CATEGORY);
  }
  #[inline]
  pub fn add_ROW_INDICATORS(&mut self, ROW_INDICATORS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_ROW_INDICATORS, ROW_INDICATORS);
  }
  #[inline]
  pub fn add_COL_INDICATORS(&mut self, COL_INDICATORS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_COL_INDICATORS, COL_INDICATORS);
  }
  #[inline]
  pub fn add_MATRIX(&mut self, MATRIX: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_MATRIX, MATRIX);
  }
  #[inline]
  pub fn add_SCORE(&mut self, SCORE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Score<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_SCORE, SCORE);
  }
  #[inline]
  pub fn add_ANALYSIS_METHOD(&mut self, ANALYSIS_METHOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_ANALYSIS_METHOD, ANALYSIS_METHOD);
  }
  #[inline]
  pub fn add_EVENT_START_TIME(&mut self, EVENT_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_EVENT_START_TIME, EVENT_START_TIME);
  }
  #[inline]
  pub fn add_EVENT_END_TIME(&mut self, EVENT_END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HYP::VT_EVENT_END_TIME, EVENT_END_TIME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HYPBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HYPBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HYP<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HYP<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HYP");
      ds.field("CAT_IDS", &self.CAT_IDS());
      ds.field("SIT_IDS", &self.SIT_IDS());
      ds.field("NAME", &self.NAME());
      ds.field("CATEGORY", &self.CATEGORY());
      ds.field("ROW_INDICATORS", &self.ROW_INDICATORS());
      ds.field("COL_INDICATORS", &self.COL_INDICATORS());
      ds.field("MATRIX", &self.MATRIX());
      ds.field("SCORE", &self.SCORE());
      ds.field("ANALYSIS_METHOD", &self.ANALYSIS_METHOD());
      ds.field("EVENT_START_TIME", &self.EVENT_START_TIME());
      ds.field("EVENT_END_TIME", &self.EVENT_END_TIME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HYPT {
  pub CAT_IDS: Option<Vec<String>>,
  pub SIT_IDS: Option<Vec<String>>,
  pub NAME: Option<String>,
  pub CATEGORY: Option<String>,
  pub ROW_INDICATORS: Option<Vec<String>>,
  pub COL_INDICATORS: Option<Vec<String>>,
  pub MATRIX: Option<Vec<bool>>,
  pub SCORE: Option<Vec<ScoreT>>,
  pub ANALYSIS_METHOD: Option<String>,
  pub EVENT_START_TIME: Option<String>,
  pub EVENT_END_TIME: Option<String>,
}
impl Default for HYPT {
  fn default() -> Self {
    Self {
      CAT_IDS: None,
      SIT_IDS: None,
      NAME: None,
      CATEGORY: None,
      ROW_INDICATORS: None,
      COL_INDICATORS: None,
      MATRIX: None,
      SCORE: None,
      ANALYSIS_METHOD: None,
      EVENT_START_TIME: None,
      EVENT_END_TIME: None,
    }
  }
}
impl HYPT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<HYP<'b>> {
    let CAT_IDS = self.CAT_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SIT_IDS = self.SIT_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CATEGORY = self.CATEGORY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ROW_INDICATORS = self.ROW_INDICATORS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let COL_INDICATORS = self.COL_INDICATORS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let MATRIX = self.MATRIX.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SCORE = self.SCORE.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ANALYSIS_METHOD = self.ANALYSIS_METHOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EVENT_START_TIME = self.EVENT_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EVENT_END_TIME = self.EVENT_END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    HYP::create(_fbb, &HYPArgs{
      CAT_IDS,
      SIT_IDS,
      NAME,
      CATEGORY,
      ROW_INDICATORS,
      COL_INDICATORS,
      MATRIX,
      SCORE,
      ANALYSIS_METHOD,
      EVENT_START_TIME,
      EVENT_END_TIME,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `HYP`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HYP_unchecked`.
pub fn root_as_HYP(buf: &[u8]) -> Result<HYP, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<HYP>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `HYP` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_HYP_unchecked`.
pub fn size_prefixed_root_as_HYP(buf: &[u8]) -> Result<HYP, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<HYP>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `HYP` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HYP_unchecked`.
pub fn root_as_HYP_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HYP<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<HYP<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `HYP` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_HYP_unchecked`.
pub fn size_prefixed_root_as_HYP_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<HYP<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<HYP<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a HYP and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `HYP`.
pub unsafe fn root_as_HYP_unchecked(buf: &[u8]) -> HYP {
  flatbuffers::root_unchecked::<HYP>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed HYP and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `HYP`.
pub unsafe fn size_prefixed_root_as_HYP_unchecked(buf: &[u8]) -> HYP {
  flatbuffers::size_prefixed_root_unchecked::<HYP>(buf)
}
pub const HYP_IDENTIFIER: &str = "$HYP";

#[inline]
pub fn HYP_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HYP_IDENTIFIER, false)
}

#[inline]
pub fn HYP_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, HYP_IDENTIFIER, true)
}

#[inline]
pub fn finish_HYP_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<HYP<'a>>) {
  fbb.finish(root, Some(HYP_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_HYP_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<HYP<'a>>) {
  fbb.finish_size_prefixed(root, Some(HYP_IDENTIFIER));
}
