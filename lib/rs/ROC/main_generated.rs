// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENGINE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENGINE_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENGINE_TYPE: [ENGINE_TYPE; 6] = [
  ENGINE_TYPE::LIQUID,
  ENGINE_TYPE::SOLID,
  ENGINE_TYPE::HYBRID,
  ENGINE_TYPE::ION,
  ENGINE_TYPE::NUCLEAR_THERMAL,
  ENGINE_TYPE::OTHER,
];

/// Enumeration of Engine Types
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ENGINE_TYPE(pub i8);
#[allow(non_upper_case_globals)]
impl ENGINE_TYPE {
  pub const LIQUID: Self = Self(0);
  pub const SOLID: Self = Self(1);
  pub const HYBRID: Self = Self(2);
  pub const ION: Self = Self(3);
  pub const NUCLEAR_THERMAL: Self = Self(4);
  pub const OTHER: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LIQUID,
    Self::SOLID,
    Self::HYBRID,
    Self::ION,
    Self::NUCLEAR_THERMAL,
    Self::OTHER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LIQUID => Some("LIQUID"),
      Self::SOLID => Some("SOLID"),
      Self::HYBRID => Some("HYBRID"),
      Self::ION => Some("ION"),
      Self::NUCLEAR_THERMAL => Some("NUCLEAR_THERMAL"),
      Self::OTHER => Some("OTHER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ENGINE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ENGINE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ENGINE_TYPE {
    type Output = ENGINE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ENGINE_TYPE {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ENGINE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ENGINE_TYPE {}
pub enum ROCOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rocket Configuration
pub struct ROC<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ROC<'a> {
  type Inner = ROC<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ROC<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_FAMILY: flatbuffers::VOffsetT = 6;
  pub const VT_VARIANT: flatbuffers::VOffsetT = 8;
  pub const VT_STAGES: flatbuffers::VOffsetT = 10;
  pub const VT_SUSTAINERS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ROC { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ROCArgs<'args>
  ) -> flatbuffers::WIPOffset<ROC<'bldr>> {
    let mut builder = ROCBuilder::new(_fbb);
    if let Some(x) = args.SUSTAINERS { builder.add_SUSTAINERS(x); }
    if let Some(x) = args.STAGES { builder.add_STAGES(x); }
    if let Some(x) = args.VARIANT { builder.add_VARIANT(x); }
    if let Some(x) = args.FAMILY { builder.add_FAMILY(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ROCT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let FAMILY = self.FAMILY().map(|x| {
      x.to_string()
    });
    let VARIANT = self.VARIANT().map(|x| {
      x.to_string()
    });
    let STAGES = self.STAGES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let SUSTAINERS = self.SUSTAINERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ROCT {
      NAME,
      FAMILY,
      VARIANT,
      STAGES,
      SUSTAINERS,
    }
  }

  /// Rocket Name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ROC::VT_NAME, None)}
  }
  /// Rocket Family
  #[inline]
  pub fn FAMILY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ROC::VT_FAMILY, None)}
  }
  /// Rocket Variant
  #[inline]
  pub fn VARIANT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ROC::VT_VARIANT, None)}
  }
  /// Stages in the Rocket
  #[inline]
  pub fn STAGES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<STAGE<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<STAGE>>>>(ROC::VT_STAGES, None)}
  }
  /// Sustainers in the Rocket
  #[inline]
  pub fn SUSTAINERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SUSTAINER<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SUSTAINER>>>>(ROC::VT_SUSTAINERS, None)}
  }
}

impl flatbuffers::Verifiable for ROC<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FAMILY", Self::VT_FAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VARIANT", Self::VT_VARIANT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<STAGE>>>>("STAGES", Self::VT_STAGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SUSTAINER>>>>("SUSTAINERS", Self::VT_SUSTAINERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ROCArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FAMILY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VARIANT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STAGES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<STAGE<'a>>>>>,
    pub SUSTAINERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SUSTAINER<'a>>>>>,
}
impl<'a> Default for ROCArgs<'a> {
  #[inline]
  fn default() -> Self {
    ROCArgs {
      NAME: None,
      FAMILY: None,
      VARIANT: None,
      STAGES: None,
      SUSTAINERS: None,
    }
  }
}

pub struct ROCBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ROCBuilder<'a, 'b> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROC::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_FAMILY(&mut self, FAMILY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROC::VT_FAMILY, FAMILY);
  }
  #[inline]
  pub fn add_VARIANT(&mut self, VARIANT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROC::VT_VARIANT, VARIANT);
  }
  #[inline]
  pub fn add_STAGES(&mut self, STAGES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<STAGE<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROC::VT_STAGES, STAGES);
  }
  #[inline]
  pub fn add_SUSTAINERS(&mut self, SUSTAINERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SUSTAINER<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROC::VT_SUSTAINERS, SUSTAINERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ROCBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ROCBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ROC<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ROC<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ROC");
      ds.field("NAME", &self.NAME());
      ds.field("FAMILY", &self.FAMILY());
      ds.field("VARIANT", &self.VARIANT());
      ds.field("STAGES", &self.STAGES());
      ds.field("SUSTAINERS", &self.SUSTAINERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ROCT {
  pub NAME: Option<String>,
  pub FAMILY: Option<String>,
  pub VARIANT: Option<String>,
  pub STAGES: Option<Vec<STAGET>>,
  pub SUSTAINERS: Option<Vec<SUSTAINERT>>,
}
impl Default for ROCT {
  fn default() -> Self {
    Self {
      NAME: None,
      FAMILY: None,
      VARIANT: None,
      STAGES: None,
      SUSTAINERS: None,
    }
  }
}
impl ROCT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ROC<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FAMILY = self.FAMILY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VARIANT = self.VARIANT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STAGES = self.STAGES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let SUSTAINERS = self.SUSTAINERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ROC::create(_fbb, &ROCArgs{
      NAME,
      FAMILY,
      VARIANT,
      STAGES,
      SUSTAINERS,
    })
  }
}
pub enum STAGEOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Stage Details
pub struct STAGE<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for STAGE<'a> {
  type Inner = STAGE<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> STAGE<'a> {
  pub const VT_STAGE_NUMBER: flatbuffers::VOffsetT = 4;
  pub const VT_ENGINES: flatbuffers::VOffsetT = 6;
  pub const VT_FUEL_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_THRUST: flatbuffers::VOffsetT = 10;
  pub const VT_BURN_DURATION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    STAGE { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args STAGEArgs<'args>
  ) -> flatbuffers::WIPOffset<STAGE<'bldr>> {
    let mut builder = STAGEBuilder::new(_fbb);
    builder.add_BURN_DURATION(args.BURN_DURATION);
    builder.add_THRUST(args.THRUST);
    if let Some(x) = args.FUEL_TYPE { builder.add_FUEL_TYPE(x); }
    if let Some(x) = args.ENGINES { builder.add_ENGINES(x); }
    builder.add_STAGE_NUMBER(args.STAGE_NUMBER);
    builder.finish()
  }

  pub fn unpack(&self) -> STAGET {
    let STAGE_NUMBER = self.STAGE_NUMBER();
    let ENGINES = self.ENGINES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let FUEL_TYPE = self.FUEL_TYPE().map(|x| {
      x.to_string()
    });
    let THRUST = self.THRUST();
    let BURN_DURATION = self.BURN_DURATION();
    STAGET {
      STAGE_NUMBER,
      ENGINES,
      FUEL_TYPE,
      THRUST,
      BURN_DURATION,
    }
  }

  /// Stage Number
  #[inline]
  pub fn STAGE_NUMBER(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(STAGE::VT_STAGE_NUMBER, Some(0)).unwrap()}
  }
  /// Engines Used in This Stage
  #[inline]
  pub fn ENGINES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ENGINE<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ENGINE>>>>(STAGE::VT_ENGINES, None)}
  }
  /// Fuel Type Used in This Stage
  #[inline]
  pub fn FUEL_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(STAGE::VT_FUEL_TYPE, None)}
  }
  /// Thrust Produced by This Stage (in Newtons)
  #[inline]
  pub fn THRUST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STAGE::VT_THRUST, Some(0.0)).unwrap()}
  }
  /// Duration of the Burn (in Seconds)
  #[inline]
  pub fn BURN_DURATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STAGE::VT_BURN_DURATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for STAGE<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("STAGE_NUMBER", Self::VT_STAGE_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ENGINE>>>>("ENGINES", Self::VT_ENGINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FUEL_TYPE", Self::VT_FUEL_TYPE, false)?
     .visit_field::<f64>("THRUST", Self::VT_THRUST, false)?
     .visit_field::<f64>("BURN_DURATION", Self::VT_BURN_DURATION, false)?
     .finish();
    Ok(())
  }
}
pub struct STAGEArgs<'a> {
    pub STAGE_NUMBER: i32,
    pub ENGINES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ENGINE<'a>>>>>,
    pub FUEL_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub THRUST: f64,
    pub BURN_DURATION: f64,
}
impl<'a> Default for STAGEArgs<'a> {
  #[inline]
  fn default() -> Self {
    STAGEArgs {
      STAGE_NUMBER: 0,
      ENGINES: None,
      FUEL_TYPE: None,
      THRUST: 0.0,
      BURN_DURATION: 0.0,
    }
  }
}

pub struct STAGEBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> STAGEBuilder<'a, 'b> {
  #[inline]
  pub fn add_STAGE_NUMBER(&mut self, STAGE_NUMBER: i32) {
    self.fbb_.push_slot::<i32>(STAGE::VT_STAGE_NUMBER, STAGE_NUMBER, 0);
  }
  #[inline]
  pub fn add_ENGINES(&mut self, ENGINES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ENGINE<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(STAGE::VT_ENGINES, ENGINES);
  }
  #[inline]
  pub fn add_FUEL_TYPE(&mut self, FUEL_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(STAGE::VT_FUEL_TYPE, FUEL_TYPE);
  }
  #[inline]
  pub fn add_THRUST(&mut self, THRUST: f64) {
    self.fbb_.push_slot::<f64>(STAGE::VT_THRUST, THRUST, 0.0);
  }
  #[inline]
  pub fn add_BURN_DURATION(&mut self, BURN_DURATION: f64) {
    self.fbb_.push_slot::<f64>(STAGE::VT_BURN_DURATION, BURN_DURATION, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> STAGEBuilder<'a, 'b> {
    let start = _fbb.start_table();
    STAGEBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<STAGE<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for STAGE<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("STAGE");
      ds.field("STAGE_NUMBER", &self.STAGE_NUMBER());
      ds.field("ENGINES", &self.ENGINES());
      ds.field("FUEL_TYPE", &self.FUEL_TYPE());
      ds.field("THRUST", &self.THRUST());
      ds.field("BURN_DURATION", &self.BURN_DURATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct STAGET {
  pub STAGE_NUMBER: i32,
  pub ENGINES: Option<Vec<ENGINET>>,
  pub FUEL_TYPE: Option<String>,
  pub THRUST: f64,
  pub BURN_DURATION: f64,
}
impl Default for STAGET {
  fn default() -> Self {
    Self {
      STAGE_NUMBER: 0,
      ENGINES: None,
      FUEL_TYPE: None,
      THRUST: 0.0,
      BURN_DURATION: 0.0,
    }
  }
}
impl STAGET {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<STAGE<'b>> {
    let STAGE_NUMBER = self.STAGE_NUMBER;
    let ENGINES = self.ENGINES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let FUEL_TYPE = self.FUEL_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let THRUST = self.THRUST;
    let BURN_DURATION = self.BURN_DURATION;
    STAGE::create(_fbb, &STAGEArgs{
      STAGE_NUMBER,
      ENGINES,
      FUEL_TYPE,
      THRUST,
      BURN_DURATION,
    })
  }
}
pub enum SUSTAINEROffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sustainer Details
pub struct SUSTAINER<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SUSTAINER<'a> {
  type Inner = SUSTAINER<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SUSTAINER<'a> {
  pub const VT_SUSTAINER_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_THRUST: flatbuffers::VOffsetT = 6;
  pub const VT_BURN_DURATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SUSTAINER { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SUSTAINERArgs<'args>
  ) -> flatbuffers::WIPOffset<SUSTAINER<'bldr>> {
    let mut builder = SUSTAINERBuilder::new(_fbb);
    builder.add_BURN_DURATION(args.BURN_DURATION);
    builder.add_THRUST(args.THRUST);
    if let Some(x) = args.SUSTAINER_NAME { builder.add_SUSTAINER_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SUSTAINERT {
    let SUSTAINER_NAME = self.SUSTAINER_NAME().map(|x| {
      x.to_string()
    });
    let THRUST = self.THRUST();
    let BURN_DURATION = self.BURN_DURATION();
    SUSTAINERT {
      SUSTAINER_NAME,
      THRUST,
      BURN_DURATION,
    }
  }

  /// Name of the Sustainer
  #[inline]
  pub fn SUSTAINER_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SUSTAINER::VT_SUSTAINER_NAME, None)}
  }
  /// Thrust Produced by the Sustainer (in Newtons)
  #[inline]
  pub fn THRUST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SUSTAINER::VT_THRUST, Some(0.0)).unwrap()}
  }
  /// Duration of the Burn (in Seconds)
  #[inline]
  pub fn BURN_DURATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SUSTAINER::VT_BURN_DURATION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SUSTAINER<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUSTAINER_NAME", Self::VT_SUSTAINER_NAME, false)?
     .visit_field::<f64>("THRUST", Self::VT_THRUST, false)?
     .visit_field::<f64>("BURN_DURATION", Self::VT_BURN_DURATION, false)?
     .finish();
    Ok(())
  }
}
pub struct SUSTAINERArgs<'a> {
    pub SUSTAINER_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub THRUST: f64,
    pub BURN_DURATION: f64,
}
impl<'a> Default for SUSTAINERArgs<'a> {
  #[inline]
  fn default() -> Self {
    SUSTAINERArgs {
      SUSTAINER_NAME: None,
      THRUST: 0.0,
      BURN_DURATION: 0.0,
    }
  }
}

pub struct SUSTAINERBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SUSTAINERBuilder<'a, 'b> {
  #[inline]
  pub fn add_SUSTAINER_NAME(&mut self, SUSTAINER_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SUSTAINER::VT_SUSTAINER_NAME, SUSTAINER_NAME);
  }
  #[inline]
  pub fn add_THRUST(&mut self, THRUST: f64) {
    self.fbb_.push_slot::<f64>(SUSTAINER::VT_THRUST, THRUST, 0.0);
  }
  #[inline]
  pub fn add_BURN_DURATION(&mut self, BURN_DURATION: f64) {
    self.fbb_.push_slot::<f64>(SUSTAINER::VT_BURN_DURATION, BURN_DURATION, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SUSTAINERBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SUSTAINERBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SUSTAINER<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SUSTAINER<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SUSTAINER");
      ds.field("SUSTAINER_NAME", &self.SUSTAINER_NAME());
      ds.field("THRUST", &self.THRUST());
      ds.field("BURN_DURATION", &self.BURN_DURATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SUSTAINERT {
  pub SUSTAINER_NAME: Option<String>,
  pub THRUST: f64,
  pub BURN_DURATION: f64,
}
impl Default for SUSTAINERT {
  fn default() -> Self {
    Self {
      SUSTAINER_NAME: None,
      THRUST: 0.0,
      BURN_DURATION: 0.0,
    }
  }
}
impl SUSTAINERT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SUSTAINER<'b>> {
    let SUSTAINER_NAME = self.SUSTAINER_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let THRUST = self.THRUST;
    let BURN_DURATION = self.BURN_DURATION;
    SUSTAINER::create(_fbb, &SUSTAINERArgs{
      SUSTAINER_NAME,
      THRUST,
      BURN_DURATION,
    })
  }
}
pub enum ENGINEOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Engine Details
pub struct ENGINE<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ENGINE<'a> {
  type Inner = ENGINE<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ENGINE<'a> {
  pub const VT_ENGINE_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_THRUST: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ENGINE { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ENGINEArgs<'args>
  ) -> flatbuffers::WIPOffset<ENGINE<'bldr>> {
    let mut builder = ENGINEBuilder::new(_fbb);
    builder.add_THRUST(args.THRUST);
    if let Some(x) = args.ENGINE_NAME { builder.add_ENGINE_NAME(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> ENGINET {
    let ENGINE_NAME = self.ENGINE_NAME().map(|x| {
      x.to_string()
    });
    let TYPE = self.TYPE();
    let THRUST = self.THRUST();
    ENGINET {
      ENGINE_NAME,
      TYPE,
      THRUST,
    }
  }

  /// Engine Name
  #[inline]
  pub fn ENGINE_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ENGINE::VT_ENGINE_NAME, None)}
  }
  /// Type of Engine
  #[inline]
  pub fn TYPE(&self) -> ENGINE_TYPE {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ENGINE_TYPE>(ENGINE::VT_TYPE, Some(ENGINE_TYPE::LIQUID)).unwrap()}
  }
  /// Thrust Produced by the Engine (in Newtons)
  #[inline]
  pub fn THRUST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ENGINE::VT_THRUST, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ENGINE<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENGINE_NAME", Self::VT_ENGINE_NAME, false)?
     .visit_field::<ENGINE_TYPE>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<f64>("THRUST", Self::VT_THRUST, false)?
     .finish();
    Ok(())
  }
}
pub struct ENGINEArgs<'a> {
    pub ENGINE_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE: ENGINE_TYPE,
    pub THRUST: f64,
}
impl<'a> Default for ENGINEArgs<'a> {
  #[inline]
  fn default() -> Self {
    ENGINEArgs {
      ENGINE_NAME: None,
      TYPE: ENGINE_TYPE::LIQUID,
      THRUST: 0.0,
    }
  }
}

pub struct ENGINEBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ENGINEBuilder<'a, 'b> {
  #[inline]
  pub fn add_ENGINE_NAME(&mut self, ENGINE_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ENGINE::VT_ENGINE_NAME, ENGINE_NAME);
  }
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: ENGINE_TYPE) {
    self.fbb_.push_slot::<ENGINE_TYPE>(ENGINE::VT_TYPE, TYPE, ENGINE_TYPE::LIQUID);
  }
  #[inline]
  pub fn add_THRUST(&mut self, THRUST: f64) {
    self.fbb_.push_slot::<f64>(ENGINE::VT_THRUST, THRUST, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ENGINEBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ENGINEBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ENGINE<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ENGINE<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ENGINE");
      ds.field("ENGINE_NAME", &self.ENGINE_NAME());
      ds.field("TYPE", &self.TYPE());
      ds.field("THRUST", &self.THRUST());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ENGINET {
  pub ENGINE_NAME: Option<String>,
  pub TYPE: ENGINE_TYPE,
  pub THRUST: f64,
}
impl Default for ENGINET {
  fn default() -> Self {
    Self {
      ENGINE_NAME: None,
      TYPE: ENGINE_TYPE::LIQUID,
      THRUST: 0.0,
    }
  }
}
impl ENGINET {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ENGINE<'b>> {
    let ENGINE_NAME = self.ENGINE_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE = self.TYPE;
    let THRUST = self.THRUST;
    ENGINE::create(_fbb, &ENGINEArgs{
      ENGINE_NAME,
      TYPE,
      THRUST,
    })
  }
}
pub enum ROCCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of Rocket Configurations
pub struct ROCCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ROCCOLLECTION<'a> {
  type Inner = ROCCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ROCCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ROCCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ROCCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<ROCCOLLECTION<'bldr>> {
    let mut builder = ROCCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ROCCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ROCCOLLECTIONT {
      RECORDS,
    }
  }

  /// Records of Rocket Configurations
  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ROC<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ROC>>>>(ROCCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for ROCCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ROC>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct ROCCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ROC<'a>>>>>,
}
impl<'a> Default for ROCCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    ROCCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct ROCCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ROCCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ROC<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ROCCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ROCCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ROCCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ROCCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ROCCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ROCCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ROCCOLLECTIONT {
  pub RECORDS: Option<Vec<ROCT>>,
}
impl Default for ROCCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl ROCCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ROCCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ROCCOLLECTION::create(_fbb, &ROCCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ROC`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ROC_unchecked`.
pub fn root_as_ROC(buf: &[u8]) -> Result<ROC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ROC>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ROC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ROC_unchecked`.
pub fn size_prefixed_root_as_ROC(buf: &[u8]) -> Result<ROC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ROC>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ROC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ROC_unchecked`.
pub fn root_as_ROC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ROC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ROC<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ROC` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ROC_unchecked`.
pub fn size_prefixed_root_as_ROC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ROC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ROC<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ROC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ROC`.
pub unsafe fn root_as_ROC_unchecked(buf: &[u8]) -> ROC {
  flatbuffers::root_unchecked::<ROC>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ROC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ROC`.
pub unsafe fn size_prefixed_root_as_ROC_unchecked(buf: &[u8]) -> ROC {
  flatbuffers::size_prefixed_root_unchecked::<ROC>(buf)
}
pub const ROC_IDENTIFIER: &str = "$ROC";

#[inline]
pub fn ROC_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROC_IDENTIFIER, false)
}

#[inline]
pub fn ROC_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROC_IDENTIFIER, true)
}

#[inline]
pub fn finish_ROC_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ROC<'a>>) {
  fbb.finish(root, Some(ROC_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ROC_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ROC<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROC_IDENTIFIER));
}
