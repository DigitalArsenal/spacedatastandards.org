// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANALYTIC_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANALYTIC_TYPE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANALYTIC_TYPE: [analyticType; 9] = [
  analyticType::SPECTRAL,
  analyticType::PHOTOMETRIC,
  analyticType::ASTROMETRIC,
  analyticType::RADIOMETRIC,
  analyticType::SIGNATURE,
  analyticType::FEATURE_EXTRACTION,
  analyticType::CHANGE_DETECTION,
  analyticType::CLASSIFICATION,
  analyticType::FUSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct analyticType(pub i8);
#[allow(non_upper_case_globals)]
impl analyticType {
  pub const SPECTRAL: Self = Self(0);
  pub const PHOTOMETRIC: Self = Self(1);
  pub const ASTROMETRIC: Self = Self(2);
  pub const RADIOMETRIC: Self = Self(3);
  pub const SIGNATURE: Self = Self(4);
  pub const FEATURE_EXTRACTION: Self = Self(5);
  pub const CHANGE_DETECTION: Self = Self(6);
  pub const CLASSIFICATION: Self = Self(7);
  pub const FUSION: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPECTRAL,
    Self::PHOTOMETRIC,
    Self::ASTROMETRIC,
    Self::RADIOMETRIC,
    Self::SIGNATURE,
    Self::FEATURE_EXTRACTION,
    Self::CHANGE_DETECTION,
    Self::CLASSIFICATION,
    Self::FUSION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPECTRAL => Some("SPECTRAL"),
      Self::PHOTOMETRIC => Some("PHOTOMETRIC"),
      Self::ASTROMETRIC => Some("ASTROMETRIC"),
      Self::RADIOMETRIC => Some("RADIOMETRIC"),
      Self::SIGNATURE => Some("SIGNATURE"),
      Self::FEATURE_EXTRACTION => Some("FEATURE_EXTRACTION"),
      Self::CHANGE_DETECTION => Some("CHANGE_DETECTION"),
      Self::CLASSIFICATION => Some("CLASSIFICATION"),
      Self::FUSION => Some("FUSION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for analyticType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for analyticType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for analyticType {
    type Output = analyticType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for analyticType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for analyticType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for analyticType {}
pub enum ANIOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Analytic Imagery Product
pub struct ANI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ANI<'a> {
  type Inner = ANI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ANI<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_ANALYTIC_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_ALGORITHM: flatbuffers::VOffsetT = 12;
  pub const VT_ALGORITHM_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_PROCESSING_TIME: flatbuffers::VOffsetT = 16;
  pub const VT_OBS_TIME: flatbuffers::VOffsetT = 18;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 20;
  pub const VT_OBJECT_DESIGNATOR: flatbuffers::VOffsetT = 22;
  pub const VT_RA: flatbuffers::VOffsetT = 24;
  pub const VT_DEC: flatbuffers::VOffsetT = 26;
  pub const VT_FOV: flatbuffers::VOffsetT = 28;
  pub const VT_VISUAL_MAG: flatbuffers::VOffsetT = 30;
  pub const VT_MAG_UNCERTAINTY: flatbuffers::VOffsetT = 32;
  pub const VT_OBJECT_COUNT: flatbuffers::VOffsetT = 34;
  pub const VT_LABELS: flatbuffers::VOffsetT = 36;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 38;
  pub const VT_FEATURES: flatbuffers::VOffsetT = 40;
  pub const VT_QUALITY: flatbuffers::VOffsetT = 42;
  pub const VT_NOTES: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ANI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ANIArgs<'args>
  ) -> flatbuffers::WIPOffset<ANI<'bldr>> {
    let mut builder = ANIBuilder::new(_fbb);
    builder.add_QUALITY(args.QUALITY);
    builder.add_MAG_UNCERTAINTY(args.MAG_UNCERTAINTY);
    builder.add_VISUAL_MAG(args.VISUAL_MAG);
    builder.add_FOV(args.FOV);
    builder.add_DEC(args.DEC);
    builder.add_RA(args.RA);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.FEATURES { builder.add_FEATURES(x); }
    if let Some(x) = args.CONFIDENCE { builder.add_CONFIDENCE(x); }
    if let Some(x) = args.LABELS { builder.add_LABELS(x); }
    builder.add_OBJECT_COUNT(args.OBJECT_COUNT);
    if let Some(x) = args.OBJECT_DESIGNATOR { builder.add_OBJECT_DESIGNATOR(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.OBS_TIME { builder.add_OBS_TIME(x); }
    if let Some(x) = args.PROCESSING_TIME { builder.add_PROCESSING_TIME(x); }
    if let Some(x) = args.ALGORITHM_VERSION { builder.add_ALGORITHM_VERSION(x); }
    if let Some(x) = args.ALGORITHM { builder.add_ALGORITHM(x); }
    if let Some(x) = args.SOURCE_TYPE { builder.add_SOURCE_TYPE(x); }
    if let Some(x) = args.SOURCE_ID { builder.add_SOURCE_ID(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_ANALYTIC_TYPE(args.ANALYTIC_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> ANIT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let SOURCE_ID = self.SOURCE_ID().map(|x| {
      x.to_string()
    });
    let SOURCE_TYPE = self.SOURCE_TYPE().map(|x| {
      x.to_string()
    });
    let ANALYTIC_TYPE = self.ANALYTIC_TYPE();
    let ALGORITHM = self.ALGORITHM().map(|x| {
      x.to_string()
    });
    let ALGORITHM_VERSION = self.ALGORITHM_VERSION().map(|x| {
      x.to_string()
    });
    let PROCESSING_TIME = self.PROCESSING_TIME().map(|x| {
      x.to_string()
    });
    let OBS_TIME = self.OBS_TIME().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let OBJECT_DESIGNATOR = self.OBJECT_DESIGNATOR().map(|x| {
      x.to_string()
    });
    let RA = self.RA();
    let DEC = self.DEC();
    let FOV = self.FOV();
    let VISUAL_MAG = self.VISUAL_MAG();
    let MAG_UNCERTAINTY = self.MAG_UNCERTAINTY();
    let OBJECT_COUNT = self.OBJECT_COUNT();
    let LABELS = self.LABELS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let CONFIDENCE = self.CONFIDENCE().map(|x| {
      x.into_iter().collect()
    });
    let FEATURES = self.FEATURES().map(|x| {
      x.into_iter().collect()
    });
    let QUALITY = self.QUALITY();
    let NOTES = self.NOTES().map(|x| {
      x.to_string()
    });
    ANIT {
      ID,
      SOURCE_ID,
      SOURCE_TYPE,
      ANALYTIC_TYPE,
      ALGORITHM,
      ALGORITHM_VERSION,
      PROCESSING_TIME,
      OBS_TIME,
      SAT_NO,
      OBJECT_DESIGNATOR,
      RA,
      DEC,
      FOV,
      VISUAL_MAG,
      MAG_UNCERTAINTY,
      OBJECT_COUNT,
      LABELS,
      CONFIDENCE,
      FEATURES,
      QUALITY,
      NOTES,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_ID, None)}
  }
  /// Reference to source imagery (e.g., SKI, GDI, EOO)
  #[inline]
  pub fn SOURCE_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_SOURCE_ID, None)}
  }
  /// Source imagery type
  #[inline]
  pub fn SOURCE_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_SOURCE_TYPE, None)}
  }
  /// Analytic product type
  #[inline]
  pub fn ANALYTIC_TYPE(&self) -> analyticType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<analyticType>(ANI::VT_ANALYTIC_TYPE, Some(analyticType::SPECTRAL)).unwrap()}
  }
  /// Processing algorithm or pipeline name
  #[inline]
  pub fn ALGORITHM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_ALGORITHM, None)}
  }
  /// Algorithm version
  #[inline]
  pub fn ALGORITHM_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_ALGORITHM_VERSION, None)}
  }
  /// Processing epoch (ISO 8601)
  #[inline]
  pub fn PROCESSING_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_PROCESSING_TIME, None)}
  }
  /// Original observation epoch (ISO 8601)
  #[inline]
  pub fn OBS_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_OBS_TIME, None)}
  }
  /// Target satellite number (if applicable)
  #[inline]
  pub fn SAT_NO(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ANI::VT_SAT_NO, Some(0)).unwrap()}
  }
  /// Target object designator
  #[inline]
  pub fn OBJECT_DESIGNATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_OBJECT_DESIGNATOR, None)}
  }
  /// Center right ascension in degrees
  #[inline]
  pub fn RA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_RA, Some(0.0)).unwrap()}
  }
  /// Center declination in degrees
  #[inline]
  pub fn DEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_DEC, Some(0.0)).unwrap()}
  }
  /// Field of view in degrees
  #[inline]
  pub fn FOV(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_FOV, Some(0.0)).unwrap()}
  }
  /// Visual magnitude estimate
  #[inline]
  pub fn VISUAL_MAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_VISUAL_MAG, Some(0.0)).unwrap()}
  }
  /// Magnitude uncertainty
  #[inline]
  pub fn MAG_UNCERTAINTY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_MAG_UNCERTAINTY, Some(0.0)).unwrap()}
  }
  /// Detected object count
  #[inline]
  pub fn OBJECT_COUNT(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ANI::VT_OBJECT_COUNT, Some(0)).unwrap()}
  }
  /// Classification labels
  #[inline]
  pub fn LABELS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ANI::VT_LABELS, None)}
  }
  /// Classification confidence scores (0.0-1.0)
  #[inline]
  pub fn CONFIDENCE(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ANI::VT_CONFIDENCE, None)}
  }
  /// Feature vector or extracted parameters
  #[inline]
  pub fn FEATURES(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ANI::VT_FEATURES, None)}
  }
  /// Quality score (0.0-1.0)
  #[inline]
  pub fn QUALITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ANI::VT_QUALITY, Some(0.0)).unwrap()}
  }
  /// Additional notes
  #[inline]
  pub fn NOTES(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ANI::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for ANI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE_ID", Self::VT_SOURCE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SOURCE_TYPE", Self::VT_SOURCE_TYPE, false)?
     .visit_field::<analyticType>("ANALYTIC_TYPE", Self::VT_ANALYTIC_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALGORITHM", Self::VT_ALGORITHM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALGORITHM_VERSION", Self::VT_ALGORITHM_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROCESSING_TIME", Self::VT_PROCESSING_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBS_TIME", Self::VT_OBS_TIME, false)?
     .visit_field::<u32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_DESIGNATOR", Self::VT_OBJECT_DESIGNATOR, false)?
     .visit_field::<f64>("RA", Self::VT_RA, false)?
     .visit_field::<f64>("DEC", Self::VT_DEC, false)?
     .visit_field::<f64>("FOV", Self::VT_FOV, false)?
     .visit_field::<f64>("VISUAL_MAG", Self::VT_VISUAL_MAG, false)?
     .visit_field::<f64>("MAG_UNCERTAINTY", Self::VT_MAG_UNCERTAINTY, false)?
     .visit_field::<u32>("OBJECT_COUNT", Self::VT_OBJECT_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("LABELS", Self::VT_LABELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("CONFIDENCE", Self::VT_CONFIDENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("FEATURES", Self::VT_FEATURES, false)?
     .visit_field::<f64>("QUALITY", Self::VT_QUALITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct ANIArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SOURCE_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ANALYTIC_TYPE: analyticType,
    pub ALGORITHM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALGORITHM_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROCESSING_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBS_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: u32,
    pub OBJECT_DESIGNATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RA: f64,
    pub DEC: f64,
    pub FOV: f64,
    pub VISUAL_MAG: f64,
    pub MAG_UNCERTAINTY: f64,
    pub OBJECT_COUNT: u32,
    pub LABELS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub CONFIDENCE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub FEATURES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub QUALITY: f64,
    pub NOTES: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ANIArgs<'a> {
  #[inline]
  fn default() -> Self {
    ANIArgs {
      ID: None,
      SOURCE_ID: None,
      SOURCE_TYPE: None,
      ANALYTIC_TYPE: analyticType::SPECTRAL,
      ALGORITHM: None,
      ALGORITHM_VERSION: None,
      PROCESSING_TIME: None,
      OBS_TIME: None,
      SAT_NO: 0,
      OBJECT_DESIGNATOR: None,
      RA: 0.0,
      DEC: 0.0,
      FOV: 0.0,
      VISUAL_MAG: 0.0,
      MAG_UNCERTAINTY: 0.0,
      OBJECT_COUNT: 0,
      LABELS: None,
      CONFIDENCE: None,
      FEATURES: None,
      QUALITY: 0.0,
      NOTES: None,
    }
  }
}

pub struct ANIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ANIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_ID, ID);
  }
  #[inline]
  pub fn add_SOURCE_ID(&mut self, SOURCE_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_SOURCE_ID, SOURCE_ID);
  }
  #[inline]
  pub fn add_SOURCE_TYPE(&mut self, SOURCE_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_SOURCE_TYPE, SOURCE_TYPE);
  }
  #[inline]
  pub fn add_ANALYTIC_TYPE(&mut self, ANALYTIC_TYPE: analyticType) {
    self.fbb_.push_slot::<analyticType>(ANI::VT_ANALYTIC_TYPE, ANALYTIC_TYPE, analyticType::SPECTRAL);
  }
  #[inline]
  pub fn add_ALGORITHM(&mut self, ALGORITHM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_ALGORITHM, ALGORITHM);
  }
  #[inline]
  pub fn add_ALGORITHM_VERSION(&mut self, ALGORITHM_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_ALGORITHM_VERSION, ALGORITHM_VERSION);
  }
  #[inline]
  pub fn add_PROCESSING_TIME(&mut self, PROCESSING_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_PROCESSING_TIME, PROCESSING_TIME);
  }
  #[inline]
  pub fn add_OBS_TIME(&mut self, OBS_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_OBS_TIME, OBS_TIME);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: u32) {
    self.fbb_.push_slot::<u32>(ANI::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_OBJECT_DESIGNATOR(&mut self, OBJECT_DESIGNATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_OBJECT_DESIGNATOR, OBJECT_DESIGNATOR);
  }
  #[inline]
  pub fn add_RA(&mut self, RA: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_RA, RA, 0.0);
  }
  #[inline]
  pub fn add_DEC(&mut self, DEC: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_DEC, DEC, 0.0);
  }
  #[inline]
  pub fn add_FOV(&mut self, FOV: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_FOV, FOV, 0.0);
  }
  #[inline]
  pub fn add_VISUAL_MAG(&mut self, VISUAL_MAG: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_VISUAL_MAG, VISUAL_MAG, 0.0);
  }
  #[inline]
  pub fn add_MAG_UNCERTAINTY(&mut self, MAG_UNCERTAINTY: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_MAG_UNCERTAINTY, MAG_UNCERTAINTY, 0.0);
  }
  #[inline]
  pub fn add_OBJECT_COUNT(&mut self, OBJECT_COUNT: u32) {
    self.fbb_.push_slot::<u32>(ANI::VT_OBJECT_COUNT, OBJECT_COUNT, 0);
  }
  #[inline]
  pub fn add_LABELS(&mut self, LABELS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_LABELS, LABELS);
  }
  #[inline]
  pub fn add_CONFIDENCE(&mut self, CONFIDENCE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_CONFIDENCE, CONFIDENCE);
  }
  #[inline]
  pub fn add_FEATURES(&mut self, FEATURES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_FEATURES, FEATURES);
  }
  #[inline]
  pub fn add_QUALITY(&mut self, QUALITY: f64) {
    self.fbb_.push_slot::<f64>(ANI::VT_QUALITY, QUALITY, 0.0);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ANI::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ANIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ANIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ANI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ANI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ANI");
      ds.field("ID", &self.ID());
      ds.field("SOURCE_ID", &self.SOURCE_ID());
      ds.field("SOURCE_TYPE", &self.SOURCE_TYPE());
      ds.field("ANALYTIC_TYPE", &self.ANALYTIC_TYPE());
      ds.field("ALGORITHM", &self.ALGORITHM());
      ds.field("ALGORITHM_VERSION", &self.ALGORITHM_VERSION());
      ds.field("PROCESSING_TIME", &self.PROCESSING_TIME());
      ds.field("OBS_TIME", &self.OBS_TIME());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("OBJECT_DESIGNATOR", &self.OBJECT_DESIGNATOR());
      ds.field("RA", &self.RA());
      ds.field("DEC", &self.DEC());
      ds.field("FOV", &self.FOV());
      ds.field("VISUAL_MAG", &self.VISUAL_MAG());
      ds.field("MAG_UNCERTAINTY", &self.MAG_UNCERTAINTY());
      ds.field("OBJECT_COUNT", &self.OBJECT_COUNT());
      ds.field("LABELS", &self.LABELS());
      ds.field("CONFIDENCE", &self.CONFIDENCE());
      ds.field("FEATURES", &self.FEATURES());
      ds.field("QUALITY", &self.QUALITY());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ANIT {
  pub ID: Option<String>,
  pub SOURCE_ID: Option<String>,
  pub SOURCE_TYPE: Option<String>,
  pub ANALYTIC_TYPE: analyticType,
  pub ALGORITHM: Option<String>,
  pub ALGORITHM_VERSION: Option<String>,
  pub PROCESSING_TIME: Option<String>,
  pub OBS_TIME: Option<String>,
  pub SAT_NO: u32,
  pub OBJECT_DESIGNATOR: Option<String>,
  pub RA: f64,
  pub DEC: f64,
  pub FOV: f64,
  pub VISUAL_MAG: f64,
  pub MAG_UNCERTAINTY: f64,
  pub OBJECT_COUNT: u32,
  pub LABELS: Option<Vec<String>>,
  pub CONFIDENCE: Option<Vec<f64>>,
  pub FEATURES: Option<Vec<f64>>,
  pub QUALITY: f64,
  pub NOTES: Option<String>,
}
impl Default for ANIT {
  fn default() -> Self {
    Self {
      ID: None,
      SOURCE_ID: None,
      SOURCE_TYPE: None,
      ANALYTIC_TYPE: analyticType::SPECTRAL,
      ALGORITHM: None,
      ALGORITHM_VERSION: None,
      PROCESSING_TIME: None,
      OBS_TIME: None,
      SAT_NO: 0,
      OBJECT_DESIGNATOR: None,
      RA: 0.0,
      DEC: 0.0,
      FOV: 0.0,
      VISUAL_MAG: 0.0,
      MAG_UNCERTAINTY: 0.0,
      OBJECT_COUNT: 0,
      LABELS: None,
      CONFIDENCE: None,
      FEATURES: None,
      QUALITY: 0.0,
      NOTES: None,
    }
  }
}
impl ANIT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ANI<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE_ID = self.SOURCE_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SOURCE_TYPE = self.SOURCE_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ANALYTIC_TYPE = self.ANALYTIC_TYPE;
    let ALGORITHM = self.ALGORITHM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALGORITHM_VERSION = self.ALGORITHM_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROCESSING_TIME = self.PROCESSING_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBS_TIME = self.OBS_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let OBJECT_DESIGNATOR = self.OBJECT_DESIGNATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RA = self.RA;
    let DEC = self.DEC;
    let FOV = self.FOV;
    let VISUAL_MAG = self.VISUAL_MAG;
    let MAG_UNCERTAINTY = self.MAG_UNCERTAINTY;
    let OBJECT_COUNT = self.OBJECT_COUNT;
    let LABELS = self.LABELS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let CONFIDENCE = self.CONFIDENCE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let FEATURES = self.FEATURES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let QUALITY = self.QUALITY;
    let NOTES = self.NOTES.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ANI::create(_fbb, &ANIArgs{
      ID,
      SOURCE_ID,
      SOURCE_TYPE,
      ANALYTIC_TYPE,
      ALGORITHM,
      ALGORITHM_VERSION,
      PROCESSING_TIME,
      OBS_TIME,
      SAT_NO,
      OBJECT_DESIGNATOR,
      RA,
      DEC,
      FOV,
      VISUAL_MAG,
      MAG_UNCERTAINTY,
      OBJECT_COUNT,
      LABELS,
      CONFIDENCE,
      FEATURES,
      QUALITY,
      NOTES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ANI`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ANI_unchecked`.
pub fn root_as_ANI(buf: &[u8]) -> Result<ANI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ANI>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ANI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ANI_unchecked`.
pub fn size_prefixed_root_as_ANI(buf: &[u8]) -> Result<ANI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ANI>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ANI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ANI_unchecked`.
pub fn root_as_ANI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ANI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ANI<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ANI` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ANI_unchecked`.
pub fn size_prefixed_root_as_ANI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ANI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ANI<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ANI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ANI`.
pub unsafe fn root_as_ANI_unchecked(buf: &[u8]) -> ANI {
  flatbuffers::root_unchecked::<ANI>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ANI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ANI`.
pub unsafe fn size_prefixed_root_as_ANI_unchecked(buf: &[u8]) -> ANI {
  flatbuffers::size_prefixed_root_unchecked::<ANI>(buf)
}
pub const ANI_IDENTIFIER: &str = "$ANI";

#[inline]
pub fn ANI_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANI_IDENTIFIER, false)
}

#[inline]
pub fn ANI_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ANI_IDENTIFIER, true)
}

#[inline]
pub fn finish_ANI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ANI<'a>>) {
  fbb.finish(root, Some(ANI_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ANI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ANI<'a>>) {
  fbb.finish_size_prefixed(root, Some(ANI_IDENTIFIER));
}
