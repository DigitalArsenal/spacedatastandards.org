// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GJNGEOMETRY_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GJNGEOMETRY_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GJNGEOMETRY_TYPE: [GJNGeometryType; 7] = [
  GJNGeometryType::POINT,
  GJNGeometryType::MULTI_POINT,
  GJNGeometryType::LINE_STRING,
  GJNGeometryType::MULTI_LINE_STRING,
  GJNGeometryType::POLYGON,
  GJNGeometryType::MULTI_POLYGON,
  GJNGeometryType::GEOMETRY_COLLECTION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GJNGeometryType(pub i8);
#[allow(non_upper_case_globals)]
impl GJNGeometryType {
  pub const POINT: Self = Self(0);
  pub const MULTI_POINT: Self = Self(1);
  pub const LINE_STRING: Self = Self(2);
  pub const MULTI_LINE_STRING: Self = Self(3);
  pub const POLYGON: Self = Self(4);
  pub const MULTI_POLYGON: Self = Self(5);
  pub const GEOMETRY_COLLECTION: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT,
    Self::MULTI_POINT,
    Self::LINE_STRING,
    Self::MULTI_LINE_STRING,
    Self::POLYGON,
    Self::MULTI_POLYGON,
    Self::GEOMETRY_COLLECTION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT => Some("POINT"),
      Self::MULTI_POINT => Some("MULTI_POINT"),
      Self::LINE_STRING => Some("LINE_STRING"),
      Self::MULTI_LINE_STRING => Some("MULTI_LINE_STRING"),
      Self::POLYGON => Some("POLYGON"),
      Self::MULTI_POLYGON => Some("MULTI_POLYGON"),
      Self::GEOMETRY_COLLECTION => Some("GEOMETRY_COLLECTION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GJNGeometryType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GJNGeometryType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GJNGeometryType {
    type Output = GJNGeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GJNGeometryType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GJNGeometryType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GJNGeometryType {}
pub enum GJNPositionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single position (longitude, latitude, optional altitude)
pub struct GJNPosition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNPosition<'a> {
  type Inner = GJNPosition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNPosition<'a> {
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 8;
  pub const VT_HAS_ALTITUDE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNPosition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNPositionArgs
  ) -> flatbuffers::WIPOffset<GJNPosition<'bldr>> {
    let mut builder = GJNPositionBuilder::new(_fbb);
    builder.add_ALTITUDE(args.ALTITUDE);
    builder.add_LATITUDE(args.LATITUDE);
    builder.add_LONGITUDE(args.LONGITUDE);
    builder.add_HAS_ALTITUDE(args.HAS_ALTITUDE);
    builder.finish()
  }

  pub fn unpack(&self) -> GJNPositionT {
    let LONGITUDE = self.LONGITUDE();
    let LATITUDE = self.LATITUDE();
    let ALTITUDE = self.ALTITUDE();
    let HAS_ALTITUDE = self.HAS_ALTITUDE();
    GJNPositionT {
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HAS_ALTITUDE,
    }
  }

  /// Longitude in decimal degrees (WGS84)
  #[inline]
  pub fn LONGITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNPosition::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  /// Latitude in decimal degrees (WGS84)
  #[inline]
  pub fn LATITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNPosition::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  /// Altitude in meters above WGS84 ellipsoid (optional)
  #[inline]
  pub fn ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNPosition::VT_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// True if altitude was explicitly provided (distinguishes 0 from absent)
  #[inline]
  pub fn HAS_ALTITUDE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNPosition::VT_HAS_ALTITUDE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GJNPosition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("LONGITUDE", Self::VT_LONGITUDE, false)?
     .visit_field::<f64>("LATITUDE", Self::VT_LATITUDE, false)?
     .visit_field::<f64>("ALTITUDE", Self::VT_ALTITUDE, false)?
     .visit_field::<bool>("HAS_ALTITUDE", Self::VT_HAS_ALTITUDE, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNPositionArgs {
    pub LONGITUDE: f64,
    pub LATITUDE: f64,
    pub ALTITUDE: f64,
    pub HAS_ALTITUDE: bool,
}
impl<'a> Default for GJNPositionArgs {
  #[inline]
  fn default() -> Self {
    GJNPositionArgs {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HAS_ALTITUDE: false,
    }
  }
}

pub struct GJNPositionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNPositionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LONGITUDE(&mut self, LONGITUDE: f64) {
    self.fbb_.push_slot::<f64>(GJNPosition::VT_LONGITUDE, LONGITUDE, 0.0);
  }
  #[inline]
  pub fn add_LATITUDE(&mut self, LATITUDE: f64) {
    self.fbb_.push_slot::<f64>(GJNPosition::VT_LATITUDE, LATITUDE, 0.0);
  }
  #[inline]
  pub fn add_ALTITUDE(&mut self, ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(GJNPosition::VT_ALTITUDE, ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_HAS_ALTITUDE(&mut self, HAS_ALTITUDE: bool) {
    self.fbb_.push_slot::<bool>(GJNPosition::VT_HAS_ALTITUDE, HAS_ALTITUDE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNPositionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNPositionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNPosition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNPosition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNPosition");
      ds.field("LONGITUDE", &self.LONGITUDE());
      ds.field("LATITUDE", &self.LATITUDE());
      ds.field("ALTITUDE", &self.ALTITUDE());
      ds.field("HAS_ALTITUDE", &self.HAS_ALTITUDE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNPositionT {
  pub LONGITUDE: f64,
  pub LATITUDE: f64,
  pub ALTITUDE: f64,
  pub HAS_ALTITUDE: bool,
}
impl Default for GJNPositionT {
  fn default() -> Self {
    Self {
      LONGITUDE: 0.0,
      LATITUDE: 0.0,
      ALTITUDE: 0.0,
      HAS_ALTITUDE: false,
    }
  }
}
impl GJNPositionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNPosition<'b>> {
    let LONGITUDE = self.LONGITUDE;
    let LATITUDE = self.LATITUDE;
    let ALTITUDE = self.ALTITUDE;
    let HAS_ALTITUDE = self.HAS_ALTITUDE;
    GJNPosition::create(_fbb, &GJNPositionArgs{
      LONGITUDE,
      LATITUDE,
      ALTITUDE,
      HAS_ALTITUDE,
    })
  }
}
pub enum GJNLinearRingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A linear ring is a closed LineString with 4+ positions (first = last)
pub struct GJNLinearRing<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNLinearRing<'a> {
  type Inner = GJNLinearRing<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNLinearRing<'a> {
  pub const VT_POSITIONS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNLinearRing { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNLinearRingArgs<'args>
  ) -> flatbuffers::WIPOffset<GJNLinearRing<'bldr>> {
    let mut builder = GJNLinearRingBuilder::new(_fbb);
    if let Some(x) = args.POSITIONS { builder.add_POSITIONS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GJNLinearRingT {
    let POSITIONS = self.POSITIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GJNLinearRingT {
      POSITIONS,
    }
  }

  /// Ordered positions forming the ring
  #[inline]
  pub fn POSITIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition>>>>(GJNLinearRing::VT_POSITIONS, None)}
  }
}

impl flatbuffers::Verifiable for GJNLinearRing<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNPosition>>>>("POSITIONS", Self::VT_POSITIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNLinearRingArgs<'a> {
    pub POSITIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition<'a>>>>>,
}
impl<'a> Default for GJNLinearRingArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNLinearRingArgs {
      POSITIONS: None,
    }
  }
}

pub struct GJNLinearRingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNLinearRingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITIONS(&mut self, POSITIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNPosition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNLinearRing::VT_POSITIONS, POSITIONS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNLinearRingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNLinearRingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNLinearRing<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNLinearRing<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNLinearRing");
      ds.field("POSITIONS", &self.POSITIONS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNLinearRingT {
  pub POSITIONS: Option<Vec<GJNPositionT>>,
}
impl Default for GJNLinearRingT {
  fn default() -> Self {
    Self {
      POSITIONS: None,
    }
  }
}
impl GJNLinearRingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNLinearRing<'b>> {
    let POSITIONS = self.POSITIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GJNLinearRing::create(_fbb, &GJNLinearRingArgs{
      POSITIONS,
    })
  }
}
pub enum GJNPolygonRingsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A polygon represented as an array of rings (outer boundary + holes)
pub struct GJNPolygonRings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNPolygonRings<'a> {
  type Inner = GJNPolygonRings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNPolygonRings<'a> {
  pub const VT_RINGS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNPolygonRings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNPolygonRingsArgs<'args>
  ) -> flatbuffers::WIPOffset<GJNPolygonRings<'bldr>> {
    let mut builder = GJNPolygonRingsBuilder::new(_fbb);
    if let Some(x) = args.RINGS { builder.add_RINGS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GJNPolygonRingsT {
    let RINGS = self.RINGS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    GJNPolygonRingsT {
      RINGS,
    }
  }

  /// Rings: first is outer boundary, rest are holes
  #[inline]
  pub fn RINGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing>>>>(GJNPolygonRings::VT_RINGS, None)}
  }
}

impl flatbuffers::Verifiable for GJNPolygonRings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNLinearRing>>>>("RINGS", Self::VT_RINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNPolygonRingsArgs<'a> {
    pub RINGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing<'a>>>>>,
}
impl<'a> Default for GJNPolygonRingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNPolygonRingsArgs {
      RINGS: None,
    }
  }
}

pub struct GJNPolygonRingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNPolygonRingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RINGS(&mut self, RINGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNLinearRing<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNPolygonRings::VT_RINGS, RINGS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNPolygonRingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNPolygonRingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNPolygonRings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNPolygonRings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNPolygonRings");
      ds.field("RINGS", &self.RINGS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNPolygonRingsT {
  pub RINGS: Option<Vec<GJNLinearRingT>>,
}
impl Default for GJNPolygonRingsT {
  fn default() -> Self {
    Self {
      RINGS: None,
    }
  }
}
impl GJNPolygonRingsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNPolygonRings<'b>> {
    let RINGS = self.RINGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    GJNPolygonRings::create(_fbb, &GJNPolygonRingsArgs{
      RINGS,
    })
  }
}
pub enum GJNGeometryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GeoJSON Geometry object
pub struct GJNGeometry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNGeometry<'a> {
  type Inner = GJNGeometry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNGeometry<'a> {
  pub const VT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_POINT: flatbuffers::VOffsetT = 6;
  pub const VT_POSITIONS: flatbuffers::VOffsetT = 8;
  pub const VT_RINGS: flatbuffers::VOffsetT = 10;
  pub const VT_POLYGON_RINGS: flatbuffers::VOffsetT = 12;
  pub const VT_GEOMETRIES: flatbuffers::VOffsetT = 14;
  pub const VT_BBOX: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNGeometry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNGeometryArgs<'args>
  ) -> flatbuffers::WIPOffset<GJNGeometry<'bldr>> {
    let mut builder = GJNGeometryBuilder::new(_fbb);
    if let Some(x) = args.BBOX { builder.add_BBOX(x); }
    if let Some(x) = args.GEOMETRIES { builder.add_GEOMETRIES(x); }
    if let Some(x) = args.POLYGON_RINGS { builder.add_POLYGON_RINGS(x); }
    if let Some(x) = args.RINGS { builder.add_RINGS(x); }
    if let Some(x) = args.POSITIONS { builder.add_POSITIONS(x); }
    if let Some(x) = args.POINT { builder.add_POINT(x); }
    builder.add_TYPE(args.TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> GJNGeometryT {
    let TYPE = self.TYPE();
    let POINT = self.POINT().map(|x| {
      Box::new(x.unpack())
    });
    let POSITIONS = self.POSITIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let RINGS = self.RINGS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let POLYGON_RINGS = self.POLYGON_RINGS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let GEOMETRIES = self.GEOMETRIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BBOX = self.BBOX().map(|x| {
      Box::new(x.unpack())
    });
    GJNGeometryT {
      TYPE,
      POINT,
      POSITIONS,
      RINGS,
      POLYGON_RINGS,
      GEOMETRIES,
      BBOX,
    }
  }

  /// Geometry type
  #[inline]
  pub fn TYPE(&self) -> GJNGeometryType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GJNGeometryType>(GJNGeometry::VT_TYPE, Some(GJNGeometryType::POINT)).unwrap()}
  }
  /// Single position (for Point)
  #[inline]
  pub fn POINT(&self) -> Option<GJNPosition<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GJNPosition>>(GJNGeometry::VT_POINT, None)}
  }
  /// Array of positions (for MultiPoint, LineString)
  #[inline]
  pub fn POSITIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition>>>>(GJNGeometry::VT_POSITIONS, None)}
  }
  /// Array of position arrays (for MultiLineString, Polygon rings)
  #[inline]
  pub fn RINGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing>>>>(GJNGeometry::VT_RINGS, None)}
  }
  /// Array of polygons each as array of rings (for MultiPolygon)
  #[inline]
  pub fn POLYGON_RINGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPolygonRings<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPolygonRings>>>>(GJNGeometry::VT_POLYGON_RINGS, None)}
  }
  /// Child geometries (for GeometryCollection)
  #[inline]
  pub fn GEOMETRIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNGeometry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNGeometry>>>>(GJNGeometry::VT_GEOMETRIES, None)}
  }
  /// Bounding box (optional, per RFC 7946 Section 5)
  #[inline]
  pub fn BBOX(&self) -> Option<GJNBoundingBox<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>(GJNGeometry::VT_BBOX, None)}
  }
}

impl flatbuffers::Verifiable for GJNGeometry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GJNGeometryType>("TYPE", Self::VT_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GJNPosition>>("POINT", Self::VT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNPosition>>>>("POSITIONS", Self::VT_POSITIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNLinearRing>>>>("RINGS", Self::VT_RINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNPolygonRings>>>>("POLYGON_RINGS", Self::VT_POLYGON_RINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNGeometry>>>>("GEOMETRIES", Self::VT_GEOMETRIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>("BBOX", Self::VT_BBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNGeometryArgs<'a> {
    pub TYPE: GJNGeometryType,
    pub POINT: Option<flatbuffers::WIPOffset<GJNPosition<'a>>>,
    pub POSITIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPosition<'a>>>>>,
    pub RINGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNLinearRing<'a>>>>>,
    pub POLYGON_RINGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNPolygonRings<'a>>>>>,
    pub GEOMETRIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNGeometry<'a>>>>>,
    pub BBOX: Option<flatbuffers::WIPOffset<GJNBoundingBox<'a>>>,
}
impl<'a> Default for GJNGeometryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNGeometryArgs {
      TYPE: GJNGeometryType::POINT,
      POINT: None,
      POSITIONS: None,
      RINGS: None,
      POLYGON_RINGS: None,
      GEOMETRIES: None,
      BBOX: None,
    }
  }
}

pub struct GJNGeometryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNGeometryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_TYPE(&mut self, TYPE: GJNGeometryType) {
    self.fbb_.push_slot::<GJNGeometryType>(GJNGeometry::VT_TYPE, TYPE, GJNGeometryType::POINT);
  }
  #[inline]
  pub fn add_POINT(&mut self, POINT: flatbuffers::WIPOffset<GJNPosition<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GJNPosition>>(GJNGeometry::VT_POINT, POINT);
  }
  #[inline]
  pub fn add_POSITIONS(&mut self, POSITIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNPosition<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNGeometry::VT_POSITIONS, POSITIONS);
  }
  #[inline]
  pub fn add_RINGS(&mut self, RINGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNLinearRing<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNGeometry::VT_RINGS, RINGS);
  }
  #[inline]
  pub fn add_POLYGON_RINGS(&mut self, POLYGON_RINGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNPolygonRings<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNGeometry::VT_POLYGON_RINGS, POLYGON_RINGS);
  }
  #[inline]
  pub fn add_GEOMETRIES(&mut self, GEOMETRIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNGeometry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNGeometry::VT_GEOMETRIES, GEOMETRIES);
  }
  #[inline]
  pub fn add_BBOX(&mut self, BBOX: flatbuffers::WIPOffset<GJNBoundingBox<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GJNBoundingBox>>(GJNGeometry::VT_BBOX, BBOX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNGeometryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNGeometryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNGeometry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNGeometry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNGeometry");
      ds.field("TYPE", &self.TYPE());
      ds.field("POINT", &self.POINT());
      ds.field("POSITIONS", &self.POSITIONS());
      ds.field("RINGS", &self.RINGS());
      ds.field("POLYGON_RINGS", &self.POLYGON_RINGS());
      ds.field("GEOMETRIES", &self.GEOMETRIES());
      ds.field("BBOX", &self.BBOX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNGeometryT {
  pub TYPE: GJNGeometryType,
  pub POINT: Option<Box<GJNPositionT>>,
  pub POSITIONS: Option<Vec<GJNPositionT>>,
  pub RINGS: Option<Vec<GJNLinearRingT>>,
  pub POLYGON_RINGS: Option<Vec<GJNPolygonRingsT>>,
  pub GEOMETRIES: Option<Vec<GJNGeometryT>>,
  pub BBOX: Option<Box<GJNBoundingBoxT>>,
}
impl Default for GJNGeometryT {
  fn default() -> Self {
    Self {
      TYPE: GJNGeometryType::POINT,
      POINT: None,
      POSITIONS: None,
      RINGS: None,
      POLYGON_RINGS: None,
      GEOMETRIES: None,
      BBOX: None,
    }
  }
}
impl GJNGeometryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNGeometry<'b>> {
    let TYPE = self.TYPE;
    let POINT = self.POINT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POSITIONS = self.POSITIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let RINGS = self.RINGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let POLYGON_RINGS = self.POLYGON_RINGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let GEOMETRIES = self.GEOMETRIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BBOX = self.BBOX.as_ref().map(|x|{
      x.pack(_fbb)
    });
    GJNGeometry::create(_fbb, &GJNGeometryArgs{
      TYPE,
      POINT,
      POSITIONS,
      RINGS,
      POLYGON_RINGS,
      GEOMETRIES,
      BBOX,
    })
  }
}
pub enum GJNPropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A key-value property entry for Feature properties
pub struct GJNProperty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNProperty<'a> {
  type Inner = GJNProperty<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNProperty<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_NUMERIC: flatbuffers::VOffsetT = 10;
  pub const VT_IS_BOOL: flatbuffers::VOffsetT = 12;
  pub const VT_BOOL_VALUE: flatbuffers::VOffsetT = 14;
  pub const VT_IS_NULL: flatbuffers::VOffsetT = 16;
  pub const VT_JSON_VALUE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNProperty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNPropertyArgs<'args>
  ) -> flatbuffers::WIPOffset<GJNProperty<'bldr>> {
    let mut builder = GJNPropertyBuilder::new(_fbb);
    builder.add_NUM_VALUE(args.NUM_VALUE);
    if let Some(x) = args.JSON_VALUE { builder.add_JSON_VALUE(x); }
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    if let Some(x) = args.KEY { builder.add_KEY(x); }
    builder.add_IS_NULL(args.IS_NULL);
    builder.add_BOOL_VALUE(args.BOOL_VALUE);
    builder.add_IS_BOOL(args.IS_BOOL);
    builder.add_IS_NUMERIC(args.IS_NUMERIC);
    builder.finish()
  }

  pub fn unpack(&self) -> GJNPropertyT {
    let KEY = self.KEY().map(|x| {
      x.to_string()
    });
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    let NUM_VALUE = self.NUM_VALUE();
    let IS_NUMERIC = self.IS_NUMERIC();
    let IS_BOOL = self.IS_BOOL();
    let BOOL_VALUE = self.BOOL_VALUE();
    let IS_NULL = self.IS_NULL();
    let JSON_VALUE = self.JSON_VALUE().map(|x| {
      x.to_string()
    });
    GJNPropertyT {
      KEY,
      VALUE,
      NUM_VALUE,
      IS_NUMERIC,
      IS_BOOL,
      BOOL_VALUE,
      IS_NULL,
      JSON_VALUE,
    }
  }

  /// Property key
  #[inline]
  pub fn KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GJNProperty::VT_KEY, None)}
  }
  /// Property value as string
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GJNProperty::VT_VALUE, None)}
  }
  /// Property value as number (use if numeric)
  #[inline]
  pub fn NUM_VALUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNProperty::VT_NUM_VALUE, Some(0.0)).unwrap()}
  }
  /// True if NUM_VALUE should be used instead of VALUE
  #[inline]
  pub fn IS_NUMERIC(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNProperty::VT_IS_NUMERIC, Some(false)).unwrap()}
  }
  /// True if this property value is a boolean
  #[inline]
  pub fn IS_BOOL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNProperty::VT_IS_BOOL, Some(false)).unwrap()}
  }
  /// Boolean value (use when IS_BOOL is true)
  #[inline]
  pub fn BOOL_VALUE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNProperty::VT_BOOL_VALUE, Some(false)).unwrap()}
  }
  /// True if this property value is JSON null
  #[inline]
  pub fn IS_NULL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNProperty::VT_IS_NULL, Some(false)).unwrap()}
  }
  /// Raw JSON string for complex values (objects, arrays)
  #[inline]
  pub fn JSON_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GJNProperty::VT_JSON_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for GJNProperty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("KEY", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .visit_field::<f64>("NUM_VALUE", Self::VT_NUM_VALUE, false)?
     .visit_field::<bool>("IS_NUMERIC", Self::VT_IS_NUMERIC, false)?
     .visit_field::<bool>("IS_BOOL", Self::VT_IS_BOOL, false)?
     .visit_field::<bool>("BOOL_VALUE", Self::VT_BOOL_VALUE, false)?
     .visit_field::<bool>("IS_NULL", Self::VT_IS_NULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("JSON_VALUE", Self::VT_JSON_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNPropertyArgs<'a> {
    pub KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NUM_VALUE: f64,
    pub IS_NUMERIC: bool,
    pub IS_BOOL: bool,
    pub BOOL_VALUE: bool,
    pub IS_NULL: bool,
    pub JSON_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GJNPropertyArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNPropertyArgs {
      KEY: None,
      VALUE: None,
      NUM_VALUE: 0.0,
      IS_NUMERIC: false,
      IS_BOOL: false,
      BOOL_VALUE: false,
      IS_NULL: false,
      JSON_VALUE: None,
    }
  }
}

pub struct GJNPropertyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNPropertyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_KEY(&mut self, KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNProperty::VT_KEY, KEY);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNProperty::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn add_NUM_VALUE(&mut self, NUM_VALUE: f64) {
    self.fbb_.push_slot::<f64>(GJNProperty::VT_NUM_VALUE, NUM_VALUE, 0.0);
  }
  #[inline]
  pub fn add_IS_NUMERIC(&mut self, IS_NUMERIC: bool) {
    self.fbb_.push_slot::<bool>(GJNProperty::VT_IS_NUMERIC, IS_NUMERIC, false);
  }
  #[inline]
  pub fn add_IS_BOOL(&mut self, IS_BOOL: bool) {
    self.fbb_.push_slot::<bool>(GJNProperty::VT_IS_BOOL, IS_BOOL, false);
  }
  #[inline]
  pub fn add_BOOL_VALUE(&mut self, BOOL_VALUE: bool) {
    self.fbb_.push_slot::<bool>(GJNProperty::VT_BOOL_VALUE, BOOL_VALUE, false);
  }
  #[inline]
  pub fn add_IS_NULL(&mut self, IS_NULL: bool) {
    self.fbb_.push_slot::<bool>(GJNProperty::VT_IS_NULL, IS_NULL, false);
  }
  #[inline]
  pub fn add_JSON_VALUE(&mut self, JSON_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNProperty::VT_JSON_VALUE, JSON_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNPropertyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNPropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNProperty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNProperty<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNProperty");
      ds.field("KEY", &self.KEY());
      ds.field("VALUE", &self.VALUE());
      ds.field("NUM_VALUE", &self.NUM_VALUE());
      ds.field("IS_NUMERIC", &self.IS_NUMERIC());
      ds.field("IS_BOOL", &self.IS_BOOL());
      ds.field("BOOL_VALUE", &self.BOOL_VALUE());
      ds.field("IS_NULL", &self.IS_NULL());
      ds.field("JSON_VALUE", &self.JSON_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNPropertyT {
  pub KEY: Option<String>,
  pub VALUE: Option<String>,
  pub NUM_VALUE: f64,
  pub IS_NUMERIC: bool,
  pub IS_BOOL: bool,
  pub BOOL_VALUE: bool,
  pub IS_NULL: bool,
  pub JSON_VALUE: Option<String>,
}
impl Default for GJNPropertyT {
  fn default() -> Self {
    Self {
      KEY: None,
      VALUE: None,
      NUM_VALUE: 0.0,
      IS_NUMERIC: false,
      IS_BOOL: false,
      BOOL_VALUE: false,
      IS_NULL: false,
      JSON_VALUE: None,
    }
  }
}
impl GJNPropertyT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNProperty<'b>> {
    let KEY = self.KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NUM_VALUE = self.NUM_VALUE;
    let IS_NUMERIC = self.IS_NUMERIC;
    let IS_BOOL = self.IS_BOOL;
    let BOOL_VALUE = self.BOOL_VALUE;
    let IS_NULL = self.IS_NULL;
    let JSON_VALUE = self.JSON_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    GJNProperty::create(_fbb, &GJNPropertyArgs{
      KEY,
      VALUE,
      NUM_VALUE,
      IS_NUMERIC,
      IS_BOOL,
      BOOL_VALUE,
      IS_NULL,
      JSON_VALUE,
    })
  }
}
pub enum GJNFeatureOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GeoJSON Feature object
pub struct GJNFeature<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNFeature<'a> {
  type Inner = GJNFeature<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNFeature<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 6;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;
  pub const VT_NUM_ID: flatbuffers::VOffsetT = 10;
  pub const VT_ID_IS_NUMERIC: flatbuffers::VOffsetT = 12;
  pub const VT_HAS_GEOMETRY: flatbuffers::VOffsetT = 14;
  pub const VT_PROPERTIES_IS_NULL: flatbuffers::VOffsetT = 16;
  pub const VT_BBOX: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNFeature { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNFeatureArgs<'args>
  ) -> flatbuffers::WIPOffset<GJNFeature<'bldr>> {
    let mut builder = GJNFeatureBuilder::new(_fbb);
    builder.add_NUM_ID(args.NUM_ID);
    if let Some(x) = args.BBOX { builder.add_BBOX(x); }
    if let Some(x) = args.PROPERTIES { builder.add_PROPERTIES(x); }
    if let Some(x) = args.GEOMETRY { builder.add_GEOMETRY(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_PROPERTIES_IS_NULL(args.PROPERTIES_IS_NULL);
    builder.add_HAS_GEOMETRY(args.HAS_GEOMETRY);
    builder.add_ID_IS_NUMERIC(args.ID_IS_NUMERIC);
    builder.finish()
  }

  pub fn unpack(&self) -> GJNFeatureT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let GEOMETRY = self.GEOMETRY().map(|x| {
      Box::new(x.unpack())
    });
    let PROPERTIES = self.PROPERTIES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let NUM_ID = self.NUM_ID();
    let ID_IS_NUMERIC = self.ID_IS_NUMERIC();
    let HAS_GEOMETRY = self.HAS_GEOMETRY();
    let PROPERTIES_IS_NULL = self.PROPERTIES_IS_NULL();
    let BBOX = self.BBOX().map(|x| {
      Box::new(x.unpack())
    });
    GJNFeatureT {
      ID,
      GEOMETRY,
      PROPERTIES,
      NUM_ID,
      ID_IS_NUMERIC,
      HAS_GEOMETRY,
      PROPERTIES_IS_NULL,
      BBOX,
    }
  }

  /// Feature identifier (optional, string form)
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GJNFeature::VT_ID, None)}
  }
  /// Geometry of the feature
  #[inline]
  pub fn GEOMETRY(&self) -> Option<GJNGeometry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GJNGeometry>>(GJNFeature::VT_GEOMETRY, None)}
  }
  /// Properties as key-value pairs
  #[inline]
  pub fn PROPERTIES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNProperty<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNProperty>>>>(GJNFeature::VT_PROPERTIES, None)}
  }
  /// Numeric feature identifier (use when ID_IS_NUMERIC is true)
  #[inline]
  pub fn NUM_ID(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNFeature::VT_NUM_ID, Some(0.0)).unwrap()}
  }
  /// True if the feature id is numeric rather than string
  #[inline]
  pub fn ID_IS_NUMERIC(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNFeature::VT_ID_IS_NUMERIC, Some(false)).unwrap()}
  }
  /// True if the feature has a geometry (false means geometry was JSON null)
  #[inline]
  pub fn HAS_GEOMETRY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNFeature::VT_HAS_GEOMETRY, Some(false)).unwrap()}
  }
  /// True if properties was JSON null (vs empty object)
  #[inline]
  pub fn PROPERTIES_IS_NULL(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNFeature::VT_PROPERTIES_IS_NULL, Some(false)).unwrap()}
  }
  /// Bounding box (optional, per RFC 7946 Section 5)
  #[inline]
  pub fn BBOX(&self) -> Option<GJNBoundingBox<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>(GJNFeature::VT_BBOX, None)}
  }
}

impl flatbuffers::Verifiable for GJNFeature<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GJNGeometry>>("GEOMETRY", Self::VT_GEOMETRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNProperty>>>>("PROPERTIES", Self::VT_PROPERTIES, false)?
     .visit_field::<f64>("NUM_ID", Self::VT_NUM_ID, false)?
     .visit_field::<bool>("ID_IS_NUMERIC", Self::VT_ID_IS_NUMERIC, false)?
     .visit_field::<bool>("HAS_GEOMETRY", Self::VT_HAS_GEOMETRY, false)?
     .visit_field::<bool>("PROPERTIES_IS_NULL", Self::VT_PROPERTIES_IS_NULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>("BBOX", Self::VT_BBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNFeatureArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GEOMETRY: Option<flatbuffers::WIPOffset<GJNGeometry<'a>>>,
    pub PROPERTIES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNProperty<'a>>>>>,
    pub NUM_ID: f64,
    pub ID_IS_NUMERIC: bool,
    pub HAS_GEOMETRY: bool,
    pub PROPERTIES_IS_NULL: bool,
    pub BBOX: Option<flatbuffers::WIPOffset<GJNBoundingBox<'a>>>,
}
impl<'a> Default for GJNFeatureArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNFeatureArgs {
      ID: None,
      GEOMETRY: None,
      PROPERTIES: None,
      NUM_ID: 0.0,
      ID_IS_NUMERIC: false,
      HAS_GEOMETRY: false,
      PROPERTIES_IS_NULL: false,
      BBOX: None,
    }
  }
}

pub struct GJNFeatureBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNFeatureBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNFeature::VT_ID, ID);
  }
  #[inline]
  pub fn add_GEOMETRY(&mut self, GEOMETRY: flatbuffers::WIPOffset<GJNGeometry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GJNGeometry>>(GJNFeature::VT_GEOMETRY, GEOMETRY);
  }
  #[inline]
  pub fn add_PROPERTIES(&mut self, PROPERTIES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNProperty<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJNFeature::VT_PROPERTIES, PROPERTIES);
  }
  #[inline]
  pub fn add_NUM_ID(&mut self, NUM_ID: f64) {
    self.fbb_.push_slot::<f64>(GJNFeature::VT_NUM_ID, NUM_ID, 0.0);
  }
  #[inline]
  pub fn add_ID_IS_NUMERIC(&mut self, ID_IS_NUMERIC: bool) {
    self.fbb_.push_slot::<bool>(GJNFeature::VT_ID_IS_NUMERIC, ID_IS_NUMERIC, false);
  }
  #[inline]
  pub fn add_HAS_GEOMETRY(&mut self, HAS_GEOMETRY: bool) {
    self.fbb_.push_slot::<bool>(GJNFeature::VT_HAS_GEOMETRY, HAS_GEOMETRY, false);
  }
  #[inline]
  pub fn add_PROPERTIES_IS_NULL(&mut self, PROPERTIES_IS_NULL: bool) {
    self.fbb_.push_slot::<bool>(GJNFeature::VT_PROPERTIES_IS_NULL, PROPERTIES_IS_NULL, false);
  }
  #[inline]
  pub fn add_BBOX(&mut self, BBOX: flatbuffers::WIPOffset<GJNBoundingBox<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GJNBoundingBox>>(GJNFeature::VT_BBOX, BBOX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNFeatureBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNFeatureBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNFeature<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNFeature<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNFeature");
      ds.field("ID", &self.ID());
      ds.field("GEOMETRY", &self.GEOMETRY());
      ds.field("PROPERTIES", &self.PROPERTIES());
      ds.field("NUM_ID", &self.NUM_ID());
      ds.field("ID_IS_NUMERIC", &self.ID_IS_NUMERIC());
      ds.field("HAS_GEOMETRY", &self.HAS_GEOMETRY());
      ds.field("PROPERTIES_IS_NULL", &self.PROPERTIES_IS_NULL());
      ds.field("BBOX", &self.BBOX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNFeatureT {
  pub ID: Option<String>,
  pub GEOMETRY: Option<Box<GJNGeometryT>>,
  pub PROPERTIES: Option<Vec<GJNPropertyT>>,
  pub NUM_ID: f64,
  pub ID_IS_NUMERIC: bool,
  pub HAS_GEOMETRY: bool,
  pub PROPERTIES_IS_NULL: bool,
  pub BBOX: Option<Box<GJNBoundingBoxT>>,
}
impl Default for GJNFeatureT {
  fn default() -> Self {
    Self {
      ID: None,
      GEOMETRY: None,
      PROPERTIES: None,
      NUM_ID: 0.0,
      ID_IS_NUMERIC: false,
      HAS_GEOMETRY: false,
      PROPERTIES_IS_NULL: false,
      BBOX: None,
    }
  }
}
impl GJNFeatureT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNFeature<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GEOMETRY = self.GEOMETRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PROPERTIES = self.PROPERTIES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let NUM_ID = self.NUM_ID;
    let ID_IS_NUMERIC = self.ID_IS_NUMERIC;
    let HAS_GEOMETRY = self.HAS_GEOMETRY;
    let PROPERTIES_IS_NULL = self.PROPERTIES_IS_NULL;
    let BBOX = self.BBOX.as_ref().map(|x|{
      x.pack(_fbb)
    });
    GJNFeature::create(_fbb, &GJNFeatureArgs{
      ID,
      GEOMETRY,
      PROPERTIES,
      NUM_ID,
      ID_IS_NUMERIC,
      HAS_GEOMETRY,
      PROPERTIES_IS_NULL,
      BBOX,
    })
  }
}
pub enum GJNBoundingBoxOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GeoJSON Bounding Box [west, south, east, north] or [west, south, min-alt, east, north, max-alt]
pub struct GJNBoundingBox<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJNBoundingBox<'a> {
  type Inner = GJNBoundingBox<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJNBoundingBox<'a> {
  pub const VT_WEST: flatbuffers::VOffsetT = 4;
  pub const VT_SOUTH: flatbuffers::VOffsetT = 6;
  pub const VT_EAST: flatbuffers::VOffsetT = 8;
  pub const VT_NORTH: flatbuffers::VOffsetT = 10;
  pub const VT_MIN_ALTITUDE: flatbuffers::VOffsetT = 12;
  pub const VT_MAX_ALTITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_HAS_ALTITUDE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJNBoundingBox { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNBoundingBoxArgs
  ) -> flatbuffers::WIPOffset<GJNBoundingBox<'bldr>> {
    let mut builder = GJNBoundingBoxBuilder::new(_fbb);
    builder.add_MAX_ALTITUDE(args.MAX_ALTITUDE);
    builder.add_MIN_ALTITUDE(args.MIN_ALTITUDE);
    builder.add_NORTH(args.NORTH);
    builder.add_EAST(args.EAST);
    builder.add_SOUTH(args.SOUTH);
    builder.add_WEST(args.WEST);
    builder.add_HAS_ALTITUDE(args.HAS_ALTITUDE);
    builder.finish()
  }

  pub fn unpack(&self) -> GJNBoundingBoxT {
    let WEST = self.WEST();
    let SOUTH = self.SOUTH();
    let EAST = self.EAST();
    let NORTH = self.NORTH();
    let MIN_ALTITUDE = self.MIN_ALTITUDE();
    let MAX_ALTITUDE = self.MAX_ALTITUDE();
    let HAS_ALTITUDE = self.HAS_ALTITUDE();
    GJNBoundingBoxT {
      WEST,
      SOUTH,
      EAST,
      NORTH,
      MIN_ALTITUDE,
      MAX_ALTITUDE,
      HAS_ALTITUDE,
    }
  }

  /// Western longitude
  #[inline]
  pub fn WEST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_WEST, Some(0.0)).unwrap()}
  }
  /// Southern latitude
  #[inline]
  pub fn SOUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_SOUTH, Some(0.0)).unwrap()}
  }
  /// Eastern longitude
  #[inline]
  pub fn EAST(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_EAST, Some(0.0)).unwrap()}
  }
  /// Northern latitude
  #[inline]
  pub fn NORTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_NORTH, Some(0.0)).unwrap()}
  }
  /// Minimum altitude (optional)
  #[inline]
  pub fn MIN_ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_MIN_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// Maximum altitude (optional)
  #[inline]
  pub fn MAX_ALTITUDE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GJNBoundingBox::VT_MAX_ALTITUDE, Some(0.0)).unwrap()}
  }
  /// True if the bbox includes altitude (6 values vs 4)
  #[inline]
  pub fn HAS_ALTITUDE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GJNBoundingBox::VT_HAS_ALTITUDE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GJNBoundingBox<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("WEST", Self::VT_WEST, false)?
     .visit_field::<f64>("SOUTH", Self::VT_SOUTH, false)?
     .visit_field::<f64>("EAST", Self::VT_EAST, false)?
     .visit_field::<f64>("NORTH", Self::VT_NORTH, false)?
     .visit_field::<f64>("MIN_ALTITUDE", Self::VT_MIN_ALTITUDE, false)?
     .visit_field::<f64>("MAX_ALTITUDE", Self::VT_MAX_ALTITUDE, false)?
     .visit_field::<bool>("HAS_ALTITUDE", Self::VT_HAS_ALTITUDE, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNBoundingBoxArgs {
    pub WEST: f64,
    pub SOUTH: f64,
    pub EAST: f64,
    pub NORTH: f64,
    pub MIN_ALTITUDE: f64,
    pub MAX_ALTITUDE: f64,
    pub HAS_ALTITUDE: bool,
}
impl<'a> Default for GJNBoundingBoxArgs {
  #[inline]
  fn default() -> Self {
    GJNBoundingBoxArgs {
      WEST: 0.0,
      SOUTH: 0.0,
      EAST: 0.0,
      NORTH: 0.0,
      MIN_ALTITUDE: 0.0,
      MAX_ALTITUDE: 0.0,
      HAS_ALTITUDE: false,
    }
  }
}

pub struct GJNBoundingBoxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNBoundingBoxBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_WEST(&mut self, WEST: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_WEST, WEST, 0.0);
  }
  #[inline]
  pub fn add_SOUTH(&mut self, SOUTH: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_SOUTH, SOUTH, 0.0);
  }
  #[inline]
  pub fn add_EAST(&mut self, EAST: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_EAST, EAST, 0.0);
  }
  #[inline]
  pub fn add_NORTH(&mut self, NORTH: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_NORTH, NORTH, 0.0);
  }
  #[inline]
  pub fn add_MIN_ALTITUDE(&mut self, MIN_ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_MIN_ALTITUDE, MIN_ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_MAX_ALTITUDE(&mut self, MAX_ALTITUDE: f64) {
    self.fbb_.push_slot::<f64>(GJNBoundingBox::VT_MAX_ALTITUDE, MAX_ALTITUDE, 0.0);
  }
  #[inline]
  pub fn add_HAS_ALTITUDE(&mut self, HAS_ALTITUDE: bool) {
    self.fbb_.push_slot::<bool>(GJNBoundingBox::VT_HAS_ALTITUDE, HAS_ALTITUDE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNBoundingBoxBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNBoundingBoxBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJNBoundingBox<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJNBoundingBox<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJNBoundingBox");
      ds.field("WEST", &self.WEST());
      ds.field("SOUTH", &self.SOUTH());
      ds.field("EAST", &self.EAST());
      ds.field("NORTH", &self.NORTH());
      ds.field("MIN_ALTITUDE", &self.MIN_ALTITUDE());
      ds.field("MAX_ALTITUDE", &self.MAX_ALTITUDE());
      ds.field("HAS_ALTITUDE", &self.HAS_ALTITUDE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNBoundingBoxT {
  pub WEST: f64,
  pub SOUTH: f64,
  pub EAST: f64,
  pub NORTH: f64,
  pub MIN_ALTITUDE: f64,
  pub MAX_ALTITUDE: f64,
  pub HAS_ALTITUDE: bool,
}
impl Default for GJNBoundingBoxT {
  fn default() -> Self {
    Self {
      WEST: 0.0,
      SOUTH: 0.0,
      EAST: 0.0,
      NORTH: 0.0,
      MIN_ALTITUDE: 0.0,
      MAX_ALTITUDE: 0.0,
      HAS_ALTITUDE: false,
    }
  }
}
impl GJNBoundingBoxT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJNBoundingBox<'b>> {
    let WEST = self.WEST;
    let SOUTH = self.SOUTH;
    let EAST = self.EAST;
    let NORTH = self.NORTH;
    let MIN_ALTITUDE = self.MIN_ALTITUDE;
    let MAX_ALTITUDE = self.MAX_ALTITUDE;
    let HAS_ALTITUDE = self.HAS_ALTITUDE;
    GJNBoundingBox::create(_fbb, &GJNBoundingBoxArgs{
      WEST,
      SOUTH,
      EAST,
      NORTH,
      MIN_ALTITUDE,
      MAX_ALTITUDE,
      HAS_ALTITUDE,
    })
  }
}
pub enum GJNOffset {}
#[derive(Copy, Clone, PartialEq)]

/// GeoJSON FeatureCollection
pub struct GJN<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GJN<'a> {
  type Inner = GJN<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GJN<'a> {
  pub const VT_FEATURES: flatbuffers::VOffsetT = 4;
  pub const VT_BBOX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GJN { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GJNArgs<'args>
  ) -> flatbuffers::WIPOffset<GJN<'bldr>> {
    let mut builder = GJNBuilder::new(_fbb);
    if let Some(x) = args.BBOX { builder.add_BBOX(x); }
    if let Some(x) = args.FEATURES { builder.add_FEATURES(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> GJNT {
    let FEATURES = self.FEATURES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BBOX = self.BBOX().map(|x| {
      Box::new(x.unpack())
    });
    GJNT {
      FEATURES,
      BBOX,
    }
  }

  /// Features in the collection
  #[inline]
  pub fn FEATURES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNFeature<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNFeature>>>>(GJN::VT_FEATURES, None)}
  }
  /// Bounding box (optional)
  #[inline]
  pub fn BBOX(&self) -> Option<GJNBoundingBox<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>(GJN::VT_BBOX, None)}
  }
}

impl flatbuffers::Verifiable for GJN<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GJNFeature>>>>("FEATURES", Self::VT_FEATURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GJNBoundingBox>>("BBOX", Self::VT_BBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct GJNArgs<'a> {
    pub FEATURES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GJNFeature<'a>>>>>,
    pub BBOX: Option<flatbuffers::WIPOffset<GJNBoundingBox<'a>>>,
}
impl<'a> Default for GJNArgs<'a> {
  #[inline]
  fn default() -> Self {
    GJNArgs {
      FEATURES: None,
      BBOX: None,
    }
  }
}

pub struct GJNBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GJNBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_FEATURES(&mut self, FEATURES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GJNFeature<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GJN::VT_FEATURES, FEATURES);
  }
  #[inline]
  pub fn add_BBOX(&mut self, BBOX: flatbuffers::WIPOffset<GJNBoundingBox<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GJNBoundingBox>>(GJN::VT_BBOX, BBOX);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GJNBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GJNBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GJN<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GJN<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GJN");
      ds.field("FEATURES", &self.FEATURES());
      ds.field("BBOX", &self.BBOX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GJNT {
  pub FEATURES: Option<Vec<GJNFeatureT>>,
  pub BBOX: Option<Box<GJNBoundingBoxT>>,
}
impl Default for GJNT {
  fn default() -> Self {
    Self {
      FEATURES: None,
      BBOX: None,
    }
  }
}
impl GJNT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GJN<'b>> {
    let FEATURES = self.FEATURES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BBOX = self.BBOX.as_ref().map(|x|{
      x.pack(_fbb)
    });
    GJN::create(_fbb, &GJNArgs{
      FEATURES,
      BBOX,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GJN`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GJN_unchecked`.
pub fn root_as_GJN(buf: &[u8]) -> Result<GJN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GJN>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GJN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_GJN_unchecked`.
pub fn size_prefixed_root_as_GJN(buf: &[u8]) -> Result<GJN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GJN>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GJN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GJN_unchecked`.
pub fn root_as_GJN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GJN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GJN<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GJN` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GJN_unchecked`.
pub fn size_prefixed_root_as_GJN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GJN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GJN<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GJN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GJN`.
pub unsafe fn root_as_GJN_unchecked(buf: &[u8]) -> GJN {
  flatbuffers::root_unchecked::<GJN>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GJN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GJN`.
pub unsafe fn size_prefixed_root_as_GJN_unchecked(buf: &[u8]) -> GJN {
  flatbuffers::size_prefixed_root_unchecked::<GJN>(buf)
}
pub const GJN_IDENTIFIER: &str = "$GJN";

#[inline]
pub fn GJN_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GJN_IDENTIFIER, false)
}

#[inline]
pub fn GJN_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GJN_IDENTIFIER, true)
}

#[inline]
pub fn finish_GJN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GJN<'a>>) {
  fbb.finish(root, Some(GJN_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_GJN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GJN<'a>>) {
  fbb.finish_size_prefixed(root, Some(GJN_IDENTIFIER));
}
