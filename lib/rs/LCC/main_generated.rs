// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LEGACY_COUNTRY_CODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LEGACY_COUNTRY_CODE: i8 = 125;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LEGACY_COUNTRY_CODE: [legacyCountryCode; 126] = [
  legacyCountryCode::AB,
  legacyCountryCode::ABS,
  legacyCountryCode::AC,
  legacyCountryCode::ALG,
  legacyCountryCode::ANG,
  legacyCountryCode::ARGN,
  legacyCountryCode::ARM,
  legacyCountryCode::ASRA,
  legacyCountryCode::AUS,
  legacyCountryCode::AZER,
  legacyCountryCode::BEL,
  legacyCountryCode::BELA,
  legacyCountryCode::BERM,
  legacyCountryCode::BGD,
  legacyCountryCode::BHUT,
  legacyCountryCode::BOL,
  legacyCountryCode::BRAZ,
  legacyCountryCode::BUL,
  legacyCountryCode::CA,
  legacyCountryCode::CHBZ,
  legacyCountryCode::CHTU,
  legacyCountryCode::CHLE,
  legacyCountryCode::CIS,
  legacyCountryCode::COL,
  legacyCountryCode::CRI,
  legacyCountryCode::CZCH,
  legacyCountryCode::DEN,
  legacyCountryCode::DJI,
  legacyCountryCode::ECU,
  legacyCountryCode::EGYP,
  legacyCountryCode::ESA,
  legacyCountryCode::ESRO,
  legacyCountryCode::EST,
  legacyCountryCode::ETH,
  legacyCountryCode::EUME,
  legacyCountryCode::EUTE,
  legacyCountryCode::FGER,
  legacyCountryCode::FIN,
  legacyCountryCode::FR,
  legacyCountryCode::FRIT,
  legacyCountryCode::GER,
  legacyCountryCode::GHA,
  legacyCountryCode::GLOB,
  legacyCountryCode::GREC,
  legacyCountryCode::GRSA,
  legacyCountryCode::GUAT,
  legacyCountryCode::HUN,
  legacyCountryCode::IM,
  legacyCountryCode::IND,
  legacyCountryCode::INDO,
  legacyCountryCode::IRAN,
  legacyCountryCode::IRAQ,
  legacyCountryCode::IRID,
  legacyCountryCode::IRL,
  legacyCountryCode::ISRA,
  legacyCountryCode::ISRO,
  legacyCountryCode::ISS,
  legacyCountryCode::IT,
  legacyCountryCode::ITSO,
  legacyCountryCode::JPN,
  legacyCountryCode::KAZ,
  legacyCountryCode::KEN,
  legacyCountryCode::LAOS,
  legacyCountryCode::LKA,
  legacyCountryCode::LTU,
  legacyCountryCode::LUXE,
  legacyCountryCode::MA,
  legacyCountryCode::MALA,
  legacyCountryCode::MCO,
  legacyCountryCode::MDA,
  legacyCountryCode::MEX,
  legacyCountryCode::MMR,
  legacyCountryCode::MNG,
  legacyCountryCode::MUS,
  legacyCountryCode::NATO,
  legacyCountryCode::NETH,
  legacyCountryCode::NICO,
  legacyCountryCode::NIG,
  legacyCountryCode::NKOR,
  legacyCountryCode::NOR,
  legacyCountryCode::NPL,
  legacyCountryCode::NZ,
  legacyCountryCode::O3B,
  legacyCountryCode::ORB,
  legacyCountryCode::PAKI,
  legacyCountryCode::PERU,
  legacyCountryCode::POL,
  legacyCountryCode::POR,
  legacyCountryCode::PRC,
  legacyCountryCode::PRY,
  legacyCountryCode::PRES,
  legacyCountryCode::QAT,
  legacyCountryCode::RASC,
  legacyCountryCode::ROC,
  legacyCountryCode::ROM,
  legacyCountryCode::RP,
  legacyCountryCode::RWA,
  legacyCountryCode::SAFR,
  legacyCountryCode::SAUD,
  legacyCountryCode::SDN,
  legacyCountryCode::SEAL,
  legacyCountryCode::SES,
  legacyCountryCode::SGJP,
  legacyCountryCode::SING,
  legacyCountryCode::SKOR,
  legacyCountryCode::SPN,
  legacyCountryCode::STCT,
  legacyCountryCode::SVN,
  legacyCountryCode::SWED,
  legacyCountryCode::SWTZ,
  legacyCountryCode::TBD,
  legacyCountryCode::THAI,
  legacyCountryCode::TMMC,
  legacyCountryCode::TUN,
  legacyCountryCode::TURK,
  legacyCountryCode::UAE,
  legacyCountryCode::UK,
  legacyCountryCode::UKR,
  legacyCountryCode::UNK,
  legacyCountryCode::URY,
  legacyCountryCode::US,
  legacyCountryCode::USBZ,
  legacyCountryCode::VAT,
  legacyCountryCode::VENZ,
  legacyCountryCode::VTNM,
  legacyCountryCode::ZWE,
];

/// Legacy Country Code
/// Note: this is for legacy compatibility; all messages requiring use of CAT should have an associated EPM
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct legacyCountryCode(pub i8);
#[allow(non_upper_case_globals)]
impl legacyCountryCode {
  /// Arab Satellite Communications Organization
  pub const AB: Self = Self(0);
  /// Asia Broadcast Satellite
  pub const ABS: Self = Self(1);
  /// Asia Satellite Telecommunications Company (ASIASAT)
  pub const AC: Self = Self(2);
  /// Algeria
  pub const ALG: Self = Self(3);
  /// Angola
  pub const ANG: Self = Self(4);
  /// Argentina
  pub const ARGN: Self = Self(5);
  /// Republic of Armenia
  pub const ARM: Self = Self(6);
  /// Austria
  pub const ASRA: Self = Self(7);
  /// Australia
  pub const AUS: Self = Self(8);
  /// Azerbaijan
  pub const AZER: Self = Self(9);
  /// Belgium
  pub const BEL: Self = Self(10);
  /// Belarus
  pub const BELA: Self = Self(11);
  /// Bermuda
  pub const BERM: Self = Self(12);
  /// People's Republic of Bangladesh
  pub const BGD: Self = Self(13);
  /// Kingdom of Bhutan
  pub const BHUT: Self = Self(14);
  /// Bolivia
  pub const BOL: Self = Self(15);
  /// Brazil
  pub const BRAZ: Self = Self(16);
  /// Bulgaria
  pub const BUL: Self = Self(17);
  /// Canada
  pub const CA: Self = Self(18);
  /// China/Brazil
  pub const CHBZ: Self = Self(19);
  /// China/Turkey
  pub const CHTU: Self = Self(20);
  /// Chile
  pub const CHLE: Self = Self(21);
  /// Commonwealth of Independent States (former USSR)
  pub const CIS: Self = Self(22);
  /// Colombia
  pub const COL: Self = Self(23);
  /// Republic of Costa Rica
  pub const CRI: Self = Self(24);
  /// Czech Republic (former Czechoslovakia)
  pub const CZCH: Self = Self(25);
  /// Denmark
  pub const DEN: Self = Self(26);
  /// Republic of Djibouti
  pub const DJI: Self = Self(27);
  /// Ecuador
  pub const ECU: Self = Self(28);
  /// Egypt
  pub const EGYP: Self = Self(29);
  /// European Space Agency
  pub const ESA: Self = Self(30);
  /// European Space Research Organization
  pub const ESRO: Self = Self(31);
  /// Estonia
  pub const EST: Self = Self(32);
  /// Ethiopia
  pub const ETH: Self = Self(33);
  /// European Organization for the Exploitation of Meteorological Satellites (EUMETSAT)
  pub const EUME: Self = Self(34);
  /// European Telecommunications Satellite Organization (EUTELSAT)
  pub const EUTE: Self = Self(35);
  /// France/Germany
  pub const FGER: Self = Self(36);
  /// Finland
  pub const FIN: Self = Self(37);
  /// France
  pub const FR: Self = Self(38);
  /// France/Italy
  pub const FRIT: Self = Self(39);
  /// Germany
  pub const GER: Self = Self(40);
  /// Republic of Ghana
  pub const GHA: Self = Self(41);
  /// Globalstar
  pub const GLOB: Self = Self(42);
  /// Greece
  pub const GREC: Self = Self(43);
  /// Greece/Saudi Arabia
  pub const GRSA: Self = Self(44);
  /// Guatemala
  pub const GUAT: Self = Self(45);
  /// Hungary
  pub const HUN: Self = Self(46);
  /// International Mobile Satellite Organization (INMARSAT)
  pub const IM: Self = Self(47);
  /// India
  pub const IND: Self = Self(48);
  /// Indonesia
  pub const INDO: Self = Self(49);
  /// Iran
  pub const IRAN: Self = Self(50);
  /// Iraq
  pub const IRAQ: Self = Self(51);
  /// Iridium
  pub const IRID: Self = Self(52);
  /// Ireland
  pub const IRL: Self = Self(53);
  /// Israel
  pub const ISRA: Self = Self(54);
  /// Indian Space Research Organisation
  pub const ISRO: Self = Self(55);
  /// International Space Station
  pub const ISS: Self = Self(56);
  /// Italy
  pub const IT: Self = Self(57);
  /// International Telecommunications Satellite Organization (INTELSAT)
  pub const ITSO: Self = Self(58);
  /// Japan
  pub const JPN: Self = Self(59);
  /// Kazakhstan
  pub const KAZ: Self = Self(60);
  /// Republic of Kenya
  pub const KEN: Self = Self(61);
  /// Laos
  pub const LAOS: Self = Self(62);
  /// Democratic Socialist Republic of Sri Lanka
  pub const LKA: Self = Self(63);
  /// Lithuania
  pub const LTU: Self = Self(64);
  /// Luxembourg
  pub const LUXE: Self = Self(65);
  /// Morocco
  pub const MA: Self = Self(66);
  /// Malaysia
  pub const MALA: Self = Self(67);
  /// Principality of Monaco
  pub const MCO: Self = Self(68);
  /// Republic of Moldova
  pub const MDA: Self = Self(69);
  /// Mexico
  pub const MEX: Self = Self(70);
  /// Republic of the Union of Myanmar
  pub const MMR: Self = Self(71);
  /// Mongolia
  pub const MNG: Self = Self(72);
  /// Mauritius
  pub const MUS: Self = Self(73);
  /// North Atlantic Treaty Organization
  pub const NATO: Self = Self(74);
  /// Netherlands
  pub const NETH: Self = Self(75);
  /// New ICO
  pub const NICO: Self = Self(76);
  /// Nigeria
  pub const NIG: Self = Self(77);
  /// Democratic People's Republic of Korea
  pub const NKOR: Self = Self(78);
  /// Norway
  pub const NOR: Self = Self(79);
  /// Federal Democratic Republic of Nepal
  pub const NPL: Self = Self(80);
  /// New Zealand
  pub const NZ: Self = Self(81);
  /// O3b Networks
  pub const O3B: Self = Self(82);
  /// ORBCOMM
  pub const ORB: Self = Self(83);
  /// Pakistan
  pub const PAKI: Self = Self(84);
  /// Peru
  pub const PERU: Self = Self(85);
  /// Poland
  pub const POL: Self = Self(86);
  /// Portugal
  pub const POR: Self = Self(87);
  /// People's Republic of China
  pub const PRC: Self = Self(88);
  /// Republic of Paraguay
  pub const PRY: Self = Self(89);
  /// People's Republic of China/European Space Agency
  pub const PRES: Self = Self(90);
  /// State of Qatar
  pub const QAT: Self = Self(91);
  /// RascomStar-QAF
  pub const RASC: Self = Self(92);
  /// Taiwan (Republic of China)
  pub const ROC: Self = Self(93);
  /// Romania
  pub const ROM: Self = Self(94);
  /// Philippines (Republic of the Philippines)
  pub const RP: Self = Self(95);
  /// Republic of Rwanda
  pub const RWA: Self = Self(96);
  /// South Africa
  pub const SAFR: Self = Self(97);
  /// Saudi Arabia
  pub const SAUD: Self = Self(98);
  /// Republic of Sudan
  pub const SDN: Self = Self(99);
  /// Sea Launch
  pub const SEAL: Self = Self(100);
  /// SES
  pub const SES: Self = Self(101);
  /// Singapore/Japan
  pub const SGJP: Self = Self(102);
  /// Singapore
  pub const SING: Self = Self(103);
  /// Republic of Korea
  pub const SKOR: Self = Self(104);
  /// Spain
  pub const SPN: Self = Self(105);
  /// Singapore/Taiwan
  pub const STCT: Self = Self(106);
  /// Slovenia
  pub const SVN: Self = Self(107);
  /// Sweden
  pub const SWED: Self = Self(108);
  /// Switzerland
  pub const SWTZ: Self = Self(109);
  /// To Be Determined
  pub const TBD: Self = Self(110);
  /// Thailand
  pub const THAI: Self = Self(111);
  /// Turkmenistan/Monaco
  pub const TMMC: Self = Self(112);
  /// Republic of Tunisia
  pub const TUN: Self = Self(113);
  /// Turkey
  pub const TURK: Self = Self(114);
  /// United Arab Emirates
  pub const UAE: Self = Self(115);
  /// United Kingdom
  pub const UK: Self = Self(116);
  /// Ukraine
  pub const UKR: Self = Self(117);
  /// Unknown
  pub const UNK: Self = Self(118);
  /// Uruguay
  pub const URY: Self = Self(119);
  /// United States
  pub const US: Self = Self(120);
  /// United States/Brazil
  pub const USBZ: Self = Self(121);
  /// Vatican City State
  pub const VAT: Self = Self(122);
  /// Venezuela
  pub const VENZ: Self = Self(123);
  /// Vietnam
  pub const VTNM: Self = Self(124);
  /// Republic of Zimbabwe
  pub const ZWE: Self = Self(125);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 125;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AB,
    Self::ABS,
    Self::AC,
    Self::ALG,
    Self::ANG,
    Self::ARGN,
    Self::ARM,
    Self::ASRA,
    Self::AUS,
    Self::AZER,
    Self::BEL,
    Self::BELA,
    Self::BERM,
    Self::BGD,
    Self::BHUT,
    Self::BOL,
    Self::BRAZ,
    Self::BUL,
    Self::CA,
    Self::CHBZ,
    Self::CHTU,
    Self::CHLE,
    Self::CIS,
    Self::COL,
    Self::CRI,
    Self::CZCH,
    Self::DEN,
    Self::DJI,
    Self::ECU,
    Self::EGYP,
    Self::ESA,
    Self::ESRO,
    Self::EST,
    Self::ETH,
    Self::EUME,
    Self::EUTE,
    Self::FGER,
    Self::FIN,
    Self::FR,
    Self::FRIT,
    Self::GER,
    Self::GHA,
    Self::GLOB,
    Self::GREC,
    Self::GRSA,
    Self::GUAT,
    Self::HUN,
    Self::IM,
    Self::IND,
    Self::INDO,
    Self::IRAN,
    Self::IRAQ,
    Self::IRID,
    Self::IRL,
    Self::ISRA,
    Self::ISRO,
    Self::ISS,
    Self::IT,
    Self::ITSO,
    Self::JPN,
    Self::KAZ,
    Self::KEN,
    Self::LAOS,
    Self::LKA,
    Self::LTU,
    Self::LUXE,
    Self::MA,
    Self::MALA,
    Self::MCO,
    Self::MDA,
    Self::MEX,
    Self::MMR,
    Self::MNG,
    Self::MUS,
    Self::NATO,
    Self::NETH,
    Self::NICO,
    Self::NIG,
    Self::NKOR,
    Self::NOR,
    Self::NPL,
    Self::NZ,
    Self::O3B,
    Self::ORB,
    Self::PAKI,
    Self::PERU,
    Self::POL,
    Self::POR,
    Self::PRC,
    Self::PRY,
    Self::PRES,
    Self::QAT,
    Self::RASC,
    Self::ROC,
    Self::ROM,
    Self::RP,
    Self::RWA,
    Self::SAFR,
    Self::SAUD,
    Self::SDN,
    Self::SEAL,
    Self::SES,
    Self::SGJP,
    Self::SING,
    Self::SKOR,
    Self::SPN,
    Self::STCT,
    Self::SVN,
    Self::SWED,
    Self::SWTZ,
    Self::TBD,
    Self::THAI,
    Self::TMMC,
    Self::TUN,
    Self::TURK,
    Self::UAE,
    Self::UK,
    Self::UKR,
    Self::UNK,
    Self::URY,
    Self::US,
    Self::USBZ,
    Self::VAT,
    Self::VENZ,
    Self::VTNM,
    Self::ZWE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AB => Some("AB"),
      Self::ABS => Some("ABS"),
      Self::AC => Some("AC"),
      Self::ALG => Some("ALG"),
      Self::ANG => Some("ANG"),
      Self::ARGN => Some("ARGN"),
      Self::ARM => Some("ARM"),
      Self::ASRA => Some("ASRA"),
      Self::AUS => Some("AUS"),
      Self::AZER => Some("AZER"),
      Self::BEL => Some("BEL"),
      Self::BELA => Some("BELA"),
      Self::BERM => Some("BERM"),
      Self::BGD => Some("BGD"),
      Self::BHUT => Some("BHUT"),
      Self::BOL => Some("BOL"),
      Self::BRAZ => Some("BRAZ"),
      Self::BUL => Some("BUL"),
      Self::CA => Some("CA"),
      Self::CHBZ => Some("CHBZ"),
      Self::CHTU => Some("CHTU"),
      Self::CHLE => Some("CHLE"),
      Self::CIS => Some("CIS"),
      Self::COL => Some("COL"),
      Self::CRI => Some("CRI"),
      Self::CZCH => Some("CZCH"),
      Self::DEN => Some("DEN"),
      Self::DJI => Some("DJI"),
      Self::ECU => Some("ECU"),
      Self::EGYP => Some("EGYP"),
      Self::ESA => Some("ESA"),
      Self::ESRO => Some("ESRO"),
      Self::EST => Some("EST"),
      Self::ETH => Some("ETH"),
      Self::EUME => Some("EUME"),
      Self::EUTE => Some("EUTE"),
      Self::FGER => Some("FGER"),
      Self::FIN => Some("FIN"),
      Self::FR => Some("FR"),
      Self::FRIT => Some("FRIT"),
      Self::GER => Some("GER"),
      Self::GHA => Some("GHA"),
      Self::GLOB => Some("GLOB"),
      Self::GREC => Some("GREC"),
      Self::GRSA => Some("GRSA"),
      Self::GUAT => Some("GUAT"),
      Self::HUN => Some("HUN"),
      Self::IM => Some("IM"),
      Self::IND => Some("IND"),
      Self::INDO => Some("INDO"),
      Self::IRAN => Some("IRAN"),
      Self::IRAQ => Some("IRAQ"),
      Self::IRID => Some("IRID"),
      Self::IRL => Some("IRL"),
      Self::ISRA => Some("ISRA"),
      Self::ISRO => Some("ISRO"),
      Self::ISS => Some("ISS"),
      Self::IT => Some("IT"),
      Self::ITSO => Some("ITSO"),
      Self::JPN => Some("JPN"),
      Self::KAZ => Some("KAZ"),
      Self::KEN => Some("KEN"),
      Self::LAOS => Some("LAOS"),
      Self::LKA => Some("LKA"),
      Self::LTU => Some("LTU"),
      Self::LUXE => Some("LUXE"),
      Self::MA => Some("MA"),
      Self::MALA => Some("MALA"),
      Self::MCO => Some("MCO"),
      Self::MDA => Some("MDA"),
      Self::MEX => Some("MEX"),
      Self::MMR => Some("MMR"),
      Self::MNG => Some("MNG"),
      Self::MUS => Some("MUS"),
      Self::NATO => Some("NATO"),
      Self::NETH => Some("NETH"),
      Self::NICO => Some("NICO"),
      Self::NIG => Some("NIG"),
      Self::NKOR => Some("NKOR"),
      Self::NOR => Some("NOR"),
      Self::NPL => Some("NPL"),
      Self::NZ => Some("NZ"),
      Self::O3B => Some("O3B"),
      Self::ORB => Some("ORB"),
      Self::PAKI => Some("PAKI"),
      Self::PERU => Some("PERU"),
      Self::POL => Some("POL"),
      Self::POR => Some("POR"),
      Self::PRC => Some("PRC"),
      Self::PRY => Some("PRY"),
      Self::PRES => Some("PRES"),
      Self::QAT => Some("QAT"),
      Self::RASC => Some("RASC"),
      Self::ROC => Some("ROC"),
      Self::ROM => Some("ROM"),
      Self::RP => Some("RP"),
      Self::RWA => Some("RWA"),
      Self::SAFR => Some("SAFR"),
      Self::SAUD => Some("SAUD"),
      Self::SDN => Some("SDN"),
      Self::SEAL => Some("SEAL"),
      Self::SES => Some("SES"),
      Self::SGJP => Some("SGJP"),
      Self::SING => Some("SING"),
      Self::SKOR => Some("SKOR"),
      Self::SPN => Some("SPN"),
      Self::STCT => Some("STCT"),
      Self::SVN => Some("SVN"),
      Self::SWED => Some("SWED"),
      Self::SWTZ => Some("SWTZ"),
      Self::TBD => Some("TBD"),
      Self::THAI => Some("THAI"),
      Self::TMMC => Some("TMMC"),
      Self::TUN => Some("TUN"),
      Self::TURK => Some("TURK"),
      Self::UAE => Some("UAE"),
      Self::UK => Some("UK"),
      Self::UKR => Some("UKR"),
      Self::UNK => Some("UNK"),
      Self::URY => Some("URY"),
      Self::US => Some("US"),
      Self::USBZ => Some("USBZ"),
      Self::VAT => Some("VAT"),
      Self::VENZ => Some("VENZ"),
      Self::VTNM => Some("VTNM"),
      Self::ZWE => Some("ZWE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for legacyCountryCode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for legacyCountryCode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for legacyCountryCode {
    type Output = legacyCountryCode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for legacyCountryCode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for legacyCountryCode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for legacyCountryCode {}
pub enum LCCOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LCC<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LCC<'a> {
  type Inner = LCC<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LCC<'a> {
  pub const VT_OWNER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LCC { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LCCArgs
  ) -> flatbuffers::WIPOffset<LCC<'bldr>> {
    let mut builder = LCCBuilder::new(_fbb);
    builder.add_OWNER(args.OWNER);
    builder.finish()
  }

  pub fn unpack(&self) -> LCCT {
    let OWNER = self.OWNER();
    LCCT {
      OWNER,
    }
  }

  #[inline]
  pub fn OWNER(&self) -> legacyCountryCode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<legacyCountryCode>(LCC::VT_OWNER, Some(legacyCountryCode::AB)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LCC<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<legacyCountryCode>("OWNER", Self::VT_OWNER, false)?
     .finish();
    Ok(())
  }
}
pub struct LCCArgs {
    pub OWNER: legacyCountryCode,
}
impl<'a> Default for LCCArgs {
  #[inline]
  fn default() -> Self {
    LCCArgs {
      OWNER: legacyCountryCode::AB,
    }
  }
}

pub struct LCCBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LCCBuilder<'a, 'b> {
  #[inline]
  pub fn add_OWNER(&mut self, OWNER: legacyCountryCode) {
    self.fbb_.push_slot::<legacyCountryCode>(LCC::VT_OWNER, OWNER, legacyCountryCode::AB);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LCCBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LCCBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LCC<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LCC<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LCC");
      ds.field("OWNER", &self.OWNER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LCCT {
  pub OWNER: legacyCountryCode,
}
impl Default for LCCT {
  fn default() -> Self {
    Self {
      OWNER: legacyCountryCode::AB,
    }
  }
}
impl LCCT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LCC<'b>> {
    let OWNER = self.OWNER;
    LCC::create(_fbb, &LCCArgs{
      OWNER,
    })
  }
}
pub enum LCCCOLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LCCCOLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LCCCOLLECTION<'a> {
  type Inner = LCCCOLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LCCCOLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LCCCOLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LCCCOLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<LCCCOLLECTION<'bldr>> {
    let mut builder = LCCCOLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> LCCCOLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    LCCCOLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LCC<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LCC>>>>(LCCCOLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for LCCCOLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LCC>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct LCCCOLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LCC<'a>>>>>,
}
impl<'a> Default for LCCCOLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    LCCCOLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct LCCCOLLECTIONBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LCCCOLLECTIONBuilder<'a, 'b> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LCC<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LCCCOLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LCCCOLLECTIONBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LCCCOLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LCCCOLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LCCCOLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LCCCOLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LCCCOLLECTIONT {
  pub RECORDS: Option<Vec<LCCT>>,
}
impl Default for LCCCOLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl LCCCOLLECTIONT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LCCCOLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    LCCCOLLECTION::create(_fbb, &LCCCOLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `LCC`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LCC_unchecked`.
pub fn root_as_LCC(buf: &[u8]) -> Result<LCC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<LCC>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `LCC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_LCC_unchecked`.
pub fn size_prefixed_root_as_LCC(buf: &[u8]) -> Result<LCC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<LCC>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `LCC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LCC_unchecked`.
pub fn root_as_LCC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LCC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<LCC<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `LCC` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_LCC_unchecked`.
pub fn size_prefixed_root_as_LCC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<LCC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<LCC<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a LCC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `LCC`.
pub unsafe fn root_as_LCC_unchecked(buf: &[u8]) -> LCC {
  flatbuffers::root_unchecked::<LCC>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed LCC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `LCC`.
pub unsafe fn size_prefixed_root_as_LCC_unchecked(buf: &[u8]) -> LCC {
  flatbuffers::size_prefixed_root_unchecked::<LCC>(buf)
}
pub const LCC_IDENTIFIER: &str = "$LCC";

#[inline]
pub fn LCC_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LCC_IDENTIFIER, false)
}

#[inline]
pub fn LCC_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LCC_IDENTIFIER, true)
}

#[inline]
pub fn finish_LCC_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<LCC<'a>>) {
  fbb.finish(root, Some(LCC_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_LCC_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<LCC<'a>>) {
  fbb.finish_size_prefixed(root, Some(LCC_IDENTIFIER));
}
