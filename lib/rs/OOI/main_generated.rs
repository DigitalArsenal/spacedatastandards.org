// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OOIOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Object of Interest
pub struct OOI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OOI<'a> {
  type Inner = OOI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OOI<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_SENSOR_TASKING_START_TIME: flatbuffers::VOffsetT = 10;
  pub const VT_SENSOR_TASKING_STOP_TIME: flatbuffers::VOffsetT = 12;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 14;
  pub const VT_STATUS: flatbuffers::VOffsetT = 16;
  pub const VT_STATUS_DATE: flatbuffers::VOffsetT = 18;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 20;
  pub const VT_LAST_OB_TIME: flatbuffers::VOffsetT = 22;
  pub const VT_MISSED_OB_TIME: flatbuffers::VOffsetT = 24;
  pub const VT_DELTA_VS: flatbuffers::VOffsetT = 26;
  pub const VT_DELTA_TS: flatbuffers::VOffsetT = 28;
  pub const VT_SV_EPOCH: flatbuffers::VOffsetT = 30;
  pub const VT_X: flatbuffers::VOffsetT = 32;
  pub const VT_Y: flatbuffers::VOffsetT = 34;
  pub const VT_Z: flatbuffers::VOffsetT = 36;
  pub const VT_XVEL: flatbuffers::VOffsetT = 38;
  pub const VT_YVEL: flatbuffers::VOffsetT = 40;
  pub const VT_ZVEL: flatbuffers::VOffsetT = 42;
  pub const VT_ELSET_EPOCH: flatbuffers::VOffsetT = 44;
  pub const VT_MEAN_MOTION: flatbuffers::VOffsetT = 46;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 48;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 50;
  pub const VT_RAAN: flatbuffers::VOffsetT = 52;
  pub const VT_ARG_OF_PERIGEE: flatbuffers::VOffsetT = 54;
  pub const VT_MEAN_ANOMALY: flatbuffers::VOffsetT = 56;
  pub const VT_REV_NO: flatbuffers::VOffsetT = 58;
  pub const VT_B_STAR: flatbuffers::VOffsetT = 60;
  pub const VT_MEAN_MOTION_DOT: flatbuffers::VOffsetT = 62;
  pub const VT_MEAN_MOTION_DDOT: flatbuffers::VOffsetT = 64;
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 66;
  pub const VT_PERIOD: flatbuffers::VOffsetT = 68;
  pub const VT_APOGEE: flatbuffers::VOffsetT = 70;
  pub const VT_PERIGEE: flatbuffers::VOffsetT = 72;
  pub const VT_AFFECTED_OBJECTS: flatbuffers::VOffsetT = 74;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 76;
  pub const VT_MANIFOLDS: flatbuffers::VOffsetT = 78;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OOI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OOIArgs<'args>
  ) -> flatbuffers::WIPOffset<OOI<'bldr>> {
    let mut builder = OOIBuilder::new(_fbb);
    builder.add_PERIGEE(args.PERIGEE);
    builder.add_APOGEE(args.APOGEE);
    builder.add_PERIOD(args.PERIOD);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    builder.add_MEAN_MOTION_DDOT(args.MEAN_MOTION_DDOT);
    builder.add_MEAN_MOTION_DOT(args.MEAN_MOTION_DOT);
    builder.add_B_STAR(args.B_STAR);
    builder.add_MEAN_ANOMALY(args.MEAN_ANOMALY);
    builder.add_ARG_OF_PERIGEE(args.ARG_OF_PERIGEE);
    builder.add_RAAN(args.RAAN);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_MEAN_MOTION(args.MEAN_MOTION);
    builder.add_ZVEL(args.ZVEL);
    builder.add_YVEL(args.YVEL);
    builder.add_XVEL(args.XVEL);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    if let Some(x) = args.MANIFOLDS { builder.add_MANIFOLDS(x); }
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.AFFECTED_OBJECTS { builder.add_AFFECTED_OBJECTS(x); }
    builder.add_REV_NO(args.REV_NO);
    if let Some(x) = args.ELSET_EPOCH { builder.add_ELSET_EPOCH(x); }
    if let Some(x) = args.SV_EPOCH { builder.add_SV_EPOCH(x); }
    if let Some(x) = args.DELTA_TS { builder.add_DELTA_TS(x); }
    if let Some(x) = args.DELTA_VS { builder.add_DELTA_VS(x); }
    if let Some(x) = args.MISSED_OB_TIME { builder.add_MISSED_OB_TIME(x); }
    if let Some(x) = args.LAST_OB_TIME { builder.add_LAST_OB_TIME(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.STATUS_DATE { builder.add_STATUS_DATE(x); }
    if let Some(x) = args.STATUS { builder.add_STATUS(x); }
    builder.add_PRIORITY(args.PRIORITY);
    if let Some(x) = args.SENSOR_TASKING_STOP_TIME { builder.add_SENSOR_TASKING_STOP_TIME(x); }
    if let Some(x) = args.SENSOR_TASKING_START_TIME { builder.add_SENSOR_TASKING_START_TIME(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OOIT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SENSOR_TASKING_START_TIME = self.SENSOR_TASKING_START_TIME().map(|x| {
      x.to_string()
    });
    let SENSOR_TASKING_STOP_TIME = self.SENSOR_TASKING_STOP_TIME().map(|x| {
      x.to_string()
    });
    let PRIORITY = self.PRIORITY();
    let STATUS = self.STATUS().map(|x| {
      x.to_string()
    });
    let STATUS_DATE = self.STATUS_DATE().map(|x| {
      x.to_string()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LAST_OB_TIME = self.LAST_OB_TIME().map(|x| {
      x.to_string()
    });
    let MISSED_OB_TIME = self.MISSED_OB_TIME().map(|x| {
      x.to_string()
    });
    let DELTA_VS = self.DELTA_VS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DELTA_TS = self.DELTA_TS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SV_EPOCH = self.SV_EPOCH().map(|x| {
      x.to_string()
    });
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let XVEL = self.XVEL();
    let YVEL = self.YVEL();
    let ZVEL = self.ZVEL();
    let ELSET_EPOCH = self.ELSET_EPOCH().map(|x| {
      x.to_string()
    });
    let MEAN_MOTION = self.MEAN_MOTION();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RAAN = self.RAAN();
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE();
    let MEAN_ANOMALY = self.MEAN_ANOMALY();
    let REV_NO = self.REV_NO();
    let B_STAR = self.B_STAR();
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT();
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT();
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let PERIOD = self.PERIOD();
    let APOGEE = self.APOGEE();
    let PERIGEE = self.PERIGEE();
    let AFFECTED_OBJECTS = self.AFFECTED_OBJECTS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    let MANIFOLDS = self.MANIFOLDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    OOIT {
      ID,
      SAT_NO,
      NAME,
      SENSOR_TASKING_START_TIME,
      SENSOR_TASKING_STOP_TIME,
      PRIORITY,
      STATUS,
      STATUS_DATE,
      DESCRIPTION,
      LAST_OB_TIME,
      MISSED_OB_TIME,
      DELTA_VS,
      DELTA_TS,
      SV_EPOCH,
      X,
      Y,
      Z,
      XVEL,
      YVEL,
      ZVEL,
      ELSET_EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      REV_NO,
      B_STAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      SEMI_MAJOR_AXIS,
      PERIOD,
      APOGEE,
      PERIGEE,
      AFFECTED_OBJECTS,
      ON_ORBIT,
      MANIFOLDS,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_ID, None)}
  }
  #[inline]
  pub fn SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OOI::VT_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_NAME, None)}
  }
  #[inline]
  pub fn SENSOR_TASKING_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_SENSOR_TASKING_START_TIME, None)}
  }
  #[inline]
  pub fn SENSOR_TASKING_STOP_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_SENSOR_TASKING_STOP_TIME, None)}
  }
  #[inline]
  pub fn PRIORITY(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OOI::VT_PRIORITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_STATUS, None)}
  }
  #[inline]
  pub fn STATUS_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_STATUS_DATE, None)}
  }
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn LAST_OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_LAST_OB_TIME, None)}
  }
  #[inline]
  pub fn MISSED_OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_MISSED_OB_TIME, None)}
  }
  #[inline]
  pub fn DELTA_VS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOI::VT_DELTA_VS, None)}
  }
  #[inline]
  pub fn DELTA_TS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOI::VT_DELTA_TS, None)}
  }
  #[inline]
  pub fn SV_EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_SV_EPOCH, None)}
  }
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn XVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_XVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn YVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_YVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ZVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_ZVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELSET_EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_ELSET_EPOCH, None)}
  }
  #[inline]
  pub fn MEAN_MOTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_MEAN_MOTION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_RAAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ARG_OF_PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_ARG_OF_PERIGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_MEAN_ANOMALY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn REV_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OOI::VT_REV_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn B_STAR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_B_STAR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_MEAN_MOTION_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_MEAN_MOTION_DDOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PERIOD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_PERIOD, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn APOGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_APOGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OOI::VT_PERIGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AFFECTED_OBJECTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOI::VT_AFFECTED_OBJECTS, None)}
  }
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OOI::VT_ON_ORBIT, None)}
  }
  #[inline]
  pub fn MANIFOLDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OOI::VT_MANIFOLDS, None)}
  }
}

impl flatbuffers::Verifiable for OOI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<i32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SENSOR_TASKING_START_TIME", Self::VT_SENSOR_TASKING_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SENSOR_TASKING_STOP_TIME", Self::VT_SENSOR_TASKING_STOP_TIME, false)?
     .visit_field::<i32>("PRIORITY", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STATUS", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STATUS_DATE", Self::VT_STATUS_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAST_OB_TIME", Self::VT_LAST_OB_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MISSED_OB_TIME", Self::VT_MISSED_OB_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DELTA_VS", Self::VT_DELTA_VS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("DELTA_TS", Self::VT_DELTA_TS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SV_EPOCH", Self::VT_SV_EPOCH, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("XVEL", Self::VT_XVEL, false)?
     .visit_field::<f64>("YVEL", Self::VT_YVEL, false)?
     .visit_field::<f64>("ZVEL", Self::VT_ZVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ELSET_EPOCH", Self::VT_ELSET_EPOCH, false)?
     .visit_field::<f64>("MEAN_MOTION", Self::VT_MEAN_MOTION, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RAAN", Self::VT_RAAN, false)?
     .visit_field::<f64>("ARG_OF_PERIGEE", Self::VT_ARG_OF_PERIGEE, false)?
     .visit_field::<f64>("MEAN_ANOMALY", Self::VT_MEAN_ANOMALY, false)?
     .visit_field::<i32>("REV_NO", Self::VT_REV_NO, false)?
     .visit_field::<f64>("B_STAR", Self::VT_B_STAR, false)?
     .visit_field::<f64>("MEAN_MOTION_DOT", Self::VT_MEAN_MOTION_DOT, false)?
     .visit_field::<f64>("MEAN_MOTION_DDOT", Self::VT_MEAN_MOTION_DDOT, false)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("PERIOD", Self::VT_PERIOD, false)?
     .visit_field::<f64>("APOGEE", Self::VT_APOGEE, false)?
     .visit_field::<f64>("PERIGEE", Self::VT_PERIGEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("AFFECTED_OBJECTS", Self::VT_AFFECTED_OBJECTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("MANIFOLDS", Self::VT_MANIFOLDS, false)?
     .finish();
    Ok(())
  }
}
pub struct OOIArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: i32,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENSOR_TASKING_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENSOR_TASKING_STOP_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PRIORITY: i32,
    pub STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STATUS_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAST_OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MISSED_OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DELTA_VS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DELTA_TS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SV_EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub XVEL: f64,
    pub YVEL: f64,
    pub ZVEL: f64,
    pub ELSET_EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEAN_MOTION: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RAAN: f64,
    pub ARG_OF_PERIGEE: f64,
    pub MEAN_ANOMALY: f64,
    pub REV_NO: i32,
    pub B_STAR: f64,
    pub MEAN_MOTION_DOT: f64,
    pub MEAN_MOTION_DDOT: f64,
    pub SEMI_MAJOR_AXIS: f64,
    pub PERIOD: f64,
    pub APOGEE: f64,
    pub PERIGEE: f64,
    pub AFFECTED_OBJECTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MANIFOLDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for OOIArgs<'a> {
  #[inline]
  fn default() -> Self {
    OOIArgs {
      ID: None,
      SAT_NO: 0,
      NAME: None,
      SENSOR_TASKING_START_TIME: None,
      SENSOR_TASKING_STOP_TIME: None,
      PRIORITY: 0,
      STATUS: None,
      STATUS_DATE: None,
      DESCRIPTION: None,
      LAST_OB_TIME: None,
      MISSED_OB_TIME: None,
      DELTA_VS: None,
      DELTA_TS: None,
      SV_EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      XVEL: 0.0,
      YVEL: 0.0,
      ZVEL: 0.0,
      ELSET_EPOCH: None,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      REV_NO: 0,
      B_STAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      PERIOD: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      AFFECTED_OBJECTS: None,
      ON_ORBIT: None,
      MANIFOLDS: None,
    }
  }
}

pub struct OOIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OOIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_ID, ID);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(OOI::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SENSOR_TASKING_START_TIME(&mut self, SENSOR_TASKING_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_SENSOR_TASKING_START_TIME, SENSOR_TASKING_START_TIME);
  }
  #[inline]
  pub fn add_SENSOR_TASKING_STOP_TIME(&mut self, SENSOR_TASKING_STOP_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_SENSOR_TASKING_STOP_TIME, SENSOR_TASKING_STOP_TIME);
  }
  #[inline]
  pub fn add_PRIORITY(&mut self, PRIORITY: i32) {
    self.fbb_.push_slot::<i32>(OOI::VT_PRIORITY, PRIORITY, 0);
  }
  #[inline]
  pub fn add_STATUS(&mut self, STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_STATUS, STATUS);
  }
  #[inline]
  pub fn add_STATUS_DATE(&mut self, STATUS_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_STATUS_DATE, STATUS_DATE);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_LAST_OB_TIME(&mut self, LAST_OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_LAST_OB_TIME, LAST_OB_TIME);
  }
  #[inline]
  pub fn add_MISSED_OB_TIME(&mut self, MISSED_OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_MISSED_OB_TIME, MISSED_OB_TIME);
  }
  #[inline]
  pub fn add_DELTA_VS(&mut self, DELTA_VS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_DELTA_VS, DELTA_VS);
  }
  #[inline]
  pub fn add_DELTA_TS(&mut self, DELTA_TS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_DELTA_TS, DELTA_TS);
  }
  #[inline]
  pub fn add_SV_EPOCH(&mut self, SV_EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_SV_EPOCH, SV_EPOCH);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_XVEL(&mut self, XVEL: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_XVEL, XVEL, 0.0);
  }
  #[inline]
  pub fn add_YVEL(&mut self, YVEL: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_YVEL, YVEL, 0.0);
  }
  #[inline]
  pub fn add_ZVEL(&mut self, ZVEL: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_ZVEL, ZVEL, 0.0);
  }
  #[inline]
  pub fn add_ELSET_EPOCH(&mut self, ELSET_EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_ELSET_EPOCH, ELSET_EPOCH);
  }
  #[inline]
  pub fn add_MEAN_MOTION(&mut self, MEAN_MOTION: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RAAN(&mut self, RAAN: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_RAAN, RAAN, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERIGEE(&mut self, ARG_OF_PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_ARG_OF_PERIGEE, ARG_OF_PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ANOMALY(&mut self, MEAN_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_REV_NO(&mut self, REV_NO: i32) {
    self.fbb_.push_slot::<i32>(OOI::VT_REV_NO, REV_NO, 0);
  }
  #[inline]
  pub fn add_B_STAR(&mut self, B_STAR: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_B_STAR, B_STAR, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DOT(&mut self, MEAN_MOTION_DOT: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_MEAN_MOTION_DOT, MEAN_MOTION_DOT, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DDOT(&mut self, MEAN_MOTION_DDOT: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_MEAN_MOTION_DDOT, MEAN_MOTION_DDOT, 0.0);
  }
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_PERIOD(&mut self, PERIOD: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_PERIOD, PERIOD, 0.0);
  }
  #[inline]
  pub fn add_APOGEE(&mut self, APOGEE: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_APOGEE, APOGEE, 0.0);
  }
  #[inline]
  pub fn add_PERIGEE(&mut self, PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(OOI::VT_PERIGEE, PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_AFFECTED_OBJECTS(&mut self, AFFECTED_OBJECTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_AFFECTED_OBJECTS, AFFECTED_OBJECTS);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn add_MANIFOLDS(&mut self, MANIFOLDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OOI::VT_MANIFOLDS, MANIFOLDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OOIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OOIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OOI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OOI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OOI");
      ds.field("ID", &self.ID());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("NAME", &self.NAME());
      ds.field("SENSOR_TASKING_START_TIME", &self.SENSOR_TASKING_START_TIME());
      ds.field("SENSOR_TASKING_STOP_TIME", &self.SENSOR_TASKING_STOP_TIME());
      ds.field("PRIORITY", &self.PRIORITY());
      ds.field("STATUS", &self.STATUS());
      ds.field("STATUS_DATE", &self.STATUS_DATE());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("LAST_OB_TIME", &self.LAST_OB_TIME());
      ds.field("MISSED_OB_TIME", &self.MISSED_OB_TIME());
      ds.field("DELTA_VS", &self.DELTA_VS());
      ds.field("DELTA_TS", &self.DELTA_TS());
      ds.field("SV_EPOCH", &self.SV_EPOCH());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("XVEL", &self.XVEL());
      ds.field("YVEL", &self.YVEL());
      ds.field("ZVEL", &self.ZVEL());
      ds.field("ELSET_EPOCH", &self.ELSET_EPOCH());
      ds.field("MEAN_MOTION", &self.MEAN_MOTION());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RAAN", &self.RAAN());
      ds.field("ARG_OF_PERIGEE", &self.ARG_OF_PERIGEE());
      ds.field("MEAN_ANOMALY", &self.MEAN_ANOMALY());
      ds.field("REV_NO", &self.REV_NO());
      ds.field("B_STAR", &self.B_STAR());
      ds.field("MEAN_MOTION_DOT", &self.MEAN_MOTION_DOT());
      ds.field("MEAN_MOTION_DDOT", &self.MEAN_MOTION_DDOT());
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("PERIOD", &self.PERIOD());
      ds.field("APOGEE", &self.APOGEE());
      ds.field("PERIGEE", &self.PERIGEE());
      ds.field("AFFECTED_OBJECTS", &self.AFFECTED_OBJECTS());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.field("MANIFOLDS", &self.MANIFOLDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OOIT {
  pub ID: Option<String>,
  pub SAT_NO: i32,
  pub NAME: Option<String>,
  pub SENSOR_TASKING_START_TIME: Option<String>,
  pub SENSOR_TASKING_STOP_TIME: Option<String>,
  pub PRIORITY: i32,
  pub STATUS: Option<String>,
  pub STATUS_DATE: Option<String>,
  pub DESCRIPTION: Option<String>,
  pub LAST_OB_TIME: Option<String>,
  pub MISSED_OB_TIME: Option<String>,
  pub DELTA_VS: Option<Vec<String>>,
  pub DELTA_TS: Option<Vec<String>>,
  pub SV_EPOCH: Option<String>,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub XVEL: f64,
  pub YVEL: f64,
  pub ZVEL: f64,
  pub ELSET_EPOCH: Option<String>,
  pub MEAN_MOTION: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RAAN: f64,
  pub ARG_OF_PERIGEE: f64,
  pub MEAN_ANOMALY: f64,
  pub REV_NO: i32,
  pub B_STAR: f64,
  pub MEAN_MOTION_DOT: f64,
  pub MEAN_MOTION_DDOT: f64,
  pub SEMI_MAJOR_AXIS: f64,
  pub PERIOD: f64,
  pub APOGEE: f64,
  pub PERIGEE: f64,
  pub AFFECTED_OBJECTS: Option<Vec<String>>,
  pub ON_ORBIT: Option<String>,
  pub MANIFOLDS: Option<Vec<String>>,
}
impl Default for OOIT {
  fn default() -> Self {
    Self {
      ID: None,
      SAT_NO: 0,
      NAME: None,
      SENSOR_TASKING_START_TIME: None,
      SENSOR_TASKING_STOP_TIME: None,
      PRIORITY: 0,
      STATUS: None,
      STATUS_DATE: None,
      DESCRIPTION: None,
      LAST_OB_TIME: None,
      MISSED_OB_TIME: None,
      DELTA_VS: None,
      DELTA_TS: None,
      SV_EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      XVEL: 0.0,
      YVEL: 0.0,
      ZVEL: 0.0,
      ELSET_EPOCH: None,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      REV_NO: 0,
      B_STAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      PERIOD: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      AFFECTED_OBJECTS: None,
      ON_ORBIT: None,
      MANIFOLDS: None,
    }
  }
}
impl OOIT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OOI<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENSOR_TASKING_START_TIME = self.SENSOR_TASKING_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENSOR_TASKING_STOP_TIME = self.SENSOR_TASKING_STOP_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PRIORITY = self.PRIORITY;
    let STATUS = self.STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STATUS_DATE = self.STATUS_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAST_OB_TIME = self.LAST_OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MISSED_OB_TIME = self.MISSED_OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DELTA_VS = self.DELTA_VS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DELTA_TS = self.DELTA_TS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SV_EPOCH = self.SV_EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let XVEL = self.XVEL;
    let YVEL = self.YVEL;
    let ZVEL = self.ZVEL;
    let ELSET_EPOCH = self.ELSET_EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEAN_MOTION = self.MEAN_MOTION;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RAAN = self.RAAN;
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE;
    let MEAN_ANOMALY = self.MEAN_ANOMALY;
    let REV_NO = self.REV_NO;
    let B_STAR = self.B_STAR;
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT;
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT;
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let PERIOD = self.PERIOD;
    let APOGEE = self.APOGEE;
    let PERIGEE = self.PERIGEE;
    let AFFECTED_OBJECTS = self.AFFECTED_OBJECTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MANIFOLDS = self.MANIFOLDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    OOI::create(_fbb, &OOIArgs{
      ID,
      SAT_NO,
      NAME,
      SENSOR_TASKING_START_TIME,
      SENSOR_TASKING_STOP_TIME,
      PRIORITY,
      STATUS,
      STATUS_DATE,
      DESCRIPTION,
      LAST_OB_TIME,
      MISSED_OB_TIME,
      DELTA_VS,
      DELTA_TS,
      SV_EPOCH,
      X,
      Y,
      Z,
      XVEL,
      YVEL,
      ZVEL,
      ELSET_EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      REV_NO,
      B_STAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      SEMI_MAJOR_AXIS,
      PERIOD,
      APOGEE,
      PERIGEE,
      AFFECTED_OBJECTS,
      ON_ORBIT,
      MANIFOLDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OOI`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOI_unchecked`.
pub fn root_as_OOI(buf: &[u8]) -> Result<OOI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OOI>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OOI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OOI_unchecked`.
pub fn size_prefixed_root_as_OOI(buf: &[u8]) -> Result<OOI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OOI>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OOI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOI_unchecked`.
pub fn root_as_OOI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OOI<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OOI` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OOI_unchecked`.
pub fn size_prefixed_root_as_OOI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OOI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OOI<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OOI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OOI`.
pub unsafe fn root_as_OOI_unchecked(buf: &[u8]) -> OOI {
  flatbuffers::root_unchecked::<OOI>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OOI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OOI`.
pub unsafe fn size_prefixed_root_as_OOI_unchecked(buf: &[u8]) -> OOI {
  flatbuffers::size_prefixed_root_unchecked::<OOI>(buf)
}
pub const OOI_IDENTIFIER: &str = "$OOI";

#[inline]
pub fn OOI_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOI_IDENTIFIER, false)
}

#[inline]
pub fn OOI_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OOI_IDENTIFIER, true)
}

#[inline]
pub fn finish_OOI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OOI<'a>>) {
  fbb.finish(root, Some(OOI_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OOI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OOI<'a>>) {
  fbb.finish_size_prefixed(root, Some(OOI_IDENTIFIER));
}
