// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IMAGE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IMAGE_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IMAGE_TYPE: [imageType; 6] = [
  imageType::VISIBLE,
  imageType::INFRARED,
  imageType::MULTISPECTRAL,
  imageType::HYPERSPECTRAL,
  imageType::UV,
  imageType::BROADBAND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct imageType(pub i8);
#[allow(non_upper_case_globals)]
impl imageType {
  pub const VISIBLE: Self = Self(0);
  pub const INFRARED: Self = Self(1);
  pub const MULTISPECTRAL: Self = Self(2);
  pub const HYPERSPECTRAL: Self = Self(3);
  pub const UV: Self = Self(4);
  pub const BROADBAND: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::VISIBLE,
    Self::INFRARED,
    Self::MULTISPECTRAL,
    Self::HYPERSPECTRAL,
    Self::UV,
    Self::BROADBAND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::VISIBLE => Some("VISIBLE"),
      Self::INFRARED => Some("INFRARED"),
      Self::MULTISPECTRAL => Some("MULTISPECTRAL"),
      Self::HYPERSPECTRAL => Some("HYPERSPECTRAL"),
      Self::UV => Some("UV"),
      Self::BROADBAND => Some("BROADBAND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for imageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for imageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for imageType {
    type Output = imageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for imageType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for imageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for imageType {}
pub enum SKIOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sky Imagery
pub struct SKI<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SKI<'a> {
  type Inner = SKI<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SKI<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 6;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 10;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 12;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 14;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 16;
  pub const VT_SENLON: flatbuffers::VOffsetT = 18;
  pub const VT_SENALT: flatbuffers::VOffsetT = 20;
  pub const VT_SENX: flatbuffers::VOffsetT = 22;
  pub const VT_SENY: flatbuffers::VOffsetT = 24;
  pub const VT_SENZ: flatbuffers::VOffsetT = 26;
  pub const VT_SEN_QUAT: flatbuffers::VOffsetT = 28;
  pub const VT_SEN_QUAT_DOT: flatbuffers::VOffsetT = 30;
  pub const VT_IMAGE_TYPE: flatbuffers::VOffsetT = 32;
  pub const VT_EXP_START_TIME: flatbuffers::VOffsetT = 34;
  pub const VT_EXP_END_TIME: flatbuffers::VOffsetT = 36;
  pub const VT_IMAGE_SOURCE_INFO: flatbuffers::VOffsetT = 38;
  pub const VT_TOP_LEFT_START_AZ: flatbuffers::VOffsetT = 40;
  pub const VT_TOP_LEFT_START_EL: flatbuffers::VOffsetT = 42;
  pub const VT_TOP_LEFT_STOP_AZ: flatbuffers::VOffsetT = 44;
  pub const VT_TOP_LEFT_STOP_EL: flatbuffers::VOffsetT = 46;
  pub const VT_IMAGE_SET_ID: flatbuffers::VOffsetT = 48;
  pub const VT_IMAGE_SET_LENGTH: flatbuffers::VOffsetT = 50;
  pub const VT_SEQUENCE_ID: flatbuffers::VOffsetT = 52;
  pub const VT_FRAME_FOVWIDTH: flatbuffers::VOffsetT = 54;
  pub const VT_FRAME_FOVHEIGHT: flatbuffers::VOffsetT = 56;
  pub const VT_PIXEL_FOVWIDTH: flatbuffers::VOffsetT = 58;
  pub const VT_PIXEL_FOVHEIGHT: flatbuffers::VOffsetT = 60;
  pub const VT_FRAME_WIDTH_PIXELS: flatbuffers::VOffsetT = 62;
  pub const VT_FRAME_HEIGHT_PIXELS: flatbuffers::VOffsetT = 64;
  pub const VT_PIXEL_BIT_DEPTH: flatbuffers::VOffsetT = 66;
  pub const VT_ANNOTATION_KEY: flatbuffers::VOffsetT = 68;
  pub const VT_CALIBRATION_KEY: flatbuffers::VOffsetT = 70;
  pub const VT_FILENAME: flatbuffers::VOffsetT = 72;
  pub const VT_FILESIZE: flatbuffers::VOffsetT = 74;
  pub const VT_CHECKSUM_VALUE: flatbuffers::VOffsetT = 76;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 78;
  pub const VT_TAGS: flatbuffers::VOffsetT = 80;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 82;
  pub const VT_EO_OBSERVATIONS: flatbuffers::VOffsetT = 84;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SKI { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SKIArgs<'args>
  ) -> flatbuffers::WIPOffset<SKI<'bldr>> {
    let mut builder = SKIBuilder::new(_fbb);
    builder.add_FILESIZE(args.FILESIZE);
    builder.add_PIXEL_FOVHEIGHT(args.PIXEL_FOVHEIGHT);
    builder.add_PIXEL_FOVWIDTH(args.PIXEL_FOVWIDTH);
    builder.add_FRAME_FOVHEIGHT(args.FRAME_FOVHEIGHT);
    builder.add_FRAME_FOVWIDTH(args.FRAME_FOVWIDTH);
    builder.add_TOP_LEFT_STOP_EL(args.TOP_LEFT_STOP_EL);
    builder.add_TOP_LEFT_STOP_AZ(args.TOP_LEFT_STOP_AZ);
    builder.add_TOP_LEFT_START_EL(args.TOP_LEFT_START_EL);
    builder.add_TOP_LEFT_START_AZ(args.TOP_LEFT_START_AZ);
    builder.add_SENZ(args.SENZ);
    builder.add_SENY(args.SENY);
    builder.add_SENX(args.SENX);
    builder.add_SENALT(args.SENALT);
    builder.add_SENLON(args.SENLON);
    builder.add_SENLAT(args.SENLAT);
    if let Some(x) = args.EO_OBSERVATIONS { builder.add_EO_OBSERVATIONS(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.CHECKSUM_VALUE { builder.add_CHECKSUM_VALUE(x); }
    if let Some(x) = args.FILENAME { builder.add_FILENAME(x); }
    if let Some(x) = args.CALIBRATION_KEY { builder.add_CALIBRATION_KEY(x); }
    if let Some(x) = args.ANNOTATION_KEY { builder.add_ANNOTATION_KEY(x); }
    if let Some(x) = args.IMAGE_SET_ID { builder.add_IMAGE_SET_ID(x); }
    if let Some(x) = args.IMAGE_SOURCE_INFO { builder.add_IMAGE_SOURCE_INFO(x); }
    if let Some(x) = args.EXP_END_TIME { builder.add_EXP_END_TIME(x); }
    if let Some(x) = args.EXP_START_TIME { builder.add_EXP_START_TIME(x); }
    if let Some(x) = args.SEN_QUAT_DOT { builder.add_SEN_QUAT_DOT(x); }
    if let Some(x) = args.SEN_QUAT { builder.add_SEN_QUAT(x); }
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_FRAME_HEIGHT_PIXELS(args.FRAME_HEIGHT_PIXELS);
    builder.add_FRAME_WIDTH_PIXELS(args.FRAME_WIDTH_PIXELS);
    builder.add_SEQUENCE_ID(args.SEQUENCE_ID);
    builder.add_IMAGE_SET_LENGTH(args.IMAGE_SET_LENGTH);
    builder.add_PIXEL_BIT_DEPTH(args.PIXEL_BIT_DEPTH);
    builder.add_IMAGE_TYPE(args.IMAGE_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> SKIT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let SENLAT = self.SENLAT();
    let SENLON = self.SENLON();
    let SENALT = self.SENALT();
    let SENX = self.SENX();
    let SENY = self.SENY();
    let SENZ = self.SENZ();
    let SEN_QUAT = self.SEN_QUAT().map(|x| {
      x.into_iter().collect()
    });
    let SEN_QUAT_DOT = self.SEN_QUAT_DOT().map(|x| {
      x.into_iter().collect()
    });
    let IMAGE_TYPE = self.IMAGE_TYPE();
    let EXP_START_TIME = self.EXP_START_TIME().map(|x| {
      x.to_string()
    });
    let EXP_END_TIME = self.EXP_END_TIME().map(|x| {
      x.to_string()
    });
    let IMAGE_SOURCE_INFO = self.IMAGE_SOURCE_INFO().map(|x| {
      x.to_string()
    });
    let TOP_LEFT_START_AZ = self.TOP_LEFT_START_AZ();
    let TOP_LEFT_START_EL = self.TOP_LEFT_START_EL();
    let TOP_LEFT_STOP_AZ = self.TOP_LEFT_STOP_AZ();
    let TOP_LEFT_STOP_EL = self.TOP_LEFT_STOP_EL();
    let IMAGE_SET_ID = self.IMAGE_SET_ID().map(|x| {
      x.to_string()
    });
    let IMAGE_SET_LENGTH = self.IMAGE_SET_LENGTH();
    let SEQUENCE_ID = self.SEQUENCE_ID();
    let FRAME_FOVWIDTH = self.FRAME_FOVWIDTH();
    let FRAME_FOVHEIGHT = self.FRAME_FOVHEIGHT();
    let PIXEL_FOVWIDTH = self.PIXEL_FOVWIDTH();
    let PIXEL_FOVHEIGHT = self.PIXEL_FOVHEIGHT();
    let FRAME_WIDTH_PIXELS = self.FRAME_WIDTH_PIXELS();
    let FRAME_HEIGHT_PIXELS = self.FRAME_HEIGHT_PIXELS();
    let PIXEL_BIT_DEPTH = self.PIXEL_BIT_DEPTH();
    let ANNOTATION_KEY = self.ANNOTATION_KEY().map(|x| {
      x.to_string()
    });
    let CALIBRATION_KEY = self.CALIBRATION_KEY().map(|x| {
      x.to_string()
    });
    let FILENAME = self.FILENAME().map(|x| {
      x.to_string()
    });
    let FILESIZE = self.FILESIZE();
    let CHECKSUM_VALUE = self.CHECKSUM_VALUE().map(|x| {
      x.to_string()
    });
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let EO_OBSERVATIONS = self.EO_OBSERVATIONS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    SKIT {
      ID,
      ON_ORBIT,
      ORIG_OBJECT_ID,
      SAT_NO,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      SEN_QUAT,
      SEN_QUAT_DOT,
      IMAGE_TYPE,
      EXP_START_TIME,
      EXP_END_TIME,
      IMAGE_SOURCE_INFO,
      TOP_LEFT_START_AZ,
      TOP_LEFT_START_EL,
      TOP_LEFT_STOP_AZ,
      TOP_LEFT_STOP_EL,
      IMAGE_SET_ID,
      IMAGE_SET_LENGTH,
      SEQUENCE_ID,
      FRAME_FOVWIDTH,
      FRAME_FOVHEIGHT,
      PIXEL_FOVWIDTH,
      PIXEL_FOVHEIGHT,
      FRAME_WIDTH_PIXELS,
      FRAME_HEIGHT_PIXELS,
      PIXEL_BIT_DEPTH,
      ANNOTATION_KEY,
      CALIBRATION_KEY,
      FILENAME,
      FILESIZE,
      CHECKSUM_VALUE,
      TRANSACTION_ID,
      TAGS,
      DESCRIPTION,
      EO_OBSERVATIONS,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ID, None)}
  }
  /// On-orbit reference
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ON_ORBIT, None)}
  }
  /// International designator
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ORIG_OBJECT_ID, None)}
  }
  /// Satellite catalog number
  #[inline]
  pub fn SAT_NO(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SKI::VT_SAT_NO, Some(0)).unwrap()}
  }
  /// Sensor identifier
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ID_SENSOR, None)}
  }
  /// Original sensor identifier
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ORIG_SENSOR_ID, None)}
  }
  /// Sensor geodetic latitude (degrees)
  #[inline]
  pub fn SENLAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor geodetic longitude (degrees)
  #[inline]
  pub fn SENLON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude (km)
  #[inline]
  pub fn SENALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// Sensor ECEF X position (km)
  #[inline]
  pub fn SENX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENX, Some(0.0)).unwrap()}
  }
  /// Sensor ECEF Y position (km)
  #[inline]
  pub fn SENY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENY, Some(0.0)).unwrap()}
  }
  /// Sensor ECEF Z position (km)
  #[inline]
  pub fn SENZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_SENZ, Some(0.0)).unwrap()}
  }
  /// Sensor quaternion (scalar-last: q1, q2, q3, q0)
  #[inline]
  pub fn SEN_QUAT(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(SKI::VT_SEN_QUAT, None)}
  }
  /// Sensor quaternion rate
  #[inline]
  pub fn SEN_QUAT_DOT(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(SKI::VT_SEN_QUAT_DOT, None)}
  }
  /// Image type
  #[inline]
  pub fn IMAGE_TYPE(&self) -> imageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<imageType>(SKI::VT_IMAGE_TYPE, Some(imageType::VISIBLE)).unwrap()}
  }
  /// Exposure start time (ISO 8601)
  #[inline]
  pub fn EXP_START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_EXP_START_TIME, None)}
  }
  /// Exposure end time (ISO 8601)
  #[inline]
  pub fn EXP_END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_EXP_END_TIME, None)}
  }
  /// Image source information
  #[inline]
  pub fn IMAGE_SOURCE_INFO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_IMAGE_SOURCE_INFO, None)}
  }
  /// Top-left corner start azimuth (degrees)
  #[inline]
  pub fn TOP_LEFT_START_AZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_TOP_LEFT_START_AZ, Some(0.0)).unwrap()}
  }
  /// Top-left corner start elevation (degrees)
  #[inline]
  pub fn TOP_LEFT_START_EL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_TOP_LEFT_START_EL, Some(0.0)).unwrap()}
  }
  /// Top-left corner stop azimuth (degrees)
  #[inline]
  pub fn TOP_LEFT_STOP_AZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_TOP_LEFT_STOP_AZ, Some(0.0)).unwrap()}
  }
  /// Top-left corner stop elevation (degrees)
  #[inline]
  pub fn TOP_LEFT_STOP_EL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_TOP_LEFT_STOP_EL, Some(0.0)).unwrap()}
  }
  /// Image set identifier
  #[inline]
  pub fn IMAGE_SET_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_IMAGE_SET_ID, None)}
  }
  /// Number of images in set
  #[inline]
  pub fn IMAGE_SET_LENGTH(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SKI::VT_IMAGE_SET_LENGTH, Some(0)).unwrap()}
  }
  /// Sequence number within set
  #[inline]
  pub fn SEQUENCE_ID(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SKI::VT_SEQUENCE_ID, Some(0)).unwrap()}
  }
  /// Frame field-of-view width (degrees)
  #[inline]
  pub fn FRAME_FOVWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_FRAME_FOVWIDTH, Some(0.0)).unwrap()}
  }
  /// Frame field-of-view height (degrees)
  #[inline]
  pub fn FRAME_FOVHEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_FRAME_FOVHEIGHT, Some(0.0)).unwrap()}
  }
  /// Pixel field-of-view width (arcseconds)
  #[inline]
  pub fn PIXEL_FOVWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_PIXEL_FOVWIDTH, Some(0.0)).unwrap()}
  }
  /// Pixel field-of-view height (arcseconds)
  #[inline]
  pub fn PIXEL_FOVHEIGHT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SKI::VT_PIXEL_FOVHEIGHT, Some(0.0)).unwrap()}
  }
  /// Frame width (pixels)
  #[inline]
  pub fn FRAME_WIDTH_PIXELS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SKI::VT_FRAME_WIDTH_PIXELS, Some(0)).unwrap()}
  }
  /// Frame height (pixels)
  #[inline]
  pub fn FRAME_HEIGHT_PIXELS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SKI::VT_FRAME_HEIGHT_PIXELS, Some(0)).unwrap()}
  }
  /// Pixel bit depth
  #[inline]
  pub fn PIXEL_BIT_DEPTH(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SKI::VT_PIXEL_BIT_DEPTH, Some(0)).unwrap()}
  }
  /// Annotation key reference
  #[inline]
  pub fn ANNOTATION_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_ANNOTATION_KEY, None)}
  }
  /// Calibration key reference
  #[inline]
  pub fn CALIBRATION_KEY(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_CALIBRATION_KEY, None)}
  }
  /// Image filename
  #[inline]
  pub fn FILENAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_FILENAME, None)}
  }
  /// File size (bytes)
  #[inline]
  pub fn FILESIZE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SKI::VT_FILESIZE, Some(0)).unwrap()}
  }
  /// File checksum value
  #[inline]
  pub fn CHECKSUM_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_CHECKSUM_VALUE, None)}
  }
  /// Transaction identifier
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_TRANSACTION_ID, None)}
  }
  /// Associated tags
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SKI::VT_TAGS, None)}
  }
  /// Description
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SKI::VT_DESCRIPTION, None)}
  }
  /// Associated EO observation references
  #[inline]
  pub fn EO_OBSERVATIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SKI::VT_EO_OBSERVATIONS, None)}
  }
}

impl flatbuffers::Verifiable for SKI<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<u32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<f64>("SENLAT", Self::VT_SENLAT, false)?
     .visit_field::<f64>("SENLON", Self::VT_SENLON, false)?
     .visit_field::<f64>("SENALT", Self::VT_SENALT, false)?
     .visit_field::<f64>("SENX", Self::VT_SENX, false)?
     .visit_field::<f64>("SENY", Self::VT_SENY, false)?
     .visit_field::<f64>("SENZ", Self::VT_SENZ, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("SEN_QUAT", Self::VT_SEN_QUAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("SEN_QUAT_DOT", Self::VT_SEN_QUAT_DOT, false)?
     .visit_field::<imageType>("IMAGE_TYPE", Self::VT_IMAGE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXP_START_TIME", Self::VT_EXP_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXP_END_TIME", Self::VT_EXP_END_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMAGE_SOURCE_INFO", Self::VT_IMAGE_SOURCE_INFO, false)?
     .visit_field::<f64>("TOP_LEFT_START_AZ", Self::VT_TOP_LEFT_START_AZ, false)?
     .visit_field::<f64>("TOP_LEFT_START_EL", Self::VT_TOP_LEFT_START_EL, false)?
     .visit_field::<f64>("TOP_LEFT_STOP_AZ", Self::VT_TOP_LEFT_STOP_AZ, false)?
     .visit_field::<f64>("TOP_LEFT_STOP_EL", Self::VT_TOP_LEFT_STOP_EL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IMAGE_SET_ID", Self::VT_IMAGE_SET_ID, false)?
     .visit_field::<u16>("IMAGE_SET_LENGTH", Self::VT_IMAGE_SET_LENGTH, false)?
     .visit_field::<u16>("SEQUENCE_ID", Self::VT_SEQUENCE_ID, false)?
     .visit_field::<f64>("FRAME_FOVWIDTH", Self::VT_FRAME_FOVWIDTH, false)?
     .visit_field::<f64>("FRAME_FOVHEIGHT", Self::VT_FRAME_FOVHEIGHT, false)?
     .visit_field::<f64>("PIXEL_FOVWIDTH", Self::VT_PIXEL_FOVWIDTH, false)?
     .visit_field::<f64>("PIXEL_FOVHEIGHT", Self::VT_PIXEL_FOVHEIGHT, false)?
     .visit_field::<u16>("FRAME_WIDTH_PIXELS", Self::VT_FRAME_WIDTH_PIXELS, false)?
     .visit_field::<u16>("FRAME_HEIGHT_PIXELS", Self::VT_FRAME_HEIGHT_PIXELS, false)?
     .visit_field::<u8>("PIXEL_BIT_DEPTH", Self::VT_PIXEL_BIT_DEPTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ANNOTATION_KEY", Self::VT_ANNOTATION_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CALIBRATION_KEY", Self::VT_CALIBRATION_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FILENAME", Self::VT_FILENAME, false)?
     .visit_field::<i64>("FILESIZE", Self::VT_FILESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CHECKSUM_VALUE", Self::VT_CHECKSUM_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("EO_OBSERVATIONS", Self::VT_EO_OBSERVATIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct SKIArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: u32,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SENLAT: f64,
    pub SENLON: f64,
    pub SENALT: f64,
    pub SENX: f64,
    pub SENY: f64,
    pub SENZ: f64,
    pub SEN_QUAT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub SEN_QUAT_DOT: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub IMAGE_TYPE: imageType,
    pub EXP_START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EXP_END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMAGE_SOURCE_INFO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TOP_LEFT_START_AZ: f64,
    pub TOP_LEFT_START_EL: f64,
    pub TOP_LEFT_STOP_AZ: f64,
    pub TOP_LEFT_STOP_EL: f64,
    pub IMAGE_SET_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMAGE_SET_LENGTH: u16,
    pub SEQUENCE_ID: u16,
    pub FRAME_FOVWIDTH: f64,
    pub FRAME_FOVHEIGHT: f64,
    pub PIXEL_FOVWIDTH: f64,
    pub PIXEL_FOVHEIGHT: f64,
    pub FRAME_WIDTH_PIXELS: u16,
    pub FRAME_HEIGHT_PIXELS: u16,
    pub PIXEL_BIT_DEPTH: u8,
    pub ANNOTATION_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CALIBRATION_KEY: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FILENAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FILESIZE: i64,
    pub CHECKSUM_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EO_OBSERVATIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SKIArgs<'a> {
  #[inline]
  fn default() -> Self {
    SKIArgs {
      ID: None,
      ON_ORBIT: None,
      ORIG_OBJECT_ID: None,
      SAT_NO: 0,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      SEN_QUAT: None,
      SEN_QUAT_DOT: None,
      IMAGE_TYPE: imageType::VISIBLE,
      EXP_START_TIME: None,
      EXP_END_TIME: None,
      IMAGE_SOURCE_INFO: None,
      TOP_LEFT_START_AZ: 0.0,
      TOP_LEFT_START_EL: 0.0,
      TOP_LEFT_STOP_AZ: 0.0,
      TOP_LEFT_STOP_EL: 0.0,
      IMAGE_SET_ID: None,
      IMAGE_SET_LENGTH: 0,
      SEQUENCE_ID: 0,
      FRAME_FOVWIDTH: 0.0,
      FRAME_FOVHEIGHT: 0.0,
      PIXEL_FOVWIDTH: 0.0,
      PIXEL_FOVHEIGHT: 0.0,
      FRAME_WIDTH_PIXELS: 0,
      FRAME_HEIGHT_PIXELS: 0,
      PIXEL_BIT_DEPTH: 0,
      ANNOTATION_KEY: None,
      CALIBRATION_KEY: None,
      FILENAME: None,
      FILESIZE: 0,
      CHECKSUM_VALUE: None,
      TRANSACTION_ID: None,
      TAGS: None,
      DESCRIPTION: None,
      EO_OBSERVATIONS: None,
    }
  }
}

pub struct SKIBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SKIBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ID, ID);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: u32) {
    self.fbb_.push_slot::<u32>(SKI::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_SENLAT(&mut self, SENLAT: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENLAT, SENLAT, 0.0);
  }
  #[inline]
  pub fn add_SENLON(&mut self, SENLON: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENLON, SENLON, 0.0);
  }
  #[inline]
  pub fn add_SENALT(&mut self, SENALT: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENALT, SENALT, 0.0);
  }
  #[inline]
  pub fn add_SENX(&mut self, SENX: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENX, SENX, 0.0);
  }
  #[inline]
  pub fn add_SENY(&mut self, SENY: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENY, SENY, 0.0);
  }
  #[inline]
  pub fn add_SENZ(&mut self, SENZ: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_SENZ, SENZ, 0.0);
  }
  #[inline]
  pub fn add_SEN_QUAT(&mut self, SEN_QUAT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_SEN_QUAT, SEN_QUAT);
  }
  #[inline]
  pub fn add_SEN_QUAT_DOT(&mut self, SEN_QUAT_DOT: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_SEN_QUAT_DOT, SEN_QUAT_DOT);
  }
  #[inline]
  pub fn add_IMAGE_TYPE(&mut self, IMAGE_TYPE: imageType) {
    self.fbb_.push_slot::<imageType>(SKI::VT_IMAGE_TYPE, IMAGE_TYPE, imageType::VISIBLE);
  }
  #[inline]
  pub fn add_EXP_START_TIME(&mut self, EXP_START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_EXP_START_TIME, EXP_START_TIME);
  }
  #[inline]
  pub fn add_EXP_END_TIME(&mut self, EXP_END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_EXP_END_TIME, EXP_END_TIME);
  }
  #[inline]
  pub fn add_IMAGE_SOURCE_INFO(&mut self, IMAGE_SOURCE_INFO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_IMAGE_SOURCE_INFO, IMAGE_SOURCE_INFO);
  }
  #[inline]
  pub fn add_TOP_LEFT_START_AZ(&mut self, TOP_LEFT_START_AZ: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_TOP_LEFT_START_AZ, TOP_LEFT_START_AZ, 0.0);
  }
  #[inline]
  pub fn add_TOP_LEFT_START_EL(&mut self, TOP_LEFT_START_EL: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_TOP_LEFT_START_EL, TOP_LEFT_START_EL, 0.0);
  }
  #[inline]
  pub fn add_TOP_LEFT_STOP_AZ(&mut self, TOP_LEFT_STOP_AZ: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_TOP_LEFT_STOP_AZ, TOP_LEFT_STOP_AZ, 0.0);
  }
  #[inline]
  pub fn add_TOP_LEFT_STOP_EL(&mut self, TOP_LEFT_STOP_EL: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_TOP_LEFT_STOP_EL, TOP_LEFT_STOP_EL, 0.0);
  }
  #[inline]
  pub fn add_IMAGE_SET_ID(&mut self, IMAGE_SET_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_IMAGE_SET_ID, IMAGE_SET_ID);
  }
  #[inline]
  pub fn add_IMAGE_SET_LENGTH(&mut self, IMAGE_SET_LENGTH: u16) {
    self.fbb_.push_slot::<u16>(SKI::VT_IMAGE_SET_LENGTH, IMAGE_SET_LENGTH, 0);
  }
  #[inline]
  pub fn add_SEQUENCE_ID(&mut self, SEQUENCE_ID: u16) {
    self.fbb_.push_slot::<u16>(SKI::VT_SEQUENCE_ID, SEQUENCE_ID, 0);
  }
  #[inline]
  pub fn add_FRAME_FOVWIDTH(&mut self, FRAME_FOVWIDTH: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_FRAME_FOVWIDTH, FRAME_FOVWIDTH, 0.0);
  }
  #[inline]
  pub fn add_FRAME_FOVHEIGHT(&mut self, FRAME_FOVHEIGHT: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_FRAME_FOVHEIGHT, FRAME_FOVHEIGHT, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_FOVWIDTH(&mut self, PIXEL_FOVWIDTH: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_PIXEL_FOVWIDTH, PIXEL_FOVWIDTH, 0.0);
  }
  #[inline]
  pub fn add_PIXEL_FOVHEIGHT(&mut self, PIXEL_FOVHEIGHT: f64) {
    self.fbb_.push_slot::<f64>(SKI::VT_PIXEL_FOVHEIGHT, PIXEL_FOVHEIGHT, 0.0);
  }
  #[inline]
  pub fn add_FRAME_WIDTH_PIXELS(&mut self, FRAME_WIDTH_PIXELS: u16) {
    self.fbb_.push_slot::<u16>(SKI::VT_FRAME_WIDTH_PIXELS, FRAME_WIDTH_PIXELS, 0);
  }
  #[inline]
  pub fn add_FRAME_HEIGHT_PIXELS(&mut self, FRAME_HEIGHT_PIXELS: u16) {
    self.fbb_.push_slot::<u16>(SKI::VT_FRAME_HEIGHT_PIXELS, FRAME_HEIGHT_PIXELS, 0);
  }
  #[inline]
  pub fn add_PIXEL_BIT_DEPTH(&mut self, PIXEL_BIT_DEPTH: u8) {
    self.fbb_.push_slot::<u8>(SKI::VT_PIXEL_BIT_DEPTH, PIXEL_BIT_DEPTH, 0);
  }
  #[inline]
  pub fn add_ANNOTATION_KEY(&mut self, ANNOTATION_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_ANNOTATION_KEY, ANNOTATION_KEY);
  }
  #[inline]
  pub fn add_CALIBRATION_KEY(&mut self, CALIBRATION_KEY: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_CALIBRATION_KEY, CALIBRATION_KEY);
  }
  #[inline]
  pub fn add_FILENAME(&mut self, FILENAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_FILENAME, FILENAME);
  }
  #[inline]
  pub fn add_FILESIZE(&mut self, FILESIZE: i64) {
    self.fbb_.push_slot::<i64>(SKI::VT_FILESIZE, FILESIZE, 0);
  }
  #[inline]
  pub fn add_CHECKSUM_VALUE(&mut self, CHECKSUM_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_CHECKSUM_VALUE, CHECKSUM_VALUE);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_EO_OBSERVATIONS(&mut self, EO_OBSERVATIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SKI::VT_EO_OBSERVATIONS, EO_OBSERVATIONS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SKIBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SKIBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SKI<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SKI<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SKI");
      ds.field("ID", &self.ID());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("SENLAT", &self.SENLAT());
      ds.field("SENLON", &self.SENLON());
      ds.field("SENALT", &self.SENALT());
      ds.field("SENX", &self.SENX());
      ds.field("SENY", &self.SENY());
      ds.field("SENZ", &self.SENZ());
      ds.field("SEN_QUAT", &self.SEN_QUAT());
      ds.field("SEN_QUAT_DOT", &self.SEN_QUAT_DOT());
      ds.field("IMAGE_TYPE", &self.IMAGE_TYPE());
      ds.field("EXP_START_TIME", &self.EXP_START_TIME());
      ds.field("EXP_END_TIME", &self.EXP_END_TIME());
      ds.field("IMAGE_SOURCE_INFO", &self.IMAGE_SOURCE_INFO());
      ds.field("TOP_LEFT_START_AZ", &self.TOP_LEFT_START_AZ());
      ds.field("TOP_LEFT_START_EL", &self.TOP_LEFT_START_EL());
      ds.field("TOP_LEFT_STOP_AZ", &self.TOP_LEFT_STOP_AZ());
      ds.field("TOP_LEFT_STOP_EL", &self.TOP_LEFT_STOP_EL());
      ds.field("IMAGE_SET_ID", &self.IMAGE_SET_ID());
      ds.field("IMAGE_SET_LENGTH", &self.IMAGE_SET_LENGTH());
      ds.field("SEQUENCE_ID", &self.SEQUENCE_ID());
      ds.field("FRAME_FOVWIDTH", &self.FRAME_FOVWIDTH());
      ds.field("FRAME_FOVHEIGHT", &self.FRAME_FOVHEIGHT());
      ds.field("PIXEL_FOVWIDTH", &self.PIXEL_FOVWIDTH());
      ds.field("PIXEL_FOVHEIGHT", &self.PIXEL_FOVHEIGHT());
      ds.field("FRAME_WIDTH_PIXELS", &self.FRAME_WIDTH_PIXELS());
      ds.field("FRAME_HEIGHT_PIXELS", &self.FRAME_HEIGHT_PIXELS());
      ds.field("PIXEL_BIT_DEPTH", &self.PIXEL_BIT_DEPTH());
      ds.field("ANNOTATION_KEY", &self.ANNOTATION_KEY());
      ds.field("CALIBRATION_KEY", &self.CALIBRATION_KEY());
      ds.field("FILENAME", &self.FILENAME());
      ds.field("FILESIZE", &self.FILESIZE());
      ds.field("CHECKSUM_VALUE", &self.CHECKSUM_VALUE());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("TAGS", &self.TAGS());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("EO_OBSERVATIONS", &self.EO_OBSERVATIONS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SKIT {
  pub ID: Option<String>,
  pub ON_ORBIT: Option<String>,
  pub ORIG_OBJECT_ID: Option<String>,
  pub SAT_NO: u32,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub SENLAT: f64,
  pub SENLON: f64,
  pub SENALT: f64,
  pub SENX: f64,
  pub SENY: f64,
  pub SENZ: f64,
  pub SEN_QUAT: Option<Vec<f64>>,
  pub SEN_QUAT_DOT: Option<Vec<f64>>,
  pub IMAGE_TYPE: imageType,
  pub EXP_START_TIME: Option<String>,
  pub EXP_END_TIME: Option<String>,
  pub IMAGE_SOURCE_INFO: Option<String>,
  pub TOP_LEFT_START_AZ: f64,
  pub TOP_LEFT_START_EL: f64,
  pub TOP_LEFT_STOP_AZ: f64,
  pub TOP_LEFT_STOP_EL: f64,
  pub IMAGE_SET_ID: Option<String>,
  pub IMAGE_SET_LENGTH: u16,
  pub SEQUENCE_ID: u16,
  pub FRAME_FOVWIDTH: f64,
  pub FRAME_FOVHEIGHT: f64,
  pub PIXEL_FOVWIDTH: f64,
  pub PIXEL_FOVHEIGHT: f64,
  pub FRAME_WIDTH_PIXELS: u16,
  pub FRAME_HEIGHT_PIXELS: u16,
  pub PIXEL_BIT_DEPTH: u8,
  pub ANNOTATION_KEY: Option<String>,
  pub CALIBRATION_KEY: Option<String>,
  pub FILENAME: Option<String>,
  pub FILESIZE: i64,
  pub CHECKSUM_VALUE: Option<String>,
  pub TRANSACTION_ID: Option<String>,
  pub TAGS: Option<Vec<String>>,
  pub DESCRIPTION: Option<String>,
  pub EO_OBSERVATIONS: Option<Vec<String>>,
}
impl Default for SKIT {
  fn default() -> Self {
    Self {
      ID: None,
      ON_ORBIT: None,
      ORIG_OBJECT_ID: None,
      SAT_NO: 0,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      SENX: 0.0,
      SENY: 0.0,
      SENZ: 0.0,
      SEN_QUAT: None,
      SEN_QUAT_DOT: None,
      IMAGE_TYPE: imageType::VISIBLE,
      EXP_START_TIME: None,
      EXP_END_TIME: None,
      IMAGE_SOURCE_INFO: None,
      TOP_LEFT_START_AZ: 0.0,
      TOP_LEFT_START_EL: 0.0,
      TOP_LEFT_STOP_AZ: 0.0,
      TOP_LEFT_STOP_EL: 0.0,
      IMAGE_SET_ID: None,
      IMAGE_SET_LENGTH: 0,
      SEQUENCE_ID: 0,
      FRAME_FOVWIDTH: 0.0,
      FRAME_FOVHEIGHT: 0.0,
      PIXEL_FOVWIDTH: 0.0,
      PIXEL_FOVHEIGHT: 0.0,
      FRAME_WIDTH_PIXELS: 0,
      FRAME_HEIGHT_PIXELS: 0,
      PIXEL_BIT_DEPTH: 0,
      ANNOTATION_KEY: None,
      CALIBRATION_KEY: None,
      FILENAME: None,
      FILESIZE: 0,
      CHECKSUM_VALUE: None,
      TRANSACTION_ID: None,
      TAGS: None,
      DESCRIPTION: None,
      EO_OBSERVATIONS: None,
    }
  }
}
impl SKIT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SKI<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SENLAT = self.SENLAT;
    let SENLON = self.SENLON;
    let SENALT = self.SENALT;
    let SENX = self.SENX;
    let SENY = self.SENY;
    let SENZ = self.SENZ;
    let SEN_QUAT = self.SEN_QUAT.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let SEN_QUAT_DOT = self.SEN_QUAT_DOT.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let IMAGE_TYPE = self.IMAGE_TYPE;
    let EXP_START_TIME = self.EXP_START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EXP_END_TIME = self.EXP_END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMAGE_SOURCE_INFO = self.IMAGE_SOURCE_INFO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TOP_LEFT_START_AZ = self.TOP_LEFT_START_AZ;
    let TOP_LEFT_START_EL = self.TOP_LEFT_START_EL;
    let TOP_LEFT_STOP_AZ = self.TOP_LEFT_STOP_AZ;
    let TOP_LEFT_STOP_EL = self.TOP_LEFT_STOP_EL;
    let IMAGE_SET_ID = self.IMAGE_SET_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMAGE_SET_LENGTH = self.IMAGE_SET_LENGTH;
    let SEQUENCE_ID = self.SEQUENCE_ID;
    let FRAME_FOVWIDTH = self.FRAME_FOVWIDTH;
    let FRAME_FOVHEIGHT = self.FRAME_FOVHEIGHT;
    let PIXEL_FOVWIDTH = self.PIXEL_FOVWIDTH;
    let PIXEL_FOVHEIGHT = self.PIXEL_FOVHEIGHT;
    let FRAME_WIDTH_PIXELS = self.FRAME_WIDTH_PIXELS;
    let FRAME_HEIGHT_PIXELS = self.FRAME_HEIGHT_PIXELS;
    let PIXEL_BIT_DEPTH = self.PIXEL_BIT_DEPTH;
    let ANNOTATION_KEY = self.ANNOTATION_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CALIBRATION_KEY = self.CALIBRATION_KEY.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FILENAME = self.FILENAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FILESIZE = self.FILESIZE;
    let CHECKSUM_VALUE = self.CHECKSUM_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EO_OBSERVATIONS = self.EO_OBSERVATIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    SKI::create(_fbb, &SKIArgs{
      ID,
      ON_ORBIT,
      ORIG_OBJECT_ID,
      SAT_NO,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      SENLAT,
      SENLON,
      SENALT,
      SENX,
      SENY,
      SENZ,
      SEN_QUAT,
      SEN_QUAT_DOT,
      IMAGE_TYPE,
      EXP_START_TIME,
      EXP_END_TIME,
      IMAGE_SOURCE_INFO,
      TOP_LEFT_START_AZ,
      TOP_LEFT_START_EL,
      TOP_LEFT_STOP_AZ,
      TOP_LEFT_STOP_EL,
      IMAGE_SET_ID,
      IMAGE_SET_LENGTH,
      SEQUENCE_ID,
      FRAME_FOVWIDTH,
      FRAME_FOVHEIGHT,
      PIXEL_FOVWIDTH,
      PIXEL_FOVHEIGHT,
      FRAME_WIDTH_PIXELS,
      FRAME_HEIGHT_PIXELS,
      PIXEL_BIT_DEPTH,
      ANNOTATION_KEY,
      CALIBRATION_KEY,
      FILENAME,
      FILESIZE,
      CHECKSUM_VALUE,
      TRANSACTION_ID,
      TAGS,
      DESCRIPTION,
      EO_OBSERVATIONS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SKI`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SKI_unchecked`.
pub fn root_as_SKI(buf: &[u8]) -> Result<SKI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SKI>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SKI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_SKI_unchecked`.
pub fn size_prefixed_root_as_SKI(buf: &[u8]) -> Result<SKI, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SKI>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SKI` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SKI_unchecked`.
pub fn root_as_SKI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SKI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SKI<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SKI` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_SKI_unchecked`.
pub fn size_prefixed_root_as_SKI_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SKI<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SKI<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SKI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SKI`.
pub unsafe fn root_as_SKI_unchecked(buf: &[u8]) -> SKI {
  flatbuffers::root_unchecked::<SKI>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SKI and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SKI`.
pub unsafe fn size_prefixed_root_as_SKI_unchecked(buf: &[u8]) -> SKI {
  flatbuffers::size_prefixed_root_unchecked::<SKI>(buf)
}
pub const SKI_IDENTIFIER: &str = "$SKI";

#[inline]
pub fn SKI_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SKI_IDENTIFIER, false)
}

#[inline]
pub fn SKI_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, SKI_IDENTIFIER, true)
}

#[inline]
pub fn finish_SKI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<SKI<'a>>) {
  fbb.finish(root, Some(SKI_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_SKI_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<SKI<'a>>) {
  fbb.finish_size_prefixed(root, Some(SKI_IDENTIFIER));
}
