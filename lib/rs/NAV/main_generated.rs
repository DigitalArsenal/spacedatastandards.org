// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VESSEL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VESSEL_TYPE: i8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VESSEL_TYPE: [VesselType; 16] = [
  VesselType::CARRIER,
  VesselType::BATTLESHIP,
  VesselType::CRUISER,
  VesselType::DESTROYER,
  VesselType::FRIGATE,
  VesselType::CORVETTE,
  VesselType::PATROL,
  VesselType::SUBMARINE_SSN,
  VesselType::SUBMARINE_SSBN,
  VesselType::SUBMARINE_SSK,
  VesselType::AMPHIBIOUS,
  VesselType::CARGO,
  VesselType::TANKER,
  VesselType::AUXILIARY,
  VesselType::FAST_ATTACK,
  VesselType::TORPEDO_BOAT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VesselType(pub i8);
#[allow(non_upper_case_globals)]
impl VesselType {
  pub const CARRIER: Self = Self(0);
  pub const BATTLESHIP: Self = Self(1);
  pub const CRUISER: Self = Self(2);
  pub const DESTROYER: Self = Self(3);
  pub const FRIGATE: Self = Self(4);
  pub const CORVETTE: Self = Self(5);
  pub const PATROL: Self = Self(6);
  pub const SUBMARINE_SSN: Self = Self(7);
  pub const SUBMARINE_SSBN: Self = Self(8);
  pub const SUBMARINE_SSK: Self = Self(9);
  pub const AMPHIBIOUS: Self = Self(10);
  pub const CARGO: Self = Self(11);
  pub const TANKER: Self = Self(12);
  pub const AUXILIARY: Self = Self(13);
  pub const FAST_ATTACK: Self = Self(14);
  pub const TORPEDO_BOAT: Self = Self(15);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CARRIER,
    Self::BATTLESHIP,
    Self::CRUISER,
    Self::DESTROYER,
    Self::FRIGATE,
    Self::CORVETTE,
    Self::PATROL,
    Self::SUBMARINE_SSN,
    Self::SUBMARINE_SSBN,
    Self::SUBMARINE_SSK,
    Self::AMPHIBIOUS,
    Self::CARGO,
    Self::TANKER,
    Self::AUXILIARY,
    Self::FAST_ATTACK,
    Self::TORPEDO_BOAT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CARRIER => Some("CARRIER"),
      Self::BATTLESHIP => Some("BATTLESHIP"),
      Self::CRUISER => Some("CRUISER"),
      Self::DESTROYER => Some("DESTROYER"),
      Self::FRIGATE => Some("FRIGATE"),
      Self::CORVETTE => Some("CORVETTE"),
      Self::PATROL => Some("PATROL"),
      Self::SUBMARINE_SSN => Some("SUBMARINE_SSN"),
      Self::SUBMARINE_SSBN => Some("SUBMARINE_SSBN"),
      Self::SUBMARINE_SSK => Some("SUBMARINE_SSK"),
      Self::AMPHIBIOUS => Some("AMPHIBIOUS"),
      Self::CARGO => Some("CARGO"),
      Self::TANKER => Some("TANKER"),
      Self::AUXILIARY => Some("AUXILIARY"),
      Self::FAST_ATTACK => Some("FAST_ATTACK"),
      Self::TORPEDO_BOAT => Some("TORPEDO_BOAT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VesselType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VesselType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VesselType {
    type Output = VesselType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VesselType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VesselType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VesselType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROPULSION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROPULSION_TYPE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROPULSION_TYPE: [PropulsionType; 9] = [
  PropulsionType::STEAM,
  PropulsionType::GAS_TURBINE,
  PropulsionType::DIESEL,
  PropulsionType::DIESEL_ELECTRIC,
  PropulsionType::NUCLEAR,
  PropulsionType::CODAG,
  PropulsionType::COGAG,
  PropulsionType::CODLAG,
  PropulsionType::AIP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PropulsionType(pub i8);
#[allow(non_upper_case_globals)]
impl PropulsionType {
  pub const STEAM: Self = Self(0);
  pub const GAS_TURBINE: Self = Self(1);
  pub const DIESEL: Self = Self(2);
  pub const DIESEL_ELECTRIC: Self = Self(3);
  pub const NUCLEAR: Self = Self(4);
  pub const CODAG: Self = Self(5);
  pub const COGAG: Self = Self(6);
  pub const CODLAG: Self = Self(7);
  pub const AIP: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STEAM,
    Self::GAS_TURBINE,
    Self::DIESEL,
    Self::DIESEL_ELECTRIC,
    Self::NUCLEAR,
    Self::CODAG,
    Self::COGAG,
    Self::CODLAG,
    Self::AIP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STEAM => Some("STEAM"),
      Self::GAS_TURBINE => Some("GAS_TURBINE"),
      Self::DIESEL => Some("DIESEL"),
      Self::DIESEL_ELECTRIC => Some("DIESEL_ELECTRIC"),
      Self::NUCLEAR => Some("NUCLEAR"),
      Self::CODAG => Some("CODAG"),
      Self::COGAG => Some("COGAG"),
      Self::CODLAG => Some("CODLAG"),
      Self::AIP => Some("AIP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PropulsionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PropulsionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PropulsionType {
    type Output = PropulsionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PropulsionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PropulsionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PropulsionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DCSTATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DCSTATE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DCSTATE: [DCState; 7] = [
  DCState::NORMAL,
  DCState::MINOR_DAMAGE,
  DCState::MODERATE_DAMAGE,
  DCState::SEVERE_DAMAGE,
  DCState::CRITICAL,
  DCState::SINKING,
  DCState::ABANDONED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DCState(pub i8);
#[allow(non_upper_case_globals)]
impl DCState {
  pub const NORMAL: Self = Self(0);
  pub const MINOR_DAMAGE: Self = Self(1);
  pub const MODERATE_DAMAGE: Self = Self(2);
  pub const SEVERE_DAMAGE: Self = Self(3);
  pub const CRITICAL: Self = Self(4);
  pub const SINKING: Self = Self(5);
  pub const ABANDONED: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::MINOR_DAMAGE,
    Self::MODERATE_DAMAGE,
    Self::SEVERE_DAMAGE,
    Self::CRITICAL,
    Self::SINKING,
    Self::ABANDONED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::MINOR_DAMAGE => Some("MINOR_DAMAGE"),
      Self::MODERATE_DAMAGE => Some("MODERATE_DAMAGE"),
      Self::SEVERE_DAMAGE => Some("SEVERE_DAMAGE"),
      Self::CRITICAL => Some("CRITICAL"),
      Self::SINKING => Some("SINKING"),
      Self::ABANDONED => Some("ABANDONED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DCState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DCState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DCState {
    type Output = DCState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DCState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DCState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DCState {}
pub enum NAVOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Naval Vessels
pub struct NAV<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NAV<'a> {
  type Inner = NAV<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NAV<'a> {
  pub const VT_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_ATTITUDE_X: flatbuffers::VOffsetT = 16;
  pub const VT_ATTITUDE_Y: flatbuffers::VOffsetT = 18;
  pub const VT_ATTITUDE_Z: flatbuffers::VOffsetT = 20;
  pub const VT_ATTITUDE_W: flatbuffers::VOffsetT = 22;
  pub const VT_OMEGA_X: flatbuffers::VOffsetT = 24;
  pub const VT_OMEGA_Y: flatbuffers::VOffsetT = 26;
  pub const VT_OMEGA_Z: flatbuffers::VOffsetT = 28;
  pub const VT_SPEED_KNOTS: flatbuffers::VOffsetT = 30;
  pub const VT_HEADING: flatbuffers::VOffsetT = 32;
  pub const VT_COURSE: flatbuffers::VOffsetT = 34;
  pub const VT_RUDDER_ANGLE: flatbuffers::VOffsetT = 36;
  pub const VT_HULL: flatbuffers::VOffsetT = 38;
  pub const VT_PROPULSION: flatbuffers::VOffsetT = 40;
  pub const VT_DC_STATE: flatbuffers::VOffsetT = 42;
  pub const VT_FIRES_ACTIVE: flatbuffers::VOffsetT = 44;
  pub const VT_FLOODING_ACTIVE: flatbuffers::VOffsetT = 46;
  pub const VT_CREW_CASUALTIES: flatbuffers::VOffsetT = 48;
  pub const VT_HULL_INTEGRITY: flatbuffers::VOffsetT = 50;
  pub const VT_POWER_AVAILABLE: flatbuffers::VOffsetT = 52;
  pub const VT_WEAPONS_ONLINE: flatbuffers::VOffsetT = 54;
  pub const VT_SENSORS_ONLINE: flatbuffers::VOffsetT = 56;
  pub const VT_RESERVED1: flatbuffers::VOffsetT = 58;
  pub const VT_FUEL_REMAINING: flatbuffers::VOffsetT = 60;
  pub const VT_AMMO_MAIN: flatbuffers::VOffsetT = 62;
  pub const VT_MISSILES_REMAINING: flatbuffers::VOffsetT = 64;
  pub const VT_TORPEDOES_REMAINING: flatbuffers::VOffsetT = 66;
  pub const VT_VESSEL_TYPE: flatbuffers::VOffsetT = 68;
  pub const VT_PROPULSION_TYPE: flatbuffers::VOffsetT = 70;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 72;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NAV { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NAVArgs<'args>
  ) -> flatbuffers::WIPOffset<NAV<'bldr>> {
    let mut builder = NAVBuilder::new(_fbb);
    builder.add_OMEGA_Z(args.OMEGA_Z);
    builder.add_OMEGA_Y(args.OMEGA_Y);
    builder.add_OMEGA_X(args.OMEGA_X);
    builder.add_ATTITUDE_W(args.ATTITUDE_W);
    builder.add_ATTITUDE_Z(args.ATTITUDE_Z);
    builder.add_ATTITUDE_Y(args.ATTITUDE_Y);
    builder.add_ATTITUDE_X(args.ATTITUDE_X);
    builder.add_VELOCITY_Z(args.VELOCITY_Z);
    builder.add_VELOCITY_Y(args.VELOCITY_Y);
    builder.add_VELOCITY_X(args.VELOCITY_X);
    builder.add_POSITION_Z(args.POSITION_Z);
    builder.add_POSITION_Y(args.POSITION_Y);
    builder.add_POSITION_X(args.POSITION_X);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_FUEL_REMAINING(args.FUEL_REMAINING);
    builder.add_POWER_AVAILABLE(args.POWER_AVAILABLE);
    builder.add_HULL_INTEGRITY(args.HULL_INTEGRITY);
    if let Some(x) = args.PROPULSION { builder.add_PROPULSION(x); }
    if let Some(x) = args.HULL { builder.add_HULL(x); }
    builder.add_RUDDER_ANGLE(args.RUDDER_ANGLE);
    builder.add_COURSE(args.COURSE);
    builder.add_HEADING(args.HEADING);
    builder.add_SPEED_KNOTS(args.SPEED_KNOTS);
    builder.add_AMMO_MAIN(args.AMMO_MAIN);
    builder.add_RESERVED1(args.RESERVED1);
    builder.add_PROPULSION_TYPE(args.PROPULSION_TYPE);
    builder.add_VESSEL_TYPE(args.VESSEL_TYPE);
    builder.add_TORPEDOES_REMAINING(args.TORPEDOES_REMAINING);
    builder.add_MISSILES_REMAINING(args.MISSILES_REMAINING);
    builder.add_SENSORS_ONLINE(args.SENSORS_ONLINE);
    builder.add_WEAPONS_ONLINE(args.WEAPONS_ONLINE);
    builder.add_CREW_CASUALTIES(args.CREW_CASUALTIES);
    builder.add_FLOODING_ACTIVE(args.FLOODING_ACTIVE);
    builder.add_FIRES_ACTIVE(args.FIRES_ACTIVE);
    builder.add_DC_STATE(args.DC_STATE);
    builder.finish()
  }

  pub fn unpack(&self) -> NAVT {
    let POSITION_X = self.POSITION_X();
    let POSITION_Y = self.POSITION_Y();
    let POSITION_Z = self.POSITION_Z();
    let VELOCITY_X = self.VELOCITY_X();
    let VELOCITY_Y = self.VELOCITY_Y();
    let VELOCITY_Z = self.VELOCITY_Z();
    let ATTITUDE_X = self.ATTITUDE_X();
    let ATTITUDE_Y = self.ATTITUDE_Y();
    let ATTITUDE_Z = self.ATTITUDE_Z();
    let ATTITUDE_W = self.ATTITUDE_W();
    let OMEGA_X = self.OMEGA_X();
    let OMEGA_Y = self.OMEGA_Y();
    let OMEGA_Z = self.OMEGA_Z();
    let SPEED_KNOTS = self.SPEED_KNOTS();
    let HEADING = self.HEADING();
    let COURSE = self.COURSE();
    let RUDDER_ANGLE = self.RUDDER_ANGLE();
    let HULL = self.HULL().map(|x| {
      x.to_string()
    });
    let PROPULSION = self.PROPULSION().map(|x| {
      x.to_string()
    });
    let DC_STATE = self.DC_STATE();
    let FIRES_ACTIVE = self.FIRES_ACTIVE();
    let FLOODING_ACTIVE = self.FLOODING_ACTIVE();
    let CREW_CASUALTIES = self.CREW_CASUALTIES();
    let HULL_INTEGRITY = self.HULL_INTEGRITY();
    let POWER_AVAILABLE = self.POWER_AVAILABLE();
    let WEAPONS_ONLINE = self.WEAPONS_ONLINE();
    let SENSORS_ONLINE = self.SENSORS_ONLINE();
    let RESERVED1 = self.RESERVED1();
    let FUEL_REMAINING = self.FUEL_REMAINING();
    let AMMO_MAIN = self.AMMO_MAIN();
    let MISSILES_REMAINING = self.MISSILES_REMAINING();
    let TORPEDOES_REMAINING = self.TORPEDOES_REMAINING();
    let VESSEL_TYPE = self.VESSEL_TYPE();
    let PROPULSION_TYPE = self.PROPULSION_TYPE();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    NAVT {
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED_KNOTS,
      HEADING,
      COURSE,
      RUDDER_ANGLE,
      HULL,
      PROPULSION,
      DC_STATE,
      FIRES_ACTIVE,
      FLOODING_ACTIVE,
      CREW_CASUALTIES,
      HULL_INTEGRITY,
      POWER_AVAILABLE,
      WEAPONS_ONLINE,
      SENSORS_ONLINE,
      RESERVED1,
      FUEL_REMAINING,
      AMMO_MAIN,
      MISSILES_REMAINING,
      TORPEDOES_REMAINING,
      VESSEL_TYPE,
      PROPULSION_TYPE,
      RESERVED,
    }
  }

  #[inline]
  pub fn POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_ATTITUDE_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_ATTITUDE_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_ATTITUDE_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_W(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_ATTITUDE_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_OMEGA_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_OMEGA_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(NAV::VT_OMEGA_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SPEED_KNOTS(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_SPEED_KNOTS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HEADING(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_HEADING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn COURSE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_COURSE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RUDDER_ANGLE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_RUDDER_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HULL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NAV::VT_HULL, None)}
  }
  #[inline]
  pub fn PROPULSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NAV::VT_PROPULSION, None)}
  }
  #[inline]
  pub fn DC_STATE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_DC_STATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FIRES_ACTIVE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_FIRES_ACTIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FLOODING_ACTIVE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_FLOODING_ACTIVE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CREW_CASUALTIES(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_CREW_CASUALTIES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn HULL_INTEGRITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_HULL_INTEGRITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POWER_AVAILABLE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_POWER_AVAILABLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn WEAPONS_ONLINE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_WEAPONS_ONLINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SENSORS_ONLINE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_SENSORS_ONLINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED1(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NAV::VT_RESERVED1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FUEL_REMAINING(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(NAV::VT_FUEL_REMAINING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AMMO_MAIN(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(NAV::VT_AMMO_MAIN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MISSILES_REMAINING(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_MISSILES_REMAINING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn TORPEDOES_REMAINING(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_TORPEDOES_REMAINING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn VESSEL_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_VESSEL_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn PROPULSION_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(NAV::VT_PROPULSION_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(NAV::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for NAV<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("POSITION_X", Self::VT_POSITION_X, false)?
     .visit_field::<f64>("POSITION_Y", Self::VT_POSITION_Y, false)?
     .visit_field::<f64>("POSITION_Z", Self::VT_POSITION_Z, false)?
     .visit_field::<f64>("VELOCITY_X", Self::VT_VELOCITY_X, false)?
     .visit_field::<f64>("VELOCITY_Y", Self::VT_VELOCITY_Y, false)?
     .visit_field::<f64>("VELOCITY_Z", Self::VT_VELOCITY_Z, false)?
     .visit_field::<f64>("ATTITUDE_X", Self::VT_ATTITUDE_X, false)?
     .visit_field::<f64>("ATTITUDE_Y", Self::VT_ATTITUDE_Y, false)?
     .visit_field::<f64>("ATTITUDE_Z", Self::VT_ATTITUDE_Z, false)?
     .visit_field::<f64>("ATTITUDE_W", Self::VT_ATTITUDE_W, false)?
     .visit_field::<f64>("OMEGA_X", Self::VT_OMEGA_X, false)?
     .visit_field::<f64>("OMEGA_Y", Self::VT_OMEGA_Y, false)?
     .visit_field::<f64>("OMEGA_Z", Self::VT_OMEGA_Z, false)?
     .visit_field::<f32>("SPEED_KNOTS", Self::VT_SPEED_KNOTS, false)?
     .visit_field::<f32>("HEADING", Self::VT_HEADING, false)?
     .visit_field::<f32>("COURSE", Self::VT_COURSE, false)?
     .visit_field::<f32>("RUDDER_ANGLE", Self::VT_RUDDER_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("HULL", Self::VT_HULL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROPULSION", Self::VT_PROPULSION, false)?
     .visit_field::<u8>("DC_STATE", Self::VT_DC_STATE, false)?
     .visit_field::<u8>("FIRES_ACTIVE", Self::VT_FIRES_ACTIVE, false)?
     .visit_field::<u8>("FLOODING_ACTIVE", Self::VT_FLOODING_ACTIVE, false)?
     .visit_field::<u8>("CREW_CASUALTIES", Self::VT_CREW_CASUALTIES, false)?
     .visit_field::<f32>("HULL_INTEGRITY", Self::VT_HULL_INTEGRITY, false)?
     .visit_field::<f32>("POWER_AVAILABLE", Self::VT_POWER_AVAILABLE, false)?
     .visit_field::<u8>("WEAPONS_ONLINE", Self::VT_WEAPONS_ONLINE, false)?
     .visit_field::<u8>("SENSORS_ONLINE", Self::VT_SENSORS_ONLINE, false)?
     .visit_field::<u16>("RESERVED1", Self::VT_RESERVED1, false)?
     .visit_field::<f32>("FUEL_REMAINING", Self::VT_FUEL_REMAINING, false)?
     .visit_field::<u16>("AMMO_MAIN", Self::VT_AMMO_MAIN, false)?
     .visit_field::<u8>("MISSILES_REMAINING", Self::VT_MISSILES_REMAINING, false)?
     .visit_field::<u8>("TORPEDOES_REMAINING", Self::VT_TORPEDOES_REMAINING, false)?
     .visit_field::<u8>("VESSEL_TYPE", Self::VT_VESSEL_TYPE, false)?
     .visit_field::<u8>("PROPULSION_TYPE", Self::VT_PROPULSION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct NAVArgs<'a> {
    pub POSITION_X: f64,
    pub POSITION_Y: f64,
    pub POSITION_Z: f64,
    pub VELOCITY_X: f64,
    pub VELOCITY_Y: f64,
    pub VELOCITY_Z: f64,
    pub ATTITUDE_X: f64,
    pub ATTITUDE_Y: f64,
    pub ATTITUDE_Z: f64,
    pub ATTITUDE_W: f64,
    pub OMEGA_X: f64,
    pub OMEGA_Y: f64,
    pub OMEGA_Z: f64,
    pub SPEED_KNOTS: f32,
    pub HEADING: f32,
    pub COURSE: f32,
    pub RUDDER_ANGLE: f32,
    pub HULL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROPULSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DC_STATE: u8,
    pub FIRES_ACTIVE: u8,
    pub FLOODING_ACTIVE: u8,
    pub CREW_CASUALTIES: u8,
    pub HULL_INTEGRITY: f32,
    pub POWER_AVAILABLE: f32,
    pub WEAPONS_ONLINE: u8,
    pub SENSORS_ONLINE: u8,
    pub RESERVED1: u16,
    pub FUEL_REMAINING: f32,
    pub AMMO_MAIN: u16,
    pub MISSILES_REMAINING: u8,
    pub TORPEDOES_REMAINING: u8,
    pub VESSEL_TYPE: u8,
    pub PROPULSION_TYPE: u8,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for NAVArgs<'a> {
  #[inline]
  fn default() -> Self {
    NAVArgs {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      SPEED_KNOTS: 0.0,
      HEADING: 0.0,
      COURSE: 0.0,
      RUDDER_ANGLE: 0.0,
      HULL: None,
      PROPULSION: None,
      DC_STATE: 0,
      FIRES_ACTIVE: 0,
      FLOODING_ACTIVE: 0,
      CREW_CASUALTIES: 0,
      HULL_INTEGRITY: 0.0,
      POWER_AVAILABLE: 0.0,
      WEAPONS_ONLINE: 0,
      SENSORS_ONLINE: 0,
      RESERVED1: 0,
      FUEL_REMAINING: 0.0,
      AMMO_MAIN: 0,
      MISSILES_REMAINING: 0,
      TORPEDOES_REMAINING: 0,
      VESSEL_TYPE: 0,
      PROPULSION_TYPE: 0,
      RESERVED: None,
    }
  }
}

pub struct NAVBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NAVBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITION_X(&mut self, POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_POSITION_X, POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Y(&mut self, POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Z(&mut self, POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_X(&mut self, VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Y(&mut self, VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Z(&mut self, VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_X(&mut self, ATTITUDE_X: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Y(&mut self, ATTITUDE_Y: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Z(&mut self, ATTITUDE_Z: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_W(&mut self, ATTITUDE_W: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_X(&mut self, OMEGA_X: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Y(&mut self, OMEGA_Y: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Z(&mut self, OMEGA_Z: f64) {
    self.fbb_.push_slot::<f64>(NAV::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  #[inline]
  pub fn add_SPEED_KNOTS(&mut self, SPEED_KNOTS: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_SPEED_KNOTS, SPEED_KNOTS, 0.0);
  }
  #[inline]
  pub fn add_HEADING(&mut self, HEADING: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_HEADING, HEADING, 0.0);
  }
  #[inline]
  pub fn add_COURSE(&mut self, COURSE: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_COURSE, COURSE, 0.0);
  }
  #[inline]
  pub fn add_RUDDER_ANGLE(&mut self, RUDDER_ANGLE: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_RUDDER_ANGLE, RUDDER_ANGLE, 0.0);
  }
  #[inline]
  pub fn add_HULL(&mut self, HULL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NAV::VT_HULL, HULL);
  }
  #[inline]
  pub fn add_PROPULSION(&mut self, PROPULSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NAV::VT_PROPULSION, PROPULSION);
  }
  #[inline]
  pub fn add_DC_STATE(&mut self, DC_STATE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_DC_STATE, DC_STATE, 0);
  }
  #[inline]
  pub fn add_FIRES_ACTIVE(&mut self, FIRES_ACTIVE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_FIRES_ACTIVE, FIRES_ACTIVE, 0);
  }
  #[inline]
  pub fn add_FLOODING_ACTIVE(&mut self, FLOODING_ACTIVE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_FLOODING_ACTIVE, FLOODING_ACTIVE, 0);
  }
  #[inline]
  pub fn add_CREW_CASUALTIES(&mut self, CREW_CASUALTIES: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_CREW_CASUALTIES, CREW_CASUALTIES, 0);
  }
  #[inline]
  pub fn add_HULL_INTEGRITY(&mut self, HULL_INTEGRITY: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_HULL_INTEGRITY, HULL_INTEGRITY, 0.0);
  }
  #[inline]
  pub fn add_POWER_AVAILABLE(&mut self, POWER_AVAILABLE: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_POWER_AVAILABLE, POWER_AVAILABLE, 0.0);
  }
  #[inline]
  pub fn add_WEAPONS_ONLINE(&mut self, WEAPONS_ONLINE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_WEAPONS_ONLINE, WEAPONS_ONLINE, 0);
  }
  #[inline]
  pub fn add_SENSORS_ONLINE(&mut self, SENSORS_ONLINE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_SENSORS_ONLINE, SENSORS_ONLINE, 0);
  }
  #[inline]
  pub fn add_RESERVED1(&mut self, RESERVED1: u16) {
    self.fbb_.push_slot::<u16>(NAV::VT_RESERVED1, RESERVED1, 0);
  }
  #[inline]
  pub fn add_FUEL_REMAINING(&mut self, FUEL_REMAINING: f32) {
    self.fbb_.push_slot::<f32>(NAV::VT_FUEL_REMAINING, FUEL_REMAINING, 0.0);
  }
  #[inline]
  pub fn add_AMMO_MAIN(&mut self, AMMO_MAIN: u16) {
    self.fbb_.push_slot::<u16>(NAV::VT_AMMO_MAIN, AMMO_MAIN, 0);
  }
  #[inline]
  pub fn add_MISSILES_REMAINING(&mut self, MISSILES_REMAINING: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_MISSILES_REMAINING, MISSILES_REMAINING, 0);
  }
  #[inline]
  pub fn add_TORPEDOES_REMAINING(&mut self, TORPEDOES_REMAINING: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_TORPEDOES_REMAINING, TORPEDOES_REMAINING, 0);
  }
  #[inline]
  pub fn add_VESSEL_TYPE(&mut self, VESSEL_TYPE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_VESSEL_TYPE, VESSEL_TYPE, 0);
  }
  #[inline]
  pub fn add_PROPULSION_TYPE(&mut self, PROPULSION_TYPE: u8) {
    self.fbb_.push_slot::<u8>(NAV::VT_PROPULSION_TYPE, PROPULSION_TYPE, 0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NAV::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NAVBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NAVBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NAV<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NAV<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NAV");
      ds.field("POSITION_X", &self.POSITION_X());
      ds.field("POSITION_Y", &self.POSITION_Y());
      ds.field("POSITION_Z", &self.POSITION_Z());
      ds.field("VELOCITY_X", &self.VELOCITY_X());
      ds.field("VELOCITY_Y", &self.VELOCITY_Y());
      ds.field("VELOCITY_Z", &self.VELOCITY_Z());
      ds.field("ATTITUDE_X", &self.ATTITUDE_X());
      ds.field("ATTITUDE_Y", &self.ATTITUDE_Y());
      ds.field("ATTITUDE_Z", &self.ATTITUDE_Z());
      ds.field("ATTITUDE_W", &self.ATTITUDE_W());
      ds.field("OMEGA_X", &self.OMEGA_X());
      ds.field("OMEGA_Y", &self.OMEGA_Y());
      ds.field("OMEGA_Z", &self.OMEGA_Z());
      ds.field("SPEED_KNOTS", &self.SPEED_KNOTS());
      ds.field("HEADING", &self.HEADING());
      ds.field("COURSE", &self.COURSE());
      ds.field("RUDDER_ANGLE", &self.RUDDER_ANGLE());
      ds.field("HULL", &self.HULL());
      ds.field("PROPULSION", &self.PROPULSION());
      ds.field("DC_STATE", &self.DC_STATE());
      ds.field("FIRES_ACTIVE", &self.FIRES_ACTIVE());
      ds.field("FLOODING_ACTIVE", &self.FLOODING_ACTIVE());
      ds.field("CREW_CASUALTIES", &self.CREW_CASUALTIES());
      ds.field("HULL_INTEGRITY", &self.HULL_INTEGRITY());
      ds.field("POWER_AVAILABLE", &self.POWER_AVAILABLE());
      ds.field("WEAPONS_ONLINE", &self.WEAPONS_ONLINE());
      ds.field("SENSORS_ONLINE", &self.SENSORS_ONLINE());
      ds.field("RESERVED1", &self.RESERVED1());
      ds.field("FUEL_REMAINING", &self.FUEL_REMAINING());
      ds.field("AMMO_MAIN", &self.AMMO_MAIN());
      ds.field("MISSILES_REMAINING", &self.MISSILES_REMAINING());
      ds.field("TORPEDOES_REMAINING", &self.TORPEDOES_REMAINING());
      ds.field("VESSEL_TYPE", &self.VESSEL_TYPE());
      ds.field("PROPULSION_TYPE", &self.PROPULSION_TYPE());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NAVT {
  pub POSITION_X: f64,
  pub POSITION_Y: f64,
  pub POSITION_Z: f64,
  pub VELOCITY_X: f64,
  pub VELOCITY_Y: f64,
  pub VELOCITY_Z: f64,
  pub ATTITUDE_X: f64,
  pub ATTITUDE_Y: f64,
  pub ATTITUDE_Z: f64,
  pub ATTITUDE_W: f64,
  pub OMEGA_X: f64,
  pub OMEGA_Y: f64,
  pub OMEGA_Z: f64,
  pub SPEED_KNOTS: f32,
  pub HEADING: f32,
  pub COURSE: f32,
  pub RUDDER_ANGLE: f32,
  pub HULL: Option<String>,
  pub PROPULSION: Option<String>,
  pub DC_STATE: u8,
  pub FIRES_ACTIVE: u8,
  pub FLOODING_ACTIVE: u8,
  pub CREW_CASUALTIES: u8,
  pub HULL_INTEGRITY: f32,
  pub POWER_AVAILABLE: f32,
  pub WEAPONS_ONLINE: u8,
  pub SENSORS_ONLINE: u8,
  pub RESERVED1: u16,
  pub FUEL_REMAINING: f32,
  pub AMMO_MAIN: u16,
  pub MISSILES_REMAINING: u8,
  pub TORPEDOES_REMAINING: u8,
  pub VESSEL_TYPE: u8,
  pub PROPULSION_TYPE: u8,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for NAVT {
  fn default() -> Self {
    Self {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      SPEED_KNOTS: 0.0,
      HEADING: 0.0,
      COURSE: 0.0,
      RUDDER_ANGLE: 0.0,
      HULL: None,
      PROPULSION: None,
      DC_STATE: 0,
      FIRES_ACTIVE: 0,
      FLOODING_ACTIVE: 0,
      CREW_CASUALTIES: 0,
      HULL_INTEGRITY: 0.0,
      POWER_AVAILABLE: 0.0,
      WEAPONS_ONLINE: 0,
      SENSORS_ONLINE: 0,
      RESERVED1: 0,
      FUEL_REMAINING: 0.0,
      AMMO_MAIN: 0,
      MISSILES_REMAINING: 0,
      TORPEDOES_REMAINING: 0,
      VESSEL_TYPE: 0,
      PROPULSION_TYPE: 0,
      RESERVED: None,
    }
  }
}
impl NAVT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<NAV<'b>> {
    let POSITION_X = self.POSITION_X;
    let POSITION_Y = self.POSITION_Y;
    let POSITION_Z = self.POSITION_Z;
    let VELOCITY_X = self.VELOCITY_X;
    let VELOCITY_Y = self.VELOCITY_Y;
    let VELOCITY_Z = self.VELOCITY_Z;
    let ATTITUDE_X = self.ATTITUDE_X;
    let ATTITUDE_Y = self.ATTITUDE_Y;
    let ATTITUDE_Z = self.ATTITUDE_Z;
    let ATTITUDE_W = self.ATTITUDE_W;
    let OMEGA_X = self.OMEGA_X;
    let OMEGA_Y = self.OMEGA_Y;
    let OMEGA_Z = self.OMEGA_Z;
    let SPEED_KNOTS = self.SPEED_KNOTS;
    let HEADING = self.HEADING;
    let COURSE = self.COURSE;
    let RUDDER_ANGLE = self.RUDDER_ANGLE;
    let HULL = self.HULL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROPULSION = self.PROPULSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DC_STATE = self.DC_STATE;
    let FIRES_ACTIVE = self.FIRES_ACTIVE;
    let FLOODING_ACTIVE = self.FLOODING_ACTIVE;
    let CREW_CASUALTIES = self.CREW_CASUALTIES;
    let HULL_INTEGRITY = self.HULL_INTEGRITY;
    let POWER_AVAILABLE = self.POWER_AVAILABLE;
    let WEAPONS_ONLINE = self.WEAPONS_ONLINE;
    let SENSORS_ONLINE = self.SENSORS_ONLINE;
    let RESERVED1 = self.RESERVED1;
    let FUEL_REMAINING = self.FUEL_REMAINING;
    let AMMO_MAIN = self.AMMO_MAIN;
    let MISSILES_REMAINING = self.MISSILES_REMAINING;
    let TORPEDOES_REMAINING = self.TORPEDOES_REMAINING;
    let VESSEL_TYPE = self.VESSEL_TYPE;
    let PROPULSION_TYPE = self.PROPULSION_TYPE;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    NAV::create(_fbb, &NAVArgs{
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED_KNOTS,
      HEADING,
      COURSE,
      RUDDER_ANGLE,
      HULL,
      PROPULSION,
      DC_STATE,
      FIRES_ACTIVE,
      FLOODING_ACTIVE,
      CREW_CASUALTIES,
      HULL_INTEGRITY,
      POWER_AVAILABLE,
      WEAPONS_ONLINE,
      SENSORS_ONLINE,
      RESERVED1,
      FUEL_REMAINING,
      AMMO_MAIN,
      MISSILES_REMAINING,
      TORPEDOES_REMAINING,
      VESSEL_TYPE,
      PROPULSION_TYPE,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `NAV`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_NAV_unchecked`.
pub fn root_as_NAV(buf: &[u8]) -> Result<NAV, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<NAV>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `NAV` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_NAV_unchecked`.
pub fn size_prefixed_root_as_NAV(buf: &[u8]) -> Result<NAV, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<NAV>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `NAV` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_NAV_unchecked`.
pub fn root_as_NAV_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NAV<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<NAV<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `NAV` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_NAV_unchecked`.
pub fn size_prefixed_root_as_NAV_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NAV<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<NAV<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a NAV and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `NAV`.
pub unsafe fn root_as_NAV_unchecked(buf: &[u8]) -> NAV {
  flatbuffers::root_unchecked::<NAV>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed NAV and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `NAV`.
pub unsafe fn size_prefixed_root_as_NAV_unchecked(buf: &[u8]) -> NAV {
  flatbuffers::size_prefixed_root_unchecked::<NAV>(buf)
}
pub const NAV_IDENTIFIER: &str = "$NAV";

#[inline]
pub fn NAV_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, NAV_IDENTIFIER, false)
}

#[inline]
pub fn NAV_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, NAV_IDENTIFIER, true)
}

#[inline]
pub fn finish_NAV_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<NAV<'a>>) {
  fbb.finish(root, Some(NAV_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_NAV_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<NAV<'a>>) {
  fbb.finish_size_prefixed(root, Some(NAV_IDENTIFIER));
}
