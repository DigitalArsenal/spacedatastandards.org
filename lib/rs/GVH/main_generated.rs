// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VEHICLE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VEHICLE_TYPE: i8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VEHICLE_TYPE: [VehicleType; 16] = [
  VehicleType::MBT,
  VehicleType::LIGHT_TANK,
  VehicleType::IFV,
  VehicleType::APC,
  VehicleType::SPAA,
  VehicleType::SPG,
  VehicleType::MLRS,
  VehicleType::RECON,
  VehicleType::TRUCK,
  VehicleType::JEEP,
  VehicleType::MRAP,
  VehicleType::ENGINEERING,
  VehicleType::RECOVERY,
  VehicleType::AAA,
  VehicleType::SAM,
  VehicleType::RADAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VehicleType(pub i8);
#[allow(non_upper_case_globals)]
impl VehicleType {
  pub const MBT: Self = Self(0);
  pub const LIGHT_TANK: Self = Self(1);
  pub const IFV: Self = Self(2);
  pub const APC: Self = Self(3);
  pub const SPAA: Self = Self(4);
  pub const SPG: Self = Self(5);
  pub const MLRS: Self = Self(6);
  pub const RECON: Self = Self(7);
  pub const TRUCK: Self = Self(8);
  pub const JEEP: Self = Self(9);
  pub const MRAP: Self = Self(10);
  pub const ENGINEERING: Self = Self(11);
  pub const RECOVERY: Self = Self(12);
  pub const AAA: Self = Self(13);
  pub const SAM: Self = Self(14);
  pub const RADAR: Self = Self(15);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MBT,
    Self::LIGHT_TANK,
    Self::IFV,
    Self::APC,
    Self::SPAA,
    Self::SPG,
    Self::MLRS,
    Self::RECON,
    Self::TRUCK,
    Self::JEEP,
    Self::MRAP,
    Self::ENGINEERING,
    Self::RECOVERY,
    Self::AAA,
    Self::SAM,
    Self::RADAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MBT => Some("MBT"),
      Self::LIGHT_TANK => Some("LIGHT_TANK"),
      Self::IFV => Some("IFV"),
      Self::APC => Some("APC"),
      Self::SPAA => Some("SPAA"),
      Self::SPG => Some("SPG"),
      Self::MLRS => Some("MLRS"),
      Self::RECON => Some("RECON"),
      Self::TRUCK => Some("TRUCK"),
      Self::JEEP => Some("JEEP"),
      Self::MRAP => Some("MRAP"),
      Self::ENGINEERING => Some("ENGINEERING"),
      Self::RECOVERY => Some("RECOVERY"),
      Self::AAA => Some("AAA"),
      Self::SAM => Some("SAM"),
      Self::RADAR => Some("RADAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VehicleType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VehicleType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VehicleType {
    type Output = VehicleType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VehicleType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VehicleType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VehicleType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DRIVE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DRIVE_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DRIVE_TYPE: [DriveType; 5] = [
  DriveType::TRACKED,
  DriveType::WHEELED_4X4,
  DriveType::WHEELED_6X6,
  DriveType::WHEELED_8X8,
  DriveType::HALF_TRACK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DriveType(pub i8);
#[allow(non_upper_case_globals)]
impl DriveType {
  pub const TRACKED: Self = Self(0);
  pub const WHEELED_4X4: Self = Self(1);
  pub const WHEELED_6X6: Self = Self(2);
  pub const WHEELED_8X8: Self = Self(3);
  pub const HALF_TRACK: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TRACKED,
    Self::WHEELED_4X4,
    Self::WHEELED_6X6,
    Self::WHEELED_8X8,
    Self::HALF_TRACK,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TRACKED => Some("TRACKED"),
      Self::WHEELED_4X4 => Some("WHEELED_4X4"),
      Self::WHEELED_6X6 => Some("WHEELED_6X6"),
      Self::WHEELED_8X8 => Some("WHEELED_8X8"),
      Self::HALF_TRACK => Some("HALF_TRACK"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DriveType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DriveType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DriveType {
    type Output = DriveType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DriveType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DriveType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DriveType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GVHENGINE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GVHENGINE_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GVHENGINE_TYPE: [GVHEngineType; 6] = [
  GVHEngineType::DIESEL,
  GVHEngineType::GASOLINE,
  GVHEngineType::GAS_TURBINE,
  GVHEngineType::MULTIFUEL,
  GVHEngineType::HYBRID,
  GVHEngineType::ELECTRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GVHEngineType(pub i8);
#[allow(non_upper_case_globals)]
impl GVHEngineType {
  pub const DIESEL: Self = Self(0);
  pub const GASOLINE: Self = Self(1);
  pub const GAS_TURBINE: Self = Self(2);
  pub const MULTIFUEL: Self = Self(3);
  pub const HYBRID: Self = Self(4);
  pub const ELECTRIC: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DIESEL,
    Self::GASOLINE,
    Self::GAS_TURBINE,
    Self::MULTIFUEL,
    Self::HYBRID,
    Self::ELECTRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DIESEL => Some("DIESEL"),
      Self::GASOLINE => Some("GASOLINE"),
      Self::GAS_TURBINE => Some("GAS_TURBINE"),
      Self::MULTIFUEL => Some("MULTIFUEL"),
      Self::HYBRID => Some("HYBRID"),
      Self::ELECTRIC => Some("ELECTRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GVHEngineType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GVHEngineType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GVHEngineType {
    type Output = GVHEngineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GVHEngineType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GVHEngineType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GVHEngineType {}
pub enum GVHOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ground Vehicles
pub struct GVH<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GVH<'a> {
  type Inner = GVH<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GVH<'a> {
  pub const VT_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_ATTITUDE_X: flatbuffers::VOffsetT = 16;
  pub const VT_ATTITUDE_Y: flatbuffers::VOffsetT = 18;
  pub const VT_ATTITUDE_Z: flatbuffers::VOffsetT = 20;
  pub const VT_ATTITUDE_W: flatbuffers::VOffsetT = 22;
  pub const VT_OMEGA_X: flatbuffers::VOffsetT = 24;
  pub const VT_OMEGA_Y: flatbuffers::VOffsetT = 26;
  pub const VT_OMEGA_Z: flatbuffers::VOffsetT = 28;
  pub const VT_SPEED: flatbuffers::VOffsetT = 30;
  pub const VT_HEADING: flatbuffers::VOffsetT = 32;
  pub const VT_LATERAL_G: flatbuffers::VOffsetT = 34;
  pub const VT_LONGITUDINAL_G: flatbuffers::VOffsetT = 36;
  pub const VT_TURRET: flatbuffers::VOffsetT = 38;
  pub const VT_DRIVETRAIN: flatbuffers::VOffsetT = 40;
  pub const VT_SUSPENSION_LF: flatbuffers::VOffsetT = 42;
  pub const VT_SUSPENSION_RF: flatbuffers::VOffsetT = 44;
  pub const VT_SUSPENSION_LR: flatbuffers::VOffsetT = 46;
  pub const VT_SUSPENSION_RR: flatbuffers::VOffsetT = 48;
  pub const VT_VEHICLE_TYPE: flatbuffers::VOffsetT = 50;
  pub const VT_DRIVE_TYPE: flatbuffers::VOffsetT = 52;
  pub const VT_ENGINE_RUNNING: flatbuffers::VOffsetT = 54;
  pub const VT_LIGHTS: flatbuffers::VOffsetT = 56;
  pub const VT_FUEL_LEVEL: flatbuffers::VOffsetT = 58;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GVH { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GVHArgs<'args>
  ) -> flatbuffers::WIPOffset<GVH<'bldr>> {
    let mut builder = GVHBuilder::new(_fbb);
    builder.add_OMEGA_Z(args.OMEGA_Z);
    builder.add_OMEGA_Y(args.OMEGA_Y);
    builder.add_OMEGA_X(args.OMEGA_X);
    builder.add_ATTITUDE_W(args.ATTITUDE_W);
    builder.add_ATTITUDE_Z(args.ATTITUDE_Z);
    builder.add_ATTITUDE_Y(args.ATTITUDE_Y);
    builder.add_ATTITUDE_X(args.ATTITUDE_X);
    builder.add_VELOCITY_Z(args.VELOCITY_Z);
    builder.add_VELOCITY_Y(args.VELOCITY_Y);
    builder.add_VELOCITY_X(args.VELOCITY_X);
    builder.add_POSITION_Z(args.POSITION_Z);
    builder.add_POSITION_Y(args.POSITION_Y);
    builder.add_POSITION_X(args.POSITION_X);
    builder.add_FUEL_LEVEL(args.FUEL_LEVEL);
    if let Some(x) = args.SUSPENSION_RR { builder.add_SUSPENSION_RR(x); }
    if let Some(x) = args.SUSPENSION_LR { builder.add_SUSPENSION_LR(x); }
    if let Some(x) = args.SUSPENSION_RF { builder.add_SUSPENSION_RF(x); }
    if let Some(x) = args.SUSPENSION_LF { builder.add_SUSPENSION_LF(x); }
    if let Some(x) = args.DRIVETRAIN { builder.add_DRIVETRAIN(x); }
    if let Some(x) = args.TURRET { builder.add_TURRET(x); }
    builder.add_LONGITUDINAL_G(args.LONGITUDINAL_G);
    builder.add_LATERAL_G(args.LATERAL_G);
    builder.add_HEADING(args.HEADING);
    builder.add_SPEED(args.SPEED);
    builder.add_LIGHTS(args.LIGHTS);
    builder.add_ENGINE_RUNNING(args.ENGINE_RUNNING);
    builder.add_DRIVE_TYPE(args.DRIVE_TYPE);
    builder.add_VEHICLE_TYPE(args.VEHICLE_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> GVHT {
    let POSITION_X = self.POSITION_X();
    let POSITION_Y = self.POSITION_Y();
    let POSITION_Z = self.POSITION_Z();
    let VELOCITY_X = self.VELOCITY_X();
    let VELOCITY_Y = self.VELOCITY_Y();
    let VELOCITY_Z = self.VELOCITY_Z();
    let ATTITUDE_X = self.ATTITUDE_X();
    let ATTITUDE_Y = self.ATTITUDE_Y();
    let ATTITUDE_Z = self.ATTITUDE_Z();
    let ATTITUDE_W = self.ATTITUDE_W();
    let OMEGA_X = self.OMEGA_X();
    let OMEGA_Y = self.OMEGA_Y();
    let OMEGA_Z = self.OMEGA_Z();
    let SPEED = self.SPEED();
    let HEADING = self.HEADING();
    let LATERAL_G = self.LATERAL_G();
    let LONGITUDINAL_G = self.LONGITUDINAL_G();
    let TURRET = self.TURRET().map(|x| {
      x.to_string()
    });
    let DRIVETRAIN = self.DRIVETRAIN().map(|x| {
      x.to_string()
    });
    let SUSPENSION_LF = self.SUSPENSION_LF().map(|x| {
      x.to_string()
    });
    let SUSPENSION_RF = self.SUSPENSION_RF().map(|x| {
      x.to_string()
    });
    let SUSPENSION_LR = self.SUSPENSION_LR().map(|x| {
      x.to_string()
    });
    let SUSPENSION_RR = self.SUSPENSION_RR().map(|x| {
      x.to_string()
    });
    let VEHICLE_TYPE = self.VEHICLE_TYPE();
    let DRIVE_TYPE = self.DRIVE_TYPE();
    let ENGINE_RUNNING = self.ENGINE_RUNNING();
    let LIGHTS = self.LIGHTS();
    let FUEL_LEVEL = self.FUEL_LEVEL();
    GVHT {
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED,
      HEADING,
      LATERAL_G,
      LONGITUDINAL_G,
      TURRET,
      DRIVETRAIN,
      SUSPENSION_LF,
      SUSPENSION_RF,
      SUSPENSION_LR,
      SUSPENSION_RR,
      VEHICLE_TYPE,
      DRIVE_TYPE,
      ENGINE_RUNNING,
      LIGHTS,
      FUEL_LEVEL,
    }
  }

  #[inline]
  pub fn POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_ATTITUDE_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_ATTITUDE_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_ATTITUDE_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_W(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_ATTITUDE_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_OMEGA_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_OMEGA_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GVH::VT_OMEGA_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SPEED(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GVH::VT_SPEED, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn HEADING(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GVH::VT_HEADING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LATERAL_G(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GVH::VT_LATERAL_G, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LONGITUDINAL_G(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GVH::VT_LONGITUDINAL_G, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TURRET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_TURRET, None)}
  }
  #[inline]
  pub fn DRIVETRAIN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_DRIVETRAIN, None)}
  }
  #[inline]
  pub fn SUSPENSION_LF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_SUSPENSION_LF, None)}
  }
  #[inline]
  pub fn SUSPENSION_RF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_SUSPENSION_RF, None)}
  }
  #[inline]
  pub fn SUSPENSION_LR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_SUSPENSION_LR, None)}
  }
  #[inline]
  pub fn SUSPENSION_RR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GVH::VT_SUSPENSION_RR, None)}
  }
  #[inline]
  pub fn VEHICLE_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GVH::VT_VEHICLE_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn DRIVE_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GVH::VT_DRIVE_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ENGINE_RUNNING(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GVH::VT_ENGINE_RUNNING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn LIGHTS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GVH::VT_LIGHTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FUEL_LEVEL(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GVH::VT_FUEL_LEVEL, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GVH<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("POSITION_X", Self::VT_POSITION_X, false)?
     .visit_field::<f64>("POSITION_Y", Self::VT_POSITION_Y, false)?
     .visit_field::<f64>("POSITION_Z", Self::VT_POSITION_Z, false)?
     .visit_field::<f64>("VELOCITY_X", Self::VT_VELOCITY_X, false)?
     .visit_field::<f64>("VELOCITY_Y", Self::VT_VELOCITY_Y, false)?
     .visit_field::<f64>("VELOCITY_Z", Self::VT_VELOCITY_Z, false)?
     .visit_field::<f64>("ATTITUDE_X", Self::VT_ATTITUDE_X, false)?
     .visit_field::<f64>("ATTITUDE_Y", Self::VT_ATTITUDE_Y, false)?
     .visit_field::<f64>("ATTITUDE_Z", Self::VT_ATTITUDE_Z, false)?
     .visit_field::<f64>("ATTITUDE_W", Self::VT_ATTITUDE_W, false)?
     .visit_field::<f64>("OMEGA_X", Self::VT_OMEGA_X, false)?
     .visit_field::<f64>("OMEGA_Y", Self::VT_OMEGA_Y, false)?
     .visit_field::<f64>("OMEGA_Z", Self::VT_OMEGA_Z, false)?
     .visit_field::<f32>("SPEED", Self::VT_SPEED, false)?
     .visit_field::<f32>("HEADING", Self::VT_HEADING, false)?
     .visit_field::<f32>("LATERAL_G", Self::VT_LATERAL_G, false)?
     .visit_field::<f32>("LONGITUDINAL_G", Self::VT_LONGITUDINAL_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TURRET", Self::VT_TURRET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DRIVETRAIN", Self::VT_DRIVETRAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUSPENSION_LF", Self::VT_SUSPENSION_LF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUSPENSION_RF", Self::VT_SUSPENSION_RF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUSPENSION_LR", Self::VT_SUSPENSION_LR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SUSPENSION_RR", Self::VT_SUSPENSION_RR, false)?
     .visit_field::<u8>("VEHICLE_TYPE", Self::VT_VEHICLE_TYPE, false)?
     .visit_field::<u8>("DRIVE_TYPE", Self::VT_DRIVE_TYPE, false)?
     .visit_field::<u8>("ENGINE_RUNNING", Self::VT_ENGINE_RUNNING, false)?
     .visit_field::<u8>("LIGHTS", Self::VT_LIGHTS, false)?
     .visit_field::<f32>("FUEL_LEVEL", Self::VT_FUEL_LEVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct GVHArgs<'a> {
    pub POSITION_X: f64,
    pub POSITION_Y: f64,
    pub POSITION_Z: f64,
    pub VELOCITY_X: f64,
    pub VELOCITY_Y: f64,
    pub VELOCITY_Z: f64,
    pub ATTITUDE_X: f64,
    pub ATTITUDE_Y: f64,
    pub ATTITUDE_Z: f64,
    pub ATTITUDE_W: f64,
    pub OMEGA_X: f64,
    pub OMEGA_Y: f64,
    pub OMEGA_Z: f64,
    pub SPEED: f32,
    pub HEADING: f32,
    pub LATERAL_G: f32,
    pub LONGITUDINAL_G: f32,
    pub TURRET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DRIVETRAIN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SUSPENSION_LF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SUSPENSION_RF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SUSPENSION_LR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SUSPENSION_RR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VEHICLE_TYPE: u8,
    pub DRIVE_TYPE: u8,
    pub ENGINE_RUNNING: u8,
    pub LIGHTS: u8,
    pub FUEL_LEVEL: f32,
}
impl<'a> Default for GVHArgs<'a> {
  #[inline]
  fn default() -> Self {
    GVHArgs {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      SPEED: 0.0,
      HEADING: 0.0,
      LATERAL_G: 0.0,
      LONGITUDINAL_G: 0.0,
      TURRET: None,
      DRIVETRAIN: None,
      SUSPENSION_LF: None,
      SUSPENSION_RF: None,
      SUSPENSION_LR: None,
      SUSPENSION_RR: None,
      VEHICLE_TYPE: 0,
      DRIVE_TYPE: 0,
      ENGINE_RUNNING: 0,
      LIGHTS: 0,
      FUEL_LEVEL: 0.0,
    }
  }
}

pub struct GVHBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GVHBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITION_X(&mut self, POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_POSITION_X, POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Y(&mut self, POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Z(&mut self, POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_X(&mut self, VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Y(&mut self, VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Z(&mut self, VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_X(&mut self, ATTITUDE_X: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Y(&mut self, ATTITUDE_Y: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Z(&mut self, ATTITUDE_Z: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_W(&mut self, ATTITUDE_W: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_X(&mut self, OMEGA_X: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Y(&mut self, OMEGA_Y: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Z(&mut self, OMEGA_Z: f64) {
    self.fbb_.push_slot::<f64>(GVH::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  #[inline]
  pub fn add_SPEED(&mut self, SPEED: f32) {
    self.fbb_.push_slot::<f32>(GVH::VT_SPEED, SPEED, 0.0);
  }
  #[inline]
  pub fn add_HEADING(&mut self, HEADING: f32) {
    self.fbb_.push_slot::<f32>(GVH::VT_HEADING, HEADING, 0.0);
  }
  #[inline]
  pub fn add_LATERAL_G(&mut self, LATERAL_G: f32) {
    self.fbb_.push_slot::<f32>(GVH::VT_LATERAL_G, LATERAL_G, 0.0);
  }
  #[inline]
  pub fn add_LONGITUDINAL_G(&mut self, LONGITUDINAL_G: f32) {
    self.fbb_.push_slot::<f32>(GVH::VT_LONGITUDINAL_G, LONGITUDINAL_G, 0.0);
  }
  #[inline]
  pub fn add_TURRET(&mut self, TURRET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_TURRET, TURRET);
  }
  #[inline]
  pub fn add_DRIVETRAIN(&mut self, DRIVETRAIN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_DRIVETRAIN, DRIVETRAIN);
  }
  #[inline]
  pub fn add_SUSPENSION_LF(&mut self, SUSPENSION_LF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_SUSPENSION_LF, SUSPENSION_LF);
  }
  #[inline]
  pub fn add_SUSPENSION_RF(&mut self, SUSPENSION_RF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_SUSPENSION_RF, SUSPENSION_RF);
  }
  #[inline]
  pub fn add_SUSPENSION_LR(&mut self, SUSPENSION_LR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_SUSPENSION_LR, SUSPENSION_LR);
  }
  #[inline]
  pub fn add_SUSPENSION_RR(&mut self, SUSPENSION_RR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GVH::VT_SUSPENSION_RR, SUSPENSION_RR);
  }
  #[inline]
  pub fn add_VEHICLE_TYPE(&mut self, VEHICLE_TYPE: u8) {
    self.fbb_.push_slot::<u8>(GVH::VT_VEHICLE_TYPE, VEHICLE_TYPE, 0);
  }
  #[inline]
  pub fn add_DRIVE_TYPE(&mut self, DRIVE_TYPE: u8) {
    self.fbb_.push_slot::<u8>(GVH::VT_DRIVE_TYPE, DRIVE_TYPE, 0);
  }
  #[inline]
  pub fn add_ENGINE_RUNNING(&mut self, ENGINE_RUNNING: u8) {
    self.fbb_.push_slot::<u8>(GVH::VT_ENGINE_RUNNING, ENGINE_RUNNING, 0);
  }
  #[inline]
  pub fn add_LIGHTS(&mut self, LIGHTS: u8) {
    self.fbb_.push_slot::<u8>(GVH::VT_LIGHTS, LIGHTS, 0);
  }
  #[inline]
  pub fn add_FUEL_LEVEL(&mut self, FUEL_LEVEL: f32) {
    self.fbb_.push_slot::<f32>(GVH::VT_FUEL_LEVEL, FUEL_LEVEL, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GVHBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GVHBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GVH<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GVH<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GVH");
      ds.field("POSITION_X", &self.POSITION_X());
      ds.field("POSITION_Y", &self.POSITION_Y());
      ds.field("POSITION_Z", &self.POSITION_Z());
      ds.field("VELOCITY_X", &self.VELOCITY_X());
      ds.field("VELOCITY_Y", &self.VELOCITY_Y());
      ds.field("VELOCITY_Z", &self.VELOCITY_Z());
      ds.field("ATTITUDE_X", &self.ATTITUDE_X());
      ds.field("ATTITUDE_Y", &self.ATTITUDE_Y());
      ds.field("ATTITUDE_Z", &self.ATTITUDE_Z());
      ds.field("ATTITUDE_W", &self.ATTITUDE_W());
      ds.field("OMEGA_X", &self.OMEGA_X());
      ds.field("OMEGA_Y", &self.OMEGA_Y());
      ds.field("OMEGA_Z", &self.OMEGA_Z());
      ds.field("SPEED", &self.SPEED());
      ds.field("HEADING", &self.HEADING());
      ds.field("LATERAL_G", &self.LATERAL_G());
      ds.field("LONGITUDINAL_G", &self.LONGITUDINAL_G());
      ds.field("TURRET", &self.TURRET());
      ds.field("DRIVETRAIN", &self.DRIVETRAIN());
      ds.field("SUSPENSION_LF", &self.SUSPENSION_LF());
      ds.field("SUSPENSION_RF", &self.SUSPENSION_RF());
      ds.field("SUSPENSION_LR", &self.SUSPENSION_LR());
      ds.field("SUSPENSION_RR", &self.SUSPENSION_RR());
      ds.field("VEHICLE_TYPE", &self.VEHICLE_TYPE());
      ds.field("DRIVE_TYPE", &self.DRIVE_TYPE());
      ds.field("ENGINE_RUNNING", &self.ENGINE_RUNNING());
      ds.field("LIGHTS", &self.LIGHTS());
      ds.field("FUEL_LEVEL", &self.FUEL_LEVEL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GVHT {
  pub POSITION_X: f64,
  pub POSITION_Y: f64,
  pub POSITION_Z: f64,
  pub VELOCITY_X: f64,
  pub VELOCITY_Y: f64,
  pub VELOCITY_Z: f64,
  pub ATTITUDE_X: f64,
  pub ATTITUDE_Y: f64,
  pub ATTITUDE_Z: f64,
  pub ATTITUDE_W: f64,
  pub OMEGA_X: f64,
  pub OMEGA_Y: f64,
  pub OMEGA_Z: f64,
  pub SPEED: f32,
  pub HEADING: f32,
  pub LATERAL_G: f32,
  pub LONGITUDINAL_G: f32,
  pub TURRET: Option<String>,
  pub DRIVETRAIN: Option<String>,
  pub SUSPENSION_LF: Option<String>,
  pub SUSPENSION_RF: Option<String>,
  pub SUSPENSION_LR: Option<String>,
  pub SUSPENSION_RR: Option<String>,
  pub VEHICLE_TYPE: u8,
  pub DRIVE_TYPE: u8,
  pub ENGINE_RUNNING: u8,
  pub LIGHTS: u8,
  pub FUEL_LEVEL: f32,
}
impl Default for GVHT {
  fn default() -> Self {
    Self {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      SPEED: 0.0,
      HEADING: 0.0,
      LATERAL_G: 0.0,
      LONGITUDINAL_G: 0.0,
      TURRET: None,
      DRIVETRAIN: None,
      SUSPENSION_LF: None,
      SUSPENSION_RF: None,
      SUSPENSION_LR: None,
      SUSPENSION_RR: None,
      VEHICLE_TYPE: 0,
      DRIVE_TYPE: 0,
      ENGINE_RUNNING: 0,
      LIGHTS: 0,
      FUEL_LEVEL: 0.0,
    }
  }
}
impl GVHT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GVH<'b>> {
    let POSITION_X = self.POSITION_X;
    let POSITION_Y = self.POSITION_Y;
    let POSITION_Z = self.POSITION_Z;
    let VELOCITY_X = self.VELOCITY_X;
    let VELOCITY_Y = self.VELOCITY_Y;
    let VELOCITY_Z = self.VELOCITY_Z;
    let ATTITUDE_X = self.ATTITUDE_X;
    let ATTITUDE_Y = self.ATTITUDE_Y;
    let ATTITUDE_Z = self.ATTITUDE_Z;
    let ATTITUDE_W = self.ATTITUDE_W;
    let OMEGA_X = self.OMEGA_X;
    let OMEGA_Y = self.OMEGA_Y;
    let OMEGA_Z = self.OMEGA_Z;
    let SPEED = self.SPEED;
    let HEADING = self.HEADING;
    let LATERAL_G = self.LATERAL_G;
    let LONGITUDINAL_G = self.LONGITUDINAL_G;
    let TURRET = self.TURRET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DRIVETRAIN = self.DRIVETRAIN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SUSPENSION_LF = self.SUSPENSION_LF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SUSPENSION_RF = self.SUSPENSION_RF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SUSPENSION_LR = self.SUSPENSION_LR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SUSPENSION_RR = self.SUSPENSION_RR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VEHICLE_TYPE = self.VEHICLE_TYPE;
    let DRIVE_TYPE = self.DRIVE_TYPE;
    let ENGINE_RUNNING = self.ENGINE_RUNNING;
    let LIGHTS = self.LIGHTS;
    let FUEL_LEVEL = self.FUEL_LEVEL;
    GVH::create(_fbb, &GVHArgs{
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      SPEED,
      HEADING,
      LATERAL_G,
      LONGITUDINAL_G,
      TURRET,
      DRIVETRAIN,
      SUSPENSION_LF,
      SUSPENSION_RF,
      SUSPENSION_LR,
      SUSPENSION_RR,
      VEHICLE_TYPE,
      DRIVE_TYPE,
      ENGINE_RUNNING,
      LIGHTS,
      FUEL_LEVEL,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GVH`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GVH_unchecked`.
pub fn root_as_GVH(buf: &[u8]) -> Result<GVH, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GVH>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GVH` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_GVH_unchecked`.
pub fn size_prefixed_root_as_GVH(buf: &[u8]) -> Result<GVH, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GVH>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GVH` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GVH_unchecked`.
pub fn root_as_GVH_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GVH<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GVH<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GVH` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GVH_unchecked`.
pub fn size_prefixed_root_as_GVH_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GVH<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GVH<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GVH and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GVH`.
pub unsafe fn root_as_GVH_unchecked(buf: &[u8]) -> GVH {
  flatbuffers::root_unchecked::<GVH>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GVH and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GVH`.
pub unsafe fn size_prefixed_root_as_GVH_unchecked(buf: &[u8]) -> GVH {
  flatbuffers::size_prefixed_root_unchecked::<GVH>(buf)
}
pub const GVH_IDENTIFIER: &str = "$GVH";

#[inline]
pub fn GVH_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GVH_IDENTIFIER, false)
}

#[inline]
pub fn GVH_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GVH_IDENTIFIER, true)
}

#[inline]
pub fn finish_GVH_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GVH<'a>>) {
  fbb.finish(root, Some(GVH_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_GVH_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GVH<'a>>) {
  fbb.finish_size_prefixed(root, Some(GVH_IDENTIFIER));
}
