// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AIRCRAFT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AIRCRAFT_TYPE: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AIRCRAFT_TYPE: [AircraftType; 12] = [
  AircraftType::FIGHTER,
  AircraftType::ATTACK,
  AircraftType::BOMBER,
  AircraftType::TRANSPORT,
  AircraftType::TRAINER,
  AircraftType::RECON,
  AircraftType::TANKER,
  AircraftType::AWACS,
  AircraftType::UAV,
  AircraftType::PROP_SINGLE,
  AircraftType::PROP_MULTI,
  AircraftType::SEAPLANE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AircraftType(pub i8);
#[allow(non_upper_case_globals)]
impl AircraftType {
  pub const FIGHTER: Self = Self(0);
  pub const ATTACK: Self = Self(1);
  pub const BOMBER: Self = Self(2);
  pub const TRANSPORT: Self = Self(3);
  pub const TRAINER: Self = Self(4);
  pub const RECON: Self = Self(5);
  pub const TANKER: Self = Self(6);
  pub const AWACS: Self = Self(7);
  pub const UAV: Self = Self(8);
  pub const PROP_SINGLE: Self = Self(9);
  pub const PROP_MULTI: Self = Self(10);
  pub const SEAPLANE: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FIGHTER,
    Self::ATTACK,
    Self::BOMBER,
    Self::TRANSPORT,
    Self::TRAINER,
    Self::RECON,
    Self::TANKER,
    Self::AWACS,
    Self::UAV,
    Self::PROP_SINGLE,
    Self::PROP_MULTI,
    Self::SEAPLANE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FIGHTER => Some("FIGHTER"),
      Self::ATTACK => Some("ATTACK"),
      Self::BOMBER => Some("BOMBER"),
      Self::TRANSPORT => Some("TRANSPORT"),
      Self::TRAINER => Some("TRAINER"),
      Self::RECON => Some("RECON"),
      Self::TANKER => Some("TANKER"),
      Self::AWACS => Some("AWACS"),
      Self::UAV => Some("UAV"),
      Self::PROP_SINGLE => Some("PROP_SINGLE"),
      Self::PROP_MULTI => Some("PROP_MULTI"),
      Self::SEAPLANE => Some("SEAPLANE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AircraftType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AircraftType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AircraftType {
    type Output = AircraftType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AircraftType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AircraftType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AircraftType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENGINE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENGINE_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENGINE_TYPE: [EngineType; 8] = [
  EngineType::TURBOJET,
  EngineType::TURBOFAN_LOW,
  EngineType::TURBOFAN_HIGH,
  EngineType::TURBOPROP,
  EngineType::PISTON,
  EngineType::RAMJET,
  EngineType::SCRAMJET,
  EngineType::ELECTRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EngineType(pub i8);
#[allow(non_upper_case_globals)]
impl EngineType {
  pub const TURBOJET: Self = Self(0);
  pub const TURBOFAN_LOW: Self = Self(1);
  pub const TURBOFAN_HIGH: Self = Self(2);
  pub const TURBOPROP: Self = Self(3);
  pub const PISTON: Self = Self(4);
  pub const RAMJET: Self = Self(5);
  pub const SCRAMJET: Self = Self(6);
  pub const ELECTRIC: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TURBOJET,
    Self::TURBOFAN_LOW,
    Self::TURBOFAN_HIGH,
    Self::TURBOPROP,
    Self::PISTON,
    Self::RAMJET,
    Self::SCRAMJET,
    Self::ELECTRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TURBOJET => Some("TURBOJET"),
      Self::TURBOFAN_LOW => Some("TURBOFAN_LOW"),
      Self::TURBOFAN_HIGH => Some("TURBOFAN_HIGH"),
      Self::TURBOPROP => Some("TURBOPROP"),
      Self::PISTON => Some("PISTON"),
      Self::RAMJET => Some("RAMJET"),
      Self::SCRAMJET => Some("SCRAMJET"),
      Self::ELECTRIC => Some("ELECTRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EngineType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EngineType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EngineType {
    type Output = EngineType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EngineType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EngineType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EngineType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FLIGHT_PHASE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FLIGHT_PHASE: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FLIGHT_PHASE: [FlightPhase; 10] = [
  FlightPhase::PARKED,
  FlightPhase::TAXI,
  FlightPhase::TAKEOFF,
  FlightPhase::CLIMB,
  FlightPhase::CRUISE,
  FlightPhase::DESCENT,
  FlightPhase::APPROACH,
  FlightPhase::LANDING,
  FlightPhase::GO_AROUND,
  FlightPhase::EMERGENCY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FlightPhase(pub i8);
#[allow(non_upper_case_globals)]
impl FlightPhase {
  pub const PARKED: Self = Self(0);
  pub const TAXI: Self = Self(1);
  pub const TAKEOFF: Self = Self(2);
  pub const CLIMB: Self = Self(3);
  pub const CRUISE: Self = Self(4);
  pub const DESCENT: Self = Self(5);
  pub const APPROACH: Self = Self(6);
  pub const LANDING: Self = Self(7);
  pub const GO_AROUND: Self = Self(8);
  pub const EMERGENCY: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PARKED,
    Self::TAXI,
    Self::TAKEOFF,
    Self::CLIMB,
    Self::CRUISE,
    Self::DESCENT,
    Self::APPROACH,
    Self::LANDING,
    Self::GO_AROUND,
    Self::EMERGENCY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PARKED => Some("PARKED"),
      Self::TAXI => Some("TAXI"),
      Self::TAKEOFF => Some("TAKEOFF"),
      Self::CLIMB => Some("CLIMB"),
      Self::CRUISE => Some("CRUISE"),
      Self::DESCENT => Some("DESCENT"),
      Self::APPROACH => Some("APPROACH"),
      Self::LANDING => Some("LANDING"),
      Self::GO_AROUND => Some("GO_AROUND"),
      Self::EMERGENCY => Some("EMERGENCY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FlightPhase {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FlightPhase {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FlightPhase {
    type Output = FlightPhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FlightPhase {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FlightPhase {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FlightPhase {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEAR_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEAR_STATE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEAR_STATE: [GearState; 5] = [
  GearState::UP,
  GearState::TRANSIT_DOWN,
  GearState::DOWN,
  GearState::TRANSIT_UP,
  GearState::DAMAGED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GearState(pub i8);
#[allow(non_upper_case_globals)]
impl GearState {
  pub const UP: Self = Self(0);
  pub const TRANSIT_DOWN: Self = Self(1);
  pub const DOWN: Self = Self(2);
  pub const TRANSIT_UP: Self = Self(3);
  pub const DAMAGED: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UP,
    Self::TRANSIT_DOWN,
    Self::DOWN,
    Self::TRANSIT_UP,
    Self::DAMAGED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UP => Some("UP"),
      Self::TRANSIT_DOWN => Some("TRANSIT_DOWN"),
      Self::DOWN => Some("DOWN"),
      Self::TRANSIT_UP => Some("TRANSIT_UP"),
      Self::DAMAGED => Some("DAMAGED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GearState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GearState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GearState {
    type Output = GearState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GearState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GearState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GearState {}
pub enum ACROffset {}
#[derive(Copy, Clone, PartialEq)]

/// Aircraft Dynamics
pub struct ACR<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ACR<'a> {
  type Inner = ACR<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ACR<'a> {
  pub const VT_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_ATTITUDE_X: flatbuffers::VOffsetT = 16;
  pub const VT_ATTITUDE_Y: flatbuffers::VOffsetT = 18;
  pub const VT_ATTITUDE_Z: flatbuffers::VOffsetT = 20;
  pub const VT_ATTITUDE_W: flatbuffers::VOffsetT = 22;
  pub const VT_OMEGA_X: flatbuffers::VOffsetT = 24;
  pub const VT_OMEGA_Y: flatbuffers::VOffsetT = 26;
  pub const VT_OMEGA_Z: flatbuffers::VOffsetT = 28;
  pub const VT_MASS: flatbuffers::VOffsetT = 30;
  pub const VT_CG_X: flatbuffers::VOffsetT = 32;
  pub const VT_CG_Z: flatbuffers::VOffsetT = 34;
  pub const VT_AERO: flatbuffers::VOffsetT = 36;
  pub const VT_CONTROLS: flatbuffers::VOffsetT = 38;
  pub const VT_ENGINE: flatbuffers::VOffsetT = 40;
  pub const VT_GEAR_STATE: flatbuffers::VOffsetT = 42;
  pub const VT_GEAR_POSITION: flatbuffers::VOffsetT = 44;
  pub const VT_FLAP_POSITION: flatbuffers::VOffsetT = 46;
  pub const VT_SPEEDBRAKE_POS: flatbuffers::VOffsetT = 48;
  pub const VT_FLIGHT_PHASE: flatbuffers::VOffsetT = 50;
  pub const VT_AUTOPILOT_MODE: flatbuffers::VOffsetT = 52;
  pub const VT_WEIGHT_ON_WHEELS: flatbuffers::VOffsetT = 54;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 56;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ACR { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ACRArgs<'args>
  ) -> flatbuffers::WIPOffset<ACR<'bldr>> {
    let mut builder = ACRBuilder::new(_fbb);
    builder.add_MASS(args.MASS);
    builder.add_OMEGA_Z(args.OMEGA_Z);
    builder.add_OMEGA_Y(args.OMEGA_Y);
    builder.add_OMEGA_X(args.OMEGA_X);
    builder.add_ATTITUDE_W(args.ATTITUDE_W);
    builder.add_ATTITUDE_Z(args.ATTITUDE_Z);
    builder.add_ATTITUDE_Y(args.ATTITUDE_Y);
    builder.add_ATTITUDE_X(args.ATTITUDE_X);
    builder.add_VELOCITY_Z(args.VELOCITY_Z);
    builder.add_VELOCITY_Y(args.VELOCITY_Y);
    builder.add_VELOCITY_X(args.VELOCITY_X);
    builder.add_POSITION_Z(args.POSITION_Z);
    builder.add_POSITION_Y(args.POSITION_Y);
    builder.add_POSITION_X(args.POSITION_X);
    if let Some(x) = args.ENGINE { builder.add_ENGINE(x); }
    if let Some(x) = args.CONTROLS { builder.add_CONTROLS(x); }
    if let Some(x) = args.AERO { builder.add_AERO(x); }
    builder.add_CG_Z(args.CG_Z);
    builder.add_CG_X(args.CG_X);
    builder.add_RESERVED(args.RESERVED);
    builder.add_WEIGHT_ON_WHEELS(args.WEIGHT_ON_WHEELS);
    builder.add_AUTOPILOT_MODE(args.AUTOPILOT_MODE);
    builder.add_FLIGHT_PHASE(args.FLIGHT_PHASE);
    builder.add_SPEEDBRAKE_POS(args.SPEEDBRAKE_POS);
    builder.add_FLAP_POSITION(args.FLAP_POSITION);
    builder.add_GEAR_POSITION(args.GEAR_POSITION);
    builder.add_GEAR_STATE(args.GEAR_STATE);
    builder.finish()
  }

  pub fn unpack(&self) -> ACRT {
    let POSITION_X = self.POSITION_X();
    let POSITION_Y = self.POSITION_Y();
    let POSITION_Z = self.POSITION_Z();
    let VELOCITY_X = self.VELOCITY_X();
    let VELOCITY_Y = self.VELOCITY_Y();
    let VELOCITY_Z = self.VELOCITY_Z();
    let ATTITUDE_X = self.ATTITUDE_X();
    let ATTITUDE_Y = self.ATTITUDE_Y();
    let ATTITUDE_Z = self.ATTITUDE_Z();
    let ATTITUDE_W = self.ATTITUDE_W();
    let OMEGA_X = self.OMEGA_X();
    let OMEGA_Y = self.OMEGA_Y();
    let OMEGA_Z = self.OMEGA_Z();
    let MASS = self.MASS();
    let CG_X = self.CG_X();
    let CG_Z = self.CG_Z();
    let AERO = self.AERO().map(|x| {
      x.to_string()
    });
    let CONTROLS = self.CONTROLS().map(|x| {
      x.to_string()
    });
    let ENGINE = self.ENGINE().map(|x| {
      x.to_string()
    });
    let GEAR_STATE = self.GEAR_STATE();
    let GEAR_POSITION = self.GEAR_POSITION();
    let FLAP_POSITION = self.FLAP_POSITION();
    let SPEEDBRAKE_POS = self.SPEEDBRAKE_POS();
    let FLIGHT_PHASE = self.FLIGHT_PHASE();
    let AUTOPILOT_MODE = self.AUTOPILOT_MODE();
    let WEIGHT_ON_WHEELS = self.WEIGHT_ON_WHEELS();
    let RESERVED = self.RESERVED();
    ACRT {
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      CG_X,
      CG_Z,
      AERO,
      CONTROLS,
      ENGINE,
      GEAR_STATE,
      GEAR_POSITION,
      FLAP_POSITION,
      SPEEDBRAKE_POS,
      FLIGHT_PHASE,
      AUTOPILOT_MODE,
      WEIGHT_ON_WHEELS,
      RESERVED,
    }
  }

  #[inline]
  pub fn POSITION_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn POSITION_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VELOCITY_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_ATTITUDE_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_ATTITUDE_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_ATTITUDE_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATTITUDE_W(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_ATTITUDE_W, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_OMEGA_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_OMEGA_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OMEGA_Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_OMEGA_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ACR::VT_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CG_X(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ACR::VT_CG_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CG_Z(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ACR::VT_CG_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AERO(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ACR::VT_AERO, None)}
  }
  #[inline]
  pub fn CONTROLS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ACR::VT_CONTROLS, None)}
  }
  #[inline]
  pub fn ENGINE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ACR::VT_ENGINE, None)}
  }
  #[inline]
  pub fn GEAR_STATE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_GEAR_STATE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn GEAR_POSITION(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_GEAR_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FLAP_POSITION(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_FLAP_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn SPEEDBRAKE_POS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_SPEEDBRAKE_POS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FLIGHT_PHASE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_FLIGHT_PHASE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn AUTOPILOT_MODE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_AUTOPILOT_MODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn WEIGHT_ON_WHEELS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_WEIGHT_ON_WHEELS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ACR::VT_RESERVED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ACR<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("POSITION_X", Self::VT_POSITION_X, false)?
     .visit_field::<f64>("POSITION_Y", Self::VT_POSITION_Y, false)?
     .visit_field::<f64>("POSITION_Z", Self::VT_POSITION_Z, false)?
     .visit_field::<f64>("VELOCITY_X", Self::VT_VELOCITY_X, false)?
     .visit_field::<f64>("VELOCITY_Y", Self::VT_VELOCITY_Y, false)?
     .visit_field::<f64>("VELOCITY_Z", Self::VT_VELOCITY_Z, false)?
     .visit_field::<f64>("ATTITUDE_X", Self::VT_ATTITUDE_X, false)?
     .visit_field::<f64>("ATTITUDE_Y", Self::VT_ATTITUDE_Y, false)?
     .visit_field::<f64>("ATTITUDE_Z", Self::VT_ATTITUDE_Z, false)?
     .visit_field::<f64>("ATTITUDE_W", Self::VT_ATTITUDE_W, false)?
     .visit_field::<f64>("OMEGA_X", Self::VT_OMEGA_X, false)?
     .visit_field::<f64>("OMEGA_Y", Self::VT_OMEGA_Y, false)?
     .visit_field::<f64>("OMEGA_Z", Self::VT_OMEGA_Z, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<f32>("CG_X", Self::VT_CG_X, false)?
     .visit_field::<f32>("CG_Z", Self::VT_CG_Z, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AERO", Self::VT_AERO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTROLS", Self::VT_CONTROLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ENGINE", Self::VT_ENGINE, false)?
     .visit_field::<u8>("GEAR_STATE", Self::VT_GEAR_STATE, false)?
     .visit_field::<u8>("GEAR_POSITION", Self::VT_GEAR_POSITION, false)?
     .visit_field::<u8>("FLAP_POSITION", Self::VT_FLAP_POSITION, false)?
     .visit_field::<u8>("SPEEDBRAKE_POS", Self::VT_SPEEDBRAKE_POS, false)?
     .visit_field::<u8>("FLIGHT_PHASE", Self::VT_FLIGHT_PHASE, false)?
     .visit_field::<u8>("AUTOPILOT_MODE", Self::VT_AUTOPILOT_MODE, false)?
     .visit_field::<u8>("WEIGHT_ON_WHEELS", Self::VT_WEIGHT_ON_WHEELS, false)?
     .visit_field::<u8>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct ACRArgs<'a> {
    pub POSITION_X: f64,
    pub POSITION_Y: f64,
    pub POSITION_Z: f64,
    pub VELOCITY_X: f64,
    pub VELOCITY_Y: f64,
    pub VELOCITY_Z: f64,
    pub ATTITUDE_X: f64,
    pub ATTITUDE_Y: f64,
    pub ATTITUDE_Z: f64,
    pub ATTITUDE_W: f64,
    pub OMEGA_X: f64,
    pub OMEGA_Y: f64,
    pub OMEGA_Z: f64,
    pub MASS: f64,
    pub CG_X: f32,
    pub CG_Z: f32,
    pub AERO: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTROLS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENGINE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub GEAR_STATE: u8,
    pub GEAR_POSITION: u8,
    pub FLAP_POSITION: u8,
    pub SPEEDBRAKE_POS: u8,
    pub FLIGHT_PHASE: u8,
    pub AUTOPILOT_MODE: u8,
    pub WEIGHT_ON_WHEELS: u8,
    pub RESERVED: u8,
}
impl<'a> Default for ACRArgs<'a> {
  #[inline]
  fn default() -> Self {
    ACRArgs {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      MASS: 0.0,
      CG_X: 0.0,
      CG_Z: 0.0,
      AERO: None,
      CONTROLS: None,
      ENGINE: None,
      GEAR_STATE: 0,
      GEAR_POSITION: 0,
      FLAP_POSITION: 0,
      SPEEDBRAKE_POS: 0,
      FLIGHT_PHASE: 0,
      AUTOPILOT_MODE: 0,
      WEIGHT_ON_WHEELS: 0,
      RESERVED: 0,
    }
  }
}

pub struct ACRBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ACRBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POSITION_X(&mut self, POSITION_X: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_POSITION_X, POSITION_X, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Y(&mut self, POSITION_Y: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_POSITION_Y, POSITION_Y, 0.0);
  }
  #[inline]
  pub fn add_POSITION_Z(&mut self, POSITION_Z: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_POSITION_Z, POSITION_Z, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_X(&mut self, VELOCITY_X: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_VELOCITY_X, VELOCITY_X, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Y(&mut self, VELOCITY_Y: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_VELOCITY_Y, VELOCITY_Y, 0.0);
  }
  #[inline]
  pub fn add_VELOCITY_Z(&mut self, VELOCITY_Z: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_VELOCITY_Z, VELOCITY_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_X(&mut self, ATTITUDE_X: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_ATTITUDE_X, ATTITUDE_X, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Y(&mut self, ATTITUDE_Y: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_ATTITUDE_Y, ATTITUDE_Y, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_Z(&mut self, ATTITUDE_Z: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_ATTITUDE_Z, ATTITUDE_Z, 0.0);
  }
  #[inline]
  pub fn add_ATTITUDE_W(&mut self, ATTITUDE_W: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_ATTITUDE_W, ATTITUDE_W, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_X(&mut self, OMEGA_X: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_OMEGA_X, OMEGA_X, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Y(&mut self, OMEGA_Y: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_OMEGA_Y, OMEGA_Y, 0.0);
  }
  #[inline]
  pub fn add_OMEGA_Z(&mut self, OMEGA_Z: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_OMEGA_Z, OMEGA_Z, 0.0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(ACR::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_CG_X(&mut self, CG_X: f32) {
    self.fbb_.push_slot::<f32>(ACR::VT_CG_X, CG_X, 0.0);
  }
  #[inline]
  pub fn add_CG_Z(&mut self, CG_Z: f32) {
    self.fbb_.push_slot::<f32>(ACR::VT_CG_Z, CG_Z, 0.0);
  }
  #[inline]
  pub fn add_AERO(&mut self, AERO: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ACR::VT_AERO, AERO);
  }
  #[inline]
  pub fn add_CONTROLS(&mut self, CONTROLS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ACR::VT_CONTROLS, CONTROLS);
  }
  #[inline]
  pub fn add_ENGINE(&mut self, ENGINE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ACR::VT_ENGINE, ENGINE);
  }
  #[inline]
  pub fn add_GEAR_STATE(&mut self, GEAR_STATE: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_GEAR_STATE, GEAR_STATE, 0);
  }
  #[inline]
  pub fn add_GEAR_POSITION(&mut self, GEAR_POSITION: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_GEAR_POSITION, GEAR_POSITION, 0);
  }
  #[inline]
  pub fn add_FLAP_POSITION(&mut self, FLAP_POSITION: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_FLAP_POSITION, FLAP_POSITION, 0);
  }
  #[inline]
  pub fn add_SPEEDBRAKE_POS(&mut self, SPEEDBRAKE_POS: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_SPEEDBRAKE_POS, SPEEDBRAKE_POS, 0);
  }
  #[inline]
  pub fn add_FLIGHT_PHASE(&mut self, FLIGHT_PHASE: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_FLIGHT_PHASE, FLIGHT_PHASE, 0);
  }
  #[inline]
  pub fn add_AUTOPILOT_MODE(&mut self, AUTOPILOT_MODE: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_AUTOPILOT_MODE, AUTOPILOT_MODE, 0);
  }
  #[inline]
  pub fn add_WEIGHT_ON_WHEELS(&mut self, WEIGHT_ON_WHEELS: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_WEIGHT_ON_WHEELS, WEIGHT_ON_WHEELS, 0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: u8) {
    self.fbb_.push_slot::<u8>(ACR::VT_RESERVED, RESERVED, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ACRBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ACRBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ACR<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ACR<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ACR");
      ds.field("POSITION_X", &self.POSITION_X());
      ds.field("POSITION_Y", &self.POSITION_Y());
      ds.field("POSITION_Z", &self.POSITION_Z());
      ds.field("VELOCITY_X", &self.VELOCITY_X());
      ds.field("VELOCITY_Y", &self.VELOCITY_Y());
      ds.field("VELOCITY_Z", &self.VELOCITY_Z());
      ds.field("ATTITUDE_X", &self.ATTITUDE_X());
      ds.field("ATTITUDE_Y", &self.ATTITUDE_Y());
      ds.field("ATTITUDE_Z", &self.ATTITUDE_Z());
      ds.field("ATTITUDE_W", &self.ATTITUDE_W());
      ds.field("OMEGA_X", &self.OMEGA_X());
      ds.field("OMEGA_Y", &self.OMEGA_Y());
      ds.field("OMEGA_Z", &self.OMEGA_Z());
      ds.field("MASS", &self.MASS());
      ds.field("CG_X", &self.CG_X());
      ds.field("CG_Z", &self.CG_Z());
      ds.field("AERO", &self.AERO());
      ds.field("CONTROLS", &self.CONTROLS());
      ds.field("ENGINE", &self.ENGINE());
      ds.field("GEAR_STATE", &self.GEAR_STATE());
      ds.field("GEAR_POSITION", &self.GEAR_POSITION());
      ds.field("FLAP_POSITION", &self.FLAP_POSITION());
      ds.field("SPEEDBRAKE_POS", &self.SPEEDBRAKE_POS());
      ds.field("FLIGHT_PHASE", &self.FLIGHT_PHASE());
      ds.field("AUTOPILOT_MODE", &self.AUTOPILOT_MODE());
      ds.field("WEIGHT_ON_WHEELS", &self.WEIGHT_ON_WHEELS());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ACRT {
  pub POSITION_X: f64,
  pub POSITION_Y: f64,
  pub POSITION_Z: f64,
  pub VELOCITY_X: f64,
  pub VELOCITY_Y: f64,
  pub VELOCITY_Z: f64,
  pub ATTITUDE_X: f64,
  pub ATTITUDE_Y: f64,
  pub ATTITUDE_Z: f64,
  pub ATTITUDE_W: f64,
  pub OMEGA_X: f64,
  pub OMEGA_Y: f64,
  pub OMEGA_Z: f64,
  pub MASS: f64,
  pub CG_X: f32,
  pub CG_Z: f32,
  pub AERO: Option<String>,
  pub CONTROLS: Option<String>,
  pub ENGINE: Option<String>,
  pub GEAR_STATE: u8,
  pub GEAR_POSITION: u8,
  pub FLAP_POSITION: u8,
  pub SPEEDBRAKE_POS: u8,
  pub FLIGHT_PHASE: u8,
  pub AUTOPILOT_MODE: u8,
  pub WEIGHT_ON_WHEELS: u8,
  pub RESERVED: u8,
}
impl Default for ACRT {
  fn default() -> Self {
    Self {
      POSITION_X: 0.0,
      POSITION_Y: 0.0,
      POSITION_Z: 0.0,
      VELOCITY_X: 0.0,
      VELOCITY_Y: 0.0,
      VELOCITY_Z: 0.0,
      ATTITUDE_X: 0.0,
      ATTITUDE_Y: 0.0,
      ATTITUDE_Z: 0.0,
      ATTITUDE_W: 0.0,
      OMEGA_X: 0.0,
      OMEGA_Y: 0.0,
      OMEGA_Z: 0.0,
      MASS: 0.0,
      CG_X: 0.0,
      CG_Z: 0.0,
      AERO: None,
      CONTROLS: None,
      ENGINE: None,
      GEAR_STATE: 0,
      GEAR_POSITION: 0,
      FLAP_POSITION: 0,
      SPEEDBRAKE_POS: 0,
      FLIGHT_PHASE: 0,
      AUTOPILOT_MODE: 0,
      WEIGHT_ON_WHEELS: 0,
      RESERVED: 0,
    }
  }
}
impl ACRT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ACR<'b>> {
    let POSITION_X = self.POSITION_X;
    let POSITION_Y = self.POSITION_Y;
    let POSITION_Z = self.POSITION_Z;
    let VELOCITY_X = self.VELOCITY_X;
    let VELOCITY_Y = self.VELOCITY_Y;
    let VELOCITY_Z = self.VELOCITY_Z;
    let ATTITUDE_X = self.ATTITUDE_X;
    let ATTITUDE_Y = self.ATTITUDE_Y;
    let ATTITUDE_Z = self.ATTITUDE_Z;
    let ATTITUDE_W = self.ATTITUDE_W;
    let OMEGA_X = self.OMEGA_X;
    let OMEGA_Y = self.OMEGA_Y;
    let OMEGA_Z = self.OMEGA_Z;
    let MASS = self.MASS;
    let CG_X = self.CG_X;
    let CG_Z = self.CG_Z;
    let AERO = self.AERO.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTROLS = self.CONTROLS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENGINE = self.ENGINE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let GEAR_STATE = self.GEAR_STATE;
    let GEAR_POSITION = self.GEAR_POSITION;
    let FLAP_POSITION = self.FLAP_POSITION;
    let SPEEDBRAKE_POS = self.SPEEDBRAKE_POS;
    let FLIGHT_PHASE = self.FLIGHT_PHASE;
    let AUTOPILOT_MODE = self.AUTOPILOT_MODE;
    let WEIGHT_ON_WHEELS = self.WEIGHT_ON_WHEELS;
    let RESERVED = self.RESERVED;
    ACR::create(_fbb, &ACRArgs{
      POSITION_X,
      POSITION_Y,
      POSITION_Z,
      VELOCITY_X,
      VELOCITY_Y,
      VELOCITY_Z,
      ATTITUDE_X,
      ATTITUDE_Y,
      ATTITUDE_Z,
      ATTITUDE_W,
      OMEGA_X,
      OMEGA_Y,
      OMEGA_Z,
      MASS,
      CG_X,
      CG_Z,
      AERO,
      CONTROLS,
      ENGINE,
      GEAR_STATE,
      GEAR_POSITION,
      FLAP_POSITION,
      SPEEDBRAKE_POS,
      FLIGHT_PHASE,
      AUTOPILOT_MODE,
      WEIGHT_ON_WHEELS,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ACR`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ACR_unchecked`.
pub fn root_as_ACR(buf: &[u8]) -> Result<ACR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ACR>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ACR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ACR_unchecked`.
pub fn size_prefixed_root_as_ACR(buf: &[u8]) -> Result<ACR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ACR>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ACR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ACR_unchecked`.
pub fn root_as_ACR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ACR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ACR<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ACR` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ACR_unchecked`.
pub fn size_prefixed_root_as_ACR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ACR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ACR<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ACR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ACR`.
pub unsafe fn root_as_ACR_unchecked(buf: &[u8]) -> ACR {
  flatbuffers::root_unchecked::<ACR>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ACR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ACR`.
pub unsafe fn size_prefixed_root_as_ACR_unchecked(buf: &[u8]) -> ACR {
  flatbuffers::size_prefixed_root_unchecked::<ACR>(buf)
}
pub const ACR_IDENTIFIER: &str = "$ACR";

#[inline]
pub fn ACR_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ACR_IDENTIFIER, false)
}

#[inline]
pub fn ACR_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ACR_IDENTIFIER, true)
}

#[inline]
pub fn finish_ACR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ACR<'a>>) {
  fbb.finish(root, Some(ACR_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_ACR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ACR<'a>>) {
  fbb.finish_size_prefixed(root, Some(ACR_IDENTIFIER));
}
