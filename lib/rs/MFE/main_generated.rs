// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum MFEOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Manifold Element Set
pub struct MFE<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MFE<'a> {
  type Inner = MFE<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MFE<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TMP_SAT_NO: flatbuffers::VOffsetT = 6;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 8;
  pub const VT_MEAN_MOTION: flatbuffers::VOffsetT = 10;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 12;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 14;
  pub const VT_RAAN: flatbuffers::VOffsetT = 16;
  pub const VT_ARG_OF_PERIGEE: flatbuffers::VOffsetT = 18;
  pub const VT_MEAN_ANOMALY: flatbuffers::VOffsetT = 20;
  pub const VT_REV_NO: flatbuffers::VOffsetT = 22;
  pub const VT_B_STAR: flatbuffers::VOffsetT = 24;
  pub const VT_MEAN_MOTION_DOT: flatbuffers::VOffsetT = 26;
  pub const VT_MEAN_MOTION_DDOT: flatbuffers::VOffsetT = 28;
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 30;
  pub const VT_PERIOD: flatbuffers::VOffsetT = 32;
  pub const VT_APOGEE: flatbuffers::VOffsetT = 34;
  pub const VT_PERIGEE: flatbuffers::VOffsetT = 36;
  pub const VT_LINE1: flatbuffers::VOffsetT = 38;
  pub const VT_LINE2: flatbuffers::VOffsetT = 40;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MFE { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MFEArgs<'args>
  ) -> flatbuffers::WIPOffset<MFE<'bldr>> {
    let mut builder = MFEBuilder::new(_fbb);
    builder.add_PERIGEE(args.PERIGEE);
    builder.add_APOGEE(args.APOGEE);
    builder.add_PERIOD(args.PERIOD);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    builder.add_MEAN_MOTION_DDOT(args.MEAN_MOTION_DDOT);
    builder.add_MEAN_MOTION_DOT(args.MEAN_MOTION_DOT);
    builder.add_B_STAR(args.B_STAR);
    builder.add_MEAN_ANOMALY(args.MEAN_ANOMALY);
    builder.add_ARG_OF_PERIGEE(args.ARG_OF_PERIGEE);
    builder.add_RAAN(args.RAAN);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_MEAN_MOTION(args.MEAN_MOTION);
    if let Some(x) = args.LINE2 { builder.add_LINE2(x); }
    if let Some(x) = args.LINE1 { builder.add_LINE1(x); }
    builder.add_REV_NO(args.REV_NO);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.add_TMP_SAT_NO(args.TMP_SAT_NO);
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MFET {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let TMP_SAT_NO = self.TMP_SAT_NO();
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let MEAN_MOTION = self.MEAN_MOTION();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RAAN = self.RAAN();
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE();
    let MEAN_ANOMALY = self.MEAN_ANOMALY();
    let REV_NO = self.REV_NO();
    let B_STAR = self.B_STAR();
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT();
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT();
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let PERIOD = self.PERIOD();
    let APOGEE = self.APOGEE();
    let PERIGEE = self.PERIGEE();
    let LINE1 = self.LINE1().map(|x| {
      x.to_string()
    });
    let LINE2 = self.LINE2().map(|x| {
      x.to_string()
    });
    MFET {
      ID,
      TMP_SAT_NO,
      EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      REV_NO,
      B_STAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      SEMI_MAJOR_AXIS,
      PERIOD,
      APOGEE,
      PERIGEE,
      LINE1,
      LINE2,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MFE::VT_ID, None)}
  }
  #[inline]
  pub fn TMP_SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MFE::VT_TMP_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MFE::VT_EPOCH, None)}
  }
  #[inline]
  pub fn MEAN_MOTION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_MEAN_MOTION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RAAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_RAAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ARG_OF_PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_ARG_OF_PERIGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_MEAN_ANOMALY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn REV_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MFE::VT_REV_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn B_STAR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_B_STAR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_MEAN_MOTION_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_MEAN_MOTION_DDOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PERIOD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_PERIOD, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn APOGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_APOGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PERIGEE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(MFE::VT_PERIGEE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn LINE1(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MFE::VT_LINE1, None)}
  }
  #[inline]
  pub fn LINE2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MFE::VT_LINE2, None)}
  }
}

impl flatbuffers::Verifiable for MFE<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<i32>("TMP_SAT_NO", Self::VT_TMP_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("MEAN_MOTION", Self::VT_MEAN_MOTION, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RAAN", Self::VT_RAAN, false)?
     .visit_field::<f64>("ARG_OF_PERIGEE", Self::VT_ARG_OF_PERIGEE, false)?
     .visit_field::<f64>("MEAN_ANOMALY", Self::VT_MEAN_ANOMALY, false)?
     .visit_field::<i32>("REV_NO", Self::VT_REV_NO, false)?
     .visit_field::<f64>("B_STAR", Self::VT_B_STAR, false)?
     .visit_field::<f64>("MEAN_MOTION_DOT", Self::VT_MEAN_MOTION_DOT, false)?
     .visit_field::<f64>("MEAN_MOTION_DDOT", Self::VT_MEAN_MOTION_DDOT, false)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("PERIOD", Self::VT_PERIOD, false)?
     .visit_field::<f64>("APOGEE", Self::VT_APOGEE, false)?
     .visit_field::<f64>("PERIGEE", Self::VT_PERIGEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LINE1", Self::VT_LINE1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LINE2", Self::VT_LINE2, false)?
     .finish();
    Ok(())
  }
}
pub struct MFEArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TMP_SAT_NO: i32,
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEAN_MOTION: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RAAN: f64,
    pub ARG_OF_PERIGEE: f64,
    pub MEAN_ANOMALY: f64,
    pub REV_NO: i32,
    pub B_STAR: f64,
    pub MEAN_MOTION_DOT: f64,
    pub MEAN_MOTION_DDOT: f64,
    pub SEMI_MAJOR_AXIS: f64,
    pub PERIOD: f64,
    pub APOGEE: f64,
    pub PERIGEE: f64,
    pub LINE1: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LINE2: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MFEArgs<'a> {
  #[inline]
  fn default() -> Self {
    MFEArgs {
      ID: None,
      TMP_SAT_NO: 0,
      EPOCH: None,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      REV_NO: 0,
      B_STAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      PERIOD: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      LINE1: None,
      LINE2: None,
    }
  }
}

pub struct MFEBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MFEBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MFE::VT_ID, ID);
  }
  #[inline]
  pub fn add_TMP_SAT_NO(&mut self, TMP_SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(MFE::VT_TMP_SAT_NO, TMP_SAT_NO, 0);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MFE::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_MEAN_MOTION(&mut self, MEAN_MOTION: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_MEAN_MOTION, MEAN_MOTION, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RAAN(&mut self, RAAN: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_RAAN, RAAN, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERIGEE(&mut self, ARG_OF_PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_ARG_OF_PERIGEE, ARG_OF_PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ANOMALY(&mut self, MEAN_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_REV_NO(&mut self, REV_NO: i32) {
    self.fbb_.push_slot::<i32>(MFE::VT_REV_NO, REV_NO, 0);
  }
  #[inline]
  pub fn add_B_STAR(&mut self, B_STAR: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_B_STAR, B_STAR, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DOT(&mut self, MEAN_MOTION_DOT: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_MEAN_MOTION_DOT, MEAN_MOTION_DOT, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DDOT(&mut self, MEAN_MOTION_DDOT: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_MEAN_MOTION_DDOT, MEAN_MOTION_DDOT, 0.0);
  }
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_PERIOD(&mut self, PERIOD: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_PERIOD, PERIOD, 0.0);
  }
  #[inline]
  pub fn add_APOGEE(&mut self, APOGEE: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_APOGEE, APOGEE, 0.0);
  }
  #[inline]
  pub fn add_PERIGEE(&mut self, PERIGEE: f64) {
    self.fbb_.push_slot::<f64>(MFE::VT_PERIGEE, PERIGEE, 0.0);
  }
  #[inline]
  pub fn add_LINE1(&mut self, LINE1: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MFE::VT_LINE1, LINE1);
  }
  #[inline]
  pub fn add_LINE2(&mut self, LINE2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MFE::VT_LINE2, LINE2);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MFEBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MFEBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MFE<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MFE<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MFE");
      ds.field("ID", &self.ID());
      ds.field("TMP_SAT_NO", &self.TMP_SAT_NO());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("MEAN_MOTION", &self.MEAN_MOTION());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RAAN", &self.RAAN());
      ds.field("ARG_OF_PERIGEE", &self.ARG_OF_PERIGEE());
      ds.field("MEAN_ANOMALY", &self.MEAN_ANOMALY());
      ds.field("REV_NO", &self.REV_NO());
      ds.field("B_STAR", &self.B_STAR());
      ds.field("MEAN_MOTION_DOT", &self.MEAN_MOTION_DOT());
      ds.field("MEAN_MOTION_DDOT", &self.MEAN_MOTION_DDOT());
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("PERIOD", &self.PERIOD());
      ds.field("APOGEE", &self.APOGEE());
      ds.field("PERIGEE", &self.PERIGEE());
      ds.field("LINE1", &self.LINE1());
      ds.field("LINE2", &self.LINE2());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MFET {
  pub ID: Option<String>,
  pub TMP_SAT_NO: i32,
  pub EPOCH: Option<String>,
  pub MEAN_MOTION: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RAAN: f64,
  pub ARG_OF_PERIGEE: f64,
  pub MEAN_ANOMALY: f64,
  pub REV_NO: i32,
  pub B_STAR: f64,
  pub MEAN_MOTION_DOT: f64,
  pub MEAN_MOTION_DDOT: f64,
  pub SEMI_MAJOR_AXIS: f64,
  pub PERIOD: f64,
  pub APOGEE: f64,
  pub PERIGEE: f64,
  pub LINE1: Option<String>,
  pub LINE2: Option<String>,
}
impl Default for MFET {
  fn default() -> Self {
    Self {
      ID: None,
      TMP_SAT_NO: 0,
      EPOCH: None,
      MEAN_MOTION: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RAAN: 0.0,
      ARG_OF_PERIGEE: 0.0,
      MEAN_ANOMALY: 0.0,
      REV_NO: 0,
      B_STAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      PERIOD: 0.0,
      APOGEE: 0.0,
      PERIGEE: 0.0,
      LINE1: None,
      LINE2: None,
    }
  }
}
impl MFET {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MFE<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TMP_SAT_NO = self.TMP_SAT_NO;
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEAN_MOTION = self.MEAN_MOTION;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RAAN = self.RAAN;
    let ARG_OF_PERIGEE = self.ARG_OF_PERIGEE;
    let MEAN_ANOMALY = self.MEAN_ANOMALY;
    let REV_NO = self.REV_NO;
    let B_STAR = self.B_STAR;
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT;
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT;
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let PERIOD = self.PERIOD;
    let APOGEE = self.APOGEE;
    let PERIGEE = self.PERIGEE;
    let LINE1 = self.LINE1.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LINE2 = self.LINE2.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MFE::create(_fbb, &MFEArgs{
      ID,
      TMP_SAT_NO,
      EPOCH,
      MEAN_MOTION,
      ECCENTRICITY,
      INCLINATION,
      RAAN,
      ARG_OF_PERIGEE,
      MEAN_ANOMALY,
      REV_NO,
      B_STAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      SEMI_MAJOR_AXIS,
      PERIOD,
      APOGEE,
      PERIGEE,
      LINE1,
      LINE2,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `MFE`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MFE_unchecked`.
pub fn root_as_MFE(buf: &[u8]) -> Result<MFE, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MFE>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MFE` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_MFE_unchecked`.
pub fn size_prefixed_root_as_MFE(buf: &[u8]) -> Result<MFE, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MFE>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MFE` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MFE_unchecked`.
pub fn root_as_MFE_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MFE<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MFE<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MFE` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_MFE_unchecked`.
pub fn size_prefixed_root_as_MFE_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MFE<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MFE<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MFE and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MFE`.
pub unsafe fn root_as_MFE_unchecked(buf: &[u8]) -> MFE {
  flatbuffers::root_unchecked::<MFE>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MFE and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MFE`.
pub unsafe fn size_prefixed_root_as_MFE_unchecked(buf: &[u8]) -> MFE {
  flatbuffers::size_prefixed_root_unchecked::<MFE>(buf)
}
pub const MFE_IDENTIFIER: &str = "$MFE";

#[inline]
pub fn MFE_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MFE_IDENTIFIER, false)
}

#[inline]
pub fn MFE_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MFE_IDENTIFIER, true)
}

#[inline]
pub fn finish_MFE_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<MFE<'a>>) {
  fbb.finish(root, Some(MFE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_MFE_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<MFE<'a>>) {
  fbb.finish_size_prefixed(root, Some(MFE_IDENTIFIER));
}
