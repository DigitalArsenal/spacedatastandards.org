// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COM_MODULATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COM_MODULATION_TYPE: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COM_MODULATION_TYPE: [ComModulationType; 15] = [
  ComModulationType::AM,
  ComModulationType::FM,
  ComModulationType::PM,
  ComModulationType::BPSK,
  ComModulationType::QPSK,
  ComModulationType::PSK8,
  ComModulationType::QAM16,
  ComModulationType::QAM64,
  ComModulationType::QAM256,
  ComModulationType::FSK,
  ComModulationType::MSK,
  ComModulationType::OFDM,
  ComModulationType::SPREAD_SPECTRUM,
  ComModulationType::FHSS,
  ComModulationType::DSSS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComModulationType(pub i8);
#[allow(non_upper_case_globals)]
impl ComModulationType {
  pub const AM: Self = Self(0);
  pub const FM: Self = Self(1);
  pub const PM: Self = Self(2);
  pub const BPSK: Self = Self(3);
  pub const QPSK: Self = Self(4);
  pub const PSK8: Self = Self(5);
  pub const QAM16: Self = Self(6);
  pub const QAM64: Self = Self(7);
  pub const QAM256: Self = Self(8);
  pub const FSK: Self = Self(9);
  pub const MSK: Self = Self(10);
  pub const OFDM: Self = Self(11);
  pub const SPREAD_SPECTRUM: Self = Self(12);
  pub const FHSS: Self = Self(13);
  pub const DSSS: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AM,
    Self::FM,
    Self::PM,
    Self::BPSK,
    Self::QPSK,
    Self::PSK8,
    Self::QAM16,
    Self::QAM64,
    Self::QAM256,
    Self::FSK,
    Self::MSK,
    Self::OFDM,
    Self::SPREAD_SPECTRUM,
    Self::FHSS,
    Self::DSSS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AM => Some("AM"),
      Self::FM => Some("FM"),
      Self::PM => Some("PM"),
      Self::BPSK => Some("BPSK"),
      Self::QPSK => Some("QPSK"),
      Self::PSK8 => Some("PSK8"),
      Self::QAM16 => Some("QAM16"),
      Self::QAM64 => Some("QAM64"),
      Self::QAM256 => Some("QAM256"),
      Self::FSK => Some("FSK"),
      Self::MSK => Some("MSK"),
      Self::OFDM => Some("OFDM"),
      Self::SPREAD_SPECTRUM => Some("SPREAD_SPECTRUM"),
      Self::FHSS => Some("FHSS"),
      Self::DSSS => Some("DSSS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ComModulationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComModulationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ComModulationType {
    type Output = ComModulationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ComModulationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComModulationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComModulationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BAND_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BAND_TYPE: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BAND_TYPE: [BandType; 13] = [
  BandType::HF,
  BandType::VHF,
  BandType::UHF,
  BandType::L_BAND,
  BandType::S_BAND,
  BandType::C_BAND,
  BandType::X_BAND,
  BandType::KU_BAND,
  BandType::K_BAND,
  BandType::KA_BAND,
  BandType::V_BAND,
  BandType::W_BAND,
  BandType::MM_WAVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BandType(pub i8);
#[allow(non_upper_case_globals)]
impl BandType {
  pub const HF: Self = Self(0);
  pub const VHF: Self = Self(1);
  pub const UHF: Self = Self(2);
  pub const L_BAND: Self = Self(3);
  pub const S_BAND: Self = Self(4);
  pub const C_BAND: Self = Self(5);
  pub const X_BAND: Self = Self(6);
  pub const KU_BAND: Self = Self(7);
  pub const K_BAND: Self = Self(8);
  pub const KA_BAND: Self = Self(9);
  pub const V_BAND: Self = Self(10);
  pub const W_BAND: Self = Self(11);
  pub const MM_WAVE: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HF,
    Self::VHF,
    Self::UHF,
    Self::L_BAND,
    Self::S_BAND,
    Self::C_BAND,
    Self::X_BAND,
    Self::KU_BAND,
    Self::K_BAND,
    Self::KA_BAND,
    Self::V_BAND,
    Self::W_BAND,
    Self::MM_WAVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HF => Some("HF"),
      Self::VHF => Some("VHF"),
      Self::UHF => Some("UHF"),
      Self::L_BAND => Some("L_BAND"),
      Self::S_BAND => Some("S_BAND"),
      Self::C_BAND => Some("C_BAND"),
      Self::X_BAND => Some("X_BAND"),
      Self::KU_BAND => Some("KU_BAND"),
      Self::K_BAND => Some("K_BAND"),
      Self::KA_BAND => Some("KA_BAND"),
      Self::V_BAND => Some("V_BAND"),
      Self::W_BAND => Some("W_BAND"),
      Self::MM_WAVE => Some("MM_WAVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BandType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BandType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BandType {
    type Output = BandType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BandType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BandType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BandType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROPAGATION_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROPAGATION_MODEL: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROPAGATION_MODEL: [PropagationModel; 13] = [
  PropagationModel::FREE_SPACE,
  PropagationModel::TWO_RAY_GROUND,
  PropagationModel::HATA_URBAN,
  PropagationModel::HATA_SUBURBAN,
  PropagationModel::COST231,
  PropagationModel::ITU_R_P525,
  PropagationModel::ITU_R_P676,
  PropagationModel::ITU_R_P838,
  PropagationModel::ITU_R_P840,
  PropagationModel::LONGLEY_RICE,
  PropagationModel::OKUMURA,
  PropagationModel::LOG_DISTANCE,
  PropagationModel::TERRAIN_INTEGRATED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PropagationModel(pub i8);
#[allow(non_upper_case_globals)]
impl PropagationModel {
  pub const FREE_SPACE: Self = Self(0);
  pub const TWO_RAY_GROUND: Self = Self(1);
  pub const HATA_URBAN: Self = Self(2);
  pub const HATA_SUBURBAN: Self = Self(3);
  pub const COST231: Self = Self(4);
  pub const ITU_R_P525: Self = Self(5);
  pub const ITU_R_P676: Self = Self(6);
  pub const ITU_R_P838: Self = Self(7);
  pub const ITU_R_P840: Self = Self(8);
  pub const LONGLEY_RICE: Self = Self(9);
  pub const OKUMURA: Self = Self(10);
  pub const LOG_DISTANCE: Self = Self(11);
  pub const TERRAIN_INTEGRATED: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FREE_SPACE,
    Self::TWO_RAY_GROUND,
    Self::HATA_URBAN,
    Self::HATA_SUBURBAN,
    Self::COST231,
    Self::ITU_R_P525,
    Self::ITU_R_P676,
    Self::ITU_R_P838,
    Self::ITU_R_P840,
    Self::LONGLEY_RICE,
    Self::OKUMURA,
    Self::LOG_DISTANCE,
    Self::TERRAIN_INTEGRATED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FREE_SPACE => Some("FREE_SPACE"),
      Self::TWO_RAY_GROUND => Some("TWO_RAY_GROUND"),
      Self::HATA_URBAN => Some("HATA_URBAN"),
      Self::HATA_SUBURBAN => Some("HATA_SUBURBAN"),
      Self::COST231 => Some("COST231"),
      Self::ITU_R_P525 => Some("ITU_R_P525"),
      Self::ITU_R_P676 => Some("ITU_R_P676"),
      Self::ITU_R_P838 => Some("ITU_R_P838"),
      Self::ITU_R_P840 => Some("ITU_R_P840"),
      Self::LONGLEY_RICE => Some("LONGLEY_RICE"),
      Self::OKUMURA => Some("OKUMURA"),
      Self::LOG_DISTANCE => Some("LOG_DISTANCE"),
      Self::TERRAIN_INTEGRATED => Some("TERRAIN_INTEGRATED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PropagationModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PropagationModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PropagationModel {
    type Output = PropagationModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PropagationModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PropagationModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PropagationModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_LINK_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_LINK_TYPE: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_LINK_TYPE: [DataLinkType; 15] = [
  DataLinkType::LINK_16,
  DataLinkType::LINK_11,
  DataLinkType::LINK_22,
  DataLinkType::CDL,
  DataLinkType::TCDL,
  DataLinkType::SADL,
  DataLinkType::IFDL,
  DataLinkType::VMF,
  DataLinkType::JREAP,
  DataLinkType::SATCOM,
  DataLinkType::ADS_B,
  DataLinkType::AIS,
  DataLinkType::HAVEQUICK,
  DataLinkType::SINCGARS,
  DataLinkType::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataLinkType(pub i8);
#[allow(non_upper_case_globals)]
impl DataLinkType {
  pub const LINK_16: Self = Self(0);
  pub const LINK_11: Self = Self(1);
  pub const LINK_22: Self = Self(2);
  pub const CDL: Self = Self(3);
  pub const TCDL: Self = Self(4);
  pub const SADL: Self = Self(5);
  pub const IFDL: Self = Self(6);
  pub const VMF: Self = Self(7);
  pub const JREAP: Self = Self(8);
  pub const SATCOM: Self = Self(9);
  pub const ADS_B: Self = Self(10);
  pub const AIS: Self = Self(11);
  pub const HAVEQUICK: Self = Self(12);
  pub const SINCGARS: Self = Self(13);
  pub const CUSTOM: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINK_16,
    Self::LINK_11,
    Self::LINK_22,
    Self::CDL,
    Self::TCDL,
    Self::SADL,
    Self::IFDL,
    Self::VMF,
    Self::JREAP,
    Self::SATCOM,
    Self::ADS_B,
    Self::AIS,
    Self::HAVEQUICK,
    Self::SINCGARS,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LINK_16 => Some("LINK_16"),
      Self::LINK_11 => Some("LINK_11"),
      Self::LINK_22 => Some("LINK_22"),
      Self::CDL => Some("CDL"),
      Self::TCDL => Some("TCDL"),
      Self::SADL => Some("SADL"),
      Self::IFDL => Some("IFDL"),
      Self::VMF => Some("VMF"),
      Self::JREAP => Some("JREAP"),
      Self::SATCOM => Some("SATCOM"),
      Self::ADS_B => Some("ADS_B"),
      Self::AIS => Some("AIS"),
      Self::HAVEQUICK => Some("HAVEQUICK"),
      Self::SINCGARS => Some("SINCGARS"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataLinkType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataLinkType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataLinkType {
    type Output = DataLinkType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataLinkType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataLinkType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataLinkType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANTENNA_PATTERN: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANTENNA_PATTERN: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANTENNA_PATTERN: [AntennaPattern; 12] = [
  AntennaPattern::ISOTROPIC,
  AntennaPattern::DIPOLE,
  AntennaPattern::YAGI,
  AntennaPattern::PARABOLIC,
  AntennaPattern::PHASED_ARRAY,
  AntennaPattern::HORN,
  AntennaPattern::PATCH,
  AntennaPattern::HELICAL,
  AntennaPattern::LOG_PERIODIC,
  AntennaPattern::OMNIDIRECTIONAL,
  AntennaPattern::SECTOR,
  AntennaPattern::CUSTOM_PATTERN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AntennaPattern(pub i8);
#[allow(non_upper_case_globals)]
impl AntennaPattern {
  pub const ISOTROPIC: Self = Self(0);
  pub const DIPOLE: Self = Self(1);
  pub const YAGI: Self = Self(2);
  pub const PARABOLIC: Self = Self(3);
  pub const PHASED_ARRAY: Self = Self(4);
  pub const HORN: Self = Self(5);
  pub const PATCH: Self = Self(6);
  pub const HELICAL: Self = Self(7);
  pub const LOG_PERIODIC: Self = Self(8);
  pub const OMNIDIRECTIONAL: Self = Self(9);
  pub const SECTOR: Self = Self(10);
  pub const CUSTOM_PATTERN: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ISOTROPIC,
    Self::DIPOLE,
    Self::YAGI,
    Self::PARABOLIC,
    Self::PHASED_ARRAY,
    Self::HORN,
    Self::PATCH,
    Self::HELICAL,
    Self::LOG_PERIODIC,
    Self::OMNIDIRECTIONAL,
    Self::SECTOR,
    Self::CUSTOM_PATTERN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ISOTROPIC => Some("ISOTROPIC"),
      Self::DIPOLE => Some("DIPOLE"),
      Self::YAGI => Some("YAGI"),
      Self::PARABOLIC => Some("PARABOLIC"),
      Self::PHASED_ARRAY => Some("PHASED_ARRAY"),
      Self::HORN => Some("HORN"),
      Self::PATCH => Some("PATCH"),
      Self::HELICAL => Some("HELICAL"),
      Self::LOG_PERIODIC => Some("LOG_PERIODIC"),
      Self::OMNIDIRECTIONAL => Some("OMNIDIRECTIONAL"),
      Self::SECTOR => Some("SECTOR"),
      Self::CUSTOM_PATTERN => Some("CUSTOM_PATTERN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AntennaPattern {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AntennaPattern {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AntennaPattern {
    type Output = AntennaPattern;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AntennaPattern {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AntennaPattern {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AntennaPattern {}
pub enum COMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Communications Systems
pub struct COM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for COM<'a> {
  type Inner = COM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> COM<'a> {
  pub const VT_SYSTEM_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IS_TRANSMITTING: flatbuffers::VOffsetT = 8;
  pub const VT_IS_RECEIVING: flatbuffers::VOffsetT = 10;
  pub const VT_CURRENT_FREQUENCY_HZ: flatbuffers::VOffsetT = 12;
  pub const VT_CURRENT_POWER_WATTS: flatbuffers::VOffsetT = 14;
  pub const VT_CURRENT_DATA_RATE_BPS: flatbuffers::VOffsetT = 16;
  pub const VT_MESSAGES_SENT: flatbuffers::VOffsetT = 18;
  pub const VT_MESSAGES_RECEIVED: flatbuffers::VOffsetT = 20;
  pub const VT_BYTES_SENT: flatbuffers::VOffsetT = 22;
  pub const VT_BYTES_RECEIVED: flatbuffers::VOffsetT = 24;
  pub const VT_CONNECTED_NODES: flatbuffers::VOffsetT = 26;
  pub const VT_ACTIVE_LINKS: flatbuffers::VOffsetT = 28;
  pub const VT_LAST_UPDATE_MS: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    COM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args COMArgs<'args>
  ) -> flatbuffers::WIPOffset<COM<'bldr>> {
    let mut builder = COMBuilder::new(_fbb);
    builder.add_LAST_UPDATE_MS(args.LAST_UPDATE_MS);
    builder.add_BYTES_RECEIVED(args.BYTES_RECEIVED);
    builder.add_BYTES_SENT(args.BYTES_SENT);
    builder.add_MESSAGES_RECEIVED(args.MESSAGES_RECEIVED);
    builder.add_MESSAGES_SENT(args.MESSAGES_SENT);
    builder.add_CURRENT_DATA_RATE_BPS(args.CURRENT_DATA_RATE_BPS);
    builder.add_CURRENT_POWER_WATTS(args.CURRENT_POWER_WATTS);
    builder.add_CURRENT_FREQUENCY_HZ(args.CURRENT_FREQUENCY_HZ);
    if let Some(x) = args.ACTIVE_LINKS { builder.add_ACTIVE_LINKS(x); }
    if let Some(x) = args.CONNECTED_NODES { builder.add_CONNECTED_NODES(x); }
    builder.add_ENTITY_ID(args.ENTITY_ID);
    builder.add_SYSTEM_ID(args.SYSTEM_ID);
    builder.add_IS_RECEIVING(args.IS_RECEIVING);
    builder.add_IS_TRANSMITTING(args.IS_TRANSMITTING);
    builder.finish()
  }

  pub fn unpack(&self) -> COMT {
    let SYSTEM_ID = self.SYSTEM_ID();
    let ENTITY_ID = self.ENTITY_ID();
    let IS_TRANSMITTING = self.IS_TRANSMITTING();
    let IS_RECEIVING = self.IS_RECEIVING();
    let CURRENT_FREQUENCY_HZ = self.CURRENT_FREQUENCY_HZ();
    let CURRENT_POWER_WATTS = self.CURRENT_POWER_WATTS();
    let CURRENT_DATA_RATE_BPS = self.CURRENT_DATA_RATE_BPS();
    let MESSAGES_SENT = self.MESSAGES_SENT();
    let MESSAGES_RECEIVED = self.MESSAGES_RECEIVED();
    let BYTES_SENT = self.BYTES_SENT();
    let BYTES_RECEIVED = self.BYTES_RECEIVED();
    let CONNECTED_NODES = self.CONNECTED_NODES().map(|x| {
      x.into_iter().collect()
    });
    let ACTIVE_LINKS = self.ACTIVE_LINKS().map(|x| {
      x.into_iter().collect()
    });
    let LAST_UPDATE_MS = self.LAST_UPDATE_MS();
    COMT {
      SYSTEM_ID,
      ENTITY_ID,
      IS_TRANSMITTING,
      IS_RECEIVING,
      CURRENT_FREQUENCY_HZ,
      CURRENT_POWER_WATTS,
      CURRENT_DATA_RATE_BPS,
      MESSAGES_SENT,
      MESSAGES_RECEIVED,
      BYTES_SENT,
      BYTES_RECEIVED,
      CONNECTED_NODES,
      ACTIVE_LINKS,
      LAST_UPDATE_MS,
    }
  }

  #[inline]
  pub fn SYSTEM_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(COM::VT_SYSTEM_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ENTITY_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(COM::VT_ENTITY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn IS_TRANSMITTING(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(COM::VT_IS_TRANSMITTING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn IS_RECEIVING(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(COM::VT_IS_RECEIVING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn CURRENT_FREQUENCY_HZ(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COM::VT_CURRENT_FREQUENCY_HZ, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CURRENT_POWER_WATTS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COM::VT_CURRENT_POWER_WATTS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CURRENT_DATA_RATE_BPS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(COM::VT_CURRENT_DATA_RATE_BPS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MESSAGES_SENT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(COM::VT_MESSAGES_SENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn MESSAGES_RECEIVED(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(COM::VT_MESSAGES_RECEIVED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BYTES_SENT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(COM::VT_BYTES_SENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BYTES_RECEIVED(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(COM::VT_BYTES_RECEIVED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn CONNECTED_NODES(&self) -> Option<flatbuffers::Vector<'a, u32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(COM::VT_CONNECTED_NODES, None)}
  }
  #[inline]
  pub fn ACTIVE_LINKS(&self) -> Option<flatbuffers::Vector<'a, DataLinkType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, DataLinkType>>>(COM::VT_ACTIVE_LINKS, None)}
  }
  #[inline]
  pub fn LAST_UPDATE_MS(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(COM::VT_LAST_UPDATE_MS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for COM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("SYSTEM_ID", Self::VT_SYSTEM_ID, false)?
     .visit_field::<u32>("ENTITY_ID", Self::VT_ENTITY_ID, false)?
     .visit_field::<bool>("IS_TRANSMITTING", Self::VT_IS_TRANSMITTING, false)?
     .visit_field::<bool>("IS_RECEIVING", Self::VT_IS_RECEIVING, false)?
     .visit_field::<f64>("CURRENT_FREQUENCY_HZ", Self::VT_CURRENT_FREQUENCY_HZ, false)?
     .visit_field::<f64>("CURRENT_POWER_WATTS", Self::VT_CURRENT_POWER_WATTS, false)?
     .visit_field::<f64>("CURRENT_DATA_RATE_BPS", Self::VT_CURRENT_DATA_RATE_BPS, false)?
     .visit_field::<u64>("MESSAGES_SENT", Self::VT_MESSAGES_SENT, false)?
     .visit_field::<u64>("MESSAGES_RECEIVED", Self::VT_MESSAGES_RECEIVED, false)?
     .visit_field::<u64>("BYTES_SENT", Self::VT_BYTES_SENT, false)?
     .visit_field::<u64>("BYTES_RECEIVED", Self::VT_BYTES_RECEIVED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>("CONNECTED_NODES", Self::VT_CONNECTED_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, DataLinkType>>>("ACTIVE_LINKS", Self::VT_ACTIVE_LINKS, false)?
     .visit_field::<i64>("LAST_UPDATE_MS", Self::VT_LAST_UPDATE_MS, false)?
     .finish();
    Ok(())
  }
}
pub struct COMArgs<'a> {
    pub SYSTEM_ID: u32,
    pub ENTITY_ID: u32,
    pub IS_TRANSMITTING: bool,
    pub IS_RECEIVING: bool,
    pub CURRENT_FREQUENCY_HZ: f64,
    pub CURRENT_POWER_WATTS: f64,
    pub CURRENT_DATA_RATE_BPS: f64,
    pub MESSAGES_SENT: u64,
    pub MESSAGES_RECEIVED: u64,
    pub BYTES_SENT: u64,
    pub BYTES_RECEIVED: u64,
    pub CONNECTED_NODES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub ACTIVE_LINKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, DataLinkType>>>,
    pub LAST_UPDATE_MS: i64,
}
impl<'a> Default for COMArgs<'a> {
  #[inline]
  fn default() -> Self {
    COMArgs {
      SYSTEM_ID: 0,
      ENTITY_ID: 0,
      IS_TRANSMITTING: false,
      IS_RECEIVING: false,
      CURRENT_FREQUENCY_HZ: 0.0,
      CURRENT_POWER_WATTS: 0.0,
      CURRENT_DATA_RATE_BPS: 0.0,
      MESSAGES_SENT: 0,
      MESSAGES_RECEIVED: 0,
      BYTES_SENT: 0,
      BYTES_RECEIVED: 0,
      CONNECTED_NODES: None,
      ACTIVE_LINKS: None,
      LAST_UPDATE_MS: 0,
    }
  }
}

pub struct COMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> COMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SYSTEM_ID(&mut self, SYSTEM_ID: u32) {
    self.fbb_.push_slot::<u32>(COM::VT_SYSTEM_ID, SYSTEM_ID, 0);
  }
  #[inline]
  pub fn add_ENTITY_ID(&mut self, ENTITY_ID: u32) {
    self.fbb_.push_slot::<u32>(COM::VT_ENTITY_ID, ENTITY_ID, 0);
  }
  #[inline]
  pub fn add_IS_TRANSMITTING(&mut self, IS_TRANSMITTING: bool) {
    self.fbb_.push_slot::<bool>(COM::VT_IS_TRANSMITTING, IS_TRANSMITTING, false);
  }
  #[inline]
  pub fn add_IS_RECEIVING(&mut self, IS_RECEIVING: bool) {
    self.fbb_.push_slot::<bool>(COM::VT_IS_RECEIVING, IS_RECEIVING, false);
  }
  #[inline]
  pub fn add_CURRENT_FREQUENCY_HZ(&mut self, CURRENT_FREQUENCY_HZ: f64) {
    self.fbb_.push_slot::<f64>(COM::VT_CURRENT_FREQUENCY_HZ, CURRENT_FREQUENCY_HZ, 0.0);
  }
  #[inline]
  pub fn add_CURRENT_POWER_WATTS(&mut self, CURRENT_POWER_WATTS: f64) {
    self.fbb_.push_slot::<f64>(COM::VT_CURRENT_POWER_WATTS, CURRENT_POWER_WATTS, 0.0);
  }
  #[inline]
  pub fn add_CURRENT_DATA_RATE_BPS(&mut self, CURRENT_DATA_RATE_BPS: f64) {
    self.fbb_.push_slot::<f64>(COM::VT_CURRENT_DATA_RATE_BPS, CURRENT_DATA_RATE_BPS, 0.0);
  }
  #[inline]
  pub fn add_MESSAGES_SENT(&mut self, MESSAGES_SENT: u64) {
    self.fbb_.push_slot::<u64>(COM::VT_MESSAGES_SENT, MESSAGES_SENT, 0);
  }
  #[inline]
  pub fn add_MESSAGES_RECEIVED(&mut self, MESSAGES_RECEIVED: u64) {
    self.fbb_.push_slot::<u64>(COM::VT_MESSAGES_RECEIVED, MESSAGES_RECEIVED, 0);
  }
  #[inline]
  pub fn add_BYTES_SENT(&mut self, BYTES_SENT: u64) {
    self.fbb_.push_slot::<u64>(COM::VT_BYTES_SENT, BYTES_SENT, 0);
  }
  #[inline]
  pub fn add_BYTES_RECEIVED(&mut self, BYTES_RECEIVED: u64) {
    self.fbb_.push_slot::<u64>(COM::VT_BYTES_RECEIVED, BYTES_RECEIVED, 0);
  }
  #[inline]
  pub fn add_CONNECTED_NODES(&mut self, CONNECTED_NODES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COM::VT_CONNECTED_NODES, CONNECTED_NODES);
  }
  #[inline]
  pub fn add_ACTIVE_LINKS(&mut self, ACTIVE_LINKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , DataLinkType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(COM::VT_ACTIVE_LINKS, ACTIVE_LINKS);
  }
  #[inline]
  pub fn add_LAST_UPDATE_MS(&mut self, LAST_UPDATE_MS: i64) {
    self.fbb_.push_slot::<i64>(COM::VT_LAST_UPDATE_MS, LAST_UPDATE_MS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> COMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    COMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<COM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for COM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("COM");
      ds.field("SYSTEM_ID", &self.SYSTEM_ID());
      ds.field("ENTITY_ID", &self.ENTITY_ID());
      ds.field("IS_TRANSMITTING", &self.IS_TRANSMITTING());
      ds.field("IS_RECEIVING", &self.IS_RECEIVING());
      ds.field("CURRENT_FREQUENCY_HZ", &self.CURRENT_FREQUENCY_HZ());
      ds.field("CURRENT_POWER_WATTS", &self.CURRENT_POWER_WATTS());
      ds.field("CURRENT_DATA_RATE_BPS", &self.CURRENT_DATA_RATE_BPS());
      ds.field("MESSAGES_SENT", &self.MESSAGES_SENT());
      ds.field("MESSAGES_RECEIVED", &self.MESSAGES_RECEIVED());
      ds.field("BYTES_SENT", &self.BYTES_SENT());
      ds.field("BYTES_RECEIVED", &self.BYTES_RECEIVED());
      ds.field("CONNECTED_NODES", &self.CONNECTED_NODES());
      ds.field("ACTIVE_LINKS", &self.ACTIVE_LINKS());
      ds.field("LAST_UPDATE_MS", &self.LAST_UPDATE_MS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct COMT {
  pub SYSTEM_ID: u32,
  pub ENTITY_ID: u32,
  pub IS_TRANSMITTING: bool,
  pub IS_RECEIVING: bool,
  pub CURRENT_FREQUENCY_HZ: f64,
  pub CURRENT_POWER_WATTS: f64,
  pub CURRENT_DATA_RATE_BPS: f64,
  pub MESSAGES_SENT: u64,
  pub MESSAGES_RECEIVED: u64,
  pub BYTES_SENT: u64,
  pub BYTES_RECEIVED: u64,
  pub CONNECTED_NODES: Option<Vec<u32>>,
  pub ACTIVE_LINKS: Option<Vec<DataLinkType>>,
  pub LAST_UPDATE_MS: i64,
}
impl Default for COMT {
  fn default() -> Self {
    Self {
      SYSTEM_ID: 0,
      ENTITY_ID: 0,
      IS_TRANSMITTING: false,
      IS_RECEIVING: false,
      CURRENT_FREQUENCY_HZ: 0.0,
      CURRENT_POWER_WATTS: 0.0,
      CURRENT_DATA_RATE_BPS: 0.0,
      MESSAGES_SENT: 0,
      MESSAGES_RECEIVED: 0,
      BYTES_SENT: 0,
      BYTES_RECEIVED: 0,
      CONNECTED_NODES: None,
      ACTIVE_LINKS: None,
      LAST_UPDATE_MS: 0,
    }
  }
}
impl COMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<COM<'b>> {
    let SYSTEM_ID = self.SYSTEM_ID;
    let ENTITY_ID = self.ENTITY_ID;
    let IS_TRANSMITTING = self.IS_TRANSMITTING;
    let IS_RECEIVING = self.IS_RECEIVING;
    let CURRENT_FREQUENCY_HZ = self.CURRENT_FREQUENCY_HZ;
    let CURRENT_POWER_WATTS = self.CURRENT_POWER_WATTS;
    let CURRENT_DATA_RATE_BPS = self.CURRENT_DATA_RATE_BPS;
    let MESSAGES_SENT = self.MESSAGES_SENT;
    let MESSAGES_RECEIVED = self.MESSAGES_RECEIVED;
    let BYTES_SENT = self.BYTES_SENT;
    let BYTES_RECEIVED = self.BYTES_RECEIVED;
    let CONNECTED_NODES = self.CONNECTED_NODES.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ACTIVE_LINKS = self.ACTIVE_LINKS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let LAST_UPDATE_MS = self.LAST_UPDATE_MS;
    COM::create(_fbb, &COMArgs{
      SYSTEM_ID,
      ENTITY_ID,
      IS_TRANSMITTING,
      IS_RECEIVING,
      CURRENT_FREQUENCY_HZ,
      CURRENT_POWER_WATTS,
      CURRENT_DATA_RATE_BPS,
      MESSAGES_SENT,
      MESSAGES_RECEIVED,
      BYTES_SENT,
      BYTES_RECEIVED,
      CONNECTED_NODES,
      ACTIVE_LINKS,
      LAST_UPDATE_MS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `COM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COM_unchecked`.
pub fn root_as_COM(buf: &[u8]) -> Result<COM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<COM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `COM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_COM_unchecked`.
pub fn size_prefixed_root_as_COM(buf: &[u8]) -> Result<COM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<COM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `COM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COM_unchecked`.
pub fn root_as_COM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<COM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<COM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `COM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_COM_unchecked`.
pub fn size_prefixed_root_as_COM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<COM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<COM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a COM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `COM`.
pub unsafe fn root_as_COM_unchecked(buf: &[u8]) -> COM {
  flatbuffers::root_unchecked::<COM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed COM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `COM`.
pub unsafe fn size_prefixed_root_as_COM_unchecked(buf: &[u8]) -> COM {
  flatbuffers::size_prefixed_root_unchecked::<COM>(buf)
}
pub const COM_IDENTIFIER: &str = "$COM";

#[inline]
pub fn COM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COM_IDENTIFIER, false)
}

#[inline]
pub fn COM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, COM_IDENTIFIER, true)
}

#[inline]
pub fn finish_COM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<COM<'a>>) {
  fbb.finish(root, Some(COM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_COM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<COM<'a>>) {
  fbb.finish_size_prefixed(root, Some(COM_IDENTIFIER));
}
