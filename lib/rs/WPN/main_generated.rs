// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_WEAPON_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_WEAPON_TYPE: i8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_WEAPON_TYPE: [WeaponType; 14] = [
  WeaponType::MG_SMALL,
  WeaponType::MG_HEAVY,
  WeaponType::AUTOCANNON,
  WeaponType::CANNON,
  WeaponType::TANK_GUN,
  WeaponType::ARTILLERY,
  WeaponType::MORTAR,
  WeaponType::ROCKET_UNGUIDED,
  WeaponType::BOMB_DUMB,
  WeaponType::BOMB_GUIDED,
  WeaponType::TORPEDO,
  WeaponType::DEPTH_CHARGE,
  WeaponType::MINE,
  WeaponType::GRENADE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct WeaponType(pub i8);
#[allow(non_upper_case_globals)]
impl WeaponType {
  pub const MG_SMALL: Self = Self(0);
  pub const MG_HEAVY: Self = Self(1);
  pub const AUTOCANNON: Self = Self(2);
  pub const CANNON: Self = Self(3);
  pub const TANK_GUN: Self = Self(4);
  pub const ARTILLERY: Self = Self(5);
  pub const MORTAR: Self = Self(6);
  pub const ROCKET_UNGUIDED: Self = Self(7);
  pub const BOMB_DUMB: Self = Self(8);
  pub const BOMB_GUIDED: Self = Self(9);
  pub const TORPEDO: Self = Self(10);
  pub const DEPTH_CHARGE: Self = Self(11);
  pub const MINE: Self = Self(12);
  pub const GRENADE: Self = Self(13);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MG_SMALL,
    Self::MG_HEAVY,
    Self::AUTOCANNON,
    Self::CANNON,
    Self::TANK_GUN,
    Self::ARTILLERY,
    Self::MORTAR,
    Self::ROCKET_UNGUIDED,
    Self::BOMB_DUMB,
    Self::BOMB_GUIDED,
    Self::TORPEDO,
    Self::DEPTH_CHARGE,
    Self::MINE,
    Self::GRENADE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MG_SMALL => Some("MG_SMALL"),
      Self::MG_HEAVY => Some("MG_HEAVY"),
      Self::AUTOCANNON => Some("AUTOCANNON"),
      Self::CANNON => Some("CANNON"),
      Self::TANK_GUN => Some("TANK_GUN"),
      Self::ARTILLERY => Some("ARTILLERY"),
      Self::MORTAR => Some("MORTAR"),
      Self::ROCKET_UNGUIDED => Some("ROCKET_UNGUIDED"),
      Self::BOMB_DUMB => Some("BOMB_DUMB"),
      Self::BOMB_GUIDED => Some("BOMB_GUIDED"),
      Self::TORPEDO => Some("TORPEDO"),
      Self::DEPTH_CHARGE => Some("DEPTH_CHARGE"),
      Self::MINE => Some("MINE"),
      Self::GRENADE => Some("GRENADE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for WeaponType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for WeaponType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for WeaponType {
    type Output = WeaponType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for WeaponType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for WeaponType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WeaponType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FUZE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FUZE_TYPE: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FUZE_TYPE: [FuzeType; 8] = [
  FuzeType::CONTACT,
  FuzeType::DELAY,
  FuzeType::TIMED,
  FuzeType::PROXIMITY,
  FuzeType::AIRBURST,
  FuzeType::MAGNETIC,
  FuzeType::PRESSURE,
  FuzeType::SEISMIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FuzeType(pub i8);
#[allow(non_upper_case_globals)]
impl FuzeType {
  pub const CONTACT: Self = Self(0);
  pub const DELAY: Self = Self(1);
  pub const TIMED: Self = Self(2);
  pub const PROXIMITY: Self = Self(3);
  pub const AIRBURST: Self = Self(4);
  pub const MAGNETIC: Self = Self(5);
  pub const PRESSURE: Self = Self(6);
  pub const SEISMIC: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CONTACT,
    Self::DELAY,
    Self::TIMED,
    Self::PROXIMITY,
    Self::AIRBURST,
    Self::MAGNETIC,
    Self::PRESSURE,
    Self::SEISMIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CONTACT => Some("CONTACT"),
      Self::DELAY => Some("DELAY"),
      Self::TIMED => Some("TIMED"),
      Self::PROXIMITY => Some("PROXIMITY"),
      Self::AIRBURST => Some("AIRBURST"),
      Self::MAGNETIC => Some("MAGNETIC"),
      Self::PRESSURE => Some("PRESSURE"),
      Self::SEISMIC => Some("SEISMIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FuzeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FuzeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FuzeType {
    type Output = FuzeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FuzeType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FuzeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FuzeType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROJECTILE_PHASE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROJECTILE_PHASE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROJECTILE_PHASE: [ProjectilePhase; 5] = [
  ProjectilePhase::LOADED,
  ProjectilePhase::IN_FLIGHT,
  ProjectilePhase::DETONATED,
  ProjectilePhase::DUD,
  ProjectilePhase::IMPACT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ProjectilePhase(pub i8);
#[allow(non_upper_case_globals)]
impl ProjectilePhase {
  pub const LOADED: Self = Self(0);
  pub const IN_FLIGHT: Self = Self(1);
  pub const DETONATED: Self = Self(2);
  pub const DUD: Self = Self(3);
  pub const IMPACT: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LOADED,
    Self::IN_FLIGHT,
    Self::DETONATED,
    Self::DUD,
    Self::IMPACT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LOADED => Some("LOADED"),
      Self::IN_FLIGHT => Some("IN_FLIGHT"),
      Self::DETONATED => Some("DETONATED"),
      Self::DUD => Some("DUD"),
      Self::IMPACT => Some("IMPACT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ProjectilePhase {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ProjectilePhase {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ProjectilePhase {
    type Output = ProjectilePhase;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ProjectilePhase {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ProjectilePhase {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ProjectilePhase {}
pub enum WPNOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Weapons and Munitions
pub struct WPN<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WPN<'a> {
  type Inner = WPN<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WPN<'a> {
  pub const VT_CALIBER: flatbuffers::VOffsetT = 4;
  pub const VT_MUZZLE_VELOCITY: flatbuffers::VOffsetT = 6;
  pub const VT_RATE_OF_FIRE: flatbuffers::VOffsetT = 8;
  pub const VT_DISPERSION: flatbuffers::VOffsetT = 10;
  pub const VT_AMMO_CAPACITY: flatbuffers::VOffsetT = 12;
  pub const VT_BURST_LENGTH: flatbuffers::VOffsetT = 14;
  pub const VT_RELOAD_TIME: flatbuffers::VOffsetT = 16;
  pub const VT_OVERHEAT_ROUNDS: flatbuffers::VOffsetT = 18;
  pub const VT_COOLDOWN_RATE: flatbuffers::VOffsetT = 20;
  pub const VT_ELEVATION_MIN: flatbuffers::VOffsetT = 22;
  pub const VT_ELEVATION_MAX: flatbuffers::VOffsetT = 24;
  pub const VT_TRAVERSE_MIN: flatbuffers::VOffsetT = 26;
  pub const VT_TRAVERSE_MAX: flatbuffers::VOffsetT = 28;
  pub const VT_SLEW_RATE: flatbuffers::VOffsetT = 30;
  pub const VT_WEAPON_TYPE: flatbuffers::VOffsetT = 32;
  pub const VT_FUZE_TYPE: flatbuffers::VOffsetT = 34;
  pub const VT_RESERVED: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WPN { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WPNArgs<'args>
  ) -> flatbuffers::WIPOffset<WPN<'bldr>> {
    let mut builder = WPNBuilder::new(_fbb);
    if let Some(x) = args.RESERVED { builder.add_RESERVED(x); }
    builder.add_SLEW_RATE(args.SLEW_RATE);
    builder.add_TRAVERSE_MAX(args.TRAVERSE_MAX);
    builder.add_TRAVERSE_MIN(args.TRAVERSE_MIN);
    builder.add_ELEVATION_MAX(args.ELEVATION_MAX);
    builder.add_ELEVATION_MIN(args.ELEVATION_MIN);
    builder.add_COOLDOWN_RATE(args.COOLDOWN_RATE);
    builder.add_RELOAD_TIME(args.RELOAD_TIME);
    builder.add_DISPERSION(args.DISPERSION);
    builder.add_RATE_OF_FIRE(args.RATE_OF_FIRE);
    builder.add_MUZZLE_VELOCITY(args.MUZZLE_VELOCITY);
    builder.add_CALIBER(args.CALIBER);
    builder.add_OVERHEAT_ROUNDS(args.OVERHEAT_ROUNDS);
    builder.add_BURST_LENGTH(args.BURST_LENGTH);
    builder.add_AMMO_CAPACITY(args.AMMO_CAPACITY);
    builder.add_FUZE_TYPE(args.FUZE_TYPE);
    builder.add_WEAPON_TYPE(args.WEAPON_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> WPNT {
    let CALIBER = self.CALIBER();
    let MUZZLE_VELOCITY = self.MUZZLE_VELOCITY();
    let RATE_OF_FIRE = self.RATE_OF_FIRE();
    let DISPERSION = self.DISPERSION();
    let AMMO_CAPACITY = self.AMMO_CAPACITY();
    let BURST_LENGTH = self.BURST_LENGTH();
    let RELOAD_TIME = self.RELOAD_TIME();
    let OVERHEAT_ROUNDS = self.OVERHEAT_ROUNDS();
    let COOLDOWN_RATE = self.COOLDOWN_RATE();
    let ELEVATION_MIN = self.ELEVATION_MIN();
    let ELEVATION_MAX = self.ELEVATION_MAX();
    let TRAVERSE_MIN = self.TRAVERSE_MIN();
    let TRAVERSE_MAX = self.TRAVERSE_MAX();
    let SLEW_RATE = self.SLEW_RATE();
    let WEAPON_TYPE = self.WEAPON_TYPE();
    let FUZE_TYPE = self.FUZE_TYPE();
    let RESERVED = self.RESERVED().map(|x| {
      x.into_iter().collect()
    });
    WPNT {
      CALIBER,
      MUZZLE_VELOCITY,
      RATE_OF_FIRE,
      DISPERSION,
      AMMO_CAPACITY,
      BURST_LENGTH,
      RELOAD_TIME,
      OVERHEAT_ROUNDS,
      COOLDOWN_RATE,
      ELEVATION_MIN,
      ELEVATION_MAX,
      TRAVERSE_MIN,
      TRAVERSE_MAX,
      SLEW_RATE,
      WEAPON_TYPE,
      FUZE_TYPE,
      RESERVED,
    }
  }

  #[inline]
  pub fn CALIBER(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_CALIBER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MUZZLE_VELOCITY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_MUZZLE_VELOCITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RATE_OF_FIRE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_RATE_OF_FIRE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DISPERSION(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_DISPERSION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AMMO_CAPACITY(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(WPN::VT_AMMO_CAPACITY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn BURST_LENGTH(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(WPN::VT_BURST_LENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RELOAD_TIME(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_RELOAD_TIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn OVERHEAT_ROUNDS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(WPN::VT_OVERHEAT_ROUNDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn COOLDOWN_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_COOLDOWN_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION_MIN(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_ELEVATION_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ELEVATION_MAX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_ELEVATION_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TRAVERSE_MIN(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_TRAVERSE_MIN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TRAVERSE_MAX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_TRAVERSE_MAX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SLEW_RATE(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WPN::VT_SLEW_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn WEAPON_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WPN::VT_WEAPON_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn FUZE_TYPE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WPN::VT_FUZE_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn RESERVED(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(WPN::VT_RESERVED, None)}
  }
}

impl flatbuffers::Verifiable for WPN<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("CALIBER", Self::VT_CALIBER, false)?
     .visit_field::<f32>("MUZZLE_VELOCITY", Self::VT_MUZZLE_VELOCITY, false)?
     .visit_field::<f32>("RATE_OF_FIRE", Self::VT_RATE_OF_FIRE, false)?
     .visit_field::<f32>("DISPERSION", Self::VT_DISPERSION, false)?
     .visit_field::<u16>("AMMO_CAPACITY", Self::VT_AMMO_CAPACITY, false)?
     .visit_field::<u16>("BURST_LENGTH", Self::VT_BURST_LENGTH, false)?
     .visit_field::<f32>("RELOAD_TIME", Self::VT_RELOAD_TIME, false)?
     .visit_field::<u16>("OVERHEAT_ROUNDS", Self::VT_OVERHEAT_ROUNDS, false)?
     .visit_field::<f32>("COOLDOWN_RATE", Self::VT_COOLDOWN_RATE, false)?
     .visit_field::<f32>("ELEVATION_MIN", Self::VT_ELEVATION_MIN, false)?
     .visit_field::<f32>("ELEVATION_MAX", Self::VT_ELEVATION_MAX, false)?
     .visit_field::<f32>("TRAVERSE_MIN", Self::VT_TRAVERSE_MIN, false)?
     .visit_field::<f32>("TRAVERSE_MAX", Self::VT_TRAVERSE_MAX, false)?
     .visit_field::<f32>("SLEW_RATE", Self::VT_SLEW_RATE, false)?
     .visit_field::<u8>("WEAPON_TYPE", Self::VT_WEAPON_TYPE, false)?
     .visit_field::<u8>("FUZE_TYPE", Self::VT_FUZE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("RESERVED", Self::VT_RESERVED, false)?
     .finish();
    Ok(())
  }
}
pub struct WPNArgs<'a> {
    pub CALIBER: f32,
    pub MUZZLE_VELOCITY: f32,
    pub RATE_OF_FIRE: f32,
    pub DISPERSION: f32,
    pub AMMO_CAPACITY: u16,
    pub BURST_LENGTH: u16,
    pub RELOAD_TIME: f32,
    pub OVERHEAT_ROUNDS: u16,
    pub COOLDOWN_RATE: f32,
    pub ELEVATION_MIN: f32,
    pub ELEVATION_MAX: f32,
    pub TRAVERSE_MIN: f32,
    pub TRAVERSE_MAX: f32,
    pub SLEW_RATE: f32,
    pub WEAPON_TYPE: u8,
    pub FUZE_TYPE: u8,
    pub RESERVED: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for WPNArgs<'a> {
  #[inline]
  fn default() -> Self {
    WPNArgs {
      CALIBER: 0.0,
      MUZZLE_VELOCITY: 0.0,
      RATE_OF_FIRE: 0.0,
      DISPERSION: 0.0,
      AMMO_CAPACITY: 0,
      BURST_LENGTH: 0,
      RELOAD_TIME: 0.0,
      OVERHEAT_ROUNDS: 0,
      COOLDOWN_RATE: 0.0,
      ELEVATION_MIN: 0.0,
      ELEVATION_MAX: 0.0,
      TRAVERSE_MIN: 0.0,
      TRAVERSE_MAX: 0.0,
      SLEW_RATE: 0.0,
      WEAPON_TYPE: 0,
      FUZE_TYPE: 0,
      RESERVED: None,
    }
  }
}

pub struct WPNBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WPNBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CALIBER(&mut self, CALIBER: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_CALIBER, CALIBER, 0.0);
  }
  #[inline]
  pub fn add_MUZZLE_VELOCITY(&mut self, MUZZLE_VELOCITY: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_MUZZLE_VELOCITY, MUZZLE_VELOCITY, 0.0);
  }
  #[inline]
  pub fn add_RATE_OF_FIRE(&mut self, RATE_OF_FIRE: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_RATE_OF_FIRE, RATE_OF_FIRE, 0.0);
  }
  #[inline]
  pub fn add_DISPERSION(&mut self, DISPERSION: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_DISPERSION, DISPERSION, 0.0);
  }
  #[inline]
  pub fn add_AMMO_CAPACITY(&mut self, AMMO_CAPACITY: u16) {
    self.fbb_.push_slot::<u16>(WPN::VT_AMMO_CAPACITY, AMMO_CAPACITY, 0);
  }
  #[inline]
  pub fn add_BURST_LENGTH(&mut self, BURST_LENGTH: u16) {
    self.fbb_.push_slot::<u16>(WPN::VT_BURST_LENGTH, BURST_LENGTH, 0);
  }
  #[inline]
  pub fn add_RELOAD_TIME(&mut self, RELOAD_TIME: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_RELOAD_TIME, RELOAD_TIME, 0.0);
  }
  #[inline]
  pub fn add_OVERHEAT_ROUNDS(&mut self, OVERHEAT_ROUNDS: u16) {
    self.fbb_.push_slot::<u16>(WPN::VT_OVERHEAT_ROUNDS, OVERHEAT_ROUNDS, 0);
  }
  #[inline]
  pub fn add_COOLDOWN_RATE(&mut self, COOLDOWN_RATE: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_COOLDOWN_RATE, COOLDOWN_RATE, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_MIN(&mut self, ELEVATION_MIN: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_ELEVATION_MIN, ELEVATION_MIN, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_MAX(&mut self, ELEVATION_MAX: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_ELEVATION_MAX, ELEVATION_MAX, 0.0);
  }
  #[inline]
  pub fn add_TRAVERSE_MIN(&mut self, TRAVERSE_MIN: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_TRAVERSE_MIN, TRAVERSE_MIN, 0.0);
  }
  #[inline]
  pub fn add_TRAVERSE_MAX(&mut self, TRAVERSE_MAX: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_TRAVERSE_MAX, TRAVERSE_MAX, 0.0);
  }
  #[inline]
  pub fn add_SLEW_RATE(&mut self, SLEW_RATE: f32) {
    self.fbb_.push_slot::<f32>(WPN::VT_SLEW_RATE, SLEW_RATE, 0.0);
  }
  #[inline]
  pub fn add_WEAPON_TYPE(&mut self, WEAPON_TYPE: u8) {
    self.fbb_.push_slot::<u8>(WPN::VT_WEAPON_TYPE, WEAPON_TYPE, 0);
  }
  #[inline]
  pub fn add_FUZE_TYPE(&mut self, FUZE_TYPE: u8) {
    self.fbb_.push_slot::<u8>(WPN::VT_FUZE_TYPE, FUZE_TYPE, 0);
  }
  #[inline]
  pub fn add_RESERVED(&mut self, RESERVED: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WPN::VT_RESERVED, RESERVED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WPNBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WPNBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WPN<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WPN<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WPN");
      ds.field("CALIBER", &self.CALIBER());
      ds.field("MUZZLE_VELOCITY", &self.MUZZLE_VELOCITY());
      ds.field("RATE_OF_FIRE", &self.RATE_OF_FIRE());
      ds.field("DISPERSION", &self.DISPERSION());
      ds.field("AMMO_CAPACITY", &self.AMMO_CAPACITY());
      ds.field("BURST_LENGTH", &self.BURST_LENGTH());
      ds.field("RELOAD_TIME", &self.RELOAD_TIME());
      ds.field("OVERHEAT_ROUNDS", &self.OVERHEAT_ROUNDS());
      ds.field("COOLDOWN_RATE", &self.COOLDOWN_RATE());
      ds.field("ELEVATION_MIN", &self.ELEVATION_MIN());
      ds.field("ELEVATION_MAX", &self.ELEVATION_MAX());
      ds.field("TRAVERSE_MIN", &self.TRAVERSE_MIN());
      ds.field("TRAVERSE_MAX", &self.TRAVERSE_MAX());
      ds.field("SLEW_RATE", &self.SLEW_RATE());
      ds.field("WEAPON_TYPE", &self.WEAPON_TYPE());
      ds.field("FUZE_TYPE", &self.FUZE_TYPE());
      ds.field("RESERVED", &self.RESERVED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WPNT {
  pub CALIBER: f32,
  pub MUZZLE_VELOCITY: f32,
  pub RATE_OF_FIRE: f32,
  pub DISPERSION: f32,
  pub AMMO_CAPACITY: u16,
  pub BURST_LENGTH: u16,
  pub RELOAD_TIME: f32,
  pub OVERHEAT_ROUNDS: u16,
  pub COOLDOWN_RATE: f32,
  pub ELEVATION_MIN: f32,
  pub ELEVATION_MAX: f32,
  pub TRAVERSE_MIN: f32,
  pub TRAVERSE_MAX: f32,
  pub SLEW_RATE: f32,
  pub WEAPON_TYPE: u8,
  pub FUZE_TYPE: u8,
  pub RESERVED: Option<Vec<u8>>,
}
impl Default for WPNT {
  fn default() -> Self {
    Self {
      CALIBER: 0.0,
      MUZZLE_VELOCITY: 0.0,
      RATE_OF_FIRE: 0.0,
      DISPERSION: 0.0,
      AMMO_CAPACITY: 0,
      BURST_LENGTH: 0,
      RELOAD_TIME: 0.0,
      OVERHEAT_ROUNDS: 0,
      COOLDOWN_RATE: 0.0,
      ELEVATION_MIN: 0.0,
      ELEVATION_MAX: 0.0,
      TRAVERSE_MIN: 0.0,
      TRAVERSE_MAX: 0.0,
      SLEW_RATE: 0.0,
      WEAPON_TYPE: 0,
      FUZE_TYPE: 0,
      RESERVED: None,
    }
  }
}
impl WPNT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<WPN<'b>> {
    let CALIBER = self.CALIBER;
    let MUZZLE_VELOCITY = self.MUZZLE_VELOCITY;
    let RATE_OF_FIRE = self.RATE_OF_FIRE;
    let DISPERSION = self.DISPERSION;
    let AMMO_CAPACITY = self.AMMO_CAPACITY;
    let BURST_LENGTH = self.BURST_LENGTH;
    let RELOAD_TIME = self.RELOAD_TIME;
    let OVERHEAT_ROUNDS = self.OVERHEAT_ROUNDS;
    let COOLDOWN_RATE = self.COOLDOWN_RATE;
    let ELEVATION_MIN = self.ELEVATION_MIN;
    let ELEVATION_MAX = self.ELEVATION_MAX;
    let TRAVERSE_MIN = self.TRAVERSE_MIN;
    let TRAVERSE_MAX = self.TRAVERSE_MAX;
    let SLEW_RATE = self.SLEW_RATE;
    let WEAPON_TYPE = self.WEAPON_TYPE;
    let FUZE_TYPE = self.FUZE_TYPE;
    let RESERVED = self.RESERVED.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    WPN::create(_fbb, &WPNArgs{
      CALIBER,
      MUZZLE_VELOCITY,
      RATE_OF_FIRE,
      DISPERSION,
      AMMO_CAPACITY,
      BURST_LENGTH,
      RELOAD_TIME,
      OVERHEAT_ROUNDS,
      COOLDOWN_RATE,
      ELEVATION_MIN,
      ELEVATION_MAX,
      TRAVERSE_MIN,
      TRAVERSE_MAX,
      SLEW_RATE,
      WEAPON_TYPE,
      FUZE_TYPE,
      RESERVED,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `WPN`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_WPN_unchecked`.
pub fn root_as_WPN(buf: &[u8]) -> Result<WPN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<WPN>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `WPN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_WPN_unchecked`.
pub fn size_prefixed_root_as_WPN(buf: &[u8]) -> Result<WPN, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<WPN>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `WPN` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_WPN_unchecked`.
pub fn root_as_WPN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WPN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<WPN<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `WPN` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_WPN_unchecked`.
pub fn size_prefixed_root_as_WPN_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WPN<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<WPN<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a WPN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `WPN`.
pub unsafe fn root_as_WPN_unchecked(buf: &[u8]) -> WPN {
  flatbuffers::root_unchecked::<WPN>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed WPN and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `WPN`.
pub unsafe fn size_prefixed_root_as_WPN_unchecked(buf: &[u8]) -> WPN {
  flatbuffers::size_prefixed_root_unchecked::<WPN>(buf)
}
pub const WPN_IDENTIFIER: &str = "$WPN";

#[inline]
pub fn WPN_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, WPN_IDENTIFIER, false)
}

#[inline]
pub fn WPN_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, WPN_IDENTIFIER, true)
}

#[inline]
pub fn finish_WPN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<WPN<'a>>) {
  fbb.finish(root, Some(WPN_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_WPN_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<WPN<'a>>) {
  fbb.finish_size_prefixed(root, Some(WPN_IDENTIFIER));
}
