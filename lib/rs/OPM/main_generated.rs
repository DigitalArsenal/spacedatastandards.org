// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Orbit Parameter Message
pub struct OPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OPM<'a> {
  type Inner = OPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OPM<'a> {
  pub const VT_CCSDS_OPM_VERS: flatbuffers::VOffsetT = 4;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 8;
  pub const VT_OBJECT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 12;
  pub const VT_CENTER_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_REF_FRAME: flatbuffers::VOffsetT = 16;
  pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 18;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 20;
  pub const VT_X: flatbuffers::VOffsetT = 22;
  pub const VT_Y: flatbuffers::VOffsetT = 24;
  pub const VT_Z: flatbuffers::VOffsetT = 26;
  pub const VT_X_DOT: flatbuffers::VOffsetT = 28;
  pub const VT_Y_DOT: flatbuffers::VOffsetT = 30;
  pub const VT_Z_DOT: flatbuffers::VOffsetT = 32;
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 34;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 36;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 38;
  pub const VT_RA_OF_ASC_NODE: flatbuffers::VOffsetT = 40;
  pub const VT_ARG_OF_PERICENTER: flatbuffers::VOffsetT = 42;
  pub const VT_TRUE_ANOMALY: flatbuffers::VOffsetT = 44;
  pub const VT_MEAN_ANOMALY: flatbuffers::VOffsetT = 46;
  pub const VT_GM: flatbuffers::VOffsetT = 48;
  pub const VT_MASS: flatbuffers::VOffsetT = 50;
  pub const VT_SOLAR_RAD_AREA: flatbuffers::VOffsetT = 52;
  pub const VT_SOLAR_RAD_COEFF: flatbuffers::VOffsetT = 54;
  pub const VT_DRAG_AREA: flatbuffers::VOffsetT = 56;
  pub const VT_DRAG_COEFF: flatbuffers::VOffsetT = 58;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OPMArgs<'args>
  ) -> flatbuffers::WIPOffset<OPM<'bldr>> {
    let mut builder = OPMBuilder::new(_fbb);
    builder.add_DRAG_COEFF(args.DRAG_COEFF);
    builder.add_DRAG_AREA(args.DRAG_AREA);
    builder.add_SOLAR_RAD_COEFF(args.SOLAR_RAD_COEFF);
    builder.add_SOLAR_RAD_AREA(args.SOLAR_RAD_AREA);
    builder.add_MASS(args.MASS);
    builder.add_GM(args.GM);
    builder.add_MEAN_ANOMALY(args.MEAN_ANOMALY);
    builder.add_TRUE_ANOMALY(args.TRUE_ANOMALY);
    builder.add_ARG_OF_PERICENTER(args.ARG_OF_PERICENTER);
    builder.add_RA_OF_ASC_NODE(args.RA_OF_ASC_NODE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    builder.add_Z_DOT(args.Z_DOT);
    builder.add_Y_DOT(args.Y_DOT);
    builder.add_X_DOT(args.X_DOT);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    if let Some(x) = args.TIME_SYSTEM { builder.add_TIME_SYSTEM(x); }
    if let Some(x) = args.REF_FRAME { builder.add_REF_FRAME(x); }
    if let Some(x) = args.CENTER_NAME { builder.add_CENTER_NAME(x); }
    if let Some(x) = args.OBJECT_ID { builder.add_OBJECT_ID(x); }
    if let Some(x) = args.OBJECT_NAME { builder.add_OBJECT_NAME(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    if let Some(x) = args.CCSDS_OPM_VERS { builder.add_CCSDS_OPM_VERS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OPMT {
    let CCSDS_OPM_VERS = self.CCSDS_OPM_VERS().map(|x| {
      x.to_string()
    });
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let OBJECT_NAME = self.OBJECT_NAME().map(|x| {
      x.to_string()
    });
    let OBJECT_ID = self.OBJECT_ID().map(|x| {
      x.to_string()
    });
    let CENTER_NAME = self.CENTER_NAME().map(|x| {
      x.to_string()
    });
    let REF_FRAME = self.REF_FRAME().map(|x| {
      x.to_string()
    });
    let TIME_SYSTEM = self.TIME_SYSTEM().map(|x| {
      x.to_string()
    });
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let X_DOT = self.X_DOT();
    let Y_DOT = self.Y_DOT();
    let Z_DOT = self.Z_DOT();
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE();
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER();
    let TRUE_ANOMALY = self.TRUE_ANOMALY();
    let MEAN_ANOMALY = self.MEAN_ANOMALY();
    let GM = self.GM();
    let MASS = self.MASS();
    let SOLAR_RAD_AREA = self.SOLAR_RAD_AREA();
    let SOLAR_RAD_COEFF = self.SOLAR_RAD_COEFF();
    let DRAG_AREA = self.DRAG_AREA();
    let DRAG_COEFF = self.DRAG_COEFF();
    OPMT {
      CCSDS_OPM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      TIME_SYSTEM,
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      TRUE_ANOMALY,
      MEAN_ANOMALY,
      GM,
      MASS,
      SOLAR_RAD_AREA,
      SOLAR_RAD_COEFF,
      DRAG_AREA,
      DRAG_COEFF,
    }
  }

  #[inline]
  pub fn CCSDS_OPM_VERS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CCSDS_OPM_VERS, None)}
  }
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CREATION_DATE, None)}
  }
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_ORIGINATOR, None)}
  }
  #[inline]
  pub fn OBJECT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_OBJECT_NAME, None)}
  }
  #[inline]
  pub fn OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_OBJECT_ID, None)}
  }
  #[inline]
  pub fn CENTER_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CENTER_NAME, None)}
  }
  #[inline]
  pub fn REF_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_REF_FRAME, None)}
  }
  #[inline]
  pub fn TIME_SYSTEM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_TIME_SYSTEM, None)}
  }
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_EPOCH, None)}
  }
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_X_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_Y_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_Z_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RA_OF_ASC_NODE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_RA_OF_ASC_NODE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ARG_OF_PERICENTER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_ARG_OF_PERICENTER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn TRUE_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_TRUE_ANOMALY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_MEAN_ANOMALY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn GM(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_GM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_RAD_AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_SOLAR_RAD_AREA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_RAD_COEFF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_SOLAR_RAD_COEFF, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRAG_AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_DRAG_AREA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRAG_COEFF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_DRAG_COEFF, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CCSDS_OPM_VERS", Self::VT_CCSDS_OPM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_NAME", Self::VT_OBJECT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_ID", Self::VT_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CENTER_NAME", Self::VT_CENTER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REF_FRAME", Self::VT_REF_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME_SYSTEM", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("X_DOT", Self::VT_X_DOT, false)?
     .visit_field::<f64>("Y_DOT", Self::VT_Y_DOT, false)?
     .visit_field::<f64>("Z_DOT", Self::VT_Z_DOT, false)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RA_OF_ASC_NODE", Self::VT_RA_OF_ASC_NODE, false)?
     .visit_field::<f64>("ARG_OF_PERICENTER", Self::VT_ARG_OF_PERICENTER, false)?
     .visit_field::<f64>("TRUE_ANOMALY", Self::VT_TRUE_ANOMALY, false)?
     .visit_field::<f64>("MEAN_ANOMALY", Self::VT_MEAN_ANOMALY, false)?
     .visit_field::<f64>("GM", Self::VT_GM, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<f64>("SOLAR_RAD_AREA", Self::VT_SOLAR_RAD_AREA, false)?
     .visit_field::<f64>("SOLAR_RAD_COEFF", Self::VT_SOLAR_RAD_COEFF, false)?
     .visit_field::<f64>("DRAG_AREA", Self::VT_DRAG_AREA, false)?
     .visit_field::<f64>("DRAG_COEFF", Self::VT_DRAG_COEFF, false)?
     .finish();
    Ok(())
  }
}
pub struct OPMArgs<'a> {
    pub CCSDS_OPM_VERS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CENTER_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REF_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_SYSTEM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub X_DOT: f64,
    pub Y_DOT: f64,
    pub Z_DOT: f64,
    pub SEMI_MAJOR_AXIS: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RA_OF_ASC_NODE: f64,
    pub ARG_OF_PERICENTER: f64,
    pub TRUE_ANOMALY: f64,
    pub MEAN_ANOMALY: f64,
    pub GM: f64,
    pub MASS: f64,
    pub SOLAR_RAD_AREA: f64,
    pub SOLAR_RAD_COEFF: f64,
    pub DRAG_AREA: f64,
    pub DRAG_COEFF: f64,
}
impl<'a> Default for OPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    OPMArgs {
      CCSDS_OPM_VERS: None,
      CREATION_DATE: None,
      ORIGINATOR: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: None,
      TIME_SYSTEM: None,
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      TRUE_ANOMALY: 0.0,
      MEAN_ANOMALY: 0.0,
      GM: 0.0,
      MASS: 0.0,
      SOLAR_RAD_AREA: 0.0,
      SOLAR_RAD_COEFF: 0.0,
      DRAG_AREA: 0.0,
      DRAG_COEFF: 0.0,
    }
  }
}

pub struct OPMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OPMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CCSDS_OPM_VERS(&mut self, CCSDS_OPM_VERS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CCSDS_OPM_VERS, CCSDS_OPM_VERS);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_OBJECT_NAME(&mut self, OBJECT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_OBJECT_NAME, OBJECT_NAME);
  }
  #[inline]
  pub fn add_OBJECT_ID(&mut self, OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_OBJECT_ID, OBJECT_ID);
  }
  #[inline]
  pub fn add_CENTER_NAME(&mut self, CENTER_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CENTER_NAME, CENTER_NAME);
  }
  #[inline]
  pub fn add_REF_FRAME(&mut self, REF_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_REF_FRAME, REF_FRAME);
  }
  #[inline]
  pub fn add_TIME_SYSTEM(&mut self, TIME_SYSTEM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_X_DOT(&mut self, X_DOT: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_X_DOT, X_DOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DOT(&mut self, Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_Y_DOT, Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DOT(&mut self, Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_Z_DOT, Z_DOT, 0.0);
  }
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RA_OF_ASC_NODE(&mut self, RA_OF_ASC_NODE: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERICENTER(&mut self, ARG_OF_PERICENTER: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_ARG_OF_PERICENTER, ARG_OF_PERICENTER, 0.0);
  }
  #[inline]
  pub fn add_TRUE_ANOMALY(&mut self, TRUE_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_TRUE_ANOMALY, TRUE_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_MEAN_ANOMALY(&mut self, MEAN_ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_MEAN_ANOMALY, MEAN_ANOMALY, 0.0);
  }
  #[inline]
  pub fn add_GM(&mut self, GM: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_GM, GM, 0.0);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_RAD_AREA(&mut self, SOLAR_RAD_AREA: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_SOLAR_RAD_AREA, SOLAR_RAD_AREA, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_RAD_COEFF(&mut self, SOLAR_RAD_COEFF: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_SOLAR_RAD_COEFF, SOLAR_RAD_COEFF, 0.0);
  }
  #[inline]
  pub fn add_DRAG_AREA(&mut self, DRAG_AREA: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_DRAG_AREA, DRAG_AREA, 0.0);
  }
  #[inline]
  pub fn add_DRAG_COEFF(&mut self, DRAG_COEFF: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_DRAG_COEFF, DRAG_COEFF, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OPMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OPM");
      ds.field("CCSDS_OPM_VERS", &self.CCSDS_OPM_VERS());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("OBJECT_NAME", &self.OBJECT_NAME());
      ds.field("OBJECT_ID", &self.OBJECT_ID());
      ds.field("CENTER_NAME", &self.CENTER_NAME());
      ds.field("REF_FRAME", &self.REF_FRAME());
      ds.field("TIME_SYSTEM", &self.TIME_SYSTEM());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("X_DOT", &self.X_DOT());
      ds.field("Y_DOT", &self.Y_DOT());
      ds.field("Z_DOT", &self.Z_DOT());
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RA_OF_ASC_NODE", &self.RA_OF_ASC_NODE());
      ds.field("ARG_OF_PERICENTER", &self.ARG_OF_PERICENTER());
      ds.field("TRUE_ANOMALY", &self.TRUE_ANOMALY());
      ds.field("MEAN_ANOMALY", &self.MEAN_ANOMALY());
      ds.field("GM", &self.GM());
      ds.field("MASS", &self.MASS());
      ds.field("SOLAR_RAD_AREA", &self.SOLAR_RAD_AREA());
      ds.field("SOLAR_RAD_COEFF", &self.SOLAR_RAD_COEFF());
      ds.field("DRAG_AREA", &self.DRAG_AREA());
      ds.field("DRAG_COEFF", &self.DRAG_COEFF());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OPMT {
  pub CCSDS_OPM_VERS: Option<String>,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub OBJECT_NAME: Option<String>,
  pub OBJECT_ID: Option<String>,
  pub CENTER_NAME: Option<String>,
  pub REF_FRAME: Option<String>,
  pub TIME_SYSTEM: Option<String>,
  pub EPOCH: Option<String>,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub X_DOT: f64,
  pub Y_DOT: f64,
  pub Z_DOT: f64,
  pub SEMI_MAJOR_AXIS: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RA_OF_ASC_NODE: f64,
  pub ARG_OF_PERICENTER: f64,
  pub TRUE_ANOMALY: f64,
  pub MEAN_ANOMALY: f64,
  pub GM: f64,
  pub MASS: f64,
  pub SOLAR_RAD_AREA: f64,
  pub SOLAR_RAD_COEFF: f64,
  pub DRAG_AREA: f64,
  pub DRAG_COEFF: f64,
}
impl Default for OPMT {
  fn default() -> Self {
    Self {
      CCSDS_OPM_VERS: None,
      CREATION_DATE: None,
      ORIGINATOR: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: None,
      TIME_SYSTEM: None,
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      TRUE_ANOMALY: 0.0,
      MEAN_ANOMALY: 0.0,
      GM: 0.0,
      MASS: 0.0,
      SOLAR_RAD_AREA: 0.0,
      SOLAR_RAD_COEFF: 0.0,
      DRAG_AREA: 0.0,
      DRAG_COEFF: 0.0,
    }
  }
}
impl OPMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OPM<'b>> {
    let CCSDS_OPM_VERS = self.CCSDS_OPM_VERS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_NAME = self.OBJECT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_ID = self.OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CENTER_NAME = self.CENTER_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REF_FRAME = self.REF_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_SYSTEM = self.TIME_SYSTEM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let X_DOT = self.X_DOT;
    let Y_DOT = self.Y_DOT;
    let Z_DOT = self.Z_DOT;
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE;
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER;
    let TRUE_ANOMALY = self.TRUE_ANOMALY;
    let MEAN_ANOMALY = self.MEAN_ANOMALY;
    let GM = self.GM;
    let MASS = self.MASS;
    let SOLAR_RAD_AREA = self.SOLAR_RAD_AREA;
    let SOLAR_RAD_COEFF = self.SOLAR_RAD_COEFF;
    let DRAG_AREA = self.DRAG_AREA;
    let DRAG_COEFF = self.DRAG_COEFF;
    OPM::create(_fbb, &OPMArgs{
      CCSDS_OPM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      TIME_SYSTEM,
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      TRUE_ANOMALY,
      MEAN_ANOMALY,
      GM,
      MASS,
      SOLAR_RAD_AREA,
      SOLAR_RAD_COEFF,
      DRAG_AREA,
      DRAG_COEFF,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OPM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn root_as_OPM(buf: &[u8]) -> Result<OPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OPM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OPM_unchecked`.
pub fn size_prefixed_root_as_OPM(buf: &[u8]) -> Result<OPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OPM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn root_as_OPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OPM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OPM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn size_prefixed_root_as_OPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OPM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OPM`.
pub unsafe fn root_as_OPM_unchecked(buf: &[u8]) -> OPM {
  flatbuffers::root_unchecked::<OPM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OPM`.
pub unsafe fn size_prefixed_root_as_OPM_unchecked(buf: &[u8]) -> OPM {
  flatbuffers::size_prefixed_root_unchecked::<OPM>(buf)
}
pub const OPM_IDENTIFIER: &str = "$OPM";

#[inline]
pub fn OPM_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OPM_IDENTIFIER, false)
}

#[inline]
pub fn OPM_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OPM_IDENTIFIER, true)
}

#[inline]
pub fn finish_OPM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OPM<'a>>) {
  fbb.finish(root, Some(OPM_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OPM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OPM<'a>>) {
  fbb.finish_size_prefixed(root, Some(OPM_IDENTIFIER));
}
