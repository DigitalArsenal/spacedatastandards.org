// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::main_generated::*;
use crate::main_generated::*;
use crate::main_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ELEMENT_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ELEMENT_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ELEMENT_TYPE: [elementType; 2] = [
  elementType::OSCULATING,
  elementType::MEAN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct elementType(pub i8);
#[allow(non_upper_case_globals)]
impl elementType {
  pub const OSCULATING: Self = Self(0);
  pub const MEAN: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OSCULATING,
    Self::MEAN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OSCULATING => Some("OSCULATING"),
      Self::MEAN => Some("MEAN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for elementType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for elementType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for elementType {
    type Output = elementType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for elementType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for elementType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for elementType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANOMALY_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANOMALY_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANOMALY_TYPE: [anomalyType; 2] = [
  anomalyType::TRUE_ANOMALY,
  anomalyType::MEAN_ANOMALY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct anomalyType(pub i8);
#[allow(non_upper_case_globals)]
impl anomalyType {
  pub const TRUE_ANOMALY: Self = Self(0);
  pub const MEAN_ANOMALY: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TRUE_ANOMALY,
    Self::MEAN_ANOMALY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TRUE_ANOMALY => Some("TRUE_ANOMALY"),
      Self::MEAN_ANOMALY => Some("MEAN_ANOMALY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for anomalyType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for anomalyType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for anomalyType {
    type Output = anomalyType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for anomalyType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for anomalyType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for anomalyType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ATMOSPHERIC_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ATMOSPHERIC_MODEL: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATMOSPHERIC_MODEL: [atmosphericModel; 7] = [
  atmosphericModel::NONE,
  atmosphericModel::JACCHIA_70,
  atmosphericModel::JB2008,
  atmosphericModel::NRLMSISE_00,
  atmosphericModel::DTM_2000,
  atmosphericModel::HWM14,
  atmosphericModel::HASDM,
];

/// Enum to represent common atmospheric models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct atmosphericModel(pub i8);
#[allow(non_upper_case_globals)]
impl atmosphericModel {
  pub const NONE: Self = Self(0);
  pub const JACCHIA_70: Self = Self(1);
  pub const JB2008: Self = Self(2);
  pub const NRLMSISE_00: Self = Self(3);
  pub const DTM_2000: Self = Self(4);
  pub const HWM14: Self = Self(5);
  pub const HASDM: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::JACCHIA_70,
    Self::JB2008,
    Self::NRLMSISE_00,
    Self::DTM_2000,
    Self::HWM14,
    Self::HASDM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::JACCHIA_70 => Some("JACCHIA_70"),
      Self::JB2008 => Some("JB2008"),
      Self::NRLMSISE_00 => Some("NRLMSISE_00"),
      Self::DTM_2000 => Some("DTM_2000"),
      Self::HWM14 => Some("HWM14"),
      Self::HASDM => Some("HASDM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for atmosphericModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for atmosphericModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for atmosphericModel {
    type Output = atmosphericModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for atmosphericModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for atmosphericModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for atmosphericModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEOPOTENTIAL_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEOPOTENTIAL_MODEL: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOPOTENTIAL_MODEL: [geopotentialModel; 6] = [
  geopotentialModel::NONE,
  geopotentialModel::EGM96,
  geopotentialModel::WGS84,
  geopotentialModel::JGM2,
  geopotentialModel::GEMT3,
  geopotentialModel::EGM96_J5,
];

/// Enum to represent common geopotential models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct geopotentialModel(pub i8);
#[allow(non_upper_case_globals)]
impl geopotentialModel {
  pub const NONE: Self = Self(0);
  pub const EGM96: Self = Self(1);
  pub const WGS84: Self = Self(2);
  pub const JGM2: Self = Self(3);
  pub const GEMT3: Self = Self(4);
  pub const EGM96_J5: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::EGM96,
    Self::WGS84,
    Self::JGM2,
    Self::GEMT3,
    Self::EGM96_J5,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::EGM96 => Some("EGM96"),
      Self::WGS84 => Some("WGS84"),
      Self::JGM2 => Some("JGM2"),
      Self::GEMT3 => Some("GEMT3"),
      Self::EGM96_J5 => Some("EGM96_J5"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for geopotentialModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for geopotentialModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for geopotentialModel {
    type Output = geopotentialModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for geopotentialModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for geopotentialModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for geopotentialModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ZONAL_HARMONIC: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ZONAL_HARMONIC: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ZONAL_HARMONIC: [zonalHarmonic; 12] = [
  zonalHarmonic::NONE,
  zonalHarmonic::J2,
  zonalHarmonic::J3,
  zonalHarmonic::J4,
  zonalHarmonic::J5,
  zonalHarmonic::J6,
  zonalHarmonic::J7,
  zonalHarmonic::J8,
  zonalHarmonic::J9,
  zonalHarmonic::J10,
  zonalHarmonic::J11,
  zonalHarmonic::J12,
];

/// Enum to represent zonal harmonics
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct zonalHarmonic(pub i8);
#[allow(non_upper_case_globals)]
impl zonalHarmonic {
  pub const NONE: Self = Self(0);
  pub const J2: Self = Self(1);
  pub const J3: Self = Self(2);
  pub const J4: Self = Self(3);
  pub const J5: Self = Self(4);
  pub const J6: Self = Self(5);
  pub const J7: Self = Self(6);
  pub const J8: Self = Self(7);
  pub const J9: Self = Self(8);
  pub const J10: Self = Self(9);
  pub const J11: Self = Self(10);
  pub const J12: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::J2,
    Self::J3,
    Self::J4,
    Self::J5,
    Self::J6,
    Self::J7,
    Self::J8,
    Self::J9,
    Self::J10,
    Self::J11,
    Self::J12,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::J2 => Some("J2"),
      Self::J3 => Some("J3"),
      Self::J4 => Some("J4"),
      Self::J5 => Some("J5"),
      Self::J6 => Some("J6"),
      Self::J7 => Some("J7"),
      Self::J8 => Some("J8"),
      Self::J9 => Some("J9"),
      Self::J10 => Some("J10"),
      Self::J11 => Some("J11"),
      Self::J12 => Some("J12"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for zonalHarmonic {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for zonalHarmonic {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for zonalHarmonic {
    type Output = zonalHarmonic;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for zonalHarmonic {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for zonalHarmonic {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for zonalHarmonic {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOLAR_RADIATION_PRESSURE_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOLAR_RADIATION_PRESSURE_MODEL: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOLAR_RADIATION_PRESSURE_MODEL: [solarRadiationPressureModel; 3] = [
  solarRadiationPressureModel::NONE,
  solarRadiationPressureModel::SPHERICAL_MODEL,
  solarRadiationPressureModel::FLAT_PLATE_MODEL,
];

/// Enum to represent solar radiation pressure models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct solarRadiationPressureModel(pub i8);
#[allow(non_upper_case_globals)]
impl solarRadiationPressureModel {
  pub const NONE: Self = Self(0);
  pub const SPHERICAL_MODEL: Self = Self(1);
  pub const FLAT_PLATE_MODEL: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SPHERICAL_MODEL,
    Self::FLAT_PLATE_MODEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SPHERICAL_MODEL => Some("SPHERICAL_MODEL"),
      Self::FLAT_PLATE_MODEL => Some("FLAT_PLATE_MODEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for solarRadiationPressureModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for solarRadiationPressureModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for solarRadiationPressureModel {
    type Output = solarRadiationPressureModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for solarRadiationPressureModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for solarRadiationPressureModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for solarRadiationPressureModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LUNAR_PERTURBATION_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LUNAR_PERTURBATION_MODEL: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LUNAR_PERTURBATION_MODEL: [lunarPerturbationModel; 4] = [
  lunarPerturbationModel::NONE,
  lunarPerturbationModel::DE430,
  lunarPerturbationModel::DE431,
  lunarPerturbationModel::LP150Q,
];

/// Enum to represent common lunar perturbation models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct lunarPerturbationModel(pub i8);
#[allow(non_upper_case_globals)]
impl lunarPerturbationModel {
  pub const NONE: Self = Self(0);
  pub const DE430: Self = Self(1);
  pub const DE431: Self = Self(2);
  pub const LP150Q: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DE430,
    Self::DE431,
    Self::LP150Q,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DE430 => Some("DE430"),
      Self::DE431 => Some("DE431"),
      Self::LP150Q => Some("LP150Q"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for lunarPerturbationModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for lunarPerturbationModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for lunarPerturbationModel {
    type Output = lunarPerturbationModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for lunarPerturbationModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for lunarPerturbationModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for lunarPerturbationModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SOLAR_PERTURBATION_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SOLAR_PERTURBATION_MODEL: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOLAR_PERTURBATION_MODEL: [solarPerturbationModel; 3] = [
  solarPerturbationModel::NONE,
  solarPerturbationModel::DE430,
  solarPerturbationModel::DE431,
];

/// Enum to represent various solar perturbation models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct solarPerturbationModel(pub i8);
#[allow(non_upper_case_globals)]
impl solarPerturbationModel {
  pub const NONE: Self = Self(0);
  pub const DE430: Self = Self(1);
  pub const DE431: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DE430,
    Self::DE431,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DE430 => Some("DE430"),
      Self::DE431 => Some("DE431"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for solarPerturbationModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for solarPerturbationModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for solarPerturbationModel {
    type Output = solarPerturbationModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for solarPerturbationModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for solarPerturbationModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for solarPerturbationModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESONANCE_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESONANCE_MODEL: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESONANCE_MODEL: [resonanceModel; 5] = [
  resonanceModel::NONE,
  resonanceModel::HIGH_ALTITUDE_RESONANCE,
  resonanceModel::LOW_ALTITUDE_RESONANCE,
  resonanceModel::LUNAR_RESONANCE,
  resonanceModel::SOLAR_RESONANCE,
];

/// Enum to represent resonance models
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct resonanceModel(pub i8);
#[allow(non_upper_case_globals)]
impl resonanceModel {
  pub const NONE: Self = Self(0);
  pub const HIGH_ALTITUDE_RESONANCE: Self = Self(1);
  pub const LOW_ALTITUDE_RESONANCE: Self = Self(2);
  pub const LUNAR_RESONANCE: Self = Self(3);
  pub const SOLAR_RESONANCE: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::HIGH_ALTITUDE_RESONANCE,
    Self::LOW_ALTITUDE_RESONANCE,
    Self::LUNAR_RESONANCE,
    Self::SOLAR_RESONANCE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::HIGH_ALTITUDE_RESONANCE => Some("HIGH_ALTITUDE_RESONANCE"),
      Self::LOW_ALTITUDE_RESONANCE => Some("LOW_ALTITUDE_RESONANCE"),
      Self::LUNAR_RESONANCE => Some("LUNAR_RESONANCE"),
      Self::SOLAR_RESONANCE => Some("SOLAR_RESONANCE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for resonanceModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for resonanceModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for resonanceModel {
    type Output = resonanceModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for resonanceModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for resonanceModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for resonanceModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PERTURBATION_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PERTURBATION_STATUS: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PERTURBATION_STATUS: [perturbationStatus; 2] = [
  perturbationStatus::OFF,
  perturbationStatus::ON,
];

/// Enum to represent the status of various perturbations (ON/OFF)
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct perturbationStatus(pub i8);
#[allow(non_upper_case_globals)]
impl perturbationStatus {
  pub const OFF: Self = Self(0);
  pub const ON: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::OFF,
    Self::ON,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::OFF => Some("OFF"),
      Self::ON => Some("ON"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for perturbationStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for perturbationStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for perturbationStatus {
    type Output = perturbationStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for perturbationStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for perturbationStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for perturbationStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROPAGATOR_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROPAGATOR_TYPE: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROPAGATOR_TYPE: [propagatorType; 13] = [
  propagatorType::NONE,
  propagatorType::SEMI_ANALYTICAL,
  propagatorType::VINTI,
  propagatorType::SGP4,
  propagatorType::COWELL,
  propagatorType::RK4,
  propagatorType::NYX,
  propagatorType::GMAT,
  propagatorType::SPICE,
  propagatorType::SGP,
  propagatorType::SDP4,
  propagatorType::SGP8,
  propagatorType::SDP8,
];

/// Enum to represent propagator types
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct propagatorType(pub i8);
#[allow(non_upper_case_globals)]
impl propagatorType {
  pub const NONE: Self = Self(0);
  pub const SEMI_ANALYTICAL: Self = Self(1);
  pub const VINTI: Self = Self(2);
  pub const SGP4: Self = Self(3);
  pub const COWELL: Self = Self(4);
  pub const RK4: Self = Self(5);
  pub const NYX: Self = Self(6);
  pub const GMAT: Self = Self(7);
  pub const SPICE: Self = Self(8);
  pub const SGP: Self = Self(9);
  pub const SDP4: Self = Self(10);
  pub const SGP8: Self = Self(11);
  pub const SDP8: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SEMI_ANALYTICAL,
    Self::VINTI,
    Self::SGP4,
    Self::COWELL,
    Self::RK4,
    Self::NYX,
    Self::GMAT,
    Self::SPICE,
    Self::SGP,
    Self::SDP4,
    Self::SGP8,
    Self::SDP8,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SEMI_ANALYTICAL => Some("SEMI_ANALYTICAL"),
      Self::VINTI => Some("VINTI"),
      Self::SGP4 => Some("SGP4"),
      Self::COWELL => Some("COWELL"),
      Self::RK4 => Some("RK4"),
      Self::NYX => Some("NYX"),
      Self::GMAT => Some("GMAT"),
      Self::SPICE => Some("SPICE"),
      Self::SGP => Some("SGP"),
      Self::SDP4 => Some("SDP4"),
      Self::SGP8 => Some("SGP8"),
      Self::SDP8 => Some("SDP8"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for propagatorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for propagatorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for propagatorType {
    type Output = propagatorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for propagatorType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for propagatorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for propagatorType {}
pub enum propagatorConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Propagator configuration structure to describe propagation settings
pub struct propagatorConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for propagatorConfig<'a> {
  type Inner = propagatorConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> propagatorConfig<'a> {
  pub const VT_PROPAGATOR_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PROPAGATOR_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_FORCE_MODELS: flatbuffers::VOffsetT = 8;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 10;
  pub const VT_TIME_STEP: flatbuffers::VOffsetT = 12;
  pub const VT_ZONAL_HARMONIC_TERMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    propagatorConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args propagatorConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<propagatorConfig<'bldr>> {
    let mut builder = propagatorConfigBuilder::new(_fbb);
    builder.add_TIME_STEP(args.TIME_STEP);
    if let Some(x) = args.ZONAL_HARMONIC_TERMS { builder.add_ZONAL_HARMONIC_TERMS(x); }
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    if let Some(x) = args.FORCE_MODELS { builder.add_FORCE_MODELS(x); }
    if let Some(x) = args.PROPAGATOR_NAME { builder.add_PROPAGATOR_NAME(x); }
    builder.add_PROPAGATOR_TYPE(args.PROPAGATOR_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> propagatorConfigT {
    let PROPAGATOR_NAME = self.PROPAGATOR_NAME().map(|x| {
      x.to_string()
    });
    let PROPAGATOR_TYPE = self.PROPAGATOR_TYPE();
    let FORCE_MODELS = self.FORCE_MODELS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let TIME_STEP = self.TIME_STEP();
    let ZONAL_HARMONIC_TERMS = self.ZONAL_HARMONIC_TERMS().map(|x| {
      x.into_iter().collect()
    });
    propagatorConfigT {
      PROPAGATOR_NAME,
      PROPAGATOR_TYPE,
      FORCE_MODELS,
      EPOCH,
      TIME_STEP,
      ZONAL_HARMONIC_TERMS,
    }
  }

  #[inline]
  pub fn PROPAGATOR_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(propagatorConfig::VT_PROPAGATOR_NAME, None)}
  }
  #[inline]
  pub fn PROPAGATOR_TYPE(&self) -> propagatorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<propagatorType>(propagatorConfig::VT_PROPAGATOR_TYPE, Some(propagatorType::NONE)).unwrap()}
  }
  #[inline]
  pub fn FORCE_MODELS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(propagatorConfig::VT_FORCE_MODELS, None)}
  }
  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(propagatorConfig::VT_EPOCH, None)}
  }
  #[inline]
  pub fn TIME_STEP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(propagatorConfig::VT_TIME_STEP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ZONAL_HARMONIC_TERMS(&self) -> Option<flatbuffers::Vector<'a, zonalHarmonic>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, zonalHarmonic>>>(propagatorConfig::VT_ZONAL_HARMONIC_TERMS, None)}
  }
}

impl flatbuffers::Verifiable for propagatorConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PROPAGATOR_NAME", Self::VT_PROPAGATOR_NAME, false)?
     .visit_field::<propagatorType>("PROPAGATOR_TYPE", Self::VT_PROPAGATOR_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("FORCE_MODELS", Self::VT_FORCE_MODELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("TIME_STEP", Self::VT_TIME_STEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, zonalHarmonic>>>("ZONAL_HARMONIC_TERMS", Self::VT_ZONAL_HARMONIC_TERMS, false)?
     .finish();
    Ok(())
  }
}
pub struct propagatorConfigArgs<'a> {
    pub PROPAGATOR_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROPAGATOR_TYPE: propagatorType,
    pub FORCE_MODELS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_STEP: f64,
    pub ZONAL_HARMONIC_TERMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, zonalHarmonic>>>,
}
impl<'a> Default for propagatorConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    propagatorConfigArgs {
      PROPAGATOR_NAME: None,
      PROPAGATOR_TYPE: propagatorType::NONE,
      FORCE_MODELS: None,
      EPOCH: None,
      TIME_STEP: 0.0,
      ZONAL_HARMONIC_TERMS: None,
    }
  }
}

pub struct propagatorConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> propagatorConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PROPAGATOR_NAME(&mut self, PROPAGATOR_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(propagatorConfig::VT_PROPAGATOR_NAME, PROPAGATOR_NAME);
  }
  #[inline]
  pub fn add_PROPAGATOR_TYPE(&mut self, PROPAGATOR_TYPE: propagatorType) {
    self.fbb_.push_slot::<propagatorType>(propagatorConfig::VT_PROPAGATOR_TYPE, PROPAGATOR_TYPE, propagatorType::NONE);
  }
  #[inline]
  pub fn add_FORCE_MODELS(&mut self, FORCE_MODELS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(propagatorConfig::VT_FORCE_MODELS, FORCE_MODELS);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(propagatorConfig::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_TIME_STEP(&mut self, TIME_STEP: f64) {
    self.fbb_.push_slot::<f64>(propagatorConfig::VT_TIME_STEP, TIME_STEP, 0.0);
  }
  #[inline]
  pub fn add_ZONAL_HARMONIC_TERMS(&mut self, ZONAL_HARMONIC_TERMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , zonalHarmonic>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(propagatorConfig::VT_ZONAL_HARMONIC_TERMS, ZONAL_HARMONIC_TERMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> propagatorConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    propagatorConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<propagatorConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for propagatorConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("propagatorConfig");
      ds.field("PROPAGATOR_NAME", &self.PROPAGATOR_NAME());
      ds.field("PROPAGATOR_TYPE", &self.PROPAGATOR_TYPE());
      ds.field("FORCE_MODELS", &self.FORCE_MODELS());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("TIME_STEP", &self.TIME_STEP());
      ds.field("ZONAL_HARMONIC_TERMS", &self.ZONAL_HARMONIC_TERMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct propagatorConfigT {
  pub PROPAGATOR_NAME: Option<String>,
  pub PROPAGATOR_TYPE: propagatorType,
  pub FORCE_MODELS: Option<Vec<String>>,
  pub EPOCH: Option<String>,
  pub TIME_STEP: f64,
  pub ZONAL_HARMONIC_TERMS: Option<Vec<zonalHarmonic>>,
}
impl Default for propagatorConfigT {
  fn default() -> Self {
    Self {
      PROPAGATOR_NAME: None,
      PROPAGATOR_TYPE: propagatorType::NONE,
      FORCE_MODELS: None,
      EPOCH: None,
      TIME_STEP: 0.0,
      ZONAL_HARMONIC_TERMS: None,
    }
  }
}
impl propagatorConfigT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<propagatorConfig<'b>> {
    let PROPAGATOR_NAME = self.PROPAGATOR_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROPAGATOR_TYPE = self.PROPAGATOR_TYPE;
    let FORCE_MODELS = self.FORCE_MODELS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_STEP = self.TIME_STEP;
    let ZONAL_HARMONIC_TERMS = self.ZONAL_HARMONIC_TERMS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    propagatorConfig::create(_fbb, &propagatorConfigArgs{
      PROPAGATOR_NAME,
      PROPAGATOR_TYPE,
      FORCE_MODELS,
      EPOCH,
      TIME_STEP,
      ZONAL_HARMONIC_TERMS,
    })
  }
}
pub enum opmStateVectorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// OPM State Vector (position and velocity)
pub struct opmStateVector<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for opmStateVector<'a> {
  type Inner = opmStateVector<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> opmStateVector<'a> {
  pub const VT_EPOCH: flatbuffers::VOffsetT = 4;
  pub const VT_X: flatbuffers::VOffsetT = 6;
  pub const VT_Y: flatbuffers::VOffsetT = 8;
  pub const VT_Z: flatbuffers::VOffsetT = 10;
  pub const VT_X_DOT: flatbuffers::VOffsetT = 12;
  pub const VT_Y_DOT: flatbuffers::VOffsetT = 14;
  pub const VT_Z_DOT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    opmStateVector { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args opmStateVectorArgs<'args>
  ) -> flatbuffers::WIPOffset<opmStateVector<'bldr>> {
    let mut builder = opmStateVectorBuilder::new(_fbb);
    builder.add_Z_DOT(args.Z_DOT);
    builder.add_Y_DOT(args.Y_DOT);
    builder.add_X_DOT(args.X_DOT);
    builder.add_Z(args.Z);
    builder.add_Y(args.Y);
    builder.add_X(args.X);
    if let Some(x) = args.EPOCH { builder.add_EPOCH(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> opmStateVectorT {
    let EPOCH = self.EPOCH().map(|x| {
      x.to_string()
    });
    let X = self.X();
    let Y = self.Y();
    let Z = self.Z();
    let X_DOT = self.X_DOT();
    let Y_DOT = self.Y_DOT();
    let Z_DOT = self.Z_DOT();
    opmStateVectorT {
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
    }
  }

  #[inline]
  pub fn EPOCH(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(opmStateVector::VT_EPOCH, None)}
  }
  #[inline]
  pub fn X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn X_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_X_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Y_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_Y_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn Z_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmStateVector::VT_Z_DOT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for opmStateVector<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<f64>("X", Self::VT_X, false)?
     .visit_field::<f64>("Y", Self::VT_Y, false)?
     .visit_field::<f64>("Z", Self::VT_Z, false)?
     .visit_field::<f64>("X_DOT", Self::VT_X_DOT, false)?
     .visit_field::<f64>("Y_DOT", Self::VT_Y_DOT, false)?
     .visit_field::<f64>("Z_DOT", Self::VT_Z_DOT, false)?
     .finish();
    Ok(())
  }
}
pub struct opmStateVectorArgs<'a> {
    pub EPOCH: Option<flatbuffers::WIPOffset<&'a str>>,
    pub X: f64,
    pub Y: f64,
    pub Z: f64,
    pub X_DOT: f64,
    pub Y_DOT: f64,
    pub Z_DOT: f64,
}
impl<'a> Default for opmStateVectorArgs<'a> {
  #[inline]
  fn default() -> Self {
    opmStateVectorArgs {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
    }
  }
}

pub struct opmStateVectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> opmStateVectorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(opmStateVector::VT_EPOCH, EPOCH);
  }
  #[inline]
  pub fn add_X(&mut self, X: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_X, X, 0.0);
  }
  #[inline]
  pub fn add_Y(&mut self, Y: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_Y, Y, 0.0);
  }
  #[inline]
  pub fn add_Z(&mut self, Z: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_Z, Z, 0.0);
  }
  #[inline]
  pub fn add_X_DOT(&mut self, X_DOT: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_X_DOT, X_DOT, 0.0);
  }
  #[inline]
  pub fn add_Y_DOT(&mut self, Y_DOT: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_Y_DOT, Y_DOT, 0.0);
  }
  #[inline]
  pub fn add_Z_DOT(&mut self, Z_DOT: f64) {
    self.fbb_.push_slot::<f64>(opmStateVector::VT_Z_DOT, Z_DOT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> opmStateVectorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    opmStateVectorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<opmStateVector<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for opmStateVector<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("opmStateVector");
      ds.field("EPOCH", &self.EPOCH());
      ds.field("X", &self.X());
      ds.field("Y", &self.Y());
      ds.field("Z", &self.Z());
      ds.field("X_DOT", &self.X_DOT());
      ds.field("Y_DOT", &self.Y_DOT());
      ds.field("Z_DOT", &self.Z_DOT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct opmStateVectorT {
  pub EPOCH: Option<String>,
  pub X: f64,
  pub Y: f64,
  pub Z: f64,
  pub X_DOT: f64,
  pub Y_DOT: f64,
  pub Z_DOT: f64,
}
impl Default for opmStateVectorT {
  fn default() -> Self {
    Self {
      EPOCH: None,
      X: 0.0,
      Y: 0.0,
      Z: 0.0,
      X_DOT: 0.0,
      Y_DOT: 0.0,
      Z_DOT: 0.0,
    }
  }
}
impl opmStateVectorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<opmStateVector<'b>> {
    let EPOCH = self.EPOCH.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let X = self.X;
    let Y = self.Y;
    let Z = self.Z;
    let X_DOT = self.X_DOT;
    let Y_DOT = self.Y_DOT;
    let Z_DOT = self.Z_DOT;
    opmStateVector::create(_fbb, &opmStateVectorArgs{
      EPOCH,
      X,
      Y,
      Z,
      X_DOT,
      Y_DOT,
      Z_DOT,
    })
  }
}
pub enum opmCovarianceMatrixLineOffset {}
#[derive(Copy, Clone, PartialEq)]

/// OPM Covariance Matrix Line
pub struct opmCovarianceMatrixLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for opmCovarianceMatrixLine<'a> {
  type Inner = opmCovarianceMatrixLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> opmCovarianceMatrixLine<'a> {
  pub const VT_CX_X: flatbuffers::VOffsetT = 4;
  pub const VT_CY_X: flatbuffers::VOffsetT = 6;
  pub const VT_CZ_X: flatbuffers::VOffsetT = 8;
  pub const VT_CX_DOT_X: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    opmCovarianceMatrixLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args opmCovarianceMatrixLineArgs
  ) -> flatbuffers::WIPOffset<opmCovarianceMatrixLine<'bldr>> {
    let mut builder = opmCovarianceMatrixLineBuilder::new(_fbb);
    builder.add_CX_DOT_X(args.CX_DOT_X);
    builder.add_CZ_X(args.CZ_X);
    builder.add_CY_X(args.CY_X);
    builder.add_CX_X(args.CX_X);
    builder.finish()
  }

  pub fn unpack(&self) -> opmCovarianceMatrixLineT {
    let CX_X = self.CX_X();
    let CY_X = self.CY_X();
    let CZ_X = self.CZ_X();
    let CX_DOT_X = self.CX_DOT_X();
    opmCovarianceMatrixLineT {
      CX_X,
      CY_X,
      CZ_X,
      CX_DOT_X,
    }
  }

  #[inline]
  pub fn CX_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmCovarianceMatrixLine::VT_CX_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmCovarianceMatrixLine::VT_CY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CZ_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmCovarianceMatrixLine::VT_CZ_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CX_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(opmCovarianceMatrixLine::VT_CX_DOT_X, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for opmCovarianceMatrixLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("CX_X", Self::VT_CX_X, false)?
     .visit_field::<f64>("CY_X", Self::VT_CY_X, false)?
     .visit_field::<f64>("CZ_X", Self::VT_CZ_X, false)?
     .visit_field::<f64>("CX_DOT_X", Self::VT_CX_DOT_X, false)?
     .finish();
    Ok(())
  }
}
pub struct opmCovarianceMatrixLineArgs {
    pub CX_X: f64,
    pub CY_X: f64,
    pub CZ_X: f64,
    pub CX_DOT_X: f64,
}
impl<'a> Default for opmCovarianceMatrixLineArgs {
  #[inline]
  fn default() -> Self {
    opmCovarianceMatrixLineArgs {
      CX_X: 0.0,
      CY_X: 0.0,
      CZ_X: 0.0,
      CX_DOT_X: 0.0,
    }
  }
}

pub struct opmCovarianceMatrixLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> opmCovarianceMatrixLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CX_X(&mut self, CX_X: f64) {
    self.fbb_.push_slot::<f64>(opmCovarianceMatrixLine::VT_CX_X, CX_X, 0.0);
  }
  #[inline]
  pub fn add_CY_X(&mut self, CY_X: f64) {
    self.fbb_.push_slot::<f64>(opmCovarianceMatrixLine::VT_CY_X, CY_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_X(&mut self, CZ_X: f64) {
    self.fbb_.push_slot::<f64>(opmCovarianceMatrixLine::VT_CZ_X, CZ_X, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X(&mut self, CX_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(opmCovarianceMatrixLine::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> opmCovarianceMatrixLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    opmCovarianceMatrixLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<opmCovarianceMatrixLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for opmCovarianceMatrixLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("opmCovarianceMatrixLine");
      ds.field("CX_X", &self.CX_X());
      ds.field("CY_X", &self.CY_X());
      ds.field("CZ_X", &self.CZ_X());
      ds.field("CX_DOT_X", &self.CX_DOT_X());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct opmCovarianceMatrixLineT {
  pub CX_X: f64,
  pub CY_X: f64,
  pub CZ_X: f64,
  pub CX_DOT_X: f64,
}
impl Default for opmCovarianceMatrixLineT {
  fn default() -> Self {
    Self {
      CX_X: 0.0,
      CY_X: 0.0,
      CZ_X: 0.0,
      CX_DOT_X: 0.0,
    }
  }
}
impl opmCovarianceMatrixLineT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<opmCovarianceMatrixLine<'b>> {
    let CX_X = self.CX_X;
    let CY_X = self.CY_X;
    let CZ_X = self.CZ_X;
    let CX_DOT_X = self.CX_DOT_X;
    opmCovarianceMatrixLine::create(_fbb, &opmCovarianceMatrixLineArgs{
      CX_X,
      CY_X,
      CZ_X,
      CX_DOT_X,
    })
  }
}
pub enum keplerianElementsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Keplerian Elements
pub struct keplerianElements<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for keplerianElements<'a> {
  type Inner = keplerianElements<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> keplerianElements<'a> {
  pub const VT_SEMI_MAJOR_AXIS: flatbuffers::VOffsetT = 4;
  pub const VT_ECCENTRICITY: flatbuffers::VOffsetT = 6;
  pub const VT_INCLINATION: flatbuffers::VOffsetT = 8;
  pub const VT_RA_OF_ASC_NODE: flatbuffers::VOffsetT = 10;
  pub const VT_ARG_OF_PERICENTER: flatbuffers::VOffsetT = 12;
  pub const VT_ANOMALY_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_ANOMALY: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    keplerianElements { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args keplerianElementsArgs
  ) -> flatbuffers::WIPOffset<keplerianElements<'bldr>> {
    let mut builder = keplerianElementsBuilder::new(_fbb);
    builder.add_ANOMALY(args.ANOMALY);
    builder.add_ARG_OF_PERICENTER(args.ARG_OF_PERICENTER);
    builder.add_RA_OF_ASC_NODE(args.RA_OF_ASC_NODE);
    builder.add_INCLINATION(args.INCLINATION);
    builder.add_ECCENTRICITY(args.ECCENTRICITY);
    builder.add_SEMI_MAJOR_AXIS(args.SEMI_MAJOR_AXIS);
    builder.add_ANOMALY_TYPE(args.ANOMALY_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> keplerianElementsT {
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS();
    let ECCENTRICITY = self.ECCENTRICITY();
    let INCLINATION = self.INCLINATION();
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE();
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER();
    let ANOMALY_TYPE = self.ANOMALY_TYPE();
    let ANOMALY = self.ANOMALY();
    keplerianElementsT {
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      ANOMALY_TYPE,
      ANOMALY,
    }
  }

  #[inline]
  pub fn SEMI_MAJOR_AXIS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_SEMI_MAJOR_AXIS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ECCENTRICITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_ECCENTRICITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn INCLINATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_INCLINATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn RA_OF_ASC_NODE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_RA_OF_ASC_NODE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ARG_OF_PERICENTER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_ARG_OF_PERICENTER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ANOMALY_TYPE(&self) -> anomalyType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<anomalyType>(keplerianElements::VT_ANOMALY_TYPE, Some(anomalyType::TRUE_ANOMALY)).unwrap()}
  }
  #[inline]
  pub fn ANOMALY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(keplerianElements::VT_ANOMALY, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for keplerianElements<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("SEMI_MAJOR_AXIS", Self::VT_SEMI_MAJOR_AXIS, false)?
     .visit_field::<f64>("ECCENTRICITY", Self::VT_ECCENTRICITY, false)?
     .visit_field::<f64>("INCLINATION", Self::VT_INCLINATION, false)?
     .visit_field::<f64>("RA_OF_ASC_NODE", Self::VT_RA_OF_ASC_NODE, false)?
     .visit_field::<f64>("ARG_OF_PERICENTER", Self::VT_ARG_OF_PERICENTER, false)?
     .visit_field::<anomalyType>("ANOMALY_TYPE", Self::VT_ANOMALY_TYPE, false)?
     .visit_field::<f64>("ANOMALY", Self::VT_ANOMALY, false)?
     .finish();
    Ok(())
  }
}
pub struct keplerianElementsArgs {
    pub SEMI_MAJOR_AXIS: f64,
    pub ECCENTRICITY: f64,
    pub INCLINATION: f64,
    pub RA_OF_ASC_NODE: f64,
    pub ARG_OF_PERICENTER: f64,
    pub ANOMALY_TYPE: anomalyType,
    pub ANOMALY: f64,
}
impl<'a> Default for keplerianElementsArgs {
  #[inline]
  fn default() -> Self {
    keplerianElementsArgs {
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      ANOMALY_TYPE: anomalyType::TRUE_ANOMALY,
      ANOMALY: 0.0,
    }
  }
}

pub struct keplerianElementsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> keplerianElementsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SEMI_MAJOR_AXIS(&mut self, SEMI_MAJOR_AXIS: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_SEMI_MAJOR_AXIS, SEMI_MAJOR_AXIS, 0.0);
  }
  #[inline]
  pub fn add_ECCENTRICITY(&mut self, ECCENTRICITY: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_ECCENTRICITY, ECCENTRICITY, 0.0);
  }
  #[inline]
  pub fn add_INCLINATION(&mut self, INCLINATION: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_INCLINATION, INCLINATION, 0.0);
  }
  #[inline]
  pub fn add_RA_OF_ASC_NODE(&mut self, RA_OF_ASC_NODE: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_RA_OF_ASC_NODE, RA_OF_ASC_NODE, 0.0);
  }
  #[inline]
  pub fn add_ARG_OF_PERICENTER(&mut self, ARG_OF_PERICENTER: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_ARG_OF_PERICENTER, ARG_OF_PERICENTER, 0.0);
  }
  #[inline]
  pub fn add_ANOMALY_TYPE(&mut self, ANOMALY_TYPE: anomalyType) {
    self.fbb_.push_slot::<anomalyType>(keplerianElements::VT_ANOMALY_TYPE, ANOMALY_TYPE, anomalyType::TRUE_ANOMALY);
  }
  #[inline]
  pub fn add_ANOMALY(&mut self, ANOMALY: f64) {
    self.fbb_.push_slot::<f64>(keplerianElements::VT_ANOMALY, ANOMALY, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> keplerianElementsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    keplerianElementsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<keplerianElements<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for keplerianElements<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("keplerianElements");
      ds.field("SEMI_MAJOR_AXIS", &self.SEMI_MAJOR_AXIS());
      ds.field("ECCENTRICITY", &self.ECCENTRICITY());
      ds.field("INCLINATION", &self.INCLINATION());
      ds.field("RA_OF_ASC_NODE", &self.RA_OF_ASC_NODE());
      ds.field("ARG_OF_PERICENTER", &self.ARG_OF_PERICENTER());
      ds.field("ANOMALY_TYPE", &self.ANOMALY_TYPE());
      ds.field("ANOMALY", &self.ANOMALY());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct keplerianElementsT {
  pub SEMI_MAJOR_AXIS: f64,
  pub ECCENTRICITY: f64,
  pub INCLINATION: f64,
  pub RA_OF_ASC_NODE: f64,
  pub ARG_OF_PERICENTER: f64,
  pub ANOMALY_TYPE: anomalyType,
  pub ANOMALY: f64,
}
impl Default for keplerianElementsT {
  fn default() -> Self {
    Self {
      SEMI_MAJOR_AXIS: 0.0,
      ECCENTRICITY: 0.0,
      INCLINATION: 0.0,
      RA_OF_ASC_NODE: 0.0,
      ARG_OF_PERICENTER: 0.0,
      ANOMALY_TYPE: anomalyType::TRUE_ANOMALY,
      ANOMALY: 0.0,
    }
  }
}
impl keplerianElementsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<keplerianElements<'b>> {
    let SEMI_MAJOR_AXIS = self.SEMI_MAJOR_AXIS;
    let ECCENTRICITY = self.ECCENTRICITY;
    let INCLINATION = self.INCLINATION;
    let RA_OF_ASC_NODE = self.RA_OF_ASC_NODE;
    let ARG_OF_PERICENTER = self.ARG_OF_PERICENTER;
    let ANOMALY_TYPE = self.ANOMALY_TYPE;
    let ANOMALY = self.ANOMALY;
    keplerianElements::create(_fbb, &keplerianElementsArgs{
      SEMI_MAJOR_AXIS,
      ECCENTRICITY,
      INCLINATION,
      RA_OF_ASC_NODE,
      ARG_OF_PERICENTER,
      ANOMALY_TYPE,
      ANOMALY,
    })
  }
}
pub enum equinoctialElementsOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Equinoctial Elements
pub struct equinoctialElements<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for equinoctialElements<'a> {
  type Inner = equinoctialElements<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> equinoctialElements<'a> {
  pub const VT_AF: flatbuffers::VOffsetT = 4;
  pub const VT_AG: flatbuffers::VOffsetT = 6;
  pub const VT_L: flatbuffers::VOffsetT = 8;
  pub const VT_N: flatbuffers::VOffsetT = 10;
  pub const VT_CHI: flatbuffers::VOffsetT = 12;
  pub const VT_PSI: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    equinoctialElements { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args equinoctialElementsArgs
  ) -> flatbuffers::WIPOffset<equinoctialElements<'bldr>> {
    let mut builder = equinoctialElementsBuilder::new(_fbb);
    builder.add_PSI(args.PSI);
    builder.add_CHI(args.CHI);
    builder.add_N(args.N);
    builder.add_L(args.L);
    builder.add_AG(args.AG);
    builder.add_AF(args.AF);
    builder.finish()
  }

  pub fn unpack(&self) -> equinoctialElementsT {
    let AF = self.AF();
    let AG = self.AG();
    let L = self.L();
    let N = self.N();
    let CHI = self.CHI();
    let PSI = self.PSI();
    equinoctialElementsT {
      AF,
      AG,
      L,
      N,
      CHI,
      PSI,
    }
  }

  #[inline]
  pub fn AF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_AF, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn AG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_AG, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn L(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_L, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn N(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_N, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CHI(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_CHI, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PSI(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(equinoctialElements::VT_PSI, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for equinoctialElements<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("AF", Self::VT_AF, false)?
     .visit_field::<f64>("AG", Self::VT_AG, false)?
     .visit_field::<f64>("L", Self::VT_L, false)?
     .visit_field::<f64>("N", Self::VT_N, false)?
     .visit_field::<f64>("CHI", Self::VT_CHI, false)?
     .visit_field::<f64>("PSI", Self::VT_PSI, false)?
     .finish();
    Ok(())
  }
}
pub struct equinoctialElementsArgs {
    pub AF: f64,
    pub AG: f64,
    pub L: f64,
    pub N: f64,
    pub CHI: f64,
    pub PSI: f64,
}
impl<'a> Default for equinoctialElementsArgs {
  #[inline]
  fn default() -> Self {
    equinoctialElementsArgs {
      AF: 0.0,
      AG: 0.0,
      L: 0.0,
      N: 0.0,
      CHI: 0.0,
      PSI: 0.0,
    }
  }
}

pub struct equinoctialElementsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> equinoctialElementsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_AF(&mut self, AF: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_AF, AF, 0.0);
  }
  #[inline]
  pub fn add_AG(&mut self, AG: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_AG, AG, 0.0);
  }
  #[inline]
  pub fn add_L(&mut self, L: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_L, L, 0.0);
  }
  #[inline]
  pub fn add_N(&mut self, N: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_N, N, 0.0);
  }
  #[inline]
  pub fn add_CHI(&mut self, CHI: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_CHI, CHI, 0.0);
  }
  #[inline]
  pub fn add_PSI(&mut self, PSI: f64) {
    self.fbb_.push_slot::<f64>(equinoctialElements::VT_PSI, PSI, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> equinoctialElementsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    equinoctialElementsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<equinoctialElements<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for equinoctialElements<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("equinoctialElements");
      ds.field("AF", &self.AF());
      ds.field("AG", &self.AG());
      ds.field("L", &self.L());
      ds.field("N", &self.N());
      ds.field("CHI", &self.CHI());
      ds.field("PSI", &self.PSI());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct equinoctialElementsT {
  pub AF: f64,
  pub AG: f64,
  pub L: f64,
  pub N: f64,
  pub CHI: f64,
  pub PSI: f64,
}
impl Default for equinoctialElementsT {
  fn default() -> Self {
    Self {
      AF: 0.0,
      AG: 0.0,
      L: 0.0,
      N: 0.0,
      CHI: 0.0,
      PSI: 0.0,
    }
  }
}
impl equinoctialElementsT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<equinoctialElements<'b>> {
    let AF = self.AF;
    let AG = self.AG;
    let L = self.L;
    let N = self.N;
    let CHI = self.CHI;
    let PSI = self.PSI;
    equinoctialElements::create(_fbb, &equinoctialElementsArgs{
      AF,
      AG,
      L,
      N,
      CHI,
      PSI,
    })
  }
}
pub enum uvwSigmasOffset {}
#[derive(Copy, Clone, PartialEq)]

/// UVW Sigmas (Covariance matrix in UVW frame)
pub struct uvwSigmas<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for uvwSigmas<'a> {
  type Inner = uvwSigmas<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> uvwSigmas<'a> {
  pub const VT_U_SIGMA: flatbuffers::VOffsetT = 4;
  pub const VT_V_SIGMA: flatbuffers::VOffsetT = 6;
  pub const VT_W_SIGMA: flatbuffers::VOffsetT = 8;
  pub const VT_UD_SIGMA: flatbuffers::VOffsetT = 10;
  pub const VT_VD_SIGMA: flatbuffers::VOffsetT = 12;
  pub const VT_WD_SIGMA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    uvwSigmas { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args uvwSigmasArgs
  ) -> flatbuffers::WIPOffset<uvwSigmas<'bldr>> {
    let mut builder = uvwSigmasBuilder::new(_fbb);
    builder.add_WD_SIGMA(args.WD_SIGMA);
    builder.add_VD_SIGMA(args.VD_SIGMA);
    builder.add_UD_SIGMA(args.UD_SIGMA);
    builder.add_W_SIGMA(args.W_SIGMA);
    builder.add_V_SIGMA(args.V_SIGMA);
    builder.add_U_SIGMA(args.U_SIGMA);
    builder.finish()
  }

  pub fn unpack(&self) -> uvwSigmasT {
    let U_SIGMA = self.U_SIGMA();
    let V_SIGMA = self.V_SIGMA();
    let W_SIGMA = self.W_SIGMA();
    let UD_SIGMA = self.UD_SIGMA();
    let VD_SIGMA = self.VD_SIGMA();
    let WD_SIGMA = self.WD_SIGMA();
    uvwSigmasT {
      U_SIGMA,
      V_SIGMA,
      W_SIGMA,
      UD_SIGMA,
      VD_SIGMA,
      WD_SIGMA,
    }
  }

  #[inline]
  pub fn U_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_U_SIGMA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn V_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_V_SIGMA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn W_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_W_SIGMA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn UD_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_UD_SIGMA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn VD_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_VD_SIGMA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn WD_SIGMA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(uvwSigmas::VT_WD_SIGMA, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for uvwSigmas<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("U_SIGMA", Self::VT_U_SIGMA, false)?
     .visit_field::<f64>("V_SIGMA", Self::VT_V_SIGMA, false)?
     .visit_field::<f64>("W_SIGMA", Self::VT_W_SIGMA, false)?
     .visit_field::<f64>("UD_SIGMA", Self::VT_UD_SIGMA, false)?
     .visit_field::<f64>("VD_SIGMA", Self::VT_VD_SIGMA, false)?
     .visit_field::<f64>("WD_SIGMA", Self::VT_WD_SIGMA, false)?
     .finish();
    Ok(())
  }
}
pub struct uvwSigmasArgs {
    pub U_SIGMA: f64,
    pub V_SIGMA: f64,
    pub W_SIGMA: f64,
    pub UD_SIGMA: f64,
    pub VD_SIGMA: f64,
    pub WD_SIGMA: f64,
}
impl<'a> Default for uvwSigmasArgs {
  #[inline]
  fn default() -> Self {
    uvwSigmasArgs {
      U_SIGMA: 0.0,
      V_SIGMA: 0.0,
      W_SIGMA: 0.0,
      UD_SIGMA: 0.0,
      VD_SIGMA: 0.0,
      WD_SIGMA: 0.0,
    }
  }
}

pub struct uvwSigmasBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> uvwSigmasBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_U_SIGMA(&mut self, U_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_U_SIGMA, U_SIGMA, 0.0);
  }
  #[inline]
  pub fn add_V_SIGMA(&mut self, V_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_V_SIGMA, V_SIGMA, 0.0);
  }
  #[inline]
  pub fn add_W_SIGMA(&mut self, W_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_W_SIGMA, W_SIGMA, 0.0);
  }
  #[inline]
  pub fn add_UD_SIGMA(&mut self, UD_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_UD_SIGMA, UD_SIGMA, 0.0);
  }
  #[inline]
  pub fn add_VD_SIGMA(&mut self, VD_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_VD_SIGMA, VD_SIGMA, 0.0);
  }
  #[inline]
  pub fn add_WD_SIGMA(&mut self, WD_SIGMA: f64) {
    self.fbb_.push_slot::<f64>(uvwSigmas::VT_WD_SIGMA, WD_SIGMA, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> uvwSigmasBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    uvwSigmasBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<uvwSigmas<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for uvwSigmas<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("uvwSigmas");
      ds.field("U_SIGMA", &self.U_SIGMA());
      ds.field("V_SIGMA", &self.V_SIGMA());
      ds.field("W_SIGMA", &self.W_SIGMA());
      ds.field("UD_SIGMA", &self.UD_SIGMA());
      ds.field("VD_SIGMA", &self.VD_SIGMA());
      ds.field("WD_SIGMA", &self.WD_SIGMA());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct uvwSigmasT {
  pub U_SIGMA: f64,
  pub V_SIGMA: f64,
  pub W_SIGMA: f64,
  pub UD_SIGMA: f64,
  pub VD_SIGMA: f64,
  pub WD_SIGMA: f64,
}
impl Default for uvwSigmasT {
  fn default() -> Self {
    Self {
      U_SIGMA: 0.0,
      V_SIGMA: 0.0,
      W_SIGMA: 0.0,
      UD_SIGMA: 0.0,
      VD_SIGMA: 0.0,
      WD_SIGMA: 0.0,
    }
  }
}
impl uvwSigmasT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<uvwSigmas<'b>> {
    let U_SIGMA = self.U_SIGMA;
    let V_SIGMA = self.V_SIGMA;
    let W_SIGMA = self.W_SIGMA;
    let UD_SIGMA = self.UD_SIGMA;
    let VD_SIGMA = self.VD_SIGMA;
    let WD_SIGMA = self.WD_SIGMA;
    uvwSigmas::create(_fbb, &uvwSigmasArgs{
      U_SIGMA,
      V_SIGMA,
      W_SIGMA,
      UD_SIGMA,
      VD_SIGMA,
      WD_SIGMA,
    })
  }
}
pub enum opmAtmosphericModelDataOffset {}
#[derive(Copy, Clone, PartialEq)]

/// OPM Atmospheric and Perturbation Model Data
pub struct opmAtmosphericModelData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for opmAtmosphericModelData<'a> {
  type Inner = opmAtmosphericModelData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> opmAtmosphericModelData<'a> {
  pub const VT_ATMOSPHERIC_MODEL: flatbuffers::VOffsetT = 4;
  pub const VT_GEOPOTENTIAL_MODEL: flatbuffers::VOffsetT = 6;
  pub const VT_LUNAR_SOLAR_PERTURBATION: flatbuffers::VOffsetT = 8;
  pub const VT_LUNAR_PERTURBATION_MODEL: flatbuffers::VOffsetT = 10;
  pub const VT_SOLAR_PERTURBATION_MODEL: flatbuffers::VOffsetT = 12;
  pub const VT_SOLAR_RADIATION_PRESSURE: flatbuffers::VOffsetT = 14;
  pub const VT_SRP_MODEL: flatbuffers::VOffsetT = 16;
  pub const VT_RESONANCE_MODEL: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    opmAtmosphericModelData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args opmAtmosphericModelDataArgs
  ) -> flatbuffers::WIPOffset<opmAtmosphericModelData<'bldr>> {
    let mut builder = opmAtmosphericModelDataBuilder::new(_fbb);
    builder.add_RESONANCE_MODEL(args.RESONANCE_MODEL);
    builder.add_SRP_MODEL(args.SRP_MODEL);
    builder.add_SOLAR_RADIATION_PRESSURE(args.SOLAR_RADIATION_PRESSURE);
    builder.add_SOLAR_PERTURBATION_MODEL(args.SOLAR_PERTURBATION_MODEL);
    builder.add_LUNAR_PERTURBATION_MODEL(args.LUNAR_PERTURBATION_MODEL);
    builder.add_LUNAR_SOLAR_PERTURBATION(args.LUNAR_SOLAR_PERTURBATION);
    builder.add_GEOPOTENTIAL_MODEL(args.GEOPOTENTIAL_MODEL);
    builder.add_ATMOSPHERIC_MODEL(args.ATMOSPHERIC_MODEL);
    builder.finish()
  }

  pub fn unpack(&self) -> opmAtmosphericModelDataT {
    let ATMOSPHERIC_MODEL = self.ATMOSPHERIC_MODEL();
    let GEOPOTENTIAL_MODEL = self.GEOPOTENTIAL_MODEL();
    let LUNAR_SOLAR_PERTURBATION = self.LUNAR_SOLAR_PERTURBATION();
    let LUNAR_PERTURBATION_MODEL = self.LUNAR_PERTURBATION_MODEL();
    let SOLAR_PERTURBATION_MODEL = self.SOLAR_PERTURBATION_MODEL();
    let SOLAR_RADIATION_PRESSURE = self.SOLAR_RADIATION_PRESSURE();
    let SRP_MODEL = self.SRP_MODEL();
    let RESONANCE_MODEL = self.RESONANCE_MODEL();
    opmAtmosphericModelDataT {
      ATMOSPHERIC_MODEL,
      GEOPOTENTIAL_MODEL,
      LUNAR_SOLAR_PERTURBATION,
      LUNAR_PERTURBATION_MODEL,
      SOLAR_PERTURBATION_MODEL,
      SOLAR_RADIATION_PRESSURE,
      SRP_MODEL,
      RESONANCE_MODEL,
    }
  }

  #[inline]
  pub fn ATMOSPHERIC_MODEL(&self) -> atmosphericModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<atmosphericModel>(opmAtmosphericModelData::VT_ATMOSPHERIC_MODEL, Some(atmosphericModel::NONE)).unwrap()}
  }
  #[inline]
  pub fn GEOPOTENTIAL_MODEL(&self) -> geopotentialModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<geopotentialModel>(opmAtmosphericModelData::VT_GEOPOTENTIAL_MODEL, Some(geopotentialModel::NONE)).unwrap()}
  }
  #[inline]
  pub fn LUNAR_SOLAR_PERTURBATION(&self) -> perturbationStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<perturbationStatus>(opmAtmosphericModelData::VT_LUNAR_SOLAR_PERTURBATION, Some(perturbationStatus::OFF)).unwrap()}
  }
  #[inline]
  pub fn LUNAR_PERTURBATION_MODEL(&self) -> lunarPerturbationModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<lunarPerturbationModel>(opmAtmosphericModelData::VT_LUNAR_PERTURBATION_MODEL, Some(lunarPerturbationModel::NONE)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_PERTURBATION_MODEL(&self) -> solarPerturbationModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<solarPerturbationModel>(opmAtmosphericModelData::VT_SOLAR_PERTURBATION_MODEL, Some(solarPerturbationModel::NONE)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_RADIATION_PRESSURE(&self) -> perturbationStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<perturbationStatus>(opmAtmosphericModelData::VT_SOLAR_RADIATION_PRESSURE, Some(perturbationStatus::OFF)).unwrap()}
  }
  #[inline]
  pub fn SRP_MODEL(&self) -> solarRadiationPressureModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<solarRadiationPressureModel>(opmAtmosphericModelData::VT_SRP_MODEL, Some(solarRadiationPressureModel::NONE)).unwrap()}
  }
  #[inline]
  pub fn RESONANCE_MODEL(&self) -> resonanceModel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<resonanceModel>(opmAtmosphericModelData::VT_RESONANCE_MODEL, Some(resonanceModel::NONE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for opmAtmosphericModelData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<atmosphericModel>("ATMOSPHERIC_MODEL", Self::VT_ATMOSPHERIC_MODEL, false)?
     .visit_field::<geopotentialModel>("GEOPOTENTIAL_MODEL", Self::VT_GEOPOTENTIAL_MODEL, false)?
     .visit_field::<perturbationStatus>("LUNAR_SOLAR_PERTURBATION", Self::VT_LUNAR_SOLAR_PERTURBATION, false)?
     .visit_field::<lunarPerturbationModel>("LUNAR_PERTURBATION_MODEL", Self::VT_LUNAR_PERTURBATION_MODEL, false)?
     .visit_field::<solarPerturbationModel>("SOLAR_PERTURBATION_MODEL", Self::VT_SOLAR_PERTURBATION_MODEL, false)?
     .visit_field::<perturbationStatus>("SOLAR_RADIATION_PRESSURE", Self::VT_SOLAR_RADIATION_PRESSURE, false)?
     .visit_field::<solarRadiationPressureModel>("SRP_MODEL", Self::VT_SRP_MODEL, false)?
     .visit_field::<resonanceModel>("RESONANCE_MODEL", Self::VT_RESONANCE_MODEL, false)?
     .finish();
    Ok(())
  }
}
pub struct opmAtmosphericModelDataArgs {
    pub ATMOSPHERIC_MODEL: atmosphericModel,
    pub GEOPOTENTIAL_MODEL: geopotentialModel,
    pub LUNAR_SOLAR_PERTURBATION: perturbationStatus,
    pub LUNAR_PERTURBATION_MODEL: lunarPerturbationModel,
    pub SOLAR_PERTURBATION_MODEL: solarPerturbationModel,
    pub SOLAR_RADIATION_PRESSURE: perturbationStatus,
    pub SRP_MODEL: solarRadiationPressureModel,
    pub RESONANCE_MODEL: resonanceModel,
}
impl<'a> Default for opmAtmosphericModelDataArgs {
  #[inline]
  fn default() -> Self {
    opmAtmosphericModelDataArgs {
      ATMOSPHERIC_MODEL: atmosphericModel::NONE,
      GEOPOTENTIAL_MODEL: geopotentialModel::NONE,
      LUNAR_SOLAR_PERTURBATION: perturbationStatus::OFF,
      LUNAR_PERTURBATION_MODEL: lunarPerturbationModel::NONE,
      SOLAR_PERTURBATION_MODEL: solarPerturbationModel::NONE,
      SOLAR_RADIATION_PRESSURE: perturbationStatus::OFF,
      SRP_MODEL: solarRadiationPressureModel::NONE,
      RESONANCE_MODEL: resonanceModel::NONE,
    }
  }
}

pub struct opmAtmosphericModelDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> opmAtmosphericModelDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ATMOSPHERIC_MODEL(&mut self, ATMOSPHERIC_MODEL: atmosphericModel) {
    self.fbb_.push_slot::<atmosphericModel>(opmAtmosphericModelData::VT_ATMOSPHERIC_MODEL, ATMOSPHERIC_MODEL, atmosphericModel::NONE);
  }
  #[inline]
  pub fn add_GEOPOTENTIAL_MODEL(&mut self, GEOPOTENTIAL_MODEL: geopotentialModel) {
    self.fbb_.push_slot::<geopotentialModel>(opmAtmosphericModelData::VT_GEOPOTENTIAL_MODEL, GEOPOTENTIAL_MODEL, geopotentialModel::NONE);
  }
  #[inline]
  pub fn add_LUNAR_SOLAR_PERTURBATION(&mut self, LUNAR_SOLAR_PERTURBATION: perturbationStatus) {
    self.fbb_.push_slot::<perturbationStatus>(opmAtmosphericModelData::VT_LUNAR_SOLAR_PERTURBATION, LUNAR_SOLAR_PERTURBATION, perturbationStatus::OFF);
  }
  #[inline]
  pub fn add_LUNAR_PERTURBATION_MODEL(&mut self, LUNAR_PERTURBATION_MODEL: lunarPerturbationModel) {
    self.fbb_.push_slot::<lunarPerturbationModel>(opmAtmosphericModelData::VT_LUNAR_PERTURBATION_MODEL, LUNAR_PERTURBATION_MODEL, lunarPerturbationModel::NONE);
  }
  #[inline]
  pub fn add_SOLAR_PERTURBATION_MODEL(&mut self, SOLAR_PERTURBATION_MODEL: solarPerturbationModel) {
    self.fbb_.push_slot::<solarPerturbationModel>(opmAtmosphericModelData::VT_SOLAR_PERTURBATION_MODEL, SOLAR_PERTURBATION_MODEL, solarPerturbationModel::NONE);
  }
  #[inline]
  pub fn add_SOLAR_RADIATION_PRESSURE(&mut self, SOLAR_RADIATION_PRESSURE: perturbationStatus) {
    self.fbb_.push_slot::<perturbationStatus>(opmAtmosphericModelData::VT_SOLAR_RADIATION_PRESSURE, SOLAR_RADIATION_PRESSURE, perturbationStatus::OFF);
  }
  #[inline]
  pub fn add_SRP_MODEL(&mut self, SRP_MODEL: solarRadiationPressureModel) {
    self.fbb_.push_slot::<solarRadiationPressureModel>(opmAtmosphericModelData::VT_SRP_MODEL, SRP_MODEL, solarRadiationPressureModel::NONE);
  }
  #[inline]
  pub fn add_RESONANCE_MODEL(&mut self, RESONANCE_MODEL: resonanceModel) {
    self.fbb_.push_slot::<resonanceModel>(opmAtmosphericModelData::VT_RESONANCE_MODEL, RESONANCE_MODEL, resonanceModel::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> opmAtmosphericModelDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    opmAtmosphericModelDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<opmAtmosphericModelData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for opmAtmosphericModelData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("opmAtmosphericModelData");
      ds.field("ATMOSPHERIC_MODEL", &self.ATMOSPHERIC_MODEL());
      ds.field("GEOPOTENTIAL_MODEL", &self.GEOPOTENTIAL_MODEL());
      ds.field("LUNAR_SOLAR_PERTURBATION", &self.LUNAR_SOLAR_PERTURBATION());
      ds.field("LUNAR_PERTURBATION_MODEL", &self.LUNAR_PERTURBATION_MODEL());
      ds.field("SOLAR_PERTURBATION_MODEL", &self.SOLAR_PERTURBATION_MODEL());
      ds.field("SOLAR_RADIATION_PRESSURE", &self.SOLAR_RADIATION_PRESSURE());
      ds.field("SRP_MODEL", &self.SRP_MODEL());
      ds.field("RESONANCE_MODEL", &self.RESONANCE_MODEL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct opmAtmosphericModelDataT {
  pub ATMOSPHERIC_MODEL: atmosphericModel,
  pub GEOPOTENTIAL_MODEL: geopotentialModel,
  pub LUNAR_SOLAR_PERTURBATION: perturbationStatus,
  pub LUNAR_PERTURBATION_MODEL: lunarPerturbationModel,
  pub SOLAR_PERTURBATION_MODEL: solarPerturbationModel,
  pub SOLAR_RADIATION_PRESSURE: perturbationStatus,
  pub SRP_MODEL: solarRadiationPressureModel,
  pub RESONANCE_MODEL: resonanceModel,
}
impl Default for opmAtmosphericModelDataT {
  fn default() -> Self {
    Self {
      ATMOSPHERIC_MODEL: atmosphericModel::NONE,
      GEOPOTENTIAL_MODEL: geopotentialModel::NONE,
      LUNAR_SOLAR_PERTURBATION: perturbationStatus::OFF,
      LUNAR_PERTURBATION_MODEL: lunarPerturbationModel::NONE,
      SOLAR_PERTURBATION_MODEL: solarPerturbationModel::NONE,
      SOLAR_RADIATION_PRESSURE: perturbationStatus::OFF,
      SRP_MODEL: solarRadiationPressureModel::NONE,
      RESONANCE_MODEL: resonanceModel::NONE,
    }
  }
}
impl opmAtmosphericModelDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<opmAtmosphericModelData<'b>> {
    let ATMOSPHERIC_MODEL = self.ATMOSPHERIC_MODEL;
    let GEOPOTENTIAL_MODEL = self.GEOPOTENTIAL_MODEL;
    let LUNAR_SOLAR_PERTURBATION = self.LUNAR_SOLAR_PERTURBATION;
    let LUNAR_PERTURBATION_MODEL = self.LUNAR_PERTURBATION_MODEL;
    let SOLAR_PERTURBATION_MODEL = self.SOLAR_PERTURBATION_MODEL;
    let SOLAR_RADIATION_PRESSURE = self.SOLAR_RADIATION_PRESSURE;
    let SRP_MODEL = self.SRP_MODEL;
    let RESONANCE_MODEL = self.RESONANCE_MODEL;
    opmAtmosphericModelData::create(_fbb, &opmAtmosphericModelDataArgs{
      ATMOSPHERIC_MODEL,
      GEOPOTENTIAL_MODEL,
      LUNAR_SOLAR_PERTURBATION,
      LUNAR_PERTURBATION_MODEL,
      SOLAR_PERTURBATION_MODEL,
      SOLAR_RADIATION_PRESSURE,
      SRP_MODEL,
      RESONANCE_MODEL,
    })
  }
}
pub enum OPMOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Orbit Parameter Message (OPM)
pub struct OPM<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OPM<'a> {
  type Inner = OPM<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OPM<'a> {
  pub const VT_CCSDS_OMM_VERS: flatbuffers::VOffsetT = 4;
  pub const VT_CREATION_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_ORIGINATOR: flatbuffers::VOffsetT = 8;
  pub const VT_OBJECT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_OBJECT_ID: flatbuffers::VOffsetT = 12;
  pub const VT_CENTER_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_REF_FRAME: flatbuffers::VOffsetT = 16;
  pub const VT_TIME_SYSTEM: flatbuffers::VOffsetT = 18;
  pub const VT_STATE_VECTOR: flatbuffers::VOffsetT = 20;
  pub const VT_KEPLERIAN_ELEMENTS: flatbuffers::VOffsetT = 22;
  pub const VT_EQUINOCTIAL_ELEMENTS: flatbuffers::VOffsetT = 24;
  pub const VT_GM: flatbuffers::VOffsetT = 26;
  pub const VT_ATMOSPHERIC_MODEL_DATA: flatbuffers::VOffsetT = 28;
  pub const VT_PROPAGATOR_SETTINGS: flatbuffers::VOffsetT = 30;
  pub const VT_COVARIANCE_MATRIX: flatbuffers::VOffsetT = 32;
  pub const VT_UVW_SIGMAS: flatbuffers::VOffsetT = 34;
  pub const VT_MASS: flatbuffers::VOffsetT = 36;
  pub const VT_SOLAR_RAD_AREA: flatbuffers::VOffsetT = 38;
  pub const VT_SOLAR_RAD_COEFF: flatbuffers::VOffsetT = 40;
  pub const VT_DRAG_AREA: flatbuffers::VOffsetT = 42;
  pub const VT_DRAG_COEFF: flatbuffers::VOffsetT = 44;
  pub const VT_SRP: flatbuffers::VOffsetT = 46;
  pub const VT_CLASSIFICATION_TYPE: flatbuffers::VOffsetT = 48;
  pub const VT_NORAD_CAT_ID: flatbuffers::VOffsetT = 50;
  pub const VT_ELEMENT_SET_NO: flatbuffers::VOffsetT = 52;
  pub const VT_REV_AT_EPOCH: flatbuffers::VOffsetT = 54;
  pub const VT_BSTAR: flatbuffers::VOffsetT = 56;
  pub const VT_MEAN_MOTION_DOT: flatbuffers::VOffsetT = 58;
  pub const VT_MEAN_MOTION_DDOT: flatbuffers::VOffsetT = 60;
  pub const VT_COV_REFERENCE_FRAME: flatbuffers::VOffsetT = 62;
  pub const VT_CX_X: flatbuffers::VOffsetT = 64;
  pub const VT_CY_X: flatbuffers::VOffsetT = 66;
  pub const VT_CZ_X: flatbuffers::VOffsetT = 68;
  pub const VT_CX_DOT_X: flatbuffers::VOffsetT = 70;
  pub const VT_USER_DEFINED_BIP_0044_TYPE: flatbuffers::VOffsetT = 72;
  pub const VT_USER_DEFINED_OBJECT_DESIGNATOR: flatbuffers::VOffsetT = 74;
  pub const VT_USER_DEFINED_EARTH_MODEL: flatbuffers::VOffsetT = 76;
  pub const VT_USER_DEFINED_EPOCH_TIMESTAMP: flatbuffers::VOffsetT = 78;
  pub const VT_USER_DEFINED_MICROSECONDS: flatbuffers::VOffsetT = 80;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OPM { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OPMArgs<'args>
  ) -> flatbuffers::WIPOffset<OPM<'bldr>> {
    let mut builder = OPMBuilder::new(_fbb);
    builder.add_USER_DEFINED_MICROSECONDS(args.USER_DEFINED_MICROSECONDS);
    builder.add_USER_DEFINED_EPOCH_TIMESTAMP(args.USER_DEFINED_EPOCH_TIMESTAMP);
    builder.add_CX_DOT_X(args.CX_DOT_X);
    builder.add_CZ_X(args.CZ_X);
    builder.add_CY_X(args.CY_X);
    builder.add_CX_X(args.CX_X);
    builder.add_MEAN_MOTION_DDOT(args.MEAN_MOTION_DDOT);
    builder.add_MEAN_MOTION_DOT(args.MEAN_MOTION_DOT);
    builder.add_BSTAR(args.BSTAR);
    builder.add_REV_AT_EPOCH(args.REV_AT_EPOCH);
    builder.add_DRAG_COEFF(args.DRAG_COEFF);
    builder.add_DRAG_AREA(args.DRAG_AREA);
    builder.add_SOLAR_RAD_COEFF(args.SOLAR_RAD_COEFF);
    builder.add_SOLAR_RAD_AREA(args.SOLAR_RAD_AREA);
    builder.add_MASS(args.MASS);
    builder.add_GM(args.GM);
    builder.add_CCSDS_OMM_VERS(args.CCSDS_OMM_VERS);
    if let Some(x) = args.USER_DEFINED_EARTH_MODEL { builder.add_USER_DEFINED_EARTH_MODEL(x); }
    if let Some(x) = args.USER_DEFINED_OBJECT_DESIGNATOR { builder.add_USER_DEFINED_OBJECT_DESIGNATOR(x); }
    builder.add_USER_DEFINED_BIP_0044_TYPE(args.USER_DEFINED_BIP_0044_TYPE);
    if let Some(x) = args.COV_REFERENCE_FRAME { builder.add_COV_REFERENCE_FRAME(x); }
    builder.add_ELEMENT_SET_NO(args.ELEMENT_SET_NO);
    builder.add_NORAD_CAT_ID(args.NORAD_CAT_ID);
    if let Some(x) = args.CLASSIFICATION_TYPE { builder.add_CLASSIFICATION_TYPE(x); }
    if let Some(x) = args.UVW_SIGMAS { builder.add_UVW_SIGMAS(x); }
    if let Some(x) = args.COVARIANCE_MATRIX { builder.add_COVARIANCE_MATRIX(x); }
    if let Some(x) = args.PROPAGATOR_SETTINGS { builder.add_PROPAGATOR_SETTINGS(x); }
    if let Some(x) = args.ATMOSPHERIC_MODEL_DATA { builder.add_ATMOSPHERIC_MODEL_DATA(x); }
    if let Some(x) = args.EQUINOCTIAL_ELEMENTS { builder.add_EQUINOCTIAL_ELEMENTS(x); }
    if let Some(x) = args.KEPLERIAN_ELEMENTS { builder.add_KEPLERIAN_ELEMENTS(x); }
    if let Some(x) = args.STATE_VECTOR { builder.add_STATE_VECTOR(x); }
    if let Some(x) = args.TIME_SYSTEM { builder.add_TIME_SYSTEM(x); }
    if let Some(x) = args.REF_FRAME { builder.add_REF_FRAME(x); }
    if let Some(x) = args.CENTER_NAME { builder.add_CENTER_NAME(x); }
    if let Some(x) = args.OBJECT_ID { builder.add_OBJECT_ID(x); }
    if let Some(x) = args.OBJECT_NAME { builder.add_OBJECT_NAME(x); }
    if let Some(x) = args.ORIGINATOR { builder.add_ORIGINATOR(x); }
    if let Some(x) = args.CREATION_DATE { builder.add_CREATION_DATE(x); }
    builder.add_SRP(args.SRP);
    builder.finish()
  }

  pub fn unpack(&self) -> OPMT {
    let CCSDS_OMM_VERS = self.CCSDS_OMM_VERS();
    let CREATION_DATE = self.CREATION_DATE().map(|x| {
      x.to_string()
    });
    let ORIGINATOR = self.ORIGINATOR().map(|x| {
      x.to_string()
    });
    let OBJECT_NAME = self.OBJECT_NAME().map(|x| {
      x.to_string()
    });
    let OBJECT_ID = self.OBJECT_ID().map(|x| {
      x.to_string()
    });
    let CENTER_NAME = self.CENTER_NAME().map(|x| {
      x.to_string()
    });
    let REF_FRAME = self.REF_FRAME().map(|x| {
      x.to_string()
    });
    let TIME_SYSTEM = self.TIME_SYSTEM().map(|x| {
      x.to_string()
    });
    let STATE_VECTOR = self.STATE_VECTOR().map(|x| {
      Box::new(x.unpack())
    });
    let KEPLERIAN_ELEMENTS = self.KEPLERIAN_ELEMENTS().map(|x| {
      Box::new(x.unpack())
    });
    let EQUINOCTIAL_ELEMENTS = self.EQUINOCTIAL_ELEMENTS().map(|x| {
      Box::new(x.unpack())
    });
    let GM = self.GM();
    let ATMOSPHERIC_MODEL_DATA = self.ATMOSPHERIC_MODEL_DATA().map(|x| {
      Box::new(x.unpack())
    });
    let PROPAGATOR_SETTINGS = self.PROPAGATOR_SETTINGS().map(|x| {
      Box::new(x.unpack())
    });
    let COVARIANCE_MATRIX = self.COVARIANCE_MATRIX().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let UVW_SIGMAS = self.UVW_SIGMAS().map(|x| {
      Box::new(x.unpack())
    });
    let MASS = self.MASS();
    let SOLAR_RAD_AREA = self.SOLAR_RAD_AREA();
    let SOLAR_RAD_COEFF = self.SOLAR_RAD_COEFF();
    let DRAG_AREA = self.DRAG_AREA();
    let DRAG_COEFF = self.DRAG_COEFF();
    let SRP = self.SRP();
    let CLASSIFICATION_TYPE = self.CLASSIFICATION_TYPE().map(|x| {
      x.to_string()
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID();
    let ELEMENT_SET_NO = self.ELEMENT_SET_NO();
    let REV_AT_EPOCH = self.REV_AT_EPOCH();
    let BSTAR = self.BSTAR();
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT();
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT();
    let COV_REFERENCE_FRAME = self.COV_REFERENCE_FRAME().map(|x| {
      x.to_string()
    });
    let CX_X = self.CX_X();
    let CY_X = self.CY_X();
    let CZ_X = self.CZ_X();
    let CX_DOT_X = self.CX_DOT_X();
    let USER_DEFINED_BIP_0044_TYPE = self.USER_DEFINED_BIP_0044_TYPE();
    let USER_DEFINED_OBJECT_DESIGNATOR = self.USER_DEFINED_OBJECT_DESIGNATOR().map(|x| {
      x.to_string()
    });
    let USER_DEFINED_EARTH_MODEL = self.USER_DEFINED_EARTH_MODEL().map(|x| {
      x.to_string()
    });
    let USER_DEFINED_EPOCH_TIMESTAMP = self.USER_DEFINED_EPOCH_TIMESTAMP();
    let USER_DEFINED_MICROSECONDS = self.USER_DEFINED_MICROSECONDS();
    OPMT {
      CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      TIME_SYSTEM,
      STATE_VECTOR,
      KEPLERIAN_ELEMENTS,
      EQUINOCTIAL_ELEMENTS,
      GM,
      ATMOSPHERIC_MODEL_DATA,
      PROPAGATOR_SETTINGS,
      COVARIANCE_MATRIX,
      UVW_SIGMAS,
      MASS,
      SOLAR_RAD_AREA,
      SOLAR_RAD_COEFF,
      DRAG_AREA,
      DRAG_COEFF,
      SRP,
      CLASSIFICATION_TYPE,
      NORAD_CAT_ID,
      ELEMENT_SET_NO,
      REV_AT_EPOCH,
      BSTAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      COV_REFERENCE_FRAME,
      CX_X,
      CY_X,
      CZ_X,
      CX_DOT_X,
      USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      USER_DEFINED_EPOCH_TIMESTAMP,
      USER_DEFINED_MICROSECONDS,
    }
  }

  #[inline]
  pub fn CCSDS_OMM_VERS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_CCSDS_OMM_VERS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CREATION_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CREATION_DATE, None)}
  }
  #[inline]
  pub fn ORIGINATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_ORIGINATOR, None)}
  }
  #[inline]
  pub fn OBJECT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_OBJECT_NAME, None)}
  }
  #[inline]
  pub fn OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_OBJECT_ID, None)}
  }
  #[inline]
  pub fn CENTER_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CENTER_NAME, None)}
  }
  #[inline]
  pub fn REF_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_REF_FRAME, None)}
  }
  #[inline]
  pub fn TIME_SYSTEM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_TIME_SYSTEM, None)}
  }
  #[inline]
  pub fn STATE_VECTOR(&self) -> Option<opmStateVector<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<opmStateVector>>(OPM::VT_STATE_VECTOR, None)}
  }
  #[inline]
  pub fn KEPLERIAN_ELEMENTS(&self) -> Option<keplerianElements<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<keplerianElements>>(OPM::VT_KEPLERIAN_ELEMENTS, None)}
  }
  #[inline]
  pub fn EQUINOCTIAL_ELEMENTS(&self) -> Option<equinoctialElements<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<equinoctialElements>>(OPM::VT_EQUINOCTIAL_ELEMENTS, None)}
  }
  #[inline]
  pub fn GM(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_GM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ATMOSPHERIC_MODEL_DATA(&self) -> Option<opmAtmosphericModelData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<opmAtmosphericModelData>>(OPM::VT_ATMOSPHERIC_MODEL_DATA, None)}
  }
  #[inline]
  pub fn PROPAGATOR_SETTINGS(&self) -> Option<propagatorConfig<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<propagatorConfig>>(OPM::VT_PROPAGATOR_SETTINGS, None)}
  }
  #[inline]
  pub fn COVARIANCE_MATRIX(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<opmCovarianceMatrixLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<opmCovarianceMatrixLine>>>>(OPM::VT_COVARIANCE_MATRIX, None)}
  }
  #[inline]
  pub fn UVW_SIGMAS(&self) -> Option<uvwSigmas<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<uvwSigmas>>(OPM::VT_UVW_SIGMAS, None)}
  }
  #[inline]
  pub fn MASS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_MASS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_RAD_AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_SOLAR_RAD_AREA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SOLAR_RAD_COEFF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_SOLAR_RAD_COEFF, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRAG_AREA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_DRAG_AREA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn DRAG_COEFF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_DRAG_COEFF, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn SRP(&self) -> perturbationStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<perturbationStatus>(OPM::VT_SRP, Some(perturbationStatus::OFF)).unwrap()}
  }
  #[inline]
  pub fn CLASSIFICATION_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_CLASSIFICATION_TYPE, None)}
  }
  #[inline]
  pub fn NORAD_CAT_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OPM::VT_NORAD_CAT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ELEMENT_SET_NO(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OPM::VT_ELEMENT_SET_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn REV_AT_EPOCH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_REV_AT_EPOCH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BSTAR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_BSTAR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_MEAN_MOTION_DOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn MEAN_MOTION_DDOT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_MEAN_MOTION_DDOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn COV_REFERENCE_FRAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_COV_REFERENCE_FRAME, None)}
  }
  #[inline]
  pub fn CX_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_CX_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CY_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_CY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CZ_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_CZ_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn CX_DOT_X(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_CX_DOT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn USER_DEFINED_BIP_0044_TYPE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(OPM::VT_USER_DEFINED_BIP_0044_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn USER_DEFINED_OBJECT_DESIGNATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_USER_DEFINED_OBJECT_DESIGNATOR, None)}
  }
  #[inline]
  pub fn USER_DEFINED_EARTH_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OPM::VT_USER_DEFINED_EARTH_MODEL, None)}
  }
  #[inline]
  pub fn USER_DEFINED_EPOCH_TIMESTAMP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_USER_DEFINED_EPOCH_TIMESTAMP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn USER_DEFINED_MICROSECONDS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OPM::VT_USER_DEFINED_MICROSECONDS, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for OPM<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("CCSDS_OMM_VERS", Self::VT_CCSDS_OMM_VERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CREATION_DATE", Self::VT_CREATION_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIGINATOR", Self::VT_ORIGINATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_NAME", Self::VT_OBJECT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OBJECT_ID", Self::VT_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CENTER_NAME", Self::VT_CENTER_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REF_FRAME", Self::VT_REF_FRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TIME_SYSTEM", Self::VT_TIME_SYSTEM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<opmStateVector>>("STATE_VECTOR", Self::VT_STATE_VECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<keplerianElements>>("KEPLERIAN_ELEMENTS", Self::VT_KEPLERIAN_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<equinoctialElements>>("EQUINOCTIAL_ELEMENTS", Self::VT_EQUINOCTIAL_ELEMENTS, false)?
     .visit_field::<f64>("GM", Self::VT_GM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<opmAtmosphericModelData>>("ATMOSPHERIC_MODEL_DATA", Self::VT_ATMOSPHERIC_MODEL_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<propagatorConfig>>("PROPAGATOR_SETTINGS", Self::VT_PROPAGATOR_SETTINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<opmCovarianceMatrixLine>>>>("COVARIANCE_MATRIX", Self::VT_COVARIANCE_MATRIX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<uvwSigmas>>("UVW_SIGMAS", Self::VT_UVW_SIGMAS, false)?
     .visit_field::<f64>("MASS", Self::VT_MASS, false)?
     .visit_field::<f64>("SOLAR_RAD_AREA", Self::VT_SOLAR_RAD_AREA, false)?
     .visit_field::<f64>("SOLAR_RAD_COEFF", Self::VT_SOLAR_RAD_COEFF, false)?
     .visit_field::<f64>("DRAG_AREA", Self::VT_DRAG_AREA, false)?
     .visit_field::<f64>("DRAG_COEFF", Self::VT_DRAG_COEFF, false)?
     .visit_field::<perturbationStatus>("SRP", Self::VT_SRP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION_TYPE", Self::VT_CLASSIFICATION_TYPE, false)?
     .visit_field::<u32>("NORAD_CAT_ID", Self::VT_NORAD_CAT_ID, false)?
     .visit_field::<u32>("ELEMENT_SET_NO", Self::VT_ELEMENT_SET_NO, false)?
     .visit_field::<f64>("REV_AT_EPOCH", Self::VT_REV_AT_EPOCH, false)?
     .visit_field::<f64>("BSTAR", Self::VT_BSTAR, false)?
     .visit_field::<f64>("MEAN_MOTION_DOT", Self::VT_MEAN_MOTION_DOT, false)?
     .visit_field::<f64>("MEAN_MOTION_DDOT", Self::VT_MEAN_MOTION_DDOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COV_REFERENCE_FRAME", Self::VT_COV_REFERENCE_FRAME, false)?
     .visit_field::<f64>("CX_X", Self::VT_CX_X, false)?
     .visit_field::<f64>("CY_X", Self::VT_CY_X, false)?
     .visit_field::<f64>("CZ_X", Self::VT_CZ_X, false)?
     .visit_field::<f64>("CX_DOT_X", Self::VT_CX_DOT_X, false)?
     .visit_field::<u32>("USER_DEFINED_BIP_0044_TYPE", Self::VT_USER_DEFINED_BIP_0044_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USER_DEFINED_OBJECT_DESIGNATOR", Self::VT_USER_DEFINED_OBJECT_DESIGNATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("USER_DEFINED_EARTH_MODEL", Self::VT_USER_DEFINED_EARTH_MODEL, false)?
     .visit_field::<f64>("USER_DEFINED_EPOCH_TIMESTAMP", Self::VT_USER_DEFINED_EPOCH_TIMESTAMP, false)?
     .visit_field::<f64>("USER_DEFINED_MICROSECONDS", Self::VT_USER_DEFINED_MICROSECONDS, false)?
     .finish();
    Ok(())
  }
}
pub struct OPMArgs<'a> {
    pub CCSDS_OMM_VERS: f64,
    pub CREATION_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIGINATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CENTER_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub REF_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_SYSTEM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STATE_VECTOR: Option<flatbuffers::WIPOffset<opmStateVector<'a>>>,
    pub KEPLERIAN_ELEMENTS: Option<flatbuffers::WIPOffset<keplerianElements<'a>>>,
    pub EQUINOCTIAL_ELEMENTS: Option<flatbuffers::WIPOffset<equinoctialElements<'a>>>,
    pub GM: f64,
    pub ATMOSPHERIC_MODEL_DATA: Option<flatbuffers::WIPOffset<opmAtmosphericModelData<'a>>>,
    pub PROPAGATOR_SETTINGS: Option<flatbuffers::WIPOffset<propagatorConfig<'a>>>,
    pub COVARIANCE_MATRIX: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<opmCovarianceMatrixLine<'a>>>>>,
    pub UVW_SIGMAS: Option<flatbuffers::WIPOffset<uvwSigmas<'a>>>,
    pub MASS: f64,
    pub SOLAR_RAD_AREA: f64,
    pub SOLAR_RAD_COEFF: f64,
    pub DRAG_AREA: f64,
    pub DRAG_COEFF: f64,
    pub SRP: perturbationStatus,
    pub CLASSIFICATION_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NORAD_CAT_ID: u32,
    pub ELEMENT_SET_NO: u32,
    pub REV_AT_EPOCH: f64,
    pub BSTAR: f64,
    pub MEAN_MOTION_DOT: f64,
    pub MEAN_MOTION_DDOT: f64,
    pub COV_REFERENCE_FRAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CX_X: f64,
    pub CY_X: f64,
    pub CZ_X: f64,
    pub CX_DOT_X: f64,
    pub USER_DEFINED_BIP_0044_TYPE: u32,
    pub USER_DEFINED_OBJECT_DESIGNATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USER_DEFINED_EARTH_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USER_DEFINED_EPOCH_TIMESTAMP: f64,
    pub USER_DEFINED_MICROSECONDS: f64,
}
impl<'a> Default for OPMArgs<'a> {
  #[inline]
  fn default() -> Self {
    OPMArgs {
      CCSDS_OMM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: None,
      TIME_SYSTEM: None,
      STATE_VECTOR: None,
      KEPLERIAN_ELEMENTS: None,
      EQUINOCTIAL_ELEMENTS: None,
      GM: 0.0,
      ATMOSPHERIC_MODEL_DATA: None,
      PROPAGATOR_SETTINGS: None,
      COVARIANCE_MATRIX: None,
      UVW_SIGMAS: None,
      MASS: 0.0,
      SOLAR_RAD_AREA: 0.0,
      SOLAR_RAD_COEFF: 0.0,
      DRAG_AREA: 0.0,
      DRAG_COEFF: 0.0,
      SRP: perturbationStatus::OFF,
      CLASSIFICATION_TYPE: None,
      NORAD_CAT_ID: 0,
      ELEMENT_SET_NO: 0,
      REV_AT_EPOCH: 0.0,
      BSTAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      COV_REFERENCE_FRAME: None,
      CX_X: 0.0,
      CY_X: 0.0,
      CZ_X: 0.0,
      CX_DOT_X: 0.0,
      USER_DEFINED_BIP_0044_TYPE: 0,
      USER_DEFINED_OBJECT_DESIGNATOR: None,
      USER_DEFINED_EARTH_MODEL: None,
      USER_DEFINED_EPOCH_TIMESTAMP: 0.0,
      USER_DEFINED_MICROSECONDS: 0.0,
    }
  }
}

pub struct OPMBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OPMBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CCSDS_OMM_VERS(&mut self, CCSDS_OMM_VERS: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_CCSDS_OMM_VERS, CCSDS_OMM_VERS, 0.0);
  }
  #[inline]
  pub fn add_CREATION_DATE(&mut self, CREATION_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CREATION_DATE, CREATION_DATE);
  }
  #[inline]
  pub fn add_ORIGINATOR(&mut self, ORIGINATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_ORIGINATOR, ORIGINATOR);
  }
  #[inline]
  pub fn add_OBJECT_NAME(&mut self, OBJECT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_OBJECT_NAME, OBJECT_NAME);
  }
  #[inline]
  pub fn add_OBJECT_ID(&mut self, OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_OBJECT_ID, OBJECT_ID);
  }
  #[inline]
  pub fn add_CENTER_NAME(&mut self, CENTER_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CENTER_NAME, CENTER_NAME);
  }
  #[inline]
  pub fn add_REF_FRAME(&mut self, REF_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_REF_FRAME, REF_FRAME);
  }
  #[inline]
  pub fn add_TIME_SYSTEM(&mut self, TIME_SYSTEM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_TIME_SYSTEM, TIME_SYSTEM);
  }
  #[inline]
  pub fn add_STATE_VECTOR(&mut self, STATE_VECTOR: flatbuffers::WIPOffset<opmStateVector<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<opmStateVector>>(OPM::VT_STATE_VECTOR, STATE_VECTOR);
  }
  #[inline]
  pub fn add_KEPLERIAN_ELEMENTS(&mut self, KEPLERIAN_ELEMENTS: flatbuffers::WIPOffset<keplerianElements<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<keplerianElements>>(OPM::VT_KEPLERIAN_ELEMENTS, KEPLERIAN_ELEMENTS);
  }
  #[inline]
  pub fn add_EQUINOCTIAL_ELEMENTS(&mut self, EQUINOCTIAL_ELEMENTS: flatbuffers::WIPOffset<equinoctialElements<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<equinoctialElements>>(OPM::VT_EQUINOCTIAL_ELEMENTS, EQUINOCTIAL_ELEMENTS);
  }
  #[inline]
  pub fn add_GM(&mut self, GM: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_GM, GM, 0.0);
  }
  #[inline]
  pub fn add_ATMOSPHERIC_MODEL_DATA(&mut self, ATMOSPHERIC_MODEL_DATA: flatbuffers::WIPOffset<opmAtmosphericModelData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<opmAtmosphericModelData>>(OPM::VT_ATMOSPHERIC_MODEL_DATA, ATMOSPHERIC_MODEL_DATA);
  }
  #[inline]
  pub fn add_PROPAGATOR_SETTINGS(&mut self, PROPAGATOR_SETTINGS: flatbuffers::WIPOffset<propagatorConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<propagatorConfig>>(OPM::VT_PROPAGATOR_SETTINGS, PROPAGATOR_SETTINGS);
  }
  #[inline]
  pub fn add_COVARIANCE_MATRIX(&mut self, COVARIANCE_MATRIX: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<opmCovarianceMatrixLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_COVARIANCE_MATRIX, COVARIANCE_MATRIX);
  }
  #[inline]
  pub fn add_UVW_SIGMAS(&mut self, UVW_SIGMAS: flatbuffers::WIPOffset<uvwSigmas<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<uvwSigmas>>(OPM::VT_UVW_SIGMAS, UVW_SIGMAS);
  }
  #[inline]
  pub fn add_MASS(&mut self, MASS: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_MASS, MASS, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_RAD_AREA(&mut self, SOLAR_RAD_AREA: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_SOLAR_RAD_AREA, SOLAR_RAD_AREA, 0.0);
  }
  #[inline]
  pub fn add_SOLAR_RAD_COEFF(&mut self, SOLAR_RAD_COEFF: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_SOLAR_RAD_COEFF, SOLAR_RAD_COEFF, 0.0);
  }
  #[inline]
  pub fn add_DRAG_AREA(&mut self, DRAG_AREA: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_DRAG_AREA, DRAG_AREA, 0.0);
  }
  #[inline]
  pub fn add_DRAG_COEFF(&mut self, DRAG_COEFF: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_DRAG_COEFF, DRAG_COEFF, 0.0);
  }
  #[inline]
  pub fn add_SRP(&mut self, SRP: perturbationStatus) {
    self.fbb_.push_slot::<perturbationStatus>(OPM::VT_SRP, SRP, perturbationStatus::OFF);
  }
  #[inline]
  pub fn add_CLASSIFICATION_TYPE(&mut self, CLASSIFICATION_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_CLASSIFICATION_TYPE, CLASSIFICATION_TYPE);
  }
  #[inline]
  pub fn add_NORAD_CAT_ID(&mut self, NORAD_CAT_ID: u32) {
    self.fbb_.push_slot::<u32>(OPM::VT_NORAD_CAT_ID, NORAD_CAT_ID, 0);
  }
  #[inline]
  pub fn add_ELEMENT_SET_NO(&mut self, ELEMENT_SET_NO: u32) {
    self.fbb_.push_slot::<u32>(OPM::VT_ELEMENT_SET_NO, ELEMENT_SET_NO, 0);
  }
  #[inline]
  pub fn add_REV_AT_EPOCH(&mut self, REV_AT_EPOCH: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_REV_AT_EPOCH, REV_AT_EPOCH, 0.0);
  }
  #[inline]
  pub fn add_BSTAR(&mut self, BSTAR: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_BSTAR, BSTAR, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DOT(&mut self, MEAN_MOTION_DOT: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_MEAN_MOTION_DOT, MEAN_MOTION_DOT, 0.0);
  }
  #[inline]
  pub fn add_MEAN_MOTION_DDOT(&mut self, MEAN_MOTION_DDOT: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_MEAN_MOTION_DDOT, MEAN_MOTION_DDOT, 0.0);
  }
  #[inline]
  pub fn add_COV_REFERENCE_FRAME(&mut self, COV_REFERENCE_FRAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_COV_REFERENCE_FRAME, COV_REFERENCE_FRAME);
  }
  #[inline]
  pub fn add_CX_X(&mut self, CX_X: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_CX_X, CX_X, 0.0);
  }
  #[inline]
  pub fn add_CY_X(&mut self, CY_X: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_CY_X, CY_X, 0.0);
  }
  #[inline]
  pub fn add_CZ_X(&mut self, CZ_X: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_CZ_X, CZ_X, 0.0);
  }
  #[inline]
  pub fn add_CX_DOT_X(&mut self, CX_DOT_X: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_CX_DOT_X, CX_DOT_X, 0.0);
  }
  #[inline]
  pub fn add_USER_DEFINED_BIP_0044_TYPE(&mut self, USER_DEFINED_BIP_0044_TYPE: u32) {
    self.fbb_.push_slot::<u32>(OPM::VT_USER_DEFINED_BIP_0044_TYPE, USER_DEFINED_BIP_0044_TYPE, 0);
  }
  #[inline]
  pub fn add_USER_DEFINED_OBJECT_DESIGNATOR(&mut self, USER_DEFINED_OBJECT_DESIGNATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_USER_DEFINED_OBJECT_DESIGNATOR, USER_DEFINED_OBJECT_DESIGNATOR);
  }
  #[inline]
  pub fn add_USER_DEFINED_EARTH_MODEL(&mut self, USER_DEFINED_EARTH_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM::VT_USER_DEFINED_EARTH_MODEL, USER_DEFINED_EARTH_MODEL);
  }
  #[inline]
  pub fn add_USER_DEFINED_EPOCH_TIMESTAMP(&mut self, USER_DEFINED_EPOCH_TIMESTAMP: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_USER_DEFINED_EPOCH_TIMESTAMP, USER_DEFINED_EPOCH_TIMESTAMP, 0.0);
  }
  #[inline]
  pub fn add_USER_DEFINED_MICROSECONDS(&mut self, USER_DEFINED_MICROSECONDS: f64) {
    self.fbb_.push_slot::<f64>(OPM::VT_USER_DEFINED_MICROSECONDS, USER_DEFINED_MICROSECONDS, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OPMBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OPMBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OPM<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OPM<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OPM");
      ds.field("CCSDS_OMM_VERS", &self.CCSDS_OMM_VERS());
      ds.field("CREATION_DATE", &self.CREATION_DATE());
      ds.field("ORIGINATOR", &self.ORIGINATOR());
      ds.field("OBJECT_NAME", &self.OBJECT_NAME());
      ds.field("OBJECT_ID", &self.OBJECT_ID());
      ds.field("CENTER_NAME", &self.CENTER_NAME());
      ds.field("REF_FRAME", &self.REF_FRAME());
      ds.field("TIME_SYSTEM", &self.TIME_SYSTEM());
      ds.field("STATE_VECTOR", &self.STATE_VECTOR());
      ds.field("KEPLERIAN_ELEMENTS", &self.KEPLERIAN_ELEMENTS());
      ds.field("EQUINOCTIAL_ELEMENTS", &self.EQUINOCTIAL_ELEMENTS());
      ds.field("GM", &self.GM());
      ds.field("ATMOSPHERIC_MODEL_DATA", &self.ATMOSPHERIC_MODEL_DATA());
      ds.field("PROPAGATOR_SETTINGS", &self.PROPAGATOR_SETTINGS());
      ds.field("COVARIANCE_MATRIX", &self.COVARIANCE_MATRIX());
      ds.field("UVW_SIGMAS", &self.UVW_SIGMAS());
      ds.field("MASS", &self.MASS());
      ds.field("SOLAR_RAD_AREA", &self.SOLAR_RAD_AREA());
      ds.field("SOLAR_RAD_COEFF", &self.SOLAR_RAD_COEFF());
      ds.field("DRAG_AREA", &self.DRAG_AREA());
      ds.field("DRAG_COEFF", &self.DRAG_COEFF());
      ds.field("SRP", &self.SRP());
      ds.field("CLASSIFICATION_TYPE", &self.CLASSIFICATION_TYPE());
      ds.field("NORAD_CAT_ID", &self.NORAD_CAT_ID());
      ds.field("ELEMENT_SET_NO", &self.ELEMENT_SET_NO());
      ds.field("REV_AT_EPOCH", &self.REV_AT_EPOCH());
      ds.field("BSTAR", &self.BSTAR());
      ds.field("MEAN_MOTION_DOT", &self.MEAN_MOTION_DOT());
      ds.field("MEAN_MOTION_DDOT", &self.MEAN_MOTION_DDOT());
      ds.field("COV_REFERENCE_FRAME", &self.COV_REFERENCE_FRAME());
      ds.field("CX_X", &self.CX_X());
      ds.field("CY_X", &self.CY_X());
      ds.field("CZ_X", &self.CZ_X());
      ds.field("CX_DOT_X", &self.CX_DOT_X());
      ds.field("USER_DEFINED_BIP_0044_TYPE", &self.USER_DEFINED_BIP_0044_TYPE());
      ds.field("USER_DEFINED_OBJECT_DESIGNATOR", &self.USER_DEFINED_OBJECT_DESIGNATOR());
      ds.field("USER_DEFINED_EARTH_MODEL", &self.USER_DEFINED_EARTH_MODEL());
      ds.field("USER_DEFINED_EPOCH_TIMESTAMP", &self.USER_DEFINED_EPOCH_TIMESTAMP());
      ds.field("USER_DEFINED_MICROSECONDS", &self.USER_DEFINED_MICROSECONDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OPMT {
  pub CCSDS_OMM_VERS: f64,
  pub CREATION_DATE: Option<String>,
  pub ORIGINATOR: Option<String>,
  pub OBJECT_NAME: Option<String>,
  pub OBJECT_ID: Option<String>,
  pub CENTER_NAME: Option<String>,
  pub REF_FRAME: Option<String>,
  pub TIME_SYSTEM: Option<String>,
  pub STATE_VECTOR: Option<Box<opmStateVectorT>>,
  pub KEPLERIAN_ELEMENTS: Option<Box<keplerianElementsT>>,
  pub EQUINOCTIAL_ELEMENTS: Option<Box<equinoctialElementsT>>,
  pub GM: f64,
  pub ATMOSPHERIC_MODEL_DATA: Option<Box<opmAtmosphericModelDataT>>,
  pub PROPAGATOR_SETTINGS: Option<Box<propagatorConfigT>>,
  pub COVARIANCE_MATRIX: Option<Vec<opmCovarianceMatrixLineT>>,
  pub UVW_SIGMAS: Option<Box<uvwSigmasT>>,
  pub MASS: f64,
  pub SOLAR_RAD_AREA: f64,
  pub SOLAR_RAD_COEFF: f64,
  pub DRAG_AREA: f64,
  pub DRAG_COEFF: f64,
  pub SRP: perturbationStatus,
  pub CLASSIFICATION_TYPE: Option<String>,
  pub NORAD_CAT_ID: u32,
  pub ELEMENT_SET_NO: u32,
  pub REV_AT_EPOCH: f64,
  pub BSTAR: f64,
  pub MEAN_MOTION_DOT: f64,
  pub MEAN_MOTION_DDOT: f64,
  pub COV_REFERENCE_FRAME: Option<String>,
  pub CX_X: f64,
  pub CY_X: f64,
  pub CZ_X: f64,
  pub CX_DOT_X: f64,
  pub USER_DEFINED_BIP_0044_TYPE: u32,
  pub USER_DEFINED_OBJECT_DESIGNATOR: Option<String>,
  pub USER_DEFINED_EARTH_MODEL: Option<String>,
  pub USER_DEFINED_EPOCH_TIMESTAMP: f64,
  pub USER_DEFINED_MICROSECONDS: f64,
}
impl Default for OPMT {
  fn default() -> Self {
    Self {
      CCSDS_OMM_VERS: 0.0,
      CREATION_DATE: None,
      ORIGINATOR: None,
      OBJECT_NAME: None,
      OBJECT_ID: None,
      CENTER_NAME: None,
      REF_FRAME: None,
      TIME_SYSTEM: None,
      STATE_VECTOR: None,
      KEPLERIAN_ELEMENTS: None,
      EQUINOCTIAL_ELEMENTS: None,
      GM: 0.0,
      ATMOSPHERIC_MODEL_DATA: None,
      PROPAGATOR_SETTINGS: None,
      COVARIANCE_MATRIX: None,
      UVW_SIGMAS: None,
      MASS: 0.0,
      SOLAR_RAD_AREA: 0.0,
      SOLAR_RAD_COEFF: 0.0,
      DRAG_AREA: 0.0,
      DRAG_COEFF: 0.0,
      SRP: perturbationStatus::OFF,
      CLASSIFICATION_TYPE: None,
      NORAD_CAT_ID: 0,
      ELEMENT_SET_NO: 0,
      REV_AT_EPOCH: 0.0,
      BSTAR: 0.0,
      MEAN_MOTION_DOT: 0.0,
      MEAN_MOTION_DDOT: 0.0,
      COV_REFERENCE_FRAME: None,
      CX_X: 0.0,
      CY_X: 0.0,
      CZ_X: 0.0,
      CX_DOT_X: 0.0,
      USER_DEFINED_BIP_0044_TYPE: 0,
      USER_DEFINED_OBJECT_DESIGNATOR: None,
      USER_DEFINED_EARTH_MODEL: None,
      USER_DEFINED_EPOCH_TIMESTAMP: 0.0,
      USER_DEFINED_MICROSECONDS: 0.0,
    }
  }
}
impl OPMT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OPM<'b>> {
    let CCSDS_OMM_VERS = self.CCSDS_OMM_VERS;
    let CREATION_DATE = self.CREATION_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIGINATOR = self.ORIGINATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_NAME = self.OBJECT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBJECT_ID = self.OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CENTER_NAME = self.CENTER_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let REF_FRAME = self.REF_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_SYSTEM = self.TIME_SYSTEM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STATE_VECTOR = self.STATE_VECTOR.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let KEPLERIAN_ELEMENTS = self.KEPLERIAN_ELEMENTS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let EQUINOCTIAL_ELEMENTS = self.EQUINOCTIAL_ELEMENTS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let GM = self.GM;
    let ATMOSPHERIC_MODEL_DATA = self.ATMOSPHERIC_MODEL_DATA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PROPAGATOR_SETTINGS = self.PROPAGATOR_SETTINGS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let COVARIANCE_MATRIX = self.COVARIANCE_MATRIX.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let UVW_SIGMAS = self.UVW_SIGMAS.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let MASS = self.MASS;
    let SOLAR_RAD_AREA = self.SOLAR_RAD_AREA;
    let SOLAR_RAD_COEFF = self.SOLAR_RAD_COEFF;
    let DRAG_AREA = self.DRAG_AREA;
    let DRAG_COEFF = self.DRAG_COEFF;
    let SRP = self.SRP;
    let CLASSIFICATION_TYPE = self.CLASSIFICATION_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NORAD_CAT_ID = self.NORAD_CAT_ID;
    let ELEMENT_SET_NO = self.ELEMENT_SET_NO;
    let REV_AT_EPOCH = self.REV_AT_EPOCH;
    let BSTAR = self.BSTAR;
    let MEAN_MOTION_DOT = self.MEAN_MOTION_DOT;
    let MEAN_MOTION_DDOT = self.MEAN_MOTION_DDOT;
    let COV_REFERENCE_FRAME = self.COV_REFERENCE_FRAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CX_X = self.CX_X;
    let CY_X = self.CY_X;
    let CZ_X = self.CZ_X;
    let CX_DOT_X = self.CX_DOT_X;
    let USER_DEFINED_BIP_0044_TYPE = self.USER_DEFINED_BIP_0044_TYPE;
    let USER_DEFINED_OBJECT_DESIGNATOR = self.USER_DEFINED_OBJECT_DESIGNATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USER_DEFINED_EARTH_MODEL = self.USER_DEFINED_EARTH_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USER_DEFINED_EPOCH_TIMESTAMP = self.USER_DEFINED_EPOCH_TIMESTAMP;
    let USER_DEFINED_MICROSECONDS = self.USER_DEFINED_MICROSECONDS;
    OPM::create(_fbb, &OPMArgs{
      CCSDS_OMM_VERS,
      CREATION_DATE,
      ORIGINATOR,
      OBJECT_NAME,
      OBJECT_ID,
      CENTER_NAME,
      REF_FRAME,
      TIME_SYSTEM,
      STATE_VECTOR,
      KEPLERIAN_ELEMENTS,
      EQUINOCTIAL_ELEMENTS,
      GM,
      ATMOSPHERIC_MODEL_DATA,
      PROPAGATOR_SETTINGS,
      COVARIANCE_MATRIX,
      UVW_SIGMAS,
      MASS,
      SOLAR_RAD_AREA,
      SOLAR_RAD_COEFF,
      DRAG_AREA,
      DRAG_COEFF,
      SRP,
      CLASSIFICATION_TYPE,
      NORAD_CAT_ID,
      ELEMENT_SET_NO,
      REV_AT_EPOCH,
      BSTAR,
      MEAN_MOTION_DOT,
      MEAN_MOTION_DDOT,
      COV_REFERENCE_FRAME,
      CX_X,
      CY_X,
      CZ_X,
      CX_DOT_X,
      USER_DEFINED_BIP_0044_TYPE,
      USER_DEFINED_OBJECT_DESIGNATOR,
      USER_DEFINED_EARTH_MODEL,
      USER_DEFINED_EPOCH_TIMESTAMP,
      USER_DEFINED_MICROSECONDS,
    })
  }
}
pub enum OPM_COLLECTIONOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of OPM records
pub struct OPM_COLLECTION<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OPM_COLLECTION<'a> {
  type Inner = OPM_COLLECTION<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OPM_COLLECTION<'a> {
  pub const VT_RECORDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OPM_COLLECTION { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OPM_COLLECTIONArgs<'args>
  ) -> flatbuffers::WIPOffset<OPM_COLLECTION<'bldr>> {
    let mut builder = OPM_COLLECTIONBuilder::new(_fbb);
    if let Some(x) = args.RECORDS { builder.add_RECORDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> OPM_COLLECTIONT {
    let RECORDS = self.RECORDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    OPM_COLLECTIONT {
      RECORDS,
    }
  }

  #[inline]
  pub fn RECORDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OPM<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OPM>>>>(OPM_COLLECTION::VT_RECORDS, None)}
  }
}

impl flatbuffers::Verifiable for OPM_COLLECTION<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OPM>>>>("RECORDS", Self::VT_RECORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct OPM_COLLECTIONArgs<'a> {
    pub RECORDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OPM<'a>>>>>,
}
impl<'a> Default for OPM_COLLECTIONArgs<'a> {
  #[inline]
  fn default() -> Self {
    OPM_COLLECTIONArgs {
      RECORDS: None,
    }
  }
}

pub struct OPM_COLLECTIONBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OPM_COLLECTIONBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RECORDS(&mut self, RECORDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OPM<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OPM_COLLECTION::VT_RECORDS, RECORDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OPM_COLLECTIONBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OPM_COLLECTIONBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OPM_COLLECTION<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OPM_COLLECTION<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OPM_COLLECTION");
      ds.field("RECORDS", &self.RECORDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OPM_COLLECTIONT {
  pub RECORDS: Option<Vec<OPMT>>,
}
impl Default for OPM_COLLECTIONT {
  fn default() -> Self {
    Self {
      RECORDS: None,
    }
  }
}
impl OPM_COLLECTIONT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OPM_COLLECTION<'b>> {
    let RECORDS = self.RECORDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    OPM_COLLECTION::create(_fbb, &OPM_COLLECTIONArgs{
      RECORDS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OPM`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn root_as_OPM(buf: &[u8]) -> Result<OPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OPM>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OPM_unchecked`.
pub fn size_prefixed_root_as_OPM(buf: &[u8]) -> Result<OPM, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OPM>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OPM` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn root_as_OPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OPM<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OPM` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OPM_unchecked`.
pub fn size_prefixed_root_as_OPM_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OPM<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OPM<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OPM`.
pub unsafe fn root_as_OPM_unchecked(buf: &[u8]) -> OPM {
  flatbuffers::root_unchecked::<OPM>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OPM and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OPM`.
pub unsafe fn size_prefixed_root_as_OPM_unchecked(buf: &[u8]) -> OPM {
  flatbuffers::size_prefixed_root_unchecked::<OPM>(buf)
}
#[inline]
pub fn finish_OPM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OPM<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_OPM_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OPM<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
