// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum OBDOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Orbit Determination Results
pub struct OBD<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OBD<'a> {
  type Inner = OBD<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> OBD<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_START_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_END_TIME: flatbuffers::VOffsetT = 8;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 10;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 12;
  pub const VT_APRIORI_ID_ELSET: flatbuffers::VOffsetT = 14;
  pub const VT_APRIORI_ELSET: flatbuffers::VOffsetT = 16;
  pub const VT_APRIORI_ID_STATE_VECTOR: flatbuffers::VOffsetT = 18;
  pub const VT_APRIORI_STATE_VECTOR: flatbuffers::VOffsetT = 20;
  pub const VT_INITIAL_OD: flatbuffers::VOffsetT = 22;
  pub const VT_LAST_OB_START: flatbuffers::VOffsetT = 24;
  pub const VT_LAST_OB_END: flatbuffers::VOffsetT = 26;
  pub const VT_TIME_SPAN: flatbuffers::VOffsetT = 28;
  pub const VT_EFFECTIVE_FROM: flatbuffers::VOffsetT = 30;
  pub const VT_EFFECTIVE_UNTIL: flatbuffers::VOffsetT = 32;
  pub const VT_WRMS: flatbuffers::VOffsetT = 34;
  pub const VT_PREVIOUS_WRMS: flatbuffers::VOffsetT = 36;
  pub const VT_FIRST_PASS_WRMS: flatbuffers::VOffsetT = 38;
  pub const VT_BEST_PASS_WRMS: flatbuffers::VOffsetT = 40;
  pub const VT_ERROR_GROWTH_RATE: flatbuffers::VOffsetT = 42;
  pub const VT_EDR: flatbuffers::VOffsetT = 44;
  pub const VT_METHOD: flatbuffers::VOffsetT = 46;
  pub const VT_METHOD_SOURCE: flatbuffers::VOffsetT = 48;
  pub const VT_FIT_SPAN: flatbuffers::VOffsetT = 50;
  pub const VT_BALLISTIC_COEFF_EST: flatbuffers::VOffsetT = 52;
  pub const VT_BALLISTIC_COEFF_MODEL: flatbuffers::VOffsetT = 54;
  pub const VT_AGOM_EST: flatbuffers::VOffsetT = 56;
  pub const VT_AGOM_MODEL: flatbuffers::VOffsetT = 58;
  pub const VT_RMS_CONVERGENCE_CRITERIA: flatbuffers::VOffsetT = 60;
  pub const VT_NUM_ITERATIONS: flatbuffers::VOffsetT = 62;
  pub const VT_ACCEPTED_OB_TYPS: flatbuffers::VOffsetT = 64;
  pub const VT_ACCEPTED_OB_IDS: flatbuffers::VOffsetT = 66;
  pub const VT_REJECTED_OB_TYPS: flatbuffers::VOffsetT = 68;
  pub const VT_REJECTED_OB_IDS: flatbuffers::VOffsetT = 70;
  pub const VT_SENSOR_IDS: flatbuffers::VOffsetT = 72;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 74;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OBD { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args OBDArgs<'args>
  ) -> flatbuffers::WIPOffset<OBD<'bldr>> {
    let mut builder = OBDBuilder::new(_fbb);
    builder.add_RMS_CONVERGENCE_CRITERIA(args.RMS_CONVERGENCE_CRITERIA);
    builder.add_FIT_SPAN(args.FIT_SPAN);
    builder.add_EDR(args.EDR);
    builder.add_ERROR_GROWTH_RATE(args.ERROR_GROWTH_RATE);
    builder.add_BEST_PASS_WRMS(args.BEST_PASS_WRMS);
    builder.add_FIRST_PASS_WRMS(args.FIRST_PASS_WRMS);
    builder.add_PREVIOUS_WRMS(args.PREVIOUS_WRMS);
    builder.add_WRMS(args.WRMS);
    builder.add_TIME_SPAN(args.TIME_SPAN);
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.SENSOR_IDS { builder.add_SENSOR_IDS(x); }
    if let Some(x) = args.REJECTED_OB_IDS { builder.add_REJECTED_OB_IDS(x); }
    if let Some(x) = args.REJECTED_OB_TYPS { builder.add_REJECTED_OB_TYPS(x); }
    if let Some(x) = args.ACCEPTED_OB_IDS { builder.add_ACCEPTED_OB_IDS(x); }
    if let Some(x) = args.ACCEPTED_OB_TYPS { builder.add_ACCEPTED_OB_TYPS(x); }
    builder.add_NUM_ITERATIONS(args.NUM_ITERATIONS);
    if let Some(x) = args.AGOM_MODEL { builder.add_AGOM_MODEL(x); }
    if let Some(x) = args.BALLISTIC_COEFF_MODEL { builder.add_BALLISTIC_COEFF_MODEL(x); }
    if let Some(x) = args.METHOD_SOURCE { builder.add_METHOD_SOURCE(x); }
    if let Some(x) = args.METHOD { builder.add_METHOD(x); }
    if let Some(x) = args.EFFECTIVE_UNTIL { builder.add_EFFECTIVE_UNTIL(x); }
    if let Some(x) = args.EFFECTIVE_FROM { builder.add_EFFECTIVE_FROM(x); }
    if let Some(x) = args.LAST_OB_END { builder.add_LAST_OB_END(x); }
    if let Some(x) = args.LAST_OB_START { builder.add_LAST_OB_START(x); }
    if let Some(x) = args.APRIORI_STATE_VECTOR { builder.add_APRIORI_STATE_VECTOR(x); }
    if let Some(x) = args.APRIORI_ID_STATE_VECTOR { builder.add_APRIORI_ID_STATE_VECTOR(x); }
    if let Some(x) = args.APRIORI_ELSET { builder.add_APRIORI_ELSET(x); }
    if let Some(x) = args.APRIORI_ID_ELSET { builder.add_APRIORI_ID_ELSET(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    if let Some(x) = args.END_TIME { builder.add_END_TIME(x); }
    if let Some(x) = args.START_TIME { builder.add_START_TIME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_AGOM_EST(args.AGOM_EST);
    builder.add_BALLISTIC_COEFF_EST(args.BALLISTIC_COEFF_EST);
    builder.add_INITIAL_OD(args.INITIAL_OD);
    builder.finish()
  }

  pub fn unpack(&self) -> OBDT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let START_TIME = self.START_TIME().map(|x| {
      x.to_string()
    });
    let END_TIME = self.END_TIME().map(|x| {
      x.to_string()
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let SAT_NO = self.SAT_NO();
    let APRIORI_ID_ELSET = self.APRIORI_ID_ELSET().map(|x| {
      x.to_string()
    });
    let APRIORI_ELSET = self.APRIORI_ELSET().map(|x| {
      x.to_string()
    });
    let APRIORI_ID_STATE_VECTOR = self.APRIORI_ID_STATE_VECTOR().map(|x| {
      x.to_string()
    });
    let APRIORI_STATE_VECTOR = self.APRIORI_STATE_VECTOR().map(|x| {
      x.to_string()
    });
    let INITIAL_OD = self.INITIAL_OD();
    let LAST_OB_START = self.LAST_OB_START().map(|x| {
      x.to_string()
    });
    let LAST_OB_END = self.LAST_OB_END().map(|x| {
      x.to_string()
    });
    let TIME_SPAN = self.TIME_SPAN();
    let EFFECTIVE_FROM = self.EFFECTIVE_FROM().map(|x| {
      x.to_string()
    });
    let EFFECTIVE_UNTIL = self.EFFECTIVE_UNTIL().map(|x| {
      x.to_string()
    });
    let WRMS = self.WRMS();
    let PREVIOUS_WRMS = self.PREVIOUS_WRMS();
    let FIRST_PASS_WRMS = self.FIRST_PASS_WRMS();
    let BEST_PASS_WRMS = self.BEST_PASS_WRMS();
    let ERROR_GROWTH_RATE = self.ERROR_GROWTH_RATE();
    let EDR = self.EDR();
    let METHOD = self.METHOD().map(|x| {
      x.to_string()
    });
    let METHOD_SOURCE = self.METHOD_SOURCE().map(|x| {
      x.to_string()
    });
    let FIT_SPAN = self.FIT_SPAN();
    let BALLISTIC_COEFF_EST = self.BALLISTIC_COEFF_EST();
    let BALLISTIC_COEFF_MODEL = self.BALLISTIC_COEFF_MODEL().map(|x| {
      x.to_string()
    });
    let AGOM_EST = self.AGOM_EST();
    let AGOM_MODEL = self.AGOM_MODEL().map(|x| {
      x.to_string()
    });
    let RMS_CONVERGENCE_CRITERIA = self.RMS_CONVERGENCE_CRITERIA();
    let NUM_ITERATIONS = self.NUM_ITERATIONS();
    let ACCEPTED_OB_TYPS = self.ACCEPTED_OB_TYPS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ACCEPTED_OB_IDS = self.ACCEPTED_OB_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let REJECTED_OB_TYPS = self.REJECTED_OB_TYPS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let REJECTED_OB_IDS = self.REJECTED_OB_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let SENSOR_IDS = self.SENSOR_IDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    OBDT {
      ID,
      START_TIME,
      END_TIME,
      ORIG_OBJECT_ID,
      SAT_NO,
      APRIORI_ID_ELSET,
      APRIORI_ELSET,
      APRIORI_ID_STATE_VECTOR,
      APRIORI_STATE_VECTOR,
      INITIAL_OD,
      LAST_OB_START,
      LAST_OB_END,
      TIME_SPAN,
      EFFECTIVE_FROM,
      EFFECTIVE_UNTIL,
      WRMS,
      PREVIOUS_WRMS,
      FIRST_PASS_WRMS,
      BEST_PASS_WRMS,
      ERROR_GROWTH_RATE,
      EDR,
      METHOD,
      METHOD_SOURCE,
      FIT_SPAN,
      BALLISTIC_COEFF_EST,
      BALLISTIC_COEFF_MODEL,
      AGOM_EST,
      AGOM_MODEL,
      RMS_CONVERGENCE_CRITERIA,
      NUM_ITERATIONS,
      ACCEPTED_OB_TYPS,
      ACCEPTED_OB_IDS,
      REJECTED_OB_TYPS,
      REJECTED_OB_IDS,
      SENSOR_IDS,
      ON_ORBIT,
    }
  }

  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_ID, None)}
  }
  #[inline]
  pub fn START_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_START_TIME, None)}
  }
  #[inline]
  pub fn END_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_END_TIME, None)}
  }
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_ORIG_OBJECT_ID, None)}
  }
  #[inline]
  pub fn SAT_NO(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OBD::VT_SAT_NO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn APRIORI_ID_ELSET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_APRIORI_ID_ELSET, None)}
  }
  #[inline]
  pub fn APRIORI_ELSET(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_APRIORI_ELSET, None)}
  }
  #[inline]
  pub fn APRIORI_ID_STATE_VECTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_APRIORI_ID_STATE_VECTOR, None)}
  }
  #[inline]
  pub fn APRIORI_STATE_VECTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_APRIORI_STATE_VECTOR, None)}
  }
  #[inline]
  pub fn INITIAL_OD(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OBD::VT_INITIAL_OD, Some(false)).unwrap()}
  }
  #[inline]
  pub fn LAST_OB_START(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_LAST_OB_START, None)}
  }
  #[inline]
  pub fn LAST_OB_END(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_LAST_OB_END, None)}
  }
  #[inline]
  pub fn TIME_SPAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_TIME_SPAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EFFECTIVE_FROM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_EFFECTIVE_FROM, None)}
  }
  #[inline]
  pub fn EFFECTIVE_UNTIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_EFFECTIVE_UNTIL, None)}
  }
  #[inline]
  pub fn WRMS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_WRMS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn PREVIOUS_WRMS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_PREVIOUS_WRMS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn FIRST_PASS_WRMS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_FIRST_PASS_WRMS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BEST_PASS_WRMS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_BEST_PASS_WRMS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ERROR_GROWTH_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_ERROR_GROWTH_RATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn EDR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_EDR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn METHOD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_METHOD, None)}
  }
  #[inline]
  pub fn METHOD_SOURCE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_METHOD_SOURCE, None)}
  }
  #[inline]
  pub fn FIT_SPAN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_FIT_SPAN, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn BALLISTIC_COEFF_EST(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OBD::VT_BALLISTIC_COEFF_EST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn BALLISTIC_COEFF_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_BALLISTIC_COEFF_MODEL, None)}
  }
  #[inline]
  pub fn AGOM_EST(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(OBD::VT_AGOM_EST, Some(false)).unwrap()}
  }
  #[inline]
  pub fn AGOM_MODEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_AGOM_MODEL, None)}
  }
  #[inline]
  pub fn RMS_CONVERGENCE_CRITERIA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(OBD::VT_RMS_CONVERGENCE_CRITERIA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn NUM_ITERATIONS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(OBD::VT_NUM_ITERATIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ACCEPTED_OB_TYPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OBD::VT_ACCEPTED_OB_TYPS, None)}
  }
  #[inline]
  pub fn ACCEPTED_OB_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OBD::VT_ACCEPTED_OB_IDS, None)}
  }
  #[inline]
  pub fn REJECTED_OB_TYPS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OBD::VT_REJECTED_OB_TYPS, None)}
  }
  #[inline]
  pub fn REJECTED_OB_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OBD::VT_REJECTED_OB_IDS, None)}
  }
  #[inline]
  pub fn SENSOR_IDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(OBD::VT_SENSOR_IDS, None)}
  }
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OBD::VT_ON_ORBIT, None)}
  }
}

impl flatbuffers::Verifiable for OBD<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("START_TIME", Self::VT_START_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("END_TIME", Self::VT_END_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<i32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("APRIORI_ID_ELSET", Self::VT_APRIORI_ID_ELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("APRIORI_ELSET", Self::VT_APRIORI_ELSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("APRIORI_ID_STATE_VECTOR", Self::VT_APRIORI_ID_STATE_VECTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("APRIORI_STATE_VECTOR", Self::VT_APRIORI_STATE_VECTOR, false)?
     .visit_field::<bool>("INITIAL_OD", Self::VT_INITIAL_OD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAST_OB_START", Self::VT_LAST_OB_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LAST_OB_END", Self::VT_LAST_OB_END, false)?
     .visit_field::<f64>("TIME_SPAN", Self::VT_TIME_SPAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EFFECTIVE_FROM", Self::VT_EFFECTIVE_FROM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EFFECTIVE_UNTIL", Self::VT_EFFECTIVE_UNTIL, false)?
     .visit_field::<f64>("WRMS", Self::VT_WRMS, false)?
     .visit_field::<f64>("PREVIOUS_WRMS", Self::VT_PREVIOUS_WRMS, false)?
     .visit_field::<f64>("FIRST_PASS_WRMS", Self::VT_FIRST_PASS_WRMS, false)?
     .visit_field::<f64>("BEST_PASS_WRMS", Self::VT_BEST_PASS_WRMS, false)?
     .visit_field::<f64>("ERROR_GROWTH_RATE", Self::VT_ERROR_GROWTH_RATE, false)?
     .visit_field::<f64>("EDR", Self::VT_EDR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("METHOD", Self::VT_METHOD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("METHOD_SOURCE", Self::VT_METHOD_SOURCE, false)?
     .visit_field::<f64>("FIT_SPAN", Self::VT_FIT_SPAN, false)?
     .visit_field::<bool>("BALLISTIC_COEFF_EST", Self::VT_BALLISTIC_COEFF_EST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BALLISTIC_COEFF_MODEL", Self::VT_BALLISTIC_COEFF_MODEL, false)?
     .visit_field::<bool>("AGOM_EST", Self::VT_AGOM_EST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AGOM_MODEL", Self::VT_AGOM_MODEL, false)?
     .visit_field::<f64>("RMS_CONVERGENCE_CRITERIA", Self::VT_RMS_CONVERGENCE_CRITERIA, false)?
     .visit_field::<i32>("NUM_ITERATIONS", Self::VT_NUM_ITERATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ACCEPTED_OB_TYPS", Self::VT_ACCEPTED_OB_TYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ACCEPTED_OB_IDS", Self::VT_ACCEPTED_OB_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("REJECTED_OB_TYPS", Self::VT_REJECTED_OB_TYPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("REJECTED_OB_IDS", Self::VT_REJECTED_OB_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("SENSOR_IDS", Self::VT_SENSOR_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .finish();
    Ok(())
  }
}
pub struct OBDArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub START_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub END_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SAT_NO: i32,
    pub APRIORI_ID_ELSET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub APRIORI_ELSET: Option<flatbuffers::WIPOffset<&'a str>>,
    pub APRIORI_ID_STATE_VECTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub APRIORI_STATE_VECTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_OD: bool,
    pub LAST_OB_START: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LAST_OB_END: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_SPAN: f64,
    pub EFFECTIVE_FROM: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EFFECTIVE_UNTIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub WRMS: f64,
    pub PREVIOUS_WRMS: f64,
    pub FIRST_PASS_WRMS: f64,
    pub BEST_PASS_WRMS: f64,
    pub ERROR_GROWTH_RATE: f64,
    pub EDR: f64,
    pub METHOD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub METHOD_SOURCE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FIT_SPAN: f64,
    pub BALLISTIC_COEFF_EST: bool,
    pub BALLISTIC_COEFF_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AGOM_EST: bool,
    pub AGOM_MODEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RMS_CONVERGENCE_CRITERIA: f64,
    pub NUM_ITERATIONS: i32,
    pub ACCEPTED_OB_TYPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ACCEPTED_OB_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub REJECTED_OB_TYPS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub REJECTED_OB_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub SENSOR_IDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for OBDArgs<'a> {
  #[inline]
  fn default() -> Self {
    OBDArgs {
      ID: None,
      START_TIME: None,
      END_TIME: None,
      ORIG_OBJECT_ID: None,
      SAT_NO: 0,
      APRIORI_ID_ELSET: None,
      APRIORI_ELSET: None,
      APRIORI_ID_STATE_VECTOR: None,
      APRIORI_STATE_VECTOR: None,
      INITIAL_OD: false,
      LAST_OB_START: None,
      LAST_OB_END: None,
      TIME_SPAN: 0.0,
      EFFECTIVE_FROM: None,
      EFFECTIVE_UNTIL: None,
      WRMS: 0.0,
      PREVIOUS_WRMS: 0.0,
      FIRST_PASS_WRMS: 0.0,
      BEST_PASS_WRMS: 0.0,
      ERROR_GROWTH_RATE: 0.0,
      EDR: 0.0,
      METHOD: None,
      METHOD_SOURCE: None,
      FIT_SPAN: 0.0,
      BALLISTIC_COEFF_EST: false,
      BALLISTIC_COEFF_MODEL: None,
      AGOM_EST: false,
      AGOM_MODEL: None,
      RMS_CONVERGENCE_CRITERIA: 0.0,
      NUM_ITERATIONS: 0,
      ACCEPTED_OB_TYPS: None,
      ACCEPTED_OB_IDS: None,
      REJECTED_OB_TYPS: None,
      REJECTED_OB_IDS: None,
      SENSOR_IDS: None,
      ON_ORBIT: None,
    }
  }
}

pub struct OBDBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OBDBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_ID, ID);
  }
  #[inline]
  pub fn add_START_TIME(&mut self, START_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_START_TIME, START_TIME);
  }
  #[inline]
  pub fn add_END_TIME(&mut self, END_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_END_TIME, END_TIME);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: i32) {
    self.fbb_.push_slot::<i32>(OBD::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_APRIORI_ID_ELSET(&mut self, APRIORI_ID_ELSET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_APRIORI_ID_ELSET, APRIORI_ID_ELSET);
  }
  #[inline]
  pub fn add_APRIORI_ELSET(&mut self, APRIORI_ELSET: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_APRIORI_ELSET, APRIORI_ELSET);
  }
  #[inline]
  pub fn add_APRIORI_ID_STATE_VECTOR(&mut self, APRIORI_ID_STATE_VECTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_APRIORI_ID_STATE_VECTOR, APRIORI_ID_STATE_VECTOR);
  }
  #[inline]
  pub fn add_APRIORI_STATE_VECTOR(&mut self, APRIORI_STATE_VECTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_APRIORI_STATE_VECTOR, APRIORI_STATE_VECTOR);
  }
  #[inline]
  pub fn add_INITIAL_OD(&mut self, INITIAL_OD: bool) {
    self.fbb_.push_slot::<bool>(OBD::VT_INITIAL_OD, INITIAL_OD, false);
  }
  #[inline]
  pub fn add_LAST_OB_START(&mut self, LAST_OB_START: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_LAST_OB_START, LAST_OB_START);
  }
  #[inline]
  pub fn add_LAST_OB_END(&mut self, LAST_OB_END: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_LAST_OB_END, LAST_OB_END);
  }
  #[inline]
  pub fn add_TIME_SPAN(&mut self, TIME_SPAN: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_TIME_SPAN, TIME_SPAN, 0.0);
  }
  #[inline]
  pub fn add_EFFECTIVE_FROM(&mut self, EFFECTIVE_FROM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_EFFECTIVE_FROM, EFFECTIVE_FROM);
  }
  #[inline]
  pub fn add_EFFECTIVE_UNTIL(&mut self, EFFECTIVE_UNTIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_EFFECTIVE_UNTIL, EFFECTIVE_UNTIL);
  }
  #[inline]
  pub fn add_WRMS(&mut self, WRMS: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_WRMS, WRMS, 0.0);
  }
  #[inline]
  pub fn add_PREVIOUS_WRMS(&mut self, PREVIOUS_WRMS: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_PREVIOUS_WRMS, PREVIOUS_WRMS, 0.0);
  }
  #[inline]
  pub fn add_FIRST_PASS_WRMS(&mut self, FIRST_PASS_WRMS: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_FIRST_PASS_WRMS, FIRST_PASS_WRMS, 0.0);
  }
  #[inline]
  pub fn add_BEST_PASS_WRMS(&mut self, BEST_PASS_WRMS: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_BEST_PASS_WRMS, BEST_PASS_WRMS, 0.0);
  }
  #[inline]
  pub fn add_ERROR_GROWTH_RATE(&mut self, ERROR_GROWTH_RATE: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_ERROR_GROWTH_RATE, ERROR_GROWTH_RATE, 0.0);
  }
  #[inline]
  pub fn add_EDR(&mut self, EDR: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_EDR, EDR, 0.0);
  }
  #[inline]
  pub fn add_METHOD(&mut self, METHOD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_METHOD, METHOD);
  }
  #[inline]
  pub fn add_METHOD_SOURCE(&mut self, METHOD_SOURCE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_METHOD_SOURCE, METHOD_SOURCE);
  }
  #[inline]
  pub fn add_FIT_SPAN(&mut self, FIT_SPAN: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_FIT_SPAN, FIT_SPAN, 0.0);
  }
  #[inline]
  pub fn add_BALLISTIC_COEFF_EST(&mut self, BALLISTIC_COEFF_EST: bool) {
    self.fbb_.push_slot::<bool>(OBD::VT_BALLISTIC_COEFF_EST, BALLISTIC_COEFF_EST, false);
  }
  #[inline]
  pub fn add_BALLISTIC_COEFF_MODEL(&mut self, BALLISTIC_COEFF_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_BALLISTIC_COEFF_MODEL, BALLISTIC_COEFF_MODEL);
  }
  #[inline]
  pub fn add_AGOM_EST(&mut self, AGOM_EST: bool) {
    self.fbb_.push_slot::<bool>(OBD::VT_AGOM_EST, AGOM_EST, false);
  }
  #[inline]
  pub fn add_AGOM_MODEL(&mut self, AGOM_MODEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_AGOM_MODEL, AGOM_MODEL);
  }
  #[inline]
  pub fn add_RMS_CONVERGENCE_CRITERIA(&mut self, RMS_CONVERGENCE_CRITERIA: f64) {
    self.fbb_.push_slot::<f64>(OBD::VT_RMS_CONVERGENCE_CRITERIA, RMS_CONVERGENCE_CRITERIA, 0.0);
  }
  #[inline]
  pub fn add_NUM_ITERATIONS(&mut self, NUM_ITERATIONS: i32) {
    self.fbb_.push_slot::<i32>(OBD::VT_NUM_ITERATIONS, NUM_ITERATIONS, 0);
  }
  #[inline]
  pub fn add_ACCEPTED_OB_TYPS(&mut self, ACCEPTED_OB_TYPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_ACCEPTED_OB_TYPS, ACCEPTED_OB_TYPS);
  }
  #[inline]
  pub fn add_ACCEPTED_OB_IDS(&mut self, ACCEPTED_OB_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_ACCEPTED_OB_IDS, ACCEPTED_OB_IDS);
  }
  #[inline]
  pub fn add_REJECTED_OB_TYPS(&mut self, REJECTED_OB_TYPS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_REJECTED_OB_TYPS, REJECTED_OB_TYPS);
  }
  #[inline]
  pub fn add_REJECTED_OB_IDS(&mut self, REJECTED_OB_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_REJECTED_OB_IDS, REJECTED_OB_IDS);
  }
  #[inline]
  pub fn add_SENSOR_IDS(&mut self, SENSOR_IDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_SENSOR_IDS, SENSOR_IDS);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OBD::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> OBDBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    OBDBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OBD<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OBD<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OBD");
      ds.field("ID", &self.ID());
      ds.field("START_TIME", &self.START_TIME());
      ds.field("END_TIME", &self.END_TIME());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("APRIORI_ID_ELSET", &self.APRIORI_ID_ELSET());
      ds.field("APRIORI_ELSET", &self.APRIORI_ELSET());
      ds.field("APRIORI_ID_STATE_VECTOR", &self.APRIORI_ID_STATE_VECTOR());
      ds.field("APRIORI_STATE_VECTOR", &self.APRIORI_STATE_VECTOR());
      ds.field("INITIAL_OD", &self.INITIAL_OD());
      ds.field("LAST_OB_START", &self.LAST_OB_START());
      ds.field("LAST_OB_END", &self.LAST_OB_END());
      ds.field("TIME_SPAN", &self.TIME_SPAN());
      ds.field("EFFECTIVE_FROM", &self.EFFECTIVE_FROM());
      ds.field("EFFECTIVE_UNTIL", &self.EFFECTIVE_UNTIL());
      ds.field("WRMS", &self.WRMS());
      ds.field("PREVIOUS_WRMS", &self.PREVIOUS_WRMS());
      ds.field("FIRST_PASS_WRMS", &self.FIRST_PASS_WRMS());
      ds.field("BEST_PASS_WRMS", &self.BEST_PASS_WRMS());
      ds.field("ERROR_GROWTH_RATE", &self.ERROR_GROWTH_RATE());
      ds.field("EDR", &self.EDR());
      ds.field("METHOD", &self.METHOD());
      ds.field("METHOD_SOURCE", &self.METHOD_SOURCE());
      ds.field("FIT_SPAN", &self.FIT_SPAN());
      ds.field("BALLISTIC_COEFF_EST", &self.BALLISTIC_COEFF_EST());
      ds.field("BALLISTIC_COEFF_MODEL", &self.BALLISTIC_COEFF_MODEL());
      ds.field("AGOM_EST", &self.AGOM_EST());
      ds.field("AGOM_MODEL", &self.AGOM_MODEL());
      ds.field("RMS_CONVERGENCE_CRITERIA", &self.RMS_CONVERGENCE_CRITERIA());
      ds.field("NUM_ITERATIONS", &self.NUM_ITERATIONS());
      ds.field("ACCEPTED_OB_TYPS", &self.ACCEPTED_OB_TYPS());
      ds.field("ACCEPTED_OB_IDS", &self.ACCEPTED_OB_IDS());
      ds.field("REJECTED_OB_TYPS", &self.REJECTED_OB_TYPS());
      ds.field("REJECTED_OB_IDS", &self.REJECTED_OB_IDS());
      ds.field("SENSOR_IDS", &self.SENSOR_IDS());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OBDT {
  pub ID: Option<String>,
  pub START_TIME: Option<String>,
  pub END_TIME: Option<String>,
  pub ORIG_OBJECT_ID: Option<String>,
  pub SAT_NO: i32,
  pub APRIORI_ID_ELSET: Option<String>,
  pub APRIORI_ELSET: Option<String>,
  pub APRIORI_ID_STATE_VECTOR: Option<String>,
  pub APRIORI_STATE_VECTOR: Option<String>,
  pub INITIAL_OD: bool,
  pub LAST_OB_START: Option<String>,
  pub LAST_OB_END: Option<String>,
  pub TIME_SPAN: f64,
  pub EFFECTIVE_FROM: Option<String>,
  pub EFFECTIVE_UNTIL: Option<String>,
  pub WRMS: f64,
  pub PREVIOUS_WRMS: f64,
  pub FIRST_PASS_WRMS: f64,
  pub BEST_PASS_WRMS: f64,
  pub ERROR_GROWTH_RATE: f64,
  pub EDR: f64,
  pub METHOD: Option<String>,
  pub METHOD_SOURCE: Option<String>,
  pub FIT_SPAN: f64,
  pub BALLISTIC_COEFF_EST: bool,
  pub BALLISTIC_COEFF_MODEL: Option<String>,
  pub AGOM_EST: bool,
  pub AGOM_MODEL: Option<String>,
  pub RMS_CONVERGENCE_CRITERIA: f64,
  pub NUM_ITERATIONS: i32,
  pub ACCEPTED_OB_TYPS: Option<Vec<String>>,
  pub ACCEPTED_OB_IDS: Option<Vec<String>>,
  pub REJECTED_OB_TYPS: Option<Vec<String>>,
  pub REJECTED_OB_IDS: Option<Vec<String>>,
  pub SENSOR_IDS: Option<Vec<String>>,
  pub ON_ORBIT: Option<String>,
}
impl Default for OBDT {
  fn default() -> Self {
    Self {
      ID: None,
      START_TIME: None,
      END_TIME: None,
      ORIG_OBJECT_ID: None,
      SAT_NO: 0,
      APRIORI_ID_ELSET: None,
      APRIORI_ELSET: None,
      APRIORI_ID_STATE_VECTOR: None,
      APRIORI_STATE_VECTOR: None,
      INITIAL_OD: false,
      LAST_OB_START: None,
      LAST_OB_END: None,
      TIME_SPAN: 0.0,
      EFFECTIVE_FROM: None,
      EFFECTIVE_UNTIL: None,
      WRMS: 0.0,
      PREVIOUS_WRMS: 0.0,
      FIRST_PASS_WRMS: 0.0,
      BEST_PASS_WRMS: 0.0,
      ERROR_GROWTH_RATE: 0.0,
      EDR: 0.0,
      METHOD: None,
      METHOD_SOURCE: None,
      FIT_SPAN: 0.0,
      BALLISTIC_COEFF_EST: false,
      BALLISTIC_COEFF_MODEL: None,
      AGOM_EST: false,
      AGOM_MODEL: None,
      RMS_CONVERGENCE_CRITERIA: 0.0,
      NUM_ITERATIONS: 0,
      ACCEPTED_OB_TYPS: None,
      ACCEPTED_OB_IDS: None,
      REJECTED_OB_TYPS: None,
      REJECTED_OB_IDS: None,
      SENSOR_IDS: None,
      ON_ORBIT: None,
    }
  }
}
impl OBDT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<OBD<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let START_TIME = self.START_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let END_TIME = self.END_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SAT_NO = self.SAT_NO;
    let APRIORI_ID_ELSET = self.APRIORI_ID_ELSET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let APRIORI_ELSET = self.APRIORI_ELSET.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let APRIORI_ID_STATE_VECTOR = self.APRIORI_ID_STATE_VECTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let APRIORI_STATE_VECTOR = self.APRIORI_STATE_VECTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_OD = self.INITIAL_OD;
    let LAST_OB_START = self.LAST_OB_START.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LAST_OB_END = self.LAST_OB_END.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_SPAN = self.TIME_SPAN;
    let EFFECTIVE_FROM = self.EFFECTIVE_FROM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EFFECTIVE_UNTIL = self.EFFECTIVE_UNTIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let WRMS = self.WRMS;
    let PREVIOUS_WRMS = self.PREVIOUS_WRMS;
    let FIRST_PASS_WRMS = self.FIRST_PASS_WRMS;
    let BEST_PASS_WRMS = self.BEST_PASS_WRMS;
    let ERROR_GROWTH_RATE = self.ERROR_GROWTH_RATE;
    let EDR = self.EDR;
    let METHOD = self.METHOD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let METHOD_SOURCE = self.METHOD_SOURCE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FIT_SPAN = self.FIT_SPAN;
    let BALLISTIC_COEFF_EST = self.BALLISTIC_COEFF_EST;
    let BALLISTIC_COEFF_MODEL = self.BALLISTIC_COEFF_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AGOM_EST = self.AGOM_EST;
    let AGOM_MODEL = self.AGOM_MODEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RMS_CONVERGENCE_CRITERIA = self.RMS_CONVERGENCE_CRITERIA;
    let NUM_ITERATIONS = self.NUM_ITERATIONS;
    let ACCEPTED_OB_TYPS = self.ACCEPTED_OB_TYPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ACCEPTED_OB_IDS = self.ACCEPTED_OB_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let REJECTED_OB_TYPS = self.REJECTED_OB_TYPS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let REJECTED_OB_IDS = self.REJECTED_OB_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let SENSOR_IDS = self.SENSOR_IDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    OBD::create(_fbb, &OBDArgs{
      ID,
      START_TIME,
      END_TIME,
      ORIG_OBJECT_ID,
      SAT_NO,
      APRIORI_ID_ELSET,
      APRIORI_ELSET,
      APRIORI_ID_STATE_VECTOR,
      APRIORI_STATE_VECTOR,
      INITIAL_OD,
      LAST_OB_START,
      LAST_OB_END,
      TIME_SPAN,
      EFFECTIVE_FROM,
      EFFECTIVE_UNTIL,
      WRMS,
      PREVIOUS_WRMS,
      FIRST_PASS_WRMS,
      BEST_PASS_WRMS,
      ERROR_GROWTH_RATE,
      EDR,
      METHOD,
      METHOD_SOURCE,
      FIT_SPAN,
      BALLISTIC_COEFF_EST,
      BALLISTIC_COEFF_MODEL,
      AGOM_EST,
      AGOM_MODEL,
      RMS_CONVERGENCE_CRITERIA,
      NUM_ITERATIONS,
      ACCEPTED_OB_TYPS,
      ACCEPTED_OB_IDS,
      REJECTED_OB_TYPS,
      REJECTED_OB_IDS,
      SENSOR_IDS,
      ON_ORBIT,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `OBD`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OBD_unchecked`.
pub fn root_as_OBD(buf: &[u8]) -> Result<OBD, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<OBD>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `OBD` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_OBD_unchecked`.
pub fn size_prefixed_root_as_OBD(buf: &[u8]) -> Result<OBD, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<OBD>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `OBD` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OBD_unchecked`.
pub fn root_as_OBD_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OBD<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<OBD<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `OBD` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_OBD_unchecked`.
pub fn size_prefixed_root_as_OBD_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<OBD<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<OBD<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a OBD and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `OBD`.
pub unsafe fn root_as_OBD_unchecked(buf: &[u8]) -> OBD {
  flatbuffers::root_unchecked::<OBD>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed OBD and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `OBD`.
pub unsafe fn size_prefixed_root_as_OBD_unchecked(buf: &[u8]) -> OBD {
  flatbuffers::size_prefixed_root_unchecked::<OBD>(buf)
}
pub const OBD_IDENTIFIER: &str = "$OBD";

#[inline]
pub fn OBD_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OBD_IDENTIFIER, false)
}

#[inline]
pub fn OBD_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, OBD_IDENTIFIER, true)
}

#[inline]
pub fn finish_OBD_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<OBD<'a>>) {
  fbb.finish(root, Some(OBD_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_OBD_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<OBD<'a>>) {
  fbb.finish_size_prefixed(root, Some(OBD_IDENTIFIER));
}
