// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRAVITY_MODEL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRAVITY_MODEL_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRAVITY_MODEL_TYPE: [GravityModelType; 6] = [
  GravityModelType::POINT_MASS,
  GravityModelType::J2_ONLY,
  GravityModelType::J2_J4,
  GravityModelType::J2_J6,
  GravityModelType::SPHERICAL_HARMONICS,
  GravityModelType::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GravityModelType(pub i8);
#[allow(non_upper_case_globals)]
impl GravityModelType {
  pub const POINT_MASS: Self = Self(0);
  pub const J2_ONLY: Self = Self(1);
  pub const J2_J4: Self = Self(2);
  pub const J2_J6: Self = Self(3);
  pub const SPHERICAL_HARMONICS: Self = Self(4);
  pub const CUSTOM: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT_MASS,
    Self::J2_ONLY,
    Self::J2_J4,
    Self::J2_J6,
    Self::SPHERICAL_HARMONICS,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT_MASS => Some("POINT_MASS"),
      Self::J2_ONLY => Some("J2_ONLY"),
      Self::J2_J4 => Some("J2_J4"),
      Self::J2_J6 => Some("J2_J6"),
      Self::SPHERICAL_HARMONICS => Some("SPHERICAL_HARMONICS"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GravityModelType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GravityModelType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GravityModelType {
    type Output = GravityModelType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GravityModelType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GravityModelType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GravityModelType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRAVITY_MODEL_NAME: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRAVITY_MODEL_NAME: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRAVITY_MODEL_NAME: [GravityModelName; 9] = [
  GravityModelName::WGS84,
  GravityModelName::EGM96,
  GravityModelName::EGM2008,
  GravityModelName::GGM05C,
  GravityModelName::JGM3,
  GravityModelName::EIGEN_6C4,
  GravityModelName::GOCO06S,
  GravityModelName::XGM2019E,
  GravityModelName::CUSTOM_MODEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GravityModelName(pub i8);
#[allow(non_upper_case_globals)]
impl GravityModelName {
  pub const WGS84: Self = Self(0);
  pub const EGM96: Self = Self(1);
  pub const EGM2008: Self = Self(2);
  pub const GGM05C: Self = Self(3);
  pub const JGM3: Self = Self(4);
  pub const EIGEN_6C4: Self = Self(5);
  pub const GOCO06S: Self = Self(6);
  pub const XGM2019E: Self = Self(7);
  pub const CUSTOM_MODEL: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::WGS84,
    Self::EGM96,
    Self::EGM2008,
    Self::GGM05C,
    Self::JGM3,
    Self::EIGEN_6C4,
    Self::GOCO06S,
    Self::XGM2019E,
    Self::CUSTOM_MODEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::WGS84 => Some("WGS84"),
      Self::EGM96 => Some("EGM96"),
      Self::EGM2008 => Some("EGM2008"),
      Self::GGM05C => Some("GGM05C"),
      Self::JGM3 => Some("JGM3"),
      Self::EIGEN_6C4 => Some("EIGEN_6C4"),
      Self::GOCO06S => Some("GOCO06S"),
      Self::XGM2019E => Some("XGM2019E"),
      Self::CUSTOM_MODEL => Some("CUSTOM_MODEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GravityModelName {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GravityModelName {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GravityModelName {
    type Output = GravityModelName;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GravityModelName {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GravityModelName {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GravityModelName {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CENTRAL_BODY: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CENTRAL_BODY: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CENTRAL_BODY: [CentralBody; 9] = [
  CentralBody::EARTH,
  CentralBody::MOON,
  CentralBody::SUN,
  CentralBody::MARS,
  CentralBody::JUPITER,
  CentralBody::SATURN,
  CentralBody::VENUS,
  CentralBody::MERCURY,
  CentralBody::CUSTOM_BODY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CentralBody(pub i8);
#[allow(non_upper_case_globals)]
impl CentralBody {
  pub const EARTH: Self = Self(0);
  pub const MOON: Self = Self(1);
  pub const SUN: Self = Self(2);
  pub const MARS: Self = Self(3);
  pub const JUPITER: Self = Self(4);
  pub const SATURN: Self = Self(5);
  pub const VENUS: Self = Self(6);
  pub const MERCURY: Self = Self(7);
  pub const CUSTOM_BODY: Self = Self(8);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EARTH,
    Self::MOON,
    Self::SUN,
    Self::MARS,
    Self::JUPITER,
    Self::SATURN,
    Self::VENUS,
    Self::MERCURY,
    Self::CUSTOM_BODY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EARTH => Some("EARTH"),
      Self::MOON => Some("MOON"),
      Self::SUN => Some("SUN"),
      Self::MARS => Some("MARS"),
      Self::JUPITER => Some("JUPITER"),
      Self::SATURN => Some("SATURN"),
      Self::VENUS => Some("VENUS"),
      Self::MERCURY => Some("MERCURY"),
      Self::CUSTOM_BODY => Some("CUSTOM_BODY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CentralBody {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CentralBody {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CentralBody {
    type Output = CentralBody;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CentralBody {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CentralBody {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CentralBody {}
pub enum GRVOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Gravity Models
pub struct GRV<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GRV<'a> {
  type Inner = GRV<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GRV<'a> {
  pub const VT_MODEL_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MODEL_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_CENTRAL_BODY: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_DEGREE: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_ORDER: flatbuffers::VOffsetT = 12;
  pub const VT_INCLUDE_SUN: flatbuffers::VOffsetT = 14;
  pub const VT_INCLUDE_MOON: flatbuffers::VOffsetT = 16;
  pub const VT_INCLUDE_PLANETS: flatbuffers::VOffsetT = 18;
  pub const VT_SOLID_TIDES: flatbuffers::VOffsetT = 20;
  pub const VT_OCEAN_TIDES: flatbuffers::VOffsetT = 22;
  pub const VT_POLE_TIDES: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GRV { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GRVArgs
  ) -> flatbuffers::WIPOffset<GRV<'bldr>> {
    let mut builder = GRVBuilder::new(_fbb);
    builder.add_MAX_ORDER(args.MAX_ORDER);
    builder.add_MAX_DEGREE(args.MAX_DEGREE);
    builder.add_POLE_TIDES(args.POLE_TIDES);
    builder.add_OCEAN_TIDES(args.OCEAN_TIDES);
    builder.add_SOLID_TIDES(args.SOLID_TIDES);
    builder.add_INCLUDE_PLANETS(args.INCLUDE_PLANETS);
    builder.add_INCLUDE_MOON(args.INCLUDE_MOON);
    builder.add_INCLUDE_SUN(args.INCLUDE_SUN);
    builder.add_CENTRAL_BODY(args.CENTRAL_BODY);
    builder.add_MODEL_NAME(args.MODEL_NAME);
    builder.add_MODEL_TYPE(args.MODEL_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> GRVT {
    let MODEL_TYPE = self.MODEL_TYPE();
    let MODEL_NAME = self.MODEL_NAME();
    let CENTRAL_BODY = self.CENTRAL_BODY();
    let MAX_DEGREE = self.MAX_DEGREE();
    let MAX_ORDER = self.MAX_ORDER();
    let INCLUDE_SUN = self.INCLUDE_SUN();
    let INCLUDE_MOON = self.INCLUDE_MOON();
    let INCLUDE_PLANETS = self.INCLUDE_PLANETS();
    let SOLID_TIDES = self.SOLID_TIDES();
    let OCEAN_TIDES = self.OCEAN_TIDES();
    let POLE_TIDES = self.POLE_TIDES();
    GRVT {
      MODEL_TYPE,
      MODEL_NAME,
      CENTRAL_BODY,
      MAX_DEGREE,
      MAX_ORDER,
      INCLUDE_SUN,
      INCLUDE_MOON,
      INCLUDE_PLANETS,
      SOLID_TIDES,
      OCEAN_TIDES,
      POLE_TIDES,
    }
  }

  #[inline]
  pub fn MODEL_TYPE(&self) -> GravityModelType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GravityModelType>(GRV::VT_MODEL_TYPE, Some(GravityModelType::J2_J4)).unwrap()}
  }
  #[inline]
  pub fn MODEL_NAME(&self) -> GravityModelName {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GravityModelName>(GRV::VT_MODEL_NAME, Some(GravityModelName::EGM2008)).unwrap()}
  }
  #[inline]
  pub fn CENTRAL_BODY(&self) -> CentralBody {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CentralBody>(GRV::VT_CENTRAL_BODY, Some(CentralBody::EARTH)).unwrap()}
  }
  #[inline]
  pub fn MAX_DEGREE(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GRV::VT_MAX_DEGREE, Some(70)).unwrap()}
  }
  #[inline]
  pub fn MAX_ORDER(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GRV::VT_MAX_ORDER, Some(70)).unwrap()}
  }
  #[inline]
  pub fn INCLUDE_SUN(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_INCLUDE_SUN, Some(true)).unwrap()}
  }
  #[inline]
  pub fn INCLUDE_MOON(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_INCLUDE_MOON, Some(true)).unwrap()}
  }
  #[inline]
  pub fn INCLUDE_PLANETS(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_INCLUDE_PLANETS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn SOLID_TIDES(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_SOLID_TIDES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn OCEAN_TIDES(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_OCEAN_TIDES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn POLE_TIDES(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GRV::VT_POLE_TIDES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GRV<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GravityModelType>("MODEL_TYPE", Self::VT_MODEL_TYPE, false)?
     .visit_field::<GravityModelName>("MODEL_NAME", Self::VT_MODEL_NAME, false)?
     .visit_field::<CentralBody>("CENTRAL_BODY", Self::VT_CENTRAL_BODY, false)?
     .visit_field::<u16>("MAX_DEGREE", Self::VT_MAX_DEGREE, false)?
     .visit_field::<u16>("MAX_ORDER", Self::VT_MAX_ORDER, false)?
     .visit_field::<bool>("INCLUDE_SUN", Self::VT_INCLUDE_SUN, false)?
     .visit_field::<bool>("INCLUDE_MOON", Self::VT_INCLUDE_MOON, false)?
     .visit_field::<bool>("INCLUDE_PLANETS", Self::VT_INCLUDE_PLANETS, false)?
     .visit_field::<bool>("SOLID_TIDES", Self::VT_SOLID_TIDES, false)?
     .visit_field::<bool>("OCEAN_TIDES", Self::VT_OCEAN_TIDES, false)?
     .visit_field::<bool>("POLE_TIDES", Self::VT_POLE_TIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct GRVArgs {
    pub MODEL_TYPE: GravityModelType,
    pub MODEL_NAME: GravityModelName,
    pub CENTRAL_BODY: CentralBody,
    pub MAX_DEGREE: u16,
    pub MAX_ORDER: u16,
    pub INCLUDE_SUN: bool,
    pub INCLUDE_MOON: bool,
    pub INCLUDE_PLANETS: bool,
    pub SOLID_TIDES: bool,
    pub OCEAN_TIDES: bool,
    pub POLE_TIDES: bool,
}
impl<'a> Default for GRVArgs {
  #[inline]
  fn default() -> Self {
    GRVArgs {
      MODEL_TYPE: GravityModelType::J2_J4,
      MODEL_NAME: GravityModelName::EGM2008,
      CENTRAL_BODY: CentralBody::EARTH,
      MAX_DEGREE: 70,
      MAX_ORDER: 70,
      INCLUDE_SUN: true,
      INCLUDE_MOON: true,
      INCLUDE_PLANETS: false,
      SOLID_TIDES: false,
      OCEAN_TIDES: false,
      POLE_TIDES: false,
    }
  }
}

pub struct GRVBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GRVBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_MODEL_TYPE(&mut self, MODEL_TYPE: GravityModelType) {
    self.fbb_.push_slot::<GravityModelType>(GRV::VT_MODEL_TYPE, MODEL_TYPE, GravityModelType::J2_J4);
  }
  #[inline]
  pub fn add_MODEL_NAME(&mut self, MODEL_NAME: GravityModelName) {
    self.fbb_.push_slot::<GravityModelName>(GRV::VT_MODEL_NAME, MODEL_NAME, GravityModelName::EGM2008);
  }
  #[inline]
  pub fn add_CENTRAL_BODY(&mut self, CENTRAL_BODY: CentralBody) {
    self.fbb_.push_slot::<CentralBody>(GRV::VT_CENTRAL_BODY, CENTRAL_BODY, CentralBody::EARTH);
  }
  #[inline]
  pub fn add_MAX_DEGREE(&mut self, MAX_DEGREE: u16) {
    self.fbb_.push_slot::<u16>(GRV::VT_MAX_DEGREE, MAX_DEGREE, 70);
  }
  #[inline]
  pub fn add_MAX_ORDER(&mut self, MAX_ORDER: u16) {
    self.fbb_.push_slot::<u16>(GRV::VT_MAX_ORDER, MAX_ORDER, 70);
  }
  #[inline]
  pub fn add_INCLUDE_SUN(&mut self, INCLUDE_SUN: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_INCLUDE_SUN, INCLUDE_SUN, true);
  }
  #[inline]
  pub fn add_INCLUDE_MOON(&mut self, INCLUDE_MOON: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_INCLUDE_MOON, INCLUDE_MOON, true);
  }
  #[inline]
  pub fn add_INCLUDE_PLANETS(&mut self, INCLUDE_PLANETS: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_INCLUDE_PLANETS, INCLUDE_PLANETS, false);
  }
  #[inline]
  pub fn add_SOLID_TIDES(&mut self, SOLID_TIDES: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_SOLID_TIDES, SOLID_TIDES, false);
  }
  #[inline]
  pub fn add_OCEAN_TIDES(&mut self, OCEAN_TIDES: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_OCEAN_TIDES, OCEAN_TIDES, false);
  }
  #[inline]
  pub fn add_POLE_TIDES(&mut self, POLE_TIDES: bool) {
    self.fbb_.push_slot::<bool>(GRV::VT_POLE_TIDES, POLE_TIDES, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GRVBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GRVBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GRV<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GRV<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GRV");
      ds.field("MODEL_TYPE", &self.MODEL_TYPE());
      ds.field("MODEL_NAME", &self.MODEL_NAME());
      ds.field("CENTRAL_BODY", &self.CENTRAL_BODY());
      ds.field("MAX_DEGREE", &self.MAX_DEGREE());
      ds.field("MAX_ORDER", &self.MAX_ORDER());
      ds.field("INCLUDE_SUN", &self.INCLUDE_SUN());
      ds.field("INCLUDE_MOON", &self.INCLUDE_MOON());
      ds.field("INCLUDE_PLANETS", &self.INCLUDE_PLANETS());
      ds.field("SOLID_TIDES", &self.SOLID_TIDES());
      ds.field("OCEAN_TIDES", &self.OCEAN_TIDES());
      ds.field("POLE_TIDES", &self.POLE_TIDES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GRVT {
  pub MODEL_TYPE: GravityModelType,
  pub MODEL_NAME: GravityModelName,
  pub CENTRAL_BODY: CentralBody,
  pub MAX_DEGREE: u16,
  pub MAX_ORDER: u16,
  pub INCLUDE_SUN: bool,
  pub INCLUDE_MOON: bool,
  pub INCLUDE_PLANETS: bool,
  pub SOLID_TIDES: bool,
  pub OCEAN_TIDES: bool,
  pub POLE_TIDES: bool,
}
impl Default for GRVT {
  fn default() -> Self {
    Self {
      MODEL_TYPE: GravityModelType::J2_J4,
      MODEL_NAME: GravityModelName::EGM2008,
      CENTRAL_BODY: CentralBody::EARTH,
      MAX_DEGREE: 70,
      MAX_ORDER: 70,
      INCLUDE_SUN: true,
      INCLUDE_MOON: true,
      INCLUDE_PLANETS: false,
      SOLID_TIDES: false,
      OCEAN_TIDES: false,
      POLE_TIDES: false,
    }
  }
}
impl GRVT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<GRV<'b>> {
    let MODEL_TYPE = self.MODEL_TYPE;
    let MODEL_NAME = self.MODEL_NAME;
    let CENTRAL_BODY = self.CENTRAL_BODY;
    let MAX_DEGREE = self.MAX_DEGREE;
    let MAX_ORDER = self.MAX_ORDER;
    let INCLUDE_SUN = self.INCLUDE_SUN;
    let INCLUDE_MOON = self.INCLUDE_MOON;
    let INCLUDE_PLANETS = self.INCLUDE_PLANETS;
    let SOLID_TIDES = self.SOLID_TIDES;
    let OCEAN_TIDES = self.OCEAN_TIDES;
    let POLE_TIDES = self.POLE_TIDES;
    GRV::create(_fbb, &GRVArgs{
      MODEL_TYPE,
      MODEL_NAME,
      CENTRAL_BODY,
      MAX_DEGREE,
      MAX_ORDER,
      INCLUDE_SUN,
      INCLUDE_MOON,
      INCLUDE_PLANETS,
      SOLID_TIDES,
      OCEAN_TIDES,
      POLE_TIDES,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GRV`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GRV_unchecked`.
pub fn root_as_GRV(buf: &[u8]) -> Result<GRV, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GRV>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GRV` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_GRV_unchecked`.
pub fn size_prefixed_root_as_GRV(buf: &[u8]) -> Result<GRV, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GRV>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GRV` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GRV_unchecked`.
pub fn root_as_GRV_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GRV<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GRV<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GRV` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_GRV_unchecked`.
pub fn size_prefixed_root_as_GRV_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GRV<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GRV<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GRV and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GRV`.
pub unsafe fn root_as_GRV_unchecked(buf: &[u8]) -> GRV {
  flatbuffers::root_unchecked::<GRV>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GRV and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GRV`.
pub unsafe fn size_prefixed_root_as_GRV_unchecked(buf: &[u8]) -> GRV {
  flatbuffers::size_prefixed_root_unchecked::<GRV>(buf)
}
pub const GRV_IDENTIFIER: &str = "$GRV";

#[inline]
pub fn GRV_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GRV_IDENTIFIER, false)
}

#[inline]
pub fn GRV_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, GRV_IDENTIFIER, true)
}

#[inline]
pub fn finish_GRV_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<GRV<'a>>) {
  fbb.finish(root, Some(GRV_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_GRV_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<GRV<'a>>) {
  fbb.finish_size_prefixed(root, Some(GRV_IDENTIFIER));
}
