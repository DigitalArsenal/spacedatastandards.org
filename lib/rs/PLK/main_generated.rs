// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LICENSE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LICENSE_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LICENSE_TYPE: [licenseType; 6] = [
  licenseType::Trial,
  licenseType::Commercial,
  licenseType::Enterprise,
  licenseType::Educational,
  licenseType::OpenSource,
  licenseType::Internal,
];

/// License type for plugin access
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct licenseType(pub i8);
#[allow(non_upper_case_globals)]
impl licenseType {
  /// Evaluation/trial license
  pub const Trial: Self = Self(0);
  /// Standard commercial license
  pub const Commercial: Self = Self(1);
  /// Enterprise site license
  pub const Enterprise: Self = Self(2);
  /// Educational/academic license
  pub const Educational: Self = Self(3);
  /// Open source project license
  pub const OpenSource: Self = Self(4);
  /// Internal OrbPro default plugins
  pub const Internal: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Trial,
    Self::Commercial,
    Self::Enterprise,
    Self::Educational,
    Self::OpenSource,
    Self::Internal,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Trial => Some("Trial"),
      Self::Commercial => Some("Commercial"),
      Self::Enterprise => Some("Enterprise"),
      Self::Educational => Some("Educational"),
      Self::OpenSource => Some("OpenSource"),
      Self::Internal => Some("Internal"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for licenseType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for licenseType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for licenseType {
    type Output = licenseType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for licenseType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for licenseType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for licenseType {}
pub enum PLKOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Plugin License Key - Issued license for plugin access
/// Uses ECIES: both parties derive symmetric key via X25519 ECDH
/// Key derivation: X25519(private, peer_public) → HKDF-SHA256 → AES-256-GCM
pub struct PLK<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PLK<'a> {
  type Inner = PLK<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PLK<'a> {
  pub const VT_LICENSE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PLUGIN_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PLUGIN_VERSION: flatbuffers::VOffsetT = 8;
  pub const VT_LICENSEE_ORG: flatbuffers::VOffsetT = 10;
  pub const VT_LICENSEE_EMAIL: flatbuffers::VOffsetT = 12;
  pub const VT_LICENSEE_PEER_ID: flatbuffers::VOffsetT = 14;
  pub const VT_LICENSEE_PUBKEY: flatbuffers::VOffsetT = 16;
  pub const VT_ISSUER_PUBKEY: flatbuffers::VOffsetT = 18;
  pub const VT_ALLOWED_DOMAINS: flatbuffers::VOffsetT = 20;
  pub const VT_ALLOWED_TLDS: flatbuffers::VOffsetT = 22;
  pub const VT_LICENSE_TYPE: flatbuffers::VOffsetT = 24;
  pub const VT_MAX_ACTIVATIONS: flatbuffers::VOffsetT = 26;
  pub const VT_ISSUED_AT: flatbuffers::VOffsetT = 28;
  pub const VT_VALID_FROM: flatbuffers::VOffsetT = 30;
  pub const VT_EXPIRES_AT: flatbuffers::VOffsetT = 32;
  pub const VT_ISSUER_PEER_ID: flatbuffers::VOffsetT = 34;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PLK { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PLKArgs<'args>
  ) -> flatbuffers::WIPOffset<PLK<'bldr>> {
    let mut builder = PLKBuilder::new(_fbb);
    builder.add_EXPIRES_AT(args.EXPIRES_AT);
    builder.add_VALID_FROM(args.VALID_FROM);
    builder.add_ISSUED_AT(args.ISSUED_AT);
    if let Some(x) = args.SIGNATURE { builder.add_SIGNATURE(x); }
    if let Some(x) = args.ISSUER_PEER_ID { builder.add_ISSUER_PEER_ID(x); }
    builder.add_MAX_ACTIVATIONS(args.MAX_ACTIVATIONS);
    if let Some(x) = args.ALLOWED_TLDS { builder.add_ALLOWED_TLDS(x); }
    if let Some(x) = args.ALLOWED_DOMAINS { builder.add_ALLOWED_DOMAINS(x); }
    if let Some(x) = args.ISSUER_PUBKEY { builder.add_ISSUER_PUBKEY(x); }
    if let Some(x) = args.LICENSEE_PUBKEY { builder.add_LICENSEE_PUBKEY(x); }
    if let Some(x) = args.LICENSEE_PEER_ID { builder.add_LICENSEE_PEER_ID(x); }
    if let Some(x) = args.LICENSEE_EMAIL { builder.add_LICENSEE_EMAIL(x); }
    if let Some(x) = args.LICENSEE_ORG { builder.add_LICENSEE_ORG(x); }
    if let Some(x) = args.PLUGIN_VERSION { builder.add_PLUGIN_VERSION(x); }
    if let Some(x) = args.PLUGIN_ID { builder.add_PLUGIN_ID(x); }
    if let Some(x) = args.LICENSE_ID { builder.add_LICENSE_ID(x); }
    builder.add_LICENSE_TYPE(args.LICENSE_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> PLKT {
    let LICENSE_ID = {
      let x = self.LICENSE_ID();
      x.to_string()
    };
    let PLUGIN_ID = {
      let x = self.PLUGIN_ID();
      x.to_string()
    };
    let PLUGIN_VERSION = self.PLUGIN_VERSION().map(|x| {
      x.to_string()
    });
    let LICENSEE_ORG = {
      let x = self.LICENSEE_ORG();
      x.to_string()
    };
    let LICENSEE_EMAIL = self.LICENSEE_EMAIL().map(|x| {
      x.to_string()
    });
    let LICENSEE_PEER_ID = self.LICENSEE_PEER_ID().map(|x| {
      x.to_string()
    });
    let LICENSEE_PUBKEY = self.LICENSEE_PUBKEY().map(|x| {
      x.into_iter().collect()
    });
    let ISSUER_PUBKEY = self.ISSUER_PUBKEY().map(|x| {
      x.into_iter().collect()
    });
    let ALLOWED_DOMAINS = self.ALLOWED_DOMAINS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let ALLOWED_TLDS = self.ALLOWED_TLDS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let LICENSE_TYPE = self.LICENSE_TYPE();
    let MAX_ACTIVATIONS = self.MAX_ACTIVATIONS();
    let ISSUED_AT = self.ISSUED_AT();
    let VALID_FROM = self.VALID_FROM();
    let EXPIRES_AT = self.EXPIRES_AT();
    let ISSUER_PEER_ID = self.ISSUER_PEER_ID().map(|x| {
      x.to_string()
    });
    let SIGNATURE = self.SIGNATURE().map(|x| {
      x.into_iter().collect()
    });
    PLKT {
      LICENSE_ID,
      PLUGIN_ID,
      PLUGIN_VERSION,
      LICENSEE_ORG,
      LICENSEE_EMAIL,
      LICENSEE_PEER_ID,
      LICENSEE_PUBKEY,
      ISSUER_PUBKEY,
      ALLOWED_DOMAINS,
      ALLOWED_TLDS,
      LICENSE_TYPE,
      MAX_ACTIVATIONS,
      ISSUED_AT,
      VALID_FROM,
      EXPIRES_AT,
      ISSUER_PEER_ID,
      SIGNATURE,
    }
  }

  /// Unique license key identifier
  #[inline]
  pub fn LICENSE_ID(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_LICENSE_ID, None).unwrap()}
  }
  /// Plugin ID this license is for
  #[inline]
  pub fn PLUGIN_ID(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_PLUGIN_ID, None).unwrap()}
  }
  /// Plugin version or version range (semver)
  #[inline]
  pub fn PLUGIN_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_PLUGIN_VERSION, None)}
  }
  /// Licensee organization name
  #[inline]
  pub fn LICENSEE_ORG(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_LICENSEE_ORG, None).unwrap()}
  }
  /// Licensee contact email
  #[inline]
  pub fn LICENSEE_EMAIL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_LICENSEE_EMAIL, None)}
  }
  /// Licensee's SDN Peer ID
  #[inline]
  pub fn LICENSEE_PEER_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_LICENSEE_PEER_ID, None)}
  }
  /// Licensee's X25519 public key (32 bytes)
  #[inline]
  pub fn LICENSEE_PUBKEY(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PLK::VT_LICENSEE_PUBKEY, None)}
  }
  /// Issuer's X25519 public key (32 bytes)
  /// Used with licensee's private key to derive shared secret via ECDH
  #[inline]
  pub fn ISSUER_PUBKEY(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PLK::VT_ISSUER_PUBKEY, None)}
  }
  /// Domain restrictions (empty = any domain allowed)
  #[inline]
  pub fn ALLOWED_DOMAINS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PLK::VT_ALLOWED_DOMAINS, None)}
  }
  /// TLD restrictions (e.g., ".gov", ".mil", ".edu")
  #[inline]
  pub fn ALLOWED_TLDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PLK::VT_ALLOWED_TLDS, None)}
  }
  /// Type of license
  #[inline]
  pub fn LICENSE_TYPE(&self) -> licenseType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<licenseType>(PLK::VT_LICENSE_TYPE, Some(licenseType::Trial)).unwrap()}
  }
  /// Maximum concurrent activations (0 = unlimited)
  #[inline]
  pub fn MAX_ACTIVATIONS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PLK::VT_MAX_ACTIVATIONS, Some(0)).unwrap()}
  }
  /// Unix timestamp when license was issued
  #[inline]
  pub fn ISSUED_AT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLK::VT_ISSUED_AT, Some(0)).unwrap()}
  }
  /// Unix timestamp when license becomes valid
  #[inline]
  pub fn VALID_FROM(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLK::VT_VALID_FROM, Some(0)).unwrap()}
  }
  /// Unix timestamp when license expires (0 = never expires)
  #[inline]
  pub fn EXPIRES_AT(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PLK::VT_EXPIRES_AT, Some(0)).unwrap()}
  }
  /// Peer ID of the license issuer (OrbPro)
  #[inline]
  pub fn ISSUER_PEER_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PLK::VT_ISSUER_PEER_ID, None)}
  }
  /// Ed25519 signature from issuer over all fields (except SIGNATURE)
  #[inline]
  pub fn SIGNATURE(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PLK::VT_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for PLK<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LICENSE_ID", Self::VT_LICENSE_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PLUGIN_ID", Self::VT_PLUGIN_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PLUGIN_VERSION", Self::VT_PLUGIN_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LICENSEE_ORG", Self::VT_LICENSEE_ORG, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LICENSEE_EMAIL", Self::VT_LICENSEE_EMAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LICENSEE_PEER_ID", Self::VT_LICENSEE_PEER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("LICENSEE_PUBKEY", Self::VT_LICENSEE_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("ISSUER_PUBKEY", Self::VT_ISSUER_PUBKEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ALLOWED_DOMAINS", Self::VT_ALLOWED_DOMAINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("ALLOWED_TLDS", Self::VT_ALLOWED_TLDS, false)?
     .visit_field::<licenseType>("LICENSE_TYPE", Self::VT_LICENSE_TYPE, false)?
     .visit_field::<u32>("MAX_ACTIVATIONS", Self::VT_MAX_ACTIVATIONS, false)?
     .visit_field::<u64>("ISSUED_AT", Self::VT_ISSUED_AT, false)?
     .visit_field::<u64>("VALID_FROM", Self::VT_VALID_FROM, false)?
     .visit_field::<u64>("EXPIRES_AT", Self::VT_EXPIRES_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ISSUER_PEER_ID", Self::VT_ISSUER_PEER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("SIGNATURE", Self::VT_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct PLKArgs<'a> {
    pub LICENSE_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PLUGIN_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PLUGIN_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LICENSEE_ORG: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LICENSEE_EMAIL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LICENSEE_PEER_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LICENSEE_PUBKEY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ISSUER_PUBKEY: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub ALLOWED_DOMAINS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub ALLOWED_TLDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub LICENSE_TYPE: licenseType,
    pub MAX_ACTIVATIONS: u32,
    pub ISSUED_AT: u64,
    pub VALID_FROM: u64,
    pub EXPIRES_AT: u64,
    pub ISSUER_PEER_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIGNATURE: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for PLKArgs<'a> {
  #[inline]
  fn default() -> Self {
    PLKArgs {
      LICENSE_ID: None, // required field
      PLUGIN_ID: None, // required field
      PLUGIN_VERSION: None,
      LICENSEE_ORG: None, // required field
      LICENSEE_EMAIL: None,
      LICENSEE_PEER_ID: None,
      LICENSEE_PUBKEY: None,
      ISSUER_PUBKEY: None,
      ALLOWED_DOMAINS: None,
      ALLOWED_TLDS: None,
      LICENSE_TYPE: licenseType::Trial,
      MAX_ACTIVATIONS: 0,
      ISSUED_AT: 0,
      VALID_FROM: 0,
      EXPIRES_AT: 0,
      ISSUER_PEER_ID: None,
      SIGNATURE: None,
    }
  }
}

pub struct PLKBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PLKBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LICENSE_ID(&mut self, LICENSE_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_LICENSE_ID, LICENSE_ID);
  }
  #[inline]
  pub fn add_PLUGIN_ID(&mut self, PLUGIN_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_PLUGIN_ID, PLUGIN_ID);
  }
  #[inline]
  pub fn add_PLUGIN_VERSION(&mut self, PLUGIN_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_PLUGIN_VERSION, PLUGIN_VERSION);
  }
  #[inline]
  pub fn add_LICENSEE_ORG(&mut self, LICENSEE_ORG: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_LICENSEE_ORG, LICENSEE_ORG);
  }
  #[inline]
  pub fn add_LICENSEE_EMAIL(&mut self, LICENSEE_EMAIL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_LICENSEE_EMAIL, LICENSEE_EMAIL);
  }
  #[inline]
  pub fn add_LICENSEE_PEER_ID(&mut self, LICENSEE_PEER_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_LICENSEE_PEER_ID, LICENSEE_PEER_ID);
  }
  #[inline]
  pub fn add_LICENSEE_PUBKEY(&mut self, LICENSEE_PUBKEY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_LICENSEE_PUBKEY, LICENSEE_PUBKEY);
  }
  #[inline]
  pub fn add_ISSUER_PUBKEY(&mut self, ISSUER_PUBKEY: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_ISSUER_PUBKEY, ISSUER_PUBKEY);
  }
  #[inline]
  pub fn add_ALLOWED_DOMAINS(&mut self, ALLOWED_DOMAINS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_ALLOWED_DOMAINS, ALLOWED_DOMAINS);
  }
  #[inline]
  pub fn add_ALLOWED_TLDS(&mut self, ALLOWED_TLDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_ALLOWED_TLDS, ALLOWED_TLDS);
  }
  #[inline]
  pub fn add_LICENSE_TYPE(&mut self, LICENSE_TYPE: licenseType) {
    self.fbb_.push_slot::<licenseType>(PLK::VT_LICENSE_TYPE, LICENSE_TYPE, licenseType::Trial);
  }
  #[inline]
  pub fn add_MAX_ACTIVATIONS(&mut self, MAX_ACTIVATIONS: u32) {
    self.fbb_.push_slot::<u32>(PLK::VT_MAX_ACTIVATIONS, MAX_ACTIVATIONS, 0);
  }
  #[inline]
  pub fn add_ISSUED_AT(&mut self, ISSUED_AT: u64) {
    self.fbb_.push_slot::<u64>(PLK::VT_ISSUED_AT, ISSUED_AT, 0);
  }
  #[inline]
  pub fn add_VALID_FROM(&mut self, VALID_FROM: u64) {
    self.fbb_.push_slot::<u64>(PLK::VT_VALID_FROM, VALID_FROM, 0);
  }
  #[inline]
  pub fn add_EXPIRES_AT(&mut self, EXPIRES_AT: u64) {
    self.fbb_.push_slot::<u64>(PLK::VT_EXPIRES_AT, EXPIRES_AT, 0);
  }
  #[inline]
  pub fn add_ISSUER_PEER_ID(&mut self, ISSUER_PEER_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_ISSUER_PEER_ID, ISSUER_PEER_ID);
  }
  #[inline]
  pub fn add_SIGNATURE(&mut self, SIGNATURE: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PLK::VT_SIGNATURE, SIGNATURE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PLKBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PLKBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PLK<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, PLK::VT_LICENSE_ID,"LICENSE_ID");
    self.fbb_.required(o, PLK::VT_PLUGIN_ID,"PLUGIN_ID");
    self.fbb_.required(o, PLK::VT_LICENSEE_ORG,"LICENSEE_ORG");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PLK<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PLK");
      ds.field("LICENSE_ID", &self.LICENSE_ID());
      ds.field("PLUGIN_ID", &self.PLUGIN_ID());
      ds.field("PLUGIN_VERSION", &self.PLUGIN_VERSION());
      ds.field("LICENSEE_ORG", &self.LICENSEE_ORG());
      ds.field("LICENSEE_EMAIL", &self.LICENSEE_EMAIL());
      ds.field("LICENSEE_PEER_ID", &self.LICENSEE_PEER_ID());
      ds.field("LICENSEE_PUBKEY", &self.LICENSEE_PUBKEY());
      ds.field("ISSUER_PUBKEY", &self.ISSUER_PUBKEY());
      ds.field("ALLOWED_DOMAINS", &self.ALLOWED_DOMAINS());
      ds.field("ALLOWED_TLDS", &self.ALLOWED_TLDS());
      ds.field("LICENSE_TYPE", &self.LICENSE_TYPE());
      ds.field("MAX_ACTIVATIONS", &self.MAX_ACTIVATIONS());
      ds.field("ISSUED_AT", &self.ISSUED_AT());
      ds.field("VALID_FROM", &self.VALID_FROM());
      ds.field("EXPIRES_AT", &self.EXPIRES_AT());
      ds.field("ISSUER_PEER_ID", &self.ISSUER_PEER_ID());
      ds.field("SIGNATURE", &self.SIGNATURE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PLKT {
  pub LICENSE_ID: String,
  pub PLUGIN_ID: String,
  pub PLUGIN_VERSION: Option<String>,
  pub LICENSEE_ORG: String,
  pub LICENSEE_EMAIL: Option<String>,
  pub LICENSEE_PEER_ID: Option<String>,
  pub LICENSEE_PUBKEY: Option<Vec<u8>>,
  pub ISSUER_PUBKEY: Option<Vec<u8>>,
  pub ALLOWED_DOMAINS: Option<Vec<String>>,
  pub ALLOWED_TLDS: Option<Vec<String>>,
  pub LICENSE_TYPE: licenseType,
  pub MAX_ACTIVATIONS: u32,
  pub ISSUED_AT: u64,
  pub VALID_FROM: u64,
  pub EXPIRES_AT: u64,
  pub ISSUER_PEER_ID: Option<String>,
  pub SIGNATURE: Option<Vec<u8>>,
}
impl Default for PLKT {
  fn default() -> Self {
    Self {
      LICENSE_ID: "".to_string(),
      PLUGIN_ID: "".to_string(),
      PLUGIN_VERSION: None,
      LICENSEE_ORG: "".to_string(),
      LICENSEE_EMAIL: None,
      LICENSEE_PEER_ID: None,
      LICENSEE_PUBKEY: None,
      ISSUER_PUBKEY: None,
      ALLOWED_DOMAINS: None,
      ALLOWED_TLDS: None,
      LICENSE_TYPE: licenseType::Trial,
      MAX_ACTIVATIONS: 0,
      ISSUED_AT: 0,
      VALID_FROM: 0,
      EXPIRES_AT: 0,
      ISSUER_PEER_ID: None,
      SIGNATURE: None,
    }
  }
}
impl PLKT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PLK<'b>> {
    let LICENSE_ID = Some({
      let x = &self.LICENSE_ID;
      _fbb.create_string(x)
    });
    let PLUGIN_ID = Some({
      let x = &self.PLUGIN_ID;
      _fbb.create_string(x)
    });
    let PLUGIN_VERSION = self.PLUGIN_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LICENSEE_ORG = Some({
      let x = &self.LICENSEE_ORG;
      _fbb.create_string(x)
    });
    let LICENSEE_EMAIL = self.LICENSEE_EMAIL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LICENSEE_PEER_ID = self.LICENSEE_PEER_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LICENSEE_PUBKEY = self.LICENSEE_PUBKEY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ISSUER_PUBKEY = self.ISSUER_PUBKEY.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let ALLOWED_DOMAINS = self.ALLOWED_DOMAINS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let ALLOWED_TLDS = self.ALLOWED_TLDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let LICENSE_TYPE = self.LICENSE_TYPE;
    let MAX_ACTIVATIONS = self.MAX_ACTIVATIONS;
    let ISSUED_AT = self.ISSUED_AT;
    let VALID_FROM = self.VALID_FROM;
    let EXPIRES_AT = self.EXPIRES_AT;
    let ISSUER_PEER_ID = self.ISSUER_PEER_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIGNATURE = self.SIGNATURE.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    PLK::create(_fbb, &PLKArgs{
      LICENSE_ID,
      PLUGIN_ID,
      PLUGIN_VERSION,
      LICENSEE_ORG,
      LICENSEE_EMAIL,
      LICENSEE_PEER_ID,
      LICENSEE_PUBKEY,
      ISSUER_PUBKEY,
      ALLOWED_DOMAINS,
      ALLOWED_TLDS,
      LICENSE_TYPE,
      MAX_ACTIVATIONS,
      ISSUED_AT,
      VALID_FROM,
      EXPIRES_AT,
      ISSUER_PEER_ID,
      SIGNATURE,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PLK`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLK_unchecked`.
pub fn root_as_PLK(buf: &[u8]) -> Result<PLK, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PLK>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PLK` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_PLK_unchecked`.
pub fn size_prefixed_root_as_PLK(buf: &[u8]) -> Result<PLK, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PLK>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PLK` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLK_unchecked`.
pub fn root_as_PLK_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PLK<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PLK<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PLK` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_PLK_unchecked`.
pub fn size_prefixed_root_as_PLK_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PLK<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PLK<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PLK and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PLK`.
pub unsafe fn root_as_PLK_unchecked(buf: &[u8]) -> PLK {
  flatbuffers::root_unchecked::<PLK>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PLK and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PLK`.
pub unsafe fn size_prefixed_root_as_PLK_unchecked(buf: &[u8]) -> PLK {
  flatbuffers::size_prefixed_root_unchecked::<PLK>(buf)
}
pub const PLK_IDENTIFIER: &str = "$PLK";

#[inline]
pub fn PLK_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PLK_IDENTIFIER, false)
}

#[inline]
pub fn PLK_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, PLK_IDENTIFIER, true)
}

#[inline]
pub fn finish_PLK_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<PLK<'a>>) {
  fbb.finish(root, Some(PLK_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_PLK_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<PLK<'a>>) {
  fbb.finish_size_prefixed(root, Some(PLK_IDENTIFIER));
}
