// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMPARISON_OPERATOR: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMPARISON_OPERATOR: i8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPARISON_OPERATOR: [ComparisonOperator; 12] = [
  ComparisonOperator::EQ,
  ComparisonOperator::NE,
  ComparisonOperator::GT,
  ComparisonOperator::LT,
  ComparisonOperator::GE,
  ComparisonOperator::LE,
  ComparisonOperator::STARTS_WITH,
  ComparisonOperator::ENDS_WITH,
  ComparisonOperator::CONTAINS,
  ComparisonOperator::NOT_STARTS_WITH,
  ComparisonOperator::NOT_ENDS_WITH,
  ComparisonOperator::NOT_CONTAINS,
];

/// Comparison operators for match criteria and conditions
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ComparisonOperator(pub i8);
#[allow(non_upper_case_globals)]
impl ComparisonOperator {
  /// Equal to
  pub const EQ: Self = Self(0);
  /// Not equal to
  pub const NE: Self = Self(1);
  /// Greater than
  pub const GT: Self = Self(2);
  /// Less than
  pub const LT: Self = Self(3);
  /// Greater than or equal to
  pub const GE: Self = Self(4);
  /// Less than or equal to
  pub const LE: Self = Self(5);
  /// String starts with
  pub const STARTS_WITH: Self = Self(6);
  /// String ends with
  pub const ENDS_WITH: Self = Self(7);
  /// String contains
  pub const CONTAINS: Self = Self(8);
  /// String does not start with
  pub const NOT_STARTS_WITH: Self = Self(9);
  /// String does not end with
  pub const NOT_ENDS_WITH: Self = Self(10);
  /// String does not contain
  pub const NOT_CONTAINS: Self = Self(11);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EQ,
    Self::NE,
    Self::GT,
    Self::LT,
    Self::GE,
    Self::LE,
    Self::STARTS_WITH,
    Self::ENDS_WITH,
    Self::CONTAINS,
    Self::NOT_STARTS_WITH,
    Self::NOT_ENDS_WITH,
    Self::NOT_CONTAINS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EQ => Some("EQ"),
      Self::NE => Some("NE"),
      Self::GT => Some("GT"),
      Self::LT => Some("LT"),
      Self::GE => Some("GE"),
      Self::LE => Some("LE"),
      Self::STARTS_WITH => Some("STARTS_WITH"),
      Self::ENDS_WITH => Some("ENDS_WITH"),
      Self::CONTAINS => Some("CONTAINS"),
      Self::NOT_STARTS_WITH => Some("NOT_STARTS_WITH"),
      Self::NOT_ENDS_WITH => Some("NOT_ENDS_WITH"),
      Self::NOT_CONTAINS => Some("NOT_CONTAINS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ComparisonOperator {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ComparisonOperator {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ComparisonOperator {
    type Output = ComparisonOperator;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ComparisonOperator {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ComparisonOperator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ComparisonOperator {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATA_SOURCE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATA_SOURCE_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATA_SOURCE_TYPE: [DataSourceType; 5] = [
  DataSourceType::TELEMETERED,
  DataSourceType::DERIVED,
  DataSourceType::CONSTANT,
  DataSourceType::LOCAL,
  DataSourceType::GROUND,
];

/// Data source types for telemetry parameters
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DataSourceType(pub i8);
#[allow(non_upper_case_globals)]
impl DataSourceType {
  /// Data received from spacecraft telemetry
  pub const TELEMETERED: Self = Self(0);
  /// Computed from other parameters
  pub const DERIVED: Self = Self(1);
  /// Fixed constant value
  pub const CONSTANT: Self = Self(2);
  /// Local ground system value
  pub const LOCAL: Self = Self(3);
  /// Ground-generated data
  pub const GROUND: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TELEMETERED,
    Self::DERIVED,
    Self::CONSTANT,
    Self::LOCAL,
    Self::GROUND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TELEMETERED => Some("TELEMETERED"),
      Self::DERIVED => Some("DERIVED"),
      Self::CONSTANT => Some("CONSTANT"),
      Self::LOCAL => Some("LOCAL"),
      Self::GROUND => Some("GROUND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DataSourceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DataSourceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DataSourceType {
    type Output = DataSourceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DataSourceType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DataSourceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DataSourceType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BOOLEAN_OPERATOR_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BOOLEAN_OPERATOR_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BOOLEAN_OPERATOR_TYPE: [BooleanOperatorType; 3] = [
  BooleanOperatorType::AND,
  BooleanOperatorType::OR,
  BooleanOperatorType::XOR,
];

/// Boolean operators for combining conditions
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BooleanOperatorType(pub i8);
#[allow(non_upper_case_globals)]
impl BooleanOperatorType {
  /// Logical AND
  pub const AND: Self = Self(0);
  /// Logical OR
  pub const OR: Self = Self(1);
  /// Logical XOR
  pub const XOR: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AND,
    Self::OR,
    Self::XOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AND => Some("AND"),
      Self::OR => Some("OR"),
      Self::XOR => Some("XOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BooleanOperatorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BooleanOperatorType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BooleanOperatorType {
    type Output = BooleanOperatorType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BooleanOperatorType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BooleanOperatorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BooleanOperatorType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REFERENCE_LOCATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REFERENCE_LOCATION_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REFERENCE_LOCATION_TYPE: [ReferenceLocationType; 4] = [
  ReferenceLocationType::CONTAINER_START,
  ReferenceLocationType::CONTAINER_END,
  ReferenceLocationType::PREVIOUS_ENTRY,
  ReferenceLocationType::NEXT_ENTRY,
];

/// Reference location for positioning within containers
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReferenceLocationType(pub i8);
#[allow(non_upper_case_globals)]
impl ReferenceLocationType {
  /// Start of the container
  pub const CONTAINER_START: Self = Self(0);
  /// End of the container
  pub const CONTAINER_END: Self = Self(1);
  /// End of previous entry
  pub const PREVIOUS_ENTRY: Self = Self(2);
  /// Start of next entry
  pub const NEXT_ENTRY: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CONTAINER_START,
    Self::CONTAINER_END,
    Self::PREVIOUS_ENTRY,
    Self::NEXT_ENTRY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CONTAINER_START => Some("CONTAINER_START"),
      Self::CONTAINER_END => Some("CONTAINER_END"),
      Self::PREVIOUS_ENTRY => Some("PREVIOUS_ENTRY"),
      Self::NEXT_ENTRY => Some("NEXT_ENTRY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ReferenceLocationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ReferenceLocationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ReferenceLocationType {
    type Output = ReferenceLocationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReferenceLocationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ReferenceLocationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ReferenceLocationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RATE_BASIS_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RATE_BASIS_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RATE_BASIS_TYPE: [RateBasisType; 2] = [
  RateBasisType::PER_SECOND,
  RateBasisType::PER_CONTAINER,
];

/// Rate basis for stream rate specifications
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RateBasisType(pub i8);
#[allow(non_upper_case_globals)]
impl RateBasisType {
  /// Rate per second
  pub const PER_SECOND: Self = Self(0);
  /// Rate per container occurrence
  pub const PER_CONTAINER: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PER_SECOND,
    Self::PER_CONTAINER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PER_SECOND => Some("PER_SECOND"),
      Self::PER_CONTAINER => Some("PER_CONTAINER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RateBasisType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RateBasisType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RateBasisType {
    type Output = RateBasisType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RateBasisType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RateBasisType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RateBasisType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BYTE_ORDER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BYTE_ORDER_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BYTE_ORDER_TYPE: [ByteOrderType; 2] = [
  ByteOrderType::BIG_ENDIAN,
  ByteOrderType::LITTLE_ENDIAN,
];

/// Byte ordering for data encoding
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ByteOrderType(pub i8);
#[allow(non_upper_case_globals)]
impl ByteOrderType {
  /// Most significant byte first
  pub const BIG_ENDIAN: Self = Self(0);
  /// Least significant byte first
  pub const LITTLE_ENDIAN: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BIG_ENDIAN,
    Self::LITTLE_ENDIAN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BIG_ENDIAN => Some("BIG_ENDIAN"),
      Self::LITTLE_ENDIAN => Some("LITTLE_ENDIAN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ByteOrderType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ByteOrderType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ByteOrderType {
    type Output = ByteOrderType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ByteOrderType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ByteOrderType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ByteOrderType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INTEGER_ENCODING_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INTEGER_ENCODING_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INTEGER_ENCODING_TYPE: [IntegerEncodingType; 6] = [
  IntegerEncodingType::UNSIGNED,
  IntegerEncodingType::TWOS_COMPLEMENT,
  IntegerEncodingType::SIGN_MAGNITUDE,
  IntegerEncodingType::ONES_COMPLEMENT,
  IntegerEncodingType::BCD,
  IntegerEncodingType::PACKED_BCD,
];

/// Integer encoding types
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IntegerEncodingType(pub i8);
#[allow(non_upper_case_globals)]
impl IntegerEncodingType {
  /// Unsigned binary
  pub const UNSIGNED: Self = Self(0);
  /// Two's complement signed
  pub const TWOS_COMPLEMENT: Self = Self(1);
  /// Sign-magnitude representation
  pub const SIGN_MAGNITUDE: Self = Self(2);
  /// Ones' complement signed
  pub const ONES_COMPLEMENT: Self = Self(3);
  /// Binary Coded Decimal
  pub const BCD: Self = Self(4);
  /// Packed BCD
  pub const PACKED_BCD: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNSIGNED,
    Self::TWOS_COMPLEMENT,
    Self::SIGN_MAGNITUDE,
    Self::ONES_COMPLEMENT,
    Self::BCD,
    Self::PACKED_BCD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNSIGNED => Some("UNSIGNED"),
      Self::TWOS_COMPLEMENT => Some("TWOS_COMPLEMENT"),
      Self::SIGN_MAGNITUDE => Some("SIGN_MAGNITUDE"),
      Self::ONES_COMPLEMENT => Some("ONES_COMPLEMENT"),
      Self::BCD => Some("BCD"),
      Self::PACKED_BCD => Some("PACKED_BCD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IntegerEncodingType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IntegerEncodingType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IntegerEncodingType {
    type Output = IntegerEncodingType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IntegerEncodingType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IntegerEncodingType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IntegerEncodingType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FLOAT_ENCODING_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FLOAT_ENCODING_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FLOAT_ENCODING_TYPE: [FloatEncodingType; 5] = [
  FloatEncodingType::IEEE754_1985,
  FloatEncodingType::MILSTD_1750A,
  FloatEncodingType::DEC,
  FloatEncodingType::IBM,
  FloatEncodingType::TI,
];

/// Float encoding formats
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FloatEncodingType(pub i8);
#[allow(non_upper_case_globals)]
impl FloatEncodingType {
  /// IEEE 754-1985 single precision (32-bit)
  pub const IEEE754_1985: Self = Self(0);
  /// MIL-STD-1750A format
  pub const MILSTD_1750A: Self = Self(1);
  /// DEC PDP format
  pub const DEC: Self = Self(2);
  /// IBM System/360 format
  pub const IBM: Self = Self(3);
  /// Texas Instruments TI format
  pub const TI: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IEEE754_1985,
    Self::MILSTD_1750A,
    Self::DEC,
    Self::IBM,
    Self::TI,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::IEEE754_1985 => Some("IEEE754_1985"),
      Self::MILSTD_1750A => Some("MILSTD_1750A"),
      Self::DEC => Some("DEC"),
      Self::IBM => Some("IBM"),
      Self::TI => Some("TI"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FloatEncodingType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FloatEncodingType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FloatEncodingType {
    type Output = FloatEncodingType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FloatEncodingType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FloatEncodingType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FloatEncodingType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STRING_ENCODING_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STRING_ENCODING_TYPE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STRING_ENCODING_TYPE: [StringEncodingType; 7] = [
  StringEncodingType::US_ASCII,
  StringEncodingType::ISO_8859_1,
  StringEncodingType::WINDOWS_1252,
  StringEncodingType::UTF_8,
  StringEncodingType::UTF_16,
  StringEncodingType::UTF_16BE,
  StringEncodingType::UTF_16LE,
];

/// String encoding character sets
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StringEncodingType(pub i8);
#[allow(non_upper_case_globals)]
impl StringEncodingType {
  /// US-ASCII (7-bit)
  pub const US_ASCII: Self = Self(0);
  /// ISO 8859-1 Latin-1
  pub const ISO_8859_1: Self = Self(1);
  /// Windows-1252
  pub const WINDOWS_1252: Self = Self(2);
  /// UTF-8
  pub const UTF_8: Self = Self(3);
  /// UTF-16
  pub const UTF_16: Self = Self(4);
  /// UTF-16 Big Endian
  pub const UTF_16BE: Self = Self(5);
  /// UTF-16 Little Endian
  pub const UTF_16LE: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::US_ASCII,
    Self::ISO_8859_1,
    Self::WINDOWS_1252,
    Self::UTF_8,
    Self::UTF_16,
    Self::UTF_16BE,
    Self::UTF_16LE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::US_ASCII => Some("US_ASCII"),
      Self::ISO_8859_1 => Some("ISO_8859_1"),
      Self::WINDOWS_1252 => Some("WINDOWS_1252"),
      Self::UTF_8 => Some("UTF_8"),
      Self::UTF_16 => Some("UTF_16"),
      Self::UTF_16BE => Some("UTF_16BE"),
      Self::UTF_16LE => Some("UTF_16LE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StringEncodingType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StringEncodingType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StringEncodingType {
    type Output = StringEncodingType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StringEncodingType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StringEncodingType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StringEncodingType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STRING_SIZE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STRING_SIZE_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STRING_SIZE_TYPE: [StringSizeType; 3] = [
  StringSizeType::FIXED,
  StringSizeType::LEADING_SIZE,
  StringSizeType::TERMINATION_CHAR,
];

/// String size specification type
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StringSizeType(pub i8);
#[allow(non_upper_case_globals)]
impl StringSizeType {
  /// Fixed length string
  pub const FIXED: Self = Self(0);
  /// Variable with leading count
  pub const LEADING_SIZE: Self = Self(1);
  /// Variable with termination character
  pub const TERMINATION_CHAR: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FIXED,
    Self::LEADING_SIZE,
    Self::TERMINATION_CHAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FIXED => Some("FIXED"),
      Self::LEADING_SIZE => Some("LEADING_SIZE"),
      Self::TERMINATION_CHAR => Some("TERMINATION_CHAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StringSizeType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StringSizeType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StringSizeType {
    type Output = StringSizeType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StringSizeType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StringSizeType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StringSizeType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ALARM_SEVERITY_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ALARM_SEVERITY_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ALARM_SEVERITY_TYPE: [AlarmSeverityType; 6] = [
  AlarmSeverityType::NORMAL,
  AlarmSeverityType::WATCH,
  AlarmSeverityType::WARNING,
  AlarmSeverityType::DISTRESS,
  AlarmSeverityType::CRITICAL,
  AlarmSeverityType::SEVERE,
];

/// Alarm severity levels
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AlarmSeverityType(pub i8);
#[allow(non_upper_case_globals)]
impl AlarmSeverityType {
  /// Normal operation
  pub const NORMAL: Self = Self(0);
  /// Watch level - early warning
  pub const WATCH: Self = Self(1);
  /// Warning level
  pub const WARNING: Self = Self(2);
  /// Distress level - significant issue
  pub const DISTRESS: Self = Self(3);
  /// Critical level - immediate action required
  pub const CRITICAL: Self = Self(4);
  /// Severe level - system failure
  pub const SEVERE: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::WATCH,
    Self::WARNING,
    Self::DISTRESS,
    Self::CRITICAL,
    Self::SEVERE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::WATCH => Some("WATCH"),
      Self::WARNING => Some("WARNING"),
      Self::DISTRESS => Some("DISTRESS"),
      Self::CRITICAL => Some("CRITICAL"),
      Self::SEVERE => Some("SEVERE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AlarmSeverityType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AlarmSeverityType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AlarmSeverityType {
    type Output = AlarmSeverityType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AlarmSeverityType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AlarmSeverityType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AlarmSeverityType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERIFIER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERIFIER_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERIFIER_TYPE: [VerifierType; 4] = [
  VerifierType::START,
  VerifierType::PROGRESS,
  VerifierType::COMPLETE,
  VerifierType::FAILED,
];

/// Verifier type for command verification
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VerifierType(pub i8);
#[allow(non_upper_case_globals)]
impl VerifierType {
  /// Execution started
  pub const START: Self = Self(0);
  /// Progress update
  pub const PROGRESS: Self = Self(1);
  /// Execution complete
  pub const COMPLETE: Self = Self(2);
  /// Command failed
  pub const FAILED: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::START,
    Self::PROGRESS,
    Self::COMPLETE,
    Self::FAILED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::START => Some("START"),
      Self::PROGRESS => Some("PROGRESS"),
      Self::COMPLETE => Some("COMPLETE"),
      Self::FAILED => Some("FAILED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VerifierType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VerifierType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VerifierType {
    type Output = VerifierType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VerifierType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VerifierType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VerifierType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TIME_WINDOW_REF_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TIME_WINDOW_REF_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TIME_WINDOW_REF_TYPE: [TimeWindowRefType; 2] = [
  TimeWindowRefType::COMMAND_RELEASE,
  TimeWindowRefType::TIME_LAST_VERIFIER_PASSED,
];

/// Time window reference for command verification
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TimeWindowRefType(pub i8);
#[allow(non_upper_case_globals)]
impl TimeWindowRefType {
  /// Relative to command release time
  pub const COMMAND_RELEASE: Self = Self(0);
  /// Relative to last verifier passed
  pub const TIME_LAST_VERIFIER_PASSED: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMMAND_RELEASE,
    Self::TIME_LAST_VERIFIER_PASSED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::COMMAND_RELEASE => Some("COMMAND_RELEASE"),
      Self::TIME_LAST_VERIFIER_PASSED => Some("TIME_LAST_VERIFIER_PASSED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TimeWindowRefType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TimeWindowRefType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TimeWindowRefType {
    type Output = TimeWindowRefType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TimeWindowRefType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TimeWindowRefType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TimeWindowRefType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EPOCH_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EPOCH_TYPE: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EPOCH_TYPE: [EpochType; 5] = [
  EpochType::TAI,
  EpochType::J2000,
  EpochType::UNIX,
  EpochType::GPS,
  EpochType::CUSTOM,
];

/// Epoch reference for absolute time
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EpochType(pub i8);
#[allow(non_upper_case_globals)]
impl EpochType {
  /// TAI epoch (1958-01-01)
  pub const TAI: Self = Self(0);
  /// J2000 epoch (2000-01-01 12:00:00 TT)
  pub const J2000: Self = Self(1);
  /// Unix epoch (1970-01-01)
  pub const UNIX: Self = Self(2);
  /// GPS epoch (1980-01-06)
  pub const GPS: Self = Self(3);
  /// Custom epoch specified in offset
  pub const CUSTOM: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TAI,
    Self::J2000,
    Self::UNIX,
    Self::GPS,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TAI => Some("TAI"),
      Self::J2000 => Some("J2000"),
      Self::UNIX => Some("UNIX"),
      Self::GPS => Some("GPS"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EpochType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EpochType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EpochType {
    type Output = EpochType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EpochType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EpochType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EpochType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ERROR_DETECTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ERROR_DETECTION_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ERROR_DETECTION_TYPE: [ErrorDetectionType; 4] = [
  ErrorDetectionType::NONE,
  ErrorDetectionType::CRC,
  ErrorDetectionType::CHECKSUM,
  ErrorDetectionType::PARITY,
];

/// Error detection/correction algorithms
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ErrorDetectionType(pub i8);
#[allow(non_upper_case_globals)]
impl ErrorDetectionType {
  /// No error detection
  pub const NONE: Self = Self(0);
  /// Cyclic redundancy check
  pub const CRC: Self = Self(1);
  /// Checksum
  pub const CHECKSUM: Self = Self(2);
  /// Parity
  pub const PARITY: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CRC,
    Self::CHECKSUM,
    Self::PARITY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CRC => Some("CRC"),
      Self::CHECKSUM => Some("CHECKSUM"),
      Self::PARITY => Some("PARITY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ErrorDetectionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ErrorDetectionType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ErrorDetectionType {
    type Output = ErrorDetectionType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ErrorDetectionType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ErrorDetectionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ErrorDetectionType {}
pub enum IntegerDataEncodingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Integer data encoding specification
pub struct IntegerDataEncoding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntegerDataEncoding<'a> {
  type Inner = IntegerDataEncoding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntegerDataEncoding<'a> {
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 4;
  pub const VT_BYTE_ORDER: flatbuffers::VOffsetT = 6;
  pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
  pub const VT_DEFAULT_CALIBRATOR: flatbuffers::VOffsetT = 10;
  pub const VT_CONTEXT_CALIBRATOR_LIST: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntegerDataEncoding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntegerDataEncodingArgs<'args>
  ) -> flatbuffers::WIPOffset<IntegerDataEncoding<'bldr>> {
    let mut builder = IntegerDataEncodingBuilder::new(_fbb);
    if let Some(x) = args.CONTEXT_CALIBRATOR_LIST { builder.add_CONTEXT_CALIBRATOR_LIST(x); }
    if let Some(x) = args.DEFAULT_CALIBRATOR { builder.add_DEFAULT_CALIBRATOR(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_ENCODING(args.ENCODING);
    builder.add_BYTE_ORDER(args.BYTE_ORDER);
    builder.finish()
  }

  pub fn unpack(&self) -> IntegerDataEncodingT {
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let BYTE_ORDER = self.BYTE_ORDER();
    let ENCODING = self.ENCODING();
    let DEFAULT_CALIBRATOR = self.DEFAULT_CALIBRATOR().map(|x| {
      x.to_string()
    });
    let CONTEXT_CALIBRATOR_LIST = self.CONTEXT_CALIBRATOR_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    IntegerDataEncodingT {
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR,
      CONTEXT_CALIBRATOR_LIST,
    }
  }

  /// Number of bits for this integer
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(IntegerDataEncoding::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Byte ordering
  #[inline]
  pub fn BYTE_ORDER(&self) -> ByteOrderType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ByteOrderType>(IntegerDataEncoding::VT_BYTE_ORDER, Some(ByteOrderType::BIG_ENDIAN)).unwrap()}
  }
  /// Integer encoding type
  #[inline]
  pub fn ENCODING(&self) -> IntegerEncodingType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IntegerEncodingType>(IntegerDataEncoding::VT_ENCODING, Some(IntegerEncodingType::UNSIGNED)).unwrap()}
  }
  /// Default calibrator reference
  #[inline]
  pub fn DEFAULT_CALIBRATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerDataEncoding::VT_DEFAULT_CALIBRATOR, None)}
  }
  /// Context-dependent calibrators
  #[inline]
  pub fn CONTEXT_CALIBRATOR_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator>>>>(IntegerDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, None)}
  }
}

impl flatbuffers::Verifiable for IntegerDataEncoding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<ByteOrderType>("BYTE_ORDER", Self::VT_BYTE_ORDER, false)?
     .visit_field::<IntegerEncodingType>("ENCODING", Self::VT_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DEFAULT_CALIBRATOR", Self::VT_DEFAULT_CALIBRATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextCalibrator>>>>("CONTEXT_CALIBRATOR_LIST", Self::VT_CONTEXT_CALIBRATOR_LIST, false)?
     .finish();
    Ok(())
  }
}
pub struct IntegerDataEncodingArgs<'a> {
    pub SIZE_IN_BITS: u16,
    pub BYTE_ORDER: ByteOrderType,
    pub ENCODING: IntegerEncodingType,
    pub DEFAULT_CALIBRATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTEXT_CALIBRATOR_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator<'a>>>>>,
}
impl<'a> Default for IntegerDataEncodingArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntegerDataEncodingArgs {
      SIZE_IN_BITS: 0,
      BYTE_ORDER: ByteOrderType::BIG_ENDIAN,
      ENCODING: IntegerEncodingType::UNSIGNED,
      DEFAULT_CALIBRATOR: None,
      CONTEXT_CALIBRATOR_LIST: None,
    }
  }
}

pub struct IntegerDataEncodingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntegerDataEncodingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(IntegerDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_BYTE_ORDER(&mut self, BYTE_ORDER: ByteOrderType) {
    self.fbb_.push_slot::<ByteOrderType>(IntegerDataEncoding::VT_BYTE_ORDER, BYTE_ORDER, ByteOrderType::BIG_ENDIAN);
  }
  #[inline]
  pub fn add_ENCODING(&mut self, ENCODING: IntegerEncodingType) {
    self.fbb_.push_slot::<IntegerEncodingType>(IntegerDataEncoding::VT_ENCODING, ENCODING, IntegerEncodingType::UNSIGNED);
  }
  #[inline]
  pub fn add_DEFAULT_CALIBRATOR(&mut self, DEFAULT_CALIBRATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerDataEncoding::VT_DEFAULT_CALIBRATOR, DEFAULT_CALIBRATOR);
  }
  #[inline]
  pub fn add_CONTEXT_CALIBRATOR_LIST(&mut self, CONTEXT_CALIBRATOR_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextCalibrator<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, CONTEXT_CALIBRATOR_LIST);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntegerDataEncodingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntegerDataEncodingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntegerDataEncoding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntegerDataEncoding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntegerDataEncoding");
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("BYTE_ORDER", &self.BYTE_ORDER());
      ds.field("ENCODING", &self.ENCODING());
      ds.field("DEFAULT_CALIBRATOR", &self.DEFAULT_CALIBRATOR());
      ds.field("CONTEXT_CALIBRATOR_LIST", &self.CONTEXT_CALIBRATOR_LIST());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IntegerDataEncodingT {
  pub SIZE_IN_BITS: u16,
  pub BYTE_ORDER: ByteOrderType,
  pub ENCODING: IntegerEncodingType,
  pub DEFAULT_CALIBRATOR: Option<String>,
  pub CONTEXT_CALIBRATOR_LIST: Option<Vec<ContextCalibratorT>>,
}
impl Default for IntegerDataEncodingT {
  fn default() -> Self {
    Self {
      SIZE_IN_BITS: 0,
      BYTE_ORDER: ByteOrderType::BIG_ENDIAN,
      ENCODING: IntegerEncodingType::UNSIGNED,
      DEFAULT_CALIBRATOR: None,
      CONTEXT_CALIBRATOR_LIST: None,
    }
  }
}
impl IntegerDataEncodingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IntegerDataEncoding<'b>> {
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let BYTE_ORDER = self.BYTE_ORDER;
    let ENCODING = self.ENCODING;
    let DEFAULT_CALIBRATOR = self.DEFAULT_CALIBRATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTEXT_CALIBRATOR_LIST = self.CONTEXT_CALIBRATOR_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    IntegerDataEncoding::create(_fbb, &IntegerDataEncodingArgs{
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR,
      CONTEXT_CALIBRATOR_LIST,
    })
  }
}
pub enum FloatDataEncodingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Float data encoding specification
pub struct FloatDataEncoding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatDataEncoding<'a> {
  type Inner = FloatDataEncoding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloatDataEncoding<'a> {
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 4;
  pub const VT_BYTE_ORDER: flatbuffers::VOffsetT = 6;
  pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
  pub const VT_DEFAULT_CALIBRATOR: flatbuffers::VOffsetT = 10;
  pub const VT_CONTEXT_CALIBRATOR_LIST: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloatDataEncoding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatDataEncodingArgs<'args>
  ) -> flatbuffers::WIPOffset<FloatDataEncoding<'bldr>> {
    let mut builder = FloatDataEncodingBuilder::new(_fbb);
    if let Some(x) = args.CONTEXT_CALIBRATOR_LIST { builder.add_CONTEXT_CALIBRATOR_LIST(x); }
    if let Some(x) = args.DEFAULT_CALIBRATOR { builder.add_DEFAULT_CALIBRATOR(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_ENCODING(args.ENCODING);
    builder.add_BYTE_ORDER(args.BYTE_ORDER);
    builder.finish()
  }

  pub fn unpack(&self) -> FloatDataEncodingT {
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let BYTE_ORDER = self.BYTE_ORDER();
    let ENCODING = self.ENCODING();
    let DEFAULT_CALIBRATOR = self.DEFAULT_CALIBRATOR().map(|x| {
      x.to_string()
    });
    let CONTEXT_CALIBRATOR_LIST = self.CONTEXT_CALIBRATOR_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    FloatDataEncodingT {
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR,
      CONTEXT_CALIBRATOR_LIST,
    }
  }

  /// Number of bits (typically 32 or 64)
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(FloatDataEncoding::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Byte ordering
  #[inline]
  pub fn BYTE_ORDER(&self) -> ByteOrderType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ByteOrderType>(FloatDataEncoding::VT_BYTE_ORDER, Some(ByteOrderType::BIG_ENDIAN)).unwrap()}
  }
  /// Float encoding format
  #[inline]
  pub fn ENCODING(&self) -> FloatEncodingType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FloatEncodingType>(FloatDataEncoding::VT_ENCODING, Some(FloatEncodingType::IEEE754_1985)).unwrap()}
  }
  /// Default calibrator reference
  #[inline]
  pub fn DEFAULT_CALIBRATOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatDataEncoding::VT_DEFAULT_CALIBRATOR, None)}
  }
  /// Context-dependent calibrators
  #[inline]
  pub fn CONTEXT_CALIBRATOR_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator>>>>(FloatDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, None)}
  }
}

impl flatbuffers::Verifiable for FloatDataEncoding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<ByteOrderType>("BYTE_ORDER", Self::VT_BYTE_ORDER, false)?
     .visit_field::<FloatEncodingType>("ENCODING", Self::VT_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DEFAULT_CALIBRATOR", Self::VT_DEFAULT_CALIBRATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextCalibrator>>>>("CONTEXT_CALIBRATOR_LIST", Self::VT_CONTEXT_CALIBRATOR_LIST, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatDataEncodingArgs<'a> {
    pub SIZE_IN_BITS: u16,
    pub BYTE_ORDER: ByteOrderType,
    pub ENCODING: FloatEncodingType,
    pub DEFAULT_CALIBRATOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTEXT_CALIBRATOR_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextCalibrator<'a>>>>>,
}
impl<'a> Default for FloatDataEncodingArgs<'a> {
  #[inline]
  fn default() -> Self {
    FloatDataEncodingArgs {
      SIZE_IN_BITS: 0,
      BYTE_ORDER: ByteOrderType::BIG_ENDIAN,
      ENCODING: FloatEncodingType::IEEE754_1985,
      DEFAULT_CALIBRATOR: None,
      CONTEXT_CALIBRATOR_LIST: None,
    }
  }
}

pub struct FloatDataEncodingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatDataEncodingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(FloatDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_BYTE_ORDER(&mut self, BYTE_ORDER: ByteOrderType) {
    self.fbb_.push_slot::<ByteOrderType>(FloatDataEncoding::VT_BYTE_ORDER, BYTE_ORDER, ByteOrderType::BIG_ENDIAN);
  }
  #[inline]
  pub fn add_ENCODING(&mut self, ENCODING: FloatEncodingType) {
    self.fbb_.push_slot::<FloatEncodingType>(FloatDataEncoding::VT_ENCODING, ENCODING, FloatEncodingType::IEEE754_1985);
  }
  #[inline]
  pub fn add_DEFAULT_CALIBRATOR(&mut self, DEFAULT_CALIBRATOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatDataEncoding::VT_DEFAULT_CALIBRATOR, DEFAULT_CALIBRATOR);
  }
  #[inline]
  pub fn add_CONTEXT_CALIBRATOR_LIST(&mut self, CONTEXT_CALIBRATOR_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextCalibrator<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatDataEncoding::VT_CONTEXT_CALIBRATOR_LIST, CONTEXT_CALIBRATOR_LIST);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatDataEncodingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatDataEncodingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatDataEncoding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloatDataEncoding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloatDataEncoding");
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("BYTE_ORDER", &self.BYTE_ORDER());
      ds.field("ENCODING", &self.ENCODING());
      ds.field("DEFAULT_CALIBRATOR", &self.DEFAULT_CALIBRATOR());
      ds.field("CONTEXT_CALIBRATOR_LIST", &self.CONTEXT_CALIBRATOR_LIST());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloatDataEncodingT {
  pub SIZE_IN_BITS: u16,
  pub BYTE_ORDER: ByteOrderType,
  pub ENCODING: FloatEncodingType,
  pub DEFAULT_CALIBRATOR: Option<String>,
  pub CONTEXT_CALIBRATOR_LIST: Option<Vec<ContextCalibratorT>>,
}
impl Default for FloatDataEncodingT {
  fn default() -> Self {
    Self {
      SIZE_IN_BITS: 0,
      BYTE_ORDER: ByteOrderType::BIG_ENDIAN,
      ENCODING: FloatEncodingType::IEEE754_1985,
      DEFAULT_CALIBRATOR: None,
      CONTEXT_CALIBRATOR_LIST: None,
    }
  }
}
impl FloatDataEncodingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FloatDataEncoding<'b>> {
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let BYTE_ORDER = self.BYTE_ORDER;
    let ENCODING = self.ENCODING;
    let DEFAULT_CALIBRATOR = self.DEFAULT_CALIBRATOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTEXT_CALIBRATOR_LIST = self.CONTEXT_CALIBRATOR_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    FloatDataEncoding::create(_fbb, &FloatDataEncodingArgs{
      SIZE_IN_BITS,
      BYTE_ORDER,
      ENCODING,
      DEFAULT_CALIBRATOR,
      CONTEXT_CALIBRATOR_LIST,
    })
  }
}
pub enum StringDataEncodingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// String data encoding specification
pub struct StringDataEncoding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringDataEncoding<'a> {
  type Inner = StringDataEncoding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringDataEncoding<'a> {
  pub const VT_ENCODING: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 8;
  pub const VT_TERMINATION_CHAR: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_SIZE_IN_BITS: flatbuffers::VOffsetT = 12;
  pub const VT_LEADING_SIZE_BITS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringDataEncoding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringDataEncodingArgs
  ) -> flatbuffers::WIPOffset<StringDataEncoding<'bldr>> {
    let mut builder = StringDataEncodingBuilder::new(_fbb);
    builder.add_MAX_SIZE_IN_BITS(args.MAX_SIZE_IN_BITS);
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_LEADING_SIZE_BITS(args.LEADING_SIZE_BITS);
    builder.add_TERMINATION_CHAR(args.TERMINATION_CHAR);
    builder.add_SIZE_TYPE(args.SIZE_TYPE);
    builder.add_ENCODING(args.ENCODING);
    builder.finish()
  }

  pub fn unpack(&self) -> StringDataEncodingT {
    let ENCODING = self.ENCODING();
    let SIZE_TYPE = self.SIZE_TYPE();
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let TERMINATION_CHAR = self.TERMINATION_CHAR();
    let MAX_SIZE_IN_BITS = self.MAX_SIZE_IN_BITS();
    let LEADING_SIZE_BITS = self.LEADING_SIZE_BITS();
    StringDataEncodingT {
      ENCODING,
      SIZE_TYPE,
      SIZE_IN_BITS,
      TERMINATION_CHAR,
      MAX_SIZE_IN_BITS,
      LEADING_SIZE_BITS,
    }
  }

  /// Character encoding
  #[inline]
  pub fn ENCODING(&self) -> StringEncodingType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StringEncodingType>(StringDataEncoding::VT_ENCODING, Some(StringEncodingType::UTF_8)).unwrap()}
  }
  /// Size type specification
  #[inline]
  pub fn SIZE_TYPE(&self) -> StringSizeType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<StringSizeType>(StringDataEncoding::VT_SIZE_TYPE, Some(StringSizeType::FIXED)).unwrap()}
  }
  /// Fixed size in bits (when SIZE_TYPE=FIXED)
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(StringDataEncoding::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Termination character (when SIZE_TYPE=TERMINATION_CHAR)
  #[inline]
  pub fn TERMINATION_CHAR(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StringDataEncoding::VT_TERMINATION_CHAR, Some(0)).unwrap()}
  }
  /// Maximum size in bits (for variable length)
  #[inline]
  pub fn MAX_SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(StringDataEncoding::VT_MAX_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Leading size field bits (when SIZE_TYPE=LEADING_SIZE)
  #[inline]
  pub fn LEADING_SIZE_BITS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StringDataEncoding::VT_LEADING_SIZE_BITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StringDataEncoding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<StringEncodingType>("ENCODING", Self::VT_ENCODING, false)?
     .visit_field::<StringSizeType>("SIZE_TYPE", Self::VT_SIZE_TYPE, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<u8>("TERMINATION_CHAR", Self::VT_TERMINATION_CHAR, false)?
     .visit_field::<u16>("MAX_SIZE_IN_BITS", Self::VT_MAX_SIZE_IN_BITS, false)?
     .visit_field::<u8>("LEADING_SIZE_BITS", Self::VT_LEADING_SIZE_BITS, false)?
     .finish();
    Ok(())
  }
}
pub struct StringDataEncodingArgs {
    pub ENCODING: StringEncodingType,
    pub SIZE_TYPE: StringSizeType,
    pub SIZE_IN_BITS: u16,
    pub TERMINATION_CHAR: u8,
    pub MAX_SIZE_IN_BITS: u16,
    pub LEADING_SIZE_BITS: u8,
}
impl<'a> Default for StringDataEncodingArgs {
  #[inline]
  fn default() -> Self {
    StringDataEncodingArgs {
      ENCODING: StringEncodingType::UTF_8,
      SIZE_TYPE: StringSizeType::FIXED,
      SIZE_IN_BITS: 0,
      TERMINATION_CHAR: 0,
      MAX_SIZE_IN_BITS: 0,
      LEADING_SIZE_BITS: 0,
    }
  }
}

pub struct StringDataEncodingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringDataEncodingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ENCODING(&mut self, ENCODING: StringEncodingType) {
    self.fbb_.push_slot::<StringEncodingType>(StringDataEncoding::VT_ENCODING, ENCODING, StringEncodingType::UTF_8);
  }
  #[inline]
  pub fn add_SIZE_TYPE(&mut self, SIZE_TYPE: StringSizeType) {
    self.fbb_.push_slot::<StringSizeType>(StringDataEncoding::VT_SIZE_TYPE, SIZE_TYPE, StringSizeType::FIXED);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(StringDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_TERMINATION_CHAR(&mut self, TERMINATION_CHAR: u8) {
    self.fbb_.push_slot::<u8>(StringDataEncoding::VT_TERMINATION_CHAR, TERMINATION_CHAR, 0);
  }
  #[inline]
  pub fn add_MAX_SIZE_IN_BITS(&mut self, MAX_SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(StringDataEncoding::VT_MAX_SIZE_IN_BITS, MAX_SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_LEADING_SIZE_BITS(&mut self, LEADING_SIZE_BITS: u8) {
    self.fbb_.push_slot::<u8>(StringDataEncoding::VT_LEADING_SIZE_BITS, LEADING_SIZE_BITS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringDataEncodingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringDataEncodingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringDataEncoding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringDataEncoding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringDataEncoding");
      ds.field("ENCODING", &self.ENCODING());
      ds.field("SIZE_TYPE", &self.SIZE_TYPE());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("TERMINATION_CHAR", &self.TERMINATION_CHAR());
      ds.field("MAX_SIZE_IN_BITS", &self.MAX_SIZE_IN_BITS());
      ds.field("LEADING_SIZE_BITS", &self.LEADING_SIZE_BITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringDataEncodingT {
  pub ENCODING: StringEncodingType,
  pub SIZE_TYPE: StringSizeType,
  pub SIZE_IN_BITS: u16,
  pub TERMINATION_CHAR: u8,
  pub MAX_SIZE_IN_BITS: u16,
  pub LEADING_SIZE_BITS: u8,
}
impl Default for StringDataEncodingT {
  fn default() -> Self {
    Self {
      ENCODING: StringEncodingType::UTF_8,
      SIZE_TYPE: StringSizeType::FIXED,
      SIZE_IN_BITS: 0,
      TERMINATION_CHAR: 0,
      MAX_SIZE_IN_BITS: 0,
      LEADING_SIZE_BITS: 0,
    }
  }
}
impl StringDataEncodingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StringDataEncoding<'b>> {
    let ENCODING = self.ENCODING;
    let SIZE_TYPE = self.SIZE_TYPE;
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let TERMINATION_CHAR = self.TERMINATION_CHAR;
    let MAX_SIZE_IN_BITS = self.MAX_SIZE_IN_BITS;
    let LEADING_SIZE_BITS = self.LEADING_SIZE_BITS;
    StringDataEncoding::create(_fbb, &StringDataEncodingArgs{
      ENCODING,
      SIZE_TYPE,
      SIZE_IN_BITS,
      TERMINATION_CHAR,
      MAX_SIZE_IN_BITS,
      LEADING_SIZE_BITS,
    })
  }
}
pub enum BinaryDataEncodingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Binary data encoding specification
pub struct BinaryDataEncoding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryDataEncoding<'a> {
  type Inner = BinaryDataEncoding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryDataEncoding<'a> {
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_SIZE_IN_BITS: flatbuffers::VOffsetT = 6;
  pub const VT_LEADING_SIZE_BITS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryDataEncoding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryDataEncodingArgs
  ) -> flatbuffers::WIPOffset<BinaryDataEncoding<'bldr>> {
    let mut builder = BinaryDataEncodingBuilder::new(_fbb);
    builder.add_MAX_SIZE_IN_BITS(args.MAX_SIZE_IN_BITS);
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_LEADING_SIZE_BITS(args.LEADING_SIZE_BITS);
    builder.finish()
  }

  pub fn unpack(&self) -> BinaryDataEncodingT {
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let MAX_SIZE_IN_BITS = self.MAX_SIZE_IN_BITS();
    let LEADING_SIZE_BITS = self.LEADING_SIZE_BITS();
    BinaryDataEncodingT {
      SIZE_IN_BITS,
      MAX_SIZE_IN_BITS,
      LEADING_SIZE_BITS,
    }
  }

  /// Fixed size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BinaryDataEncoding::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Maximum size in bits (for variable length)
  #[inline]
  pub fn MAX_SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(BinaryDataEncoding::VT_MAX_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Leading size field bits (for variable length)
  #[inline]
  pub fn LEADING_SIZE_BITS(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(BinaryDataEncoding::VT_LEADING_SIZE_BITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryDataEncoding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<u16>("MAX_SIZE_IN_BITS", Self::VT_MAX_SIZE_IN_BITS, false)?
     .visit_field::<u8>("LEADING_SIZE_BITS", Self::VT_LEADING_SIZE_BITS, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryDataEncodingArgs {
    pub SIZE_IN_BITS: u16,
    pub MAX_SIZE_IN_BITS: u16,
    pub LEADING_SIZE_BITS: u8,
}
impl<'a> Default for BinaryDataEncodingArgs {
  #[inline]
  fn default() -> Self {
    BinaryDataEncodingArgs {
      SIZE_IN_BITS: 0,
      MAX_SIZE_IN_BITS: 0,
      LEADING_SIZE_BITS: 0,
    }
  }
}

pub struct BinaryDataEncodingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryDataEncodingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(BinaryDataEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_MAX_SIZE_IN_BITS(&mut self, MAX_SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(BinaryDataEncoding::VT_MAX_SIZE_IN_BITS, MAX_SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_LEADING_SIZE_BITS(&mut self, LEADING_SIZE_BITS: u8) {
    self.fbb_.push_slot::<u8>(BinaryDataEncoding::VT_LEADING_SIZE_BITS, LEADING_SIZE_BITS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryDataEncodingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryDataEncodingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryDataEncoding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryDataEncoding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryDataEncoding");
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("MAX_SIZE_IN_BITS", &self.MAX_SIZE_IN_BITS());
      ds.field("LEADING_SIZE_BITS", &self.LEADING_SIZE_BITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BinaryDataEncodingT {
  pub SIZE_IN_BITS: u16,
  pub MAX_SIZE_IN_BITS: u16,
  pub LEADING_SIZE_BITS: u8,
}
impl Default for BinaryDataEncodingT {
  fn default() -> Self {
    Self {
      SIZE_IN_BITS: 0,
      MAX_SIZE_IN_BITS: 0,
      LEADING_SIZE_BITS: 0,
    }
  }
}
impl BinaryDataEncodingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BinaryDataEncoding<'b>> {
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let MAX_SIZE_IN_BITS = self.MAX_SIZE_IN_BITS;
    let LEADING_SIZE_BITS = self.LEADING_SIZE_BITS;
    BinaryDataEncoding::create(_fbb, &BinaryDataEncodingArgs{
      SIZE_IN_BITS,
      MAX_SIZE_IN_BITS,
      LEADING_SIZE_BITS,
    })
  }
}
pub enum PolynomialCalibratorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Polynomial calibrator - converts raw to engineering using polynomial
pub struct PolynomialCalibrator<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PolynomialCalibrator<'a> {
  type Inner = PolynomialCalibrator<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PolynomialCalibrator<'a> {
  pub const VT_COEFFICIENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PolynomialCalibrator { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolynomialCalibratorArgs<'args>
  ) -> flatbuffers::WIPOffset<PolynomialCalibrator<'bldr>> {
    let mut builder = PolynomialCalibratorBuilder::new(_fbb);
    if let Some(x) = args.COEFFICIENTS { builder.add_COEFFICIENTS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> PolynomialCalibratorT {
    let COEFFICIENTS = self.COEFFICIENTS().map(|x| {
      x.into_iter().collect()
    });
    PolynomialCalibratorT {
      COEFFICIENTS,
    }
  }

  /// Polynomial terms (index is power, value is coefficient)
  #[inline]
  pub fn COEFFICIENTS(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(PolynomialCalibrator::VT_COEFFICIENTS, None)}
  }
}

impl flatbuffers::Verifiable for PolynomialCalibrator<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("COEFFICIENTS", Self::VT_COEFFICIENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct PolynomialCalibratorArgs<'a> {
    pub COEFFICIENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for PolynomialCalibratorArgs<'a> {
  #[inline]
  fn default() -> Self {
    PolynomialCalibratorArgs {
      COEFFICIENTS: None,
    }
  }
}

pub struct PolynomialCalibratorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolynomialCalibratorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COEFFICIENTS(&mut self, COEFFICIENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PolynomialCalibrator::VT_COEFFICIENTS, COEFFICIENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolynomialCalibratorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolynomialCalibratorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PolynomialCalibrator<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PolynomialCalibrator<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PolynomialCalibrator");
      ds.field("COEFFICIENTS", &self.COEFFICIENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PolynomialCalibratorT {
  pub COEFFICIENTS: Option<Vec<f64>>,
}
impl Default for PolynomialCalibratorT {
  fn default() -> Self {
    Self {
      COEFFICIENTS: None,
    }
  }
}
impl PolynomialCalibratorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<PolynomialCalibrator<'b>> {
    let COEFFICIENTS = self.COEFFICIENTS.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    PolynomialCalibrator::create(_fbb, &PolynomialCalibratorArgs{
      COEFFICIENTS,
    })
  }
}
pub enum SplinePointOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Spline point for spline calibration
pub struct SplinePoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplinePoint<'a> {
  type Inner = SplinePoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SplinePoint<'a> {
  pub const VT_RAW: flatbuffers::VOffsetT = 4;
  pub const VT_CALIBRATED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplinePoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SplinePointArgs
  ) -> flatbuffers::WIPOffset<SplinePoint<'bldr>> {
    let mut builder = SplinePointBuilder::new(_fbb);
    builder.add_CALIBRATED(args.CALIBRATED);
    builder.add_RAW(args.RAW);
    builder.finish()
  }

  pub fn unpack(&self) -> SplinePointT {
    let RAW = self.RAW();
    let CALIBRATED = self.CALIBRATED();
    SplinePointT {
      RAW,
      CALIBRATED,
    }
  }

  /// Raw value
  #[inline]
  pub fn RAW(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SplinePoint::VT_RAW, Some(0.0)).unwrap()}
  }
  /// Calibrated/engineering value
  #[inline]
  pub fn CALIBRATED(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SplinePoint::VT_CALIBRATED, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SplinePoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("RAW", Self::VT_RAW, false)?
     .visit_field::<f64>("CALIBRATED", Self::VT_CALIBRATED, false)?
     .finish();
    Ok(())
  }
}
pub struct SplinePointArgs {
    pub RAW: f64,
    pub CALIBRATED: f64,
}
impl<'a> Default for SplinePointArgs {
  #[inline]
  fn default() -> Self {
    SplinePointArgs {
      RAW: 0.0,
      CALIBRATED: 0.0,
    }
  }
}

pub struct SplinePointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SplinePointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RAW(&mut self, RAW: f64) {
    self.fbb_.push_slot::<f64>(SplinePoint::VT_RAW, RAW, 0.0);
  }
  #[inline]
  pub fn add_CALIBRATED(&mut self, CALIBRATED: f64) {
    self.fbb_.push_slot::<f64>(SplinePoint::VT_CALIBRATED, CALIBRATED, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SplinePointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SplinePointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplinePoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplinePoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplinePoint");
      ds.field("RAW", &self.RAW());
      ds.field("CALIBRATED", &self.CALIBRATED());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SplinePointT {
  pub RAW: f64,
  pub CALIBRATED: f64,
}
impl Default for SplinePointT {
  fn default() -> Self {
    Self {
      RAW: 0.0,
      CALIBRATED: 0.0,
    }
  }
}
impl SplinePointT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SplinePoint<'b>> {
    let RAW = self.RAW;
    let CALIBRATED = self.CALIBRATED;
    SplinePoint::create(_fbb, &SplinePointArgs{
      RAW,
      CALIBRATED,
    })
  }
}
pub enum SplineCalibratorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Spline calibrator - piecewise linear interpolation
pub struct SplineCalibrator<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplineCalibrator<'a> {
  type Inner = SplineCalibrator<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SplineCalibrator<'a> {
  pub const VT_POINTS: flatbuffers::VOffsetT = 4;
  pub const VT_EXTRAPOLATE_LOW: flatbuffers::VOffsetT = 6;
  pub const VT_EXTRAPOLATE_HIGH: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplineCalibrator { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SplineCalibratorArgs<'args>
  ) -> flatbuffers::WIPOffset<SplineCalibrator<'bldr>> {
    let mut builder = SplineCalibratorBuilder::new(_fbb);
    if let Some(x) = args.POINTS { builder.add_POINTS(x); }
    builder.add_EXTRAPOLATE_HIGH(args.EXTRAPOLATE_HIGH);
    builder.add_EXTRAPOLATE_LOW(args.EXTRAPOLATE_LOW);
    builder.finish()
  }

  pub fn unpack(&self) -> SplineCalibratorT {
    let POINTS = self.POINTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let EXTRAPOLATE_LOW = self.EXTRAPOLATE_LOW();
    let EXTRAPOLATE_HIGH = self.EXTRAPOLATE_HIGH();
    SplineCalibratorT {
      POINTS,
      EXTRAPOLATE_LOW,
      EXTRAPOLATE_HIGH,
    }
  }

  /// Spline points ordered by raw value
  #[inline]
  pub fn POINTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SplinePoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SplinePoint>>>>(SplineCalibrator::VT_POINTS, None)}
  }
  /// Extrapolate below minimum point
  #[inline]
  pub fn EXTRAPOLATE_LOW(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SplineCalibrator::VT_EXTRAPOLATE_LOW, Some(false)).unwrap()}
  }
  /// Extrapolate above maximum point
  #[inline]
  pub fn EXTRAPOLATE_HIGH(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SplineCalibrator::VT_EXTRAPOLATE_HIGH, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SplineCalibrator<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SplinePoint>>>>("POINTS", Self::VT_POINTS, false)?
     .visit_field::<bool>("EXTRAPOLATE_LOW", Self::VT_EXTRAPOLATE_LOW, false)?
     .visit_field::<bool>("EXTRAPOLATE_HIGH", Self::VT_EXTRAPOLATE_HIGH, false)?
     .finish();
    Ok(())
  }
}
pub struct SplineCalibratorArgs<'a> {
    pub POINTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SplinePoint<'a>>>>>,
    pub EXTRAPOLATE_LOW: bool,
    pub EXTRAPOLATE_HIGH: bool,
}
impl<'a> Default for SplineCalibratorArgs<'a> {
  #[inline]
  fn default() -> Self {
    SplineCalibratorArgs {
      POINTS: None,
      EXTRAPOLATE_LOW: false,
      EXTRAPOLATE_HIGH: false,
    }
  }
}

pub struct SplineCalibratorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SplineCalibratorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_POINTS(&mut self, POINTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SplinePoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SplineCalibrator::VT_POINTS, POINTS);
  }
  #[inline]
  pub fn add_EXTRAPOLATE_LOW(&mut self, EXTRAPOLATE_LOW: bool) {
    self.fbb_.push_slot::<bool>(SplineCalibrator::VT_EXTRAPOLATE_LOW, EXTRAPOLATE_LOW, false);
  }
  #[inline]
  pub fn add_EXTRAPOLATE_HIGH(&mut self, EXTRAPOLATE_HIGH: bool) {
    self.fbb_.push_slot::<bool>(SplineCalibrator::VT_EXTRAPOLATE_HIGH, EXTRAPOLATE_HIGH, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SplineCalibratorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SplineCalibratorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplineCalibrator<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplineCalibrator<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplineCalibrator");
      ds.field("POINTS", &self.POINTS());
      ds.field("EXTRAPOLATE_LOW", &self.EXTRAPOLATE_LOW());
      ds.field("EXTRAPOLATE_HIGH", &self.EXTRAPOLATE_HIGH());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SplineCalibratorT {
  pub POINTS: Option<Vec<SplinePointT>>,
  pub EXTRAPOLATE_LOW: bool,
  pub EXTRAPOLATE_HIGH: bool,
}
impl Default for SplineCalibratorT {
  fn default() -> Self {
    Self {
      POINTS: None,
      EXTRAPOLATE_LOW: false,
      EXTRAPOLATE_HIGH: false,
    }
  }
}
impl SplineCalibratorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SplineCalibrator<'b>> {
    let POINTS = self.POINTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let EXTRAPOLATE_LOW = self.EXTRAPOLATE_LOW;
    let EXTRAPOLATE_HIGH = self.EXTRAPOLATE_HIGH;
    SplineCalibrator::create(_fbb, &SplineCalibratorArgs{
      POINTS,
      EXTRAPOLATE_LOW,
      EXTRAPOLATE_HIGH,
    })
  }
}
pub enum MathOperationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Mathematical operation for math operation calibrator
pub struct MathOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MathOperation<'a> {
  type Inner = MathOperation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MathOperation<'a> {
  pub const VT_RPN_EXPRESSION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MathOperation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MathOperationArgs<'args>
  ) -> flatbuffers::WIPOffset<MathOperation<'bldr>> {
    let mut builder = MathOperationBuilder::new(_fbb);
    if let Some(x) = args.RPN_EXPRESSION { builder.add_RPN_EXPRESSION(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MathOperationT {
    let RPN_EXPRESSION = self.RPN_EXPRESSION().map(|x| {
      x.to_string()
    });
    MathOperationT {
      RPN_EXPRESSION,
    }
  }

  /// Operation in Reverse Polish Notation (RPN)
  #[inline]
  pub fn RPN_EXPRESSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MathOperation::VT_RPN_EXPRESSION, None)}
  }
}

impl flatbuffers::Verifiable for MathOperation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RPN_EXPRESSION", Self::VT_RPN_EXPRESSION, false)?
     .finish();
    Ok(())
  }
}
pub struct MathOperationArgs<'a> {
    pub RPN_EXPRESSION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MathOperationArgs<'a> {
  #[inline]
  fn default() -> Self {
    MathOperationArgs {
      RPN_EXPRESSION: None,
    }
  }
}

pub struct MathOperationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MathOperationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_RPN_EXPRESSION(&mut self, RPN_EXPRESSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathOperation::VT_RPN_EXPRESSION, RPN_EXPRESSION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MathOperationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MathOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MathOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MathOperation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MathOperation");
      ds.field("RPN_EXPRESSION", &self.RPN_EXPRESSION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MathOperationT {
  pub RPN_EXPRESSION: Option<String>,
}
impl Default for MathOperationT {
  fn default() -> Self {
    Self {
      RPN_EXPRESSION: None,
    }
  }
}
impl MathOperationT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MathOperation<'b>> {
    let RPN_EXPRESSION = self.RPN_EXPRESSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MathOperation::create(_fbb, &MathOperationArgs{
      RPN_EXPRESSION,
    })
  }
}
pub enum ContextCalibratorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Context-dependent calibrator selection
pub struct ContextCalibrator<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContextCalibrator<'a> {
  type Inner = ContextCalibrator<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContextCalibrator<'a> {
  pub const VT_MATCH_CRITERIA: flatbuffers::VOffsetT = 4;
  pub const VT_POLYNOMIAL: flatbuffers::VOffsetT = 6;
  pub const VT_SPLINE: flatbuffers::VOffsetT = 8;
  pub const VT_MATH_OPERATION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContextCalibrator { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContextCalibratorArgs<'args>
  ) -> flatbuffers::WIPOffset<ContextCalibrator<'bldr>> {
    let mut builder = ContextCalibratorBuilder::new(_fbb);
    if let Some(x) = args.MATH_OPERATION { builder.add_MATH_OPERATION(x); }
    if let Some(x) = args.SPLINE { builder.add_SPLINE(x); }
    if let Some(x) = args.POLYNOMIAL { builder.add_POLYNOMIAL(x); }
    if let Some(x) = args.MATCH_CRITERIA { builder.add_MATCH_CRITERIA(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContextCalibratorT {
    let MATCH_CRITERIA = self.MATCH_CRITERIA().map(|x| {
      Box::new(x.unpack())
    });
    let POLYNOMIAL = self.POLYNOMIAL().map(|x| {
      Box::new(x.unpack())
    });
    let SPLINE = self.SPLINE().map(|x| {
      Box::new(x.unpack())
    });
    let MATH_OPERATION = self.MATH_OPERATION().map(|x| {
      Box::new(x.unpack())
    });
    ContextCalibratorT {
      MATCH_CRITERIA,
      POLYNOMIAL,
      SPLINE,
      MATH_OPERATION,
    }
  }

  /// Match criteria for selecting this calibrator
  #[inline]
  pub fn MATCH_CRITERIA(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(ContextCalibrator::VT_MATCH_CRITERIA, None)}
  }
  /// Polynomial calibrator (if used)
  #[inline]
  pub fn POLYNOMIAL(&self) -> Option<PolynomialCalibrator<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PolynomialCalibrator>>(ContextCalibrator::VT_POLYNOMIAL, None)}
  }
  /// Spline calibrator (if used)
  #[inline]
  pub fn SPLINE(&self) -> Option<SplineCalibrator<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SplineCalibrator>>(ContextCalibrator::VT_SPLINE, None)}
  }
  /// Math operation calibrator (if used)
  #[inline]
  pub fn MATH_OPERATION(&self) -> Option<MathOperation<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MathOperation>>(ContextCalibrator::VT_MATH_OPERATION, None)}
  }
}

impl flatbuffers::Verifiable for ContextCalibrator<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("MATCH_CRITERIA", Self::VT_MATCH_CRITERIA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PolynomialCalibrator>>("POLYNOMIAL", Self::VT_POLYNOMIAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SplineCalibrator>>("SPLINE", Self::VT_SPLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MathOperation>>("MATH_OPERATION", Self::VT_MATH_OPERATION, false)?
     .finish();
    Ok(())
  }
}
pub struct ContextCalibratorArgs<'a> {
    pub MATCH_CRITERIA: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
    pub POLYNOMIAL: Option<flatbuffers::WIPOffset<PolynomialCalibrator<'a>>>,
    pub SPLINE: Option<flatbuffers::WIPOffset<SplineCalibrator<'a>>>,
    pub MATH_OPERATION: Option<flatbuffers::WIPOffset<MathOperation<'a>>>,
}
impl<'a> Default for ContextCalibratorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContextCalibratorArgs {
      MATCH_CRITERIA: None,
      POLYNOMIAL: None,
      SPLINE: None,
      MATH_OPERATION: None,
    }
  }
}

pub struct ContextCalibratorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContextCalibratorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_MATCH_CRITERIA(&mut self, MATCH_CRITERIA: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(ContextCalibrator::VT_MATCH_CRITERIA, MATCH_CRITERIA);
  }
  #[inline]
  pub fn add_POLYNOMIAL(&mut self, POLYNOMIAL: flatbuffers::WIPOffset<PolynomialCalibrator<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PolynomialCalibrator>>(ContextCalibrator::VT_POLYNOMIAL, POLYNOMIAL);
  }
  #[inline]
  pub fn add_SPLINE(&mut self, SPLINE: flatbuffers::WIPOffset<SplineCalibrator<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SplineCalibrator>>(ContextCalibrator::VT_SPLINE, SPLINE);
  }
  #[inline]
  pub fn add_MATH_OPERATION(&mut self, MATH_OPERATION: flatbuffers::WIPOffset<MathOperation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MathOperation>>(ContextCalibrator::VT_MATH_OPERATION, MATH_OPERATION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContextCalibratorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContextCalibratorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContextCalibrator<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContextCalibrator<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContextCalibrator");
      ds.field("MATCH_CRITERIA", &self.MATCH_CRITERIA());
      ds.field("POLYNOMIAL", &self.POLYNOMIAL());
      ds.field("SPLINE", &self.SPLINE());
      ds.field("MATH_OPERATION", &self.MATH_OPERATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContextCalibratorT {
  pub MATCH_CRITERIA: Option<Box<MatchCriteriaT>>,
  pub POLYNOMIAL: Option<Box<PolynomialCalibratorT>>,
  pub SPLINE: Option<Box<SplineCalibratorT>>,
  pub MATH_OPERATION: Option<Box<MathOperationT>>,
}
impl Default for ContextCalibratorT {
  fn default() -> Self {
    Self {
      MATCH_CRITERIA: None,
      POLYNOMIAL: None,
      SPLINE: None,
      MATH_OPERATION: None,
    }
  }
}
impl ContextCalibratorT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContextCalibrator<'b>> {
    let MATCH_CRITERIA = self.MATCH_CRITERIA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let POLYNOMIAL = self.POLYNOMIAL.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SPLINE = self.SPLINE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let MATH_OPERATION = self.MATH_OPERATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    ContextCalibrator::create(_fbb, &ContextCalibratorArgs{
      MATCH_CRITERIA,
      POLYNOMIAL,
      SPLINE,
      MATH_OPERATION,
    })
  }
}
pub enum AlarmRangeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Numeric alarm range
pub struct AlarmRange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlarmRange<'a> {
  type Inner = AlarmRange<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlarmRange<'a> {
  pub const VT_MIN_INCLUSIVE: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_INCLUSIVE: flatbuffers::VOffsetT = 6;
  pub const VT_MIN_EXCLUSIVE: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_EXCLUSIVE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlarmRange { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlarmRangeArgs
  ) -> flatbuffers::WIPOffset<AlarmRange<'bldr>> {
    let mut builder = AlarmRangeBuilder::new(_fbb);
    builder.add_MAX_EXCLUSIVE(args.MAX_EXCLUSIVE);
    builder.add_MIN_EXCLUSIVE(args.MIN_EXCLUSIVE);
    builder.add_MAX_INCLUSIVE(args.MAX_INCLUSIVE);
    builder.add_MIN_INCLUSIVE(args.MIN_INCLUSIVE);
    builder.finish()
  }

  pub fn unpack(&self) -> AlarmRangeT {
    let MIN_INCLUSIVE = self.MIN_INCLUSIVE();
    let MAX_INCLUSIVE = self.MAX_INCLUSIVE();
    let MIN_EXCLUSIVE = self.MIN_EXCLUSIVE();
    let MAX_EXCLUSIVE = self.MAX_EXCLUSIVE();
    AlarmRangeT {
      MIN_INCLUSIVE,
      MAX_INCLUSIVE,
      MIN_EXCLUSIVE,
      MAX_EXCLUSIVE,
    }
  }

  /// Minimum value (inclusive)
  #[inline]
  pub fn MIN_INCLUSIVE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AlarmRange::VT_MIN_INCLUSIVE, Some(0.0)).unwrap()}
  }
  /// Maximum value (inclusive)
  #[inline]
  pub fn MAX_INCLUSIVE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AlarmRange::VT_MAX_INCLUSIVE, Some(0.0)).unwrap()}
  }
  /// Minimum value (exclusive)
  #[inline]
  pub fn MIN_EXCLUSIVE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AlarmRange::VT_MIN_EXCLUSIVE, Some(0.0)).unwrap()}
  }
  /// Maximum value (exclusive)
  #[inline]
  pub fn MAX_EXCLUSIVE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AlarmRange::VT_MAX_EXCLUSIVE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AlarmRange<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("MIN_INCLUSIVE", Self::VT_MIN_INCLUSIVE, false)?
     .visit_field::<f64>("MAX_INCLUSIVE", Self::VT_MAX_INCLUSIVE, false)?
     .visit_field::<f64>("MIN_EXCLUSIVE", Self::VT_MIN_EXCLUSIVE, false)?
     .visit_field::<f64>("MAX_EXCLUSIVE", Self::VT_MAX_EXCLUSIVE, false)?
     .finish();
    Ok(())
  }
}
pub struct AlarmRangeArgs {
    pub MIN_INCLUSIVE: f64,
    pub MAX_INCLUSIVE: f64,
    pub MIN_EXCLUSIVE: f64,
    pub MAX_EXCLUSIVE: f64,
}
impl<'a> Default for AlarmRangeArgs {
  #[inline]
  fn default() -> Self {
    AlarmRangeArgs {
      MIN_INCLUSIVE: 0.0,
      MAX_INCLUSIVE: 0.0,
      MIN_EXCLUSIVE: 0.0,
      MAX_EXCLUSIVE: 0.0,
    }
  }
}

pub struct AlarmRangeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlarmRangeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_MIN_INCLUSIVE(&mut self, MIN_INCLUSIVE: f64) {
    self.fbb_.push_slot::<f64>(AlarmRange::VT_MIN_INCLUSIVE, MIN_INCLUSIVE, 0.0);
  }
  #[inline]
  pub fn add_MAX_INCLUSIVE(&mut self, MAX_INCLUSIVE: f64) {
    self.fbb_.push_slot::<f64>(AlarmRange::VT_MAX_INCLUSIVE, MAX_INCLUSIVE, 0.0);
  }
  #[inline]
  pub fn add_MIN_EXCLUSIVE(&mut self, MIN_EXCLUSIVE: f64) {
    self.fbb_.push_slot::<f64>(AlarmRange::VT_MIN_EXCLUSIVE, MIN_EXCLUSIVE, 0.0);
  }
  #[inline]
  pub fn add_MAX_EXCLUSIVE(&mut self, MAX_EXCLUSIVE: f64) {
    self.fbb_.push_slot::<f64>(AlarmRange::VT_MAX_EXCLUSIVE, MAX_EXCLUSIVE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlarmRangeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlarmRangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlarmRange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlarmRange<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlarmRange");
      ds.field("MIN_INCLUSIVE", &self.MIN_INCLUSIVE());
      ds.field("MAX_INCLUSIVE", &self.MAX_INCLUSIVE());
      ds.field("MIN_EXCLUSIVE", &self.MIN_EXCLUSIVE());
      ds.field("MAX_EXCLUSIVE", &self.MAX_EXCLUSIVE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AlarmRangeT {
  pub MIN_INCLUSIVE: f64,
  pub MAX_INCLUSIVE: f64,
  pub MIN_EXCLUSIVE: f64,
  pub MAX_EXCLUSIVE: f64,
}
impl Default for AlarmRangeT {
  fn default() -> Self {
    Self {
      MIN_INCLUSIVE: 0.0,
      MAX_INCLUSIVE: 0.0,
      MIN_EXCLUSIVE: 0.0,
      MAX_EXCLUSIVE: 0.0,
    }
  }
}
impl AlarmRangeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AlarmRange<'b>> {
    let MIN_INCLUSIVE = self.MIN_INCLUSIVE;
    let MAX_INCLUSIVE = self.MAX_INCLUSIVE;
    let MIN_EXCLUSIVE = self.MIN_EXCLUSIVE;
    let MAX_EXCLUSIVE = self.MAX_EXCLUSIVE;
    AlarmRange::create(_fbb, &AlarmRangeArgs{
      MIN_INCLUSIVE,
      MAX_INCLUSIVE,
      MIN_EXCLUSIVE,
      MAX_EXCLUSIVE,
    })
  }
}
pub enum StaticAlarmRangesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Static numeric alarm levels
pub struct StaticAlarmRanges<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StaticAlarmRanges<'a> {
  type Inner = StaticAlarmRanges<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StaticAlarmRanges<'a> {
  pub const VT_WATCH_RANGE: flatbuffers::VOffsetT = 4;
  pub const VT_WARNING_RANGE: flatbuffers::VOffsetT = 6;
  pub const VT_DISTRESS_RANGE: flatbuffers::VOffsetT = 8;
  pub const VT_CRITICAL_RANGE: flatbuffers::VOffsetT = 10;
  pub const VT_SEVERE_RANGE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StaticAlarmRanges { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StaticAlarmRangesArgs<'args>
  ) -> flatbuffers::WIPOffset<StaticAlarmRanges<'bldr>> {
    let mut builder = StaticAlarmRangesBuilder::new(_fbb);
    if let Some(x) = args.SEVERE_RANGE { builder.add_SEVERE_RANGE(x); }
    if let Some(x) = args.CRITICAL_RANGE { builder.add_CRITICAL_RANGE(x); }
    if let Some(x) = args.DISTRESS_RANGE { builder.add_DISTRESS_RANGE(x); }
    if let Some(x) = args.WARNING_RANGE { builder.add_WARNING_RANGE(x); }
    if let Some(x) = args.WATCH_RANGE { builder.add_WATCH_RANGE(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StaticAlarmRangesT {
    let WATCH_RANGE = self.WATCH_RANGE().map(|x| {
      Box::new(x.unpack())
    });
    let WARNING_RANGE = self.WARNING_RANGE().map(|x| {
      Box::new(x.unpack())
    });
    let DISTRESS_RANGE = self.DISTRESS_RANGE().map(|x| {
      Box::new(x.unpack())
    });
    let CRITICAL_RANGE = self.CRITICAL_RANGE().map(|x| {
      Box::new(x.unpack())
    });
    let SEVERE_RANGE = self.SEVERE_RANGE().map(|x| {
      Box::new(x.unpack())
    });
    StaticAlarmRangesT {
      WATCH_RANGE,
      WARNING_RANGE,
      DISTRESS_RANGE,
      CRITICAL_RANGE,
      SEVERE_RANGE,
    }
  }

  /// Watch range
  #[inline]
  pub fn WATCH_RANGE(&self) -> Option<AlarmRange<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlarmRange>>(StaticAlarmRanges::VT_WATCH_RANGE, None)}
  }
  /// Warning range
  #[inline]
  pub fn WARNING_RANGE(&self) -> Option<AlarmRange<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlarmRange>>(StaticAlarmRanges::VT_WARNING_RANGE, None)}
  }
  /// Distress range
  #[inline]
  pub fn DISTRESS_RANGE(&self) -> Option<AlarmRange<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlarmRange>>(StaticAlarmRanges::VT_DISTRESS_RANGE, None)}
  }
  /// Critical range
  #[inline]
  pub fn CRITICAL_RANGE(&self) -> Option<AlarmRange<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlarmRange>>(StaticAlarmRanges::VT_CRITICAL_RANGE, None)}
  }
  /// Severe range
  #[inline]
  pub fn SEVERE_RANGE(&self) -> Option<AlarmRange<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlarmRange>>(StaticAlarmRanges::VT_SEVERE_RANGE, None)}
  }
}

impl flatbuffers::Verifiable for StaticAlarmRanges<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlarmRange>>("WATCH_RANGE", Self::VT_WATCH_RANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlarmRange>>("WARNING_RANGE", Self::VT_WARNING_RANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlarmRange>>("DISTRESS_RANGE", Self::VT_DISTRESS_RANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlarmRange>>("CRITICAL_RANGE", Self::VT_CRITICAL_RANGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlarmRange>>("SEVERE_RANGE", Self::VT_SEVERE_RANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct StaticAlarmRangesArgs<'a> {
    pub WATCH_RANGE: Option<flatbuffers::WIPOffset<AlarmRange<'a>>>,
    pub WARNING_RANGE: Option<flatbuffers::WIPOffset<AlarmRange<'a>>>,
    pub DISTRESS_RANGE: Option<flatbuffers::WIPOffset<AlarmRange<'a>>>,
    pub CRITICAL_RANGE: Option<flatbuffers::WIPOffset<AlarmRange<'a>>>,
    pub SEVERE_RANGE: Option<flatbuffers::WIPOffset<AlarmRange<'a>>>,
}
impl<'a> Default for StaticAlarmRangesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StaticAlarmRangesArgs {
      WATCH_RANGE: None,
      WARNING_RANGE: None,
      DISTRESS_RANGE: None,
      CRITICAL_RANGE: None,
      SEVERE_RANGE: None,
    }
  }
}

pub struct StaticAlarmRangesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StaticAlarmRangesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_WATCH_RANGE(&mut self, WATCH_RANGE: flatbuffers::WIPOffset<AlarmRange<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlarmRange>>(StaticAlarmRanges::VT_WATCH_RANGE, WATCH_RANGE);
  }
  #[inline]
  pub fn add_WARNING_RANGE(&mut self, WARNING_RANGE: flatbuffers::WIPOffset<AlarmRange<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlarmRange>>(StaticAlarmRanges::VT_WARNING_RANGE, WARNING_RANGE);
  }
  #[inline]
  pub fn add_DISTRESS_RANGE(&mut self, DISTRESS_RANGE: flatbuffers::WIPOffset<AlarmRange<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlarmRange>>(StaticAlarmRanges::VT_DISTRESS_RANGE, DISTRESS_RANGE);
  }
  #[inline]
  pub fn add_CRITICAL_RANGE(&mut self, CRITICAL_RANGE: flatbuffers::WIPOffset<AlarmRange<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlarmRange>>(StaticAlarmRanges::VT_CRITICAL_RANGE, CRITICAL_RANGE);
  }
  #[inline]
  pub fn add_SEVERE_RANGE(&mut self, SEVERE_RANGE: flatbuffers::WIPOffset<AlarmRange<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlarmRange>>(StaticAlarmRanges::VT_SEVERE_RANGE, SEVERE_RANGE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StaticAlarmRangesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StaticAlarmRangesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StaticAlarmRanges<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StaticAlarmRanges<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StaticAlarmRanges");
      ds.field("WATCH_RANGE", &self.WATCH_RANGE());
      ds.field("WARNING_RANGE", &self.WARNING_RANGE());
      ds.field("DISTRESS_RANGE", &self.DISTRESS_RANGE());
      ds.field("CRITICAL_RANGE", &self.CRITICAL_RANGE());
      ds.field("SEVERE_RANGE", &self.SEVERE_RANGE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StaticAlarmRangesT {
  pub WATCH_RANGE: Option<Box<AlarmRangeT>>,
  pub WARNING_RANGE: Option<Box<AlarmRangeT>>,
  pub DISTRESS_RANGE: Option<Box<AlarmRangeT>>,
  pub CRITICAL_RANGE: Option<Box<AlarmRangeT>>,
  pub SEVERE_RANGE: Option<Box<AlarmRangeT>>,
}
impl Default for StaticAlarmRangesT {
  fn default() -> Self {
    Self {
      WATCH_RANGE: None,
      WARNING_RANGE: None,
      DISTRESS_RANGE: None,
      CRITICAL_RANGE: None,
      SEVERE_RANGE: None,
    }
  }
}
impl StaticAlarmRangesT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StaticAlarmRanges<'b>> {
    let WATCH_RANGE = self.WATCH_RANGE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let WARNING_RANGE = self.WARNING_RANGE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DISTRESS_RANGE = self.DISTRESS_RANGE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CRITICAL_RANGE = self.CRITICAL_RANGE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SEVERE_RANGE = self.SEVERE_RANGE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    StaticAlarmRanges::create(_fbb, &StaticAlarmRangesArgs{
      WATCH_RANGE,
      WARNING_RANGE,
      DISTRESS_RANGE,
      CRITICAL_RANGE,
      SEVERE_RANGE,
    })
  }
}
pub enum EnumerationAlarmOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Enumerated alarm
pub struct EnumerationAlarm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumerationAlarm<'a> {
  type Inner = EnumerationAlarm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EnumerationAlarm<'a> {
  pub const VT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_ALARM_LEVEL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnumerationAlarm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumerationAlarmArgs<'args>
  ) -> flatbuffers::WIPOffset<EnumerationAlarm<'bldr>> {
    let mut builder = EnumerationAlarmBuilder::new(_fbb);
    if let Some(x) = args.LABEL { builder.add_LABEL(x); }
    builder.add_ALARM_LEVEL(args.ALARM_LEVEL);
    builder.finish()
  }

  pub fn unpack(&self) -> EnumerationAlarmT {
    let LABEL = self.LABEL().map(|x| {
      x.to_string()
    });
    let ALARM_LEVEL = self.ALARM_LEVEL();
    EnumerationAlarmT {
      LABEL,
      ALARM_LEVEL,
    }
  }

  /// Enumerated value label
  #[inline]
  pub fn LABEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumerationAlarm::VT_LABEL, None)}
  }
  /// Alarm level for this value
  #[inline]
  pub fn ALARM_LEVEL(&self) -> AlarmSeverityType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AlarmSeverityType>(EnumerationAlarm::VT_ALARM_LEVEL, Some(AlarmSeverityType::NORMAL)).unwrap()}
  }
}

impl flatbuffers::Verifiable for EnumerationAlarm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LABEL", Self::VT_LABEL, false)?
     .visit_field::<AlarmSeverityType>("ALARM_LEVEL", Self::VT_ALARM_LEVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumerationAlarmArgs<'a> {
    pub LABEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALARM_LEVEL: AlarmSeverityType,
}
impl<'a> Default for EnumerationAlarmArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumerationAlarmArgs {
      LABEL: None,
      ALARM_LEVEL: AlarmSeverityType::NORMAL,
    }
  }
}

pub struct EnumerationAlarmBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumerationAlarmBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LABEL(&mut self, LABEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumerationAlarm::VT_LABEL, LABEL);
  }
  #[inline]
  pub fn add_ALARM_LEVEL(&mut self, ALARM_LEVEL: AlarmSeverityType) {
    self.fbb_.push_slot::<AlarmSeverityType>(EnumerationAlarm::VT_ALARM_LEVEL, ALARM_LEVEL, AlarmSeverityType::NORMAL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumerationAlarmBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumerationAlarmBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumerationAlarm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnumerationAlarm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnumerationAlarm");
      ds.field("LABEL", &self.LABEL());
      ds.field("ALARM_LEVEL", &self.ALARM_LEVEL());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EnumerationAlarmT {
  pub LABEL: Option<String>,
  pub ALARM_LEVEL: AlarmSeverityType,
}
impl Default for EnumerationAlarmT {
  fn default() -> Self {
    Self {
      LABEL: None,
      ALARM_LEVEL: AlarmSeverityType::NORMAL,
    }
  }
}
impl EnumerationAlarmT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EnumerationAlarm<'b>> {
    let LABEL = self.LABEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALARM_LEVEL = self.ALARM_LEVEL;
    EnumerationAlarm::create(_fbb, &EnumerationAlarmArgs{
      LABEL,
      ALARM_LEVEL,
    })
  }
}
pub enum DefaultAlarmOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Default alarm definition
pub struct DefaultAlarm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DefaultAlarm<'a> {
  type Inner = DefaultAlarm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DefaultAlarm<'a> {
  pub const VT_MIN_VIOLATIONS: flatbuffers::VOffsetT = 4;
  pub const VT_STATIC_ALARM_RANGES: flatbuffers::VOffsetT = 6;
  pub const VT_ENUMERATION_ALARMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DefaultAlarm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DefaultAlarmArgs<'args>
  ) -> flatbuffers::WIPOffset<DefaultAlarm<'bldr>> {
    let mut builder = DefaultAlarmBuilder::new(_fbb);
    if let Some(x) = args.ENUMERATION_ALARMS { builder.add_ENUMERATION_ALARMS(x); }
    if let Some(x) = args.STATIC_ALARM_RANGES { builder.add_STATIC_ALARM_RANGES(x); }
    builder.add_MIN_VIOLATIONS(args.MIN_VIOLATIONS);
    builder.finish()
  }

  pub fn unpack(&self) -> DefaultAlarmT {
    let MIN_VIOLATIONS = self.MIN_VIOLATIONS();
    let STATIC_ALARM_RANGES = self.STATIC_ALARM_RANGES().map(|x| {
      Box::new(x.unpack())
    });
    let ENUMERATION_ALARMS = self.ENUMERATION_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    DefaultAlarmT {
      MIN_VIOLATIONS,
      STATIC_ALARM_RANGES,
      ENUMERATION_ALARMS,
    }
  }

  /// Minimum violations before alarm triggers
  #[inline]
  pub fn MIN_VIOLATIONS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(DefaultAlarm::VT_MIN_VIOLATIONS, Some(0)).unwrap()}
  }
  /// Static numeric alarm ranges
  #[inline]
  pub fn STATIC_ALARM_RANGES(&self) -> Option<StaticAlarmRanges<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StaticAlarmRanges>>(DefaultAlarm::VT_STATIC_ALARM_RANGES, None)}
  }
  /// Enumeration alarms for enumerated types
  #[inline]
  pub fn ENUMERATION_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationAlarm>>>>(DefaultAlarm::VT_ENUMERATION_ALARMS, None)}
  }
}

impl flatbuffers::Verifiable for DefaultAlarm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("MIN_VIOLATIONS", Self::VT_MIN_VIOLATIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StaticAlarmRanges>>("STATIC_ALARM_RANGES", Self::VT_STATIC_ALARM_RANGES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumerationAlarm>>>>("ENUMERATION_ALARMS", Self::VT_ENUMERATION_ALARMS, false)?
     .finish();
    Ok(())
  }
}
pub struct DefaultAlarmArgs<'a> {
    pub MIN_VIOLATIONS: u16,
    pub STATIC_ALARM_RANGES: Option<flatbuffers::WIPOffset<StaticAlarmRanges<'a>>>,
    pub ENUMERATION_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationAlarm<'a>>>>>,
}
impl<'a> Default for DefaultAlarmArgs<'a> {
  #[inline]
  fn default() -> Self {
    DefaultAlarmArgs {
      MIN_VIOLATIONS: 0,
      STATIC_ALARM_RANGES: None,
      ENUMERATION_ALARMS: None,
    }
  }
}

pub struct DefaultAlarmBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DefaultAlarmBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_MIN_VIOLATIONS(&mut self, MIN_VIOLATIONS: u16) {
    self.fbb_.push_slot::<u16>(DefaultAlarm::VT_MIN_VIOLATIONS, MIN_VIOLATIONS, 0);
  }
  #[inline]
  pub fn add_STATIC_ALARM_RANGES(&mut self, STATIC_ALARM_RANGES: flatbuffers::WIPOffset<StaticAlarmRanges<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StaticAlarmRanges>>(DefaultAlarm::VT_STATIC_ALARM_RANGES, STATIC_ALARM_RANGES);
  }
  #[inline]
  pub fn add_ENUMERATION_ALARMS(&mut self, ENUMERATION_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumerationAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DefaultAlarm::VT_ENUMERATION_ALARMS, ENUMERATION_ALARMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DefaultAlarmBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DefaultAlarmBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DefaultAlarm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DefaultAlarm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DefaultAlarm");
      ds.field("MIN_VIOLATIONS", &self.MIN_VIOLATIONS());
      ds.field("STATIC_ALARM_RANGES", &self.STATIC_ALARM_RANGES());
      ds.field("ENUMERATION_ALARMS", &self.ENUMERATION_ALARMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DefaultAlarmT {
  pub MIN_VIOLATIONS: u16,
  pub STATIC_ALARM_RANGES: Option<Box<StaticAlarmRangesT>>,
  pub ENUMERATION_ALARMS: Option<Vec<EnumerationAlarmT>>,
}
impl Default for DefaultAlarmT {
  fn default() -> Self {
    Self {
      MIN_VIOLATIONS: 0,
      STATIC_ALARM_RANGES: None,
      ENUMERATION_ALARMS: None,
    }
  }
}
impl DefaultAlarmT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DefaultAlarm<'b>> {
    let MIN_VIOLATIONS = self.MIN_VIOLATIONS;
    let STATIC_ALARM_RANGES = self.STATIC_ALARM_RANGES.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ENUMERATION_ALARMS = self.ENUMERATION_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    DefaultAlarm::create(_fbb, &DefaultAlarmArgs{
      MIN_VIOLATIONS,
      STATIC_ALARM_RANGES,
      ENUMERATION_ALARMS,
    })
  }
}
pub enum ContextAlarmOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Context-dependent alarm
pub struct ContextAlarm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContextAlarm<'a> {
  type Inner = ContextAlarm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContextAlarm<'a> {
  pub const VT_MATCH_CRITERIA: flatbuffers::VOffsetT = 4;
  pub const VT_ALARM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContextAlarm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContextAlarmArgs<'args>
  ) -> flatbuffers::WIPOffset<ContextAlarm<'bldr>> {
    let mut builder = ContextAlarmBuilder::new(_fbb);
    if let Some(x) = args.ALARM { builder.add_ALARM(x); }
    if let Some(x) = args.MATCH_CRITERIA { builder.add_MATCH_CRITERIA(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContextAlarmT {
    let MATCH_CRITERIA = self.MATCH_CRITERIA().map(|x| {
      Box::new(x.unpack())
    });
    let ALARM = self.ALARM().map(|x| {
      Box::new(x.unpack())
    });
    ContextAlarmT {
      MATCH_CRITERIA,
      ALARM,
    }
  }

  /// Match criteria for this alarm context
  #[inline]
  pub fn MATCH_CRITERIA(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(ContextAlarm::VT_MATCH_CRITERIA, None)}
  }
  /// Alarm definition for this context
  #[inline]
  pub fn ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(ContextAlarm::VT_ALARM, None)}
  }
}

impl flatbuffers::Verifiable for ContextAlarm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("MATCH_CRITERIA", Self::VT_MATCH_CRITERIA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("ALARM", Self::VT_ALARM, false)?
     .finish();
    Ok(())
  }
}
pub struct ContextAlarmArgs<'a> {
    pub MATCH_CRITERIA: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
    pub ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
}
impl<'a> Default for ContextAlarmArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContextAlarmArgs {
      MATCH_CRITERIA: None,
      ALARM: None,
    }
  }
}

pub struct ContextAlarmBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContextAlarmBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_MATCH_CRITERIA(&mut self, MATCH_CRITERIA: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(ContextAlarm::VT_MATCH_CRITERIA, MATCH_CRITERIA);
  }
  #[inline]
  pub fn add_ALARM(&mut self, ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(ContextAlarm::VT_ALARM, ALARM);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContextAlarmBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContextAlarmBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContextAlarm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContextAlarm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContextAlarm");
      ds.field("MATCH_CRITERIA", &self.MATCH_CRITERIA());
      ds.field("ALARM", &self.ALARM());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContextAlarmT {
  pub MATCH_CRITERIA: Option<Box<MatchCriteriaT>>,
  pub ALARM: Option<Box<DefaultAlarmT>>,
}
impl Default for ContextAlarmT {
  fn default() -> Self {
    Self {
      MATCH_CRITERIA: None,
      ALARM: None,
    }
  }
}
impl ContextAlarmT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContextAlarm<'b>> {
    let MATCH_CRITERIA = self.MATCH_CRITERIA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ALARM = self.ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    ContextAlarm::create(_fbb, &ContextAlarmArgs{
      MATCH_CRITERIA,
      ALARM,
    })
  }
}
pub enum ParameterComparisonOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Parameter comparison for match criteria
pub struct ParameterComparison<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParameterComparison<'a> {
  type Inner = ParameterComparison<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParameterComparison<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATOR: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_USE_CALIBRATED_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParameterComparison { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterComparisonArgs<'args>
  ) -> flatbuffers::WIPOffset<ParameterComparison<'bldr>> {
    let mut builder = ParameterComparisonBuilder::new(_fbb);
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.add_USE_CALIBRATED_VALUE(args.USE_CALIBRATED_VALUE);
    builder.add_OPERATOR(args.OPERATOR);
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterComparisonT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let OPERATOR = self.OPERATOR();
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    let USE_CALIBRATED_VALUE = self.USE_CALIBRATED_VALUE();
    ParameterComparisonT {
      PARAMETER_REF,
      OPERATOR,
      VALUE,
      USE_CALIBRATED_VALUE,
    }
  }

  /// Parameter reference path
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParameterComparison::VT_PARAMETER_REF, None)}
  }
  /// Comparison operator
  #[inline]
  pub fn OPERATOR(&self) -> ComparisonOperator {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComparisonOperator>(ParameterComparison::VT_OPERATOR, Some(ComparisonOperator::EQ)).unwrap()}
  }
  /// Value to compare against
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParameterComparison::VT_VALUE, None)}
  }
  /// Use calibrated value (true) or raw value (false)
  #[inline]
  pub fn USE_CALIBRATED_VALUE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ParameterComparison::VT_USE_CALIBRATED_VALUE, Some(true)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ParameterComparison<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<ComparisonOperator>("OPERATOR", Self::VT_OPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .visit_field::<bool>("USE_CALIBRATED_VALUE", Self::VT_USE_CALIBRATED_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterComparisonArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPERATOR: ComparisonOperator,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub USE_CALIBRATED_VALUE: bool,
}
impl<'a> Default for ParameterComparisonArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterComparisonArgs {
      PARAMETER_REF: None,
      OPERATOR: ComparisonOperator::EQ,
      VALUE: None,
      USE_CALIBRATED_VALUE: true,
    }
  }
}

pub struct ParameterComparisonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterComparisonBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterComparison::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_OPERATOR(&mut self, OPERATOR: ComparisonOperator) {
    self.fbb_.push_slot::<ComparisonOperator>(ParameterComparison::VT_OPERATOR, OPERATOR, ComparisonOperator::EQ);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterComparison::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn add_USE_CALIBRATED_VALUE(&mut self, USE_CALIBRATED_VALUE: bool) {
    self.fbb_.push_slot::<bool>(ParameterComparison::VT_USE_CALIBRATED_VALUE, USE_CALIBRATED_VALUE, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterComparisonBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterComparisonBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParameterComparison<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParameterComparison<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParameterComparison");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("OPERATOR", &self.OPERATOR());
      ds.field("VALUE", &self.VALUE());
      ds.field("USE_CALIBRATED_VALUE", &self.USE_CALIBRATED_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterComparisonT {
  pub PARAMETER_REF: Option<String>,
  pub OPERATOR: ComparisonOperator,
  pub VALUE: Option<String>,
  pub USE_CALIBRATED_VALUE: bool,
}
impl Default for ParameterComparisonT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      OPERATOR: ComparisonOperator::EQ,
      VALUE: None,
      USE_CALIBRATED_VALUE: true,
    }
  }
}
impl ParameterComparisonT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParameterComparison<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPERATOR = self.OPERATOR;
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let USE_CALIBRATED_VALUE = self.USE_CALIBRATED_VALUE;
    ParameterComparison::create(_fbb, &ParameterComparisonArgs{
      PARAMETER_REF,
      OPERATOR,
      VALUE,
      USE_CALIBRATED_VALUE,
    })
  }
}
pub enum BooleanExpressionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Boolean expression combining comparisons
pub struct BooleanExpression<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BooleanExpression<'a> {
  type Inner = BooleanExpression<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BooleanExpression<'a> {
  pub const VT_OPERATOR: flatbuffers::VOffsetT = 4;
  pub const VT_CONDITIONS: flatbuffers::VOffsetT = 6;
  pub const VT_EXPRESSIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BooleanExpression { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BooleanExpressionArgs<'args>
  ) -> flatbuffers::WIPOffset<BooleanExpression<'bldr>> {
    let mut builder = BooleanExpressionBuilder::new(_fbb);
    if let Some(x) = args.EXPRESSIONS { builder.add_EXPRESSIONS(x); }
    if let Some(x) = args.CONDITIONS { builder.add_CONDITIONS(x); }
    builder.add_OPERATOR(args.OPERATOR);
    builder.finish()
  }

  pub fn unpack(&self) -> BooleanExpressionT {
    let OPERATOR = self.OPERATOR();
    let CONDITIONS = self.CONDITIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let EXPRESSIONS = self.EXPRESSIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    BooleanExpressionT {
      OPERATOR,
      CONDITIONS,
      EXPRESSIONS,
    }
  }

  /// Boolean operator
  #[inline]
  pub fn OPERATOR(&self) -> BooleanOperatorType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BooleanOperatorType>(BooleanExpression::VT_OPERATOR, Some(BooleanOperatorType::AND)).unwrap()}
  }
  /// Comparison conditions
  #[inline]
  pub fn CONDITIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison>>>>(BooleanExpression::VT_CONDITIONS, None)}
  }
  /// Nested expressions
  #[inline]
  pub fn EXPRESSIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanExpression<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanExpression>>>>(BooleanExpression::VT_EXPRESSIONS, None)}
  }
}

impl flatbuffers::Verifiable for BooleanExpression<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<BooleanOperatorType>("OPERATOR", Self::VT_OPERATOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ParameterComparison>>>>("CONDITIONS", Self::VT_CONDITIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BooleanExpression>>>>("EXPRESSIONS", Self::VT_EXPRESSIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct BooleanExpressionArgs<'a> {
    pub OPERATOR: BooleanOperatorType,
    pub CONDITIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison<'a>>>>>,
    pub EXPRESSIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanExpression<'a>>>>>,
}
impl<'a> Default for BooleanExpressionArgs<'a> {
  #[inline]
  fn default() -> Self {
    BooleanExpressionArgs {
      OPERATOR: BooleanOperatorType::AND,
      CONDITIONS: None,
      EXPRESSIONS: None,
    }
  }
}

pub struct BooleanExpressionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BooleanExpressionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_OPERATOR(&mut self, OPERATOR: BooleanOperatorType) {
    self.fbb_.push_slot::<BooleanOperatorType>(BooleanExpression::VT_OPERATOR, OPERATOR, BooleanOperatorType::AND);
  }
  #[inline]
  pub fn add_CONDITIONS(&mut self, CONDITIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ParameterComparison<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanExpression::VT_CONDITIONS, CONDITIONS);
  }
  #[inline]
  pub fn add_EXPRESSIONS(&mut self, EXPRESSIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BooleanExpression<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanExpression::VT_EXPRESSIONS, EXPRESSIONS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BooleanExpressionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BooleanExpressionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BooleanExpression<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BooleanExpression<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BooleanExpression");
      ds.field("OPERATOR", &self.OPERATOR());
      ds.field("CONDITIONS", &self.CONDITIONS());
      ds.field("EXPRESSIONS", &self.EXPRESSIONS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BooleanExpressionT {
  pub OPERATOR: BooleanOperatorType,
  pub CONDITIONS: Option<Vec<ParameterComparisonT>>,
  pub EXPRESSIONS: Option<Vec<BooleanExpressionT>>,
}
impl Default for BooleanExpressionT {
  fn default() -> Self {
    Self {
      OPERATOR: BooleanOperatorType::AND,
      CONDITIONS: None,
      EXPRESSIONS: None,
    }
  }
}
impl BooleanExpressionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BooleanExpression<'b>> {
    let OPERATOR = self.OPERATOR;
    let CONDITIONS = self.CONDITIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let EXPRESSIONS = self.EXPRESSIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    BooleanExpression::create(_fbb, &BooleanExpressionArgs{
      OPERATOR,
      CONDITIONS,
      EXPRESSIONS,
    })
  }
}
pub enum MatchCriteriaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Match criteria for conditional logic
pub struct MatchCriteria<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchCriteria<'a> {
  type Inner = MatchCriteria<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchCriteria<'a> {
  pub const VT_COMPARISON: flatbuffers::VOffsetT = 4;
  pub const VT_COMPARISON_LIST: flatbuffers::VOffsetT = 6;
  pub const VT_BOOLEAN_EXPRESSION: flatbuffers::VOffsetT = 8;
  pub const VT_CUSTOM_ALGORITHM: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchCriteria { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MatchCriteriaArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchCriteria<'bldr>> {
    let mut builder = MatchCriteriaBuilder::new(_fbb);
    if let Some(x) = args.CUSTOM_ALGORITHM { builder.add_CUSTOM_ALGORITHM(x); }
    if let Some(x) = args.BOOLEAN_EXPRESSION { builder.add_BOOLEAN_EXPRESSION(x); }
    if let Some(x) = args.COMPARISON_LIST { builder.add_COMPARISON_LIST(x); }
    if let Some(x) = args.COMPARISON { builder.add_COMPARISON(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MatchCriteriaT {
    let COMPARISON = self.COMPARISON().map(|x| {
      Box::new(x.unpack())
    });
    let COMPARISON_LIST = self.COMPARISON_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BOOLEAN_EXPRESSION = self.BOOLEAN_EXPRESSION().map(|x| {
      Box::new(x.unpack())
    });
    let CUSTOM_ALGORITHM = self.CUSTOM_ALGORITHM().map(|x| {
      x.to_string()
    });
    MatchCriteriaT {
      COMPARISON,
      COMPARISON_LIST,
      BOOLEAN_EXPRESSION,
      CUSTOM_ALGORITHM,
    }
  }

  /// Single comparison
  #[inline]
  pub fn COMPARISON(&self) -> Option<ParameterComparison<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterComparison>>(MatchCriteria::VT_COMPARISON, None)}
  }
  /// List of comparisons (implicit AND)
  #[inline]
  pub fn COMPARISON_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison>>>>(MatchCriteria::VT_COMPARISON_LIST, None)}
  }
  /// Boolean expression
  #[inline]
  pub fn BOOLEAN_EXPRESSION(&self) -> Option<BooleanExpression<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BooleanExpression>>(MatchCriteria::VT_BOOLEAN_EXPRESSION, None)}
  }
  /// Custom algorithm reference
  #[inline]
  pub fn CUSTOM_ALGORITHM(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MatchCriteria::VT_CUSTOM_ALGORITHM, None)}
  }
}

impl flatbuffers::Verifiable for MatchCriteria<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterComparison>>("COMPARISON", Self::VT_COMPARISON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ParameterComparison>>>>("COMPARISON_LIST", Self::VT_COMPARISON_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BooleanExpression>>("BOOLEAN_EXPRESSION", Self::VT_BOOLEAN_EXPRESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CUSTOM_ALGORITHM", Self::VT_CUSTOM_ALGORITHM, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchCriteriaArgs<'a> {
    pub COMPARISON: Option<flatbuffers::WIPOffset<ParameterComparison<'a>>>,
    pub COMPARISON_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ParameterComparison<'a>>>>>,
    pub BOOLEAN_EXPRESSION: Option<flatbuffers::WIPOffset<BooleanExpression<'a>>>,
    pub CUSTOM_ALGORITHM: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MatchCriteriaArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchCriteriaArgs {
      COMPARISON: None,
      COMPARISON_LIST: None,
      BOOLEAN_EXPRESSION: None,
      CUSTOM_ALGORITHM: None,
    }
  }
}

pub struct MatchCriteriaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MatchCriteriaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMPARISON(&mut self, COMPARISON: flatbuffers::WIPOffset<ParameterComparison<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterComparison>>(MatchCriteria::VT_COMPARISON, COMPARISON);
  }
  #[inline]
  pub fn add_COMPARISON_LIST(&mut self, COMPARISON_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ParameterComparison<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchCriteria::VT_COMPARISON_LIST, COMPARISON_LIST);
  }
  #[inline]
  pub fn add_BOOLEAN_EXPRESSION(&mut self, BOOLEAN_EXPRESSION: flatbuffers::WIPOffset<BooleanExpression<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BooleanExpression>>(MatchCriteria::VT_BOOLEAN_EXPRESSION, BOOLEAN_EXPRESSION);
  }
  #[inline]
  pub fn add_CUSTOM_ALGORITHM(&mut self, CUSTOM_ALGORITHM: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchCriteria::VT_CUSTOM_ALGORITHM, CUSTOM_ALGORITHM);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MatchCriteriaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MatchCriteriaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchCriteria<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchCriteria<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchCriteria");
      ds.field("COMPARISON", &self.COMPARISON());
      ds.field("COMPARISON_LIST", &self.COMPARISON_LIST());
      ds.field("BOOLEAN_EXPRESSION", &self.BOOLEAN_EXPRESSION());
      ds.field("CUSTOM_ALGORITHM", &self.CUSTOM_ALGORITHM());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MatchCriteriaT {
  pub COMPARISON: Option<Box<ParameterComparisonT>>,
  pub COMPARISON_LIST: Option<Vec<ParameterComparisonT>>,
  pub BOOLEAN_EXPRESSION: Option<Box<BooleanExpressionT>>,
  pub CUSTOM_ALGORITHM: Option<String>,
}
impl Default for MatchCriteriaT {
  fn default() -> Self {
    Self {
      COMPARISON: None,
      COMPARISON_LIST: None,
      BOOLEAN_EXPRESSION: None,
      CUSTOM_ALGORITHM: None,
    }
  }
}
impl MatchCriteriaT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MatchCriteria<'b>> {
    let COMPARISON = self.COMPARISON.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let COMPARISON_LIST = self.COMPARISON_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BOOLEAN_EXPRESSION = self.BOOLEAN_EXPRESSION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CUSTOM_ALGORITHM = self.CUSTOM_ALGORITHM.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    MatchCriteria::create(_fbb, &MatchCriteriaArgs{
      COMPARISON,
      COMPARISON_LIST,
      BOOLEAN_EXPRESSION,
      CUSTOM_ALGORITHM,
    })
  }
}
pub enum UnitOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Unit specification
pub struct Unit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unit<'a> {
  type Inner = Unit<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Unit<'a> {
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 4;
  pub const VT_SYMBOL: flatbuffers::VOffsetT = 6;
  pub const VT_POWER: flatbuffers::VOffsetT = 8;
  pub const VT_FACTOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unit { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnitArgs<'args>
  ) -> flatbuffers::WIPOffset<Unit<'bldr>> {
    let mut builder = UnitBuilder::new(_fbb);
    builder.add_FACTOR(args.FACTOR);
    builder.add_POWER(args.POWER);
    if let Some(x) = args.SYMBOL { builder.add_SYMBOL(x); }
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> UnitT {
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    let SYMBOL = self.SYMBOL().map(|x| {
      x.to_string()
    });
    let POWER = self.POWER();
    let FACTOR = self.FACTOR();
    UnitT {
      DESCRIPTION,
      SYMBOL,
      POWER,
      FACTOR,
    }
  }

  /// Unit description (e.g., "meters per second")
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unit::VT_DESCRIPTION, None)}
  }
  /// Unit symbol (e.g., "m/s")
  #[inline]
  pub fn SYMBOL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unit::VT_SYMBOL, None)}
  }
  /// Power/exponent for this unit
  #[inline]
  pub fn POWER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Unit::VT_POWER, Some(0.0)).unwrap()}
  }
  /// Factor multiplier
  #[inline]
  pub fn FACTOR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Unit::VT_FACTOR, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Unit<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SYMBOL", Self::VT_SYMBOL, false)?
     .visit_field::<f64>("POWER", Self::VT_POWER, false)?
     .visit_field::<f64>("FACTOR", Self::VT_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitArgs<'a> {
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SYMBOL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub POWER: f64,
    pub FACTOR: f64,
}
impl<'a> Default for UnitArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnitArgs {
      DESCRIPTION: None,
      SYMBOL: None,
      POWER: 0.0,
      FACTOR: 0.0,
    }
  }
}

pub struct UnitBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unit::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn add_SYMBOL(&mut self, SYMBOL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unit::VT_SYMBOL, SYMBOL);
  }
  #[inline]
  pub fn add_POWER(&mut self, POWER: f64) {
    self.fbb_.push_slot::<f64>(Unit::VT_POWER, POWER, 0.0);
  }
  #[inline]
  pub fn add_FACTOR(&mut self, FACTOR: f64) {
    self.fbb_.push_slot::<f64>(Unit::VT_FACTOR, FACTOR, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnitBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unit<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unit");
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.field("SYMBOL", &self.SYMBOL());
      ds.field("POWER", &self.POWER());
      ds.field("FACTOR", &self.FACTOR());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UnitT {
  pub DESCRIPTION: Option<String>,
  pub SYMBOL: Option<String>,
  pub POWER: f64,
  pub FACTOR: f64,
}
impl Default for UnitT {
  fn default() -> Self {
    Self {
      DESCRIPTION: None,
      SYMBOL: None,
      POWER: 0.0,
      FACTOR: 0.0,
    }
  }
}
impl UnitT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Unit<'b>> {
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SYMBOL = self.SYMBOL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let POWER = self.POWER;
    let FACTOR = self.FACTOR;
    Unit::create(_fbb, &UnitArgs{
      DESCRIPTION,
      SYMBOL,
      POWER,
      FACTOR,
    })
  }
}
pub enum EnumerationValueOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Enumeration value mapping
pub struct EnumerationValue<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumerationValue<'a> {
  type Inner = EnumerationValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EnumerationValue<'a> {
  pub const VT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_MAX_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnumerationValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumerationValueArgs<'args>
  ) -> flatbuffers::WIPOffset<EnumerationValue<'bldr>> {
    let mut builder = EnumerationValueBuilder::new(_fbb);
    builder.add_MAX_VALUE(args.MAX_VALUE);
    builder.add_VALUE(args.VALUE);
    if let Some(x) = args.DESCRIPTION { builder.add_DESCRIPTION(x); }
    if let Some(x) = args.LABEL { builder.add_LABEL(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EnumerationValueT {
    let LABEL = self.LABEL().map(|x| {
      x.to_string()
    });
    let VALUE = self.VALUE();
    let MAX_VALUE = self.MAX_VALUE();
    let DESCRIPTION = self.DESCRIPTION().map(|x| {
      x.to_string()
    });
    EnumerationValueT {
      LABEL,
      VALUE,
      MAX_VALUE,
      DESCRIPTION,
    }
  }

  /// Label/name for this value
  #[inline]
  pub fn LABEL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumerationValue::VT_LABEL, None)}
  }
  /// Numeric value
  #[inline]
  pub fn VALUE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EnumerationValue::VT_VALUE, Some(0)).unwrap()}
  }
  /// Maximum value (for ranges)
  #[inline]
  pub fn MAX_VALUE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(EnumerationValue::VT_MAX_VALUE, Some(0)).unwrap()}
  }
  /// Description of this enumeration value
  #[inline]
  pub fn DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumerationValue::VT_DESCRIPTION, None)}
  }
}

impl flatbuffers::Verifiable for EnumerationValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LABEL", Self::VT_LABEL, false)?
     .visit_field::<i64>("VALUE", Self::VT_VALUE, false)?
     .visit_field::<i64>("MAX_VALUE", Self::VT_MAX_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTION", Self::VT_DESCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumerationValueArgs<'a> {
    pub LABEL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALUE: i64,
    pub MAX_VALUE: i64,
    pub DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnumerationValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumerationValueArgs {
      LABEL: None,
      VALUE: 0,
      MAX_VALUE: 0,
      DESCRIPTION: None,
    }
  }
}

pub struct EnumerationValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumerationValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_LABEL(&mut self, LABEL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumerationValue::VT_LABEL, LABEL);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: i64) {
    self.fbb_.push_slot::<i64>(EnumerationValue::VT_VALUE, VALUE, 0);
  }
  #[inline]
  pub fn add_MAX_VALUE(&mut self, MAX_VALUE: i64) {
    self.fbb_.push_slot::<i64>(EnumerationValue::VT_MAX_VALUE, MAX_VALUE, 0);
  }
  #[inline]
  pub fn add_DESCRIPTION(&mut self, DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumerationValue::VT_DESCRIPTION, DESCRIPTION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumerationValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumerationValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumerationValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnumerationValue<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnumerationValue");
      ds.field("LABEL", &self.LABEL());
      ds.field("VALUE", &self.VALUE());
      ds.field("MAX_VALUE", &self.MAX_VALUE());
      ds.field("DESCRIPTION", &self.DESCRIPTION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EnumerationValueT {
  pub LABEL: Option<String>,
  pub VALUE: i64,
  pub MAX_VALUE: i64,
  pub DESCRIPTION: Option<String>,
}
impl Default for EnumerationValueT {
  fn default() -> Self {
    Self {
      LABEL: None,
      VALUE: 0,
      MAX_VALUE: 0,
      DESCRIPTION: None,
    }
  }
}
impl EnumerationValueT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EnumerationValue<'b>> {
    let LABEL = self.LABEL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALUE = self.VALUE;
    let MAX_VALUE = self.MAX_VALUE;
    let DESCRIPTION = self.DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EnumerationValue::create(_fbb, &EnumerationValueArgs{
      LABEL,
      VALUE,
      MAX_VALUE,
      DESCRIPTION,
    })
  }
}
pub enum IntegerParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Integer parameter type
pub struct IntegerParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntegerParameterType<'a> {
  type Inner = IntegerParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntegerParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_UNITS: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 12;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 14;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 16;
  pub const VT_VALID_MIN: flatbuffers::VOffsetT = 18;
  pub const VT_VALID_MAX: flatbuffers::VOffsetT = 20;
  pub const VT_SIGNED: flatbuffers::VOffsetT = 22;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 24;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntegerParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntegerParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<IntegerParameterType<'bldr>> {
    let mut builder = IntegerParameterTypeBuilder::new(_fbb);
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.add_VALID_MAX(args.VALID_MAX);
    builder.add_VALID_MIN(args.VALID_MIN);
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.UNITS { builder.add_UNITS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_SIGNED(args.SIGNED);
    builder.finish()
  }

  pub fn unpack(&self) -> IntegerParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let UNITS = self.UNITS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let VALID_MIN = self.VALID_MIN();
    let VALID_MAX = self.VALID_MAX();
    let SIGNED = self.SIGNED();
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let INITIAL_VALUE = self.INITIAL_VALUE();
    IntegerParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Units
  #[inline]
  pub fn UNITS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(IntegerParameterType::VT_UNITS, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(IntegerParameterType::VT_DATA_ENCODING, None)}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(IntegerParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(IntegerParameterType::VT_CONTEXT_ALARMS, None)}
  }
  /// Minimum valid value
  #[inline]
  pub fn VALID_MIN(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerParameterType::VT_VALID_MIN, Some(0)).unwrap()}
  }
  /// Maximum valid value
  #[inline]
  pub fn VALID_MAX(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerParameterType::VT_VALID_MAX, Some(0)).unwrap()}
  }
  /// Signed integer (true) or unsigned (false)
  #[inline]
  pub fn SIGNED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(IntegerParameterType::VT_SIGNED, Some(false)).unwrap()}
  }
  /// Size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(IntegerParameterType::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerParameterType::VT_INITIAL_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IntegerParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("UNITS", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .visit_field::<i64>("VALID_MIN", Self::VT_VALID_MIN, false)?
     .visit_field::<i64>("VALID_MAX", Self::VT_VALID_MAX, false)?
     .visit_field::<bool>("SIGNED", Self::VT_SIGNED, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<i64>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntegerParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UNITS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
    pub VALID_MIN: i64,
    pub VALID_MAX: i64,
    pub SIGNED: bool,
    pub SIZE_IN_BITS: u16,
    pub INITIAL_VALUE: i64,
}
impl<'a> Default for IntegerParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntegerParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      VALID_MIN: 0,
      VALID_MAX: 0,
      SIGNED: false,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0,
    }
  }
}

pub struct IntegerParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntegerParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_UNITS(&mut self, UNITS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerParameterType::VT_UNITS, UNITS);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(IntegerParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(IntegerParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn add_VALID_MIN(&mut self, VALID_MIN: i64) {
    self.fbb_.push_slot::<i64>(IntegerParameterType::VT_VALID_MIN, VALID_MIN, 0);
  }
  #[inline]
  pub fn add_VALID_MAX(&mut self, VALID_MAX: i64) {
    self.fbb_.push_slot::<i64>(IntegerParameterType::VT_VALID_MAX, VALID_MAX, 0);
  }
  #[inline]
  pub fn add_SIGNED(&mut self, SIGNED: bool) {
    self.fbb_.push_slot::<bool>(IntegerParameterType::VT_SIGNED, SIGNED, false);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(IntegerParameterType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: i64) {
    self.fbb_.push_slot::<i64>(IntegerParameterType::VT_INITIAL_VALUE, INITIAL_VALUE, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntegerParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntegerParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntegerParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntegerParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntegerParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("UNITS", &self.UNITS());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.field("VALID_MIN", &self.VALID_MIN());
      ds.field("VALID_MAX", &self.VALID_MAX());
      ds.field("SIGNED", &self.SIGNED());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IntegerParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub UNITS: Option<Vec<UnitT>>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
  pub VALID_MIN: i64,
  pub VALID_MAX: i64,
  pub SIGNED: bool,
  pub SIZE_IN_BITS: u16,
  pub INITIAL_VALUE: i64,
}
impl Default for IntegerParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      VALID_MIN: 0,
      VALID_MAX: 0,
      SIGNED: false,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0,
    }
  }
}
impl IntegerParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IntegerParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UNITS = self.UNITS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let VALID_MIN = self.VALID_MIN;
    let VALID_MAX = self.VALID_MAX;
    let SIGNED = self.SIGNED;
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let INITIAL_VALUE = self.INITIAL_VALUE;
    IntegerParameterType::create(_fbb, &IntegerParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    })
  }
}
pub enum FloatParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Float parameter type
pub struct FloatParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatParameterType<'a> {
  type Inner = FloatParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloatParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_UNITS: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 12;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 14;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 16;
  pub const VT_VALID_MIN: flatbuffers::VOffsetT = 18;
  pub const VT_VALID_MAX: flatbuffers::VOffsetT = 20;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 22;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloatParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<FloatParameterType<'bldr>> {
    let mut builder = FloatParameterTypeBuilder::new(_fbb);
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.add_VALID_MAX(args.VALID_MAX);
    builder.add_VALID_MIN(args.VALID_MIN);
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.UNITS { builder.add_UNITS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.finish()
  }

  pub fn unpack(&self) -> FloatParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let UNITS = self.UNITS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let VALID_MIN = self.VALID_MIN();
    let VALID_MAX = self.VALID_MAX();
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let INITIAL_VALUE = self.INITIAL_VALUE();
    FloatParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Units
  #[inline]
  pub fn UNITS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(FloatParameterType::VT_UNITS, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<FloatDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FloatDataEncoding>>(FloatParameterType::VT_DATA_ENCODING, None)}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(FloatParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(FloatParameterType::VT_CONTEXT_ALARMS, None)}
  }
  /// Minimum valid value
  #[inline]
  pub fn VALID_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatParameterType::VT_VALID_MIN, Some(0.0)).unwrap()}
  }
  /// Maximum valid value
  #[inline]
  pub fn VALID_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatParameterType::VT_VALID_MAX, Some(0.0)).unwrap()}
  }
  /// Size in bits (32 or 64)
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(FloatParameterType::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatParameterType::VT_INITIAL_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FloatParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("UNITS", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FloatDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .visit_field::<f64>("VALID_MIN", Self::VT_VALID_MIN, false)?
     .visit_field::<f64>("VALID_MAX", Self::VT_VALID_MAX, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<f64>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UNITS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<FloatDataEncoding<'a>>>,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
    pub VALID_MIN: f64,
    pub VALID_MAX: f64,
    pub SIZE_IN_BITS: u16,
    pub INITIAL_VALUE: f64,
}
impl<'a> Default for FloatParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    FloatParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      VALID_MIN: 0.0,
      VALID_MAX: 0.0,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0.0,
    }
  }
}

pub struct FloatParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_UNITS(&mut self, UNITS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameterType::VT_UNITS, UNITS);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<FloatDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FloatDataEncoding>>(FloatParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(FloatParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn add_VALID_MIN(&mut self, VALID_MIN: f64) {
    self.fbb_.push_slot::<f64>(FloatParameterType::VT_VALID_MIN, VALID_MIN, 0.0);
  }
  #[inline]
  pub fn add_VALID_MAX(&mut self, VALID_MAX: f64) {
    self.fbb_.push_slot::<f64>(FloatParameterType::VT_VALID_MAX, VALID_MAX, 0.0);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(FloatParameterType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: f64) {
    self.fbb_.push_slot::<f64>(FloatParameterType::VT_INITIAL_VALUE, INITIAL_VALUE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloatParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloatParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("UNITS", &self.UNITS());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.field("VALID_MIN", &self.VALID_MIN());
      ds.field("VALID_MAX", &self.VALID_MAX());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloatParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub UNITS: Option<Vec<UnitT>>,
  pub DATA_ENCODING: Option<Box<FloatDataEncodingT>>,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
  pub VALID_MIN: f64,
  pub VALID_MAX: f64,
  pub SIZE_IN_BITS: u16,
  pub INITIAL_VALUE: f64,
}
impl Default for FloatParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      VALID_MIN: 0.0,
      VALID_MAX: 0.0,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0.0,
    }
  }
}
impl FloatParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FloatParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UNITS = self.UNITS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let VALID_MIN = self.VALID_MIN;
    let VALID_MAX = self.VALID_MAX;
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let INITIAL_VALUE = self.INITIAL_VALUE;
    FloatParameterType::create(_fbb, &FloatParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    })
  }
}
pub enum StringParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// String parameter type
pub struct StringParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringParameterType<'a> {
  type Inner = StringParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 12;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 14;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 16;
  pub const VT_RESTRICTION_PATTERN: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<StringParameterType<'bldr>> {
    let mut builder = StringParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.RESTRICTION_PATTERN { builder.add_RESTRICTION_PATTERN(x); }
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StringParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    let RESTRICTION_PATTERN = self.RESTRICTION_PATTERN().map(|x| {
      x.to_string()
    });
    StringParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      INITIAL_VALUE,
      RESTRICTION_PATTERN,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<StringDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StringDataEncoding>>(StringParameterType::VT_DATA_ENCODING, None)}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(StringParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(StringParameterType::VT_CONTEXT_ALARMS, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameterType::VT_INITIAL_VALUE, None)}
  }
  /// Restriction pattern (regex)
  #[inline]
  pub fn RESTRICTION_PATTERN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringParameterType::VT_RESTRICTION_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for StringParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StringDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RESTRICTION_PATTERN", Self::VT_RESTRICTION_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct StringParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<StringDataEncoding<'a>>>,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RESTRICTION_PATTERN: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      INITIAL_VALUE: None,
      RESTRICTION_PATTERN: None,
    }
  }
}

pub struct StringParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<StringDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StringDataEncoding>>(StringParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(StringParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn add_RESTRICTION_PATTERN(&mut self, RESTRICTION_PATTERN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringParameterType::VT_RESTRICTION_PATTERN, RESTRICTION_PATTERN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.field("RESTRICTION_PATTERN", &self.RESTRICTION_PATTERN());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<StringDataEncodingT>>,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
  pub INITIAL_VALUE: Option<String>,
  pub RESTRICTION_PATTERN: Option<String>,
}
impl Default for StringParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      INITIAL_VALUE: None,
      RESTRICTION_PATTERN: None,
    }
  }
}
impl StringParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StringParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RESTRICTION_PATTERN = self.RESTRICTION_PATTERN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    StringParameterType::create(_fbb, &StringParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      INITIAL_VALUE,
      RESTRICTION_PATTERN,
    })
  }
}
pub enum BooleanParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Boolean parameter type
pub struct BooleanParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BooleanParameterType<'a> {
  type Inner = BooleanParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BooleanParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_ONE_STRING_VALUE: flatbuffers::VOffsetT = 12;
  pub const VT_ZERO_STRING_VALUE: flatbuffers::VOffsetT = 14;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BooleanParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BooleanParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<BooleanParameterType<'bldr>> {
    let mut builder = BooleanParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.ZERO_STRING_VALUE { builder.add_ZERO_STRING_VALUE(x); }
    if let Some(x) = args.ONE_STRING_VALUE { builder.add_ONE_STRING_VALUE(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.finish()
  }

  pub fn unpack(&self) -> BooleanParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let ONE_STRING_VALUE = self.ONE_STRING_VALUE().map(|x| {
      x.to_string()
    });
    let ZERO_STRING_VALUE = self.ZERO_STRING_VALUE().map(|x| {
      x.to_string()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE();
    BooleanParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ONE_STRING_VALUE,
      ZERO_STRING_VALUE,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding (typically IntegerDataEncoding with 1 bit)
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(BooleanParameterType::VT_DATA_ENCODING, None)}
  }
  /// String representation of true value
  #[inline]
  pub fn ONE_STRING_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanParameterType::VT_ONE_STRING_VALUE, None)}
  }
  /// String representation of false value
  #[inline]
  pub fn ZERO_STRING_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanParameterType::VT_ZERO_STRING_VALUE, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BooleanParameterType::VT_INITIAL_VALUE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BooleanParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ONE_STRING_VALUE", Self::VT_ONE_STRING_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ZERO_STRING_VALUE", Self::VT_ZERO_STRING_VALUE, false)?
     .visit_field::<bool>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BooleanParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub ONE_STRING_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ZERO_STRING_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_VALUE: bool,
}
impl<'a> Default for BooleanParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    BooleanParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ONE_STRING_VALUE: None,
      ZERO_STRING_VALUE: None,
      INITIAL_VALUE: false,
    }
  }
}

pub struct BooleanParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BooleanParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(BooleanParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_ONE_STRING_VALUE(&mut self, ONE_STRING_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanParameterType::VT_ONE_STRING_VALUE, ONE_STRING_VALUE);
  }
  #[inline]
  pub fn add_ZERO_STRING_VALUE(&mut self, ZERO_STRING_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanParameterType::VT_ZERO_STRING_VALUE, ZERO_STRING_VALUE);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: bool) {
    self.fbb_.push_slot::<bool>(BooleanParameterType::VT_INITIAL_VALUE, INITIAL_VALUE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BooleanParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BooleanParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BooleanParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BooleanParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BooleanParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("ONE_STRING_VALUE", &self.ONE_STRING_VALUE());
      ds.field("ZERO_STRING_VALUE", &self.ZERO_STRING_VALUE());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BooleanParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub ONE_STRING_VALUE: Option<String>,
  pub ZERO_STRING_VALUE: Option<String>,
  pub INITIAL_VALUE: bool,
}
impl Default for BooleanParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ONE_STRING_VALUE: None,
      ZERO_STRING_VALUE: None,
      INITIAL_VALUE: false,
    }
  }
}
impl BooleanParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BooleanParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ONE_STRING_VALUE = self.ONE_STRING_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ZERO_STRING_VALUE = self.ZERO_STRING_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE;
    BooleanParameterType::create(_fbb, &BooleanParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ONE_STRING_VALUE,
      ZERO_STRING_VALUE,
      INITIAL_VALUE,
    })
  }
}
pub enum EnumeratedParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Enumerated parameter type
pub struct EnumeratedParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumeratedParameterType<'a> {
  type Inner = EnumeratedParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EnumeratedParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 12;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 14;
  pub const VT_ENUMERATION_LIST: flatbuffers::VOffsetT = 16;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnumeratedParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumeratedParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<EnumeratedParameterType<'bldr>> {
    let mut builder = EnumeratedParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.ENUMERATION_LIST { builder.add_ENUMERATION_LIST(x); }
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EnumeratedParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ENUMERATION_LIST = self.ENUMERATION_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    EnumeratedParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      ENUMERATION_LIST,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(EnumeratedParameterType::VT_DATA_ENCODING, None)}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(EnumeratedParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(EnumeratedParameterType::VT_CONTEXT_ALARMS, None)}
  }
  /// Enumeration values list
  #[inline]
  pub fn ENUMERATION_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue>>>>(EnumeratedParameterType::VT_ENUMERATION_LIST, None)}
  }
  /// Initial/default value label
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedParameterType::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for EnumeratedParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumerationValue>>>>("ENUMERATION_LIST", Self::VT_ENUMERATION_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumeratedParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
    pub ENUMERATION_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue<'a>>>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnumeratedParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumeratedParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      ENUMERATION_LIST: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct EnumeratedParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumeratedParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(EnumeratedParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(EnumeratedParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn add_ENUMERATION_LIST(&mut self, ENUMERATION_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumerationValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_ENUMERATION_LIST, ENUMERATION_LIST);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumeratedParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumeratedParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumeratedParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnumeratedParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnumeratedParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.field("ENUMERATION_LIST", &self.ENUMERATION_LIST());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EnumeratedParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
  pub ENUMERATION_LIST: Option<Vec<EnumerationValueT>>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for EnumeratedParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
      ENUMERATION_LIST: None,
      INITIAL_VALUE: None,
    }
  }
}
impl EnumeratedParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EnumeratedParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ENUMERATION_LIST = self.ENUMERATION_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EnumeratedParameterType::create(_fbb, &EnumeratedParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
      ENUMERATION_LIST,
      INITIAL_VALUE,
    })
  }
}
pub enum BinaryParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Binary parameter type
pub struct BinaryParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryParameterType<'a> {
  type Inner = BinaryParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryParameterType<'bldr>> {
    let mut builder = BinaryParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BinaryParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    BinaryParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<BinaryDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryDataEncoding>>(BinaryParameterType::VT_DATA_ENCODING, None)}
  }
  /// Initial/default value (hex string)
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryParameterType::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<BinaryDataEncoding<'a>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BinaryParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct BinaryParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<BinaryDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryDataEncoding>>(BinaryParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryParameterType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BinaryParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<BinaryDataEncodingT>>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for BinaryParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
    }
  }
}
impl BinaryParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BinaryParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    BinaryParameterType::create(_fbb, &BinaryParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
    })
  }
}
pub enum AbsoluteTimeParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Absolute time parameter type
pub struct AbsoluteTimeParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbsoluteTimeParameterType<'a> {
  type Inner = AbsoluteTimeParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AbsoluteTimeParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_EPOCH: flatbuffers::VOffsetT = 10;
  pub const VT_EPOCH_DATE: flatbuffers::VOffsetT = 12;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 14;
  pub const VT_SCALE: flatbuffers::VOffsetT = 16;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 18;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 20;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AbsoluteTimeParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AbsoluteTimeParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<AbsoluteTimeParameterType<'bldr>> {
    let mut builder = AbsoluteTimeParameterTypeBuilder::new(_fbb);
    builder.add_OFFSET(args.OFFSET);
    builder.add_SCALE(args.SCALE);
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.EPOCH_DATE { builder.add_EPOCH_DATE(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_EPOCH(args.EPOCH);
    builder.finish()
  }

  pub fn unpack(&self) -> AbsoluteTimeParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let EPOCH = self.EPOCH();
    let EPOCH_DATE = self.EPOCH_DATE().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let SCALE = self.SCALE();
    let OFFSET = self.OFFSET();
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    AbsoluteTimeParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      EPOCH,
      EPOCH_DATE,
      DATA_ENCODING,
      SCALE,
      OFFSET,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AbsoluteTimeParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AbsoluteTimeParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AbsoluteTimeParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Reference epoch
  #[inline]
  pub fn EPOCH(&self) -> EpochType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EpochType>(AbsoluteTimeParameterType::VT_EPOCH, Some(EpochType::UNIX)).unwrap()}
  }
  /// Custom epoch date (ISO 8601) when EPOCH=CUSTOM
  #[inline]
  pub fn EPOCH_DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AbsoluteTimeParameterType::VT_EPOCH_DATE, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(AbsoluteTimeParameterType::VT_DATA_ENCODING, None)}
  }
  /// Time unit scale factor
  #[inline]
  pub fn SCALE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AbsoluteTimeParameterType::VT_SCALE, Some(0.0)).unwrap()}
  }
  /// Time unit offset
  #[inline]
  pub fn OFFSET(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AbsoluteTimeParameterType::VT_OFFSET, Some(0.0)).unwrap()}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(AbsoluteTimeParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(AbsoluteTimeParameterType::VT_CONTEXT_ALARMS, None)}
  }
}

impl flatbuffers::Verifiable for AbsoluteTimeParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<EpochType>("EPOCH", Self::VT_EPOCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EPOCH_DATE", Self::VT_EPOCH_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<f64>("SCALE", Self::VT_SCALE, false)?
     .visit_field::<f64>("OFFSET", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .finish();
    Ok(())
  }
}
pub struct AbsoluteTimeParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EPOCH: EpochType,
    pub EPOCH_DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub SCALE: f64,
    pub OFFSET: f64,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
}
impl<'a> Default for AbsoluteTimeParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AbsoluteTimeParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      EPOCH: EpochType::UNIX,
      EPOCH_DATE: None,
      DATA_ENCODING: None,
      SCALE: 0.0,
      OFFSET: 0.0,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
    }
  }
}

pub struct AbsoluteTimeParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AbsoluteTimeParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbsoluteTimeParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbsoluteTimeParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbsoluteTimeParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_EPOCH(&mut self, EPOCH: EpochType) {
    self.fbb_.push_slot::<EpochType>(AbsoluteTimeParameterType::VT_EPOCH, EPOCH, EpochType::UNIX);
  }
  #[inline]
  pub fn add_EPOCH_DATE(&mut self, EPOCH_DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbsoluteTimeParameterType::VT_EPOCH_DATE, EPOCH_DATE);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(AbsoluteTimeParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_SCALE(&mut self, SCALE: f64) {
    self.fbb_.push_slot::<f64>(AbsoluteTimeParameterType::VT_SCALE, SCALE, 0.0);
  }
  #[inline]
  pub fn add_OFFSET(&mut self, OFFSET: f64) {
    self.fbb_.push_slot::<f64>(AbsoluteTimeParameterType::VT_OFFSET, OFFSET, 0.0);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(AbsoluteTimeParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AbsoluteTimeParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AbsoluteTimeParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AbsoluteTimeParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbsoluteTimeParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AbsoluteTimeParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AbsoluteTimeParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("EPOCH", &self.EPOCH());
      ds.field("EPOCH_DATE", &self.EPOCH_DATE());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("SCALE", &self.SCALE());
      ds.field("OFFSET", &self.OFFSET());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AbsoluteTimeParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub EPOCH: EpochType,
  pub EPOCH_DATE: Option<String>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub SCALE: f64,
  pub OFFSET: f64,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
}
impl Default for AbsoluteTimeParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      EPOCH: EpochType::UNIX,
      EPOCH_DATE: None,
      DATA_ENCODING: None,
      SCALE: 0.0,
      OFFSET: 0.0,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
    }
  }
}
impl AbsoluteTimeParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AbsoluteTimeParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EPOCH = self.EPOCH;
    let EPOCH_DATE = self.EPOCH_DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SCALE = self.SCALE;
    let OFFSET = self.OFFSET;
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    AbsoluteTimeParameterType::create(_fbb, &AbsoluteTimeParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      EPOCH,
      EPOCH_DATE,
      DATA_ENCODING,
      SCALE,
      OFFSET,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
    })
  }
}
pub enum RelativeTimeParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Relative time parameter type
pub struct RelativeTimeParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RelativeTimeParameterType<'a> {
  type Inner = RelativeTimeParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RelativeTimeParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_UNITS: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 12;
  pub const VT_DEFAULT_ALARM: flatbuffers::VOffsetT = 14;
  pub const VT_CONTEXT_ALARMS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RelativeTimeParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RelativeTimeParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<RelativeTimeParameterType<'bldr>> {
    let mut builder = RelativeTimeParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.CONTEXT_ALARMS { builder.add_CONTEXT_ALARMS(x); }
    if let Some(x) = args.DEFAULT_ALARM { builder.add_DEFAULT_ALARM(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.UNITS { builder.add_UNITS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> RelativeTimeParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let UNITS = self.UNITS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM().map(|x| {
      Box::new(x.unpack())
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    RelativeTimeParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RelativeTimeParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RelativeTimeParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RelativeTimeParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Units
  #[inline]
  pub fn UNITS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(RelativeTimeParameterType::VT_UNITS, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(RelativeTimeParameterType::VT_DATA_ENCODING, None)}
  }
  /// Default alarm
  #[inline]
  pub fn DEFAULT_ALARM(&self) -> Option<DefaultAlarm<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DefaultAlarm>>(RelativeTimeParameterType::VT_DEFAULT_ALARM, None)}
  }
  /// Context alarms
  #[inline]
  pub fn CONTEXT_ALARMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm>>>>(RelativeTimeParameterType::VT_CONTEXT_ALARMS, None)}
  }
}

impl flatbuffers::Verifiable for RelativeTimeParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("UNITS", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DefaultAlarm>>("DEFAULT_ALARM", Self::VT_DEFAULT_ALARM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContextAlarm>>>>("CONTEXT_ALARMS", Self::VT_CONTEXT_ALARMS, false)?
     .finish();
    Ok(())
  }
}
pub struct RelativeTimeParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UNITS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub DEFAULT_ALARM: Option<flatbuffers::WIPOffset<DefaultAlarm<'a>>>,
    pub CONTEXT_ALARMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContextAlarm<'a>>>>>,
}
impl<'a> Default for RelativeTimeParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelativeTimeParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
    }
  }
}

pub struct RelativeTimeParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RelativeTimeParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelativeTimeParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelativeTimeParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelativeTimeParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_UNITS(&mut self, UNITS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelativeTimeParameterType::VT_UNITS, UNITS);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(RelativeTimeParameterType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_DEFAULT_ALARM(&mut self, DEFAULT_ALARM: flatbuffers::WIPOffset<DefaultAlarm<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DefaultAlarm>>(RelativeTimeParameterType::VT_DEFAULT_ALARM, DEFAULT_ALARM);
  }
  #[inline]
  pub fn add_CONTEXT_ALARMS(&mut self, CONTEXT_ALARMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContextAlarm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RelativeTimeParameterType::VT_CONTEXT_ALARMS, CONTEXT_ALARMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RelativeTimeParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RelativeTimeParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RelativeTimeParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RelativeTimeParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RelativeTimeParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("UNITS", &self.UNITS());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("DEFAULT_ALARM", &self.DEFAULT_ALARM());
      ds.field("CONTEXT_ALARMS", &self.CONTEXT_ALARMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RelativeTimeParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub UNITS: Option<Vec<UnitT>>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub DEFAULT_ALARM: Option<Box<DefaultAlarmT>>,
  pub CONTEXT_ALARMS: Option<Vec<ContextAlarmT>>,
}
impl Default for RelativeTimeParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      DEFAULT_ALARM: None,
      CONTEXT_ALARMS: None,
    }
  }
}
impl RelativeTimeParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RelativeTimeParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UNITS = self.UNITS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let DEFAULT_ALARM = self.DEFAULT_ALARM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTEXT_ALARMS = self.CONTEXT_ALARMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    RelativeTimeParameterType::create(_fbb, &RelativeTimeParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      DEFAULT_ALARM,
      CONTEXT_ALARMS,
    })
  }
}
pub enum ArrayDimensionOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Array dimension specification
pub struct ArrayDimension<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayDimension<'a> {
  type Inner = ArrayDimension<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayDimension<'a> {
  pub const VT_SIZE: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_PARAMETER_REF: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayDimension { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArrayDimensionArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayDimension<'bldr>> {
    let mut builder = ArrayDimensionBuilder::new(_fbb);
    if let Some(x) = args.SIZE_PARAMETER_REF { builder.add_SIZE_PARAMETER_REF(x); }
    builder.add_SIZE(args.SIZE);
    builder.finish()
  }

  pub fn unpack(&self) -> ArrayDimensionT {
    let SIZE = self.SIZE();
    let SIZE_PARAMETER_REF = self.SIZE_PARAMETER_REF().map(|x| {
      x.to_string()
    });
    ArrayDimensionT {
      SIZE,
      SIZE_PARAMETER_REF,
    }
  }

  /// Fixed size of this dimension
  #[inline]
  pub fn SIZE(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ArrayDimension::VT_SIZE, Some(0)).unwrap()}
  }
  /// Dynamic size from parameter reference
  #[inline]
  pub fn SIZE_PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayDimension::VT_SIZE_PARAMETER_REF, None)}
  }
}

impl flatbuffers::Verifiable for ArrayDimension<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("SIZE", Self::VT_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SIZE_PARAMETER_REF", Self::VT_SIZE_PARAMETER_REF, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayDimensionArgs<'a> {
    pub SIZE: u32,
    pub SIZE_PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ArrayDimensionArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayDimensionArgs {
      SIZE: 0,
      SIZE_PARAMETER_REF: None,
    }
  }
}

pub struct ArrayDimensionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayDimensionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SIZE(&mut self, SIZE: u32) {
    self.fbb_.push_slot::<u32>(ArrayDimension::VT_SIZE, SIZE, 0);
  }
  #[inline]
  pub fn add_SIZE_PARAMETER_REF(&mut self, SIZE_PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayDimension::VT_SIZE_PARAMETER_REF, SIZE_PARAMETER_REF);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArrayDimensionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArrayDimensionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayDimension<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayDimension<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayDimension");
      ds.field("SIZE", &self.SIZE());
      ds.field("SIZE_PARAMETER_REF", &self.SIZE_PARAMETER_REF());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArrayDimensionT {
  pub SIZE: u32,
  pub SIZE_PARAMETER_REF: Option<String>,
}
impl Default for ArrayDimensionT {
  fn default() -> Self {
    Self {
      SIZE: 0,
      SIZE_PARAMETER_REF: None,
    }
  }
}
impl ArrayDimensionT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArrayDimension<'b>> {
    let SIZE = self.SIZE;
    let SIZE_PARAMETER_REF = self.SIZE_PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ArrayDimension::create(_fbb, &ArrayDimensionArgs{
      SIZE,
      SIZE_PARAMETER_REF,
    })
  }
}
pub enum ArrayParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Array parameter type
pub struct ArrayParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayParameterType<'a> {
  type Inner = ArrayParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_ARRAY_TYPE_REF: flatbuffers::VOffsetT = 10;
  pub const VT_DIMENSIONS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArrayParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayParameterType<'bldr>> {
    let mut builder = ArrayParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.DIMENSIONS { builder.add_DIMENSIONS(x); }
    if let Some(x) = args.ARRAY_TYPE_REF { builder.add_ARRAY_TYPE_REF(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArrayParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let ARRAY_TYPE_REF = self.ARRAY_TYPE_REF().map(|x| {
      x.to_string()
    });
    let DIMENSIONS = self.DIMENSIONS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ArrayParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ARRAY_TYPE_REF,
      DIMENSIONS,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Reference to the array element type
  #[inline]
  pub fn ARRAY_TYPE_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayParameterType::VT_ARRAY_TYPE_REF, None)}
  }
  /// Dimension list
  #[inline]
  pub fn DIMENSIONS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayDimension<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayDimension>>>>(ArrayParameterType::VT_DIMENSIONS, None)}
  }
}

impl flatbuffers::Verifiable for ArrayParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ARRAY_TYPE_REF", Self::VT_ARRAY_TYPE_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayDimension>>>>("DIMENSIONS", Self::VT_DIMENSIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ARRAY_TYPE_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DIMENSIONS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayDimension<'a>>>>>,
}
impl<'a> Default for ArrayParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ARRAY_TYPE_REF: None,
      DIMENSIONS: None,
    }
  }
}

pub struct ArrayParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_ARRAY_TYPE_REF(&mut self, ARRAY_TYPE_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterType::VT_ARRAY_TYPE_REF, ARRAY_TYPE_REF);
  }
  #[inline]
  pub fn add_DIMENSIONS(&mut self, DIMENSIONS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ArrayDimension<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterType::VT_DIMENSIONS, DIMENSIONS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArrayParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArrayParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("ARRAY_TYPE_REF", &self.ARRAY_TYPE_REF());
      ds.field("DIMENSIONS", &self.DIMENSIONS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArrayParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub ARRAY_TYPE_REF: Option<String>,
  pub DIMENSIONS: Option<Vec<ArrayDimensionT>>,
}
impl Default for ArrayParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ARRAY_TYPE_REF: None,
      DIMENSIONS: None,
    }
  }
}
impl ArrayParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArrayParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ARRAY_TYPE_REF = self.ARRAY_TYPE_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DIMENSIONS = self.DIMENSIONS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ArrayParameterType::create(_fbb, &ArrayParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ARRAY_TYPE_REF,
      DIMENSIONS,
    })
  }
}
pub enum AggregateMemberOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Aggregate member definition
pub struct AggregateMember<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AggregateMember<'a> {
  type Inner = AggregateMember<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AggregateMember<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_REF: flatbuffers::VOffsetT = 6;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AggregateMember { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AggregateMemberArgs<'args>
  ) -> flatbuffers::WIPOffset<AggregateMember<'bldr>> {
    let mut builder = AggregateMemberBuilder::new(_fbb);
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.TYPE_REF { builder.add_TYPE_REF(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AggregateMemberT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let TYPE_REF = self.TYPE_REF().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    AggregateMemberT {
      NAME,
      TYPE_REF,
      SHORT_DESCRIPTION,
    }
  }

  /// Member name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateMember::VT_NAME, None)}
  }
  /// Reference to parameter type
  #[inline]
  pub fn TYPE_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateMember::VT_TYPE_REF, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateMember::VT_SHORT_DESCRIPTION, None)}
  }
}

impl flatbuffers::Verifiable for AggregateMember<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TYPE_REF", Self::VT_TYPE_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct AggregateMemberArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TYPE_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AggregateMemberArgs<'a> {
  #[inline]
  fn default() -> Self {
    AggregateMemberArgs {
      NAME: None,
      TYPE_REF: None,
      SHORT_DESCRIPTION: None,
    }
  }
}

pub struct AggregateMemberBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AggregateMemberBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateMember::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_TYPE_REF(&mut self, TYPE_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateMember::VT_TYPE_REF, TYPE_REF);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateMember::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AggregateMemberBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AggregateMemberBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AggregateMember<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AggregateMember<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AggregateMember");
      ds.field("NAME", &self.NAME());
      ds.field("TYPE_REF", &self.TYPE_REF());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AggregateMemberT {
  pub NAME: Option<String>,
  pub TYPE_REF: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
}
impl Default for AggregateMemberT {
  fn default() -> Self {
    Self {
      NAME: None,
      TYPE_REF: None,
      SHORT_DESCRIPTION: None,
    }
  }
}
impl AggregateMemberT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AggregateMember<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TYPE_REF = self.TYPE_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AggregateMember::create(_fbb, &AggregateMemberArgs{
      NAME,
      TYPE_REF,
      SHORT_DESCRIPTION,
    })
  }
}
pub enum AggregateParameterTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Aggregate parameter type (structure)
pub struct AggregateParameterType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AggregateParameterType<'a> {
  type Inner = AggregateParameterType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AggregateParameterType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_MEMBERS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AggregateParameterType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AggregateParameterTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<AggregateParameterType<'bldr>> {
    let mut builder = AggregateParameterTypeBuilder::new(_fbb);
    if let Some(x) = args.MEMBERS { builder.add_MEMBERS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AggregateParameterTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MEMBERS = self.MEMBERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    AggregateParameterTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      MEMBERS,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateParameterType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateParameterType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateParameterType::VT_LONG_DESCRIPTION, None)}
  }
  /// Member list
  #[inline]
  pub fn MEMBERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember>>>>(AggregateParameterType::VT_MEMBERS, None)}
  }
}

impl flatbuffers::Verifiable for AggregateParameterType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AggregateMember>>>>("MEMBERS", Self::VT_MEMBERS, false)?
     .finish();
    Ok(())
  }
}
pub struct AggregateParameterTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEMBERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember<'a>>>>>,
}
impl<'a> Default for AggregateParameterTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AggregateParameterTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      MEMBERS: None,
    }
  }
}

pub struct AggregateParameterTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AggregateParameterTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateParameterType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateParameterType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateParameterType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_MEMBERS(&mut self, MEMBERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AggregateMember<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateParameterType::VT_MEMBERS, MEMBERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AggregateParameterTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AggregateParameterTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AggregateParameterType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AggregateParameterType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AggregateParameterType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("MEMBERS", &self.MEMBERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AggregateParameterTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub MEMBERS: Option<Vec<AggregateMemberT>>,
}
impl Default for AggregateParameterTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      MEMBERS: None,
    }
  }
}
impl AggregateParameterTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AggregateParameterType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEMBERS = self.MEMBERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    AggregateParameterType::create(_fbb, &AggregateParameterTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      MEMBERS,
    })
  }
}
pub enum ParameterTypeSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of all parameter types
pub struct ParameterTypeSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParameterTypeSet<'a> {
  type Inner = ParameterTypeSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParameterTypeSet<'a> {
  pub const VT_INTEGER_TYPES: flatbuffers::VOffsetT = 4;
  pub const VT_FLOAT_TYPES: flatbuffers::VOffsetT = 6;
  pub const VT_STRING_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_BOOLEAN_TYPES: flatbuffers::VOffsetT = 10;
  pub const VT_ENUMERATED_TYPES: flatbuffers::VOffsetT = 12;
  pub const VT_BINARY_TYPES: flatbuffers::VOffsetT = 14;
  pub const VT_ABSOLUTE_TIME_TYPES: flatbuffers::VOffsetT = 16;
  pub const VT_RELATIVE_TIME_TYPES: flatbuffers::VOffsetT = 18;
  pub const VT_ARRAY_TYPES: flatbuffers::VOffsetT = 20;
  pub const VT_AGGREGATE_TYPES: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParameterTypeSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterTypeSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ParameterTypeSet<'bldr>> {
    let mut builder = ParameterTypeSetBuilder::new(_fbb);
    if let Some(x) = args.AGGREGATE_TYPES { builder.add_AGGREGATE_TYPES(x); }
    if let Some(x) = args.ARRAY_TYPES { builder.add_ARRAY_TYPES(x); }
    if let Some(x) = args.RELATIVE_TIME_TYPES { builder.add_RELATIVE_TIME_TYPES(x); }
    if let Some(x) = args.ABSOLUTE_TIME_TYPES { builder.add_ABSOLUTE_TIME_TYPES(x); }
    if let Some(x) = args.BINARY_TYPES { builder.add_BINARY_TYPES(x); }
    if let Some(x) = args.ENUMERATED_TYPES { builder.add_ENUMERATED_TYPES(x); }
    if let Some(x) = args.BOOLEAN_TYPES { builder.add_BOOLEAN_TYPES(x); }
    if let Some(x) = args.STRING_TYPES { builder.add_STRING_TYPES(x); }
    if let Some(x) = args.FLOAT_TYPES { builder.add_FLOAT_TYPES(x); }
    if let Some(x) = args.INTEGER_TYPES { builder.add_INTEGER_TYPES(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterTypeSetT {
    let INTEGER_TYPES = self.INTEGER_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let FLOAT_TYPES = self.FLOAT_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let STRING_TYPES = self.STRING_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BOOLEAN_TYPES = self.BOOLEAN_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ENUMERATED_TYPES = self.ENUMERATED_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BINARY_TYPES = self.BINARY_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ABSOLUTE_TIME_TYPES = self.ABSOLUTE_TIME_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let RELATIVE_TIME_TYPES = self.RELATIVE_TIME_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ARRAY_TYPES = self.ARRAY_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let AGGREGATE_TYPES = self.AGGREGATE_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ParameterTypeSetT {
      INTEGER_TYPES,
      FLOAT_TYPES,
      STRING_TYPES,
      BOOLEAN_TYPES,
      ENUMERATED_TYPES,
      BINARY_TYPES,
      ABSOLUTE_TIME_TYPES,
      RELATIVE_TIME_TYPES,
      ARRAY_TYPES,
      AGGREGATE_TYPES,
    }
  }

  /// Integer parameter types
  #[inline]
  pub fn INTEGER_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerParameterType>>>>(ParameterTypeSet::VT_INTEGER_TYPES, None)}
  }
  /// Float parameter types
  #[inline]
  pub fn FLOAT_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameterType>>>>(ParameterTypeSet::VT_FLOAT_TYPES, None)}
  }
  /// String parameter types
  #[inline]
  pub fn STRING_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameterType>>>>(ParameterTypeSet::VT_STRING_TYPES, None)}
  }
  /// Boolean parameter types
  #[inline]
  pub fn BOOLEAN_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanParameterType>>>>(ParameterTypeSet::VT_BOOLEAN_TYPES, None)}
  }
  /// Enumerated parameter types
  #[inline]
  pub fn ENUMERATED_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedParameterType>>>>(ParameterTypeSet::VT_ENUMERATED_TYPES, None)}
  }
  /// Binary parameter types
  #[inline]
  pub fn BINARY_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryParameterType>>>>(ParameterTypeSet::VT_BINARY_TYPES, None)}
  }
  /// Absolute time parameter types
  #[inline]
  pub fn ABSOLUTE_TIME_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AbsoluteTimeParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AbsoluteTimeParameterType>>>>(ParameterTypeSet::VT_ABSOLUTE_TIME_TYPES, None)}
  }
  /// Relative time parameter types
  #[inline]
  pub fn RELATIVE_TIME_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelativeTimeParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelativeTimeParameterType>>>>(ParameterTypeSet::VT_RELATIVE_TIME_TYPES, None)}
  }
  /// Array parameter types
  #[inline]
  pub fn ARRAY_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayParameterType>>>>(ParameterTypeSet::VT_ARRAY_TYPES, None)}
  }
  /// Aggregate parameter types
  #[inline]
  pub fn AGGREGATE_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateParameterType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateParameterType>>>>(ParameterTypeSet::VT_AGGREGATE_TYPES, None)}
  }
}

impl flatbuffers::Verifiable for ParameterTypeSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntegerParameterType>>>>("INTEGER_TYPES", Self::VT_INTEGER_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FloatParameterType>>>>("FLOAT_TYPES", Self::VT_FLOAT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringParameterType>>>>("STRING_TYPES", Self::VT_STRING_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BooleanParameterType>>>>("BOOLEAN_TYPES", Self::VT_BOOLEAN_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumeratedParameterType>>>>("ENUMERATED_TYPES", Self::VT_ENUMERATED_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryParameterType>>>>("BINARY_TYPES", Self::VT_BINARY_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AbsoluteTimeParameterType>>>>("ABSOLUTE_TIME_TYPES", Self::VT_ABSOLUTE_TIME_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RelativeTimeParameterType>>>>("RELATIVE_TIME_TYPES", Self::VT_RELATIVE_TIME_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArrayParameterType>>>>("ARRAY_TYPES", Self::VT_ARRAY_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AggregateParameterType>>>>("AGGREGATE_TYPES", Self::VT_AGGREGATE_TYPES, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterTypeSetArgs<'a> {
    pub INTEGER_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerParameterType<'a>>>>>,
    pub FLOAT_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatParameterType<'a>>>>>,
    pub STRING_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringParameterType<'a>>>>>,
    pub BOOLEAN_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanParameterType<'a>>>>>,
    pub ENUMERATED_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedParameterType<'a>>>>>,
    pub BINARY_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryParameterType<'a>>>>>,
    pub ABSOLUTE_TIME_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AbsoluteTimeParameterType<'a>>>>>,
    pub RELATIVE_TIME_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RelativeTimeParameterType<'a>>>>>,
    pub ARRAY_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArrayParameterType<'a>>>>>,
    pub AGGREGATE_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateParameterType<'a>>>>>,
}
impl<'a> Default for ParameterTypeSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterTypeSetArgs {
      INTEGER_TYPES: None,
      FLOAT_TYPES: None,
      STRING_TYPES: None,
      BOOLEAN_TYPES: None,
      ENUMERATED_TYPES: None,
      BINARY_TYPES: None,
      ABSOLUTE_TIME_TYPES: None,
      RELATIVE_TIME_TYPES: None,
      ARRAY_TYPES: None,
      AGGREGATE_TYPES: None,
    }
  }
}

pub struct ParameterTypeSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterTypeSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_INTEGER_TYPES(&mut self, INTEGER_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntegerParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_INTEGER_TYPES, INTEGER_TYPES);
  }
  #[inline]
  pub fn add_FLOAT_TYPES(&mut self, FLOAT_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FloatParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_FLOAT_TYPES, FLOAT_TYPES);
  }
  #[inline]
  pub fn add_STRING_TYPES(&mut self, STRING_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_STRING_TYPES, STRING_TYPES);
  }
  #[inline]
  pub fn add_BOOLEAN_TYPES(&mut self, BOOLEAN_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BooleanParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_BOOLEAN_TYPES, BOOLEAN_TYPES);
  }
  #[inline]
  pub fn add_ENUMERATED_TYPES(&mut self, ENUMERATED_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumeratedParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_ENUMERATED_TYPES, ENUMERATED_TYPES);
  }
  #[inline]
  pub fn add_BINARY_TYPES(&mut self, BINARY_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_BINARY_TYPES, BINARY_TYPES);
  }
  #[inline]
  pub fn add_ABSOLUTE_TIME_TYPES(&mut self, ABSOLUTE_TIME_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AbsoluteTimeParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_ABSOLUTE_TIME_TYPES, ABSOLUTE_TIME_TYPES);
  }
  #[inline]
  pub fn add_RELATIVE_TIME_TYPES(&mut self, RELATIVE_TIME_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RelativeTimeParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_RELATIVE_TIME_TYPES, RELATIVE_TIME_TYPES);
  }
  #[inline]
  pub fn add_ARRAY_TYPES(&mut self, ARRAY_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ArrayParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_ARRAY_TYPES, ARRAY_TYPES);
  }
  #[inline]
  pub fn add_AGGREGATE_TYPES(&mut self, AGGREGATE_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AggregateParameterType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterTypeSet::VT_AGGREGATE_TYPES, AGGREGATE_TYPES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterTypeSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterTypeSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParameterTypeSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParameterTypeSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParameterTypeSet");
      ds.field("INTEGER_TYPES", &self.INTEGER_TYPES());
      ds.field("FLOAT_TYPES", &self.FLOAT_TYPES());
      ds.field("STRING_TYPES", &self.STRING_TYPES());
      ds.field("BOOLEAN_TYPES", &self.BOOLEAN_TYPES());
      ds.field("ENUMERATED_TYPES", &self.ENUMERATED_TYPES());
      ds.field("BINARY_TYPES", &self.BINARY_TYPES());
      ds.field("ABSOLUTE_TIME_TYPES", &self.ABSOLUTE_TIME_TYPES());
      ds.field("RELATIVE_TIME_TYPES", &self.RELATIVE_TIME_TYPES());
      ds.field("ARRAY_TYPES", &self.ARRAY_TYPES());
      ds.field("AGGREGATE_TYPES", &self.AGGREGATE_TYPES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterTypeSetT {
  pub INTEGER_TYPES: Option<Vec<IntegerParameterTypeT>>,
  pub FLOAT_TYPES: Option<Vec<FloatParameterTypeT>>,
  pub STRING_TYPES: Option<Vec<StringParameterTypeT>>,
  pub BOOLEAN_TYPES: Option<Vec<BooleanParameterTypeT>>,
  pub ENUMERATED_TYPES: Option<Vec<EnumeratedParameterTypeT>>,
  pub BINARY_TYPES: Option<Vec<BinaryParameterTypeT>>,
  pub ABSOLUTE_TIME_TYPES: Option<Vec<AbsoluteTimeParameterTypeT>>,
  pub RELATIVE_TIME_TYPES: Option<Vec<RelativeTimeParameterTypeT>>,
  pub ARRAY_TYPES: Option<Vec<ArrayParameterTypeT>>,
  pub AGGREGATE_TYPES: Option<Vec<AggregateParameterTypeT>>,
}
impl Default for ParameterTypeSetT {
  fn default() -> Self {
    Self {
      INTEGER_TYPES: None,
      FLOAT_TYPES: None,
      STRING_TYPES: None,
      BOOLEAN_TYPES: None,
      ENUMERATED_TYPES: None,
      BINARY_TYPES: None,
      ABSOLUTE_TIME_TYPES: None,
      RELATIVE_TIME_TYPES: None,
      ARRAY_TYPES: None,
      AGGREGATE_TYPES: None,
    }
  }
}
impl ParameterTypeSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParameterTypeSet<'b>> {
    let INTEGER_TYPES = self.INTEGER_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let FLOAT_TYPES = self.FLOAT_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let STRING_TYPES = self.STRING_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BOOLEAN_TYPES = self.BOOLEAN_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ENUMERATED_TYPES = self.ENUMERATED_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BINARY_TYPES = self.BINARY_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ABSOLUTE_TIME_TYPES = self.ABSOLUTE_TIME_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let RELATIVE_TIME_TYPES = self.RELATIVE_TIME_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ARRAY_TYPES = self.ARRAY_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let AGGREGATE_TYPES = self.AGGREGATE_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ParameterTypeSet::create(_fbb, &ParameterTypeSetArgs{
      INTEGER_TYPES,
      FLOAT_TYPES,
      STRING_TYPES,
      BOOLEAN_TYPES,
      ENUMERATED_TYPES,
      BINARY_TYPES,
      ABSOLUTE_TIME_TYPES,
      RELATIVE_TIME_TYPES,
      ARRAY_TYPES,
      AGGREGATE_TYPES,
    })
  }
}
pub enum ParameterPropertiesOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Parameter properties
pub struct ParameterProperties<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParameterProperties<'a> {
  type Inner = ParameterProperties<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParameterProperties<'a> {
  pub const VT_DATA_SOURCE: flatbuffers::VOffsetT = 4;
  pub const VT_READ_ONLY: flatbuffers::VOffsetT = 6;
  pub const VT_SYSTEM_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_VALIDITY_CONDITION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParameterProperties { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterPropertiesArgs<'args>
  ) -> flatbuffers::WIPOffset<ParameterProperties<'bldr>> {
    let mut builder = ParameterPropertiesBuilder::new(_fbb);
    if let Some(x) = args.VALIDITY_CONDITION { builder.add_VALIDITY_CONDITION(x); }
    if let Some(x) = args.SYSTEM_NAME { builder.add_SYSTEM_NAME(x); }
    builder.add_READ_ONLY(args.READ_ONLY);
    builder.add_DATA_SOURCE(args.DATA_SOURCE);
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterPropertiesT {
    let DATA_SOURCE = self.DATA_SOURCE();
    let READ_ONLY = self.READ_ONLY();
    let SYSTEM_NAME = self.SYSTEM_NAME().map(|x| {
      x.to_string()
    });
    let VALIDITY_CONDITION = self.VALIDITY_CONDITION().map(|x| {
      Box::new(x.unpack())
    });
    ParameterPropertiesT {
      DATA_SOURCE,
      READ_ONLY,
      SYSTEM_NAME,
      VALIDITY_CONDITION,
    }
  }

  /// Data source type
  #[inline]
  pub fn DATA_SOURCE(&self) -> DataSourceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DataSourceType>(ParameterProperties::VT_DATA_SOURCE, Some(DataSourceType::TELEMETERED)).unwrap()}
  }
  /// Read-only parameter
  #[inline]
  pub fn READ_ONLY(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ParameterProperties::VT_READ_ONLY, Some(true)).unwrap()}
  }
  /// System/subsystem name
  #[inline]
  pub fn SYSTEM_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParameterProperties::VT_SYSTEM_NAME, None)}
  }
  /// Validity condition
  #[inline]
  pub fn VALIDITY_CONDITION(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(ParameterProperties::VT_VALIDITY_CONDITION, None)}
  }
}

impl flatbuffers::Verifiable for ParameterProperties<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DataSourceType>("DATA_SOURCE", Self::VT_DATA_SOURCE, false)?
     .visit_field::<bool>("READ_ONLY", Self::VT_READ_ONLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SYSTEM_NAME", Self::VT_SYSTEM_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("VALIDITY_CONDITION", Self::VT_VALIDITY_CONDITION, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterPropertiesArgs<'a> {
    pub DATA_SOURCE: DataSourceType,
    pub READ_ONLY: bool,
    pub SYSTEM_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALIDITY_CONDITION: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
}
impl<'a> Default for ParameterPropertiesArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterPropertiesArgs {
      DATA_SOURCE: DataSourceType::TELEMETERED,
      READ_ONLY: true,
      SYSTEM_NAME: None,
      VALIDITY_CONDITION: None,
    }
  }
}

pub struct ParameterPropertiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterPropertiesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_DATA_SOURCE(&mut self, DATA_SOURCE: DataSourceType) {
    self.fbb_.push_slot::<DataSourceType>(ParameterProperties::VT_DATA_SOURCE, DATA_SOURCE, DataSourceType::TELEMETERED);
  }
  #[inline]
  pub fn add_READ_ONLY(&mut self, READ_ONLY: bool) {
    self.fbb_.push_slot::<bool>(ParameterProperties::VT_READ_ONLY, READ_ONLY, true);
  }
  #[inline]
  pub fn add_SYSTEM_NAME(&mut self, SYSTEM_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterProperties::VT_SYSTEM_NAME, SYSTEM_NAME);
  }
  #[inline]
  pub fn add_VALIDITY_CONDITION(&mut self, VALIDITY_CONDITION: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(ParameterProperties::VT_VALIDITY_CONDITION, VALIDITY_CONDITION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterPropertiesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterPropertiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParameterProperties<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParameterProperties<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParameterProperties");
      ds.field("DATA_SOURCE", &self.DATA_SOURCE());
      ds.field("READ_ONLY", &self.READ_ONLY());
      ds.field("SYSTEM_NAME", &self.SYSTEM_NAME());
      ds.field("VALIDITY_CONDITION", &self.VALIDITY_CONDITION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterPropertiesT {
  pub DATA_SOURCE: DataSourceType,
  pub READ_ONLY: bool,
  pub SYSTEM_NAME: Option<String>,
  pub VALIDITY_CONDITION: Option<Box<MatchCriteriaT>>,
}
impl Default for ParameterPropertiesT {
  fn default() -> Self {
    Self {
      DATA_SOURCE: DataSourceType::TELEMETERED,
      READ_ONLY: true,
      SYSTEM_NAME: None,
      VALIDITY_CONDITION: None,
    }
  }
}
impl ParameterPropertiesT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParameterProperties<'b>> {
    let DATA_SOURCE = self.DATA_SOURCE;
    let READ_ONLY = self.READ_ONLY;
    let SYSTEM_NAME = self.SYSTEM_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALIDITY_CONDITION = self.VALIDITY_CONDITION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    ParameterProperties::create(_fbb, &ParameterPropertiesArgs{
      DATA_SOURCE,
      READ_ONLY,
      SYSTEM_NAME,
      VALIDITY_CONDITION,
    })
  }
}
pub enum ParameterOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Parameter definition
pub struct Parameter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Parameter<'a> {
  type Inner = Parameter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Parameter<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER_TYPE_REF: flatbuffers::VOffsetT = 6;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 12;
  pub const VT_PHYSICAL_ADDRESS: flatbuffers::VOffsetT = 14;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Parameter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterArgs<'args>
  ) -> flatbuffers::WIPOffset<Parameter<'bldr>> {
    let mut builder = ParameterBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.PHYSICAL_ADDRESS { builder.add_PHYSICAL_ADDRESS(x); }
    if let Some(x) = args.PROPERTIES { builder.add_PROPERTIES(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.PARAMETER_TYPE_REF { builder.add_PARAMETER_TYPE_REF(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let PARAMETER_TYPE_REF = self.PARAMETER_TYPE_REF().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let PROPERTIES = self.PROPERTIES().map(|x| {
      Box::new(x.unpack())
    });
    let PHYSICAL_ADDRESS = self.PHYSICAL_ADDRESS().map(|x| {
      x.to_string()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    ParameterT {
      NAME,
      PARAMETER_TYPE_REF,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      PROPERTIES,
      PHYSICAL_ADDRESS,
      INITIAL_VALUE,
    }
  }

  /// Parameter name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_NAME, None)}
  }
  /// Reference to parameter type
  #[inline]
  pub fn PARAMETER_TYPE_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_PARAMETER_TYPE_REF, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_LONG_DESCRIPTION, None)}
  }
  /// Parameter properties
  #[inline]
  pub fn PROPERTIES(&self) -> Option<ParameterProperties<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterProperties>>(Parameter::VT_PROPERTIES, None)}
  }
  /// Physical address mapping
  #[inline]
  pub fn PHYSICAL_ADDRESS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_PHYSICAL_ADDRESS, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Parameter::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Parameter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_TYPE_REF", Self::VT_PARAMETER_TYPE_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterProperties>>("PROPERTIES", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PHYSICAL_ADDRESS", Self::VT_PHYSICAL_ADDRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PARAMETER_TYPE_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PROPERTIES: Option<flatbuffers::WIPOffset<ParameterProperties<'a>>>,
    pub PHYSICAL_ADDRESS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ParameterArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterArgs {
      NAME: None,
      PARAMETER_TYPE_REF: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      PROPERTIES: None,
      PHYSICAL_ADDRESS: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct ParameterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_PARAMETER_TYPE_REF(&mut self, PARAMETER_TYPE_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_PARAMETER_TYPE_REF, PARAMETER_TYPE_REF);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_PROPERTIES(&mut self, PROPERTIES: flatbuffers::WIPOffset<ParameterProperties<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterProperties>>(Parameter::VT_PROPERTIES, PROPERTIES);
  }
  #[inline]
  pub fn add_PHYSICAL_ADDRESS(&mut self, PHYSICAL_ADDRESS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_PHYSICAL_ADDRESS, PHYSICAL_ADDRESS);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Parameter::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Parameter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Parameter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Parameter");
      ds.field("NAME", &self.NAME());
      ds.field("PARAMETER_TYPE_REF", &self.PARAMETER_TYPE_REF());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("PROPERTIES", &self.PROPERTIES());
      ds.field("PHYSICAL_ADDRESS", &self.PHYSICAL_ADDRESS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterT {
  pub NAME: Option<String>,
  pub PARAMETER_TYPE_REF: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub PROPERTIES: Option<Box<ParameterPropertiesT>>,
  pub PHYSICAL_ADDRESS: Option<String>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for ParameterT {
  fn default() -> Self {
    Self {
      NAME: None,
      PARAMETER_TYPE_REF: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      PROPERTIES: None,
      PHYSICAL_ADDRESS: None,
      INITIAL_VALUE: None,
    }
  }
}
impl ParameterT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Parameter<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PARAMETER_TYPE_REF = self.PARAMETER_TYPE_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PROPERTIES = self.PROPERTIES.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PHYSICAL_ADDRESS = self.PHYSICAL_ADDRESS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Parameter::create(_fbb, &ParameterArgs{
      NAME,
      PARAMETER_TYPE_REF,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      PROPERTIES,
      PHYSICAL_ADDRESS,
      INITIAL_VALUE,
    })
  }
}
pub enum ParameterSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of parameters
pub struct ParameterSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParameterSet<'a> {
  type Inner = ParameterSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParameterSet<'a> {
  pub const VT_PARAMETERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParameterSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ParameterSet<'bldr>> {
    let mut builder = ParameterSetBuilder::new(_fbb);
    if let Some(x) = args.PARAMETERS { builder.add_PARAMETERS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterSetT {
    let PARAMETERS = self.PARAMETERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ParameterSetT {
      PARAMETERS,
    }
  }

  /// Parameters
  #[inline]
  pub fn PARAMETERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter>>>>(ParameterSet::VT_PARAMETERS, None)}
  }
}

impl flatbuffers::Verifiable for ParameterSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Parameter>>>>("PARAMETERS", Self::VT_PARAMETERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterSetArgs<'a> {
    pub PARAMETERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Parameter<'a>>>>>,
}
impl<'a> Default for ParameterSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterSetArgs {
      PARAMETERS: None,
    }
  }
}

pub struct ParameterSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETERS(&mut self, PARAMETERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Parameter<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterSet::VT_PARAMETERS, PARAMETERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParameterSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParameterSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParameterSet");
      ds.field("PARAMETERS", &self.PARAMETERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterSetT {
  pub PARAMETERS: Option<Vec<ParameterT>>,
}
impl Default for ParameterSetT {
  fn default() -> Self {
    Self {
      PARAMETERS: None,
    }
  }
}
impl ParameterSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParameterSet<'b>> {
    let PARAMETERS = self.PARAMETERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ParameterSet::create(_fbb, &ParameterSetArgs{
      PARAMETERS,
    })
  }
}
pub enum LocationInContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Location specification within a container
pub struct LocationInContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LocationInContainer<'a> {
  type Inner = LocationInContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LocationInContainer<'a> {
  pub const VT_REFERENCE_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET_IN_BITS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LocationInContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LocationInContainerArgs
  ) -> flatbuffers::WIPOffset<LocationInContainer<'bldr>> {
    let mut builder = LocationInContainerBuilder::new(_fbb);
    builder.add_OFFSET_IN_BITS(args.OFFSET_IN_BITS);
    builder.add_REFERENCE_LOCATION(args.REFERENCE_LOCATION);
    builder.finish()
  }

  pub fn unpack(&self) -> LocationInContainerT {
    let REFERENCE_LOCATION = self.REFERENCE_LOCATION();
    let OFFSET_IN_BITS = self.OFFSET_IN_BITS();
    LocationInContainerT {
      REFERENCE_LOCATION,
      OFFSET_IN_BITS,
    }
  }

  /// Reference location type
  #[inline]
  pub fn REFERENCE_LOCATION(&self) -> ReferenceLocationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ReferenceLocationType>(LocationInContainer::VT_REFERENCE_LOCATION, Some(ReferenceLocationType::PREVIOUS_ENTRY)).unwrap()}
  }
  /// Offset in bits from reference location
  #[inline]
  pub fn OFFSET_IN_BITS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LocationInContainer::VT_OFFSET_IN_BITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LocationInContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ReferenceLocationType>("REFERENCE_LOCATION", Self::VT_REFERENCE_LOCATION, false)?
     .visit_field::<i32>("OFFSET_IN_BITS", Self::VT_OFFSET_IN_BITS, false)?
     .finish();
    Ok(())
  }
}
pub struct LocationInContainerArgs {
    pub REFERENCE_LOCATION: ReferenceLocationType,
    pub OFFSET_IN_BITS: i32,
}
impl<'a> Default for LocationInContainerArgs {
  #[inline]
  fn default() -> Self {
    LocationInContainerArgs {
      REFERENCE_LOCATION: ReferenceLocationType::PREVIOUS_ENTRY,
      OFFSET_IN_BITS: 0,
    }
  }
}

pub struct LocationInContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LocationInContainerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_REFERENCE_LOCATION(&mut self, REFERENCE_LOCATION: ReferenceLocationType) {
    self.fbb_.push_slot::<ReferenceLocationType>(LocationInContainer::VT_REFERENCE_LOCATION, REFERENCE_LOCATION, ReferenceLocationType::PREVIOUS_ENTRY);
  }
  #[inline]
  pub fn add_OFFSET_IN_BITS(&mut self, OFFSET_IN_BITS: i32) {
    self.fbb_.push_slot::<i32>(LocationInContainer::VT_OFFSET_IN_BITS, OFFSET_IN_BITS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LocationInContainerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LocationInContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LocationInContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LocationInContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LocationInContainer");
      ds.field("REFERENCE_LOCATION", &self.REFERENCE_LOCATION());
      ds.field("OFFSET_IN_BITS", &self.OFFSET_IN_BITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LocationInContainerT {
  pub REFERENCE_LOCATION: ReferenceLocationType,
  pub OFFSET_IN_BITS: i32,
}
impl Default for LocationInContainerT {
  fn default() -> Self {
    Self {
      REFERENCE_LOCATION: ReferenceLocationType::PREVIOUS_ENTRY,
      OFFSET_IN_BITS: 0,
    }
  }
}
impl LocationInContainerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<LocationInContainer<'b>> {
    let REFERENCE_LOCATION = self.REFERENCE_LOCATION;
    let OFFSET_IN_BITS = self.OFFSET_IN_BITS;
    LocationInContainer::create(_fbb, &LocationInContainerArgs{
      REFERENCE_LOCATION,
      OFFSET_IN_BITS,
    })
  }
}
pub enum RepeatEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Repeat entry specification
pub struct RepeatEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RepeatEntry<'a> {
  type Inner = RepeatEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RepeatEntry<'a> {
  pub const VT_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_COUNT_PARAMETER_REF: flatbuffers::VOffsetT = 6;
  pub const VT_OFFSET_IN_BITS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RepeatEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RepeatEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<RepeatEntry<'bldr>> {
    let mut builder = RepeatEntryBuilder::new(_fbb);
    builder.add_OFFSET_IN_BITS(args.OFFSET_IN_BITS);
    if let Some(x) = args.COUNT_PARAMETER_REF { builder.add_COUNT_PARAMETER_REF(x); }
    builder.add_COUNT(args.COUNT);
    builder.finish()
  }

  pub fn unpack(&self) -> RepeatEntryT {
    let COUNT = self.COUNT();
    let COUNT_PARAMETER_REF = self.COUNT_PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let OFFSET_IN_BITS = self.OFFSET_IN_BITS();
    RepeatEntryT {
      COUNT,
      COUNT_PARAMETER_REF,
      OFFSET_IN_BITS,
    }
  }

  /// Fixed repeat count
  #[inline]
  pub fn COUNT(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RepeatEntry::VT_COUNT, Some(0)).unwrap()}
  }
  /// Dynamic count from parameter reference
  #[inline]
  pub fn COUNT_PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RepeatEntry::VT_COUNT_PARAMETER_REF, None)}
  }
  /// Offset in bits between repetitions
  #[inline]
  pub fn OFFSET_IN_BITS(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RepeatEntry::VT_OFFSET_IN_BITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RepeatEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("COUNT", Self::VT_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COUNT_PARAMETER_REF", Self::VT_COUNT_PARAMETER_REF, false)?
     .visit_field::<i32>("OFFSET_IN_BITS", Self::VT_OFFSET_IN_BITS, false)?
     .finish();
    Ok(())
  }
}
pub struct RepeatEntryArgs<'a> {
    pub COUNT: u32,
    pub COUNT_PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OFFSET_IN_BITS: i32,
}
impl<'a> Default for RepeatEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    RepeatEntryArgs {
      COUNT: 0,
      COUNT_PARAMETER_REF: None,
      OFFSET_IN_BITS: 0,
    }
  }
}

pub struct RepeatEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RepeatEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COUNT(&mut self, COUNT: u32) {
    self.fbb_.push_slot::<u32>(RepeatEntry::VT_COUNT, COUNT, 0);
  }
  #[inline]
  pub fn add_COUNT_PARAMETER_REF(&mut self, COUNT_PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RepeatEntry::VT_COUNT_PARAMETER_REF, COUNT_PARAMETER_REF);
  }
  #[inline]
  pub fn add_OFFSET_IN_BITS(&mut self, OFFSET_IN_BITS: i32) {
    self.fbb_.push_slot::<i32>(RepeatEntry::VT_OFFSET_IN_BITS, OFFSET_IN_BITS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RepeatEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RepeatEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RepeatEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RepeatEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RepeatEntry");
      ds.field("COUNT", &self.COUNT());
      ds.field("COUNT_PARAMETER_REF", &self.COUNT_PARAMETER_REF());
      ds.field("OFFSET_IN_BITS", &self.OFFSET_IN_BITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RepeatEntryT {
  pub COUNT: u32,
  pub COUNT_PARAMETER_REF: Option<String>,
  pub OFFSET_IN_BITS: i32,
}
impl Default for RepeatEntryT {
  fn default() -> Self {
    Self {
      COUNT: 0,
      COUNT_PARAMETER_REF: None,
      OFFSET_IN_BITS: 0,
    }
  }
}
impl RepeatEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RepeatEntry<'b>> {
    let COUNT = self.COUNT;
    let COUNT_PARAMETER_REF = self.COUNT_PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OFFSET_IN_BITS = self.OFFSET_IN_BITS;
    RepeatEntry::create(_fbb, &RepeatEntryArgs{
      COUNT,
      COUNT_PARAMETER_REF,
      OFFSET_IN_BITS,
    })
  }
}
pub enum ParameterRefEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Parameter reference entry in container
pub struct ParameterRefEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParameterRefEntry<'a> {
  type Inner = ParameterRefEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParameterRefEntry<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_REPEAT: flatbuffers::VOffsetT = 8;
  pub const VT_INCLUDE_CONDITION: flatbuffers::VOffsetT = 10;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParameterRefEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParameterRefEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ParameterRefEntry<'bldr>> {
    let mut builder = ParameterRefEntryBuilder::new(_fbb);
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.INCLUDE_CONDITION { builder.add_INCLUDE_CONDITION(x); }
    if let Some(x) = args.REPEAT { builder.add_REPEAT(x); }
    if let Some(x) = args.LOCATION { builder.add_LOCATION(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ParameterRefEntryT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let LOCATION = self.LOCATION().map(|x| {
      Box::new(x.unpack())
    });
    let REPEAT = self.REPEAT().map(|x| {
      Box::new(x.unpack())
    });
    let INCLUDE_CONDITION = self.INCLUDE_CONDITION().map(|x| {
      Box::new(x.unpack())
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    ParameterRefEntryT {
      PARAMETER_REF,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION,
      SHORT_DESCRIPTION,
    }
  }

  /// Parameter reference path
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParameterRefEntry::VT_PARAMETER_REF, None)}
  }
  /// Location in container
  #[inline]
  pub fn LOCATION(&self) -> Option<LocationInContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LocationInContainer>>(ParameterRefEntry::VT_LOCATION, None)}
  }
  /// Repeat specification
  #[inline]
  pub fn REPEAT(&self) -> Option<RepeatEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RepeatEntry>>(ParameterRefEntry::VT_REPEAT, None)}
  }
  /// Include condition
  #[inline]
  pub fn INCLUDE_CONDITION(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(ParameterRefEntry::VT_INCLUDE_CONDITION, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParameterRefEntry::VT_SHORT_DESCRIPTION, None)}
  }
}

impl flatbuffers::Verifiable for ParameterRefEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LocationInContainer>>("LOCATION", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RepeatEntry>>("REPEAT", Self::VT_REPEAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("INCLUDE_CONDITION", Self::VT_INCLUDE_CONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ParameterRefEntryArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCATION: Option<flatbuffers::WIPOffset<LocationInContainer<'a>>>,
    pub REPEAT: Option<flatbuffers::WIPOffset<RepeatEntry<'a>>>,
    pub INCLUDE_CONDITION: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ParameterRefEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParameterRefEntryArgs {
      PARAMETER_REF: None,
      LOCATION: None,
      REPEAT: None,
      INCLUDE_CONDITION: None,
      SHORT_DESCRIPTION: None,
    }
  }
}

pub struct ParameterRefEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParameterRefEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterRefEntry::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_LOCATION(&mut self, LOCATION: flatbuffers::WIPOffset<LocationInContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LocationInContainer>>(ParameterRefEntry::VT_LOCATION, LOCATION);
  }
  #[inline]
  pub fn add_REPEAT(&mut self, REPEAT: flatbuffers::WIPOffset<RepeatEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RepeatEntry>>(ParameterRefEntry::VT_REPEAT, REPEAT);
  }
  #[inline]
  pub fn add_INCLUDE_CONDITION(&mut self, INCLUDE_CONDITION: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(ParameterRefEntry::VT_INCLUDE_CONDITION, INCLUDE_CONDITION);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParameterRefEntry::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParameterRefEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParameterRefEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParameterRefEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParameterRefEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParameterRefEntry");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("LOCATION", &self.LOCATION());
      ds.field("REPEAT", &self.REPEAT());
      ds.field("INCLUDE_CONDITION", &self.INCLUDE_CONDITION());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ParameterRefEntryT {
  pub PARAMETER_REF: Option<String>,
  pub LOCATION: Option<Box<LocationInContainerT>>,
  pub REPEAT: Option<Box<RepeatEntryT>>,
  pub INCLUDE_CONDITION: Option<Box<MatchCriteriaT>>,
  pub SHORT_DESCRIPTION: Option<String>,
}
impl Default for ParameterRefEntryT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      LOCATION: None,
      REPEAT: None,
      INCLUDE_CONDITION: None,
      SHORT_DESCRIPTION: None,
    }
  }
}
impl ParameterRefEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ParameterRefEntry<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCATION = self.LOCATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let REPEAT = self.REPEAT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INCLUDE_CONDITION = self.INCLUDE_CONDITION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ParameterRefEntry::create(_fbb, &ParameterRefEntryArgs{
      PARAMETER_REF,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION,
      SHORT_DESCRIPTION,
    })
  }
}
pub enum ContainerRefEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Container reference entry (nested container)
pub struct ContainerRefEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerRefEntry<'a> {
  type Inner = ContainerRefEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerRefEntry<'a> {
  pub const VT_CONTAINER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_REPEAT: flatbuffers::VOffsetT = 8;
  pub const VT_INCLUDE_CONDITION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerRefEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerRefEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerRefEntry<'bldr>> {
    let mut builder = ContainerRefEntryBuilder::new(_fbb);
    if let Some(x) = args.INCLUDE_CONDITION { builder.add_INCLUDE_CONDITION(x); }
    if let Some(x) = args.REPEAT { builder.add_REPEAT(x); }
    if let Some(x) = args.LOCATION { builder.add_LOCATION(x); }
    if let Some(x) = args.CONTAINER_REF { builder.add_CONTAINER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContainerRefEntryT {
    let CONTAINER_REF = self.CONTAINER_REF().map(|x| {
      x.to_string()
    });
    let LOCATION = self.LOCATION().map(|x| {
      Box::new(x.unpack())
    });
    let REPEAT = self.REPEAT().map(|x| {
      Box::new(x.unpack())
    });
    let INCLUDE_CONDITION = self.INCLUDE_CONDITION().map(|x| {
      Box::new(x.unpack())
    });
    ContainerRefEntryT {
      CONTAINER_REF,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION,
    }
  }

  /// Container reference path
  #[inline]
  pub fn CONTAINER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContainerRefEntry::VT_CONTAINER_REF, None)}
  }
  /// Location in container
  #[inline]
  pub fn LOCATION(&self) -> Option<LocationInContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LocationInContainer>>(ContainerRefEntry::VT_LOCATION, None)}
  }
  /// Repeat specification
  #[inline]
  pub fn REPEAT(&self) -> Option<RepeatEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RepeatEntry>>(ContainerRefEntry::VT_REPEAT, None)}
  }
  /// Include condition
  #[inline]
  pub fn INCLUDE_CONDITION(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(ContainerRefEntry::VT_INCLUDE_CONDITION, None)}
  }
}

impl flatbuffers::Verifiable for ContainerRefEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTAINER_REF", Self::VT_CONTAINER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LocationInContainer>>("LOCATION", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RepeatEntry>>("REPEAT", Self::VT_REPEAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("INCLUDE_CONDITION", Self::VT_INCLUDE_CONDITION, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerRefEntryArgs<'a> {
    pub CONTAINER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCATION: Option<flatbuffers::WIPOffset<LocationInContainer<'a>>>,
    pub REPEAT: Option<flatbuffers::WIPOffset<RepeatEntry<'a>>>,
    pub INCLUDE_CONDITION: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
}
impl<'a> Default for ContainerRefEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerRefEntryArgs {
      CONTAINER_REF: None,
      LOCATION: None,
      REPEAT: None,
      INCLUDE_CONDITION: None,
    }
  }
}

pub struct ContainerRefEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerRefEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CONTAINER_REF(&mut self, CONTAINER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerRefEntry::VT_CONTAINER_REF, CONTAINER_REF);
  }
  #[inline]
  pub fn add_LOCATION(&mut self, LOCATION: flatbuffers::WIPOffset<LocationInContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LocationInContainer>>(ContainerRefEntry::VT_LOCATION, LOCATION);
  }
  #[inline]
  pub fn add_REPEAT(&mut self, REPEAT: flatbuffers::WIPOffset<RepeatEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RepeatEntry>>(ContainerRefEntry::VT_REPEAT, REPEAT);
  }
  #[inline]
  pub fn add_INCLUDE_CONDITION(&mut self, INCLUDE_CONDITION: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(ContainerRefEntry::VT_INCLUDE_CONDITION, INCLUDE_CONDITION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerRefEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerRefEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerRefEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerRefEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerRefEntry");
      ds.field("CONTAINER_REF", &self.CONTAINER_REF());
      ds.field("LOCATION", &self.LOCATION());
      ds.field("REPEAT", &self.REPEAT());
      ds.field("INCLUDE_CONDITION", &self.INCLUDE_CONDITION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContainerRefEntryT {
  pub CONTAINER_REF: Option<String>,
  pub LOCATION: Option<Box<LocationInContainerT>>,
  pub REPEAT: Option<Box<RepeatEntryT>>,
  pub INCLUDE_CONDITION: Option<Box<MatchCriteriaT>>,
}
impl Default for ContainerRefEntryT {
  fn default() -> Self {
    Self {
      CONTAINER_REF: None,
      LOCATION: None,
      REPEAT: None,
      INCLUDE_CONDITION: None,
    }
  }
}
impl ContainerRefEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContainerRefEntry<'b>> {
    let CONTAINER_REF = self.CONTAINER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCATION = self.LOCATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let REPEAT = self.REPEAT.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INCLUDE_CONDITION = self.INCLUDE_CONDITION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    ContainerRefEntry::create(_fbb, &ContainerRefEntryArgs{
      CONTAINER_REF,
      LOCATION,
      REPEAT,
      INCLUDE_CONDITION,
    })
  }
}
pub enum FixedValueEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Fixed value entry (static padding/header)
pub struct FixedValueEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FixedValueEntry<'a> {
  type Inner = FixedValueEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FixedValueEntry<'a> {
  pub const VT_BINARY_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FixedValueEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FixedValueEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<FixedValueEntry<'bldr>> {
    let mut builder = FixedValueEntryBuilder::new(_fbb);
    if let Some(x) = args.LOCATION { builder.add_LOCATION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    if let Some(x) = args.BINARY_VALUE { builder.add_BINARY_VALUE(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.finish()
  }

  pub fn unpack(&self) -> FixedValueEntryT {
    let BINARY_VALUE = self.BINARY_VALUE().map(|x| {
      x.to_string()
    });
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let LOCATION = self.LOCATION().map(|x| {
      Box::new(x.unpack())
    });
    FixedValueEntryT {
      BINARY_VALUE,
      SIZE_IN_BITS,
      NAME,
      LOCATION,
    }
  }

  /// Binary value (hex string)
  #[inline]
  pub fn BINARY_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FixedValueEntry::VT_BINARY_VALUE, None)}
  }
  /// Size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(FixedValueEntry::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Name/description
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FixedValueEntry::VT_NAME, None)}
  }
  /// Location in container
  #[inline]
  pub fn LOCATION(&self) -> Option<LocationInContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LocationInContainer>>(FixedValueEntry::VT_LOCATION, None)}
  }
}

impl flatbuffers::Verifiable for FixedValueEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("BINARY_VALUE", Self::VT_BINARY_VALUE, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LocationInContainer>>("LOCATION", Self::VT_LOCATION, false)?
     .finish();
    Ok(())
  }
}
pub struct FixedValueEntryArgs<'a> {
    pub BINARY_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIZE_IN_BITS: u16,
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCATION: Option<flatbuffers::WIPOffset<LocationInContainer<'a>>>,
}
impl<'a> Default for FixedValueEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    FixedValueEntryArgs {
      BINARY_VALUE: None,
      SIZE_IN_BITS: 0,
      NAME: None,
      LOCATION: None,
    }
  }
}

pub struct FixedValueEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FixedValueEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_BINARY_VALUE(&mut self, BINARY_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedValueEntry::VT_BINARY_VALUE, BINARY_VALUE);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(FixedValueEntry::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedValueEntry::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_LOCATION(&mut self, LOCATION: flatbuffers::WIPOffset<LocationInContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LocationInContainer>>(FixedValueEntry::VT_LOCATION, LOCATION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FixedValueEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FixedValueEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FixedValueEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FixedValueEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FixedValueEntry");
      ds.field("BINARY_VALUE", &self.BINARY_VALUE());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("NAME", &self.NAME());
      ds.field("LOCATION", &self.LOCATION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FixedValueEntryT {
  pub BINARY_VALUE: Option<String>,
  pub SIZE_IN_BITS: u16,
  pub NAME: Option<String>,
  pub LOCATION: Option<Box<LocationInContainerT>>,
}
impl Default for FixedValueEntryT {
  fn default() -> Self {
    Self {
      BINARY_VALUE: None,
      SIZE_IN_BITS: 0,
      NAME: None,
      LOCATION: None,
    }
  }
}
impl FixedValueEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FixedValueEntry<'b>> {
    let BINARY_VALUE = self.BINARY_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCATION = self.LOCATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    FixedValueEntry::create(_fbb, &FixedValueEntryArgs{
      BINARY_VALUE,
      SIZE_IN_BITS,
      NAME,
      LOCATION,
    })
  }
}
pub enum ArrayParameterRefEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Array parameter reference entry
pub struct ArrayParameterRefEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArrayParameterRefEntry<'a> {
  type Inner = ArrayParameterRefEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArrayParameterRefEntry<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_FIRST_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_LAST_INDEX: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArrayParameterRefEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArrayParameterRefEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ArrayParameterRefEntry<'bldr>> {
    let mut builder = ArrayParameterRefEntryBuilder::new(_fbb);
    builder.add_LAST_INDEX(args.LAST_INDEX);
    builder.add_FIRST_INDEX(args.FIRST_INDEX);
    if let Some(x) = args.LOCATION { builder.add_LOCATION(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArrayParameterRefEntryT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let LOCATION = self.LOCATION().map(|x| {
      Box::new(x.unpack())
    });
    let FIRST_INDEX = self.FIRST_INDEX();
    let LAST_INDEX = self.LAST_INDEX();
    ArrayParameterRefEntryT {
      PARAMETER_REF,
      LOCATION,
      FIRST_INDEX,
      LAST_INDEX,
    }
  }

  /// Parameter reference path
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArrayParameterRefEntry::VT_PARAMETER_REF, None)}
  }
  /// Location in container
  #[inline]
  pub fn LOCATION(&self) -> Option<LocationInContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LocationInContainer>>(ArrayParameterRefEntry::VT_LOCATION, None)}
  }
  /// First index to include
  #[inline]
  pub fn FIRST_INDEX(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ArrayParameterRefEntry::VT_FIRST_INDEX, Some(0)).unwrap()}
  }
  /// Last index to include
  #[inline]
  pub fn LAST_INDEX(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ArrayParameterRefEntry::VT_LAST_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ArrayParameterRefEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LocationInContainer>>("LOCATION", Self::VT_LOCATION, false)?
     .visit_field::<u32>("FIRST_INDEX", Self::VT_FIRST_INDEX, false)?
     .visit_field::<u32>("LAST_INDEX", Self::VT_LAST_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct ArrayParameterRefEntryArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCATION: Option<flatbuffers::WIPOffset<LocationInContainer<'a>>>,
    pub FIRST_INDEX: u32,
    pub LAST_INDEX: u32,
}
impl<'a> Default for ArrayParameterRefEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArrayParameterRefEntryArgs {
      PARAMETER_REF: None,
      LOCATION: None,
      FIRST_INDEX: 0,
      LAST_INDEX: 0,
    }
  }
}

pub struct ArrayParameterRefEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArrayParameterRefEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArrayParameterRefEntry::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_LOCATION(&mut self, LOCATION: flatbuffers::WIPOffset<LocationInContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LocationInContainer>>(ArrayParameterRefEntry::VT_LOCATION, LOCATION);
  }
  #[inline]
  pub fn add_FIRST_INDEX(&mut self, FIRST_INDEX: u32) {
    self.fbb_.push_slot::<u32>(ArrayParameterRefEntry::VT_FIRST_INDEX, FIRST_INDEX, 0);
  }
  #[inline]
  pub fn add_LAST_INDEX(&mut self, LAST_INDEX: u32) {
    self.fbb_.push_slot::<u32>(ArrayParameterRefEntry::VT_LAST_INDEX, LAST_INDEX, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArrayParameterRefEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArrayParameterRefEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArrayParameterRefEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArrayParameterRefEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArrayParameterRefEntry");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("LOCATION", &self.LOCATION());
      ds.field("FIRST_INDEX", &self.FIRST_INDEX());
      ds.field("LAST_INDEX", &self.LAST_INDEX());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArrayParameterRefEntryT {
  pub PARAMETER_REF: Option<String>,
  pub LOCATION: Option<Box<LocationInContainerT>>,
  pub FIRST_INDEX: u32,
  pub LAST_INDEX: u32,
}
impl Default for ArrayParameterRefEntryT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      LOCATION: None,
      FIRST_INDEX: 0,
      LAST_INDEX: 0,
    }
  }
}
impl ArrayParameterRefEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArrayParameterRefEntry<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCATION = self.LOCATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let FIRST_INDEX = self.FIRST_INDEX;
    let LAST_INDEX = self.LAST_INDEX;
    ArrayParameterRefEntry::create(_fbb, &ArrayParameterRefEntryArgs{
      PARAMETER_REF,
      LOCATION,
      FIRST_INDEX,
      LAST_INDEX,
    })
  }
}
pub enum ContainerEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Container entry list item (union of entry types)
pub struct ContainerEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerEntry<'a> {
  type Inner = ContainerEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerEntry<'a> {
  pub const VT_PARAMETER_REF_ENTRY: flatbuffers::VOffsetT = 4;
  pub const VT_CONTAINER_REF_ENTRY: flatbuffers::VOffsetT = 6;
  pub const VT_FIXED_VALUE_ENTRY: flatbuffers::VOffsetT = 8;
  pub const VT_ARRAY_PARAMETER_REF_ENTRY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerEntry<'bldr>> {
    let mut builder = ContainerEntryBuilder::new(_fbb);
    if let Some(x) = args.ARRAY_PARAMETER_REF_ENTRY { builder.add_ARRAY_PARAMETER_REF_ENTRY(x); }
    if let Some(x) = args.FIXED_VALUE_ENTRY { builder.add_FIXED_VALUE_ENTRY(x); }
    if let Some(x) = args.CONTAINER_REF_ENTRY { builder.add_CONTAINER_REF_ENTRY(x); }
    if let Some(x) = args.PARAMETER_REF_ENTRY { builder.add_PARAMETER_REF_ENTRY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContainerEntryT {
    let PARAMETER_REF_ENTRY = self.PARAMETER_REF_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    let CONTAINER_REF_ENTRY = self.CONTAINER_REF_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    let FIXED_VALUE_ENTRY = self.FIXED_VALUE_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    let ARRAY_PARAMETER_REF_ENTRY = self.ARRAY_PARAMETER_REF_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    ContainerEntryT {
      PARAMETER_REF_ENTRY,
      CONTAINER_REF_ENTRY,
      FIXED_VALUE_ENTRY,
      ARRAY_PARAMETER_REF_ENTRY,
    }
  }

  /// Parameter reference entry
  #[inline]
  pub fn PARAMETER_REF_ENTRY(&self) -> Option<ParameterRefEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterRefEntry>>(ContainerEntry::VT_PARAMETER_REF_ENTRY, None)}
  }
  /// Container reference entry
  #[inline]
  pub fn CONTAINER_REF_ENTRY(&self) -> Option<ContainerRefEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerRefEntry>>(ContainerEntry::VT_CONTAINER_REF_ENTRY, None)}
  }
  /// Fixed value entry
  #[inline]
  pub fn FIXED_VALUE_ENTRY(&self) -> Option<FixedValueEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FixedValueEntry>>(ContainerEntry::VT_FIXED_VALUE_ENTRY, None)}
  }
  /// Array parameter reference entry
  #[inline]
  pub fn ARRAY_PARAMETER_REF_ENTRY(&self) -> Option<ArrayParameterRefEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ArrayParameterRefEntry>>(ContainerEntry::VT_ARRAY_PARAMETER_REF_ENTRY, None)}
  }
}

impl flatbuffers::Verifiable for ContainerEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterRefEntry>>("PARAMETER_REF_ENTRY", Self::VT_PARAMETER_REF_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerRefEntry>>("CONTAINER_REF_ENTRY", Self::VT_CONTAINER_REF_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FixedValueEntry>>("FIXED_VALUE_ENTRY", Self::VT_FIXED_VALUE_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ArrayParameterRefEntry>>("ARRAY_PARAMETER_REF_ENTRY", Self::VT_ARRAY_PARAMETER_REF_ENTRY, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerEntryArgs<'a> {
    pub PARAMETER_REF_ENTRY: Option<flatbuffers::WIPOffset<ParameterRefEntry<'a>>>,
    pub CONTAINER_REF_ENTRY: Option<flatbuffers::WIPOffset<ContainerRefEntry<'a>>>,
    pub FIXED_VALUE_ENTRY: Option<flatbuffers::WIPOffset<FixedValueEntry<'a>>>,
    pub ARRAY_PARAMETER_REF_ENTRY: Option<flatbuffers::WIPOffset<ArrayParameterRefEntry<'a>>>,
}
impl<'a> Default for ContainerEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerEntryArgs {
      PARAMETER_REF_ENTRY: None,
      CONTAINER_REF_ENTRY: None,
      FIXED_VALUE_ENTRY: None,
      ARRAY_PARAMETER_REF_ENTRY: None,
    }
  }
}

pub struct ContainerEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF_ENTRY(&mut self, PARAMETER_REF_ENTRY: flatbuffers::WIPOffset<ParameterRefEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterRefEntry>>(ContainerEntry::VT_PARAMETER_REF_ENTRY, PARAMETER_REF_ENTRY);
  }
  #[inline]
  pub fn add_CONTAINER_REF_ENTRY(&mut self, CONTAINER_REF_ENTRY: flatbuffers::WIPOffset<ContainerRefEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerRefEntry>>(ContainerEntry::VT_CONTAINER_REF_ENTRY, CONTAINER_REF_ENTRY);
  }
  #[inline]
  pub fn add_FIXED_VALUE_ENTRY(&mut self, FIXED_VALUE_ENTRY: flatbuffers::WIPOffset<FixedValueEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FixedValueEntry>>(ContainerEntry::VT_FIXED_VALUE_ENTRY, FIXED_VALUE_ENTRY);
  }
  #[inline]
  pub fn add_ARRAY_PARAMETER_REF_ENTRY(&mut self, ARRAY_PARAMETER_REF_ENTRY: flatbuffers::WIPOffset<ArrayParameterRefEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ArrayParameterRefEntry>>(ContainerEntry::VT_ARRAY_PARAMETER_REF_ENTRY, ARRAY_PARAMETER_REF_ENTRY);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerEntry");
      ds.field("PARAMETER_REF_ENTRY", &self.PARAMETER_REF_ENTRY());
      ds.field("CONTAINER_REF_ENTRY", &self.CONTAINER_REF_ENTRY());
      ds.field("FIXED_VALUE_ENTRY", &self.FIXED_VALUE_ENTRY());
      ds.field("ARRAY_PARAMETER_REF_ENTRY", &self.ARRAY_PARAMETER_REF_ENTRY());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContainerEntryT {
  pub PARAMETER_REF_ENTRY: Option<Box<ParameterRefEntryT>>,
  pub CONTAINER_REF_ENTRY: Option<Box<ContainerRefEntryT>>,
  pub FIXED_VALUE_ENTRY: Option<Box<FixedValueEntryT>>,
  pub ARRAY_PARAMETER_REF_ENTRY: Option<Box<ArrayParameterRefEntryT>>,
}
impl Default for ContainerEntryT {
  fn default() -> Self {
    Self {
      PARAMETER_REF_ENTRY: None,
      CONTAINER_REF_ENTRY: None,
      FIXED_VALUE_ENTRY: None,
      ARRAY_PARAMETER_REF_ENTRY: None,
    }
  }
}
impl ContainerEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContainerEntry<'b>> {
    let PARAMETER_REF_ENTRY = self.PARAMETER_REF_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTAINER_REF_ENTRY = self.CONTAINER_REF_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let FIXED_VALUE_ENTRY = self.FIXED_VALUE_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ARRAY_PARAMETER_REF_ENTRY = self.ARRAY_PARAMETER_REF_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    ContainerEntry::create(_fbb, &ContainerEntryArgs{
      PARAMETER_REF_ENTRY,
      CONTAINER_REF_ENTRY,
      FIXED_VALUE_ENTRY,
      ARRAY_PARAMETER_REF_ENTRY,
    })
  }
}
pub enum BaseContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Base container reference with restriction
pub struct BaseContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BaseContainer<'a> {
  type Inner = BaseContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BaseContainer<'a> {
  pub const VT_CONTAINER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_RESTRICTION_CRITERIA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BaseContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BaseContainerArgs<'args>
  ) -> flatbuffers::WIPOffset<BaseContainer<'bldr>> {
    let mut builder = BaseContainerBuilder::new(_fbb);
    if let Some(x) = args.RESTRICTION_CRITERIA { builder.add_RESTRICTION_CRITERIA(x); }
    if let Some(x) = args.CONTAINER_REF { builder.add_CONTAINER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BaseContainerT {
    let CONTAINER_REF = self.CONTAINER_REF().map(|x| {
      x.to_string()
    });
    let RESTRICTION_CRITERIA = self.RESTRICTION_CRITERIA().map(|x| {
      Box::new(x.unpack())
    });
    BaseContainerT {
      CONTAINER_REF,
      RESTRICTION_CRITERIA,
    }
  }

  /// Container reference path
  #[inline]
  pub fn CONTAINER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BaseContainer::VT_CONTAINER_REF, None)}
  }
  /// Restriction criteria
  #[inline]
  pub fn RESTRICTION_CRITERIA(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(BaseContainer::VT_RESTRICTION_CRITERIA, None)}
  }
}

impl flatbuffers::Verifiable for BaseContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTAINER_REF", Self::VT_CONTAINER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("RESTRICTION_CRITERIA", Self::VT_RESTRICTION_CRITERIA, false)?
     .finish();
    Ok(())
  }
}
pub struct BaseContainerArgs<'a> {
    pub CONTAINER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RESTRICTION_CRITERIA: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
}
impl<'a> Default for BaseContainerArgs<'a> {
  #[inline]
  fn default() -> Self {
    BaseContainerArgs {
      CONTAINER_REF: None,
      RESTRICTION_CRITERIA: None,
    }
  }
}

pub struct BaseContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BaseContainerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CONTAINER_REF(&mut self, CONTAINER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BaseContainer::VT_CONTAINER_REF, CONTAINER_REF);
  }
  #[inline]
  pub fn add_RESTRICTION_CRITERIA(&mut self, RESTRICTION_CRITERIA: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(BaseContainer::VT_RESTRICTION_CRITERIA, RESTRICTION_CRITERIA);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BaseContainerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BaseContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BaseContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BaseContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BaseContainer");
      ds.field("CONTAINER_REF", &self.CONTAINER_REF());
      ds.field("RESTRICTION_CRITERIA", &self.RESTRICTION_CRITERIA());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BaseContainerT {
  pub CONTAINER_REF: Option<String>,
  pub RESTRICTION_CRITERIA: Option<Box<MatchCriteriaT>>,
}
impl Default for BaseContainerT {
  fn default() -> Self {
    Self {
      CONTAINER_REF: None,
      RESTRICTION_CRITERIA: None,
    }
  }
}
impl BaseContainerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BaseContainer<'b>> {
    let CONTAINER_REF = self.CONTAINER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RESTRICTION_CRITERIA = self.RESTRICTION_CRITERIA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    BaseContainer::create(_fbb, &BaseContainerArgs{
      CONTAINER_REF,
      RESTRICTION_CRITERIA,
    })
  }
}
pub enum RateInStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rate specification for container in stream
pub struct RateInStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RateInStream<'a> {
  type Inner = RateInStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RateInStream<'a> {
  pub const VT_STREAM_REF: flatbuffers::VOffsetT = 4;
  pub const VT_RATE: flatbuffers::VOffsetT = 6;
  pub const VT_BASIS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RateInStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RateInStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<RateInStream<'bldr>> {
    let mut builder = RateInStreamBuilder::new(_fbb);
    builder.add_RATE(args.RATE);
    if let Some(x) = args.STREAM_REF { builder.add_STREAM_REF(x); }
    builder.add_BASIS(args.BASIS);
    builder.finish()
  }

  pub fn unpack(&self) -> RateInStreamT {
    let STREAM_REF = self.STREAM_REF().map(|x| {
      x.to_string()
    });
    let RATE = self.RATE();
    let BASIS = self.BASIS();
    RateInStreamT {
      STREAM_REF,
      RATE,
      BASIS,
    }
  }

  /// Stream reference
  #[inline]
  pub fn STREAM_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RateInStream::VT_STREAM_REF, None)}
  }
  /// Rate value
  #[inline]
  pub fn RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RateInStream::VT_RATE, Some(0.0)).unwrap()}
  }
  /// Rate basis
  #[inline]
  pub fn BASIS(&self) -> RateBasisType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RateBasisType>(RateInStream::VT_BASIS, Some(RateBasisType::PER_SECOND)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RateInStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("STREAM_REF", Self::VT_STREAM_REF, false)?
     .visit_field::<f64>("RATE", Self::VT_RATE, false)?
     .visit_field::<RateBasisType>("BASIS", Self::VT_BASIS, false)?
     .finish();
    Ok(())
  }
}
pub struct RateInStreamArgs<'a> {
    pub STREAM_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RATE: f64,
    pub BASIS: RateBasisType,
}
impl<'a> Default for RateInStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    RateInStreamArgs {
      STREAM_REF: None,
      RATE: 0.0,
      BASIS: RateBasisType::PER_SECOND,
    }
  }
}

pub struct RateInStreamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RateInStreamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_STREAM_REF(&mut self, STREAM_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RateInStream::VT_STREAM_REF, STREAM_REF);
  }
  #[inline]
  pub fn add_RATE(&mut self, RATE: f64) {
    self.fbb_.push_slot::<f64>(RateInStream::VT_RATE, RATE, 0.0);
  }
  #[inline]
  pub fn add_BASIS(&mut self, BASIS: RateBasisType) {
    self.fbb_.push_slot::<RateBasisType>(RateInStream::VT_BASIS, BASIS, RateBasisType::PER_SECOND);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RateInStreamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RateInStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RateInStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RateInStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RateInStream");
      ds.field("STREAM_REF", &self.STREAM_REF());
      ds.field("RATE", &self.RATE());
      ds.field("BASIS", &self.BASIS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RateInStreamT {
  pub STREAM_REF: Option<String>,
  pub RATE: f64,
  pub BASIS: RateBasisType,
}
impl Default for RateInStreamT {
  fn default() -> Self {
    Self {
      STREAM_REF: None,
      RATE: 0.0,
      BASIS: RateBasisType::PER_SECOND,
    }
  }
}
impl RateInStreamT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RateInStream<'b>> {
    let STREAM_REF = self.STREAM_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RATE = self.RATE;
    let BASIS = self.BASIS;
    RateInStream::create(_fbb, &RateInStreamArgs{
      STREAM_REF,
      RATE,
      BASIS,
    })
  }
}
pub enum ContainerBinaryEncodingOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Binary encoding specification for container
pub struct ContainerBinaryEncoding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerBinaryEncoding<'a> {
  type Inner = ContainerBinaryEncoding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerBinaryEncoding<'a> {
  pub const VT_ERROR_DETECTION: flatbuffers::VOffsetT = 4;
  pub const VT_CRC_POLYNOMIAL: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerBinaryEncoding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerBinaryEncodingArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerBinaryEncoding<'bldr>> {
    let mut builder = ContainerBinaryEncodingBuilder::new(_fbb);
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    if let Some(x) = args.CRC_POLYNOMIAL { builder.add_CRC_POLYNOMIAL(x); }
    builder.add_ERROR_DETECTION(args.ERROR_DETECTION);
    builder.finish()
  }

  pub fn unpack(&self) -> ContainerBinaryEncodingT {
    let ERROR_DETECTION = self.ERROR_DETECTION();
    let CRC_POLYNOMIAL = self.CRC_POLYNOMIAL().map(|x| {
      x.to_string()
    });
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    ContainerBinaryEncodingT {
      ERROR_DETECTION,
      CRC_POLYNOMIAL,
      SIZE_IN_BITS,
    }
  }

  /// Error detection type
  #[inline]
  pub fn ERROR_DETECTION(&self) -> ErrorDetectionType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ErrorDetectionType>(ContainerBinaryEncoding::VT_ERROR_DETECTION, Some(ErrorDetectionType::NONE)).unwrap()}
  }
  /// CRC polynomial (for CRC error detection)
  #[inline]
  pub fn CRC_POLYNOMIAL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContainerBinaryEncoding::VT_CRC_POLYNOMIAL, None)}
  }
  /// Size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ContainerBinaryEncoding::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContainerBinaryEncoding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ErrorDetectionType>("ERROR_DETECTION", Self::VT_ERROR_DETECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CRC_POLYNOMIAL", Self::VT_CRC_POLYNOMIAL, false)?
     .visit_field::<u32>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerBinaryEncodingArgs<'a> {
    pub ERROR_DETECTION: ErrorDetectionType,
    pub CRC_POLYNOMIAL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SIZE_IN_BITS: u32,
}
impl<'a> Default for ContainerBinaryEncodingArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerBinaryEncodingArgs {
      ERROR_DETECTION: ErrorDetectionType::NONE,
      CRC_POLYNOMIAL: None,
      SIZE_IN_BITS: 0,
    }
  }
}

pub struct ContainerBinaryEncodingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerBinaryEncodingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ERROR_DETECTION(&mut self, ERROR_DETECTION: ErrorDetectionType) {
    self.fbb_.push_slot::<ErrorDetectionType>(ContainerBinaryEncoding::VT_ERROR_DETECTION, ERROR_DETECTION, ErrorDetectionType::NONE);
  }
  #[inline]
  pub fn add_CRC_POLYNOMIAL(&mut self, CRC_POLYNOMIAL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerBinaryEncoding::VT_CRC_POLYNOMIAL, CRC_POLYNOMIAL);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u32) {
    self.fbb_.push_slot::<u32>(ContainerBinaryEncoding::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerBinaryEncodingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerBinaryEncodingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerBinaryEncoding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerBinaryEncoding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerBinaryEncoding");
      ds.field("ERROR_DETECTION", &self.ERROR_DETECTION());
      ds.field("CRC_POLYNOMIAL", &self.CRC_POLYNOMIAL());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContainerBinaryEncodingT {
  pub ERROR_DETECTION: ErrorDetectionType,
  pub CRC_POLYNOMIAL: Option<String>,
  pub SIZE_IN_BITS: u32,
}
impl Default for ContainerBinaryEncodingT {
  fn default() -> Self {
    Self {
      ERROR_DETECTION: ErrorDetectionType::NONE,
      CRC_POLYNOMIAL: None,
      SIZE_IN_BITS: 0,
    }
  }
}
impl ContainerBinaryEncodingT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContainerBinaryEncoding<'b>> {
    let ERROR_DETECTION = self.ERROR_DETECTION;
    let CRC_POLYNOMIAL = self.CRC_POLYNOMIAL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    ContainerBinaryEncoding::create(_fbb, &ContainerBinaryEncodingArgs{
      ERROR_DETECTION,
      CRC_POLYNOMIAL,
      SIZE_IN_BITS,
    })
  }
}
pub enum SequenceContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sequence container (packet definition)
pub struct SequenceContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SequenceContainer<'a> {
  type Inner = SequenceContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SequenceContainer<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_ABSTRACT: flatbuffers::VOffsetT = 10;
  pub const VT_ENTRY_LIST: flatbuffers::VOffsetT = 12;
  pub const VT_BASE_CONTAINER: flatbuffers::VOffsetT = 14;
  pub const VT_BINARY_ENCODING: flatbuffers::VOffsetT = 16;
  pub const VT_RATE_IN_STREAM: flatbuffers::VOffsetT = 18;
  pub const VT_IDLE_PATTERN: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SequenceContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SequenceContainerArgs<'args>
  ) -> flatbuffers::WIPOffset<SequenceContainer<'bldr>> {
    let mut builder = SequenceContainerBuilder::new(_fbb);
    if let Some(x) = args.IDLE_PATTERN { builder.add_IDLE_PATTERN(x); }
    if let Some(x) = args.RATE_IN_STREAM { builder.add_RATE_IN_STREAM(x); }
    if let Some(x) = args.BINARY_ENCODING { builder.add_BINARY_ENCODING(x); }
    if let Some(x) = args.BASE_CONTAINER { builder.add_BASE_CONTAINER(x); }
    if let Some(x) = args.ENTRY_LIST { builder.add_ENTRY_LIST(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_ABSTRACT(args.ABSTRACT);
    builder.finish()
  }

  pub fn unpack(&self) -> SequenceContainerT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let ABSTRACT = self.ABSTRACT();
    let ENTRY_LIST = self.ENTRY_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BASE_CONTAINER = self.BASE_CONTAINER().map(|x| {
      Box::new(x.unpack())
    });
    let BINARY_ENCODING = self.BINARY_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let RATE_IN_STREAM = self.RATE_IN_STREAM().map(|x| {
      Box::new(x.unpack())
    });
    let IDLE_PATTERN = self.IDLE_PATTERN().map(|x| {
      x.to_string()
    });
    SequenceContainerT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ABSTRACT,
      ENTRY_LIST,
      BASE_CONTAINER,
      BINARY_ENCODING,
      RATE_IN_STREAM,
      IDLE_PATTERN,
    }
  }

  /// Container name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SequenceContainer::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SequenceContainer::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SequenceContainer::VT_LONG_DESCRIPTION, None)}
  }
  /// Abstract container (used as base only)
  #[inline]
  pub fn ABSTRACT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SequenceContainer::VT_ABSTRACT, Some(false)).unwrap()}
  }
  /// Container entry list
  #[inline]
  pub fn ENTRY_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContainerEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContainerEntry>>>>(SequenceContainer::VT_ENTRY_LIST, None)}
  }
  /// Base container (inheritance)
  #[inline]
  pub fn BASE_CONTAINER(&self) -> Option<BaseContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BaseContainer>>(SequenceContainer::VT_BASE_CONTAINER, None)}
  }
  /// Binary encoding
  #[inline]
  pub fn BINARY_ENCODING(&self) -> Option<ContainerBinaryEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerBinaryEncoding>>(SequenceContainer::VT_BINARY_ENCODING, None)}
  }
  /// Rate in stream
  #[inline]
  pub fn RATE_IN_STREAM(&self) -> Option<RateInStream<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RateInStream>>(SequenceContainer::VT_RATE_IN_STREAM, None)}
  }
  /// Idle pattern (hex string for padding)
  #[inline]
  pub fn IDLE_PATTERN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SequenceContainer::VT_IDLE_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for SequenceContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<bool>("ABSTRACT", Self::VT_ABSTRACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContainerEntry>>>>("ENTRY_LIST", Self::VT_ENTRY_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseContainer>>("BASE_CONTAINER", Self::VT_BASE_CONTAINER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerBinaryEncoding>>("BINARY_ENCODING", Self::VT_BINARY_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RateInStream>>("RATE_IN_STREAM", Self::VT_RATE_IN_STREAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("IDLE_PATTERN", Self::VT_IDLE_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct SequenceContainerArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ABSTRACT: bool,
    pub ENTRY_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContainerEntry<'a>>>>>,
    pub BASE_CONTAINER: Option<flatbuffers::WIPOffset<BaseContainer<'a>>>,
    pub BINARY_ENCODING: Option<flatbuffers::WIPOffset<ContainerBinaryEncoding<'a>>>,
    pub RATE_IN_STREAM: Option<flatbuffers::WIPOffset<RateInStream<'a>>>,
    pub IDLE_PATTERN: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SequenceContainerArgs<'a> {
  #[inline]
  fn default() -> Self {
    SequenceContainerArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ABSTRACT: false,
      ENTRY_LIST: None,
      BASE_CONTAINER: None,
      BINARY_ENCODING: None,
      RATE_IN_STREAM: None,
      IDLE_PATTERN: None,
    }
  }
}

pub struct SequenceContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SequenceContainerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceContainer::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceContainer::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceContainer::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_ABSTRACT(&mut self, ABSTRACT: bool) {
    self.fbb_.push_slot::<bool>(SequenceContainer::VT_ABSTRACT, ABSTRACT, false);
  }
  #[inline]
  pub fn add_ENTRY_LIST(&mut self, ENTRY_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContainerEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceContainer::VT_ENTRY_LIST, ENTRY_LIST);
  }
  #[inline]
  pub fn add_BASE_CONTAINER(&mut self, BASE_CONTAINER: flatbuffers::WIPOffset<BaseContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BaseContainer>>(SequenceContainer::VT_BASE_CONTAINER, BASE_CONTAINER);
  }
  #[inline]
  pub fn add_BINARY_ENCODING(&mut self, BINARY_ENCODING: flatbuffers::WIPOffset<ContainerBinaryEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerBinaryEncoding>>(SequenceContainer::VT_BINARY_ENCODING, BINARY_ENCODING);
  }
  #[inline]
  pub fn add_RATE_IN_STREAM(&mut self, RATE_IN_STREAM: flatbuffers::WIPOffset<RateInStream<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RateInStream>>(SequenceContainer::VT_RATE_IN_STREAM, RATE_IN_STREAM);
  }
  #[inline]
  pub fn add_IDLE_PATTERN(&mut self, IDLE_PATTERN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SequenceContainer::VT_IDLE_PATTERN, IDLE_PATTERN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SequenceContainerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SequenceContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SequenceContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SequenceContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SequenceContainer");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("ABSTRACT", &self.ABSTRACT());
      ds.field("ENTRY_LIST", &self.ENTRY_LIST());
      ds.field("BASE_CONTAINER", &self.BASE_CONTAINER());
      ds.field("BINARY_ENCODING", &self.BINARY_ENCODING());
      ds.field("RATE_IN_STREAM", &self.RATE_IN_STREAM());
      ds.field("IDLE_PATTERN", &self.IDLE_PATTERN());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SequenceContainerT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub ABSTRACT: bool,
  pub ENTRY_LIST: Option<Vec<ContainerEntryT>>,
  pub BASE_CONTAINER: Option<Box<BaseContainerT>>,
  pub BINARY_ENCODING: Option<Box<ContainerBinaryEncodingT>>,
  pub RATE_IN_STREAM: Option<Box<RateInStreamT>>,
  pub IDLE_PATTERN: Option<String>,
}
impl Default for SequenceContainerT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ABSTRACT: false,
      ENTRY_LIST: None,
      BASE_CONTAINER: None,
      BINARY_ENCODING: None,
      RATE_IN_STREAM: None,
      IDLE_PATTERN: None,
    }
  }
}
impl SequenceContainerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<SequenceContainer<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ABSTRACT = self.ABSTRACT;
    let ENTRY_LIST = self.ENTRY_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BASE_CONTAINER = self.BASE_CONTAINER.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let BINARY_ENCODING = self.BINARY_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let RATE_IN_STREAM = self.RATE_IN_STREAM.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let IDLE_PATTERN = self.IDLE_PATTERN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SequenceContainer::create(_fbb, &SequenceContainerArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ABSTRACT,
      ENTRY_LIST,
      BASE_CONTAINER,
      BINARY_ENCODING,
      RATE_IN_STREAM,
      IDLE_PATTERN,
    })
  }
}
pub enum ContainerSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of sequence containers
pub struct ContainerSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContainerSet<'a> {
  type Inner = ContainerSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContainerSet<'a> {
  pub const VT_CONTAINERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContainerSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContainerSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ContainerSet<'bldr>> {
    let mut builder = ContainerSetBuilder::new(_fbb);
    if let Some(x) = args.CONTAINERS { builder.add_CONTAINERS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ContainerSetT {
    let CONTAINERS = self.CONTAINERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ContainerSetT {
      CONTAINERS,
    }
  }

  /// Sequence containers
  #[inline]
  pub fn CONTAINERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequenceContainer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequenceContainer>>>>(ContainerSet::VT_CONTAINERS, None)}
  }
}

impl flatbuffers::Verifiable for ContainerSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SequenceContainer>>>>("CONTAINERS", Self::VT_CONTAINERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContainerSetArgs<'a> {
    pub CONTAINERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SequenceContainer<'a>>>>>,
}
impl<'a> Default for ContainerSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContainerSetArgs {
      CONTAINERS: None,
    }
  }
}

pub struct ContainerSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContainerSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CONTAINERS(&mut self, CONTAINERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SequenceContainer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContainerSet::VT_CONTAINERS, CONTAINERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContainerSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContainerSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContainerSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContainerSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContainerSet");
      ds.field("CONTAINERS", &self.CONTAINERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ContainerSetT {
  pub CONTAINERS: Option<Vec<SequenceContainerT>>,
}
impl Default for ContainerSetT {
  fn default() -> Self {
    Self {
      CONTAINERS: None,
    }
  }
}
impl ContainerSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ContainerSet<'b>> {
    let CONTAINERS = self.CONTAINERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ContainerSet::create(_fbb, &ContainerSetArgs{
      CONTAINERS,
    })
  }
}
pub enum AlgorithmInputOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Algorithm input binding
pub struct AlgorithmInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlgorithmInput<'a> {
  type Inner = AlgorithmInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlgorithmInput<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_INPUT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlgorithmInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlgorithmInputArgs<'args>
  ) -> flatbuffers::WIPOffset<AlgorithmInput<'bldr>> {
    let mut builder = AlgorithmInputBuilder::new(_fbb);
    if let Some(x) = args.INPUT_NAME { builder.add_INPUT_NAME(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AlgorithmInputT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let INPUT_NAME = self.INPUT_NAME().map(|x| {
      x.to_string()
    });
    AlgorithmInputT {
      PARAMETER_REF,
      INPUT_NAME,
    }
  }

  /// Parameter reference
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmInput::VT_PARAMETER_REF, None)}
  }
  /// Input name in algorithm
  #[inline]
  pub fn INPUT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmInput::VT_INPUT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for AlgorithmInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INPUT_NAME", Self::VT_INPUT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct AlgorithmInputArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INPUT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AlgorithmInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    AlgorithmInputArgs {
      PARAMETER_REF: None,
      INPUT_NAME: None,
    }
  }
}

pub struct AlgorithmInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlgorithmInputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmInput::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_INPUT_NAME(&mut self, INPUT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmInput::VT_INPUT_NAME, INPUT_NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlgorithmInputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlgorithmInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlgorithmInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlgorithmInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlgorithmInput");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("INPUT_NAME", &self.INPUT_NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AlgorithmInputT {
  pub PARAMETER_REF: Option<String>,
  pub INPUT_NAME: Option<String>,
}
impl Default for AlgorithmInputT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      INPUT_NAME: None,
    }
  }
}
impl AlgorithmInputT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AlgorithmInput<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INPUT_NAME = self.INPUT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AlgorithmInput::create(_fbb, &AlgorithmInputArgs{
      PARAMETER_REF,
      INPUT_NAME,
    })
  }
}
pub enum AlgorithmOutputOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Algorithm output binding
pub struct AlgorithmOutput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlgorithmOutput<'a> {
  type Inner = AlgorithmOutput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlgorithmOutput<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlgorithmOutput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlgorithmOutputArgs<'args>
  ) -> flatbuffers::WIPOffset<AlgorithmOutput<'bldr>> {
    let mut builder = AlgorithmOutputBuilder::new(_fbb);
    if let Some(x) = args.OUTPUT_NAME { builder.add_OUTPUT_NAME(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AlgorithmOutputT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let OUTPUT_NAME = self.OUTPUT_NAME().map(|x| {
      x.to_string()
    });
    AlgorithmOutputT {
      PARAMETER_REF,
      OUTPUT_NAME,
    }
  }

  /// Parameter reference
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmOutput::VT_PARAMETER_REF, None)}
  }
  /// Output name in algorithm
  #[inline]
  pub fn OUTPUT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmOutput::VT_OUTPUT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for AlgorithmOutput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OUTPUT_NAME", Self::VT_OUTPUT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct AlgorithmOutputArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OUTPUT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AlgorithmOutputArgs<'a> {
  #[inline]
  fn default() -> Self {
    AlgorithmOutputArgs {
      PARAMETER_REF: None,
      OUTPUT_NAME: None,
    }
  }
}

pub struct AlgorithmOutputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlgorithmOutputBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmOutput::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_OUTPUT_NAME(&mut self, OUTPUT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmOutput::VT_OUTPUT_NAME, OUTPUT_NAME);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlgorithmOutputBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlgorithmOutputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlgorithmOutput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlgorithmOutput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlgorithmOutput");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("OUTPUT_NAME", &self.OUTPUT_NAME());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AlgorithmOutputT {
  pub PARAMETER_REF: Option<String>,
  pub OUTPUT_NAME: Option<String>,
}
impl Default for AlgorithmOutputT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      OUTPUT_NAME: None,
    }
  }
}
impl AlgorithmOutputT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AlgorithmOutput<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OUTPUT_NAME = self.OUTPUT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    AlgorithmOutput::create(_fbb, &AlgorithmOutputArgs{
      PARAMETER_REF,
      OUTPUT_NAME,
    })
  }
}
pub enum AlgorithmTriggerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Trigger condition for algorithm execution
pub struct AlgorithmTrigger<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlgorithmTrigger<'a> {
  type Inner = AlgorithmTrigger<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlgorithmTrigger<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_CONTAINER_REF: flatbuffers::VOffsetT = 6;
  pub const VT_RATE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlgorithmTrigger { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlgorithmTriggerArgs<'args>
  ) -> flatbuffers::WIPOffset<AlgorithmTrigger<'bldr>> {
    let mut builder = AlgorithmTriggerBuilder::new(_fbb);
    builder.add_RATE(args.RATE);
    if let Some(x) = args.CONTAINER_REF { builder.add_CONTAINER_REF(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AlgorithmTriggerT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let CONTAINER_REF = self.CONTAINER_REF().map(|x| {
      x.to_string()
    });
    let RATE = self.RATE();
    AlgorithmTriggerT {
      PARAMETER_REF,
      CONTAINER_REF,
      RATE,
    }
  }

  /// Trigger on parameter update
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmTrigger::VT_PARAMETER_REF, None)}
  }
  /// Trigger on container reception
  #[inline]
  pub fn CONTAINER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AlgorithmTrigger::VT_CONTAINER_REF, None)}
  }
  /// Trigger rate (per second)
  #[inline]
  pub fn RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AlgorithmTrigger::VT_RATE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AlgorithmTrigger<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTAINER_REF", Self::VT_CONTAINER_REF, false)?
     .visit_field::<f64>("RATE", Self::VT_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct AlgorithmTriggerArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTAINER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RATE: f64,
}
impl<'a> Default for AlgorithmTriggerArgs<'a> {
  #[inline]
  fn default() -> Self {
    AlgorithmTriggerArgs {
      PARAMETER_REF: None,
      CONTAINER_REF: None,
      RATE: 0.0,
    }
  }
}

pub struct AlgorithmTriggerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlgorithmTriggerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmTrigger::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_CONTAINER_REF(&mut self, CONTAINER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmTrigger::VT_CONTAINER_REF, CONTAINER_REF);
  }
  #[inline]
  pub fn add_RATE(&mut self, RATE: f64) {
    self.fbb_.push_slot::<f64>(AlgorithmTrigger::VT_RATE, RATE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlgorithmTriggerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlgorithmTriggerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlgorithmTrigger<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlgorithmTrigger<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlgorithmTrigger");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("CONTAINER_REF", &self.CONTAINER_REF());
      ds.field("RATE", &self.RATE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AlgorithmTriggerT {
  pub PARAMETER_REF: Option<String>,
  pub CONTAINER_REF: Option<String>,
  pub RATE: f64,
}
impl Default for AlgorithmTriggerT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      CONTAINER_REF: None,
      RATE: 0.0,
    }
  }
}
impl AlgorithmTriggerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AlgorithmTrigger<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTAINER_REF = self.CONTAINER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RATE = self.RATE;
    AlgorithmTrigger::create(_fbb, &AlgorithmTriggerArgs{
      PARAMETER_REF,
      CONTAINER_REF,
      RATE,
    })
  }
}
pub enum CustomAlgorithmOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Custom algorithm definition
pub struct CustomAlgorithm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomAlgorithm<'a> {
  type Inner = CustomAlgorithm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CustomAlgorithm<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_LANGUAGE: flatbuffers::VOffsetT = 10;
  pub const VT_ALGORITHM_TEXT: flatbuffers::VOffsetT = 12;
  pub const VT_EXTERNAL_ALGORITHM_REF: flatbuffers::VOffsetT = 14;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 16;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 18;
  pub const VT_TRIGGERS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomAlgorithm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CustomAlgorithmArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomAlgorithm<'bldr>> {
    let mut builder = CustomAlgorithmBuilder::new(_fbb);
    if let Some(x) = args.TRIGGERS { builder.add_TRIGGERS(x); }
    if let Some(x) = args.OUTPUTS { builder.add_OUTPUTS(x); }
    if let Some(x) = args.INPUTS { builder.add_INPUTS(x); }
    if let Some(x) = args.EXTERNAL_ALGORITHM_REF { builder.add_EXTERNAL_ALGORITHM_REF(x); }
    if let Some(x) = args.ALGORITHM_TEXT { builder.add_ALGORITHM_TEXT(x); }
    if let Some(x) = args.LANGUAGE { builder.add_LANGUAGE(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CustomAlgorithmT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LANGUAGE = self.LANGUAGE().map(|x| {
      x.to_string()
    });
    let ALGORITHM_TEXT = self.ALGORITHM_TEXT().map(|x| {
      x.to_string()
    });
    let EXTERNAL_ALGORITHM_REF = self.EXTERNAL_ALGORITHM_REF().map(|x| {
      x.to_string()
    });
    let INPUTS = self.INPUTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let OUTPUTS = self.OUTPUTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let TRIGGERS = self.TRIGGERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    CustomAlgorithmT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      LANGUAGE,
      ALGORITHM_TEXT,
      EXTERNAL_ALGORITHM_REF,
      INPUTS,
      OUTPUTS,
      TRIGGERS,
    }
  }

  /// Algorithm name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_LONG_DESCRIPTION, None)}
  }
  /// Programming language
  #[inline]
  pub fn LANGUAGE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_LANGUAGE, None)}
  }
  /// Algorithm text/code
  #[inline]
  pub fn ALGORITHM_TEXT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_ALGORITHM_TEXT, None)}
  }
  /// External algorithm reference
  #[inline]
  pub fn EXTERNAL_ALGORITHM_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomAlgorithm::VT_EXTERNAL_ALGORITHM_REF, None)}
  }
  /// Input bindings
  #[inline]
  pub fn INPUTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmInput<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmInput>>>>(CustomAlgorithm::VT_INPUTS, None)}
  }
  /// Output bindings
  #[inline]
  pub fn OUTPUTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmOutput<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmOutput>>>>(CustomAlgorithm::VT_OUTPUTS, None)}
  }
  /// Trigger conditions
  #[inline]
  pub fn TRIGGERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger>>>>(CustomAlgorithm::VT_TRIGGERS, None)}
  }
}

impl flatbuffers::Verifiable for CustomAlgorithm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LANGUAGE", Self::VT_LANGUAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALGORITHM_TEXT", Self::VT_ALGORITHM_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("EXTERNAL_ALGORITHM_REF", Self::VT_EXTERNAL_ALGORITHM_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AlgorithmInput>>>>("INPUTS", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AlgorithmOutput>>>>("OUTPUTS", Self::VT_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AlgorithmTrigger>>>>("TRIGGERS", Self::VT_TRIGGERS, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomAlgorithmArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LANGUAGE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALGORITHM_TEXT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub EXTERNAL_ALGORITHM_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INPUTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmInput<'a>>>>>,
    pub OUTPUTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmOutput<'a>>>>>,
    pub TRIGGERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger<'a>>>>>,
}
impl<'a> Default for CustomAlgorithmArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomAlgorithmArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      LANGUAGE: None,
      ALGORITHM_TEXT: None,
      EXTERNAL_ALGORITHM_REF: None,
      INPUTS: None,
      OUTPUTS: None,
      TRIGGERS: None,
    }
  }
}

pub struct CustomAlgorithmBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CustomAlgorithmBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_LANGUAGE(&mut self, LANGUAGE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_LANGUAGE, LANGUAGE);
  }
  #[inline]
  pub fn add_ALGORITHM_TEXT(&mut self, ALGORITHM_TEXT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_ALGORITHM_TEXT, ALGORITHM_TEXT);
  }
  #[inline]
  pub fn add_EXTERNAL_ALGORITHM_REF(&mut self, EXTERNAL_ALGORITHM_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_EXTERNAL_ALGORITHM_REF, EXTERNAL_ALGORITHM_REF);
  }
  #[inline]
  pub fn add_INPUTS(&mut self, INPUTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AlgorithmInput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_INPUTS, INPUTS);
  }
  #[inline]
  pub fn add_OUTPUTS(&mut self, OUTPUTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AlgorithmOutput<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_OUTPUTS, OUTPUTS);
  }
  #[inline]
  pub fn add_TRIGGERS(&mut self, TRIGGERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AlgorithmTrigger<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomAlgorithm::VT_TRIGGERS, TRIGGERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CustomAlgorithmBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CustomAlgorithmBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomAlgorithm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomAlgorithm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomAlgorithm");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("LANGUAGE", &self.LANGUAGE());
      ds.field("ALGORITHM_TEXT", &self.ALGORITHM_TEXT());
      ds.field("EXTERNAL_ALGORITHM_REF", &self.EXTERNAL_ALGORITHM_REF());
      ds.field("INPUTS", &self.INPUTS());
      ds.field("OUTPUTS", &self.OUTPUTS());
      ds.field("TRIGGERS", &self.TRIGGERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CustomAlgorithmT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub LANGUAGE: Option<String>,
  pub ALGORITHM_TEXT: Option<String>,
  pub EXTERNAL_ALGORITHM_REF: Option<String>,
  pub INPUTS: Option<Vec<AlgorithmInputT>>,
  pub OUTPUTS: Option<Vec<AlgorithmOutputT>>,
  pub TRIGGERS: Option<Vec<AlgorithmTriggerT>>,
}
impl Default for CustomAlgorithmT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      LANGUAGE: None,
      ALGORITHM_TEXT: None,
      EXTERNAL_ALGORITHM_REF: None,
      INPUTS: None,
      OUTPUTS: None,
      TRIGGERS: None,
    }
  }
}
impl CustomAlgorithmT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CustomAlgorithm<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LANGUAGE = self.LANGUAGE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALGORITHM_TEXT = self.ALGORITHM_TEXT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let EXTERNAL_ALGORITHM_REF = self.EXTERNAL_ALGORITHM_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INPUTS = self.INPUTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let OUTPUTS = self.OUTPUTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let TRIGGERS = self.TRIGGERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    CustomAlgorithm::create(_fbb, &CustomAlgorithmArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      LANGUAGE,
      ALGORITHM_TEXT,
      EXTERNAL_ALGORITHM_REF,
      INPUTS,
      OUTPUTS,
      TRIGGERS,
    })
  }
}
pub enum MathAlgorithmOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Math algorithm (inline calculation)
pub struct MathAlgorithm<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MathAlgorithm<'a> {
  type Inner = MathAlgorithm<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MathAlgorithm<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_MATH_OPERATION: flatbuffers::VOffsetT = 8;
  pub const VT_OUTPUT_PARAMETER_REF: flatbuffers::VOffsetT = 10;
  pub const VT_TRIGGERS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MathAlgorithm { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MathAlgorithmArgs<'args>
  ) -> flatbuffers::WIPOffset<MathAlgorithm<'bldr>> {
    let mut builder = MathAlgorithmBuilder::new(_fbb);
    if let Some(x) = args.TRIGGERS { builder.add_TRIGGERS(x); }
    if let Some(x) = args.OUTPUT_PARAMETER_REF { builder.add_OUTPUT_PARAMETER_REF(x); }
    if let Some(x) = args.MATH_OPERATION { builder.add_MATH_OPERATION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MathAlgorithmT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MATH_OPERATION = self.MATH_OPERATION().map(|x| {
      x.to_string()
    });
    let OUTPUT_PARAMETER_REF = self.OUTPUT_PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let TRIGGERS = self.TRIGGERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MathAlgorithmT {
      NAME,
      SHORT_DESCRIPTION,
      MATH_OPERATION,
      OUTPUT_PARAMETER_REF,
      TRIGGERS,
    }
  }

  /// Algorithm name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MathAlgorithm::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MathAlgorithm::VT_SHORT_DESCRIPTION, None)}
  }
  /// Math operation in RPN
  #[inline]
  pub fn MATH_OPERATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MathAlgorithm::VT_MATH_OPERATION, None)}
  }
  /// Output parameter reference
  #[inline]
  pub fn OUTPUT_PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MathAlgorithm::VT_OUTPUT_PARAMETER_REF, None)}
  }
  /// Trigger conditions
  #[inline]
  pub fn TRIGGERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger>>>>(MathAlgorithm::VT_TRIGGERS, None)}
  }
}

impl flatbuffers::Verifiable for MathAlgorithm<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MATH_OPERATION", Self::VT_MATH_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OUTPUT_PARAMETER_REF", Self::VT_OUTPUT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AlgorithmTrigger>>>>("TRIGGERS", Self::VT_TRIGGERS, false)?
     .finish();
    Ok(())
  }
}
pub struct MathAlgorithmArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MATH_OPERATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OUTPUT_PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRIGGERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AlgorithmTrigger<'a>>>>>,
}
impl<'a> Default for MathAlgorithmArgs<'a> {
  #[inline]
  fn default() -> Self {
    MathAlgorithmArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      MATH_OPERATION: None,
      OUTPUT_PARAMETER_REF: None,
      TRIGGERS: None,
    }
  }
}

pub struct MathAlgorithmBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MathAlgorithmBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathAlgorithm::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathAlgorithm::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_MATH_OPERATION(&mut self, MATH_OPERATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathAlgorithm::VT_MATH_OPERATION, MATH_OPERATION);
  }
  #[inline]
  pub fn add_OUTPUT_PARAMETER_REF(&mut self, OUTPUT_PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathAlgorithm::VT_OUTPUT_PARAMETER_REF, OUTPUT_PARAMETER_REF);
  }
  #[inline]
  pub fn add_TRIGGERS(&mut self, TRIGGERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AlgorithmTrigger<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MathAlgorithm::VT_TRIGGERS, TRIGGERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MathAlgorithmBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MathAlgorithmBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MathAlgorithm<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MathAlgorithm<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MathAlgorithm");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("MATH_OPERATION", &self.MATH_OPERATION());
      ds.field("OUTPUT_PARAMETER_REF", &self.OUTPUT_PARAMETER_REF());
      ds.field("TRIGGERS", &self.TRIGGERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MathAlgorithmT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub MATH_OPERATION: Option<String>,
  pub OUTPUT_PARAMETER_REF: Option<String>,
  pub TRIGGERS: Option<Vec<AlgorithmTriggerT>>,
}
impl Default for MathAlgorithmT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      MATH_OPERATION: None,
      OUTPUT_PARAMETER_REF: None,
      TRIGGERS: None,
    }
  }
}
impl MathAlgorithmT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MathAlgorithm<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MATH_OPERATION = self.MATH_OPERATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OUTPUT_PARAMETER_REF = self.OUTPUT_PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRIGGERS = self.TRIGGERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MathAlgorithm::create(_fbb, &MathAlgorithmArgs{
      NAME,
      SHORT_DESCRIPTION,
      MATH_OPERATION,
      OUTPUT_PARAMETER_REF,
      TRIGGERS,
    })
  }
}
pub enum AlgorithmSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of algorithms
pub struct AlgorithmSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlgorithmSet<'a> {
  type Inner = AlgorithmSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlgorithmSet<'a> {
  pub const VT_CUSTOM_ALGORITHMS: flatbuffers::VOffsetT = 4;
  pub const VT_MATH_ALGORITHMS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlgorithmSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlgorithmSetArgs<'args>
  ) -> flatbuffers::WIPOffset<AlgorithmSet<'bldr>> {
    let mut builder = AlgorithmSetBuilder::new(_fbb);
    if let Some(x) = args.MATH_ALGORITHMS { builder.add_MATH_ALGORITHMS(x); }
    if let Some(x) = args.CUSTOM_ALGORITHMS { builder.add_CUSTOM_ALGORITHMS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AlgorithmSetT {
    let CUSTOM_ALGORITHMS = self.CUSTOM_ALGORITHMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let MATH_ALGORITHMS = self.MATH_ALGORITHMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    AlgorithmSetT {
      CUSTOM_ALGORITHMS,
      MATH_ALGORITHMS,
    }
  }

  /// Custom algorithms
  #[inline]
  pub fn CUSTOM_ALGORITHMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomAlgorithm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomAlgorithm>>>>(AlgorithmSet::VT_CUSTOM_ALGORITHMS, None)}
  }
  /// Math algorithms
  #[inline]
  pub fn MATH_ALGORITHMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MathAlgorithm<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MathAlgorithm>>>>(AlgorithmSet::VT_MATH_ALGORITHMS, None)}
  }
}

impl flatbuffers::Verifiable for AlgorithmSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CustomAlgorithm>>>>("CUSTOM_ALGORITHMS", Self::VT_CUSTOM_ALGORITHMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MathAlgorithm>>>>("MATH_ALGORITHMS", Self::VT_MATH_ALGORITHMS, false)?
     .finish();
    Ok(())
  }
}
pub struct AlgorithmSetArgs<'a> {
    pub CUSTOM_ALGORITHMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomAlgorithm<'a>>>>>,
    pub MATH_ALGORITHMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MathAlgorithm<'a>>>>>,
}
impl<'a> Default for AlgorithmSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    AlgorithmSetArgs {
      CUSTOM_ALGORITHMS: None,
      MATH_ALGORITHMS: None,
    }
  }
}

pub struct AlgorithmSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlgorithmSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CUSTOM_ALGORITHMS(&mut self, CUSTOM_ALGORITHMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomAlgorithm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmSet::VT_CUSTOM_ALGORITHMS, CUSTOM_ALGORITHMS);
  }
  #[inline]
  pub fn add_MATH_ALGORITHMS(&mut self, MATH_ALGORITHMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MathAlgorithm<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AlgorithmSet::VT_MATH_ALGORITHMS, MATH_ALGORITHMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlgorithmSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlgorithmSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlgorithmSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlgorithmSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlgorithmSet");
      ds.field("CUSTOM_ALGORITHMS", &self.CUSTOM_ALGORITHMS());
      ds.field("MATH_ALGORITHMS", &self.MATH_ALGORITHMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AlgorithmSetT {
  pub CUSTOM_ALGORITHMS: Option<Vec<CustomAlgorithmT>>,
  pub MATH_ALGORITHMS: Option<Vec<MathAlgorithmT>>,
}
impl Default for AlgorithmSetT {
  fn default() -> Self {
    Self {
      CUSTOM_ALGORITHMS: None,
      MATH_ALGORITHMS: None,
    }
  }
}
impl AlgorithmSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AlgorithmSet<'b>> {
    let CUSTOM_ALGORITHMS = self.CUSTOM_ALGORITHMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let MATH_ALGORITHMS = self.MATH_ALGORITHMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    AlgorithmSet::create(_fbb, &AlgorithmSetArgs{
      CUSTOM_ALGORITHMS,
      MATH_ALGORITHMS,
    })
  }
}
pub enum IntegerArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Integer argument type
pub struct IntegerArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IntegerArgumentType<'a> {
  type Inner = IntegerArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IntegerArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_UNITS: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 12;
  pub const VT_VALID_MIN: flatbuffers::VOffsetT = 14;
  pub const VT_VALID_MAX: flatbuffers::VOffsetT = 16;
  pub const VT_SIGNED: flatbuffers::VOffsetT = 18;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 20;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IntegerArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IntegerArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<IntegerArgumentType<'bldr>> {
    let mut builder = IntegerArgumentTypeBuilder::new(_fbb);
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.add_VALID_MAX(args.VALID_MAX);
    builder.add_VALID_MIN(args.VALID_MIN);
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.UNITS { builder.add_UNITS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.add_SIGNED(args.SIGNED);
    builder.finish()
  }

  pub fn unpack(&self) -> IntegerArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let UNITS = self.UNITS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let VALID_MIN = self.VALID_MIN();
    let VALID_MAX = self.VALID_MAX();
    let SIGNED = self.SIGNED();
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let INITIAL_VALUE = self.INITIAL_VALUE();
    IntegerArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(IntegerArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Units
  #[inline]
  pub fn UNITS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(IntegerArgumentType::VT_UNITS, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(IntegerArgumentType::VT_DATA_ENCODING, None)}
  }
  /// Minimum valid value
  #[inline]
  pub fn VALID_MIN(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerArgumentType::VT_VALID_MIN, Some(0)).unwrap()}
  }
  /// Maximum valid value
  #[inline]
  pub fn VALID_MAX(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerArgumentType::VT_VALID_MAX, Some(0)).unwrap()}
  }
  /// Signed integer (true) or unsigned (false)
  #[inline]
  pub fn SIGNED(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(IntegerArgumentType::VT_SIGNED, Some(false)).unwrap()}
  }
  /// Size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(IntegerArgumentType::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(IntegerArgumentType::VT_INITIAL_VALUE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IntegerArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("UNITS", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<i64>("VALID_MIN", Self::VT_VALID_MIN, false)?
     .visit_field::<i64>("VALID_MAX", Self::VT_VALID_MAX, false)?
     .visit_field::<bool>("SIGNED", Self::VT_SIGNED, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<i64>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct IntegerArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UNITS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub VALID_MIN: i64,
    pub VALID_MAX: i64,
    pub SIGNED: bool,
    pub SIZE_IN_BITS: u16,
    pub INITIAL_VALUE: i64,
}
impl<'a> Default for IntegerArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    IntegerArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      VALID_MIN: 0,
      VALID_MAX: 0,
      SIGNED: false,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0,
    }
  }
}

pub struct IntegerArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IntegerArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_UNITS(&mut self, UNITS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(IntegerArgumentType::VT_UNITS, UNITS);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(IntegerArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_VALID_MIN(&mut self, VALID_MIN: i64) {
    self.fbb_.push_slot::<i64>(IntegerArgumentType::VT_VALID_MIN, VALID_MIN, 0);
  }
  #[inline]
  pub fn add_VALID_MAX(&mut self, VALID_MAX: i64) {
    self.fbb_.push_slot::<i64>(IntegerArgumentType::VT_VALID_MAX, VALID_MAX, 0);
  }
  #[inline]
  pub fn add_SIGNED(&mut self, SIGNED: bool) {
    self.fbb_.push_slot::<bool>(IntegerArgumentType::VT_SIGNED, SIGNED, false);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(IntegerArgumentType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: i64) {
    self.fbb_.push_slot::<i64>(IntegerArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IntegerArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IntegerArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IntegerArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IntegerArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IntegerArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("UNITS", &self.UNITS());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("VALID_MIN", &self.VALID_MIN());
      ds.field("VALID_MAX", &self.VALID_MAX());
      ds.field("SIGNED", &self.SIGNED());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IntegerArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub UNITS: Option<Vec<UnitT>>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub VALID_MIN: i64,
  pub VALID_MAX: i64,
  pub SIGNED: bool,
  pub SIZE_IN_BITS: u16,
  pub INITIAL_VALUE: i64,
}
impl Default for IntegerArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      VALID_MIN: 0,
      VALID_MAX: 0,
      SIGNED: false,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0,
    }
  }
}
impl IntegerArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<IntegerArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UNITS = self.UNITS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let VALID_MIN = self.VALID_MIN;
    let VALID_MAX = self.VALID_MAX;
    let SIGNED = self.SIGNED;
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let INITIAL_VALUE = self.INITIAL_VALUE;
    IntegerArgumentType::create(_fbb, &IntegerArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIGNED,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    })
  }
}
pub enum FloatArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Float argument type
pub struct FloatArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloatArgumentType<'a> {
  type Inner = FloatArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FloatArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_UNITS: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 12;
  pub const VT_VALID_MIN: flatbuffers::VOffsetT = 14;
  pub const VT_VALID_MAX: flatbuffers::VOffsetT = 16;
  pub const VT_SIZE_IN_BITS: flatbuffers::VOffsetT = 18;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloatArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FloatArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<FloatArgumentType<'bldr>> {
    let mut builder = FloatArgumentTypeBuilder::new(_fbb);
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.add_VALID_MAX(args.VALID_MAX);
    builder.add_VALID_MIN(args.VALID_MIN);
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.UNITS { builder.add_UNITS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SIZE_IN_BITS(args.SIZE_IN_BITS);
    builder.finish()
  }

  pub fn unpack(&self) -> FloatArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let UNITS = self.UNITS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let VALID_MIN = self.VALID_MIN();
    let VALID_MAX = self.VALID_MAX();
    let SIZE_IN_BITS = self.SIZE_IN_BITS();
    let INITIAL_VALUE = self.INITIAL_VALUE();
    FloatArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FloatArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Units
  #[inline]
  pub fn UNITS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit>>>>(FloatArgumentType::VT_UNITS, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<FloatDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FloatDataEncoding>>(FloatArgumentType::VT_DATA_ENCODING, None)}
  }
  /// Minimum valid value
  #[inline]
  pub fn VALID_MIN(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatArgumentType::VT_VALID_MIN, Some(0.0)).unwrap()}
  }
  /// Maximum valid value
  #[inline]
  pub fn VALID_MAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatArgumentType::VT_VALID_MAX, Some(0.0)).unwrap()}
  }
  /// Size in bits
  #[inline]
  pub fn SIZE_IN_BITS(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(FloatArgumentType::VT_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FloatArgumentType::VT_INITIAL_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FloatArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Unit>>>>("UNITS", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FloatDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<f64>("VALID_MIN", Self::VT_VALID_MIN, false)?
     .visit_field::<f64>("VALID_MAX", Self::VT_VALID_MAX, false)?
     .visit_field::<u16>("SIZE_IN_BITS", Self::VT_SIZE_IN_BITS, false)?
     .visit_field::<f64>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FloatArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UNITS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Unit<'a>>>>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<FloatDataEncoding<'a>>>,
    pub VALID_MIN: f64,
    pub VALID_MAX: f64,
    pub SIZE_IN_BITS: u16,
    pub INITIAL_VALUE: f64,
}
impl<'a> Default for FloatArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    FloatArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      VALID_MIN: 0.0,
      VALID_MAX: 0.0,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0.0,
    }
  }
}

pub struct FloatArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FloatArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_UNITS(&mut self, UNITS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Unit<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FloatArgumentType::VT_UNITS, UNITS);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<FloatDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FloatDataEncoding>>(FloatArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_VALID_MIN(&mut self, VALID_MIN: f64) {
    self.fbb_.push_slot::<f64>(FloatArgumentType::VT_VALID_MIN, VALID_MIN, 0.0);
  }
  #[inline]
  pub fn add_VALID_MAX(&mut self, VALID_MAX: f64) {
    self.fbb_.push_slot::<f64>(FloatArgumentType::VT_VALID_MAX, VALID_MAX, 0.0);
  }
  #[inline]
  pub fn add_SIZE_IN_BITS(&mut self, SIZE_IN_BITS: u16) {
    self.fbb_.push_slot::<u16>(FloatArgumentType::VT_SIZE_IN_BITS, SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: f64) {
    self.fbb_.push_slot::<f64>(FloatArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FloatArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FloatArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloatArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloatArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloatArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("UNITS", &self.UNITS());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("VALID_MIN", &self.VALID_MIN());
      ds.field("VALID_MAX", &self.VALID_MAX());
      ds.field("SIZE_IN_BITS", &self.SIZE_IN_BITS());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloatArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub UNITS: Option<Vec<UnitT>>,
  pub DATA_ENCODING: Option<Box<FloatDataEncodingT>>,
  pub VALID_MIN: f64,
  pub VALID_MAX: f64,
  pub SIZE_IN_BITS: u16,
  pub INITIAL_VALUE: f64,
}
impl Default for FloatArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      UNITS: None,
      DATA_ENCODING: None,
      VALID_MIN: 0.0,
      VALID_MAX: 0.0,
      SIZE_IN_BITS: 0,
      INITIAL_VALUE: 0.0,
    }
  }
}
impl FloatArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FloatArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UNITS = self.UNITS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let VALID_MIN = self.VALID_MIN;
    let VALID_MAX = self.VALID_MAX;
    let SIZE_IN_BITS = self.SIZE_IN_BITS;
    let INITIAL_VALUE = self.INITIAL_VALUE;
    FloatArgumentType::create(_fbb, &FloatArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      UNITS,
      DATA_ENCODING,
      VALID_MIN,
      VALID_MAX,
      SIZE_IN_BITS,
      INITIAL_VALUE,
    })
  }
}
pub enum StringArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// String argument type
pub struct StringArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringArgumentType<'a> {
  type Inner = StringArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 12;
  pub const VT_RESTRICTION_PATTERN: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<StringArgumentType<'bldr>> {
    let mut builder = StringArgumentTypeBuilder::new(_fbb);
    if let Some(x) = args.RESTRICTION_PATTERN { builder.add_RESTRICTION_PATTERN(x); }
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StringArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    let RESTRICTION_PATTERN = self.RESTRICTION_PATTERN().map(|x| {
      x.to_string()
    });
    StringArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
      RESTRICTION_PATTERN,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<StringDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StringDataEncoding>>(StringArgumentType::VT_DATA_ENCODING, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringArgumentType::VT_INITIAL_VALUE, None)}
  }
  /// Restriction pattern (regex)
  #[inline]
  pub fn RESTRICTION_PATTERN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringArgumentType::VT_RESTRICTION_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for StringArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StringDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RESTRICTION_PATTERN", Self::VT_RESTRICTION_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct StringArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<StringDataEncoding<'a>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub RESTRICTION_PATTERN: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
      RESTRICTION_PATTERN: None,
    }
  }
}

pub struct StringArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<StringDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StringDataEncoding>>(StringArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn add_RESTRICTION_PATTERN(&mut self, RESTRICTION_PATTERN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringArgumentType::VT_RESTRICTION_PATTERN, RESTRICTION_PATTERN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.field("RESTRICTION_PATTERN", &self.RESTRICTION_PATTERN());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StringArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<StringDataEncodingT>>,
  pub INITIAL_VALUE: Option<String>,
  pub RESTRICTION_PATTERN: Option<String>,
}
impl Default for StringArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
      RESTRICTION_PATTERN: None,
    }
  }
}
impl StringArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StringArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let RESTRICTION_PATTERN = self.RESTRICTION_PATTERN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    StringArgumentType::create(_fbb, &StringArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
      RESTRICTION_PATTERN,
    })
  }
}
pub enum BooleanArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Boolean argument type
pub struct BooleanArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BooleanArgumentType<'a> {
  type Inner = BooleanArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BooleanArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_ONE_STRING_VALUE: flatbuffers::VOffsetT = 12;
  pub const VT_ZERO_STRING_VALUE: flatbuffers::VOffsetT = 14;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BooleanArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BooleanArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<BooleanArgumentType<'bldr>> {
    let mut builder = BooleanArgumentTypeBuilder::new(_fbb);
    if let Some(x) = args.ZERO_STRING_VALUE { builder.add_ZERO_STRING_VALUE(x); }
    if let Some(x) = args.ONE_STRING_VALUE { builder.add_ONE_STRING_VALUE(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_INITIAL_VALUE(args.INITIAL_VALUE);
    builder.finish()
  }

  pub fn unpack(&self) -> BooleanArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let ONE_STRING_VALUE = self.ONE_STRING_VALUE().map(|x| {
      x.to_string()
    });
    let ZERO_STRING_VALUE = self.ZERO_STRING_VALUE().map(|x| {
      x.to_string()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE();
    BooleanArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ONE_STRING_VALUE,
      ZERO_STRING_VALUE,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(BooleanArgumentType::VT_DATA_ENCODING, None)}
  }
  /// String representation of true value
  #[inline]
  pub fn ONE_STRING_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanArgumentType::VT_ONE_STRING_VALUE, None)}
  }
  /// String representation of false value
  #[inline]
  pub fn ZERO_STRING_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BooleanArgumentType::VT_ZERO_STRING_VALUE, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BooleanArgumentType::VT_INITIAL_VALUE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BooleanArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ONE_STRING_VALUE", Self::VT_ONE_STRING_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ZERO_STRING_VALUE", Self::VT_ZERO_STRING_VALUE, false)?
     .visit_field::<bool>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BooleanArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub ONE_STRING_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ZERO_STRING_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_VALUE: bool,
}
impl<'a> Default for BooleanArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    BooleanArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ONE_STRING_VALUE: None,
      ZERO_STRING_VALUE: None,
      INITIAL_VALUE: false,
    }
  }
}

pub struct BooleanArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BooleanArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(BooleanArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_ONE_STRING_VALUE(&mut self, ONE_STRING_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanArgumentType::VT_ONE_STRING_VALUE, ONE_STRING_VALUE);
  }
  #[inline]
  pub fn add_ZERO_STRING_VALUE(&mut self, ZERO_STRING_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BooleanArgumentType::VT_ZERO_STRING_VALUE, ZERO_STRING_VALUE);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: bool) {
    self.fbb_.push_slot::<bool>(BooleanArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BooleanArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BooleanArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BooleanArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BooleanArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BooleanArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("ONE_STRING_VALUE", &self.ONE_STRING_VALUE());
      ds.field("ZERO_STRING_VALUE", &self.ZERO_STRING_VALUE());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BooleanArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub ONE_STRING_VALUE: Option<String>,
  pub ZERO_STRING_VALUE: Option<String>,
  pub INITIAL_VALUE: bool,
}
impl Default for BooleanArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ONE_STRING_VALUE: None,
      ZERO_STRING_VALUE: None,
      INITIAL_VALUE: false,
    }
  }
}
impl BooleanArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BooleanArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ONE_STRING_VALUE = self.ONE_STRING_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ZERO_STRING_VALUE = self.ZERO_STRING_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE;
    BooleanArgumentType::create(_fbb, &BooleanArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ONE_STRING_VALUE,
      ZERO_STRING_VALUE,
      INITIAL_VALUE,
    })
  }
}
pub enum EnumeratedArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Enumerated argument type
pub struct EnumeratedArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnumeratedArgumentType<'a> {
  type Inner = EnumeratedArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EnumeratedArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_ENUMERATION_LIST: flatbuffers::VOffsetT = 12;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EnumeratedArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EnumeratedArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<EnumeratedArgumentType<'bldr>> {
    let mut builder = EnumeratedArgumentTypeBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.ENUMERATION_LIST { builder.add_ENUMERATION_LIST(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> EnumeratedArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let ENUMERATION_LIST = self.ENUMERATION_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    EnumeratedArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ENUMERATION_LIST,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<IntegerDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>(EnumeratedArgumentType::VT_DATA_ENCODING, None)}
  }
  /// Enumeration values list
  #[inline]
  pub fn ENUMERATION_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue>>>>(EnumeratedArgumentType::VT_ENUMERATION_LIST, None)}
  }
  /// Initial/default value label
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EnumeratedArgumentType::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for EnumeratedArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IntegerDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumerationValue>>>>("ENUMERATION_LIST", Self::VT_ENUMERATION_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct EnumeratedArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<IntegerDataEncoding<'a>>>,
    pub ENUMERATION_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumerationValue<'a>>>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnumeratedArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    EnumeratedArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ENUMERATION_LIST: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct EnumeratedArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnumeratedArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<IntegerDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IntegerDataEncoding>>(EnumeratedArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_ENUMERATION_LIST(&mut self, ENUMERATION_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumerationValue<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedArgumentType::VT_ENUMERATION_LIST, ENUMERATION_LIST);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EnumeratedArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnumeratedArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EnumeratedArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EnumeratedArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EnumeratedArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EnumeratedArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("ENUMERATION_LIST", &self.ENUMERATION_LIST());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EnumeratedArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<IntegerDataEncodingT>>,
  pub ENUMERATION_LIST: Option<Vec<EnumerationValueT>>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for EnumeratedArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      ENUMERATION_LIST: None,
      INITIAL_VALUE: None,
    }
  }
}
impl EnumeratedArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<EnumeratedArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ENUMERATION_LIST = self.ENUMERATION_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    EnumeratedArgumentType::create(_fbb, &EnumeratedArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      ENUMERATION_LIST,
      INITIAL_VALUE,
    })
  }
}
pub enum BinaryArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Binary argument type
pub struct BinaryArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryArgumentType<'a> {
  type Inner = BinaryArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ENCODING: flatbuffers::VOffsetT = 10;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryArgumentType<'bldr>> {
    let mut builder = BinaryArgumentTypeBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.DATA_ENCODING { builder.add_DATA_ENCODING(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BinaryArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let DATA_ENCODING = self.DATA_ENCODING().map(|x| {
      Box::new(x.unpack())
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    BinaryArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Data encoding
  #[inline]
  pub fn DATA_ENCODING(&self) -> Option<BinaryDataEncoding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryDataEncoding>>(BinaryArgumentType::VT_DATA_ENCODING, None)}
  }
  /// Initial/default value (hex string)
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryArgumentType::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryDataEncoding>>("DATA_ENCODING", Self::VT_DATA_ENCODING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATA_ENCODING: Option<flatbuffers::WIPOffset<BinaryDataEncoding<'a>>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BinaryArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct BinaryArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_DATA_ENCODING(&mut self, DATA_ENCODING: flatbuffers::WIPOffset<BinaryDataEncoding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryDataEncoding>>(BinaryArgumentType::VT_DATA_ENCODING, DATA_ENCODING);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryArgumentType::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("DATA_ENCODING", &self.DATA_ENCODING());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BinaryArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub DATA_ENCODING: Option<Box<BinaryDataEncodingT>>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for BinaryArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      DATA_ENCODING: None,
      INITIAL_VALUE: None,
    }
  }
}
impl BinaryArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BinaryArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATA_ENCODING = self.DATA_ENCODING.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    BinaryArgumentType::create(_fbb, &BinaryArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      DATA_ENCODING,
      INITIAL_VALUE,
    })
  }
}
pub enum AggregateArgumentTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Aggregate argument type
pub struct AggregateArgumentType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AggregateArgumentType<'a> {
  type Inner = AggregateArgumentType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AggregateArgumentType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_MEMBERS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AggregateArgumentType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AggregateArgumentTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<AggregateArgumentType<'bldr>> {
    let mut builder = AggregateArgumentTypeBuilder::new(_fbb);
    if let Some(x) = args.MEMBERS { builder.add_MEMBERS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> AggregateArgumentTypeT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MEMBERS = self.MEMBERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    AggregateArgumentTypeT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      MEMBERS,
    }
  }

  /// Type name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateArgumentType::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateArgumentType::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AggregateArgumentType::VT_LONG_DESCRIPTION, None)}
  }
  /// Member list
  #[inline]
  pub fn MEMBERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember>>>>(AggregateArgumentType::VT_MEMBERS, None)}
  }
}

impl flatbuffers::Verifiable for AggregateArgumentType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AggregateMember>>>>("MEMBERS", Self::VT_MEMBERS, false)?
     .finish();
    Ok(())
  }
}
pub struct AggregateArgumentTypeArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MEMBERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateMember<'a>>>>>,
}
impl<'a> Default for AggregateArgumentTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AggregateArgumentTypeArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      MEMBERS: None,
    }
  }
}

pub struct AggregateArgumentTypeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AggregateArgumentTypeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateArgumentType::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateArgumentType::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateArgumentType::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_MEMBERS(&mut self, MEMBERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AggregateMember<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AggregateArgumentType::VT_MEMBERS, MEMBERS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AggregateArgumentTypeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AggregateArgumentTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AggregateArgumentType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AggregateArgumentType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AggregateArgumentType");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("MEMBERS", &self.MEMBERS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AggregateArgumentTypeT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub MEMBERS: Option<Vec<AggregateMemberT>>,
}
impl Default for AggregateArgumentTypeT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      MEMBERS: None,
    }
  }
}
impl AggregateArgumentTypeT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<AggregateArgumentType<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MEMBERS = self.MEMBERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    AggregateArgumentType::create(_fbb, &AggregateArgumentTypeArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      MEMBERS,
    })
  }
}
pub enum ArgumentTypeSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of argument types
pub struct ArgumentTypeSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgumentTypeSet<'a> {
  type Inner = ArgumentTypeSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArgumentTypeSet<'a> {
  pub const VT_INTEGER_TYPES: flatbuffers::VOffsetT = 4;
  pub const VT_FLOAT_TYPES: flatbuffers::VOffsetT = 6;
  pub const VT_STRING_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_BOOLEAN_TYPES: flatbuffers::VOffsetT = 10;
  pub const VT_ENUMERATED_TYPES: flatbuffers::VOffsetT = 12;
  pub const VT_BINARY_TYPES: flatbuffers::VOffsetT = 14;
  pub const VT_AGGREGATE_TYPES: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgumentTypeSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArgumentTypeSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ArgumentTypeSet<'bldr>> {
    let mut builder = ArgumentTypeSetBuilder::new(_fbb);
    if let Some(x) = args.AGGREGATE_TYPES { builder.add_AGGREGATE_TYPES(x); }
    if let Some(x) = args.BINARY_TYPES { builder.add_BINARY_TYPES(x); }
    if let Some(x) = args.ENUMERATED_TYPES { builder.add_ENUMERATED_TYPES(x); }
    if let Some(x) = args.BOOLEAN_TYPES { builder.add_BOOLEAN_TYPES(x); }
    if let Some(x) = args.STRING_TYPES { builder.add_STRING_TYPES(x); }
    if let Some(x) = args.FLOAT_TYPES { builder.add_FLOAT_TYPES(x); }
    if let Some(x) = args.INTEGER_TYPES { builder.add_INTEGER_TYPES(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArgumentTypeSetT {
    let INTEGER_TYPES = self.INTEGER_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let FLOAT_TYPES = self.FLOAT_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let STRING_TYPES = self.STRING_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BOOLEAN_TYPES = self.BOOLEAN_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let ENUMERATED_TYPES = self.ENUMERATED_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BINARY_TYPES = self.BINARY_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let AGGREGATE_TYPES = self.AGGREGATE_TYPES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ArgumentTypeSetT {
      INTEGER_TYPES,
      FLOAT_TYPES,
      STRING_TYPES,
      BOOLEAN_TYPES,
      ENUMERATED_TYPES,
      BINARY_TYPES,
      AGGREGATE_TYPES,
    }
  }

  /// Integer argument types
  #[inline]
  pub fn INTEGER_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerArgumentType>>>>(ArgumentTypeSet::VT_INTEGER_TYPES, None)}
  }
  /// Float argument types
  #[inline]
  pub fn FLOAT_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatArgumentType>>>>(ArgumentTypeSet::VT_FLOAT_TYPES, None)}
  }
  /// String argument types
  #[inline]
  pub fn STRING_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringArgumentType>>>>(ArgumentTypeSet::VT_STRING_TYPES, None)}
  }
  /// Boolean argument types
  #[inline]
  pub fn BOOLEAN_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanArgumentType>>>>(ArgumentTypeSet::VT_BOOLEAN_TYPES, None)}
  }
  /// Enumerated argument types
  #[inline]
  pub fn ENUMERATED_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedArgumentType>>>>(ArgumentTypeSet::VT_ENUMERATED_TYPES, None)}
  }
  /// Binary argument types
  #[inline]
  pub fn BINARY_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryArgumentType>>>>(ArgumentTypeSet::VT_BINARY_TYPES, None)}
  }
  /// Aggregate argument types
  #[inline]
  pub fn AGGREGATE_TYPES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateArgumentType<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateArgumentType>>>>(ArgumentTypeSet::VT_AGGREGATE_TYPES, None)}
  }
}

impl flatbuffers::Verifiable for ArgumentTypeSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IntegerArgumentType>>>>("INTEGER_TYPES", Self::VT_INTEGER_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FloatArgumentType>>>>("FLOAT_TYPES", Self::VT_FLOAT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringArgumentType>>>>("STRING_TYPES", Self::VT_STRING_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BooleanArgumentType>>>>("BOOLEAN_TYPES", Self::VT_BOOLEAN_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnumeratedArgumentType>>>>("ENUMERATED_TYPES", Self::VT_ENUMERATED_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryArgumentType>>>>("BINARY_TYPES", Self::VT_BINARY_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AggregateArgumentType>>>>("AGGREGATE_TYPES", Self::VT_AGGREGATE_TYPES, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgumentTypeSetArgs<'a> {
    pub INTEGER_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IntegerArgumentType<'a>>>>>,
    pub FLOAT_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FloatArgumentType<'a>>>>>,
    pub STRING_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringArgumentType<'a>>>>>,
    pub BOOLEAN_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BooleanArgumentType<'a>>>>>,
    pub ENUMERATED_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnumeratedArgumentType<'a>>>>>,
    pub BINARY_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryArgumentType<'a>>>>>,
    pub AGGREGATE_TYPES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AggregateArgumentType<'a>>>>>,
}
impl<'a> Default for ArgumentTypeSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArgumentTypeSetArgs {
      INTEGER_TYPES: None,
      FLOAT_TYPES: None,
      STRING_TYPES: None,
      BOOLEAN_TYPES: None,
      ENUMERATED_TYPES: None,
      BINARY_TYPES: None,
      AGGREGATE_TYPES: None,
    }
  }
}

pub struct ArgumentTypeSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArgumentTypeSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_INTEGER_TYPES(&mut self, INTEGER_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IntegerArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_INTEGER_TYPES, INTEGER_TYPES);
  }
  #[inline]
  pub fn add_FLOAT_TYPES(&mut self, FLOAT_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FloatArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_FLOAT_TYPES, FLOAT_TYPES);
  }
  #[inline]
  pub fn add_STRING_TYPES(&mut self, STRING_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_STRING_TYPES, STRING_TYPES);
  }
  #[inline]
  pub fn add_BOOLEAN_TYPES(&mut self, BOOLEAN_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BooleanArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_BOOLEAN_TYPES, BOOLEAN_TYPES);
  }
  #[inline]
  pub fn add_ENUMERATED_TYPES(&mut self, ENUMERATED_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EnumeratedArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_ENUMERATED_TYPES, ENUMERATED_TYPES);
  }
  #[inline]
  pub fn add_BINARY_TYPES(&mut self, BINARY_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_BINARY_TYPES, BINARY_TYPES);
  }
  #[inline]
  pub fn add_AGGREGATE_TYPES(&mut self, AGGREGATE_TYPES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<AggregateArgumentType<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentTypeSet::VT_AGGREGATE_TYPES, AGGREGATE_TYPES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArgumentTypeSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArgumentTypeSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgumentTypeSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgumentTypeSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgumentTypeSet");
      ds.field("INTEGER_TYPES", &self.INTEGER_TYPES());
      ds.field("FLOAT_TYPES", &self.FLOAT_TYPES());
      ds.field("STRING_TYPES", &self.STRING_TYPES());
      ds.field("BOOLEAN_TYPES", &self.BOOLEAN_TYPES());
      ds.field("ENUMERATED_TYPES", &self.ENUMERATED_TYPES());
      ds.field("BINARY_TYPES", &self.BINARY_TYPES());
      ds.field("AGGREGATE_TYPES", &self.AGGREGATE_TYPES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgumentTypeSetT {
  pub INTEGER_TYPES: Option<Vec<IntegerArgumentTypeT>>,
  pub FLOAT_TYPES: Option<Vec<FloatArgumentTypeT>>,
  pub STRING_TYPES: Option<Vec<StringArgumentTypeT>>,
  pub BOOLEAN_TYPES: Option<Vec<BooleanArgumentTypeT>>,
  pub ENUMERATED_TYPES: Option<Vec<EnumeratedArgumentTypeT>>,
  pub BINARY_TYPES: Option<Vec<BinaryArgumentTypeT>>,
  pub AGGREGATE_TYPES: Option<Vec<AggregateArgumentTypeT>>,
}
impl Default for ArgumentTypeSetT {
  fn default() -> Self {
    Self {
      INTEGER_TYPES: None,
      FLOAT_TYPES: None,
      STRING_TYPES: None,
      BOOLEAN_TYPES: None,
      ENUMERATED_TYPES: None,
      BINARY_TYPES: None,
      AGGREGATE_TYPES: None,
    }
  }
}
impl ArgumentTypeSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArgumentTypeSet<'b>> {
    let INTEGER_TYPES = self.INTEGER_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let FLOAT_TYPES = self.FLOAT_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let STRING_TYPES = self.STRING_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BOOLEAN_TYPES = self.BOOLEAN_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let ENUMERATED_TYPES = self.ENUMERATED_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BINARY_TYPES = self.BINARY_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let AGGREGATE_TYPES = self.AGGREGATE_TYPES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ArgumentTypeSet::create(_fbb, &ArgumentTypeSetArgs{
      INTEGER_TYPES,
      FLOAT_TYPES,
      STRING_TYPES,
      BOOLEAN_TYPES,
      ENUMERATED_TYPES,
      BINARY_TYPES,
      AGGREGATE_TYPES,
    })
  }
}
pub enum ArgumentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Command argument definition
pub struct Argument<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Argument<'a> {
  type Inner = Argument<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Argument<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ARGUMENT_TYPE_REF: flatbuffers::VOffsetT = 6;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_INITIAL_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Argument { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArgumentArgs<'args>
  ) -> flatbuffers::WIPOffset<Argument<'bldr>> {
    let mut builder = ArgumentBuilder::new(_fbb);
    if let Some(x) = args.INITIAL_VALUE { builder.add_INITIAL_VALUE(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.ARGUMENT_TYPE_REF { builder.add_ARGUMENT_TYPE_REF(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArgumentT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ARGUMENT_TYPE_REF = self.ARGUMENT_TYPE_REF().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let INITIAL_VALUE = self.INITIAL_VALUE().map(|x| {
      x.to_string()
    });
    ArgumentT {
      NAME,
      ARGUMENT_TYPE_REF,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      INITIAL_VALUE,
    }
  }

  /// Argument name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_NAME, None)}
  }
  /// Reference to argument type
  #[inline]
  pub fn ARGUMENT_TYPE_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_ARGUMENT_TYPE_REF, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_LONG_DESCRIPTION, None)}
  }
  /// Initial/default value
  #[inline]
  pub fn INITIAL_VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Argument::VT_INITIAL_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Argument<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ARGUMENT_TYPE_REF", Self::VT_ARGUMENT_TYPE_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("INITIAL_VALUE", Self::VT_INITIAL_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgumentArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ARGUMENT_TYPE_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INITIAL_VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ArgumentArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArgumentArgs {
      NAME: None,
      ARGUMENT_TYPE_REF: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      INITIAL_VALUE: None,
    }
  }
}

pub struct ArgumentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArgumentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ARGUMENT_TYPE_REF(&mut self, ARGUMENT_TYPE_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_ARGUMENT_TYPE_REF, ARGUMENT_TYPE_REF);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_INITIAL_VALUE(&mut self, INITIAL_VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Argument::VT_INITIAL_VALUE, INITIAL_VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArgumentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArgumentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Argument<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Argument<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Argument");
      ds.field("NAME", &self.NAME());
      ds.field("ARGUMENT_TYPE_REF", &self.ARGUMENT_TYPE_REF());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("INITIAL_VALUE", &self.INITIAL_VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgumentT {
  pub NAME: Option<String>,
  pub ARGUMENT_TYPE_REF: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub INITIAL_VALUE: Option<String>,
}
impl Default for ArgumentT {
  fn default() -> Self {
    Self {
      NAME: None,
      ARGUMENT_TYPE_REF: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      INITIAL_VALUE: None,
    }
  }
}
impl ArgumentT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Argument<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ARGUMENT_TYPE_REF = self.ARGUMENT_TYPE_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INITIAL_VALUE = self.INITIAL_VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    Argument::create(_fbb, &ArgumentArgs{
      NAME,
      ARGUMENT_TYPE_REF,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      INITIAL_VALUE,
    })
  }
}
pub enum ArgumentRefEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Argument reference entry in command container
pub struct ArgumentRefEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgumentRefEntry<'a> {
  type Inner = ArgumentRefEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArgumentRefEntry<'a> {
  pub const VT_ARGUMENT_REF: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgumentRefEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArgumentRefEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<ArgumentRefEntry<'bldr>> {
    let mut builder = ArgumentRefEntryBuilder::new(_fbb);
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.LOCATION { builder.add_LOCATION(x); }
    if let Some(x) = args.ARGUMENT_REF { builder.add_ARGUMENT_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArgumentRefEntryT {
    let ARGUMENT_REF = self.ARGUMENT_REF().map(|x| {
      x.to_string()
    });
    let LOCATION = self.LOCATION().map(|x| {
      Box::new(x.unpack())
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    ArgumentRefEntryT {
      ARGUMENT_REF,
      LOCATION,
      SHORT_DESCRIPTION,
    }
  }

  /// Argument reference
  #[inline]
  pub fn ARGUMENT_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArgumentRefEntry::VT_ARGUMENT_REF, None)}
  }
  /// Location in container
  #[inline]
  pub fn LOCATION(&self) -> Option<LocationInContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LocationInContainer>>(ArgumentRefEntry::VT_LOCATION, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArgumentRefEntry::VT_SHORT_DESCRIPTION, None)}
  }
}

impl flatbuffers::Verifiable for ArgumentRefEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ARGUMENT_REF", Self::VT_ARGUMENT_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LocationInContainer>>("LOCATION", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgumentRefEntryArgs<'a> {
    pub ARGUMENT_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LOCATION: Option<flatbuffers::WIPOffset<LocationInContainer<'a>>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ArgumentRefEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArgumentRefEntryArgs {
      ARGUMENT_REF: None,
      LOCATION: None,
      SHORT_DESCRIPTION: None,
    }
  }
}

pub struct ArgumentRefEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArgumentRefEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ARGUMENT_REF(&mut self, ARGUMENT_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentRefEntry::VT_ARGUMENT_REF, ARGUMENT_REF);
  }
  #[inline]
  pub fn add_LOCATION(&mut self, LOCATION: flatbuffers::WIPOffset<LocationInContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LocationInContainer>>(ArgumentRefEntry::VT_LOCATION, LOCATION);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentRefEntry::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArgumentRefEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArgumentRefEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgumentRefEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgumentRefEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgumentRefEntry");
      ds.field("ARGUMENT_REF", &self.ARGUMENT_REF());
      ds.field("LOCATION", &self.LOCATION());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgumentRefEntryT {
  pub ARGUMENT_REF: Option<String>,
  pub LOCATION: Option<Box<LocationInContainerT>>,
  pub SHORT_DESCRIPTION: Option<String>,
}
impl Default for ArgumentRefEntryT {
  fn default() -> Self {
    Self {
      ARGUMENT_REF: None,
      LOCATION: None,
      SHORT_DESCRIPTION: None,
    }
  }
}
impl ArgumentRefEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArgumentRefEntry<'b>> {
    let ARGUMENT_REF = self.ARGUMENT_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LOCATION = self.LOCATION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ArgumentRefEntry::create(_fbb, &ArgumentRefEntryArgs{
      ARGUMENT_REF,
      LOCATION,
      SHORT_DESCRIPTION,
    })
  }
}
pub enum CommandContainerEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Command container entry
pub struct CommandContainerEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommandContainerEntry<'a> {
  type Inner = CommandContainerEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommandContainerEntry<'a> {
  pub const VT_ARGUMENT_REF_ENTRY: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER_REF_ENTRY: flatbuffers::VOffsetT = 6;
  pub const VT_FIXED_VALUE_ENTRY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommandContainerEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommandContainerEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<CommandContainerEntry<'bldr>> {
    let mut builder = CommandContainerEntryBuilder::new(_fbb);
    if let Some(x) = args.FIXED_VALUE_ENTRY { builder.add_FIXED_VALUE_ENTRY(x); }
    if let Some(x) = args.PARAMETER_REF_ENTRY { builder.add_PARAMETER_REF_ENTRY(x); }
    if let Some(x) = args.ARGUMENT_REF_ENTRY { builder.add_ARGUMENT_REF_ENTRY(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CommandContainerEntryT {
    let ARGUMENT_REF_ENTRY = self.ARGUMENT_REF_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    let PARAMETER_REF_ENTRY = self.PARAMETER_REF_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    let FIXED_VALUE_ENTRY = self.FIXED_VALUE_ENTRY().map(|x| {
      Box::new(x.unpack())
    });
    CommandContainerEntryT {
      ARGUMENT_REF_ENTRY,
      PARAMETER_REF_ENTRY,
      FIXED_VALUE_ENTRY,
    }
  }

  /// Argument reference entry
  #[inline]
  pub fn ARGUMENT_REF_ENTRY(&self) -> Option<ArgumentRefEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ArgumentRefEntry>>(CommandContainerEntry::VT_ARGUMENT_REF_ENTRY, None)}
  }
  /// Parameter reference entry
  #[inline]
  pub fn PARAMETER_REF_ENTRY(&self) -> Option<ParameterRefEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterRefEntry>>(CommandContainerEntry::VT_PARAMETER_REF_ENTRY, None)}
  }
  /// Fixed value entry
  #[inline]
  pub fn FIXED_VALUE_ENTRY(&self) -> Option<FixedValueEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FixedValueEntry>>(CommandContainerEntry::VT_FIXED_VALUE_ENTRY, None)}
  }
}

impl flatbuffers::Verifiable for CommandContainerEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ArgumentRefEntry>>("ARGUMENT_REF_ENTRY", Self::VT_ARGUMENT_REF_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterRefEntry>>("PARAMETER_REF_ENTRY", Self::VT_PARAMETER_REF_ENTRY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FixedValueEntry>>("FIXED_VALUE_ENTRY", Self::VT_FIXED_VALUE_ENTRY, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandContainerEntryArgs<'a> {
    pub ARGUMENT_REF_ENTRY: Option<flatbuffers::WIPOffset<ArgumentRefEntry<'a>>>,
    pub PARAMETER_REF_ENTRY: Option<flatbuffers::WIPOffset<ParameterRefEntry<'a>>>,
    pub FIXED_VALUE_ENTRY: Option<flatbuffers::WIPOffset<FixedValueEntry<'a>>>,
}
impl<'a> Default for CommandContainerEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandContainerEntryArgs {
      ARGUMENT_REF_ENTRY: None,
      PARAMETER_REF_ENTRY: None,
      FIXED_VALUE_ENTRY: None,
    }
  }
}

pub struct CommandContainerEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommandContainerEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ARGUMENT_REF_ENTRY(&mut self, ARGUMENT_REF_ENTRY: flatbuffers::WIPOffset<ArgumentRefEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ArgumentRefEntry>>(CommandContainerEntry::VT_ARGUMENT_REF_ENTRY, ARGUMENT_REF_ENTRY);
  }
  #[inline]
  pub fn add_PARAMETER_REF_ENTRY(&mut self, PARAMETER_REF_ENTRY: flatbuffers::WIPOffset<ParameterRefEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterRefEntry>>(CommandContainerEntry::VT_PARAMETER_REF_ENTRY, PARAMETER_REF_ENTRY);
  }
  #[inline]
  pub fn add_FIXED_VALUE_ENTRY(&mut self, FIXED_VALUE_ENTRY: flatbuffers::WIPOffset<FixedValueEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FixedValueEntry>>(CommandContainerEntry::VT_FIXED_VALUE_ENTRY, FIXED_VALUE_ENTRY);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommandContainerEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommandContainerEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommandContainerEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommandContainerEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommandContainerEntry");
      ds.field("ARGUMENT_REF_ENTRY", &self.ARGUMENT_REF_ENTRY());
      ds.field("PARAMETER_REF_ENTRY", &self.PARAMETER_REF_ENTRY());
      ds.field("FIXED_VALUE_ENTRY", &self.FIXED_VALUE_ENTRY());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CommandContainerEntryT {
  pub ARGUMENT_REF_ENTRY: Option<Box<ArgumentRefEntryT>>,
  pub PARAMETER_REF_ENTRY: Option<Box<ParameterRefEntryT>>,
  pub FIXED_VALUE_ENTRY: Option<Box<FixedValueEntryT>>,
}
impl Default for CommandContainerEntryT {
  fn default() -> Self {
    Self {
      ARGUMENT_REF_ENTRY: None,
      PARAMETER_REF_ENTRY: None,
      FIXED_VALUE_ENTRY: None,
    }
  }
}
impl CommandContainerEntryT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CommandContainerEntry<'b>> {
    let ARGUMENT_REF_ENTRY = self.ARGUMENT_REF_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PARAMETER_REF_ENTRY = self.PARAMETER_REF_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let FIXED_VALUE_ENTRY = self.FIXED_VALUE_ENTRY.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CommandContainerEntry::create(_fbb, &CommandContainerEntryArgs{
      ARGUMENT_REF_ENTRY,
      PARAMETER_REF_ENTRY,
      FIXED_VALUE_ENTRY,
    })
  }
}
pub enum CommandContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Command container definition
pub struct CommandContainer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommandContainer<'a> {
  type Inner = CommandContainer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommandContainer<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_ENTRY_LIST: flatbuffers::VOffsetT = 6;
  pub const VT_BASE_CONTAINER: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommandContainer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommandContainerArgs<'args>
  ) -> flatbuffers::WIPOffset<CommandContainer<'bldr>> {
    let mut builder = CommandContainerBuilder::new(_fbb);
    if let Some(x) = args.BASE_CONTAINER { builder.add_BASE_CONTAINER(x); }
    if let Some(x) = args.ENTRY_LIST { builder.add_ENTRY_LIST(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CommandContainerT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let ENTRY_LIST = self.ENTRY_LIST().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let BASE_CONTAINER = self.BASE_CONTAINER().map(|x| {
      Box::new(x.unpack())
    });
    CommandContainerT {
      NAME,
      ENTRY_LIST,
      BASE_CONTAINER,
    }
  }

  /// Container name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CommandContainer::VT_NAME, None)}
  }
  /// Entry list
  #[inline]
  pub fn ENTRY_LIST(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandContainerEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandContainerEntry>>>>(CommandContainer::VT_ENTRY_LIST, None)}
  }
  /// Base container reference
  #[inline]
  pub fn BASE_CONTAINER(&self) -> Option<BaseContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BaseContainer>>(CommandContainer::VT_BASE_CONTAINER, None)}
  }
}

impl flatbuffers::Verifiable for CommandContainer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CommandContainerEntry>>>>("ENTRY_LIST", Self::VT_ENTRY_LIST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseContainer>>("BASE_CONTAINER", Self::VT_BASE_CONTAINER, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandContainerArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ENTRY_LIST: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandContainerEntry<'a>>>>>,
    pub BASE_CONTAINER: Option<flatbuffers::WIPOffset<BaseContainer<'a>>>,
}
impl<'a> Default for CommandContainerArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandContainerArgs {
      NAME: None,
      ENTRY_LIST: None,
      BASE_CONTAINER: None,
    }
  }
}

pub struct CommandContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommandContainerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommandContainer::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_ENTRY_LIST(&mut self, ENTRY_LIST: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CommandContainerEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommandContainer::VT_ENTRY_LIST, ENTRY_LIST);
  }
  #[inline]
  pub fn add_BASE_CONTAINER(&mut self, BASE_CONTAINER: flatbuffers::WIPOffset<BaseContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BaseContainer>>(CommandContainer::VT_BASE_CONTAINER, BASE_CONTAINER);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommandContainerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommandContainerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommandContainer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommandContainer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommandContainer");
      ds.field("NAME", &self.NAME());
      ds.field("ENTRY_LIST", &self.ENTRY_LIST());
      ds.field("BASE_CONTAINER", &self.BASE_CONTAINER());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CommandContainerT {
  pub NAME: Option<String>,
  pub ENTRY_LIST: Option<Vec<CommandContainerEntryT>>,
  pub BASE_CONTAINER: Option<Box<BaseContainerT>>,
}
impl Default for CommandContainerT {
  fn default() -> Self {
    Self {
      NAME: None,
      ENTRY_LIST: None,
      BASE_CONTAINER: None,
    }
  }
}
impl CommandContainerT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CommandContainer<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ENTRY_LIST = self.ENTRY_LIST.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let BASE_CONTAINER = self.BASE_CONTAINER.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CommandContainer::create(_fbb, &CommandContainerArgs{
      NAME,
      ENTRY_LIST,
      BASE_CONTAINER,
    })
  }
}
pub enum CommandVerifierOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Command verifier definition
pub struct CommandVerifier<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommandVerifier<'a> {
  type Inner = CommandVerifier<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommandVerifier<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VERIFIER_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CONDITION: flatbuffers::VOffsetT = 8;
  pub const VT_CONTAINER_REF: flatbuffers::VOffsetT = 10;
  pub const VT_TIME_WINDOW_START: flatbuffers::VOffsetT = 12;
  pub const VT_TIME_WINDOW_STOP: flatbuffers::VOffsetT = 14;
  pub const VT_TIME_WINDOW_REF: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommandVerifier { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommandVerifierArgs<'args>
  ) -> flatbuffers::WIPOffset<CommandVerifier<'bldr>> {
    let mut builder = CommandVerifierBuilder::new(_fbb);
    builder.add_TIME_WINDOW_STOP(args.TIME_WINDOW_STOP);
    builder.add_TIME_WINDOW_START(args.TIME_WINDOW_START);
    if let Some(x) = args.CONTAINER_REF { builder.add_CONTAINER_REF(x); }
    if let Some(x) = args.CONDITION { builder.add_CONDITION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_TIME_WINDOW_REF(args.TIME_WINDOW_REF);
    builder.add_VERIFIER_TYPE(args.VERIFIER_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> CommandVerifierT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let VERIFIER_TYPE = self.VERIFIER_TYPE();
    let CONDITION = self.CONDITION().map(|x| {
      Box::new(x.unpack())
    });
    let CONTAINER_REF = self.CONTAINER_REF().map(|x| {
      x.to_string()
    });
    let TIME_WINDOW_START = self.TIME_WINDOW_START();
    let TIME_WINDOW_STOP = self.TIME_WINDOW_STOP();
    let TIME_WINDOW_REF = self.TIME_WINDOW_REF();
    CommandVerifierT {
      NAME,
      VERIFIER_TYPE,
      CONDITION,
      CONTAINER_REF,
      TIME_WINDOW_START,
      TIME_WINDOW_STOP,
      TIME_WINDOW_REF,
    }
  }

  /// Verifier name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CommandVerifier::VT_NAME, None)}
  }
  /// Verifier type
  #[inline]
  pub fn VERIFIER_TYPE(&self) -> VerifierType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VerifierType>(CommandVerifier::VT_VERIFIER_TYPE, Some(VerifierType::START)).unwrap()}
  }
  /// Verification condition
  #[inline]
  pub fn CONDITION(&self) -> Option<MatchCriteria<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MatchCriteria>>(CommandVerifier::VT_CONDITION, None)}
  }
  /// Container reference for verification
  #[inline]
  pub fn CONTAINER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CommandVerifier::VT_CONTAINER_REF, None)}
  }
  /// Time window start (seconds)
  #[inline]
  pub fn TIME_WINDOW_START(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CommandVerifier::VT_TIME_WINDOW_START, Some(0.0)).unwrap()}
  }
  /// Time window stop (seconds)
  #[inline]
  pub fn TIME_WINDOW_STOP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(CommandVerifier::VT_TIME_WINDOW_STOP, Some(0.0)).unwrap()}
  }
  /// Time window reference type
  #[inline]
  pub fn TIME_WINDOW_REF(&self) -> TimeWindowRefType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TimeWindowRefType>(CommandVerifier::VT_TIME_WINDOW_REF, Some(TimeWindowRefType::COMMAND_RELEASE)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CommandVerifier<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<VerifierType>("VERIFIER_TYPE", Self::VT_VERIFIER_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MatchCriteria>>("CONDITION", Self::VT_CONDITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CONTAINER_REF", Self::VT_CONTAINER_REF, false)?
     .visit_field::<f64>("TIME_WINDOW_START", Self::VT_TIME_WINDOW_START, false)?
     .visit_field::<f64>("TIME_WINDOW_STOP", Self::VT_TIME_WINDOW_STOP, false)?
     .visit_field::<TimeWindowRefType>("TIME_WINDOW_REF", Self::VT_TIME_WINDOW_REF, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandVerifierArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VERIFIER_TYPE: VerifierType,
    pub CONDITION: Option<flatbuffers::WIPOffset<MatchCriteria<'a>>>,
    pub CONTAINER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TIME_WINDOW_START: f64,
    pub TIME_WINDOW_STOP: f64,
    pub TIME_WINDOW_REF: TimeWindowRefType,
}
impl<'a> Default for CommandVerifierArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandVerifierArgs {
      NAME: None,
      VERIFIER_TYPE: VerifierType::START,
      CONDITION: None,
      CONTAINER_REF: None,
      TIME_WINDOW_START: 0.0,
      TIME_WINDOW_STOP: 0.0,
      TIME_WINDOW_REF: TimeWindowRefType::COMMAND_RELEASE,
    }
  }
}

pub struct CommandVerifierBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommandVerifierBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommandVerifier::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_VERIFIER_TYPE(&mut self, VERIFIER_TYPE: VerifierType) {
    self.fbb_.push_slot::<VerifierType>(CommandVerifier::VT_VERIFIER_TYPE, VERIFIER_TYPE, VerifierType::START);
  }
  #[inline]
  pub fn add_CONDITION(&mut self, CONDITION: flatbuffers::WIPOffset<MatchCriteria<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MatchCriteria>>(CommandVerifier::VT_CONDITION, CONDITION);
  }
  #[inline]
  pub fn add_CONTAINER_REF(&mut self, CONTAINER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommandVerifier::VT_CONTAINER_REF, CONTAINER_REF);
  }
  #[inline]
  pub fn add_TIME_WINDOW_START(&mut self, TIME_WINDOW_START: f64) {
    self.fbb_.push_slot::<f64>(CommandVerifier::VT_TIME_WINDOW_START, TIME_WINDOW_START, 0.0);
  }
  #[inline]
  pub fn add_TIME_WINDOW_STOP(&mut self, TIME_WINDOW_STOP: f64) {
    self.fbb_.push_slot::<f64>(CommandVerifier::VT_TIME_WINDOW_STOP, TIME_WINDOW_STOP, 0.0);
  }
  #[inline]
  pub fn add_TIME_WINDOW_REF(&mut self, TIME_WINDOW_REF: TimeWindowRefType) {
    self.fbb_.push_slot::<TimeWindowRefType>(CommandVerifier::VT_TIME_WINDOW_REF, TIME_WINDOW_REF, TimeWindowRefType::COMMAND_RELEASE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommandVerifierBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommandVerifierBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommandVerifier<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommandVerifier<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommandVerifier");
      ds.field("NAME", &self.NAME());
      ds.field("VERIFIER_TYPE", &self.VERIFIER_TYPE());
      ds.field("CONDITION", &self.CONDITION());
      ds.field("CONTAINER_REF", &self.CONTAINER_REF());
      ds.field("TIME_WINDOW_START", &self.TIME_WINDOW_START());
      ds.field("TIME_WINDOW_STOP", &self.TIME_WINDOW_STOP());
      ds.field("TIME_WINDOW_REF", &self.TIME_WINDOW_REF());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CommandVerifierT {
  pub NAME: Option<String>,
  pub VERIFIER_TYPE: VerifierType,
  pub CONDITION: Option<Box<MatchCriteriaT>>,
  pub CONTAINER_REF: Option<String>,
  pub TIME_WINDOW_START: f64,
  pub TIME_WINDOW_STOP: f64,
  pub TIME_WINDOW_REF: TimeWindowRefType,
}
impl Default for CommandVerifierT {
  fn default() -> Self {
    Self {
      NAME: None,
      VERIFIER_TYPE: VerifierType::START,
      CONDITION: None,
      CONTAINER_REF: None,
      TIME_WINDOW_START: 0.0,
      TIME_WINDOW_STOP: 0.0,
      TIME_WINDOW_REF: TimeWindowRefType::COMMAND_RELEASE,
    }
  }
}
impl CommandVerifierT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CommandVerifier<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VERIFIER_TYPE = self.VERIFIER_TYPE;
    let CONDITION = self.CONDITION.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTAINER_REF = self.CONTAINER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TIME_WINDOW_START = self.TIME_WINDOW_START;
    let TIME_WINDOW_STOP = self.TIME_WINDOW_STOP;
    let TIME_WINDOW_REF = self.TIME_WINDOW_REF;
    CommandVerifier::create(_fbb, &CommandVerifierArgs{
      NAME,
      VERIFIER_TYPE,
      CONDITION,
      CONTAINER_REF,
      TIME_WINDOW_START,
      TIME_WINDOW_STOP,
      TIME_WINDOW_REF,
    })
  }
}
pub enum CommandSignificanceOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Significance of command execution
pub struct CommandSignificance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommandSignificance<'a> {
  type Inner = CommandSignificance<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommandSignificance<'a> {
  pub const VT_CONSEQUENCE_LEVEL: flatbuffers::VOffsetT = 4;
  pub const VT_REASON_FOR_WARNING: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommandSignificance { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommandSignificanceArgs<'args>
  ) -> flatbuffers::WIPOffset<CommandSignificance<'bldr>> {
    let mut builder = CommandSignificanceBuilder::new(_fbb);
    if let Some(x) = args.REASON_FOR_WARNING { builder.add_REASON_FOR_WARNING(x); }
    builder.add_CONSEQUENCE_LEVEL(args.CONSEQUENCE_LEVEL);
    builder.finish()
  }

  pub fn unpack(&self) -> CommandSignificanceT {
    let CONSEQUENCE_LEVEL = self.CONSEQUENCE_LEVEL();
    let REASON_FOR_WARNING = self.REASON_FOR_WARNING().map(|x| {
      x.to_string()
    });
    CommandSignificanceT {
      CONSEQUENCE_LEVEL,
      REASON_FOR_WARNING,
    }
  }

  /// Consequence level (1=lowest, higher=more severe)
  #[inline]
  pub fn CONSEQUENCE_LEVEL(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(CommandSignificance::VT_CONSEQUENCE_LEVEL, Some(0)).unwrap()}
  }
  /// Reason for significance
  #[inline]
  pub fn REASON_FOR_WARNING(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CommandSignificance::VT_REASON_FOR_WARNING, None)}
  }
}

impl flatbuffers::Verifiable for CommandSignificance<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("CONSEQUENCE_LEVEL", Self::VT_CONSEQUENCE_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("REASON_FOR_WARNING", Self::VT_REASON_FOR_WARNING, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandSignificanceArgs<'a> {
    pub CONSEQUENCE_LEVEL: u8,
    pub REASON_FOR_WARNING: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CommandSignificanceArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandSignificanceArgs {
      CONSEQUENCE_LEVEL: 0,
      REASON_FOR_WARNING: None,
    }
  }
}

pub struct CommandSignificanceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommandSignificanceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_CONSEQUENCE_LEVEL(&mut self, CONSEQUENCE_LEVEL: u8) {
    self.fbb_.push_slot::<u8>(CommandSignificance::VT_CONSEQUENCE_LEVEL, CONSEQUENCE_LEVEL, 0);
  }
  #[inline]
  pub fn add_REASON_FOR_WARNING(&mut self, REASON_FOR_WARNING: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CommandSignificance::VT_REASON_FOR_WARNING, REASON_FOR_WARNING);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommandSignificanceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommandSignificanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommandSignificance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommandSignificance<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommandSignificance");
      ds.field("CONSEQUENCE_LEVEL", &self.CONSEQUENCE_LEVEL());
      ds.field("REASON_FOR_WARNING", &self.REASON_FOR_WARNING());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CommandSignificanceT {
  pub CONSEQUENCE_LEVEL: u8,
  pub REASON_FOR_WARNING: Option<String>,
}
impl Default for CommandSignificanceT {
  fn default() -> Self {
    Self {
      CONSEQUENCE_LEVEL: 0,
      REASON_FOR_WARNING: None,
    }
  }
}
impl CommandSignificanceT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CommandSignificance<'b>> {
    let CONSEQUENCE_LEVEL = self.CONSEQUENCE_LEVEL;
    let REASON_FOR_WARNING = self.REASON_FOR_WARNING.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CommandSignificance::create(_fbb, &CommandSignificanceArgs{
      CONSEQUENCE_LEVEL,
      REASON_FOR_WARNING,
    })
  }
}
pub enum BaseMetaCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Base metacommand reference
pub struct BaseMetaCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BaseMetaCommand<'a> {
  type Inner = BaseMetaCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BaseMetaCommand<'a> {
  pub const VT_META_COMMAND_REF: flatbuffers::VOffsetT = 4;
  pub const VT_ARGUMENT_ASSIGNMENTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BaseMetaCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BaseMetaCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<BaseMetaCommand<'bldr>> {
    let mut builder = BaseMetaCommandBuilder::new(_fbb);
    if let Some(x) = args.ARGUMENT_ASSIGNMENTS { builder.add_ARGUMENT_ASSIGNMENTS(x); }
    if let Some(x) = args.META_COMMAND_REF { builder.add_META_COMMAND_REF(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BaseMetaCommandT {
    let META_COMMAND_REF = self.META_COMMAND_REF().map(|x| {
      x.to_string()
    });
    let ARGUMENT_ASSIGNMENTS = self.ARGUMENT_ASSIGNMENTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    BaseMetaCommandT {
      META_COMMAND_REF,
      ARGUMENT_ASSIGNMENTS,
    }
  }

  /// MetaCommand reference
  #[inline]
  pub fn META_COMMAND_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BaseMetaCommand::VT_META_COMMAND_REF, None)}
  }
  /// Argument assignments for inherited arguments
  #[inline]
  pub fn ARGUMENT_ASSIGNMENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArgumentAssignment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArgumentAssignment>>>>(BaseMetaCommand::VT_ARGUMENT_ASSIGNMENTS, None)}
  }
}

impl flatbuffers::Verifiable for BaseMetaCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("META_COMMAND_REF", Self::VT_META_COMMAND_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ArgumentAssignment>>>>("ARGUMENT_ASSIGNMENTS", Self::VT_ARGUMENT_ASSIGNMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BaseMetaCommandArgs<'a> {
    pub META_COMMAND_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ARGUMENT_ASSIGNMENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ArgumentAssignment<'a>>>>>,
}
impl<'a> Default for BaseMetaCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    BaseMetaCommandArgs {
      META_COMMAND_REF: None,
      ARGUMENT_ASSIGNMENTS: None,
    }
  }
}

pub struct BaseMetaCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BaseMetaCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_META_COMMAND_REF(&mut self, META_COMMAND_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BaseMetaCommand::VT_META_COMMAND_REF, META_COMMAND_REF);
  }
  #[inline]
  pub fn add_ARGUMENT_ASSIGNMENTS(&mut self, ARGUMENT_ASSIGNMENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ArgumentAssignment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BaseMetaCommand::VT_ARGUMENT_ASSIGNMENTS, ARGUMENT_ASSIGNMENTS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BaseMetaCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BaseMetaCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BaseMetaCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BaseMetaCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BaseMetaCommand");
      ds.field("META_COMMAND_REF", &self.META_COMMAND_REF());
      ds.field("ARGUMENT_ASSIGNMENTS", &self.ARGUMENT_ASSIGNMENTS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BaseMetaCommandT {
  pub META_COMMAND_REF: Option<String>,
  pub ARGUMENT_ASSIGNMENTS: Option<Vec<ArgumentAssignmentT>>,
}
impl Default for BaseMetaCommandT {
  fn default() -> Self {
    Self {
      META_COMMAND_REF: None,
      ARGUMENT_ASSIGNMENTS: None,
    }
  }
}
impl BaseMetaCommandT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BaseMetaCommand<'b>> {
    let META_COMMAND_REF = self.META_COMMAND_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ARGUMENT_ASSIGNMENTS = self.ARGUMENT_ASSIGNMENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    BaseMetaCommand::create(_fbb, &BaseMetaCommandArgs{
      META_COMMAND_REF,
      ARGUMENT_ASSIGNMENTS,
    })
  }
}
pub enum ArgumentAssignmentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Argument assignment (value binding)
pub struct ArgumentAssignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgumentAssignment<'a> {
  type Inner = ArgumentAssignment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ArgumentAssignment<'a> {
  pub const VT_ARGUMENT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgumentAssignment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArgumentAssignmentArgs<'args>
  ) -> flatbuffers::WIPOffset<ArgumentAssignment<'bldr>> {
    let mut builder = ArgumentAssignmentBuilder::new(_fbb);
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    if let Some(x) = args.ARGUMENT_NAME { builder.add_ARGUMENT_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ArgumentAssignmentT {
    let ARGUMENT_NAME = self.ARGUMENT_NAME().map(|x| {
      x.to_string()
    });
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    ArgumentAssignmentT {
      ARGUMENT_NAME,
      VALUE,
    }
  }

  /// Argument name
  #[inline]
  pub fn ARGUMENT_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArgumentAssignment::VT_ARGUMENT_NAME, None)}
  }
  /// Assigned value
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ArgumentAssignment::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for ArgumentAssignment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ARGUMENT_NAME", Self::VT_ARGUMENT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgumentAssignmentArgs<'a> {
    pub ARGUMENT_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ArgumentAssignmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArgumentAssignmentArgs {
      ARGUMENT_NAME: None,
      VALUE: None,
    }
  }
}

pub struct ArgumentAssignmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArgumentAssignmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ARGUMENT_NAME(&mut self, ARGUMENT_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentAssignment::VT_ARGUMENT_NAME, ARGUMENT_NAME);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArgumentAssignment::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArgumentAssignmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArgumentAssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgumentAssignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgumentAssignment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgumentAssignment");
      ds.field("ARGUMENT_NAME", &self.ARGUMENT_NAME());
      ds.field("VALUE", &self.VALUE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgumentAssignmentT {
  pub ARGUMENT_NAME: Option<String>,
  pub VALUE: Option<String>,
}
impl Default for ArgumentAssignmentT {
  fn default() -> Self {
    Self {
      ARGUMENT_NAME: None,
      VALUE: None,
    }
  }
}
impl ArgumentAssignmentT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ArgumentAssignment<'b>> {
    let ARGUMENT_NAME = self.ARGUMENT_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    ArgumentAssignment::create(_fbb, &ArgumentAssignmentArgs{
      ARGUMENT_NAME,
      VALUE,
    })
  }
}
pub enum InterlockOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Interlock constraint
pub struct Interlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Interlock<'a> {
  type Inner = Interlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Interlock<'a> {
  pub const VT_PARAMETER_REF: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_OPERATOR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Interlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args InterlockArgs<'args>
  ) -> flatbuffers::WIPOffset<Interlock<'bldr>> {
    let mut builder = InterlockBuilder::new(_fbb);
    if let Some(x) = args.VALUE { builder.add_VALUE(x); }
    if let Some(x) = args.PARAMETER_REF { builder.add_PARAMETER_REF(x); }
    builder.add_OPERATOR(args.OPERATOR);
    builder.finish()
  }

  pub fn unpack(&self) -> InterlockT {
    let PARAMETER_REF = self.PARAMETER_REF().map(|x| {
      x.to_string()
    });
    let VALUE = self.VALUE().map(|x| {
      x.to_string()
    });
    let OPERATOR = self.OPERATOR();
    InterlockT {
      PARAMETER_REF,
      VALUE,
      OPERATOR,
    }
  }

  /// Parameter reference
  #[inline]
  pub fn PARAMETER_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Interlock::VT_PARAMETER_REF, None)}
  }
  /// Required value
  #[inline]
  pub fn VALUE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Interlock::VT_VALUE, None)}
  }
  /// Operator for comparison
  #[inline]
  pub fn OPERATOR(&self) -> ComparisonOperator {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ComparisonOperator>(Interlock::VT_OPERATOR, Some(ComparisonOperator::EQ)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Interlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PARAMETER_REF", Self::VT_PARAMETER_REF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALUE", Self::VT_VALUE, false)?
     .visit_field::<ComparisonOperator>("OPERATOR", Self::VT_OPERATOR, false)?
     .finish();
    Ok(())
  }
}
pub struct InterlockArgs<'a> {
    pub PARAMETER_REF: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALUE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPERATOR: ComparisonOperator,
}
impl<'a> Default for InterlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    InterlockArgs {
      PARAMETER_REF: None,
      VALUE: None,
      OPERATOR: ComparisonOperator::EQ,
    }
  }
}

pub struct InterlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> InterlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_REF(&mut self, PARAMETER_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Interlock::VT_PARAMETER_REF, PARAMETER_REF);
  }
  #[inline]
  pub fn add_VALUE(&mut self, VALUE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Interlock::VT_VALUE, VALUE);
  }
  #[inline]
  pub fn add_OPERATOR(&mut self, OPERATOR: ComparisonOperator) {
    self.fbb_.push_slot::<ComparisonOperator>(Interlock::VT_OPERATOR, OPERATOR, ComparisonOperator::EQ);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> InterlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    InterlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Interlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Interlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Interlock");
      ds.field("PARAMETER_REF", &self.PARAMETER_REF());
      ds.field("VALUE", &self.VALUE());
      ds.field("OPERATOR", &self.OPERATOR());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct InterlockT {
  pub PARAMETER_REF: Option<String>,
  pub VALUE: Option<String>,
  pub OPERATOR: ComparisonOperator,
}
impl Default for InterlockT {
  fn default() -> Self {
    Self {
      PARAMETER_REF: None,
      VALUE: None,
      OPERATOR: ComparisonOperator::EQ,
    }
  }
}
impl InterlockT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Interlock<'b>> {
    let PARAMETER_REF = self.PARAMETER_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALUE = self.VALUE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPERATOR = self.OPERATOR;
    Interlock::create(_fbb, &InterlockArgs{
      PARAMETER_REF,
      VALUE,
      OPERATOR,
    })
  }
}
pub enum MetaCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

/// MetaCommand definition
pub struct MetaCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetaCommand<'a> {
  type Inner = MetaCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MetaCommand<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_ABSTRACT: flatbuffers::VOffsetT = 10;
  pub const VT_ARGUMENTS: flatbuffers::VOffsetT = 12;
  pub const VT_COMMAND_CONTAINER: flatbuffers::VOffsetT = 14;
  pub const VT_BASE_META_COMMAND: flatbuffers::VOffsetT = 16;
  pub const VT_VERIFIERS: flatbuffers::VOffsetT = 18;
  pub const VT_SIGNIFICANCE: flatbuffers::VOffsetT = 20;
  pub const VT_INTERLOCKS: flatbuffers::VOffsetT = 22;
  pub const VT_DEFAULT_SIGNIFICANCE: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MetaCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MetaCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<MetaCommand<'bldr>> {
    let mut builder = MetaCommandBuilder::new(_fbb);
    if let Some(x) = args.DEFAULT_SIGNIFICANCE { builder.add_DEFAULT_SIGNIFICANCE(x); }
    if let Some(x) = args.INTERLOCKS { builder.add_INTERLOCKS(x); }
    if let Some(x) = args.SIGNIFICANCE { builder.add_SIGNIFICANCE(x); }
    if let Some(x) = args.VERIFIERS { builder.add_VERIFIERS(x); }
    if let Some(x) = args.BASE_META_COMMAND { builder.add_BASE_META_COMMAND(x); }
    if let Some(x) = args.COMMAND_CONTAINER { builder.add_COMMAND_CONTAINER(x); }
    if let Some(x) = args.ARGUMENTS { builder.add_ARGUMENTS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_ABSTRACT(args.ABSTRACT);
    builder.finish()
  }

  pub fn unpack(&self) -> MetaCommandT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let ABSTRACT = self.ABSTRACT();
    let ARGUMENTS = self.ARGUMENTS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let COMMAND_CONTAINER = self.COMMAND_CONTAINER().map(|x| {
      Box::new(x.unpack())
    });
    let BASE_META_COMMAND = self.BASE_META_COMMAND().map(|x| {
      Box::new(x.unpack())
    });
    let VERIFIERS = self.VERIFIERS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let SIGNIFICANCE = self.SIGNIFICANCE().map(|x| {
      Box::new(x.unpack())
    });
    let INTERLOCKS = self.INTERLOCKS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let DEFAULT_SIGNIFICANCE = self.DEFAULT_SIGNIFICANCE().map(|x| {
      Box::new(x.unpack())
    });
    MetaCommandT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ABSTRACT,
      ARGUMENTS,
      COMMAND_CONTAINER,
      BASE_META_COMMAND,
      VERIFIERS,
      SIGNIFICANCE,
      INTERLOCKS,
      DEFAULT_SIGNIFICANCE,
    }
  }

  /// Command name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetaCommand::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetaCommand::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetaCommand::VT_LONG_DESCRIPTION, None)}
  }
  /// Abstract command (base only)
  #[inline]
  pub fn ABSTRACT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MetaCommand::VT_ABSTRACT, Some(false)).unwrap()}
  }
  /// Argument list
  #[inline]
  pub fn ARGUMENTS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument>>>>(MetaCommand::VT_ARGUMENTS, None)}
  }
  /// Command container
  #[inline]
  pub fn COMMAND_CONTAINER(&self) -> Option<CommandContainer<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CommandContainer>>(MetaCommand::VT_COMMAND_CONTAINER, None)}
  }
  /// Base metacommand (inheritance)
  #[inline]
  pub fn BASE_META_COMMAND(&self) -> Option<BaseMetaCommand<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BaseMetaCommand>>(MetaCommand::VT_BASE_META_COMMAND, None)}
  }
  /// Command verifiers
  #[inline]
  pub fn VERIFIERS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandVerifier<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandVerifier>>>>(MetaCommand::VT_VERIFIERS, None)}
  }
  /// Command significance
  #[inline]
  pub fn SIGNIFICANCE(&self) -> Option<CommandSignificance<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CommandSignificance>>(MetaCommand::VT_SIGNIFICANCE, None)}
  }
  /// Interlock constraints
  #[inline]
  pub fn INTERLOCKS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Interlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Interlock>>>>(MetaCommand::VT_INTERLOCKS, None)}
  }
  /// Default significance
  #[inline]
  pub fn DEFAULT_SIGNIFICANCE(&self) -> Option<CommandSignificance<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CommandSignificance>>(MetaCommand::VT_DEFAULT_SIGNIFICANCE, None)}
  }
}

impl flatbuffers::Verifiable for MetaCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<bool>("ABSTRACT", Self::VT_ABSTRACT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Argument>>>>("ARGUMENTS", Self::VT_ARGUMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CommandContainer>>("COMMAND_CONTAINER", Self::VT_COMMAND_CONTAINER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BaseMetaCommand>>("BASE_META_COMMAND", Self::VT_BASE_META_COMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CommandVerifier>>>>("VERIFIERS", Self::VT_VERIFIERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CommandSignificance>>("SIGNIFICANCE", Self::VT_SIGNIFICANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Interlock>>>>("INTERLOCKS", Self::VT_INTERLOCKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CommandSignificance>>("DEFAULT_SIGNIFICANCE", Self::VT_DEFAULT_SIGNIFICANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct MetaCommandArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ABSTRACT: bool,
    pub ARGUMENTS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Argument<'a>>>>>,
    pub COMMAND_CONTAINER: Option<flatbuffers::WIPOffset<CommandContainer<'a>>>,
    pub BASE_META_COMMAND: Option<flatbuffers::WIPOffset<BaseMetaCommand<'a>>>,
    pub VERIFIERS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CommandVerifier<'a>>>>>,
    pub SIGNIFICANCE: Option<flatbuffers::WIPOffset<CommandSignificance<'a>>>,
    pub INTERLOCKS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Interlock<'a>>>>>,
    pub DEFAULT_SIGNIFICANCE: Option<flatbuffers::WIPOffset<CommandSignificance<'a>>>,
}
impl<'a> Default for MetaCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetaCommandArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ABSTRACT: false,
      ARGUMENTS: None,
      COMMAND_CONTAINER: None,
      BASE_META_COMMAND: None,
      VERIFIERS: None,
      SIGNIFICANCE: None,
      INTERLOCKS: None,
      DEFAULT_SIGNIFICANCE: None,
    }
  }
}

pub struct MetaCommandBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetaCommandBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_ABSTRACT(&mut self, ABSTRACT: bool) {
    self.fbb_.push_slot::<bool>(MetaCommand::VT_ABSTRACT, ABSTRACT, false);
  }
  #[inline]
  pub fn add_ARGUMENTS(&mut self, ARGUMENTS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Argument<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_ARGUMENTS, ARGUMENTS);
  }
  #[inline]
  pub fn add_COMMAND_CONTAINER(&mut self, COMMAND_CONTAINER: flatbuffers::WIPOffset<CommandContainer<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CommandContainer>>(MetaCommand::VT_COMMAND_CONTAINER, COMMAND_CONTAINER);
  }
  #[inline]
  pub fn add_BASE_META_COMMAND(&mut self, BASE_META_COMMAND: flatbuffers::WIPOffset<BaseMetaCommand<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BaseMetaCommand>>(MetaCommand::VT_BASE_META_COMMAND, BASE_META_COMMAND);
  }
  #[inline]
  pub fn add_VERIFIERS(&mut self, VERIFIERS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CommandVerifier<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_VERIFIERS, VERIFIERS);
  }
  #[inline]
  pub fn add_SIGNIFICANCE(&mut self, SIGNIFICANCE: flatbuffers::WIPOffset<CommandSignificance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CommandSignificance>>(MetaCommand::VT_SIGNIFICANCE, SIGNIFICANCE);
  }
  #[inline]
  pub fn add_INTERLOCKS(&mut self, INTERLOCKS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Interlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommand::VT_INTERLOCKS, INTERLOCKS);
  }
  #[inline]
  pub fn add_DEFAULT_SIGNIFICANCE(&mut self, DEFAULT_SIGNIFICANCE: flatbuffers::WIPOffset<CommandSignificance<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CommandSignificance>>(MetaCommand::VT_DEFAULT_SIGNIFICANCE, DEFAULT_SIGNIFICANCE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MetaCommandBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MetaCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetaCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MetaCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MetaCommand");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("ABSTRACT", &self.ABSTRACT());
      ds.field("ARGUMENTS", &self.ARGUMENTS());
      ds.field("COMMAND_CONTAINER", &self.COMMAND_CONTAINER());
      ds.field("BASE_META_COMMAND", &self.BASE_META_COMMAND());
      ds.field("VERIFIERS", &self.VERIFIERS());
      ds.field("SIGNIFICANCE", &self.SIGNIFICANCE());
      ds.field("INTERLOCKS", &self.INTERLOCKS());
      ds.field("DEFAULT_SIGNIFICANCE", &self.DEFAULT_SIGNIFICANCE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MetaCommandT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub ABSTRACT: bool,
  pub ARGUMENTS: Option<Vec<ArgumentT>>,
  pub COMMAND_CONTAINER: Option<Box<CommandContainerT>>,
  pub BASE_META_COMMAND: Option<Box<BaseMetaCommandT>>,
  pub VERIFIERS: Option<Vec<CommandVerifierT>>,
  pub SIGNIFICANCE: Option<Box<CommandSignificanceT>>,
  pub INTERLOCKS: Option<Vec<InterlockT>>,
  pub DEFAULT_SIGNIFICANCE: Option<Box<CommandSignificanceT>>,
}
impl Default for MetaCommandT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      ABSTRACT: false,
      ARGUMENTS: None,
      COMMAND_CONTAINER: None,
      BASE_META_COMMAND: None,
      VERIFIERS: None,
      SIGNIFICANCE: None,
      INTERLOCKS: None,
      DEFAULT_SIGNIFICANCE: None,
    }
  }
}
impl MetaCommandT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MetaCommand<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ABSTRACT = self.ABSTRACT;
    let ARGUMENTS = self.ARGUMENTS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let COMMAND_CONTAINER = self.COMMAND_CONTAINER.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let BASE_META_COMMAND = self.BASE_META_COMMAND.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let VERIFIERS = self.VERIFIERS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let SIGNIFICANCE = self.SIGNIFICANCE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let INTERLOCKS = self.INTERLOCKS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let DEFAULT_SIGNIFICANCE = self.DEFAULT_SIGNIFICANCE.as_ref().map(|x|{
      x.pack(_fbb)
    });
    MetaCommand::create(_fbb, &MetaCommandArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      ABSTRACT,
      ARGUMENTS,
      COMMAND_CONTAINER,
      BASE_META_COMMAND,
      VERIFIERS,
      SIGNIFICANCE,
      INTERLOCKS,
      DEFAULT_SIGNIFICANCE,
    })
  }
}
pub enum MetaCommandSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of metacommands
pub struct MetaCommandSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetaCommandSet<'a> {
  type Inner = MetaCommandSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MetaCommandSet<'a> {
  pub const VT_META_COMMANDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MetaCommandSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MetaCommandSetArgs<'args>
  ) -> flatbuffers::WIPOffset<MetaCommandSet<'bldr>> {
    let mut builder = MetaCommandSetBuilder::new(_fbb);
    if let Some(x) = args.META_COMMANDS { builder.add_META_COMMANDS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MetaCommandSetT {
    let META_COMMANDS = self.META_COMMANDS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    MetaCommandSetT {
      META_COMMANDS,
    }
  }

  /// MetaCommands
  #[inline]
  pub fn META_COMMANDS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetaCommand<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetaCommand>>>>(MetaCommandSet::VT_META_COMMANDS, None)}
  }
}

impl flatbuffers::Verifiable for MetaCommandSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetaCommand>>>>("META_COMMANDS", Self::VT_META_COMMANDS, false)?
     .finish();
    Ok(())
  }
}
pub struct MetaCommandSetArgs<'a> {
    pub META_COMMANDS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetaCommand<'a>>>>>,
}
impl<'a> Default for MetaCommandSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetaCommandSetArgs {
      META_COMMANDS: None,
    }
  }
}

pub struct MetaCommandSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetaCommandSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_META_COMMANDS(&mut self, META_COMMANDS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MetaCommand<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetaCommandSet::VT_META_COMMANDS, META_COMMANDS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MetaCommandSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MetaCommandSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetaCommandSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MetaCommandSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MetaCommandSet");
      ds.field("META_COMMANDS", &self.META_COMMANDS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MetaCommandSetT {
  pub META_COMMANDS: Option<Vec<MetaCommandT>>,
}
impl Default for MetaCommandSetT {
  fn default() -> Self {
    Self {
      META_COMMANDS: None,
    }
  }
}
impl MetaCommandSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<MetaCommandSet<'b>> {
    let META_COMMANDS = self.META_COMMANDS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    MetaCommandSet::create(_fbb, &MetaCommandSetArgs{
      META_COMMANDS,
    })
  }
}
pub enum FixedFrameStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Fixed frame stream
pub struct FixedFrameStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FixedFrameStream<'a> {
  type Inner = FixedFrameStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FixedFrameStream<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_FRAME_SIZE_IN_BITS: flatbuffers::VOffsetT = 8;
  pub const VT_SYNC_PATTERN: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FixedFrameStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FixedFrameStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<FixedFrameStream<'bldr>> {
    let mut builder = FixedFrameStreamBuilder::new(_fbb);
    if let Some(x) = args.SYNC_PATTERN { builder.add_SYNC_PATTERN(x); }
    builder.add_FRAME_SIZE_IN_BITS(args.FRAME_SIZE_IN_BITS);
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> FixedFrameStreamT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let FRAME_SIZE_IN_BITS = self.FRAME_SIZE_IN_BITS();
    let SYNC_PATTERN = self.SYNC_PATTERN().map(|x| {
      x.to_string()
    });
    FixedFrameStreamT {
      NAME,
      SHORT_DESCRIPTION,
      FRAME_SIZE_IN_BITS,
      SYNC_PATTERN,
    }
  }

  /// Stream name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FixedFrameStream::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FixedFrameStream::VT_SHORT_DESCRIPTION, None)}
  }
  /// Frame size in bits
  #[inline]
  pub fn FRAME_SIZE_IN_BITS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(FixedFrameStream::VT_FRAME_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Sync pattern (hex string)
  #[inline]
  pub fn SYNC_PATTERN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FixedFrameStream::VT_SYNC_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for FixedFrameStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<u32>("FRAME_SIZE_IN_BITS", Self::VT_FRAME_SIZE_IN_BITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SYNC_PATTERN", Self::VT_SYNC_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct FixedFrameStreamArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FRAME_SIZE_IN_BITS: u32,
    pub SYNC_PATTERN: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FixedFrameStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    FixedFrameStreamArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      FRAME_SIZE_IN_BITS: 0,
      SYNC_PATTERN: None,
    }
  }
}

pub struct FixedFrameStreamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FixedFrameStreamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedFrameStream::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedFrameStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_FRAME_SIZE_IN_BITS(&mut self, FRAME_SIZE_IN_BITS: u32) {
    self.fbb_.push_slot::<u32>(FixedFrameStream::VT_FRAME_SIZE_IN_BITS, FRAME_SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_SYNC_PATTERN(&mut self, SYNC_PATTERN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FixedFrameStream::VT_SYNC_PATTERN, SYNC_PATTERN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FixedFrameStreamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FixedFrameStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FixedFrameStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FixedFrameStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FixedFrameStream");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("FRAME_SIZE_IN_BITS", &self.FRAME_SIZE_IN_BITS());
      ds.field("SYNC_PATTERN", &self.SYNC_PATTERN());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FixedFrameStreamT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub FRAME_SIZE_IN_BITS: u32,
  pub SYNC_PATTERN: Option<String>,
}
impl Default for FixedFrameStreamT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      FRAME_SIZE_IN_BITS: 0,
      SYNC_PATTERN: None,
    }
  }
}
impl FixedFrameStreamT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<FixedFrameStream<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FRAME_SIZE_IN_BITS = self.FRAME_SIZE_IN_BITS;
    let SYNC_PATTERN = self.SYNC_PATTERN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    FixedFrameStream::create(_fbb, &FixedFrameStreamArgs{
      NAME,
      SHORT_DESCRIPTION,
      FRAME_SIZE_IN_BITS,
      SYNC_PATTERN,
    })
  }
}
pub enum VariableFrameStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Variable frame stream
pub struct VariableFrameStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariableFrameStream<'a> {
  type Inner = VariableFrameStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VariableFrameStream<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_MIN_FRAME_SIZE_IN_BITS: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_FRAME_SIZE_IN_BITS: flatbuffers::VOffsetT = 10;
  pub const VT_SIZE_FIELD_OFFSET: flatbuffers::VOffsetT = 12;
  pub const VT_SIZE_FIELD_SIZE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VariableFrameStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VariableFrameStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<VariableFrameStream<'bldr>> {
    let mut builder = VariableFrameStreamBuilder::new(_fbb);
    builder.add_SIZE_FIELD_OFFSET(args.SIZE_FIELD_OFFSET);
    builder.add_MAX_FRAME_SIZE_IN_BITS(args.MAX_FRAME_SIZE_IN_BITS);
    builder.add_MIN_FRAME_SIZE_IN_BITS(args.MIN_FRAME_SIZE_IN_BITS);
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.add_SIZE_FIELD_SIZE(args.SIZE_FIELD_SIZE);
    builder.finish()
  }

  pub fn unpack(&self) -> VariableFrameStreamT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let MIN_FRAME_SIZE_IN_BITS = self.MIN_FRAME_SIZE_IN_BITS();
    let MAX_FRAME_SIZE_IN_BITS = self.MAX_FRAME_SIZE_IN_BITS();
    let SIZE_FIELD_OFFSET = self.SIZE_FIELD_OFFSET();
    let SIZE_FIELD_SIZE = self.SIZE_FIELD_SIZE();
    VariableFrameStreamT {
      NAME,
      SHORT_DESCRIPTION,
      MIN_FRAME_SIZE_IN_BITS,
      MAX_FRAME_SIZE_IN_BITS,
      SIZE_FIELD_OFFSET,
      SIZE_FIELD_SIZE,
    }
  }

  /// Stream name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VariableFrameStream::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VariableFrameStream::VT_SHORT_DESCRIPTION, None)}
  }
  /// Minimum frame size in bits
  #[inline]
  pub fn MIN_FRAME_SIZE_IN_BITS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VariableFrameStream::VT_MIN_FRAME_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Maximum frame size in bits
  #[inline]
  pub fn MAX_FRAME_SIZE_IN_BITS(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VariableFrameStream::VT_MAX_FRAME_SIZE_IN_BITS, Some(0)).unwrap()}
  }
  /// Size field location in bits
  #[inline]
  pub fn SIZE_FIELD_OFFSET(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(VariableFrameStream::VT_SIZE_FIELD_OFFSET, Some(0)).unwrap()}
  }
  /// Size field size in bits
  #[inline]
  pub fn SIZE_FIELD_SIZE(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(VariableFrameStream::VT_SIZE_FIELD_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VariableFrameStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<u32>("MIN_FRAME_SIZE_IN_BITS", Self::VT_MIN_FRAME_SIZE_IN_BITS, false)?
     .visit_field::<u32>("MAX_FRAME_SIZE_IN_BITS", Self::VT_MAX_FRAME_SIZE_IN_BITS, false)?
     .visit_field::<u32>("SIZE_FIELD_OFFSET", Self::VT_SIZE_FIELD_OFFSET, false)?
     .visit_field::<u16>("SIZE_FIELD_SIZE", Self::VT_SIZE_FIELD_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct VariableFrameStreamArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MIN_FRAME_SIZE_IN_BITS: u32,
    pub MAX_FRAME_SIZE_IN_BITS: u32,
    pub SIZE_FIELD_OFFSET: u32,
    pub SIZE_FIELD_SIZE: u16,
}
impl<'a> Default for VariableFrameStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariableFrameStreamArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      MIN_FRAME_SIZE_IN_BITS: 0,
      MAX_FRAME_SIZE_IN_BITS: 0,
      SIZE_FIELD_OFFSET: 0,
      SIZE_FIELD_SIZE: 0,
    }
  }
}

pub struct VariableFrameStreamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VariableFrameStreamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableFrameStream::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableFrameStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_MIN_FRAME_SIZE_IN_BITS(&mut self, MIN_FRAME_SIZE_IN_BITS: u32) {
    self.fbb_.push_slot::<u32>(VariableFrameStream::VT_MIN_FRAME_SIZE_IN_BITS, MIN_FRAME_SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_MAX_FRAME_SIZE_IN_BITS(&mut self, MAX_FRAME_SIZE_IN_BITS: u32) {
    self.fbb_.push_slot::<u32>(VariableFrameStream::VT_MAX_FRAME_SIZE_IN_BITS, MAX_FRAME_SIZE_IN_BITS, 0);
  }
  #[inline]
  pub fn add_SIZE_FIELD_OFFSET(&mut self, SIZE_FIELD_OFFSET: u32) {
    self.fbb_.push_slot::<u32>(VariableFrameStream::VT_SIZE_FIELD_OFFSET, SIZE_FIELD_OFFSET, 0);
  }
  #[inline]
  pub fn add_SIZE_FIELD_SIZE(&mut self, SIZE_FIELD_SIZE: u16) {
    self.fbb_.push_slot::<u16>(VariableFrameStream::VT_SIZE_FIELD_SIZE, SIZE_FIELD_SIZE, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VariableFrameStreamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VariableFrameStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariableFrameStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VariableFrameStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VariableFrameStream");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("MIN_FRAME_SIZE_IN_BITS", &self.MIN_FRAME_SIZE_IN_BITS());
      ds.field("MAX_FRAME_SIZE_IN_BITS", &self.MAX_FRAME_SIZE_IN_BITS());
      ds.field("SIZE_FIELD_OFFSET", &self.SIZE_FIELD_OFFSET());
      ds.field("SIZE_FIELD_SIZE", &self.SIZE_FIELD_SIZE());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct VariableFrameStreamT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub MIN_FRAME_SIZE_IN_BITS: u32,
  pub MAX_FRAME_SIZE_IN_BITS: u32,
  pub SIZE_FIELD_OFFSET: u32,
  pub SIZE_FIELD_SIZE: u16,
}
impl Default for VariableFrameStreamT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      MIN_FRAME_SIZE_IN_BITS: 0,
      MAX_FRAME_SIZE_IN_BITS: 0,
      SIZE_FIELD_OFFSET: 0,
      SIZE_FIELD_SIZE: 0,
    }
  }
}
impl VariableFrameStreamT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<VariableFrameStream<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MIN_FRAME_SIZE_IN_BITS = self.MIN_FRAME_SIZE_IN_BITS;
    let MAX_FRAME_SIZE_IN_BITS = self.MAX_FRAME_SIZE_IN_BITS;
    let SIZE_FIELD_OFFSET = self.SIZE_FIELD_OFFSET;
    let SIZE_FIELD_SIZE = self.SIZE_FIELD_SIZE;
    VariableFrameStream::create(_fbb, &VariableFrameStreamArgs{
      NAME,
      SHORT_DESCRIPTION,
      MIN_FRAME_SIZE_IN_BITS,
      MAX_FRAME_SIZE_IN_BITS,
      SIZE_FIELD_OFFSET,
      SIZE_FIELD_SIZE,
    })
  }
}
pub enum CustomStreamOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Custom stream
pub struct CustomStream<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomStream<'a> {
  type Inner = CustomStream<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CustomStream<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_ALGORITHM_REF: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomStream { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CustomStreamArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomStream<'bldr>> {
    let mut builder = CustomStreamBuilder::new(_fbb);
    if let Some(x) = args.ALGORITHM_REF { builder.add_ALGORITHM_REF(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CustomStreamT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let ALGORITHM_REF = self.ALGORITHM_REF().map(|x| {
      x.to_string()
    });
    CustomStreamT {
      NAME,
      SHORT_DESCRIPTION,
      ALGORITHM_REF,
    }
  }

  /// Stream name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomStream::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomStream::VT_SHORT_DESCRIPTION, None)}
  }
  /// Algorithm reference for parsing
  #[inline]
  pub fn ALGORITHM_REF(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomStream::VT_ALGORITHM_REF, None)}
  }
}

impl flatbuffers::Verifiable for CustomStream<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ALGORITHM_REF", Self::VT_ALGORITHM_REF, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomStreamArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ALGORITHM_REF: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CustomStreamArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomStreamArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      ALGORITHM_REF: None,
    }
  }
}

pub struct CustomStreamBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CustomStreamBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomStream::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomStream::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_ALGORITHM_REF(&mut self, ALGORITHM_REF: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomStream::VT_ALGORITHM_REF, ALGORITHM_REF);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CustomStreamBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CustomStreamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomStream<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomStream<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomStream");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("ALGORITHM_REF", &self.ALGORITHM_REF());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CustomStreamT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub ALGORITHM_REF: Option<String>,
}
impl Default for CustomStreamT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      ALGORITHM_REF: None,
    }
  }
}
impl CustomStreamT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CustomStream<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ALGORITHM_REF = self.ALGORITHM_REF.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    CustomStream::create(_fbb, &CustomStreamArgs{
      NAME,
      SHORT_DESCRIPTION,
      ALGORITHM_REF,
    })
  }
}
pub enum StreamSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of streams
pub struct StreamSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StreamSet<'a> {
  type Inner = StreamSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StreamSet<'a> {
  pub const VT_FIXED_FRAME_STREAMS: flatbuffers::VOffsetT = 4;
  pub const VT_VARIABLE_FRAME_STREAMS: flatbuffers::VOffsetT = 6;
  pub const VT_CUSTOM_STREAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StreamSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StreamSetArgs<'args>
  ) -> flatbuffers::WIPOffset<StreamSet<'bldr>> {
    let mut builder = StreamSetBuilder::new(_fbb);
    if let Some(x) = args.CUSTOM_STREAMS { builder.add_CUSTOM_STREAMS(x); }
    if let Some(x) = args.VARIABLE_FRAME_STREAMS { builder.add_VARIABLE_FRAME_STREAMS(x); }
    if let Some(x) = args.FIXED_FRAME_STREAMS { builder.add_FIXED_FRAME_STREAMS(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> StreamSetT {
    let FIXED_FRAME_STREAMS = self.FIXED_FRAME_STREAMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let VARIABLE_FRAME_STREAMS = self.VARIABLE_FRAME_STREAMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let CUSTOM_STREAMS = self.CUSTOM_STREAMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    StreamSetT {
      FIXED_FRAME_STREAMS,
      VARIABLE_FRAME_STREAMS,
      CUSTOM_STREAMS,
    }
  }

  /// Fixed frame streams
  #[inline]
  pub fn FIXED_FRAME_STREAMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedFrameStream<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedFrameStream>>>>(StreamSet::VT_FIXED_FRAME_STREAMS, None)}
  }
  /// Variable frame streams
  #[inline]
  pub fn VARIABLE_FRAME_STREAMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableFrameStream<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableFrameStream>>>>(StreamSet::VT_VARIABLE_FRAME_STREAMS, None)}
  }
  /// Custom streams
  #[inline]
  pub fn CUSTOM_STREAMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomStream<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomStream>>>>(StreamSet::VT_CUSTOM_STREAMS, None)}
  }
}

impl flatbuffers::Verifiable for StreamSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FixedFrameStream>>>>("FIXED_FRAME_STREAMS", Self::VT_FIXED_FRAME_STREAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VariableFrameStream>>>>("VARIABLE_FRAME_STREAMS", Self::VT_VARIABLE_FRAME_STREAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CustomStream>>>>("CUSTOM_STREAMS", Self::VT_CUSTOM_STREAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct StreamSetArgs<'a> {
    pub FIXED_FRAME_STREAMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FixedFrameStream<'a>>>>>,
    pub VARIABLE_FRAME_STREAMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableFrameStream<'a>>>>>,
    pub CUSTOM_STREAMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CustomStream<'a>>>>>,
}
impl<'a> Default for StreamSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    StreamSetArgs {
      FIXED_FRAME_STREAMS: None,
      VARIABLE_FRAME_STREAMS: None,
      CUSTOM_STREAMS: None,
    }
  }
}

pub struct StreamSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StreamSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_FIXED_FRAME_STREAMS(&mut self, FIXED_FRAME_STREAMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FixedFrameStream<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StreamSet::VT_FIXED_FRAME_STREAMS, FIXED_FRAME_STREAMS);
  }
  #[inline]
  pub fn add_VARIABLE_FRAME_STREAMS(&mut self, VARIABLE_FRAME_STREAMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VariableFrameStream<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StreamSet::VT_VARIABLE_FRAME_STREAMS, VARIABLE_FRAME_STREAMS);
  }
  #[inline]
  pub fn add_CUSTOM_STREAMS(&mut self, CUSTOM_STREAMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CustomStream<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StreamSet::VT_CUSTOM_STREAMS, CUSTOM_STREAMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StreamSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StreamSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StreamSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StreamSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StreamSet");
      ds.field("FIXED_FRAME_STREAMS", &self.FIXED_FRAME_STREAMS());
      ds.field("VARIABLE_FRAME_STREAMS", &self.VARIABLE_FRAME_STREAMS());
      ds.field("CUSTOM_STREAMS", &self.CUSTOM_STREAMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StreamSetT {
  pub FIXED_FRAME_STREAMS: Option<Vec<FixedFrameStreamT>>,
  pub VARIABLE_FRAME_STREAMS: Option<Vec<VariableFrameStreamT>>,
  pub CUSTOM_STREAMS: Option<Vec<CustomStreamT>>,
}
impl Default for StreamSetT {
  fn default() -> Self {
    Self {
      FIXED_FRAME_STREAMS: None,
      VARIABLE_FRAME_STREAMS: None,
      CUSTOM_STREAMS: None,
    }
  }
}
impl StreamSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<StreamSet<'b>> {
    let FIXED_FRAME_STREAMS = self.FIXED_FRAME_STREAMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let VARIABLE_FRAME_STREAMS = self.VARIABLE_FRAME_STREAMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let CUSTOM_STREAMS = self.CUSTOM_STREAMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    StreamSet::create(_fbb, &StreamSetArgs{
      FIXED_FRAME_STREAMS,
      VARIABLE_FRAME_STREAMS,
      CUSTOM_STREAMS,
    })
  }
}
pub enum ServiceOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Service definition
pub struct Service<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Service<'a> {
  type Inner = Service<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Service<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_CONTAINER_REFS: flatbuffers::VOffsetT = 10;
  pub const VT_COMMAND_REFS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Service { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServiceArgs<'args>
  ) -> flatbuffers::WIPOffset<Service<'bldr>> {
    let mut builder = ServiceBuilder::new(_fbb);
    if let Some(x) = args.COMMAND_REFS { builder.add_COMMAND_REFS(x); }
    if let Some(x) = args.CONTAINER_REFS { builder.add_CONTAINER_REFS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ServiceT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let CONTAINER_REFS = self.CONTAINER_REFS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    let COMMAND_REFS = self.COMMAND_REFS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    ServiceT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      CONTAINER_REFS,
      COMMAND_REFS,
    }
  }

  /// Service name
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Service::VT_LONG_DESCRIPTION, None)}
  }
  /// Container references provided by this service
  #[inline]
  pub fn CONTAINER_REFS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Service::VT_CONTAINER_REFS, None)}
  }
  /// Command references accepted by this service
  #[inline]
  pub fn COMMAND_REFS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Service::VT_COMMAND_REFS, None)}
  }
}

impl flatbuffers::Verifiable for Service<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("CONTAINER_REFS", Self::VT_CONTAINER_REFS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("COMMAND_REFS", Self::VT_COMMAND_REFS, false)?
     .finish();
    Ok(())
  }
}
pub struct ServiceArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CONTAINER_REFS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub COMMAND_REFS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ServiceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServiceArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      CONTAINER_REFS: None,
      COMMAND_REFS: None,
    }
  }
}

pub struct ServiceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServiceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_CONTAINER_REFS(&mut self, CONTAINER_REFS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_CONTAINER_REFS, CONTAINER_REFS);
  }
  #[inline]
  pub fn add_COMMAND_REFS(&mut self, COMMAND_REFS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Service::VT_COMMAND_REFS, COMMAND_REFS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServiceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServiceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Service<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Service<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Service");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("CONTAINER_REFS", &self.CONTAINER_REFS());
      ds.field("COMMAND_REFS", &self.COMMAND_REFS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ServiceT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub CONTAINER_REFS: Option<Vec<String>>,
  pub COMMAND_REFS: Option<Vec<String>>,
}
impl Default for ServiceT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      CONTAINER_REFS: None,
      COMMAND_REFS: None,
    }
  }
}
impl ServiceT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<Service<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CONTAINER_REFS = self.CONTAINER_REFS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    let COMMAND_REFS = self.COMMAND_REFS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    Service::create(_fbb, &ServiceArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      CONTAINER_REFS,
      COMMAND_REFS,
    })
  }
}
pub enum ServiceSetOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Collection of services
pub struct ServiceSet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ServiceSet<'a> {
  type Inner = ServiceSet<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ServiceSet<'a> {
  pub const VT_SERVICES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ServiceSet { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServiceSetArgs<'args>
  ) -> flatbuffers::WIPOffset<ServiceSet<'bldr>> {
    let mut builder = ServiceSetBuilder::new(_fbb);
    if let Some(x) = args.SERVICES { builder.add_SERVICES(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ServiceSetT {
    let SERVICES = self.SERVICES().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ServiceSetT {
      SERVICES,
    }
  }

  /// Services
  #[inline]
  pub fn SERVICES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service>>>>(ServiceSet::VT_SERVICES, None)}
  }
}

impl flatbuffers::Verifiable for ServiceSet<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Service>>>>("SERVICES", Self::VT_SERVICES, false)?
     .finish();
    Ok(())
  }
}
pub struct ServiceSetArgs<'a> {
    pub SERVICES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Service<'a>>>>>,
}
impl<'a> Default for ServiceSetArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServiceSetArgs {
      SERVICES: None,
    }
  }
}

pub struct ServiceSetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServiceSetBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_SERVICES(&mut self, SERVICES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Service<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServiceSet::VT_SERVICES, SERVICES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServiceSetBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServiceSetBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ServiceSet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ServiceSet<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ServiceSet");
      ds.field("SERVICES", &self.SERVICES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ServiceSetT {
  pub SERVICES: Option<Vec<ServiceT>>,
}
impl Default for ServiceSetT {
  fn default() -> Self {
    Self {
      SERVICES: None,
    }
  }
}
impl ServiceSetT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<ServiceSet<'b>> {
    let SERVICES = self.SERVICES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    ServiceSet::create(_fbb, &ServiceSetArgs{
      SERVICES,
    })
  }
}
pub enum XTCHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Document header information
pub struct XTCHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for XTCHeader<'a> {
  type Inner = XTCHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> XTCHeader<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_DATE: flatbuffers::VOffsetT = 6;
  pub const VT_CLASSIFICATION: flatbuffers::VOffsetT = 8;
  pub const VT_VALIDATION_STATUS: flatbuffers::VOffsetT = 10;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 12;
  pub const VT_NOTES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    XTCHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args XTCHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<XTCHeader<'bldr>> {
    let mut builder = XTCHeaderBuilder::new(_fbb);
    if let Some(x) = args.NOTES { builder.add_NOTES(x); }
    if let Some(x) = args.AUTHOR { builder.add_AUTHOR(x); }
    if let Some(x) = args.VALIDATION_STATUS { builder.add_VALIDATION_STATUS(x); }
    if let Some(x) = args.CLASSIFICATION { builder.add_CLASSIFICATION(x); }
    if let Some(x) = args.DATE { builder.add_DATE(x); }
    if let Some(x) = args.VERSION { builder.add_VERSION(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> XTCHeaderT {
    let VERSION = self.VERSION().map(|x| {
      x.to_string()
    });
    let DATE = self.DATE().map(|x| {
      x.to_string()
    });
    let CLASSIFICATION = self.CLASSIFICATION().map(|x| {
      x.to_string()
    });
    let VALIDATION_STATUS = self.VALIDATION_STATUS().map(|x| {
      x.to_string()
    });
    let AUTHOR = self.AUTHOR().map(|x| {
      x.to_string()
    });
    let NOTES = self.NOTES().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    XTCHeaderT {
      VERSION,
      DATE,
      CLASSIFICATION,
      VALIDATION_STATUS,
      AUTHOR,
      NOTES,
    }
  }

  /// Version of this XTCE document
  #[inline]
  pub fn VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTCHeader::VT_VERSION, None)}
  }
  /// Date of document creation (ISO 8601)
  #[inline]
  pub fn DATE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTCHeader::VT_DATE, None)}
  }
  /// Classification level
  #[inline]
  pub fn CLASSIFICATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTCHeader::VT_CLASSIFICATION, None)}
  }
  /// Validation status
  #[inline]
  pub fn VALIDATION_STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTCHeader::VT_VALIDATION_STATUS, None)}
  }
  /// Author information
  #[inline]
  pub fn AUTHOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTCHeader::VT_AUTHOR, None)}
  }
  /// Notes/comments
  #[inline]
  pub fn NOTES(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(XTCHeader::VT_NOTES, None)}
  }
}

impl flatbuffers::Verifiable for XTCHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VERSION", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DATE", Self::VT_DATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CLASSIFICATION", Self::VT_CLASSIFICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("VALIDATION_STATUS", Self::VT_VALIDATION_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("AUTHOR", Self::VT_AUTHOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("NOTES", Self::VT_NOTES, false)?
     .finish();
    Ok(())
  }
}
pub struct XTCHeaderArgs<'a> {
    pub VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DATE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CLASSIFICATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub VALIDATION_STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub AUTHOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub NOTES: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for XTCHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    XTCHeaderArgs {
      VERSION: None,
      DATE: None,
      CLASSIFICATION: None,
      VALIDATION_STATUS: None,
      AUTHOR: None,
      NOTES: None,
    }
  }
}

pub struct XTCHeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> XTCHeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_VERSION(&mut self, VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_VERSION, VERSION);
  }
  #[inline]
  pub fn add_DATE(&mut self, DATE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_DATE, DATE);
  }
  #[inline]
  pub fn add_CLASSIFICATION(&mut self, CLASSIFICATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_CLASSIFICATION, CLASSIFICATION);
  }
  #[inline]
  pub fn add_VALIDATION_STATUS(&mut self, VALIDATION_STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_VALIDATION_STATUS, VALIDATION_STATUS);
  }
  #[inline]
  pub fn add_AUTHOR(&mut self, AUTHOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_AUTHOR, AUTHOR);
  }
  #[inline]
  pub fn add_NOTES(&mut self, NOTES: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTCHeader::VT_NOTES, NOTES);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> XTCHeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    XTCHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<XTCHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for XTCHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("XTCHeader");
      ds.field("VERSION", &self.VERSION());
      ds.field("DATE", &self.DATE());
      ds.field("CLASSIFICATION", &self.CLASSIFICATION());
      ds.field("VALIDATION_STATUS", &self.VALIDATION_STATUS());
      ds.field("AUTHOR", &self.AUTHOR());
      ds.field("NOTES", &self.NOTES());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct XTCHeaderT {
  pub VERSION: Option<String>,
  pub DATE: Option<String>,
  pub CLASSIFICATION: Option<String>,
  pub VALIDATION_STATUS: Option<String>,
  pub AUTHOR: Option<String>,
  pub NOTES: Option<Vec<String>>,
}
impl Default for XTCHeaderT {
  fn default() -> Self {
    Self {
      VERSION: None,
      DATE: None,
      CLASSIFICATION: None,
      VALIDATION_STATUS: None,
      AUTHOR: None,
      NOTES: None,
    }
  }
}
impl XTCHeaderT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<XTCHeader<'b>> {
    let VERSION = self.VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DATE = self.DATE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CLASSIFICATION = self.CLASSIFICATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let VALIDATION_STATUS = self.VALIDATION_STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let AUTHOR = self.AUTHOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let NOTES = self.NOTES.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    XTCHeader::create(_fbb, &XTCHeaderArgs{
      VERSION,
      DATE,
      CLASSIFICATION,
      VALIDATION_STATUS,
      AUTHOR,
      NOTES,
    })
  }
}
pub enum TelemetryMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Telemetry metadata collection
pub struct TelemetryMetaData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TelemetryMetaData<'a> {
  type Inner = TelemetryMetaData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TelemetryMetaData<'a> {
  pub const VT_PARAMETER_TYPE_SET: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER_SET: flatbuffers::VOffsetT = 6;
  pub const VT_CONTAINER_SET: flatbuffers::VOffsetT = 8;
  pub const VT_ALGORITHM_SET: flatbuffers::VOffsetT = 10;
  pub const VT_STREAM_SET: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TelemetryMetaData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TelemetryMetaDataArgs<'args>
  ) -> flatbuffers::WIPOffset<TelemetryMetaData<'bldr>> {
    let mut builder = TelemetryMetaDataBuilder::new(_fbb);
    if let Some(x) = args.STREAM_SET { builder.add_STREAM_SET(x); }
    if let Some(x) = args.ALGORITHM_SET { builder.add_ALGORITHM_SET(x); }
    if let Some(x) = args.CONTAINER_SET { builder.add_CONTAINER_SET(x); }
    if let Some(x) = args.PARAMETER_SET { builder.add_PARAMETER_SET(x); }
    if let Some(x) = args.PARAMETER_TYPE_SET { builder.add_PARAMETER_TYPE_SET(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> TelemetryMetaDataT {
    let PARAMETER_TYPE_SET = self.PARAMETER_TYPE_SET().map(|x| {
      Box::new(x.unpack())
    });
    let PARAMETER_SET = self.PARAMETER_SET().map(|x| {
      Box::new(x.unpack())
    });
    let CONTAINER_SET = self.CONTAINER_SET().map(|x| {
      Box::new(x.unpack())
    });
    let ALGORITHM_SET = self.ALGORITHM_SET().map(|x| {
      Box::new(x.unpack())
    });
    let STREAM_SET = self.STREAM_SET().map(|x| {
      Box::new(x.unpack())
    });
    TelemetryMetaDataT {
      PARAMETER_TYPE_SET,
      PARAMETER_SET,
      CONTAINER_SET,
      ALGORITHM_SET,
      STREAM_SET,
    }
  }

  /// Parameter type definitions
  #[inline]
  pub fn PARAMETER_TYPE_SET(&self) -> Option<ParameterTypeSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterTypeSet>>(TelemetryMetaData::VT_PARAMETER_TYPE_SET, None)}
  }
  /// Parameter definitions
  #[inline]
  pub fn PARAMETER_SET(&self) -> Option<ParameterSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterSet>>(TelemetryMetaData::VT_PARAMETER_SET, None)}
  }
  /// Container definitions
  #[inline]
  pub fn CONTAINER_SET(&self) -> Option<ContainerSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerSet>>(TelemetryMetaData::VT_CONTAINER_SET, None)}
  }
  /// Algorithm definitions
  #[inline]
  pub fn ALGORITHM_SET(&self) -> Option<AlgorithmSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlgorithmSet>>(TelemetryMetaData::VT_ALGORITHM_SET, None)}
  }
  /// Stream definitions
  #[inline]
  pub fn STREAM_SET(&self) -> Option<StreamSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StreamSet>>(TelemetryMetaData::VT_STREAM_SET, None)}
  }
}

impl flatbuffers::Verifiable for TelemetryMetaData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterTypeSet>>("PARAMETER_TYPE_SET", Self::VT_PARAMETER_TYPE_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterSet>>("PARAMETER_SET", Self::VT_PARAMETER_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerSet>>("CONTAINER_SET", Self::VT_CONTAINER_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlgorithmSet>>("ALGORITHM_SET", Self::VT_ALGORITHM_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StreamSet>>("STREAM_SET", Self::VT_STREAM_SET, false)?
     .finish();
    Ok(())
  }
}
pub struct TelemetryMetaDataArgs<'a> {
    pub PARAMETER_TYPE_SET: Option<flatbuffers::WIPOffset<ParameterTypeSet<'a>>>,
    pub PARAMETER_SET: Option<flatbuffers::WIPOffset<ParameterSet<'a>>>,
    pub CONTAINER_SET: Option<flatbuffers::WIPOffset<ContainerSet<'a>>>,
    pub ALGORITHM_SET: Option<flatbuffers::WIPOffset<AlgorithmSet<'a>>>,
    pub STREAM_SET: Option<flatbuffers::WIPOffset<StreamSet<'a>>>,
}
impl<'a> Default for TelemetryMetaDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    TelemetryMetaDataArgs {
      PARAMETER_TYPE_SET: None,
      PARAMETER_SET: None,
      CONTAINER_SET: None,
      ALGORITHM_SET: None,
      STREAM_SET: None,
    }
  }
}

pub struct TelemetryMetaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TelemetryMetaDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_PARAMETER_TYPE_SET(&mut self, PARAMETER_TYPE_SET: flatbuffers::WIPOffset<ParameterTypeSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterTypeSet>>(TelemetryMetaData::VT_PARAMETER_TYPE_SET, PARAMETER_TYPE_SET);
  }
  #[inline]
  pub fn add_PARAMETER_SET(&mut self, PARAMETER_SET: flatbuffers::WIPOffset<ParameterSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterSet>>(TelemetryMetaData::VT_PARAMETER_SET, PARAMETER_SET);
  }
  #[inline]
  pub fn add_CONTAINER_SET(&mut self, CONTAINER_SET: flatbuffers::WIPOffset<ContainerSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerSet>>(TelemetryMetaData::VT_CONTAINER_SET, CONTAINER_SET);
  }
  #[inline]
  pub fn add_ALGORITHM_SET(&mut self, ALGORITHM_SET: flatbuffers::WIPOffset<AlgorithmSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlgorithmSet>>(TelemetryMetaData::VT_ALGORITHM_SET, ALGORITHM_SET);
  }
  #[inline]
  pub fn add_STREAM_SET(&mut self, STREAM_SET: flatbuffers::WIPOffset<StreamSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StreamSet>>(TelemetryMetaData::VT_STREAM_SET, STREAM_SET);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TelemetryMetaDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TelemetryMetaDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TelemetryMetaData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TelemetryMetaData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TelemetryMetaData");
      ds.field("PARAMETER_TYPE_SET", &self.PARAMETER_TYPE_SET());
      ds.field("PARAMETER_SET", &self.PARAMETER_SET());
      ds.field("CONTAINER_SET", &self.CONTAINER_SET());
      ds.field("ALGORITHM_SET", &self.ALGORITHM_SET());
      ds.field("STREAM_SET", &self.STREAM_SET());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TelemetryMetaDataT {
  pub PARAMETER_TYPE_SET: Option<Box<ParameterTypeSetT>>,
  pub PARAMETER_SET: Option<Box<ParameterSetT>>,
  pub CONTAINER_SET: Option<Box<ContainerSetT>>,
  pub ALGORITHM_SET: Option<Box<AlgorithmSetT>>,
  pub STREAM_SET: Option<Box<StreamSetT>>,
}
impl Default for TelemetryMetaDataT {
  fn default() -> Self {
    Self {
      PARAMETER_TYPE_SET: None,
      PARAMETER_SET: None,
      CONTAINER_SET: None,
      ALGORITHM_SET: None,
      STREAM_SET: None,
    }
  }
}
impl TelemetryMetaDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<TelemetryMetaData<'b>> {
    let PARAMETER_TYPE_SET = self.PARAMETER_TYPE_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PARAMETER_SET = self.PARAMETER_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CONTAINER_SET = self.CONTAINER_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ALGORITHM_SET = self.ALGORITHM_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let STREAM_SET = self.STREAM_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    TelemetryMetaData::create(_fbb, &TelemetryMetaDataArgs{
      PARAMETER_TYPE_SET,
      PARAMETER_SET,
      CONTAINER_SET,
      ALGORITHM_SET,
      STREAM_SET,
    })
  }
}
pub enum CommandMetaDataOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Command metadata collection
pub struct CommandMetaData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CommandMetaData<'a> {
  type Inner = CommandMetaData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CommandMetaData<'a> {
  pub const VT_ARGUMENT_TYPE_SET: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER_TYPE_SET: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMETER_SET: flatbuffers::VOffsetT = 8;
  pub const VT_META_COMMAND_SET: flatbuffers::VOffsetT = 10;
  pub const VT_COMMAND_CONTAINER_SET: flatbuffers::VOffsetT = 12;
  pub const VT_ALGORITHM_SET: flatbuffers::VOffsetT = 14;
  pub const VT_STREAM_SET: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CommandMetaData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CommandMetaDataArgs<'args>
  ) -> flatbuffers::WIPOffset<CommandMetaData<'bldr>> {
    let mut builder = CommandMetaDataBuilder::new(_fbb);
    if let Some(x) = args.STREAM_SET { builder.add_STREAM_SET(x); }
    if let Some(x) = args.ALGORITHM_SET { builder.add_ALGORITHM_SET(x); }
    if let Some(x) = args.COMMAND_CONTAINER_SET { builder.add_COMMAND_CONTAINER_SET(x); }
    if let Some(x) = args.META_COMMAND_SET { builder.add_META_COMMAND_SET(x); }
    if let Some(x) = args.PARAMETER_SET { builder.add_PARAMETER_SET(x); }
    if let Some(x) = args.PARAMETER_TYPE_SET { builder.add_PARAMETER_TYPE_SET(x); }
    if let Some(x) = args.ARGUMENT_TYPE_SET { builder.add_ARGUMENT_TYPE_SET(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CommandMetaDataT {
    let ARGUMENT_TYPE_SET = self.ARGUMENT_TYPE_SET().map(|x| {
      Box::new(x.unpack())
    });
    let PARAMETER_TYPE_SET = self.PARAMETER_TYPE_SET().map(|x| {
      Box::new(x.unpack())
    });
    let PARAMETER_SET = self.PARAMETER_SET().map(|x| {
      Box::new(x.unpack())
    });
    let META_COMMAND_SET = self.META_COMMAND_SET().map(|x| {
      Box::new(x.unpack())
    });
    let COMMAND_CONTAINER_SET = self.COMMAND_CONTAINER_SET().map(|x| {
      Box::new(x.unpack())
    });
    let ALGORITHM_SET = self.ALGORITHM_SET().map(|x| {
      Box::new(x.unpack())
    });
    let STREAM_SET = self.STREAM_SET().map(|x| {
      Box::new(x.unpack())
    });
    CommandMetaDataT {
      ARGUMENT_TYPE_SET,
      PARAMETER_TYPE_SET,
      PARAMETER_SET,
      META_COMMAND_SET,
      COMMAND_CONTAINER_SET,
      ALGORITHM_SET,
      STREAM_SET,
    }
  }

  /// Argument type definitions
  #[inline]
  pub fn ARGUMENT_TYPE_SET(&self) -> Option<ArgumentTypeSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ArgumentTypeSet>>(CommandMetaData::VT_ARGUMENT_TYPE_SET, None)}
  }
  /// Parameter types used by commands
  #[inline]
  pub fn PARAMETER_TYPE_SET(&self) -> Option<ParameterTypeSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterTypeSet>>(CommandMetaData::VT_PARAMETER_TYPE_SET, None)}
  }
  /// Parameters used by commands
  #[inline]
  pub fn PARAMETER_SET(&self) -> Option<ParameterSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParameterSet>>(CommandMetaData::VT_PARAMETER_SET, None)}
  }
  /// MetaCommand definitions
  #[inline]
  pub fn META_COMMAND_SET(&self) -> Option<MetaCommandSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MetaCommandSet>>(CommandMetaData::VT_META_COMMAND_SET, None)}
  }
  /// Command container set
  #[inline]
  pub fn COMMAND_CONTAINER_SET(&self) -> Option<ContainerSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContainerSet>>(CommandMetaData::VT_COMMAND_CONTAINER_SET, None)}
  }
  /// Algorithm definitions
  #[inline]
  pub fn ALGORITHM_SET(&self) -> Option<AlgorithmSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlgorithmSet>>(CommandMetaData::VT_ALGORITHM_SET, None)}
  }
  /// Stream definitions
  #[inline]
  pub fn STREAM_SET(&self) -> Option<StreamSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StreamSet>>(CommandMetaData::VT_STREAM_SET, None)}
  }
}

impl flatbuffers::Verifiable for CommandMetaData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ArgumentTypeSet>>("ARGUMENT_TYPE_SET", Self::VT_ARGUMENT_TYPE_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterTypeSet>>("PARAMETER_TYPE_SET", Self::VT_PARAMETER_TYPE_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParameterSet>>("PARAMETER_SET", Self::VT_PARAMETER_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MetaCommandSet>>("META_COMMAND_SET", Self::VT_META_COMMAND_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContainerSet>>("COMMAND_CONTAINER_SET", Self::VT_COMMAND_CONTAINER_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlgorithmSet>>("ALGORITHM_SET", Self::VT_ALGORITHM_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StreamSet>>("STREAM_SET", Self::VT_STREAM_SET, false)?
     .finish();
    Ok(())
  }
}
pub struct CommandMetaDataArgs<'a> {
    pub ARGUMENT_TYPE_SET: Option<flatbuffers::WIPOffset<ArgumentTypeSet<'a>>>,
    pub PARAMETER_TYPE_SET: Option<flatbuffers::WIPOffset<ParameterTypeSet<'a>>>,
    pub PARAMETER_SET: Option<flatbuffers::WIPOffset<ParameterSet<'a>>>,
    pub META_COMMAND_SET: Option<flatbuffers::WIPOffset<MetaCommandSet<'a>>>,
    pub COMMAND_CONTAINER_SET: Option<flatbuffers::WIPOffset<ContainerSet<'a>>>,
    pub ALGORITHM_SET: Option<flatbuffers::WIPOffset<AlgorithmSet<'a>>>,
    pub STREAM_SET: Option<flatbuffers::WIPOffset<StreamSet<'a>>>,
}
impl<'a> Default for CommandMetaDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    CommandMetaDataArgs {
      ARGUMENT_TYPE_SET: None,
      PARAMETER_TYPE_SET: None,
      PARAMETER_SET: None,
      META_COMMAND_SET: None,
      COMMAND_CONTAINER_SET: None,
      ALGORITHM_SET: None,
      STREAM_SET: None,
    }
  }
}

pub struct CommandMetaDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CommandMetaDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ARGUMENT_TYPE_SET(&mut self, ARGUMENT_TYPE_SET: flatbuffers::WIPOffset<ArgumentTypeSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ArgumentTypeSet>>(CommandMetaData::VT_ARGUMENT_TYPE_SET, ARGUMENT_TYPE_SET);
  }
  #[inline]
  pub fn add_PARAMETER_TYPE_SET(&mut self, PARAMETER_TYPE_SET: flatbuffers::WIPOffset<ParameterTypeSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterTypeSet>>(CommandMetaData::VT_PARAMETER_TYPE_SET, PARAMETER_TYPE_SET);
  }
  #[inline]
  pub fn add_PARAMETER_SET(&mut self, PARAMETER_SET: flatbuffers::WIPOffset<ParameterSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParameterSet>>(CommandMetaData::VT_PARAMETER_SET, PARAMETER_SET);
  }
  #[inline]
  pub fn add_META_COMMAND_SET(&mut self, META_COMMAND_SET: flatbuffers::WIPOffset<MetaCommandSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MetaCommandSet>>(CommandMetaData::VT_META_COMMAND_SET, META_COMMAND_SET);
  }
  #[inline]
  pub fn add_COMMAND_CONTAINER_SET(&mut self, COMMAND_CONTAINER_SET: flatbuffers::WIPOffset<ContainerSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContainerSet>>(CommandMetaData::VT_COMMAND_CONTAINER_SET, COMMAND_CONTAINER_SET);
  }
  #[inline]
  pub fn add_ALGORITHM_SET(&mut self, ALGORITHM_SET: flatbuffers::WIPOffset<AlgorithmSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlgorithmSet>>(CommandMetaData::VT_ALGORITHM_SET, ALGORITHM_SET);
  }
  #[inline]
  pub fn add_STREAM_SET(&mut self, STREAM_SET: flatbuffers::WIPOffset<StreamSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StreamSet>>(CommandMetaData::VT_STREAM_SET, STREAM_SET);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CommandMetaDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CommandMetaDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CommandMetaData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CommandMetaData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CommandMetaData");
      ds.field("ARGUMENT_TYPE_SET", &self.ARGUMENT_TYPE_SET());
      ds.field("PARAMETER_TYPE_SET", &self.PARAMETER_TYPE_SET());
      ds.field("PARAMETER_SET", &self.PARAMETER_SET());
      ds.field("META_COMMAND_SET", &self.META_COMMAND_SET());
      ds.field("COMMAND_CONTAINER_SET", &self.COMMAND_CONTAINER_SET());
      ds.field("ALGORITHM_SET", &self.ALGORITHM_SET());
      ds.field("STREAM_SET", &self.STREAM_SET());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CommandMetaDataT {
  pub ARGUMENT_TYPE_SET: Option<Box<ArgumentTypeSetT>>,
  pub PARAMETER_TYPE_SET: Option<Box<ParameterTypeSetT>>,
  pub PARAMETER_SET: Option<Box<ParameterSetT>>,
  pub META_COMMAND_SET: Option<Box<MetaCommandSetT>>,
  pub COMMAND_CONTAINER_SET: Option<Box<ContainerSetT>>,
  pub ALGORITHM_SET: Option<Box<AlgorithmSetT>>,
  pub STREAM_SET: Option<Box<StreamSetT>>,
}
impl Default for CommandMetaDataT {
  fn default() -> Self {
    Self {
      ARGUMENT_TYPE_SET: None,
      PARAMETER_TYPE_SET: None,
      PARAMETER_SET: None,
      META_COMMAND_SET: None,
      COMMAND_CONTAINER_SET: None,
      ALGORITHM_SET: None,
      STREAM_SET: None,
    }
  }
}
impl CommandMetaDataT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<CommandMetaData<'b>> {
    let ARGUMENT_TYPE_SET = self.ARGUMENT_TYPE_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PARAMETER_TYPE_SET = self.PARAMETER_TYPE_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let PARAMETER_SET = self.PARAMETER_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let META_COMMAND_SET = self.META_COMMAND_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let COMMAND_CONTAINER_SET = self.COMMAND_CONTAINER_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let ALGORITHM_SET = self.ALGORITHM_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let STREAM_SET = self.STREAM_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    CommandMetaData::create(_fbb, &CommandMetaDataArgs{
      ARGUMENT_TYPE_SET,
      PARAMETER_TYPE_SET,
      PARAMETER_SET,
      META_COMMAND_SET,
      COMMAND_CONTAINER_SET,
      ALGORITHM_SET,
      STREAM_SET,
    })
  }
}
pub enum XTCOffset {}
#[derive(Copy, Clone, PartialEq)]

/// SpaceSystem - Root element for XTCE document
/// A SpaceSystem defines the telemetry and command configuration for a space
/// vehicle or subsystem. SpaceSystems can be nested hierarchically to represent
/// the structure of a spacecraft (e.g., spacecraft -> subsystem -> payload).
pub struct XTC<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for XTC<'a> {
  type Inner = XTC<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> XTC<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_SHORT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LONG_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_OPERATIONAL_STATUS: flatbuffers::VOffsetT = 10;
  pub const VT_HEADER: flatbuffers::VOffsetT = 12;
  pub const VT_TELEMETRY_META_DATA: flatbuffers::VOffsetT = 14;
  pub const VT_COMMAND_META_DATA: flatbuffers::VOffsetT = 16;
  pub const VT_SERVICE_SET: flatbuffers::VOffsetT = 18;
  pub const VT_CHILD_SYSTEMS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    XTC { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args XTCArgs<'args>
  ) -> flatbuffers::WIPOffset<XTC<'bldr>> {
    let mut builder = XTCBuilder::new(_fbb);
    if let Some(x) = args.CHILD_SYSTEMS { builder.add_CHILD_SYSTEMS(x); }
    if let Some(x) = args.SERVICE_SET { builder.add_SERVICE_SET(x); }
    if let Some(x) = args.COMMAND_META_DATA { builder.add_COMMAND_META_DATA(x); }
    if let Some(x) = args.TELEMETRY_META_DATA { builder.add_TELEMETRY_META_DATA(x); }
    if let Some(x) = args.HEADER { builder.add_HEADER(x); }
    if let Some(x) = args.OPERATIONAL_STATUS { builder.add_OPERATIONAL_STATUS(x); }
    if let Some(x) = args.LONG_DESCRIPTION { builder.add_LONG_DESCRIPTION(x); }
    if let Some(x) = args.SHORT_DESCRIPTION { builder.add_SHORT_DESCRIPTION(x); }
    if let Some(x) = args.NAME { builder.add_NAME(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> XTCT {
    let NAME = self.NAME().map(|x| {
      x.to_string()
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION().map(|x| {
      x.to_string()
    });
    let OPERATIONAL_STATUS = self.OPERATIONAL_STATUS().map(|x| {
      x.to_string()
    });
    let HEADER = self.HEADER().map(|x| {
      Box::new(x.unpack())
    });
    let TELEMETRY_META_DATA = self.TELEMETRY_META_DATA().map(|x| {
      Box::new(x.unpack())
    });
    let COMMAND_META_DATA = self.COMMAND_META_DATA().map(|x| {
      Box::new(x.unpack())
    });
    let SERVICE_SET = self.SERVICE_SET().map(|x| {
      Box::new(x.unpack())
    });
    let CHILD_SYSTEMS = self.CHILD_SYSTEMS().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    XTCT {
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      OPERATIONAL_STATUS,
      HEADER,
      TELEMETRY_META_DATA,
      COMMAND_META_DATA,
      SERVICE_SET,
      CHILD_SYSTEMS,
    }
  }

  /// Name of this space system
  #[inline]
  pub fn NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTC::VT_NAME, None)}
  }
  /// Short description
  #[inline]
  pub fn SHORT_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTC::VT_SHORT_DESCRIPTION, None)}
  }
  /// Long description
  #[inline]
  pub fn LONG_DESCRIPTION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTC::VT_LONG_DESCRIPTION, None)}
  }
  /// Operational status
  #[inline]
  pub fn OPERATIONAL_STATUS(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(XTC::VT_OPERATIONAL_STATUS, None)}
  }
  /// Document header
  #[inline]
  pub fn HEADER(&self) -> Option<XTCHeader<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<XTCHeader>>(XTC::VT_HEADER, None)}
  }
  /// Telemetry metadata
  #[inline]
  pub fn TELEMETRY_META_DATA(&self) -> Option<TelemetryMetaData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TelemetryMetaData>>(XTC::VT_TELEMETRY_META_DATA, None)}
  }
  /// Command metadata
  #[inline]
  pub fn COMMAND_META_DATA(&self) -> Option<CommandMetaData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CommandMetaData>>(XTC::VT_COMMAND_META_DATA, None)}
  }
  /// Service definitions
  #[inline]
  pub fn SERVICE_SET(&self) -> Option<ServiceSet<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ServiceSet>>(XTC::VT_SERVICE_SET, None)}
  }
  /// Child space systems (hierarchical structure)
  #[inline]
  pub fn CHILD_SYSTEMS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<XTC<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<XTC>>>>(XTC::VT_CHILD_SYSTEMS, None)}
  }
}

impl flatbuffers::Verifiable for XTC<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("NAME", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("SHORT_DESCRIPTION", Self::VT_SHORT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("LONG_DESCRIPTION", Self::VT_LONG_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OPERATIONAL_STATUS", Self::VT_OPERATIONAL_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<XTCHeader>>("HEADER", Self::VT_HEADER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TelemetryMetaData>>("TELEMETRY_META_DATA", Self::VT_TELEMETRY_META_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CommandMetaData>>("COMMAND_META_DATA", Self::VT_COMMAND_META_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ServiceSet>>("SERVICE_SET", Self::VT_SERVICE_SET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<XTC>>>>("CHILD_SYSTEMS", Self::VT_CHILD_SYSTEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct XTCArgs<'a> {
    pub NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub SHORT_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub LONG_DESCRIPTION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OPERATIONAL_STATUS: Option<flatbuffers::WIPOffset<&'a str>>,
    pub HEADER: Option<flatbuffers::WIPOffset<XTCHeader<'a>>>,
    pub TELEMETRY_META_DATA: Option<flatbuffers::WIPOffset<TelemetryMetaData<'a>>>,
    pub COMMAND_META_DATA: Option<flatbuffers::WIPOffset<CommandMetaData<'a>>>,
    pub SERVICE_SET: Option<flatbuffers::WIPOffset<ServiceSet<'a>>>,
    pub CHILD_SYSTEMS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<XTC<'a>>>>>,
}
impl<'a> Default for XTCArgs<'a> {
  #[inline]
  fn default() -> Self {
    XTCArgs {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      OPERATIONAL_STATUS: None,
      HEADER: None,
      TELEMETRY_META_DATA: None,
      COMMAND_META_DATA: None,
      SERVICE_SET: None,
      CHILD_SYSTEMS: None,
    }
  }
}

pub struct XTCBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> XTCBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_NAME(&mut self, NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTC::VT_NAME, NAME);
  }
  #[inline]
  pub fn add_SHORT_DESCRIPTION(&mut self, SHORT_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTC::VT_SHORT_DESCRIPTION, SHORT_DESCRIPTION);
  }
  #[inline]
  pub fn add_LONG_DESCRIPTION(&mut self, LONG_DESCRIPTION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTC::VT_LONG_DESCRIPTION, LONG_DESCRIPTION);
  }
  #[inline]
  pub fn add_OPERATIONAL_STATUS(&mut self, OPERATIONAL_STATUS: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTC::VT_OPERATIONAL_STATUS, OPERATIONAL_STATUS);
  }
  #[inline]
  pub fn add_HEADER(&mut self, HEADER: flatbuffers::WIPOffset<XTCHeader<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<XTCHeader>>(XTC::VT_HEADER, HEADER);
  }
  #[inline]
  pub fn add_TELEMETRY_META_DATA(&mut self, TELEMETRY_META_DATA: flatbuffers::WIPOffset<TelemetryMetaData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TelemetryMetaData>>(XTC::VT_TELEMETRY_META_DATA, TELEMETRY_META_DATA);
  }
  #[inline]
  pub fn add_COMMAND_META_DATA(&mut self, COMMAND_META_DATA: flatbuffers::WIPOffset<CommandMetaData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CommandMetaData>>(XTC::VT_COMMAND_META_DATA, COMMAND_META_DATA);
  }
  #[inline]
  pub fn add_SERVICE_SET(&mut self, SERVICE_SET: flatbuffers::WIPOffset<ServiceSet<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ServiceSet>>(XTC::VT_SERVICE_SET, SERVICE_SET);
  }
  #[inline]
  pub fn add_CHILD_SYSTEMS(&mut self, CHILD_SYSTEMS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<XTC<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(XTC::VT_CHILD_SYSTEMS, CHILD_SYSTEMS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> XTCBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    XTCBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<XTC<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for XTC<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("XTC");
      ds.field("NAME", &self.NAME());
      ds.field("SHORT_DESCRIPTION", &self.SHORT_DESCRIPTION());
      ds.field("LONG_DESCRIPTION", &self.LONG_DESCRIPTION());
      ds.field("OPERATIONAL_STATUS", &self.OPERATIONAL_STATUS());
      ds.field("HEADER", &self.HEADER());
      ds.field("TELEMETRY_META_DATA", &self.TELEMETRY_META_DATA());
      ds.field("COMMAND_META_DATA", &self.COMMAND_META_DATA());
      ds.field("SERVICE_SET", &self.SERVICE_SET());
      ds.field("CHILD_SYSTEMS", &self.CHILD_SYSTEMS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct XTCT {
  pub NAME: Option<String>,
  pub SHORT_DESCRIPTION: Option<String>,
  pub LONG_DESCRIPTION: Option<String>,
  pub OPERATIONAL_STATUS: Option<String>,
  pub HEADER: Option<Box<XTCHeaderT>>,
  pub TELEMETRY_META_DATA: Option<Box<TelemetryMetaDataT>>,
  pub COMMAND_META_DATA: Option<Box<CommandMetaDataT>>,
  pub SERVICE_SET: Option<Box<ServiceSetT>>,
  pub CHILD_SYSTEMS: Option<Vec<XTCT>>,
}
impl Default for XTCT {
  fn default() -> Self {
    Self {
      NAME: None,
      SHORT_DESCRIPTION: None,
      LONG_DESCRIPTION: None,
      OPERATIONAL_STATUS: None,
      HEADER: None,
      TELEMETRY_META_DATA: None,
      COMMAND_META_DATA: None,
      SERVICE_SET: None,
      CHILD_SYSTEMS: None,
    }
  }
}
impl XTCT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<XTC<'b>> {
    let NAME = self.NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let SHORT_DESCRIPTION = self.SHORT_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let LONG_DESCRIPTION = self.LONG_DESCRIPTION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OPERATIONAL_STATUS = self.OPERATIONAL_STATUS.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let HEADER = self.HEADER.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let TELEMETRY_META_DATA = self.TELEMETRY_META_DATA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let COMMAND_META_DATA = self.COMMAND_META_DATA.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let SERVICE_SET = self.SERVICE_SET.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let CHILD_SYSTEMS = self.CHILD_SYSTEMS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    XTC::create(_fbb, &XTCArgs{
      NAME,
      SHORT_DESCRIPTION,
      LONG_DESCRIPTION,
      OPERATIONAL_STATUS,
      HEADER,
      TELEMETRY_META_DATA,
      COMMAND_META_DATA,
      SERVICE_SET,
      CHILD_SYSTEMS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `XTC`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_XTC_unchecked`.
pub fn root_as_XTC(buf: &[u8]) -> Result<XTC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<XTC>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `XTC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_XTC_unchecked`.
pub fn size_prefixed_root_as_XTC(buf: &[u8]) -> Result<XTC, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<XTC>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `XTC` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_XTC_unchecked`.
pub fn root_as_XTC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<XTC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<XTC<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `XTC` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_XTC_unchecked`.
pub fn size_prefixed_root_as_XTC_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<XTC<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<XTC<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a XTC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `XTC`.
pub unsafe fn root_as_XTC_unchecked(buf: &[u8]) -> XTC {
  flatbuffers::root_unchecked::<XTC>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed XTC and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `XTC`.
pub unsafe fn size_prefixed_root_as_XTC_unchecked(buf: &[u8]) -> XTC {
  flatbuffers::size_prefixed_root_unchecked::<XTC>(buf)
}
pub const XTC_IDENTIFIER: &str = "$XTC";

#[inline]
pub fn XTC_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, XTC_IDENTIFIER, false)
}

#[inline]
pub fn XTC_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, XTC_IDENTIFIER, true)
}

#[inline]
pub fn finish_XTC_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<XTC<'a>>) {
  fbb.finish(root, Some(XTC_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_XTC_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<XTC<'a>>) {
  fbb.finish_size_prefixed(root, Some(XTC_IDENTIFIER));
}
