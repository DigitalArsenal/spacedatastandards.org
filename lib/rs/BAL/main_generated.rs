// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DRAG_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DRAG_MODEL: i8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DRAG_MODEL: [DragModel; 11] = [
  DragModel::G1,
  DragModel::G2,
  DragModel::G5,
  DragModel::G6,
  DragModel::G7,
  DragModel::G8,
  DragModel::GI,
  DragModel::GL,
  DragModel::GS,
  DragModel::RA4,
  DragModel::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DragModel(pub i8);
#[allow(non_upper_case_globals)]
impl DragModel {
  pub const G1: Self = Self(0);
  pub const G2: Self = Self(1);
  pub const G5: Self = Self(2);
  pub const G6: Self = Self(3);
  pub const G7: Self = Self(4);
  pub const G8: Self = Self(5);
  pub const GI: Self = Self(6);
  pub const GL: Self = Self(7);
  pub const GS: Self = Self(8);
  pub const RA4: Self = Self(9);
  pub const CUSTOM: Self = Self(10);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 10;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::G1,
    Self::G2,
    Self::G5,
    Self::G6,
    Self::G7,
    Self::G8,
    Self::GI,
    Self::GL,
    Self::GS,
    Self::RA4,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::G1 => Some("G1"),
      Self::G2 => Some("G2"),
      Self::G5 => Some("G5"),
      Self::G6 => Some("G6"),
      Self::G7 => Some("G7"),
      Self::G8 => Some("G8"),
      Self::GI => Some("GI"),
      Self::GL => Some("GL"),
      Self::GS => Some("GS"),
      Self::RA4 => Some("RA4"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DragModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DragModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DragModel {
    type Output = DragModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DragModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DragModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DragModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALLISTIC_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALLISTIC_MODEL: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALLISTIC_MODEL: [BallisticModel; 4] = [
  BallisticModel::POINT_MASS_2D,
  BallisticModel::POINT_MASS_3D,
  BallisticModel::MODIFIED_POINT_MASS,
  BallisticModel::SIX_DOF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallisticModel(pub i8);
#[allow(non_upper_case_globals)]
impl BallisticModel {
  pub const POINT_MASS_2D: Self = Self(0);
  pub const POINT_MASS_3D: Self = Self(1);
  pub const MODIFIED_POINT_MASS: Self = Self(2);
  pub const SIX_DOF: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT_MASS_2D,
    Self::POINT_MASS_3D,
    Self::MODIFIED_POINT_MASS,
    Self::SIX_DOF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT_MASS_2D => Some("POINT_MASS_2D"),
      Self::POINT_MASS_3D => Some("POINT_MASS_3D"),
      Self::MODIFIED_POINT_MASS => Some("MODIFIED_POINT_MASS"),
      Self::SIX_DOF => Some("SIX_DOF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallisticModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallisticModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallisticModel {
    type Output = BallisticModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallisticModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallisticModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallisticModel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PROJECTILE_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PROJECTILE_TYPE: i8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PROJECTILE_TYPE: [ProjectileType; 16] = [
  ProjectileType::BALL,
  ProjectileType::HOLLOW_POINT,
  ProjectileType::BOAT_TAIL,
  ProjectileType::ARMOR_PIERCING,
  ProjectileType::ARMOR_PIERCING_INCENDIARY,
  ProjectileType::TRACER,
  ProjectileType::SABOT,
  ProjectileType::SUBCALIBER,
  ProjectileType::HEAT,
  ProjectileType::HESH,
  ProjectileType::HE,
  ProjectileType::APFSDS,
  ProjectileType::ARTILLERY_HE,
  ProjectileType::MORTAR,
  ProjectileType::GRENADE,
  ProjectileType::ROCKET,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ProjectileType(pub i8);
#[allow(non_upper_case_globals)]
impl ProjectileType {
  pub const BALL: Self = Self(0);
  pub const HOLLOW_POINT: Self = Self(1);
  pub const BOAT_TAIL: Self = Self(2);
  pub const ARMOR_PIERCING: Self = Self(3);
  pub const ARMOR_PIERCING_INCENDIARY: Self = Self(4);
  pub const TRACER: Self = Self(5);
  pub const SABOT: Self = Self(6);
  pub const SUBCALIBER: Self = Self(7);
  pub const HEAT: Self = Self(8);
  pub const HESH: Self = Self(9);
  pub const HE: Self = Self(10);
  pub const APFSDS: Self = Self(11);
  pub const ARTILLERY_HE: Self = Self(12);
  pub const MORTAR: Self = Self(13);
  pub const GRENADE: Self = Self(14);
  pub const ROCKET: Self = Self(15);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BALL,
    Self::HOLLOW_POINT,
    Self::BOAT_TAIL,
    Self::ARMOR_PIERCING,
    Self::ARMOR_PIERCING_INCENDIARY,
    Self::TRACER,
    Self::SABOT,
    Self::SUBCALIBER,
    Self::HEAT,
    Self::HESH,
    Self::HE,
    Self::APFSDS,
    Self::ARTILLERY_HE,
    Self::MORTAR,
    Self::GRENADE,
    Self::ROCKET,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BALL => Some("BALL"),
      Self::HOLLOW_POINT => Some("HOLLOW_POINT"),
      Self::BOAT_TAIL => Some("BOAT_TAIL"),
      Self::ARMOR_PIERCING => Some("ARMOR_PIERCING"),
      Self::ARMOR_PIERCING_INCENDIARY => Some("ARMOR_PIERCING_INCENDIARY"),
      Self::TRACER => Some("TRACER"),
      Self::SABOT => Some("SABOT"),
      Self::SUBCALIBER => Some("SUBCALIBER"),
      Self::HEAT => Some("HEAT"),
      Self::HESH => Some("HESH"),
      Self::HE => Some("HE"),
      Self::APFSDS => Some("APFSDS"),
      Self::ARTILLERY_HE => Some("ARTILLERY_HE"),
      Self::MORTAR => Some("MORTAR"),
      Self::GRENADE => Some("GRENADE"),
      Self::ROCKET => Some("ROCKET"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ProjectileType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ProjectileType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ProjectileType {
    type Output = ProjectileType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ProjectileType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ProjectileType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ProjectileType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STABILIZATION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STABILIZATION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STABILIZATION_TYPE: [StabilizationType; 3] = [
  StabilizationType::SPIN,
  StabilizationType::FIN,
  StabilizationType::DUAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct StabilizationType(pub i8);
#[allow(non_upper_case_globals)]
impl StabilizationType {
  pub const SPIN: Self = Self(0);
  pub const FIN: Self = Self(1);
  pub const DUAL: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SPIN,
    Self::FIN,
    Self::DUAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SPIN => Some("SPIN"),
      Self::FIN => Some("FIN"),
      Self::DUAL => Some("DUAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for StabilizationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for StabilizationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for StabilizationType {
    type Output = StabilizationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for StabilizationType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for StabilizationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for StabilizationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PENETRATION_MODEL: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PENETRATION_MODEL: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PENETRATION_MODEL: [PenetrationModel; 5] = [
  PenetrationModel::DE_MARRE,
  PenetrationModel::THOR,
  PenetrationModel::ODERMATT,
  PenetrationModel::ANDERSON,
  PenetrationModel::BRL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PenetrationModel(pub i8);
#[allow(non_upper_case_globals)]
impl PenetrationModel {
  pub const DE_MARRE: Self = Self(0);
  pub const THOR: Self = Self(1);
  pub const ODERMATT: Self = Self(2);
  pub const ANDERSON: Self = Self(3);
  pub const BRL: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DE_MARRE,
    Self::THOR,
    Self::ODERMATT,
    Self::ANDERSON,
    Self::BRL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DE_MARRE => Some("DE_MARRE"),
      Self::THOR => Some("THOR"),
      Self::ODERMATT => Some("ODERMATT"),
      Self::ANDERSON => Some("ANDERSON"),
      Self::BRL => Some("BRL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PenetrationModel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PenetrationModel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PenetrationModel {
    type Output = PenetrationModel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PenetrationModel {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PenetrationModel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PenetrationModel {}
pub enum BALOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Ballistics
pub struct BAL<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BAL<'a> {
  type Inner = BAL<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BAL<'a> {
  pub const VT_COMMAND: flatbuffers::VOffsetT = 4;
  pub const VT_TRAJECTORY_REQUEST: flatbuffers::VOffsetT = 6;
  pub const VT_TABLE_REQUEST: flatbuffers::VOffsetT = 8;
  pub const VT_FIRE_CONTROL: flatbuffers::VOffsetT = 10;
  pub const VT_PENETRATION_PROJECTILE: flatbuffers::VOffsetT = 12;
  pub const VT_PENETRATION_ARMOR: flatbuffers::VOffsetT = 14;
  pub const VT_IMPACT_VELOCITY_MPS: flatbuffers::VOffsetT = 16;
  pub const VT_IMPACT_ANGLE_DEG: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BAL { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BALArgs<'args>
  ) -> flatbuffers::WIPOffset<BAL<'bldr>> {
    let mut builder = BALBuilder::new(_fbb);
    builder.add_IMPACT_ANGLE_DEG(args.IMPACT_ANGLE_DEG);
    builder.add_IMPACT_VELOCITY_MPS(args.IMPACT_VELOCITY_MPS);
    if let Some(x) = args.PENETRATION_ARMOR { builder.add_PENETRATION_ARMOR(x); }
    if let Some(x) = args.PENETRATION_PROJECTILE { builder.add_PENETRATION_PROJECTILE(x); }
    if let Some(x) = args.FIRE_CONTROL { builder.add_FIRE_CONTROL(x); }
    if let Some(x) = args.TABLE_REQUEST { builder.add_TABLE_REQUEST(x); }
    if let Some(x) = args.TRAJECTORY_REQUEST { builder.add_TRAJECTORY_REQUEST(x); }
    if let Some(x) = args.COMMAND { builder.add_COMMAND(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BALT {
    let COMMAND = self.COMMAND().map(|x| {
      x.to_string()
    });
    let TRAJECTORY_REQUEST = self.TRAJECTORY_REQUEST().map(|x| {
      x.to_string()
    });
    let TABLE_REQUEST = self.TABLE_REQUEST().map(|x| {
      x.to_string()
    });
    let FIRE_CONTROL = self.FIRE_CONTROL().map(|x| {
      x.to_string()
    });
    let PENETRATION_PROJECTILE = self.PENETRATION_PROJECTILE().map(|x| {
      x.to_string()
    });
    let PENETRATION_ARMOR = self.PENETRATION_ARMOR().map(|x| {
      x.to_string()
    });
    let IMPACT_VELOCITY_MPS = self.IMPACT_VELOCITY_MPS();
    let IMPACT_ANGLE_DEG = self.IMPACT_ANGLE_DEG();
    BALT {
      COMMAND,
      TRAJECTORY_REQUEST,
      TABLE_REQUEST,
      FIRE_CONTROL,
      PENETRATION_PROJECTILE,
      PENETRATION_ARMOR,
      IMPACT_VELOCITY_MPS,
      IMPACT_ANGLE_DEG,
    }
  }

  #[inline]
  pub fn COMMAND(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_COMMAND, None)}
  }
  #[inline]
  pub fn TRAJECTORY_REQUEST(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_TRAJECTORY_REQUEST, None)}
  }
  #[inline]
  pub fn TABLE_REQUEST(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_TABLE_REQUEST, None)}
  }
  #[inline]
  pub fn FIRE_CONTROL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_FIRE_CONTROL, None)}
  }
  #[inline]
  pub fn PENETRATION_PROJECTILE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_PENETRATION_PROJECTILE, None)}
  }
  #[inline]
  pub fn PENETRATION_ARMOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BAL::VT_PENETRATION_ARMOR, None)}
  }
  #[inline]
  pub fn IMPACT_VELOCITY_MPS(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BAL::VT_IMPACT_VELOCITY_MPS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn IMPACT_ANGLE_DEG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(BAL::VT_IMPACT_ANGLE_DEG, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BAL<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COMMAND", Self::VT_COMMAND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRAJECTORY_REQUEST", Self::VT_TRAJECTORY_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TABLE_REQUEST", Self::VT_TABLE_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("FIRE_CONTROL", Self::VT_FIRE_CONTROL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PENETRATION_PROJECTILE", Self::VT_PENETRATION_PROJECTILE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("PENETRATION_ARMOR", Self::VT_PENETRATION_ARMOR, false)?
     .visit_field::<f64>("IMPACT_VELOCITY_MPS", Self::VT_IMPACT_VELOCITY_MPS, false)?
     .visit_field::<f64>("IMPACT_ANGLE_DEG", Self::VT_IMPACT_ANGLE_DEG, false)?
     .finish();
    Ok(())
  }
}
pub struct BALArgs<'a> {
    pub COMMAND: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRAJECTORY_REQUEST: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TABLE_REQUEST: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FIRE_CONTROL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PENETRATION_PROJECTILE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub PENETRATION_ARMOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub IMPACT_VELOCITY_MPS: f64,
    pub IMPACT_ANGLE_DEG: f64,
}
impl<'a> Default for BALArgs<'a> {
  #[inline]
  fn default() -> Self {
    BALArgs {
      COMMAND: None,
      TRAJECTORY_REQUEST: None,
      TABLE_REQUEST: None,
      FIRE_CONTROL: None,
      PENETRATION_PROJECTILE: None,
      PENETRATION_ARMOR: None,
      IMPACT_VELOCITY_MPS: 0.0,
      IMPACT_ANGLE_DEG: 0.0,
    }
  }
}

pub struct BALBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BALBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_COMMAND(&mut self, COMMAND: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_COMMAND, COMMAND);
  }
  #[inline]
  pub fn add_TRAJECTORY_REQUEST(&mut self, TRAJECTORY_REQUEST: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_TRAJECTORY_REQUEST, TRAJECTORY_REQUEST);
  }
  #[inline]
  pub fn add_TABLE_REQUEST(&mut self, TABLE_REQUEST: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_TABLE_REQUEST, TABLE_REQUEST);
  }
  #[inline]
  pub fn add_FIRE_CONTROL(&mut self, FIRE_CONTROL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_FIRE_CONTROL, FIRE_CONTROL);
  }
  #[inline]
  pub fn add_PENETRATION_PROJECTILE(&mut self, PENETRATION_PROJECTILE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_PENETRATION_PROJECTILE, PENETRATION_PROJECTILE);
  }
  #[inline]
  pub fn add_PENETRATION_ARMOR(&mut self, PENETRATION_ARMOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BAL::VT_PENETRATION_ARMOR, PENETRATION_ARMOR);
  }
  #[inline]
  pub fn add_IMPACT_VELOCITY_MPS(&mut self, IMPACT_VELOCITY_MPS: f64) {
    self.fbb_.push_slot::<f64>(BAL::VT_IMPACT_VELOCITY_MPS, IMPACT_VELOCITY_MPS, 0.0);
  }
  #[inline]
  pub fn add_IMPACT_ANGLE_DEG(&mut self, IMPACT_ANGLE_DEG: f64) {
    self.fbb_.push_slot::<f64>(BAL::VT_IMPACT_ANGLE_DEG, IMPACT_ANGLE_DEG, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BALBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BALBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BAL<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BAL<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BAL");
      ds.field("COMMAND", &self.COMMAND());
      ds.field("TRAJECTORY_REQUEST", &self.TRAJECTORY_REQUEST());
      ds.field("TABLE_REQUEST", &self.TABLE_REQUEST());
      ds.field("FIRE_CONTROL", &self.FIRE_CONTROL());
      ds.field("PENETRATION_PROJECTILE", &self.PENETRATION_PROJECTILE());
      ds.field("PENETRATION_ARMOR", &self.PENETRATION_ARMOR());
      ds.field("IMPACT_VELOCITY_MPS", &self.IMPACT_VELOCITY_MPS());
      ds.field("IMPACT_ANGLE_DEG", &self.IMPACT_ANGLE_DEG());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BALT {
  pub COMMAND: Option<String>,
  pub TRAJECTORY_REQUEST: Option<String>,
  pub TABLE_REQUEST: Option<String>,
  pub FIRE_CONTROL: Option<String>,
  pub PENETRATION_PROJECTILE: Option<String>,
  pub PENETRATION_ARMOR: Option<String>,
  pub IMPACT_VELOCITY_MPS: f64,
  pub IMPACT_ANGLE_DEG: f64,
}
impl Default for BALT {
  fn default() -> Self {
    Self {
      COMMAND: None,
      TRAJECTORY_REQUEST: None,
      TABLE_REQUEST: None,
      FIRE_CONTROL: None,
      PENETRATION_PROJECTILE: None,
      PENETRATION_ARMOR: None,
      IMPACT_VELOCITY_MPS: 0.0,
      IMPACT_ANGLE_DEG: 0.0,
    }
  }
}
impl BALT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<BAL<'b>> {
    let COMMAND = self.COMMAND.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRAJECTORY_REQUEST = self.TRAJECTORY_REQUEST.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TABLE_REQUEST = self.TABLE_REQUEST.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FIRE_CONTROL = self.FIRE_CONTROL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PENETRATION_PROJECTILE = self.PENETRATION_PROJECTILE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let PENETRATION_ARMOR = self.PENETRATION_ARMOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let IMPACT_VELOCITY_MPS = self.IMPACT_VELOCITY_MPS;
    let IMPACT_ANGLE_DEG = self.IMPACT_ANGLE_DEG;
    BAL::create(_fbb, &BALArgs{
      COMMAND,
      TRAJECTORY_REQUEST,
      TABLE_REQUEST,
      FIRE_CONTROL,
      PENETRATION_PROJECTILE,
      PENETRATION_ARMOR,
      IMPACT_VELOCITY_MPS,
      IMPACT_ANGLE_DEG,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `BAL`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BAL_unchecked`.
pub fn root_as_BAL(buf: &[u8]) -> Result<BAL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<BAL>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `BAL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_BAL_unchecked`.
pub fn size_prefixed_root_as_BAL(buf: &[u8]) -> Result<BAL, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<BAL>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `BAL` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BAL_unchecked`.
pub fn root_as_BAL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BAL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<BAL<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `BAL` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_BAL_unchecked`.
pub fn size_prefixed_root_as_BAL_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BAL<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<BAL<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a BAL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `BAL`.
pub unsafe fn root_as_BAL_unchecked(buf: &[u8]) -> BAL {
  flatbuffers::root_unchecked::<BAL>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed BAL and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `BAL`.
pub unsafe fn size_prefixed_root_as_BAL_unchecked(buf: &[u8]) -> BAL {
  flatbuffers::size_prefixed_root_unchecked::<BAL>(buf)
}
pub const BAL_IDENTIFIER: &str = "$BAL";

#[inline]
pub fn BAL_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BAL_IDENTIFIER, false)
}

#[inline]
pub fn BAL_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, BAL_IDENTIFIER, true)
}

#[inline]
pub fn finish_BAL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<BAL<'a>>) {
  fbb.finish(root, Some(BAL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_BAL_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<BAL<'a>>) {
  fbb.finish_size_prefixed(root, Some(BAL_IDENTIFIER));
}
