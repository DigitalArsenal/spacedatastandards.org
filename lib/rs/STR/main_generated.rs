// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum STROffset {}
#[derive(Copy, Clone, PartialEq)]

/// Star Catalog Entry
pub struct STR<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for STR<'a> {
  type Inner = STR<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> STR<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CS_ID: flatbuffers::VOffsetT = 6;
  pub const VT_GNC_CAT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_GAIADR3_CAT_ID: flatbuffers::VOffsetT = 10;
  pub const VT_HIP_CAT_ID: flatbuffers::VOffsetT = 12;
  pub const VT_CAT_VERSION: flatbuffers::VOffsetT = 14;
  pub const VT_ASTROMETRY_ORIGIN: flatbuffers::VOffsetT = 16;
  pub const VT_STAR_EPOCH: flatbuffers::VOffsetT = 18;
  pub const VT_RA: flatbuffers::VOffsetT = 20;
  pub const VT_RA_UNC: flatbuffers::VOffsetT = 22;
  pub const VT_DEC: flatbuffers::VOffsetT = 24;
  pub const VT_DEC_UNC: flatbuffers::VOffsetT = 26;
  pub const VT_POS_UNC_FLAG: flatbuffers::VOffsetT = 28;
  pub const VT_PARALLAX: flatbuffers::VOffsetT = 30;
  pub const VT_PARALLAX_UNC: flatbuffers::VOffsetT = 32;
  pub const VT_PMRA: flatbuffers::VOffsetT = 34;
  pub const VT_PMRA_UNC: flatbuffers::VOffsetT = 36;
  pub const VT_PMDEC: flatbuffers::VOffsetT = 38;
  pub const VT_PMDEC_UNC: flatbuffers::VOffsetT = 40;
  pub const VT_PM_UNC_FLAG: flatbuffers::VOffsetT = 42;
  pub const VT_GMAG: flatbuffers::VOffsetT = 44;
  pub const VT_GMAG_UNC: flatbuffers::VOffsetT = 46;
  pub const VT_BPMAG: flatbuffers::VOffsetT = 48;
  pub const VT_BPMAG_UNC: flatbuffers::VOffsetT = 50;
  pub const VT_RPMAG: flatbuffers::VOffsetT = 52;
  pub const VT_RPMAG_UNC: flatbuffers::VOffsetT = 54;
  pub const VT_JMAG: flatbuffers::VOffsetT = 56;
  pub const VT_JMAG_UNC: flatbuffers::VOffsetT = 58;
  pub const VT_KMAG: flatbuffers::VOffsetT = 60;
  pub const VT_KMAG_UNC: flatbuffers::VOffsetT = 62;
  pub const VT_HMAG: flatbuffers::VOffsetT = 64;
  pub const VT_HMAG_UNC: flatbuffers::VOffsetT = 66;
  pub const VT_VAR_FLAG: flatbuffers::VOffsetT = 68;
  pub const VT_MULT_FLAG: flatbuffers::VOffsetT = 70;
  pub const VT_NEIGHBOR_ID: flatbuffers::VOffsetT = 72;
  pub const VT_NEIGHBOR_FLAG: flatbuffers::VOffsetT = 74;
  pub const VT_NEIGHBOR_DISTANCE: flatbuffers::VOffsetT = 76;
  pub const VT_SHIFT_FLAG: flatbuffers::VOffsetT = 78;
  pub const VT_SHIFT: flatbuffers::VOffsetT = 80;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    STR { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args STRArgs<'args>
  ) -> flatbuffers::WIPOffset<STR<'bldr>> {
    let mut builder = STRBuilder::new(_fbb);
    builder.add_SHIFT(args.SHIFT);
    builder.add_NEIGHBOR_DISTANCE(args.NEIGHBOR_DISTANCE);
    builder.add_HMAG_UNC(args.HMAG_UNC);
    builder.add_HMAG(args.HMAG);
    builder.add_KMAG_UNC(args.KMAG_UNC);
    builder.add_KMAG(args.KMAG);
    builder.add_JMAG_UNC(args.JMAG_UNC);
    builder.add_JMAG(args.JMAG);
    builder.add_RPMAG_UNC(args.RPMAG_UNC);
    builder.add_RPMAG(args.RPMAG);
    builder.add_BPMAG_UNC(args.BPMAG_UNC);
    builder.add_BPMAG(args.BPMAG);
    builder.add_GMAG_UNC(args.GMAG_UNC);
    builder.add_GMAG(args.GMAG);
    builder.add_PMDEC_UNC(args.PMDEC_UNC);
    builder.add_PMDEC(args.PMDEC);
    builder.add_PMRA_UNC(args.PMRA_UNC);
    builder.add_PMRA(args.PMRA);
    builder.add_PARALLAX_UNC(args.PARALLAX_UNC);
    builder.add_PARALLAX(args.PARALLAX);
    builder.add_DEC_UNC(args.DEC_UNC);
    builder.add_DEC(args.DEC);
    builder.add_RA_UNC(args.RA_UNC);
    builder.add_RA(args.RA);
    builder.add_STAR_EPOCH(args.STAR_EPOCH);
    builder.add_GAIADR3_CAT_ID(args.GAIADR3_CAT_ID);
    builder.add_CS_ID(args.CS_ID);
    builder.add_NEIGHBOR_ID(args.NEIGHBOR_ID);
    if let Some(x) = args.ASTROMETRY_ORIGIN { builder.add_ASTROMETRY_ORIGIN(x); }
    if let Some(x) = args.CAT_VERSION { builder.add_CAT_VERSION(x); }
    builder.add_HIP_CAT_ID(args.HIP_CAT_ID);
    builder.add_GNC_CAT_ID(args.GNC_CAT_ID);
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_SHIFT_FLAG(args.SHIFT_FLAG);
    builder.add_NEIGHBOR_FLAG(args.NEIGHBOR_FLAG);
    builder.add_MULT_FLAG(args.MULT_FLAG);
    builder.add_VAR_FLAG(args.VAR_FLAG);
    builder.add_PM_UNC_FLAG(args.PM_UNC_FLAG);
    builder.add_POS_UNC_FLAG(args.POS_UNC_FLAG);
    builder.finish()
  }

  pub fn unpack(&self) -> STRT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let CS_ID = self.CS_ID();
    let GNC_CAT_ID = self.GNC_CAT_ID();
    let GAIADR3_CAT_ID = self.GAIADR3_CAT_ID();
    let HIP_CAT_ID = self.HIP_CAT_ID();
    let CAT_VERSION = self.CAT_VERSION().map(|x| {
      x.to_string()
    });
    let ASTROMETRY_ORIGIN = self.ASTROMETRY_ORIGIN().map(|x| {
      x.to_string()
    });
    let STAR_EPOCH = self.STAR_EPOCH();
    let RA = self.RA();
    let RA_UNC = self.RA_UNC();
    let DEC = self.DEC();
    let DEC_UNC = self.DEC_UNC();
    let POS_UNC_FLAG = self.POS_UNC_FLAG();
    let PARALLAX = self.PARALLAX();
    let PARALLAX_UNC = self.PARALLAX_UNC();
    let PMRA = self.PMRA();
    let PMRA_UNC = self.PMRA_UNC();
    let PMDEC = self.PMDEC();
    let PMDEC_UNC = self.PMDEC_UNC();
    let PM_UNC_FLAG = self.PM_UNC_FLAG();
    let GMAG = self.GMAG();
    let GMAG_UNC = self.GMAG_UNC();
    let BPMAG = self.BPMAG();
    let BPMAG_UNC = self.BPMAG_UNC();
    let RPMAG = self.RPMAG();
    let RPMAG_UNC = self.RPMAG_UNC();
    let JMAG = self.JMAG();
    let JMAG_UNC = self.JMAG_UNC();
    let KMAG = self.KMAG();
    let KMAG_UNC = self.KMAG_UNC();
    let HMAG = self.HMAG();
    let HMAG_UNC = self.HMAG_UNC();
    let VAR_FLAG = self.VAR_FLAG();
    let MULT_FLAG = self.MULT_FLAG();
    let NEIGHBOR_ID = self.NEIGHBOR_ID();
    let NEIGHBOR_FLAG = self.NEIGHBOR_FLAG();
    let NEIGHBOR_DISTANCE = self.NEIGHBOR_DISTANCE();
    let SHIFT_FLAG = self.SHIFT_FLAG();
    let SHIFT = self.SHIFT();
    STRT {
      ID,
      CS_ID,
      GNC_CAT_ID,
      GAIADR3_CAT_ID,
      HIP_CAT_ID,
      CAT_VERSION,
      ASTROMETRY_ORIGIN,
      STAR_EPOCH,
      RA,
      RA_UNC,
      DEC,
      DEC_UNC,
      POS_UNC_FLAG,
      PARALLAX,
      PARALLAX_UNC,
      PMRA,
      PMRA_UNC,
      PMDEC,
      PMDEC_UNC,
      PM_UNC_FLAG,
      GMAG,
      GMAG_UNC,
      BPMAG,
      BPMAG_UNC,
      RPMAG,
      RPMAG_UNC,
      JMAG,
      JMAG_UNC,
      KMAG,
      KMAG_UNC,
      HMAG,
      HMAG_UNC,
      VAR_FLAG,
      MULT_FLAG,
      NEIGHBOR_ID,
      NEIGHBOR_FLAG,
      NEIGHBOR_DISTANCE,
      SHIFT_FLAG,
      SHIFT,
    }
  }

  /// Unique internal identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(STR::VT_ID, None)}
  }
  /// CelesTrak Star catalog identifier
  #[inline]
  pub fn CS_ID(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(STR::VT_CS_ID, Some(0)).unwrap()}
  }
  /// GNC star catalog identifier
  #[inline]
  pub fn GNC_CAT_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(STR::VT_GNC_CAT_ID, Some(0)).unwrap()}
  }
  /// Gaia DR3 source identifier
  #[inline]
  pub fn GAIADR3_CAT_ID(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(STR::VT_GAIADR3_CAT_ID, Some(0)).unwrap()}
  }
  /// Hipparcos catalog identifier
  #[inline]
  pub fn HIP_CAT_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(STR::VT_HIP_CAT_ID, Some(0)).unwrap()}
  }
  /// Catalog version string
  #[inline]
  pub fn CAT_VERSION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(STR::VT_CAT_VERSION, None)}
  }
  /// Astrometry source description
  #[inline]
  pub fn ASTROMETRY_ORIGIN(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(STR::VT_ASTROMETRY_ORIGIN, None)}
  }
  /// Epoch of stellar position (Julian years)
  #[inline]
  pub fn STAR_EPOCH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_STAR_EPOCH, Some(0.0)).unwrap()}
  }
  /// Right ascension (degrees, ICRS)
  #[inline]
  pub fn RA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_RA, Some(0.0)).unwrap()}
  }
  /// Right ascension uncertainty (arcseconds)
  #[inline]
  pub fn RA_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_RA_UNC, Some(0.0)).unwrap()}
  }
  /// Declination (degrees, ICRS)
  #[inline]
  pub fn DEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_DEC, Some(0.0)).unwrap()}
  }
  /// Declination uncertainty (arcseconds)
  #[inline]
  pub fn DEC_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_DEC_UNC, Some(0.0)).unwrap()}
  }
  /// True if position uncertainty is flagged
  #[inline]
  pub fn POS_UNC_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_POS_UNC_FLAG, Some(false)).unwrap()}
  }
  /// Parallax (milliarcseconds)
  #[inline]
  pub fn PARALLAX(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PARALLAX, Some(0.0)).unwrap()}
  }
  /// Parallax uncertainty (milliarcseconds)
  #[inline]
  pub fn PARALLAX_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PARALLAX_UNC, Some(0.0)).unwrap()}
  }
  /// Proper motion in RA (milliarcseconds/year)
  #[inline]
  pub fn PMRA(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PMRA, Some(0.0)).unwrap()}
  }
  /// Proper motion in RA uncertainty (milliarcseconds/year)
  #[inline]
  pub fn PMRA_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PMRA_UNC, Some(0.0)).unwrap()}
  }
  /// Proper motion in DEC (milliarcseconds/year)
  #[inline]
  pub fn PMDEC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PMDEC, Some(0.0)).unwrap()}
  }
  /// Proper motion in DEC uncertainty (milliarcseconds/year)
  #[inline]
  pub fn PMDEC_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_PMDEC_UNC, Some(0.0)).unwrap()}
  }
  /// True if proper motion uncertainty is flagged
  #[inline]
  pub fn PM_UNC_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_PM_UNC_FLAG, Some(false)).unwrap()}
  }
  /// Gaia G-band magnitude
  #[inline]
  pub fn GMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_GMAG, Some(0.0)).unwrap()}
  }
  /// Gaia G-band magnitude uncertainty
  #[inline]
  pub fn GMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_GMAG_UNC, Some(0.0)).unwrap()}
  }
  /// Gaia BP-band magnitude (blue photometer)
  #[inline]
  pub fn BPMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_BPMAG, Some(0.0)).unwrap()}
  }
  /// Gaia BP-band magnitude uncertainty
  #[inline]
  pub fn BPMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_BPMAG_UNC, Some(0.0)).unwrap()}
  }
  /// Gaia RP-band magnitude (red photometer)
  #[inline]
  pub fn RPMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_RPMAG, Some(0.0)).unwrap()}
  }
  /// Gaia RP-band magnitude uncertainty
  #[inline]
  pub fn RPMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_RPMAG_UNC, Some(0.0)).unwrap()}
  }
  /// 2MASS J-band magnitude (1.25 um)
  #[inline]
  pub fn JMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_JMAG, Some(0.0)).unwrap()}
  }
  /// J-band magnitude uncertainty
  #[inline]
  pub fn JMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_JMAG_UNC, Some(0.0)).unwrap()}
  }
  /// 2MASS K-band magnitude (2.17 um)
  #[inline]
  pub fn KMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_KMAG, Some(0.0)).unwrap()}
  }
  /// K-band magnitude uncertainty
  #[inline]
  pub fn KMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_KMAG_UNC, Some(0.0)).unwrap()}
  }
  /// 2MASS H-band magnitude (1.65 um)
  #[inline]
  pub fn HMAG(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_HMAG, Some(0.0)).unwrap()}
  }
  /// H-band magnitude uncertainty
  #[inline]
  pub fn HMAG_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_HMAG_UNC, Some(0.0)).unwrap()}
  }
  /// True if star is variable
  #[inline]
  pub fn VAR_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_VAR_FLAG, Some(false)).unwrap()}
  }
  /// True if star is in a multiple system
  #[inline]
  pub fn MULT_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_MULT_FLAG, Some(false)).unwrap()}
  }
  /// Nearest neighbor catalog identifier
  #[inline]
  pub fn NEIGHBOR_ID(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(STR::VT_NEIGHBOR_ID, Some(0)).unwrap()}
  }
  /// True if nearest neighbor is within confusion radius
  #[inline]
  pub fn NEIGHBOR_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_NEIGHBOR_FLAG, Some(false)).unwrap()}
  }
  /// Distance to nearest neighbor (arcseconds)
  #[inline]
  pub fn NEIGHBOR_DISTANCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_NEIGHBOR_DISTANCE, Some(0.0)).unwrap()}
  }
  /// True if position shift detected between catalogs
  #[inline]
  pub fn SHIFT_FLAG(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(STR::VT_SHIFT_FLAG, Some(false)).unwrap()}
  }
  /// Position shift magnitude (arcseconds)
  #[inline]
  pub fn SHIFT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(STR::VT_SHIFT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for STR<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<i64>("CS_ID", Self::VT_CS_ID, false)?
     .visit_field::<u32>("GNC_CAT_ID", Self::VT_GNC_CAT_ID, false)?
     .visit_field::<i64>("GAIADR3_CAT_ID", Self::VT_GAIADR3_CAT_ID, false)?
     .visit_field::<u32>("HIP_CAT_ID", Self::VT_HIP_CAT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CAT_VERSION", Self::VT_CAT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ASTROMETRY_ORIGIN", Self::VT_ASTROMETRY_ORIGIN, false)?
     .visit_field::<f64>("STAR_EPOCH", Self::VT_STAR_EPOCH, false)?
     .visit_field::<f64>("RA", Self::VT_RA, false)?
     .visit_field::<f64>("RA_UNC", Self::VT_RA_UNC, false)?
     .visit_field::<f64>("DEC", Self::VT_DEC, false)?
     .visit_field::<f64>("DEC_UNC", Self::VT_DEC_UNC, false)?
     .visit_field::<bool>("POS_UNC_FLAG", Self::VT_POS_UNC_FLAG, false)?
     .visit_field::<f64>("PARALLAX", Self::VT_PARALLAX, false)?
     .visit_field::<f64>("PARALLAX_UNC", Self::VT_PARALLAX_UNC, false)?
     .visit_field::<f64>("PMRA", Self::VT_PMRA, false)?
     .visit_field::<f64>("PMRA_UNC", Self::VT_PMRA_UNC, false)?
     .visit_field::<f64>("PMDEC", Self::VT_PMDEC, false)?
     .visit_field::<f64>("PMDEC_UNC", Self::VT_PMDEC_UNC, false)?
     .visit_field::<bool>("PM_UNC_FLAG", Self::VT_PM_UNC_FLAG, false)?
     .visit_field::<f64>("GMAG", Self::VT_GMAG, false)?
     .visit_field::<f64>("GMAG_UNC", Self::VT_GMAG_UNC, false)?
     .visit_field::<f64>("BPMAG", Self::VT_BPMAG, false)?
     .visit_field::<f64>("BPMAG_UNC", Self::VT_BPMAG_UNC, false)?
     .visit_field::<f64>("RPMAG", Self::VT_RPMAG, false)?
     .visit_field::<f64>("RPMAG_UNC", Self::VT_RPMAG_UNC, false)?
     .visit_field::<f64>("JMAG", Self::VT_JMAG, false)?
     .visit_field::<f64>("JMAG_UNC", Self::VT_JMAG_UNC, false)?
     .visit_field::<f64>("KMAG", Self::VT_KMAG, false)?
     .visit_field::<f64>("KMAG_UNC", Self::VT_KMAG_UNC, false)?
     .visit_field::<f64>("HMAG", Self::VT_HMAG, false)?
     .visit_field::<f64>("HMAG_UNC", Self::VT_HMAG_UNC, false)?
     .visit_field::<bool>("VAR_FLAG", Self::VT_VAR_FLAG, false)?
     .visit_field::<bool>("MULT_FLAG", Self::VT_MULT_FLAG, false)?
     .visit_field::<u32>("NEIGHBOR_ID", Self::VT_NEIGHBOR_ID, false)?
     .visit_field::<bool>("NEIGHBOR_FLAG", Self::VT_NEIGHBOR_FLAG, false)?
     .visit_field::<f64>("NEIGHBOR_DISTANCE", Self::VT_NEIGHBOR_DISTANCE, false)?
     .visit_field::<bool>("SHIFT_FLAG", Self::VT_SHIFT_FLAG, false)?
     .visit_field::<f64>("SHIFT", Self::VT_SHIFT, false)?
     .finish();
    Ok(())
  }
}
pub struct STRArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CS_ID: i64,
    pub GNC_CAT_ID: u32,
    pub GAIADR3_CAT_ID: i64,
    pub HIP_CAT_ID: u32,
    pub CAT_VERSION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ASTROMETRY_ORIGIN: Option<flatbuffers::WIPOffset<&'a str>>,
    pub STAR_EPOCH: f64,
    pub RA: f64,
    pub RA_UNC: f64,
    pub DEC: f64,
    pub DEC_UNC: f64,
    pub POS_UNC_FLAG: bool,
    pub PARALLAX: f64,
    pub PARALLAX_UNC: f64,
    pub PMRA: f64,
    pub PMRA_UNC: f64,
    pub PMDEC: f64,
    pub PMDEC_UNC: f64,
    pub PM_UNC_FLAG: bool,
    pub GMAG: f64,
    pub GMAG_UNC: f64,
    pub BPMAG: f64,
    pub BPMAG_UNC: f64,
    pub RPMAG: f64,
    pub RPMAG_UNC: f64,
    pub JMAG: f64,
    pub JMAG_UNC: f64,
    pub KMAG: f64,
    pub KMAG_UNC: f64,
    pub HMAG: f64,
    pub HMAG_UNC: f64,
    pub VAR_FLAG: bool,
    pub MULT_FLAG: bool,
    pub NEIGHBOR_ID: u32,
    pub NEIGHBOR_FLAG: bool,
    pub NEIGHBOR_DISTANCE: f64,
    pub SHIFT_FLAG: bool,
    pub SHIFT: f64,
}
impl<'a> Default for STRArgs<'a> {
  #[inline]
  fn default() -> Self {
    STRArgs {
      ID: None,
      CS_ID: 0,
      GNC_CAT_ID: 0,
      GAIADR3_CAT_ID: 0,
      HIP_CAT_ID: 0,
      CAT_VERSION: None,
      ASTROMETRY_ORIGIN: None,
      STAR_EPOCH: 0.0,
      RA: 0.0,
      RA_UNC: 0.0,
      DEC: 0.0,
      DEC_UNC: 0.0,
      POS_UNC_FLAG: false,
      PARALLAX: 0.0,
      PARALLAX_UNC: 0.0,
      PMRA: 0.0,
      PMRA_UNC: 0.0,
      PMDEC: 0.0,
      PMDEC_UNC: 0.0,
      PM_UNC_FLAG: false,
      GMAG: 0.0,
      GMAG_UNC: 0.0,
      BPMAG: 0.0,
      BPMAG_UNC: 0.0,
      RPMAG: 0.0,
      RPMAG_UNC: 0.0,
      JMAG: 0.0,
      JMAG_UNC: 0.0,
      KMAG: 0.0,
      KMAG_UNC: 0.0,
      HMAG: 0.0,
      HMAG_UNC: 0.0,
      VAR_FLAG: false,
      MULT_FLAG: false,
      NEIGHBOR_ID: 0,
      NEIGHBOR_FLAG: false,
      NEIGHBOR_DISTANCE: 0.0,
      SHIFT_FLAG: false,
      SHIFT: 0.0,
    }
  }
}

pub struct STRBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> STRBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(STR::VT_ID, ID);
  }
  #[inline]
  pub fn add_CS_ID(&mut self, CS_ID: i64) {
    self.fbb_.push_slot::<i64>(STR::VT_CS_ID, CS_ID, 0);
  }
  #[inline]
  pub fn add_GNC_CAT_ID(&mut self, GNC_CAT_ID: u32) {
    self.fbb_.push_slot::<u32>(STR::VT_GNC_CAT_ID, GNC_CAT_ID, 0);
  }
  #[inline]
  pub fn add_GAIADR3_CAT_ID(&mut self, GAIADR3_CAT_ID: i64) {
    self.fbb_.push_slot::<i64>(STR::VT_GAIADR3_CAT_ID, GAIADR3_CAT_ID, 0);
  }
  #[inline]
  pub fn add_HIP_CAT_ID(&mut self, HIP_CAT_ID: u32) {
    self.fbb_.push_slot::<u32>(STR::VT_HIP_CAT_ID, HIP_CAT_ID, 0);
  }
  #[inline]
  pub fn add_CAT_VERSION(&mut self, CAT_VERSION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(STR::VT_CAT_VERSION, CAT_VERSION);
  }
  #[inline]
  pub fn add_ASTROMETRY_ORIGIN(&mut self, ASTROMETRY_ORIGIN: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(STR::VT_ASTROMETRY_ORIGIN, ASTROMETRY_ORIGIN);
  }
  #[inline]
  pub fn add_STAR_EPOCH(&mut self, STAR_EPOCH: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_STAR_EPOCH, STAR_EPOCH, 0.0);
  }
  #[inline]
  pub fn add_RA(&mut self, RA: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_RA, RA, 0.0);
  }
  #[inline]
  pub fn add_RA_UNC(&mut self, RA_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_RA_UNC, RA_UNC, 0.0);
  }
  #[inline]
  pub fn add_DEC(&mut self, DEC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_DEC, DEC, 0.0);
  }
  #[inline]
  pub fn add_DEC_UNC(&mut self, DEC_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_DEC_UNC, DEC_UNC, 0.0);
  }
  #[inline]
  pub fn add_POS_UNC_FLAG(&mut self, POS_UNC_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_POS_UNC_FLAG, POS_UNC_FLAG, false);
  }
  #[inline]
  pub fn add_PARALLAX(&mut self, PARALLAX: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PARALLAX, PARALLAX, 0.0);
  }
  #[inline]
  pub fn add_PARALLAX_UNC(&mut self, PARALLAX_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PARALLAX_UNC, PARALLAX_UNC, 0.0);
  }
  #[inline]
  pub fn add_PMRA(&mut self, PMRA: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PMRA, PMRA, 0.0);
  }
  #[inline]
  pub fn add_PMRA_UNC(&mut self, PMRA_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PMRA_UNC, PMRA_UNC, 0.0);
  }
  #[inline]
  pub fn add_PMDEC(&mut self, PMDEC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PMDEC, PMDEC, 0.0);
  }
  #[inline]
  pub fn add_PMDEC_UNC(&mut self, PMDEC_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_PMDEC_UNC, PMDEC_UNC, 0.0);
  }
  #[inline]
  pub fn add_PM_UNC_FLAG(&mut self, PM_UNC_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_PM_UNC_FLAG, PM_UNC_FLAG, false);
  }
  #[inline]
  pub fn add_GMAG(&mut self, GMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_GMAG, GMAG, 0.0);
  }
  #[inline]
  pub fn add_GMAG_UNC(&mut self, GMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_GMAG_UNC, GMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_BPMAG(&mut self, BPMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_BPMAG, BPMAG, 0.0);
  }
  #[inline]
  pub fn add_BPMAG_UNC(&mut self, BPMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_BPMAG_UNC, BPMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_RPMAG(&mut self, RPMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_RPMAG, RPMAG, 0.0);
  }
  #[inline]
  pub fn add_RPMAG_UNC(&mut self, RPMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_RPMAG_UNC, RPMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_JMAG(&mut self, JMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_JMAG, JMAG, 0.0);
  }
  #[inline]
  pub fn add_JMAG_UNC(&mut self, JMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_JMAG_UNC, JMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_KMAG(&mut self, KMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_KMAG, KMAG, 0.0);
  }
  #[inline]
  pub fn add_KMAG_UNC(&mut self, KMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_KMAG_UNC, KMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_HMAG(&mut self, HMAG: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_HMAG, HMAG, 0.0);
  }
  #[inline]
  pub fn add_HMAG_UNC(&mut self, HMAG_UNC: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_HMAG_UNC, HMAG_UNC, 0.0);
  }
  #[inline]
  pub fn add_VAR_FLAG(&mut self, VAR_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_VAR_FLAG, VAR_FLAG, false);
  }
  #[inline]
  pub fn add_MULT_FLAG(&mut self, MULT_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_MULT_FLAG, MULT_FLAG, false);
  }
  #[inline]
  pub fn add_NEIGHBOR_ID(&mut self, NEIGHBOR_ID: u32) {
    self.fbb_.push_slot::<u32>(STR::VT_NEIGHBOR_ID, NEIGHBOR_ID, 0);
  }
  #[inline]
  pub fn add_NEIGHBOR_FLAG(&mut self, NEIGHBOR_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_NEIGHBOR_FLAG, NEIGHBOR_FLAG, false);
  }
  #[inline]
  pub fn add_NEIGHBOR_DISTANCE(&mut self, NEIGHBOR_DISTANCE: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_NEIGHBOR_DISTANCE, NEIGHBOR_DISTANCE, 0.0);
  }
  #[inline]
  pub fn add_SHIFT_FLAG(&mut self, SHIFT_FLAG: bool) {
    self.fbb_.push_slot::<bool>(STR::VT_SHIFT_FLAG, SHIFT_FLAG, false);
  }
  #[inline]
  pub fn add_SHIFT(&mut self, SHIFT: f64) {
    self.fbb_.push_slot::<f64>(STR::VT_SHIFT, SHIFT, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> STRBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    STRBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<STR<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for STR<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("STR");
      ds.field("ID", &self.ID());
      ds.field("CS_ID", &self.CS_ID());
      ds.field("GNC_CAT_ID", &self.GNC_CAT_ID());
      ds.field("GAIADR3_CAT_ID", &self.GAIADR3_CAT_ID());
      ds.field("HIP_CAT_ID", &self.HIP_CAT_ID());
      ds.field("CAT_VERSION", &self.CAT_VERSION());
      ds.field("ASTROMETRY_ORIGIN", &self.ASTROMETRY_ORIGIN());
      ds.field("STAR_EPOCH", &self.STAR_EPOCH());
      ds.field("RA", &self.RA());
      ds.field("RA_UNC", &self.RA_UNC());
      ds.field("DEC", &self.DEC());
      ds.field("DEC_UNC", &self.DEC_UNC());
      ds.field("POS_UNC_FLAG", &self.POS_UNC_FLAG());
      ds.field("PARALLAX", &self.PARALLAX());
      ds.field("PARALLAX_UNC", &self.PARALLAX_UNC());
      ds.field("PMRA", &self.PMRA());
      ds.field("PMRA_UNC", &self.PMRA_UNC());
      ds.field("PMDEC", &self.PMDEC());
      ds.field("PMDEC_UNC", &self.PMDEC_UNC());
      ds.field("PM_UNC_FLAG", &self.PM_UNC_FLAG());
      ds.field("GMAG", &self.GMAG());
      ds.field("GMAG_UNC", &self.GMAG_UNC());
      ds.field("BPMAG", &self.BPMAG());
      ds.field("BPMAG_UNC", &self.BPMAG_UNC());
      ds.field("RPMAG", &self.RPMAG());
      ds.field("RPMAG_UNC", &self.RPMAG_UNC());
      ds.field("JMAG", &self.JMAG());
      ds.field("JMAG_UNC", &self.JMAG_UNC());
      ds.field("KMAG", &self.KMAG());
      ds.field("KMAG_UNC", &self.KMAG_UNC());
      ds.field("HMAG", &self.HMAG());
      ds.field("HMAG_UNC", &self.HMAG_UNC());
      ds.field("VAR_FLAG", &self.VAR_FLAG());
      ds.field("MULT_FLAG", &self.MULT_FLAG());
      ds.field("NEIGHBOR_ID", &self.NEIGHBOR_ID());
      ds.field("NEIGHBOR_FLAG", &self.NEIGHBOR_FLAG());
      ds.field("NEIGHBOR_DISTANCE", &self.NEIGHBOR_DISTANCE());
      ds.field("SHIFT_FLAG", &self.SHIFT_FLAG());
      ds.field("SHIFT", &self.SHIFT());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct STRT {
  pub ID: Option<String>,
  pub CS_ID: i64,
  pub GNC_CAT_ID: u32,
  pub GAIADR3_CAT_ID: i64,
  pub HIP_CAT_ID: u32,
  pub CAT_VERSION: Option<String>,
  pub ASTROMETRY_ORIGIN: Option<String>,
  pub STAR_EPOCH: f64,
  pub RA: f64,
  pub RA_UNC: f64,
  pub DEC: f64,
  pub DEC_UNC: f64,
  pub POS_UNC_FLAG: bool,
  pub PARALLAX: f64,
  pub PARALLAX_UNC: f64,
  pub PMRA: f64,
  pub PMRA_UNC: f64,
  pub PMDEC: f64,
  pub PMDEC_UNC: f64,
  pub PM_UNC_FLAG: bool,
  pub GMAG: f64,
  pub GMAG_UNC: f64,
  pub BPMAG: f64,
  pub BPMAG_UNC: f64,
  pub RPMAG: f64,
  pub RPMAG_UNC: f64,
  pub JMAG: f64,
  pub JMAG_UNC: f64,
  pub KMAG: f64,
  pub KMAG_UNC: f64,
  pub HMAG: f64,
  pub HMAG_UNC: f64,
  pub VAR_FLAG: bool,
  pub MULT_FLAG: bool,
  pub NEIGHBOR_ID: u32,
  pub NEIGHBOR_FLAG: bool,
  pub NEIGHBOR_DISTANCE: f64,
  pub SHIFT_FLAG: bool,
  pub SHIFT: f64,
}
impl Default for STRT {
  fn default() -> Self {
    Self {
      ID: None,
      CS_ID: 0,
      GNC_CAT_ID: 0,
      GAIADR3_CAT_ID: 0,
      HIP_CAT_ID: 0,
      CAT_VERSION: None,
      ASTROMETRY_ORIGIN: None,
      STAR_EPOCH: 0.0,
      RA: 0.0,
      RA_UNC: 0.0,
      DEC: 0.0,
      DEC_UNC: 0.0,
      POS_UNC_FLAG: false,
      PARALLAX: 0.0,
      PARALLAX_UNC: 0.0,
      PMRA: 0.0,
      PMRA_UNC: 0.0,
      PMDEC: 0.0,
      PMDEC_UNC: 0.0,
      PM_UNC_FLAG: false,
      GMAG: 0.0,
      GMAG_UNC: 0.0,
      BPMAG: 0.0,
      BPMAG_UNC: 0.0,
      RPMAG: 0.0,
      RPMAG_UNC: 0.0,
      JMAG: 0.0,
      JMAG_UNC: 0.0,
      KMAG: 0.0,
      KMAG_UNC: 0.0,
      HMAG: 0.0,
      HMAG_UNC: 0.0,
      VAR_FLAG: false,
      MULT_FLAG: false,
      NEIGHBOR_ID: 0,
      NEIGHBOR_FLAG: false,
      NEIGHBOR_DISTANCE: 0.0,
      SHIFT_FLAG: false,
      SHIFT: 0.0,
    }
  }
}
impl STRT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<STR<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CS_ID = self.CS_ID;
    let GNC_CAT_ID = self.GNC_CAT_ID;
    let GAIADR3_CAT_ID = self.GAIADR3_CAT_ID;
    let HIP_CAT_ID = self.HIP_CAT_ID;
    let CAT_VERSION = self.CAT_VERSION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ASTROMETRY_ORIGIN = self.ASTROMETRY_ORIGIN.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let STAR_EPOCH = self.STAR_EPOCH;
    let RA = self.RA;
    let RA_UNC = self.RA_UNC;
    let DEC = self.DEC;
    let DEC_UNC = self.DEC_UNC;
    let POS_UNC_FLAG = self.POS_UNC_FLAG;
    let PARALLAX = self.PARALLAX;
    let PARALLAX_UNC = self.PARALLAX_UNC;
    let PMRA = self.PMRA;
    let PMRA_UNC = self.PMRA_UNC;
    let PMDEC = self.PMDEC;
    let PMDEC_UNC = self.PMDEC_UNC;
    let PM_UNC_FLAG = self.PM_UNC_FLAG;
    let GMAG = self.GMAG;
    let GMAG_UNC = self.GMAG_UNC;
    let BPMAG = self.BPMAG;
    let BPMAG_UNC = self.BPMAG_UNC;
    let RPMAG = self.RPMAG;
    let RPMAG_UNC = self.RPMAG_UNC;
    let JMAG = self.JMAG;
    let JMAG_UNC = self.JMAG_UNC;
    let KMAG = self.KMAG;
    let KMAG_UNC = self.KMAG_UNC;
    let HMAG = self.HMAG;
    let HMAG_UNC = self.HMAG_UNC;
    let VAR_FLAG = self.VAR_FLAG;
    let MULT_FLAG = self.MULT_FLAG;
    let NEIGHBOR_ID = self.NEIGHBOR_ID;
    let NEIGHBOR_FLAG = self.NEIGHBOR_FLAG;
    let NEIGHBOR_DISTANCE = self.NEIGHBOR_DISTANCE;
    let SHIFT_FLAG = self.SHIFT_FLAG;
    let SHIFT = self.SHIFT;
    STR::create(_fbb, &STRArgs{
      ID,
      CS_ID,
      GNC_CAT_ID,
      GAIADR3_CAT_ID,
      HIP_CAT_ID,
      CAT_VERSION,
      ASTROMETRY_ORIGIN,
      STAR_EPOCH,
      RA,
      RA_UNC,
      DEC,
      DEC_UNC,
      POS_UNC_FLAG,
      PARALLAX,
      PARALLAX_UNC,
      PMRA,
      PMRA_UNC,
      PMDEC,
      PMDEC_UNC,
      PM_UNC_FLAG,
      GMAG,
      GMAG_UNC,
      BPMAG,
      BPMAG_UNC,
      RPMAG,
      RPMAG_UNC,
      JMAG,
      JMAG_UNC,
      KMAG,
      KMAG_UNC,
      HMAG,
      HMAG_UNC,
      VAR_FLAG,
      MULT_FLAG,
      NEIGHBOR_ID,
      NEIGHBOR_FLAG,
      NEIGHBOR_DISTANCE,
      SHIFT_FLAG,
      SHIFT,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `STR`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_STR_unchecked`.
pub fn root_as_STR(buf: &[u8]) -> Result<STR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<STR>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `STR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_STR_unchecked`.
pub fn size_prefixed_root_as_STR(buf: &[u8]) -> Result<STR, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<STR>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `STR` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_STR_unchecked`.
pub fn root_as_STR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<STR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<STR<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `STR` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_STR_unchecked`.
pub fn size_prefixed_root_as_STR_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<STR<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<STR<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a STR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `STR`.
pub unsafe fn root_as_STR_unchecked(buf: &[u8]) -> STR {
  flatbuffers::root_unchecked::<STR>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed STR and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `STR`.
pub unsafe fn size_prefixed_root_as_STR_unchecked(buf: &[u8]) -> STR {
  flatbuffers::size_prefixed_root_unchecked::<STR>(buf)
}
pub const STR_IDENTIFIER: &str = "$STR";

#[inline]
pub fn STR_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, STR_IDENTIFIER, false)
}

#[inline]
pub fn STR_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, STR_IDENTIFIER, true)
}

#[inline]
pub fn finish_STR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<STR<'a>>) {
  fbb.finish(root, Some(STR_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_STR_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<STR<'a>>) {
  fbb.finish_size_prefixed(root, Some(STR_IDENTIFIER));
}
