// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RF_OBS_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RF_OBS_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RF_OBS_TYPE: [rfObsType; 6] = [
  rfObsType::EMISSION,
  rfObsType::TRANSPONDER,
  rfObsType::INTERFERENCE,
  rfObsType::BEACON,
  rfObsType::TELEMETRY,
  rfObsType::UNKNOWN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct rfObsType(pub i8);
#[allow(non_upper_case_globals)]
impl rfObsType {
  pub const EMISSION: Self = Self(0);
  pub const TRANSPONDER: Self = Self(1);
  pub const INTERFERENCE: Self = Self(2);
  pub const BEACON: Self = Self(3);
  pub const TELEMETRY: Self = Self(4);
  pub const UNKNOWN: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EMISSION,
    Self::TRANSPONDER,
    Self::INTERFERENCE,
    Self::BEACON,
    Self::TELEMETRY,
    Self::UNKNOWN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EMISSION => Some("EMISSION"),
      Self::TRANSPONDER => Some("TRANSPONDER"),
      Self::INTERFERENCE => Some("INTERFERENCE"),
      Self::BEACON => Some("BEACON"),
      Self::TELEMETRY => Some("TELEMETRY"),
      Self::UNKNOWN => Some("UNKNOWN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for rfObsType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for rfObsType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for rfObsType {
    type Output = rfObsType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for rfObsType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for rfObsType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for rfObsType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RF_DETECTION_STATUS: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RF_DETECTION_STATUS: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RF_DETECTION_STATUS: [rfDetectionStatus; 5] = [
  rfDetectionStatus::DETECTED,
  rfDetectionStatus::CONFIRMED,
  rfDetectionStatus::TENTATIVE,
  rfDetectionStatus::LOST,
  rfDetectionStatus::INTERFERENCE_ONLY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct rfDetectionStatus(pub i8);
#[allow(non_upper_case_globals)]
impl rfDetectionStatus {
  pub const DETECTED: Self = Self(0);
  pub const CONFIRMED: Self = Self(1);
  pub const TENTATIVE: Self = Self(2);
  pub const LOST: Self = Self(3);
  pub const INTERFERENCE_ONLY: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DETECTED,
    Self::CONFIRMED,
    Self::TENTATIVE,
    Self::LOST,
    Self::INTERFERENCE_ONLY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DETECTED => Some("DETECTED"),
      Self::CONFIRMED => Some("CONFIRMED"),
      Self::TENTATIVE => Some("TENTATIVE"),
      Self::LOST => Some("LOST"),
      Self::INTERFERENCE_ONLY => Some("INTERFERENCE_ONLY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for rfDetectionStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for rfDetectionStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for rfDetectionStatus {
    type Output = rfDetectionStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for rfDetectionStatus {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for rfDetectionStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for rfDetectionStatus {}
pub enum RFOOffset {}
#[derive(Copy, Clone, PartialEq)]

/// RF Observation
pub struct RFO<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RFO<'a> {
  type Inner = RFO<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RFO<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OB_TIME: flatbuffers::VOffsetT = 6;
  pub const VT_ID_SENSOR: flatbuffers::VOffsetT = 8;
  pub const VT_ORIG_SENSOR_ID: flatbuffers::VOffsetT = 10;
  pub const VT_OBS_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_SAT_NO: flatbuffers::VOffsetT = 14;
  pub const VT_ORIG_OBJECT_ID: flatbuffers::VOffsetT = 16;
  pub const VT_ON_ORBIT: flatbuffers::VOffsetT = 18;
  pub const VT_UCT: flatbuffers::VOffsetT = 20;
  pub const VT_TASK_ID: flatbuffers::VOffsetT = 22;
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 24;
  pub const VT_TRACK_ID: flatbuffers::VOffsetT = 26;
  pub const VT_TRANSPONDER: flatbuffers::VOffsetT = 28;
  pub const VT_DETECTION_STATUS: flatbuffers::VOffsetT = 30;
  pub const VT_AZIMUTH: flatbuffers::VOffsetT = 32;
  pub const VT_AZIMUTH_UNC: flatbuffers::VOffsetT = 34;
  pub const VT_AZIMUTH_RATE: flatbuffers::VOffsetT = 36;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 38;
  pub const VT_ELEVATION_UNC: flatbuffers::VOffsetT = 40;
  pub const VT_ELEVATION_RATE: flatbuffers::VOffsetT = 42;
  pub const VT_RANGE: flatbuffers::VOffsetT = 44;
  pub const VT_RANGE_UNC: flatbuffers::VOffsetT = 46;
  pub const VT_RANGE_RATE: flatbuffers::VOffsetT = 48;
  pub const VT_RANGE_RATE_UNC: flatbuffers::VOffsetT = 50;
  pub const VT_TRACK_RANGE: flatbuffers::VOffsetT = 52;
  pub const VT_SENLAT: flatbuffers::VOffsetT = 54;
  pub const VT_SENLON: flatbuffers::VOffsetT = 56;
  pub const VT_SENALT: flatbuffers::VOffsetT = 58;
  pub const VT_ELNOT: flatbuffers::VOffsetT = 60;
  pub const VT_ANTENNA_NAME: flatbuffers::VOffsetT = 62;
  pub const VT_COLLECTION_MODE: flatbuffers::VOffsetT = 64;
  pub const VT_FREQUENCY: flatbuffers::VOffsetT = 66;
  pub const VT_NOMINAL_FREQUENCY: flatbuffers::VOffsetT = 68;
  pub const VT_START_FREQUENCY: flatbuffers::VOffsetT = 70;
  pub const VT_END_FREQUENCY: flatbuffers::VOffsetT = 72;
  pub const VT_FREQUENCY_SHIFT: flatbuffers::VOffsetT = 74;
  pub const VT_BANDWIDTH: flatbuffers::VOffsetT = 76;
  pub const VT_NOMINAL_BANDWIDTH: flatbuffers::VOffsetT = 78;
  pub const VT_RESOLUTION_BANDWIDTH: flatbuffers::VOffsetT = 80;
  pub const VT_VIDEO_BANDWIDTH: flatbuffers::VOffsetT = 82;
  pub const VT_RELATIVE_CARRIER_POWER: flatbuffers::VOffsetT = 84;
  pub const VT_SPECTRUM_ANALYZER_POWER: flatbuffers::VOffsetT = 86;
  pub const VT_RELATIVE_NOISE_FLOOR: flatbuffers::VOffsetT = 88;
  pub const VT_REFERENCE_LEVEL: flatbuffers::VOffsetT = 90;
  pub const VT_NOISE_PWR_DENSITY: flatbuffers::VOffsetT = 92;
  pub const VT_PGRI: flatbuffers::VOffsetT = 94;
  pub const VT_EIRP: flatbuffers::VOffsetT = 96;
  pub const VT_NOMINAL_EIRP: flatbuffers::VOffsetT = 98;
  pub const VT_MIN_PSD: flatbuffers::VOffsetT = 100;
  pub const VT_MAX_PSD: flatbuffers::VOffsetT = 102;
  pub const VT_SNR: flatbuffers::VOffsetT = 104;
  pub const VT_NOMINAL_SNR: flatbuffers::VOffsetT = 106;
  pub const VT_POWER_OVER_NOISE: flatbuffers::VOffsetT = 108;
  pub const VT_NOMINAL_POWER_OVER_NOISE: flatbuffers::VOffsetT = 110;
  pub const VT_POLARITY: flatbuffers::VOffsetT = 112;
  pub const VT_POLARITY_TYPE: flatbuffers::VOffsetT = 114;
  pub const VT_CHANNEL: flatbuffers::VOffsetT = 116;
  pub const VT_BAUD_RATE: flatbuffers::VOffsetT = 118;
  pub const VT_SYMBOL_TO_NOISE_RATIO: flatbuffers::VOffsetT = 120;
  pub const VT_BIT_ERROR_RATE: flatbuffers::VOffsetT = 122;
  pub const VT_PEAK: flatbuffers::VOffsetT = 124;
  pub const VT_INCOMING: flatbuffers::VOffsetT = 126;
  pub const VT_SWITCH_POINT: flatbuffers::VOffsetT = 128;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 130;
  pub const VT_CARRIER_STANDARD: flatbuffers::VOffsetT = 132;
  pub const VT_MODULATION: flatbuffers::VOffsetT = 134;
  pub const VT_INNER_CODING_RATE: flatbuffers::VOffsetT = 136;
  pub const VT_OUTER_CODING_RATE: flatbuffers::VOffsetT = 138;
  pub const VT_TRANSMIT_FILTER_TYPE: flatbuffers::VOffsetT = 140;
  pub const VT_TRANSMIT_FILTER_ROLL_OFF: flatbuffers::VOffsetT = 142;
  pub const VT_RAW_FILE_URI: flatbuffers::VOffsetT = 144;
  pub const VT_DESCRIPTOR: flatbuffers::VOffsetT = 146;
  pub const VT_URL: flatbuffers::VOffsetT = 148;
  pub const VT_TAGS: flatbuffers::VOffsetT = 150;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RFO { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RFOArgs<'args>
  ) -> flatbuffers::WIPOffset<RFO<'bldr>> {
    let mut builder = RFOBuilder::new(_fbb);
    builder.add_TRANSMIT_FILTER_ROLL_OFF(args.TRANSMIT_FILTER_ROLL_OFF);
    builder.add_CONFIDENCE(args.CONFIDENCE);
    builder.add_BIT_ERROR_RATE(args.BIT_ERROR_RATE);
    builder.add_SYMBOL_TO_NOISE_RATIO(args.SYMBOL_TO_NOISE_RATIO);
    builder.add_BAUD_RATE(args.BAUD_RATE);
    builder.add_POLARITY(args.POLARITY);
    builder.add_NOMINAL_POWER_OVER_NOISE(args.NOMINAL_POWER_OVER_NOISE);
    builder.add_POWER_OVER_NOISE(args.POWER_OVER_NOISE);
    builder.add_NOMINAL_SNR(args.NOMINAL_SNR);
    builder.add_SNR(args.SNR);
    builder.add_MAX_PSD(args.MAX_PSD);
    builder.add_MIN_PSD(args.MIN_PSD);
    builder.add_NOMINAL_EIRP(args.NOMINAL_EIRP);
    builder.add_EIRP(args.EIRP);
    builder.add_PGRI(args.PGRI);
    builder.add_NOISE_PWR_DENSITY(args.NOISE_PWR_DENSITY);
    builder.add_REFERENCE_LEVEL(args.REFERENCE_LEVEL);
    builder.add_RELATIVE_NOISE_FLOOR(args.RELATIVE_NOISE_FLOOR);
    builder.add_SPECTRUM_ANALYZER_POWER(args.SPECTRUM_ANALYZER_POWER);
    builder.add_RELATIVE_CARRIER_POWER(args.RELATIVE_CARRIER_POWER);
    builder.add_VIDEO_BANDWIDTH(args.VIDEO_BANDWIDTH);
    builder.add_RESOLUTION_BANDWIDTH(args.RESOLUTION_BANDWIDTH);
    builder.add_NOMINAL_BANDWIDTH(args.NOMINAL_BANDWIDTH);
    builder.add_BANDWIDTH(args.BANDWIDTH);
    builder.add_FREQUENCY_SHIFT(args.FREQUENCY_SHIFT);
    builder.add_END_FREQUENCY(args.END_FREQUENCY);
    builder.add_START_FREQUENCY(args.START_FREQUENCY);
    builder.add_NOMINAL_FREQUENCY(args.NOMINAL_FREQUENCY);
    builder.add_FREQUENCY(args.FREQUENCY);
    builder.add_SENALT(args.SENALT);
    builder.add_SENLON(args.SENLON);
    builder.add_SENLAT(args.SENLAT);
    builder.add_TRACK_RANGE(args.TRACK_RANGE);
    builder.add_RANGE_RATE_UNC(args.RANGE_RATE_UNC);
    builder.add_RANGE_RATE(args.RANGE_RATE);
    builder.add_RANGE_UNC(args.RANGE_UNC);
    builder.add_RANGE(args.RANGE);
    builder.add_ELEVATION_RATE(args.ELEVATION_RATE);
    builder.add_ELEVATION_UNC(args.ELEVATION_UNC);
    builder.add_ELEVATION(args.ELEVATION);
    builder.add_AZIMUTH_RATE(args.AZIMUTH_RATE);
    builder.add_AZIMUTH_UNC(args.AZIMUTH_UNC);
    builder.add_AZIMUTH(args.AZIMUTH);
    if let Some(x) = args.TAGS { builder.add_TAGS(x); }
    if let Some(x) = args.URL { builder.add_URL(x); }
    if let Some(x) = args.DESCRIPTOR { builder.add_DESCRIPTOR(x); }
    if let Some(x) = args.RAW_FILE_URI { builder.add_RAW_FILE_URI(x); }
    if let Some(x) = args.TRANSMIT_FILTER_TYPE { builder.add_TRANSMIT_FILTER_TYPE(x); }
    if let Some(x) = args.MODULATION { builder.add_MODULATION(x); }
    if let Some(x) = args.CARRIER_STANDARD { builder.add_CARRIER_STANDARD(x); }
    if let Some(x) = args.POLARITY_TYPE { builder.add_POLARITY_TYPE(x); }
    if let Some(x) = args.COLLECTION_MODE { builder.add_COLLECTION_MODE(x); }
    if let Some(x) = args.ANTENNA_NAME { builder.add_ANTENNA_NAME(x); }
    if let Some(x) = args.ELNOT { builder.add_ELNOT(x); }
    if let Some(x) = args.TRANSPONDER { builder.add_TRANSPONDER(x); }
    if let Some(x) = args.TRACK_ID { builder.add_TRACK_ID(x); }
    if let Some(x) = args.TRANSACTION_ID { builder.add_TRANSACTION_ID(x); }
    if let Some(x) = args.TASK_ID { builder.add_TASK_ID(x); }
    if let Some(x) = args.ON_ORBIT { builder.add_ON_ORBIT(x); }
    if let Some(x) = args.ORIG_OBJECT_ID { builder.add_ORIG_OBJECT_ID(x); }
    builder.add_SAT_NO(args.SAT_NO);
    if let Some(x) = args.ORIG_SENSOR_ID { builder.add_ORIG_SENSOR_ID(x); }
    if let Some(x) = args.ID_SENSOR { builder.add_ID_SENSOR(x); }
    if let Some(x) = args.OB_TIME { builder.add_OB_TIME(x); }
    if let Some(x) = args.ID { builder.add_ID(x); }
    builder.add_SWITCH_POINT(args.SWITCH_POINT);
    builder.add_CHANNEL(args.CHANNEL);
    builder.add_OUTER_CODING_RATE(args.OUTER_CODING_RATE);
    builder.add_INNER_CODING_RATE(args.INNER_CODING_RATE);
    builder.add_INCOMING(args.INCOMING);
    builder.add_PEAK(args.PEAK);
    builder.add_DETECTION_STATUS(args.DETECTION_STATUS);
    builder.add_UCT(args.UCT);
    builder.add_OBS_TYPE(args.OBS_TYPE);
    builder.finish()
  }

  pub fn unpack(&self) -> RFOT {
    let ID = self.ID().map(|x| {
      x.to_string()
    });
    let OB_TIME = self.OB_TIME().map(|x| {
      x.to_string()
    });
    let ID_SENSOR = self.ID_SENSOR().map(|x| {
      x.to_string()
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID().map(|x| {
      x.to_string()
    });
    let OBS_TYPE = self.OBS_TYPE();
    let SAT_NO = self.SAT_NO();
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID().map(|x| {
      x.to_string()
    });
    let ON_ORBIT = self.ON_ORBIT().map(|x| {
      x.to_string()
    });
    let UCT = self.UCT();
    let TASK_ID = self.TASK_ID().map(|x| {
      x.to_string()
    });
    let TRANSACTION_ID = self.TRANSACTION_ID().map(|x| {
      x.to_string()
    });
    let TRACK_ID = self.TRACK_ID().map(|x| {
      x.to_string()
    });
    let TRANSPONDER = self.TRANSPONDER().map(|x| {
      x.to_string()
    });
    let DETECTION_STATUS = self.DETECTION_STATUS();
    let AZIMUTH = self.AZIMUTH();
    let AZIMUTH_UNC = self.AZIMUTH_UNC();
    let AZIMUTH_RATE = self.AZIMUTH_RATE();
    let ELEVATION = self.ELEVATION();
    let ELEVATION_UNC = self.ELEVATION_UNC();
    let ELEVATION_RATE = self.ELEVATION_RATE();
    let RANGE = self.RANGE();
    let RANGE_UNC = self.RANGE_UNC();
    let RANGE_RATE = self.RANGE_RATE();
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC();
    let TRACK_RANGE = self.TRACK_RANGE();
    let SENLAT = self.SENLAT();
    let SENLON = self.SENLON();
    let SENALT = self.SENALT();
    let ELNOT = self.ELNOT().map(|x| {
      x.to_string()
    });
    let ANTENNA_NAME = self.ANTENNA_NAME().map(|x| {
      x.to_string()
    });
    let COLLECTION_MODE = self.COLLECTION_MODE().map(|x| {
      x.to_string()
    });
    let FREQUENCY = self.FREQUENCY();
    let NOMINAL_FREQUENCY = self.NOMINAL_FREQUENCY();
    let START_FREQUENCY = self.START_FREQUENCY();
    let END_FREQUENCY = self.END_FREQUENCY();
    let FREQUENCY_SHIFT = self.FREQUENCY_SHIFT();
    let BANDWIDTH = self.BANDWIDTH();
    let NOMINAL_BANDWIDTH = self.NOMINAL_BANDWIDTH();
    let RESOLUTION_BANDWIDTH = self.RESOLUTION_BANDWIDTH();
    let VIDEO_BANDWIDTH = self.VIDEO_BANDWIDTH();
    let RELATIVE_CARRIER_POWER = self.RELATIVE_CARRIER_POWER();
    let SPECTRUM_ANALYZER_POWER = self.SPECTRUM_ANALYZER_POWER();
    let RELATIVE_NOISE_FLOOR = self.RELATIVE_NOISE_FLOOR();
    let REFERENCE_LEVEL = self.REFERENCE_LEVEL();
    let NOISE_PWR_DENSITY = self.NOISE_PWR_DENSITY();
    let PGRI = self.PGRI();
    let EIRP = self.EIRP();
    let NOMINAL_EIRP = self.NOMINAL_EIRP();
    let MIN_PSD = self.MIN_PSD();
    let MAX_PSD = self.MAX_PSD();
    let SNR = self.SNR();
    let NOMINAL_SNR = self.NOMINAL_SNR();
    let POWER_OVER_NOISE = self.POWER_OVER_NOISE();
    let NOMINAL_POWER_OVER_NOISE = self.NOMINAL_POWER_OVER_NOISE();
    let POLARITY = self.POLARITY();
    let POLARITY_TYPE = self.POLARITY_TYPE().map(|x| {
      x.to_string()
    });
    let CHANNEL = self.CHANNEL();
    let BAUD_RATE = self.BAUD_RATE();
    let SYMBOL_TO_NOISE_RATIO = self.SYMBOL_TO_NOISE_RATIO();
    let BIT_ERROR_RATE = self.BIT_ERROR_RATE();
    let PEAK = self.PEAK();
    let INCOMING = self.INCOMING();
    let SWITCH_POINT = self.SWITCH_POINT();
    let CONFIDENCE = self.CONFIDENCE();
    let CARRIER_STANDARD = self.CARRIER_STANDARD().map(|x| {
      x.to_string()
    });
    let MODULATION = self.MODULATION().map(|x| {
      x.to_string()
    });
    let INNER_CODING_RATE = self.INNER_CODING_RATE();
    let OUTER_CODING_RATE = self.OUTER_CODING_RATE();
    let TRANSMIT_FILTER_TYPE = self.TRANSMIT_FILTER_TYPE().map(|x| {
      x.to_string()
    });
    let TRANSMIT_FILTER_ROLL_OFF = self.TRANSMIT_FILTER_ROLL_OFF();
    let RAW_FILE_URI = self.RAW_FILE_URI().map(|x| {
      x.to_string()
    });
    let DESCRIPTOR = self.DESCRIPTOR().map(|x| {
      x.to_string()
    });
    let URL = self.URL().map(|x| {
      x.to_string()
    });
    let TAGS = self.TAGS().map(|x| {
      x.iter().map(|s| s.to_string()).collect()
    });
    RFOT {
      ID,
      OB_TIME,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OBS_TYPE,
      SAT_NO,
      ORIG_OBJECT_ID,
      ON_ORBIT,
      UCT,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      TRANSPONDER,
      DETECTION_STATUS,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_RATE,
      RANGE,
      RANGE_UNC,
      RANGE_RATE,
      RANGE_RATE_UNC,
      TRACK_RANGE,
      SENLAT,
      SENLON,
      SENALT,
      ELNOT,
      ANTENNA_NAME,
      COLLECTION_MODE,
      FREQUENCY,
      NOMINAL_FREQUENCY,
      START_FREQUENCY,
      END_FREQUENCY,
      FREQUENCY_SHIFT,
      BANDWIDTH,
      NOMINAL_BANDWIDTH,
      RESOLUTION_BANDWIDTH,
      VIDEO_BANDWIDTH,
      RELATIVE_CARRIER_POWER,
      SPECTRUM_ANALYZER_POWER,
      RELATIVE_NOISE_FLOOR,
      REFERENCE_LEVEL,
      NOISE_PWR_DENSITY,
      PGRI,
      EIRP,
      NOMINAL_EIRP,
      MIN_PSD,
      MAX_PSD,
      SNR,
      NOMINAL_SNR,
      POWER_OVER_NOISE,
      NOMINAL_POWER_OVER_NOISE,
      POLARITY,
      POLARITY_TYPE,
      CHANNEL,
      BAUD_RATE,
      SYMBOL_TO_NOISE_RATIO,
      BIT_ERROR_RATE,
      PEAK,
      INCOMING,
      SWITCH_POINT,
      CONFIDENCE,
      CARRIER_STANDARD,
      MODULATION,
      INNER_CODING_RATE,
      OUTER_CODING_RATE,
      TRANSMIT_FILTER_TYPE,
      TRANSMIT_FILTER_ROLL_OFF,
      RAW_FILE_URI,
      DESCRIPTOR,
      URL,
      TAGS,
    }
  }

  /// Unique identifier
  #[inline]
  pub fn ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ID, None)}
  }
  /// Observation time (ISO 8601)
  #[inline]
  pub fn OB_TIME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_OB_TIME, None)}
  }
  /// Sensor identifier
  #[inline]
  pub fn ID_SENSOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ID_SENSOR, None)}
  }
  /// Original sensor identifier
  #[inline]
  pub fn ORIG_SENSOR_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ORIG_SENSOR_ID, None)}
  }
  /// Observation type
  #[inline]
  pub fn OBS_TYPE(&self) -> rfObsType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<rfObsType>(RFO::VT_OBS_TYPE, Some(rfObsType::EMISSION)).unwrap()}
  }
  /// Satellite catalog number
  #[inline]
  pub fn SAT_NO(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RFO::VT_SAT_NO, Some(0)).unwrap()}
  }
  /// International designator
  #[inline]
  pub fn ORIG_OBJECT_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ORIG_OBJECT_ID, None)}
  }
  /// On-orbit reference
  #[inline]
  pub fn ON_ORBIT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ON_ORBIT, None)}
  }
  /// True if uncorrelated target
  #[inline]
  pub fn UCT(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFO::VT_UCT, Some(false)).unwrap()}
  }
  /// Task identifier
  #[inline]
  pub fn TASK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_TASK_ID, None)}
  }
  /// Transaction identifier
  #[inline]
  pub fn TRANSACTION_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_TRANSACTION_ID, None)}
  }
  /// Track identifier
  #[inline]
  pub fn TRACK_ID(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_TRACK_ID, None)}
  }
  /// Transponder identifier
  #[inline]
  pub fn TRANSPONDER(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_TRANSPONDER, None)}
  }
  /// Detection status
  #[inline]
  pub fn DETECTION_STATUS(&self) -> rfDetectionStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<rfDetectionStatus>(RFO::VT_DETECTION_STATUS, Some(rfDetectionStatus::DETECTED)).unwrap()}
  }
  /// Azimuth angle (degrees)
  #[inline]
  pub fn AZIMUTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_AZIMUTH, Some(0.0)).unwrap()}
  }
  /// Azimuth uncertainty (degrees, 1-sigma)
  #[inline]
  pub fn AZIMUTH_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_AZIMUTH_UNC, Some(0.0)).unwrap()}
  }
  /// Azimuth rate (degrees/s)
  #[inline]
  pub fn AZIMUTH_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_AZIMUTH_RATE, Some(0.0)).unwrap()}
  }
  /// Elevation angle (degrees)
  #[inline]
  pub fn ELEVATION(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  /// Elevation uncertainty (degrees, 1-sigma)
  #[inline]
  pub fn ELEVATION_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_ELEVATION_UNC, Some(0.0)).unwrap()}
  }
  /// Elevation rate (degrees/s)
  #[inline]
  pub fn ELEVATION_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_ELEVATION_RATE, Some(0.0)).unwrap()}
  }
  /// Slant range (km)
  #[inline]
  pub fn RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RANGE, Some(0.0)).unwrap()}
  }
  /// Range uncertainty (km, 1-sigma)
  #[inline]
  pub fn RANGE_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RANGE_UNC, Some(0.0)).unwrap()}
  }
  /// Range rate (km/s)
  #[inline]
  pub fn RANGE_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RANGE_RATE, Some(0.0)).unwrap()}
  }
  /// Range rate uncertainty (km/s, 1-sigma)
  #[inline]
  pub fn RANGE_RATE_UNC(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RANGE_RATE_UNC, Some(0.0)).unwrap()}
  }
  /// Track range (km)
  #[inline]
  pub fn TRACK_RANGE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_TRACK_RANGE, Some(0.0)).unwrap()}
  }
  /// Sensor latitude (degrees)
  #[inline]
  pub fn SENLAT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SENLAT, Some(0.0)).unwrap()}
  }
  /// Sensor longitude (degrees)
  #[inline]
  pub fn SENLON(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SENLON, Some(0.0)).unwrap()}
  }
  /// Sensor altitude (km)
  #[inline]
  pub fn SENALT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SENALT, Some(0.0)).unwrap()}
  }
  /// ELNOT (Electronic Intelligence Notation)
  #[inline]
  pub fn ELNOT(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ELNOT, None)}
  }
  /// Antenna name
  #[inline]
  pub fn ANTENNA_NAME(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_ANTENNA_NAME, None)}
  }
  /// Collection mode
  #[inline]
  pub fn COLLECTION_MODE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_COLLECTION_MODE, None)}
  }
  /// Measured center frequency (MHz)
  #[inline]
  pub fn FREQUENCY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// Nominal center frequency (MHz)
  #[inline]
  pub fn NOMINAL_FREQUENCY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOMINAL_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// Start frequency of emission (MHz)
  #[inline]
  pub fn START_FREQUENCY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_START_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// End frequency of emission (MHz)
  #[inline]
  pub fn END_FREQUENCY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_END_FREQUENCY, Some(0.0)).unwrap()}
  }
  /// Frequency shift from nominal (MHz)
  #[inline]
  pub fn FREQUENCY_SHIFT(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_FREQUENCY_SHIFT, Some(0.0)).unwrap()}
  }
  /// Measured bandwidth (MHz)
  #[inline]
  pub fn BANDWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Nominal bandwidth (MHz)
  #[inline]
  pub fn NOMINAL_BANDWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOMINAL_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Resolution bandwidth (MHz)
  #[inline]
  pub fn RESOLUTION_BANDWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RESOLUTION_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Video bandwidth (MHz)
  #[inline]
  pub fn VIDEO_BANDWIDTH(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_VIDEO_BANDWIDTH, Some(0.0)).unwrap()}
  }
  /// Relative carrier power (dBm)
  #[inline]
  pub fn RELATIVE_CARRIER_POWER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RELATIVE_CARRIER_POWER, Some(0.0)).unwrap()}
  }
  /// Spectrum analyzer power (dBm)
  #[inline]
  pub fn SPECTRUM_ANALYZER_POWER(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SPECTRUM_ANALYZER_POWER, Some(0.0)).unwrap()}
  }
  /// Relative noise floor (dBm)
  #[inline]
  pub fn RELATIVE_NOISE_FLOOR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_RELATIVE_NOISE_FLOOR, Some(0.0)).unwrap()}
  }
  /// Reference level (dBm)
  #[inline]
  pub fn REFERENCE_LEVEL(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_REFERENCE_LEVEL, Some(0.0)).unwrap()}
  }
  /// Noise power density (dBm/Hz)
  #[inline]
  pub fn NOISE_PWR_DENSITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOISE_PWR_DENSITY, Some(0.0)).unwrap()}
  }
  /// PGRI (Pulse Group Repetition Interval, microseconds)
  #[inline]
  pub fn PGRI(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_PGRI, Some(0.0)).unwrap()}
  }
  /// Effective isotropic radiated power (dBW)
  #[inline]
  pub fn EIRP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_EIRP, Some(0.0)).unwrap()}
  }
  /// Nominal EIRP (dBW)
  #[inline]
  pub fn NOMINAL_EIRP(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOMINAL_EIRP, Some(0.0)).unwrap()}
  }
  /// Minimum power spectral density (dBm/Hz)
  #[inline]
  pub fn MIN_PSD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_MIN_PSD, Some(0.0)).unwrap()}
  }
  /// Maximum power spectral density (dBm/Hz)
  #[inline]
  pub fn MAX_PSD(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_MAX_PSD, Some(0.0)).unwrap()}
  }
  /// Signal-to-noise ratio (dB)
  #[inline]
  pub fn SNR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SNR, Some(0.0)).unwrap()}
  }
  /// Nominal SNR (dB)
  #[inline]
  pub fn NOMINAL_SNR(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOMINAL_SNR, Some(0.0)).unwrap()}
  }
  /// Power over noise (dB)
  #[inline]
  pub fn POWER_OVER_NOISE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_POWER_OVER_NOISE, Some(0.0)).unwrap()}
  }
  /// Nominal power over noise (dB)
  #[inline]
  pub fn NOMINAL_POWER_OVER_NOISE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_NOMINAL_POWER_OVER_NOISE, Some(0.0)).unwrap()}
  }
  /// Polarity angle (degrees)
  #[inline]
  pub fn POLARITY(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_POLARITY, Some(0.0)).unwrap()}
  }
  /// Polarization type (e.g., LHCP, RHCP, LINEAR)
  #[inline]
  pub fn POLARITY_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_POLARITY_TYPE, None)}
  }
  /// Channel number
  #[inline]
  pub fn CHANNEL(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RFO::VT_CHANNEL, Some(0)).unwrap()}
  }
  /// Baud rate (symbols/s)
  #[inline]
  pub fn BAUD_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_BAUD_RATE, Some(0.0)).unwrap()}
  }
  /// Symbol-to-noise ratio (dB)
  #[inline]
  pub fn SYMBOL_TO_NOISE_RATIO(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_SYMBOL_TO_NOISE_RATIO, Some(0.0)).unwrap()}
  }
  /// Bit error rate
  #[inline]
  pub fn BIT_ERROR_RATE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_BIT_ERROR_RATE, Some(0.0)).unwrap()}
  }
  /// True if peak measurement
  #[inline]
  pub fn PEAK(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFO::VT_PEAK, Some(false)).unwrap()}
  }
  /// True if incoming signal
  #[inline]
  pub fn INCOMING(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RFO::VT_INCOMING, Some(false)).unwrap()}
  }
  /// Switch point number
  #[inline]
  pub fn SWITCH_POINT(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(RFO::VT_SWITCH_POINT, Some(0)).unwrap()}
  }
  /// Confidence score (0-1)
  #[inline]
  pub fn CONFIDENCE(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_CONFIDENCE, Some(0.0)).unwrap()}
  }
  /// Carrier standard (e.g., DVB-S, DVB-S2)
  #[inline]
  pub fn CARRIER_STANDARD(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_CARRIER_STANDARD, None)}
  }
  /// Modulation type
  #[inline]
  pub fn MODULATION(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_MODULATION, None)}
  }
  /// Inner FEC coding rate denominator
  #[inline]
  pub fn INNER_CODING_RATE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RFO::VT_INNER_CODING_RATE, Some(0)).unwrap()}
  }
  /// Outer FEC coding rate denominator
  #[inline]
  pub fn OUTER_CODING_RATE(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RFO::VT_OUTER_CODING_RATE, Some(0)).unwrap()}
  }
  /// Transmit filter type
  #[inline]
  pub fn TRANSMIT_FILTER_TYPE(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_TRANSMIT_FILTER_TYPE, None)}
  }
  /// Transmit filter roll-off factor
  #[inline]
  pub fn TRANSMIT_FILTER_ROLL_OFF(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(RFO::VT_TRANSMIT_FILTER_ROLL_OFF, Some(0.0)).unwrap()}
  }
  /// Reference to raw data file
  #[inline]
  pub fn RAW_FILE_URI(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_RAW_FILE_URI, None)}
  }
  /// Event descriptor
  #[inline]
  pub fn DESCRIPTOR(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_DESCRIPTOR, None)}
  }
  /// Reference URL
  #[inline]
  pub fn URL(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RFO::VT_URL, None)}
  }
  /// Associated tags
  #[inline]
  pub fn TAGS(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RFO::VT_TAGS, None)}
  }
}

impl flatbuffers::Verifiable for RFO<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("OB_TIME", Self::VT_OB_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ID_SENSOR", Self::VT_ID_SENSOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_SENSOR_ID", Self::VT_ORIG_SENSOR_ID, false)?
     .visit_field::<rfObsType>("OBS_TYPE", Self::VT_OBS_TYPE, false)?
     .visit_field::<u32>("SAT_NO", Self::VT_SAT_NO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ORIG_OBJECT_ID", Self::VT_ORIG_OBJECT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ON_ORBIT", Self::VT_ON_ORBIT, false)?
     .visit_field::<bool>("UCT", Self::VT_UCT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TASK_ID", Self::VT_TASK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSACTION_ID", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRACK_ID", Self::VT_TRACK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSPONDER", Self::VT_TRANSPONDER, false)?
     .visit_field::<rfDetectionStatus>("DETECTION_STATUS", Self::VT_DETECTION_STATUS, false)?
     .visit_field::<f64>("AZIMUTH", Self::VT_AZIMUTH, false)?
     .visit_field::<f64>("AZIMUTH_UNC", Self::VT_AZIMUTH_UNC, false)?
     .visit_field::<f64>("AZIMUTH_RATE", Self::VT_AZIMUTH_RATE, false)?
     .visit_field::<f64>("ELEVATION", Self::VT_ELEVATION, false)?
     .visit_field::<f64>("ELEVATION_UNC", Self::VT_ELEVATION_UNC, false)?
     .visit_field::<f64>("ELEVATION_RATE", Self::VT_ELEVATION_RATE, false)?
     .visit_field::<f64>("RANGE", Self::VT_RANGE, false)?
     .visit_field::<f64>("RANGE_UNC", Self::VT_RANGE_UNC, false)?
     .visit_field::<f64>("RANGE_RATE", Self::VT_RANGE_RATE, false)?
     .visit_field::<f64>("RANGE_RATE_UNC", Self::VT_RANGE_RATE_UNC, false)?
     .visit_field::<f64>("TRACK_RANGE", Self::VT_TRACK_RANGE, false)?
     .visit_field::<f64>("SENLAT", Self::VT_SENLAT, false)?
     .visit_field::<f64>("SENLON", Self::VT_SENLON, false)?
     .visit_field::<f64>("SENALT", Self::VT_SENALT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ELNOT", Self::VT_ELNOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("ANTENNA_NAME", Self::VT_ANTENNA_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("COLLECTION_MODE", Self::VT_COLLECTION_MODE, false)?
     .visit_field::<f64>("FREQUENCY", Self::VT_FREQUENCY, false)?
     .visit_field::<f64>("NOMINAL_FREQUENCY", Self::VT_NOMINAL_FREQUENCY, false)?
     .visit_field::<f64>("START_FREQUENCY", Self::VT_START_FREQUENCY, false)?
     .visit_field::<f64>("END_FREQUENCY", Self::VT_END_FREQUENCY, false)?
     .visit_field::<f64>("FREQUENCY_SHIFT", Self::VT_FREQUENCY_SHIFT, false)?
     .visit_field::<f64>("BANDWIDTH", Self::VT_BANDWIDTH, false)?
     .visit_field::<f64>("NOMINAL_BANDWIDTH", Self::VT_NOMINAL_BANDWIDTH, false)?
     .visit_field::<f64>("RESOLUTION_BANDWIDTH", Self::VT_RESOLUTION_BANDWIDTH, false)?
     .visit_field::<f64>("VIDEO_BANDWIDTH", Self::VT_VIDEO_BANDWIDTH, false)?
     .visit_field::<f64>("RELATIVE_CARRIER_POWER", Self::VT_RELATIVE_CARRIER_POWER, false)?
     .visit_field::<f64>("SPECTRUM_ANALYZER_POWER", Self::VT_SPECTRUM_ANALYZER_POWER, false)?
     .visit_field::<f64>("RELATIVE_NOISE_FLOOR", Self::VT_RELATIVE_NOISE_FLOOR, false)?
     .visit_field::<f64>("REFERENCE_LEVEL", Self::VT_REFERENCE_LEVEL, false)?
     .visit_field::<f64>("NOISE_PWR_DENSITY", Self::VT_NOISE_PWR_DENSITY, false)?
     .visit_field::<f64>("PGRI", Self::VT_PGRI, false)?
     .visit_field::<f64>("EIRP", Self::VT_EIRP, false)?
     .visit_field::<f64>("NOMINAL_EIRP", Self::VT_NOMINAL_EIRP, false)?
     .visit_field::<f64>("MIN_PSD", Self::VT_MIN_PSD, false)?
     .visit_field::<f64>("MAX_PSD", Self::VT_MAX_PSD, false)?
     .visit_field::<f64>("SNR", Self::VT_SNR, false)?
     .visit_field::<f64>("NOMINAL_SNR", Self::VT_NOMINAL_SNR, false)?
     .visit_field::<f64>("POWER_OVER_NOISE", Self::VT_POWER_OVER_NOISE, false)?
     .visit_field::<f64>("NOMINAL_POWER_OVER_NOISE", Self::VT_NOMINAL_POWER_OVER_NOISE, false)?
     .visit_field::<f64>("POLARITY", Self::VT_POLARITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("POLARITY_TYPE", Self::VT_POLARITY_TYPE, false)?
     .visit_field::<u16>("CHANNEL", Self::VT_CHANNEL, false)?
     .visit_field::<f64>("BAUD_RATE", Self::VT_BAUD_RATE, false)?
     .visit_field::<f64>("SYMBOL_TO_NOISE_RATIO", Self::VT_SYMBOL_TO_NOISE_RATIO, false)?
     .visit_field::<f64>("BIT_ERROR_RATE", Self::VT_BIT_ERROR_RATE, false)?
     .visit_field::<bool>("PEAK", Self::VT_PEAK, false)?
     .visit_field::<bool>("INCOMING", Self::VT_INCOMING, false)?
     .visit_field::<u16>("SWITCH_POINT", Self::VT_SWITCH_POINT, false)?
     .visit_field::<f64>("CONFIDENCE", Self::VT_CONFIDENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("CARRIER_STANDARD", Self::VT_CARRIER_STANDARD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("MODULATION", Self::VT_MODULATION, false)?
     .visit_field::<u8>("INNER_CODING_RATE", Self::VT_INNER_CODING_RATE, false)?
     .visit_field::<u8>("OUTER_CODING_RATE", Self::VT_OUTER_CODING_RATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("TRANSMIT_FILTER_TYPE", Self::VT_TRANSMIT_FILTER_TYPE, false)?
     .visit_field::<f64>("TRANSMIT_FILTER_ROLL_OFF", Self::VT_TRANSMIT_FILTER_ROLL_OFF, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("RAW_FILE_URI", Self::VT_RAW_FILE_URI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("DESCRIPTOR", Self::VT_DESCRIPTOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("URL", Self::VT_URL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("TAGS", Self::VT_TAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct RFOArgs<'a> {
    pub ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OB_TIME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ID_SENSOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ORIG_SENSOR_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub OBS_TYPE: rfObsType,
    pub SAT_NO: u32,
    pub ORIG_OBJECT_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ON_ORBIT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub UCT: bool,
    pub TASK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSACTION_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRACK_ID: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSPONDER: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DETECTION_STATUS: rfDetectionStatus,
    pub AZIMUTH: f64,
    pub AZIMUTH_UNC: f64,
    pub AZIMUTH_RATE: f64,
    pub ELEVATION: f64,
    pub ELEVATION_UNC: f64,
    pub ELEVATION_RATE: f64,
    pub RANGE: f64,
    pub RANGE_UNC: f64,
    pub RANGE_RATE: f64,
    pub RANGE_RATE_UNC: f64,
    pub TRACK_RANGE: f64,
    pub SENLAT: f64,
    pub SENLON: f64,
    pub SENALT: f64,
    pub ELNOT: Option<flatbuffers::WIPOffset<&'a str>>,
    pub ANTENNA_NAME: Option<flatbuffers::WIPOffset<&'a str>>,
    pub COLLECTION_MODE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub FREQUENCY: f64,
    pub NOMINAL_FREQUENCY: f64,
    pub START_FREQUENCY: f64,
    pub END_FREQUENCY: f64,
    pub FREQUENCY_SHIFT: f64,
    pub BANDWIDTH: f64,
    pub NOMINAL_BANDWIDTH: f64,
    pub RESOLUTION_BANDWIDTH: f64,
    pub VIDEO_BANDWIDTH: f64,
    pub RELATIVE_CARRIER_POWER: f64,
    pub SPECTRUM_ANALYZER_POWER: f64,
    pub RELATIVE_NOISE_FLOOR: f64,
    pub REFERENCE_LEVEL: f64,
    pub NOISE_PWR_DENSITY: f64,
    pub PGRI: f64,
    pub EIRP: f64,
    pub NOMINAL_EIRP: f64,
    pub MIN_PSD: f64,
    pub MAX_PSD: f64,
    pub SNR: f64,
    pub NOMINAL_SNR: f64,
    pub POWER_OVER_NOISE: f64,
    pub NOMINAL_POWER_OVER_NOISE: f64,
    pub POLARITY: f64,
    pub POLARITY_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub CHANNEL: u16,
    pub BAUD_RATE: f64,
    pub SYMBOL_TO_NOISE_RATIO: f64,
    pub BIT_ERROR_RATE: f64,
    pub PEAK: bool,
    pub INCOMING: bool,
    pub SWITCH_POINT: u16,
    pub CONFIDENCE: f64,
    pub CARRIER_STANDARD: Option<flatbuffers::WIPOffset<&'a str>>,
    pub MODULATION: Option<flatbuffers::WIPOffset<&'a str>>,
    pub INNER_CODING_RATE: u8,
    pub OUTER_CODING_RATE: u8,
    pub TRANSMIT_FILTER_TYPE: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TRANSMIT_FILTER_ROLL_OFF: f64,
    pub RAW_FILE_URI: Option<flatbuffers::WIPOffset<&'a str>>,
    pub DESCRIPTOR: Option<flatbuffers::WIPOffset<&'a str>>,
    pub URL: Option<flatbuffers::WIPOffset<&'a str>>,
    pub TAGS: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for RFOArgs<'a> {
  #[inline]
  fn default() -> Self {
    RFOArgs {
      ID: None,
      OB_TIME: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OBS_TYPE: rfObsType::EMISSION,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ON_ORBIT: None,
      UCT: false,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      TRANSPONDER: None,
      DETECTION_STATUS: rfDetectionStatus::DETECTED,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_UNC: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      TRACK_RANGE: 0.0,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      ELNOT: None,
      ANTENNA_NAME: None,
      COLLECTION_MODE: None,
      FREQUENCY: 0.0,
      NOMINAL_FREQUENCY: 0.0,
      START_FREQUENCY: 0.0,
      END_FREQUENCY: 0.0,
      FREQUENCY_SHIFT: 0.0,
      BANDWIDTH: 0.0,
      NOMINAL_BANDWIDTH: 0.0,
      RESOLUTION_BANDWIDTH: 0.0,
      VIDEO_BANDWIDTH: 0.0,
      RELATIVE_CARRIER_POWER: 0.0,
      SPECTRUM_ANALYZER_POWER: 0.0,
      RELATIVE_NOISE_FLOOR: 0.0,
      REFERENCE_LEVEL: 0.0,
      NOISE_PWR_DENSITY: 0.0,
      PGRI: 0.0,
      EIRP: 0.0,
      NOMINAL_EIRP: 0.0,
      MIN_PSD: 0.0,
      MAX_PSD: 0.0,
      SNR: 0.0,
      NOMINAL_SNR: 0.0,
      POWER_OVER_NOISE: 0.0,
      NOMINAL_POWER_OVER_NOISE: 0.0,
      POLARITY: 0.0,
      POLARITY_TYPE: None,
      CHANNEL: 0,
      BAUD_RATE: 0.0,
      SYMBOL_TO_NOISE_RATIO: 0.0,
      BIT_ERROR_RATE: 0.0,
      PEAK: false,
      INCOMING: false,
      SWITCH_POINT: 0,
      CONFIDENCE: 0.0,
      CARRIER_STANDARD: None,
      MODULATION: None,
      INNER_CODING_RATE: 0,
      OUTER_CODING_RATE: 0,
      TRANSMIT_FILTER_TYPE: None,
      TRANSMIT_FILTER_ROLL_OFF: 0.0,
      RAW_FILE_URI: None,
      DESCRIPTOR: None,
      URL: None,
      TAGS: None,
    }
  }
}

pub struct RFOBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RFOBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ID(&mut self, ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ID, ID);
  }
  #[inline]
  pub fn add_OB_TIME(&mut self, OB_TIME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_OB_TIME, OB_TIME);
  }
  #[inline]
  pub fn add_ID_SENSOR(&mut self, ID_SENSOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ID_SENSOR, ID_SENSOR);
  }
  #[inline]
  pub fn add_ORIG_SENSOR_ID(&mut self, ORIG_SENSOR_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ORIG_SENSOR_ID, ORIG_SENSOR_ID);
  }
  #[inline]
  pub fn add_OBS_TYPE(&mut self, OBS_TYPE: rfObsType) {
    self.fbb_.push_slot::<rfObsType>(RFO::VT_OBS_TYPE, OBS_TYPE, rfObsType::EMISSION);
  }
  #[inline]
  pub fn add_SAT_NO(&mut self, SAT_NO: u32) {
    self.fbb_.push_slot::<u32>(RFO::VT_SAT_NO, SAT_NO, 0);
  }
  #[inline]
  pub fn add_ORIG_OBJECT_ID(&mut self, ORIG_OBJECT_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ORIG_OBJECT_ID, ORIG_OBJECT_ID);
  }
  #[inline]
  pub fn add_ON_ORBIT(&mut self, ON_ORBIT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ON_ORBIT, ON_ORBIT);
  }
  #[inline]
  pub fn add_UCT(&mut self, UCT: bool) {
    self.fbb_.push_slot::<bool>(RFO::VT_UCT, UCT, false);
  }
  #[inline]
  pub fn add_TASK_ID(&mut self, TASK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TASK_ID, TASK_ID);
  }
  #[inline]
  pub fn add_TRANSACTION_ID(&mut self, TRANSACTION_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TRANSACTION_ID, TRANSACTION_ID);
  }
  #[inline]
  pub fn add_TRACK_ID(&mut self, TRACK_ID: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TRACK_ID, TRACK_ID);
  }
  #[inline]
  pub fn add_TRANSPONDER(&mut self, TRANSPONDER: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TRANSPONDER, TRANSPONDER);
  }
  #[inline]
  pub fn add_DETECTION_STATUS(&mut self, DETECTION_STATUS: rfDetectionStatus) {
    self.fbb_.push_slot::<rfDetectionStatus>(RFO::VT_DETECTION_STATUS, DETECTION_STATUS, rfDetectionStatus::DETECTED);
  }
  #[inline]
  pub fn add_AZIMUTH(&mut self, AZIMUTH: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_AZIMUTH, AZIMUTH, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_UNC(&mut self, AZIMUTH_UNC: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_AZIMUTH_UNC, AZIMUTH_UNC, 0.0);
  }
  #[inline]
  pub fn add_AZIMUTH_RATE(&mut self, AZIMUTH_RATE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_AZIMUTH_RATE, AZIMUTH_RATE, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION(&mut self, ELEVATION: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_ELEVATION, ELEVATION, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_UNC(&mut self, ELEVATION_UNC: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_ELEVATION_UNC, ELEVATION_UNC, 0.0);
  }
  #[inline]
  pub fn add_ELEVATION_RATE(&mut self, ELEVATION_RATE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_ELEVATION_RATE, ELEVATION_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE(&mut self, RANGE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RANGE, RANGE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_UNC(&mut self, RANGE_UNC: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RANGE_UNC, RANGE_UNC, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE(&mut self, RANGE_RATE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RANGE_RATE, RANGE_RATE, 0.0);
  }
  #[inline]
  pub fn add_RANGE_RATE_UNC(&mut self, RANGE_RATE_UNC: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RANGE_RATE_UNC, RANGE_RATE_UNC, 0.0);
  }
  #[inline]
  pub fn add_TRACK_RANGE(&mut self, TRACK_RANGE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_TRACK_RANGE, TRACK_RANGE, 0.0);
  }
  #[inline]
  pub fn add_SENLAT(&mut self, SENLAT: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SENLAT, SENLAT, 0.0);
  }
  #[inline]
  pub fn add_SENLON(&mut self, SENLON: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SENLON, SENLON, 0.0);
  }
  #[inline]
  pub fn add_SENALT(&mut self, SENALT: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SENALT, SENALT, 0.0);
  }
  #[inline]
  pub fn add_ELNOT(&mut self, ELNOT: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ELNOT, ELNOT);
  }
  #[inline]
  pub fn add_ANTENNA_NAME(&mut self, ANTENNA_NAME: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_ANTENNA_NAME, ANTENNA_NAME);
  }
  #[inline]
  pub fn add_COLLECTION_MODE(&mut self, COLLECTION_MODE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_COLLECTION_MODE, COLLECTION_MODE);
  }
  #[inline]
  pub fn add_FREQUENCY(&mut self, FREQUENCY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_FREQUENCY, FREQUENCY, 0.0);
  }
  #[inline]
  pub fn add_NOMINAL_FREQUENCY(&mut self, NOMINAL_FREQUENCY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOMINAL_FREQUENCY, NOMINAL_FREQUENCY, 0.0);
  }
  #[inline]
  pub fn add_START_FREQUENCY(&mut self, START_FREQUENCY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_START_FREQUENCY, START_FREQUENCY, 0.0);
  }
  #[inline]
  pub fn add_END_FREQUENCY(&mut self, END_FREQUENCY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_END_FREQUENCY, END_FREQUENCY, 0.0);
  }
  #[inline]
  pub fn add_FREQUENCY_SHIFT(&mut self, FREQUENCY_SHIFT: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_FREQUENCY_SHIFT, FREQUENCY_SHIFT, 0.0);
  }
  #[inline]
  pub fn add_BANDWIDTH(&mut self, BANDWIDTH: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_BANDWIDTH, BANDWIDTH, 0.0);
  }
  #[inline]
  pub fn add_NOMINAL_BANDWIDTH(&mut self, NOMINAL_BANDWIDTH: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOMINAL_BANDWIDTH, NOMINAL_BANDWIDTH, 0.0);
  }
  #[inline]
  pub fn add_RESOLUTION_BANDWIDTH(&mut self, RESOLUTION_BANDWIDTH: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RESOLUTION_BANDWIDTH, RESOLUTION_BANDWIDTH, 0.0);
  }
  #[inline]
  pub fn add_VIDEO_BANDWIDTH(&mut self, VIDEO_BANDWIDTH: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_VIDEO_BANDWIDTH, VIDEO_BANDWIDTH, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_CARRIER_POWER(&mut self, RELATIVE_CARRIER_POWER: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RELATIVE_CARRIER_POWER, RELATIVE_CARRIER_POWER, 0.0);
  }
  #[inline]
  pub fn add_SPECTRUM_ANALYZER_POWER(&mut self, SPECTRUM_ANALYZER_POWER: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SPECTRUM_ANALYZER_POWER, SPECTRUM_ANALYZER_POWER, 0.0);
  }
  #[inline]
  pub fn add_RELATIVE_NOISE_FLOOR(&mut self, RELATIVE_NOISE_FLOOR: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_RELATIVE_NOISE_FLOOR, RELATIVE_NOISE_FLOOR, 0.0);
  }
  #[inline]
  pub fn add_REFERENCE_LEVEL(&mut self, REFERENCE_LEVEL: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_REFERENCE_LEVEL, REFERENCE_LEVEL, 0.0);
  }
  #[inline]
  pub fn add_NOISE_PWR_DENSITY(&mut self, NOISE_PWR_DENSITY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOISE_PWR_DENSITY, NOISE_PWR_DENSITY, 0.0);
  }
  #[inline]
  pub fn add_PGRI(&mut self, PGRI: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_PGRI, PGRI, 0.0);
  }
  #[inline]
  pub fn add_EIRP(&mut self, EIRP: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_EIRP, EIRP, 0.0);
  }
  #[inline]
  pub fn add_NOMINAL_EIRP(&mut self, NOMINAL_EIRP: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOMINAL_EIRP, NOMINAL_EIRP, 0.0);
  }
  #[inline]
  pub fn add_MIN_PSD(&mut self, MIN_PSD: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_MIN_PSD, MIN_PSD, 0.0);
  }
  #[inline]
  pub fn add_MAX_PSD(&mut self, MAX_PSD: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_MAX_PSD, MAX_PSD, 0.0);
  }
  #[inline]
  pub fn add_SNR(&mut self, SNR: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SNR, SNR, 0.0);
  }
  #[inline]
  pub fn add_NOMINAL_SNR(&mut self, NOMINAL_SNR: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOMINAL_SNR, NOMINAL_SNR, 0.0);
  }
  #[inline]
  pub fn add_POWER_OVER_NOISE(&mut self, POWER_OVER_NOISE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_POWER_OVER_NOISE, POWER_OVER_NOISE, 0.0);
  }
  #[inline]
  pub fn add_NOMINAL_POWER_OVER_NOISE(&mut self, NOMINAL_POWER_OVER_NOISE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_NOMINAL_POWER_OVER_NOISE, NOMINAL_POWER_OVER_NOISE, 0.0);
  }
  #[inline]
  pub fn add_POLARITY(&mut self, POLARITY: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_POLARITY, POLARITY, 0.0);
  }
  #[inline]
  pub fn add_POLARITY_TYPE(&mut self, POLARITY_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_POLARITY_TYPE, POLARITY_TYPE);
  }
  #[inline]
  pub fn add_CHANNEL(&mut self, CHANNEL: u16) {
    self.fbb_.push_slot::<u16>(RFO::VT_CHANNEL, CHANNEL, 0);
  }
  #[inline]
  pub fn add_BAUD_RATE(&mut self, BAUD_RATE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_BAUD_RATE, BAUD_RATE, 0.0);
  }
  #[inline]
  pub fn add_SYMBOL_TO_NOISE_RATIO(&mut self, SYMBOL_TO_NOISE_RATIO: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_SYMBOL_TO_NOISE_RATIO, SYMBOL_TO_NOISE_RATIO, 0.0);
  }
  #[inline]
  pub fn add_BIT_ERROR_RATE(&mut self, BIT_ERROR_RATE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_BIT_ERROR_RATE, BIT_ERROR_RATE, 0.0);
  }
  #[inline]
  pub fn add_PEAK(&mut self, PEAK: bool) {
    self.fbb_.push_slot::<bool>(RFO::VT_PEAK, PEAK, false);
  }
  #[inline]
  pub fn add_INCOMING(&mut self, INCOMING: bool) {
    self.fbb_.push_slot::<bool>(RFO::VT_INCOMING, INCOMING, false);
  }
  #[inline]
  pub fn add_SWITCH_POINT(&mut self, SWITCH_POINT: u16) {
    self.fbb_.push_slot::<u16>(RFO::VT_SWITCH_POINT, SWITCH_POINT, 0);
  }
  #[inline]
  pub fn add_CONFIDENCE(&mut self, CONFIDENCE: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_CONFIDENCE, CONFIDENCE, 0.0);
  }
  #[inline]
  pub fn add_CARRIER_STANDARD(&mut self, CARRIER_STANDARD: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_CARRIER_STANDARD, CARRIER_STANDARD);
  }
  #[inline]
  pub fn add_MODULATION(&mut self, MODULATION: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_MODULATION, MODULATION);
  }
  #[inline]
  pub fn add_INNER_CODING_RATE(&mut self, INNER_CODING_RATE: u8) {
    self.fbb_.push_slot::<u8>(RFO::VT_INNER_CODING_RATE, INNER_CODING_RATE, 0);
  }
  #[inline]
  pub fn add_OUTER_CODING_RATE(&mut self, OUTER_CODING_RATE: u8) {
    self.fbb_.push_slot::<u8>(RFO::VT_OUTER_CODING_RATE, OUTER_CODING_RATE, 0);
  }
  #[inline]
  pub fn add_TRANSMIT_FILTER_TYPE(&mut self, TRANSMIT_FILTER_TYPE: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TRANSMIT_FILTER_TYPE, TRANSMIT_FILTER_TYPE);
  }
  #[inline]
  pub fn add_TRANSMIT_FILTER_ROLL_OFF(&mut self, TRANSMIT_FILTER_ROLL_OFF: f64) {
    self.fbb_.push_slot::<f64>(RFO::VT_TRANSMIT_FILTER_ROLL_OFF, TRANSMIT_FILTER_ROLL_OFF, 0.0);
  }
  #[inline]
  pub fn add_RAW_FILE_URI(&mut self, RAW_FILE_URI: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_RAW_FILE_URI, RAW_FILE_URI);
  }
  #[inline]
  pub fn add_DESCRIPTOR(&mut self, DESCRIPTOR: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_DESCRIPTOR, DESCRIPTOR);
  }
  #[inline]
  pub fn add_URL(&mut self, URL: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_URL, URL);
  }
  #[inline]
  pub fn add_TAGS(&mut self, TAGS: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RFO::VT_TAGS, TAGS);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RFOBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RFOBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RFO<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RFO<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RFO");
      ds.field("ID", &self.ID());
      ds.field("OB_TIME", &self.OB_TIME());
      ds.field("ID_SENSOR", &self.ID_SENSOR());
      ds.field("ORIG_SENSOR_ID", &self.ORIG_SENSOR_ID());
      ds.field("OBS_TYPE", &self.OBS_TYPE());
      ds.field("SAT_NO", &self.SAT_NO());
      ds.field("ORIG_OBJECT_ID", &self.ORIG_OBJECT_ID());
      ds.field("ON_ORBIT", &self.ON_ORBIT());
      ds.field("UCT", &self.UCT());
      ds.field("TASK_ID", &self.TASK_ID());
      ds.field("TRANSACTION_ID", &self.TRANSACTION_ID());
      ds.field("TRACK_ID", &self.TRACK_ID());
      ds.field("TRANSPONDER", &self.TRANSPONDER());
      ds.field("DETECTION_STATUS", &self.DETECTION_STATUS());
      ds.field("AZIMUTH", &self.AZIMUTH());
      ds.field("AZIMUTH_UNC", &self.AZIMUTH_UNC());
      ds.field("AZIMUTH_RATE", &self.AZIMUTH_RATE());
      ds.field("ELEVATION", &self.ELEVATION());
      ds.field("ELEVATION_UNC", &self.ELEVATION_UNC());
      ds.field("ELEVATION_RATE", &self.ELEVATION_RATE());
      ds.field("RANGE", &self.RANGE());
      ds.field("RANGE_UNC", &self.RANGE_UNC());
      ds.field("RANGE_RATE", &self.RANGE_RATE());
      ds.field("RANGE_RATE_UNC", &self.RANGE_RATE_UNC());
      ds.field("TRACK_RANGE", &self.TRACK_RANGE());
      ds.field("SENLAT", &self.SENLAT());
      ds.field("SENLON", &self.SENLON());
      ds.field("SENALT", &self.SENALT());
      ds.field("ELNOT", &self.ELNOT());
      ds.field("ANTENNA_NAME", &self.ANTENNA_NAME());
      ds.field("COLLECTION_MODE", &self.COLLECTION_MODE());
      ds.field("FREQUENCY", &self.FREQUENCY());
      ds.field("NOMINAL_FREQUENCY", &self.NOMINAL_FREQUENCY());
      ds.field("START_FREQUENCY", &self.START_FREQUENCY());
      ds.field("END_FREQUENCY", &self.END_FREQUENCY());
      ds.field("FREQUENCY_SHIFT", &self.FREQUENCY_SHIFT());
      ds.field("BANDWIDTH", &self.BANDWIDTH());
      ds.field("NOMINAL_BANDWIDTH", &self.NOMINAL_BANDWIDTH());
      ds.field("RESOLUTION_BANDWIDTH", &self.RESOLUTION_BANDWIDTH());
      ds.field("VIDEO_BANDWIDTH", &self.VIDEO_BANDWIDTH());
      ds.field("RELATIVE_CARRIER_POWER", &self.RELATIVE_CARRIER_POWER());
      ds.field("SPECTRUM_ANALYZER_POWER", &self.SPECTRUM_ANALYZER_POWER());
      ds.field("RELATIVE_NOISE_FLOOR", &self.RELATIVE_NOISE_FLOOR());
      ds.field("REFERENCE_LEVEL", &self.REFERENCE_LEVEL());
      ds.field("NOISE_PWR_DENSITY", &self.NOISE_PWR_DENSITY());
      ds.field("PGRI", &self.PGRI());
      ds.field("EIRP", &self.EIRP());
      ds.field("NOMINAL_EIRP", &self.NOMINAL_EIRP());
      ds.field("MIN_PSD", &self.MIN_PSD());
      ds.field("MAX_PSD", &self.MAX_PSD());
      ds.field("SNR", &self.SNR());
      ds.field("NOMINAL_SNR", &self.NOMINAL_SNR());
      ds.field("POWER_OVER_NOISE", &self.POWER_OVER_NOISE());
      ds.field("NOMINAL_POWER_OVER_NOISE", &self.NOMINAL_POWER_OVER_NOISE());
      ds.field("POLARITY", &self.POLARITY());
      ds.field("POLARITY_TYPE", &self.POLARITY_TYPE());
      ds.field("CHANNEL", &self.CHANNEL());
      ds.field("BAUD_RATE", &self.BAUD_RATE());
      ds.field("SYMBOL_TO_NOISE_RATIO", &self.SYMBOL_TO_NOISE_RATIO());
      ds.field("BIT_ERROR_RATE", &self.BIT_ERROR_RATE());
      ds.field("PEAK", &self.PEAK());
      ds.field("INCOMING", &self.INCOMING());
      ds.field("SWITCH_POINT", &self.SWITCH_POINT());
      ds.field("CONFIDENCE", &self.CONFIDENCE());
      ds.field("CARRIER_STANDARD", &self.CARRIER_STANDARD());
      ds.field("MODULATION", &self.MODULATION());
      ds.field("INNER_CODING_RATE", &self.INNER_CODING_RATE());
      ds.field("OUTER_CODING_RATE", &self.OUTER_CODING_RATE());
      ds.field("TRANSMIT_FILTER_TYPE", &self.TRANSMIT_FILTER_TYPE());
      ds.field("TRANSMIT_FILTER_ROLL_OFF", &self.TRANSMIT_FILTER_ROLL_OFF());
      ds.field("RAW_FILE_URI", &self.RAW_FILE_URI());
      ds.field("DESCRIPTOR", &self.DESCRIPTOR());
      ds.field("URL", &self.URL());
      ds.field("TAGS", &self.TAGS());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RFOT {
  pub ID: Option<String>,
  pub OB_TIME: Option<String>,
  pub ID_SENSOR: Option<String>,
  pub ORIG_SENSOR_ID: Option<String>,
  pub OBS_TYPE: rfObsType,
  pub SAT_NO: u32,
  pub ORIG_OBJECT_ID: Option<String>,
  pub ON_ORBIT: Option<String>,
  pub UCT: bool,
  pub TASK_ID: Option<String>,
  pub TRANSACTION_ID: Option<String>,
  pub TRACK_ID: Option<String>,
  pub TRANSPONDER: Option<String>,
  pub DETECTION_STATUS: rfDetectionStatus,
  pub AZIMUTH: f64,
  pub AZIMUTH_UNC: f64,
  pub AZIMUTH_RATE: f64,
  pub ELEVATION: f64,
  pub ELEVATION_UNC: f64,
  pub ELEVATION_RATE: f64,
  pub RANGE: f64,
  pub RANGE_UNC: f64,
  pub RANGE_RATE: f64,
  pub RANGE_RATE_UNC: f64,
  pub TRACK_RANGE: f64,
  pub SENLAT: f64,
  pub SENLON: f64,
  pub SENALT: f64,
  pub ELNOT: Option<String>,
  pub ANTENNA_NAME: Option<String>,
  pub COLLECTION_MODE: Option<String>,
  pub FREQUENCY: f64,
  pub NOMINAL_FREQUENCY: f64,
  pub START_FREQUENCY: f64,
  pub END_FREQUENCY: f64,
  pub FREQUENCY_SHIFT: f64,
  pub BANDWIDTH: f64,
  pub NOMINAL_BANDWIDTH: f64,
  pub RESOLUTION_BANDWIDTH: f64,
  pub VIDEO_BANDWIDTH: f64,
  pub RELATIVE_CARRIER_POWER: f64,
  pub SPECTRUM_ANALYZER_POWER: f64,
  pub RELATIVE_NOISE_FLOOR: f64,
  pub REFERENCE_LEVEL: f64,
  pub NOISE_PWR_DENSITY: f64,
  pub PGRI: f64,
  pub EIRP: f64,
  pub NOMINAL_EIRP: f64,
  pub MIN_PSD: f64,
  pub MAX_PSD: f64,
  pub SNR: f64,
  pub NOMINAL_SNR: f64,
  pub POWER_OVER_NOISE: f64,
  pub NOMINAL_POWER_OVER_NOISE: f64,
  pub POLARITY: f64,
  pub POLARITY_TYPE: Option<String>,
  pub CHANNEL: u16,
  pub BAUD_RATE: f64,
  pub SYMBOL_TO_NOISE_RATIO: f64,
  pub BIT_ERROR_RATE: f64,
  pub PEAK: bool,
  pub INCOMING: bool,
  pub SWITCH_POINT: u16,
  pub CONFIDENCE: f64,
  pub CARRIER_STANDARD: Option<String>,
  pub MODULATION: Option<String>,
  pub INNER_CODING_RATE: u8,
  pub OUTER_CODING_RATE: u8,
  pub TRANSMIT_FILTER_TYPE: Option<String>,
  pub TRANSMIT_FILTER_ROLL_OFF: f64,
  pub RAW_FILE_URI: Option<String>,
  pub DESCRIPTOR: Option<String>,
  pub URL: Option<String>,
  pub TAGS: Option<Vec<String>>,
}
impl Default for RFOT {
  fn default() -> Self {
    Self {
      ID: None,
      OB_TIME: None,
      ID_SENSOR: None,
      ORIG_SENSOR_ID: None,
      OBS_TYPE: rfObsType::EMISSION,
      SAT_NO: 0,
      ORIG_OBJECT_ID: None,
      ON_ORBIT: None,
      UCT: false,
      TASK_ID: None,
      TRANSACTION_ID: None,
      TRACK_ID: None,
      TRANSPONDER: None,
      DETECTION_STATUS: rfDetectionStatus::DETECTED,
      AZIMUTH: 0.0,
      AZIMUTH_UNC: 0.0,
      AZIMUTH_RATE: 0.0,
      ELEVATION: 0.0,
      ELEVATION_UNC: 0.0,
      ELEVATION_RATE: 0.0,
      RANGE: 0.0,
      RANGE_UNC: 0.0,
      RANGE_RATE: 0.0,
      RANGE_RATE_UNC: 0.0,
      TRACK_RANGE: 0.0,
      SENLAT: 0.0,
      SENLON: 0.0,
      SENALT: 0.0,
      ELNOT: None,
      ANTENNA_NAME: None,
      COLLECTION_MODE: None,
      FREQUENCY: 0.0,
      NOMINAL_FREQUENCY: 0.0,
      START_FREQUENCY: 0.0,
      END_FREQUENCY: 0.0,
      FREQUENCY_SHIFT: 0.0,
      BANDWIDTH: 0.0,
      NOMINAL_BANDWIDTH: 0.0,
      RESOLUTION_BANDWIDTH: 0.0,
      VIDEO_BANDWIDTH: 0.0,
      RELATIVE_CARRIER_POWER: 0.0,
      SPECTRUM_ANALYZER_POWER: 0.0,
      RELATIVE_NOISE_FLOOR: 0.0,
      REFERENCE_LEVEL: 0.0,
      NOISE_PWR_DENSITY: 0.0,
      PGRI: 0.0,
      EIRP: 0.0,
      NOMINAL_EIRP: 0.0,
      MIN_PSD: 0.0,
      MAX_PSD: 0.0,
      SNR: 0.0,
      NOMINAL_SNR: 0.0,
      POWER_OVER_NOISE: 0.0,
      NOMINAL_POWER_OVER_NOISE: 0.0,
      POLARITY: 0.0,
      POLARITY_TYPE: None,
      CHANNEL: 0,
      BAUD_RATE: 0.0,
      SYMBOL_TO_NOISE_RATIO: 0.0,
      BIT_ERROR_RATE: 0.0,
      PEAK: false,
      INCOMING: false,
      SWITCH_POINT: 0,
      CONFIDENCE: 0.0,
      CARRIER_STANDARD: None,
      MODULATION: None,
      INNER_CODING_RATE: 0,
      OUTER_CODING_RATE: 0,
      TRANSMIT_FILTER_TYPE: None,
      TRANSMIT_FILTER_ROLL_OFF: 0.0,
      RAW_FILE_URI: None,
      DESCRIPTOR: None,
      URL: None,
      TAGS: None,
    }
  }
}
impl RFOT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<RFO<'b>> {
    let ID = self.ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OB_TIME = self.OB_TIME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ID_SENSOR = self.ID_SENSOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ORIG_SENSOR_ID = self.ORIG_SENSOR_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let OBS_TYPE = self.OBS_TYPE;
    let SAT_NO = self.SAT_NO;
    let ORIG_OBJECT_ID = self.ORIG_OBJECT_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ON_ORBIT = self.ON_ORBIT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let UCT = self.UCT;
    let TASK_ID = self.TASK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSACTION_ID = self.TRANSACTION_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRACK_ID = self.TRACK_ID.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSPONDER = self.TRANSPONDER.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DETECTION_STATUS = self.DETECTION_STATUS;
    let AZIMUTH = self.AZIMUTH;
    let AZIMUTH_UNC = self.AZIMUTH_UNC;
    let AZIMUTH_RATE = self.AZIMUTH_RATE;
    let ELEVATION = self.ELEVATION;
    let ELEVATION_UNC = self.ELEVATION_UNC;
    let ELEVATION_RATE = self.ELEVATION_RATE;
    let RANGE = self.RANGE;
    let RANGE_UNC = self.RANGE_UNC;
    let RANGE_RATE = self.RANGE_RATE;
    let RANGE_RATE_UNC = self.RANGE_RATE_UNC;
    let TRACK_RANGE = self.TRACK_RANGE;
    let SENLAT = self.SENLAT;
    let SENLON = self.SENLON;
    let SENALT = self.SENALT;
    let ELNOT = self.ELNOT.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let ANTENNA_NAME = self.ANTENNA_NAME.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let COLLECTION_MODE = self.COLLECTION_MODE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let FREQUENCY = self.FREQUENCY;
    let NOMINAL_FREQUENCY = self.NOMINAL_FREQUENCY;
    let START_FREQUENCY = self.START_FREQUENCY;
    let END_FREQUENCY = self.END_FREQUENCY;
    let FREQUENCY_SHIFT = self.FREQUENCY_SHIFT;
    let BANDWIDTH = self.BANDWIDTH;
    let NOMINAL_BANDWIDTH = self.NOMINAL_BANDWIDTH;
    let RESOLUTION_BANDWIDTH = self.RESOLUTION_BANDWIDTH;
    let VIDEO_BANDWIDTH = self.VIDEO_BANDWIDTH;
    let RELATIVE_CARRIER_POWER = self.RELATIVE_CARRIER_POWER;
    let SPECTRUM_ANALYZER_POWER = self.SPECTRUM_ANALYZER_POWER;
    let RELATIVE_NOISE_FLOOR = self.RELATIVE_NOISE_FLOOR;
    let REFERENCE_LEVEL = self.REFERENCE_LEVEL;
    let NOISE_PWR_DENSITY = self.NOISE_PWR_DENSITY;
    let PGRI = self.PGRI;
    let EIRP = self.EIRP;
    let NOMINAL_EIRP = self.NOMINAL_EIRP;
    let MIN_PSD = self.MIN_PSD;
    let MAX_PSD = self.MAX_PSD;
    let SNR = self.SNR;
    let NOMINAL_SNR = self.NOMINAL_SNR;
    let POWER_OVER_NOISE = self.POWER_OVER_NOISE;
    let NOMINAL_POWER_OVER_NOISE = self.NOMINAL_POWER_OVER_NOISE;
    let POLARITY = self.POLARITY;
    let POLARITY_TYPE = self.POLARITY_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let CHANNEL = self.CHANNEL;
    let BAUD_RATE = self.BAUD_RATE;
    let SYMBOL_TO_NOISE_RATIO = self.SYMBOL_TO_NOISE_RATIO;
    let BIT_ERROR_RATE = self.BIT_ERROR_RATE;
    let PEAK = self.PEAK;
    let INCOMING = self.INCOMING;
    let SWITCH_POINT = self.SWITCH_POINT;
    let CONFIDENCE = self.CONFIDENCE;
    let CARRIER_STANDARD = self.CARRIER_STANDARD.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let MODULATION = self.MODULATION.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let INNER_CODING_RATE = self.INNER_CODING_RATE;
    let OUTER_CODING_RATE = self.OUTER_CODING_RATE;
    let TRANSMIT_FILTER_TYPE = self.TRANSMIT_FILTER_TYPE.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TRANSMIT_FILTER_ROLL_OFF = self.TRANSMIT_FILTER_ROLL_OFF;
    let RAW_FILE_URI = self.RAW_FILE_URI.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let DESCRIPTOR = self.DESCRIPTOR.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let URL = self.URL.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let TAGS = self.TAGS.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|s| _fbb.create_string(s)).collect();_fbb.create_vector(&w)
    });
    RFO::create(_fbb, &RFOArgs{
      ID,
      OB_TIME,
      ID_SENSOR,
      ORIG_SENSOR_ID,
      OBS_TYPE,
      SAT_NO,
      ORIG_OBJECT_ID,
      ON_ORBIT,
      UCT,
      TASK_ID,
      TRANSACTION_ID,
      TRACK_ID,
      TRANSPONDER,
      DETECTION_STATUS,
      AZIMUTH,
      AZIMUTH_UNC,
      AZIMUTH_RATE,
      ELEVATION,
      ELEVATION_UNC,
      ELEVATION_RATE,
      RANGE,
      RANGE_UNC,
      RANGE_RATE,
      RANGE_RATE_UNC,
      TRACK_RANGE,
      SENLAT,
      SENLON,
      SENALT,
      ELNOT,
      ANTENNA_NAME,
      COLLECTION_MODE,
      FREQUENCY,
      NOMINAL_FREQUENCY,
      START_FREQUENCY,
      END_FREQUENCY,
      FREQUENCY_SHIFT,
      BANDWIDTH,
      NOMINAL_BANDWIDTH,
      RESOLUTION_BANDWIDTH,
      VIDEO_BANDWIDTH,
      RELATIVE_CARRIER_POWER,
      SPECTRUM_ANALYZER_POWER,
      RELATIVE_NOISE_FLOOR,
      REFERENCE_LEVEL,
      NOISE_PWR_DENSITY,
      PGRI,
      EIRP,
      NOMINAL_EIRP,
      MIN_PSD,
      MAX_PSD,
      SNR,
      NOMINAL_SNR,
      POWER_OVER_NOISE,
      NOMINAL_POWER_OVER_NOISE,
      POLARITY,
      POLARITY_TYPE,
      CHANNEL,
      BAUD_RATE,
      SYMBOL_TO_NOISE_RATIO,
      BIT_ERROR_RATE,
      PEAK,
      INCOMING,
      SWITCH_POINT,
      CONFIDENCE,
      CARRIER_STANDARD,
      MODULATION,
      INNER_CODING_RATE,
      OUTER_CODING_RATE,
      TRANSMIT_FILTER_TYPE,
      TRANSMIT_FILTER_ROLL_OFF,
      RAW_FILE_URI,
      DESCRIPTOR,
      URL,
      TAGS,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RFO`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFO_unchecked`.
pub fn root_as_RFO(buf: &[u8]) -> Result<RFO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<RFO>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RFO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_RFO_unchecked`.
pub fn size_prefixed_root_as_RFO(buf: &[u8]) -> Result<RFO, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<RFO>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RFO` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFO_unchecked`.
pub fn root_as_RFO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<RFO<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RFO` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_RFO_unchecked`.
pub fn size_prefixed_root_as_RFO_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RFO<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<RFO<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RFO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RFO`.
pub unsafe fn root_as_RFO_unchecked(buf: &[u8]) -> RFO {
  flatbuffers::root_unchecked::<RFO>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RFO and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RFO`.
pub unsafe fn size_prefixed_root_as_RFO_unchecked(buf: &[u8]) -> RFO {
  flatbuffers::size_prefixed_root_unchecked::<RFO>(buf)
}
pub const RFO_IDENTIFIER: &str = "$RFO";

#[inline]
pub fn RFO_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFO_IDENTIFIER, false)
}

#[inline]
pub fn RFO_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, RFO_IDENTIFIER, true)
}

#[inline]
pub fn finish_RFO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<RFO<'a>>) {
  fbb.finish(root, Some(RFO_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_RFO_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<RFO<'a>>) {
  fbb.finish_size_prefixed(root, Some(RFO_IDENTIFIER));
}
